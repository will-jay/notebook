<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c795b064ae51670eb2598395d78a28f664e7e272e6843ac063557eafe0ee25de59651171d61e42ad68af48244bb8f8afd36690cb1c5a8567ada68e72a9a121e6a3f77b31f4d90f3e015b83cfa7f7d1fe4626f5ee1e85acacea94aebac25bffe0623c74f8b2180919f2dcd113cc7720205fd90be5772ce55d4e9a4d76e2c2de897c9b81aef198004f7b538f4034269176c5f6c30093424626511a9bb814e4918ad2ded9ec754329b0e5d192a86b63c2576368492ecd3f6612917cafa8c5f6cf7dc052e36b37bc8fa1075fbf61107055dc676187adfae9b4e27d1cf98e84407598aa65306dd1230ab6f18d06af049e0443b7560bb5ac321f7d97f34da8cb52d104f50c797e1876fd76fbeab2226ad11be96a2399799b4ff7808f0d7e96e719c937d76719f3a30013bddb53062888d42a4daae887f32f4e12ea1c269fcfe929496fffb0844bbeb93b14c23960fe7745612b5d2c1ff7046a1bcb1eba51bd1aaaf33c7ac004ea767663a3457871d97cddaa572216818bc77c7256c4bdfabb91e868a31b08cbde46d3e28758b227f1b96f374f0c6dbfd59df8ac6c6f23c0150ca3cdf4a4ca510e57fc5f8b5f11dcab80e1e625b0d10a844cf06d3e6ce011b7fb66eb5bcfb85d71f273fdf120a6f8af841da782c64f38ef06daddc20e761cbc3c091d8e2bd0ddf098ac4d67e2c25d4961b7d9a3fdf6cd897fcb500e59637c69d4310ff77ebfb850919e48a356b9aae567a1c5bd14f2b8498f975b7467ee6b62c57fd0ce3c8cf354aa5dca15fc6cc4872cc330645d7c9693bea7b7a3b4068d9aa032ba64b63f134426cf7b17bdf3b0b8ed0386a848265364c2015d907db2939c4ab7764fc896a4ca59fe81cc9dd57c6f880347799c886f1199da4ded15c236ce12a36def979bace19d95fd7f512be792d55105cd4c7329ffd81b29ad99f1a0d57461633bafd90486e40573a4294fac3cfeaabcdab03cf2634280eeb39670d253282fe3bbbaa73986e13a694eaa7bbdd03395f0eb5799a343e8e26396ceb0de6ef82776c8296266d232896faed02aae6ada9df1c1d19bc0ec8c08b11eac294a7ac7a185f622f7cbd5a7497865693c62ed11834393b9919fc6462c70e8e750462b22d1c66dab88582552fe2e5c1fe5e0587e790908f999492f8fb6fa45d3d60b651b3d3d54aed420f0118ce2b38ff37587b734721957c4bc4797aef323af138b3e8d46ed851e579da85cad3d2dd95af8dcd146981e40cc41ee250f55b990e0ad844ff696f94c40264dc5f5645a9bcd2877cf443709b5d2e08e2907b8367a7860b7f395ee66eb39ad63d23f72c48c5cdeb833c6e443a360544f843e6c79b2a6bec8bfee7fef8dfc57eacf59912d6bb551ef8f16ba9ce5a451ba5965a56bdfeabc6bdc6366a9c6144e54a73d3af819a11df015aa576517679fb70faed6e4bdf61f5d38edf4389c4e361b79fe6805c73e344d94c9a8cccd8ca099f76f05f84b8e74810ffd7aec14da3ac3a2bb5bc79a117ca52cb4b121f6371503fed9f2a2c690644bab5356aec8abd45afc320f4e59325e300b9c8a97375539c27a41a379e049229d980c74cf05e67a93888e00f9d1d0f62169edba41bcdc7a79349de4f713be88e1eba1899c6d6279851a3df744d9a62d8e6db413e3cc945338d681f195fe0d84b4584940f9c3eae6e60b36566d2e8f7f72aba3d01c253af1fe0d0164204bbd5069d2e3193fe39d02940c1a7fc17ae2e14c566e79e7a7ccb7fd36e004253af6ea9104b5ef9fbb57558190d54cebbec2667cfd5104a1cf5ed39b412081af713c381ed94600578f61db644cd86354950777ad807dd6358fe946f1d7baf1326b0c88ceba70fd63990319226b600c60df7570beca21a0e39298e313e4b207ba5f62c532d530d45a7a611ee6eadbd37750ea1e6ae995c56812c6adeedc897322dfaca59e59506963d9122f819059036589ae2a9d850e636993c06284efbf876c697b806b098aa1c5ca26a1486aa91fee414ff713051b10d0725ed63b2c6c3bad2b204a153f1e46f4e7c5b17d63fb7d57a8d06c3e3edbaac64fe7295eba1534dd195d90fa9cd97db56de6c842355acb0e2e78e08a3f2ace0101396a79304740cf08d09ac4ef679a3273c1d66faf3001f08961c6d49024b12996baab9ebd5693b33fe1fb905282decfe4b5296718d5d87d980314a9a7e713d83407419e555d38edd4ee756b72f9abb9169eea78980a842934027bf8ddc8f402430c3f3606677c72f5ca75e5f4771ce0298f0d9879cf0c3a67a86625160086c924cac8842c147dbaef62f0c622368f81ae445b0ff23d1c5183587d6639b3d1187fa134567907bda02379e05e2bee8c4389c9143d26ef300b6e17403dc146f178cdaf1fd60c4e058e35e8784c46911f1e6cc551b7e922a4c9a1ef4b54be8bad2fdb2adfa721faedc60311a39ebe8b569779529c39c0fb45dc6db408df51b1e04250c124b7fd82e4a3599c9d4be4ff30cdf8efa9e97dcfb7fb74368ac920d9bb79594c2ac6660caa98d3bb4f4180a01c77f8a2f8349151c56186a9cba91b79baa306c728f771ad89553af207ee50df9c9348a9cdf17dce68363569b12ac5b4a5fe4a19cf3dfd7332aec7093f30890a60f697ccae356ee9dbd4010312dceab96f13eb2595743f66e240dad1c2210d6964ea026d2435616da50f0a3e7e60bdb5bc9a14406b4e452274cd824dbcfa4a23002f92c488c07e689d30fa16b5a498fa2ecadd2bdc58bde7e282865f78d1a94a455628dd5de27d09e9ae420821306bdfd9d13d213ad1cab09406e4f40adc2d9843621dcbe8ef6580ea6bc695f82f515ff756d9fdf064d8c69c828d33bf0bd494ed8feab16121177d40ebbce924ecd36ca6e26b65d946f3c0f84ab03bcbaeb68fcece0dfe8625cf5ce93e1b0ca474769e83abcb51ac8004dd7730cf7e50c0672ee28909be17fa68d811df80ed8a8bd01954e5d43c35de657b6c104454ed90811f4cbb6e3b44c53338089ce9daab6e3e18b3925f3397f7886d0cf420fc800d805845efc9950e544fe4d416f828f643eae3a6ade38fd76cf139da64c017624ab88c1bec9baafad0e89e16319f1f29e9ad26bde4d78fe51cfa088a177e15c5f4ad14f7b2dd45e368bc2476036270e33854351aae74654e6851d4d79dfed892e3bc09586dca09ed8b8e7ab21ebfa9ad32a5292e404a90164e957f850bd5400af208ca1541438fe06fcad8fa6c689522879fe12a1934ce99fb190ea82c74e60e47a420ad471cf345bc24a4f4b91d7eafb00335929a4c71ad127ea4173328fb5ab746bfbc977b3ebab57006a1281acbace44acee94cde2905dfb7cbb5c44a58f4d6e94a3d792153ac6122a63de32ebe5071cac3f16af7d621a423a911249b4910c0ef7654ba38e494352c91269a976c232d486fc86f8f8ea5a3b876e4850e6689f8f0979bd2e327efca29c52498d7b0e6f004bb24e855428ac7a50c2370e6184aeb811241e48ee31365d646321c23d3909cd198e0d9ce41af099162e93f0f9f4bee6aaf06a5a44217e0c3d021c62a0274bfeb0488dc1634a2f3e3a3173f255e1223723a86222fe83242a43044173a392a29e3a6152a196c683e37a751ad33e4bf2040b0f918373b53714d68b830a5564d44f9c1804fcd6894830886fae0f0eed817fd3f8bcce01f966047a9abe51395801c576b3e033f691dd9c0e1d6e7f97d42822528da331bdcded9279a2b85270d9069e27952d126eba894016e60b3279df8b41696d2184a9bb59d1a29c198472d02d2fcaa458ce32536241469837ae6f7942f5df619a494ae0b484d4de78abe4e0266f49d35f07da867d7992afd06ff924fb618db7e996742e03b63b59e8e3fc1546a91e917d339b51d1a0a5325035a3e99e2693dde93dd498cb89c74121508f8ba449dc2bff4adc547be5987b5ce01c52c18de4a294883f44fcdfbc7b2a243beb92a8c38c66803e1a1d6ccd49b405503c7db9f140d118c5f20baf9a20a1e51817f776dc9d93eb99d3161ac788a8b0e2b84245b951efb13ca8528b35cf5ecceea7b5f9c0407dfe5be8e73196cc0580a54aea679d39b5c49fd257d707a731aa010191f1c39dc7a306767216ef41b64c2b3bd1404f258a23d944626139d4f0464d885c8400524489b6c0508454fe077e8b1b193d667fca563949a2e0d7d016f247f152552168d4eed479b8332f1345e89b5f01a470f16d166a7c2b1e66948dad397db65bbcc418d1ee31cf3dae1499105bfdf55dd25f50211e49b11b5415f71599e004ba40c4eb7c19a410421371f34cbe4157f44e5ae1d741fad17f26ab839b451c24e91f9c6ad158b3396d77d39371e1a74d838a26b6f3eab82ed9cc7b142e9cd4aa73b475ff9c6e3cdbd4c2ff1d299526060677ff327f514f5bfe4797eeffecb633c796654dd8832dbd0f0629fcb8a2213e8b2710d29e9a02f359d149706b7f219b683693547fe333f682235e0c00ed8df160d2d2e78bef969377299bca40ac6f48b23ca284fb75562cff925293853f385b1b065fc255892c2e557502e920aad7197ffef351255df305f4481d3425f8af88f9410a94898a0ed2171cffbdac5ce18f43006fd5563cbff3922bbfc0e87128f6e8ce8600a412973ef3ebb055e87e412f77c680ecc05632205ba5d158adba5694f22d4979a0d43c825e5c3042150b7b86a1237f7b796a21976fae97789b98935e256d32ef6dc95d74c8d11955b791178fd78f2505b45617c668b217abfb6469cf2ed149b8e75cac5e2b14f1f1486e23bb2f6ee6605bd242e7d4973f2a7e425ef3074ad03e5240ba18f1df685c88caad43e0f8edb377b69c6f1d9cc44e09847d1129571c3c5621044fe78ef9eb9141c7349d11b0deeec96c75239a45e9f8d16f096b8fe872ca6bac708ed0846ea40c5003acededbe72ad0d240401590ec90affda99c3a328f034b2425a3deedc8a156384235accb0c21248901a85bd0a482482e1177c57f8378a03ca944436d8b3427fab90afce70079f98321101f88e27fd161b0d093c502ddd0b11754bd7ef7e1eafbf1cf0058ecb1ab4011dc9b6f8e65245d0ec7c515417e22162283831b9105d2494e2024e43fd4d6a778f8d7d1123105e08ef848b643c02af36e8b492c0fd4f66a70f777729135b38545d90a6347ccecf5026c2b6a3f6d01a579c35c15302b90a9e043f57dc343c11ecd84877db449c33e7461cb5d683834c7060a17419df1fa43ea95fa285606232a89a7e6860cd765648672940121536eee5d26076ebe38cabbb2b1d3d396229420878e0592c423adda0263f5c990f047b27156bd5d3ad872dce3b3943c2e2e4dd4650aae2ffe4dd54e79b585909b64acc03f0ff0d2a9defec2a3b9ea0c454daba9666bf09023f74ab66a3dee5462858a2114308bd4fb0cf147f76351133189769cc46a0daf816407caf7e707898c8d53de791fc402186945f9969a559360c43dd114ca03f4a77efcb28915500dc2670a19723b466d9565850060a65046b91e173a08a6a083b234b3e7aaad2b34260e8f711894f13ba7677a34e28d438c32701655c9be48c997399d2d4c2c19c9526d4ea51df60f27631399745a119dfd6e260e43ac93a4ae87e4b1718d54fc33a6bceda448ba0f764b3f292dc09e194dff377a7adde731c023d5c18f1f7798968cd77709a89817e4e88506365d334efd31d290a0825f0a56ea440c3d2799b3897142c44a5cdc0672b295970d80539a96ed4df90b4a141f428cfa1b842cc7bcb135fecfc11ae12205e27468e08ced390ed2d2cbde2efcc3c1050cdcd2693ab25c17816fcbb0d5287ac1a0ee35483fbc4d475cfc9b0352cb171e2194cb8f6cbc9de84148c71715d8e043b2844ba16f641937b06160b78f9ad92172c29e23a870129e4588c5cdddbb05d39d7ef64b43cf052cc4dd03a750d0356af228ea060b56fceeefca5cf44bf328b472f8919435c133ea76bc9bdce3723710545e5603d3b4cbd5e300b1e1c2b4d46f7b34c27ebb4acde452da64be0bb8f4239731a38eea6507bf15177745df6ba9eeef51c3fb9fc1e467081812ad309990a60bea3e691a1bc078dfd3d5c243da9bde546604390cb5a3bb397e68c523e28d0d1a751aa29025a569c547787d8e9b3c7d8ad6bec7a29bd820f2df2ae811e0c14b4ffb1237d02bb1888b82eece2310c356a5f3193a811abaca328896e756f836416fb6d443d110b6295e08883126d18ff11b17db470e4153b9cfaf9955f3df0815bf3de22398843d9f78a52e77dee930268d842d8d7cf1c161d7a886f5e6f1fe310bf4f883fa7af8527567491a1f9545d96ae247fe5483716b24bbb0b3ebac06b6125c9fb2a39732a5e6e85018a7459fc4c6b75fdcdae96a5a524b16b5b4ce192d06911b413075e66699650f0c9a588f4ac64a62ea798f77766e9714ccf98dff5719d3d7e9a17f7eef9bac6f107994f15f2323ca614b5ce6294e867534edc09cddead8bbac730c07f843053d26e2515a8ee1b6e0fcc37331cc6687159b743ea6cc2cf9eadafcc49da7cd58c6f993b3a5a6195100f9cbe8c2fb624e8c92accff7f2357d918ce2c7e85259b8eb1a88355f76503b4b96400fa4d1649756d2786734e3009d306ac5158f7879d4f5561350f7e87227d61e6d2428897ad94998aa98a5582b8e134ef91e3c172205f7aa244ebc8bd3ce46923b48453740345ab5267f4a3ce5bcd9056e02a43c049af38f466bd068c1133ac9c65a0d357837b57fc8fe6f24aed6305f40bcb6f9c031da458b18ef6eb8ec11f38883e16644271004c1e6f265cd5edb2cd6d11d13ec7c530bcf6a34b857916cd2f2680d0e69ab8b5dd0e76aee8b587ccc3c98148d1317f4a5c722436ebd5e0668a03e027bbb7be1ead94332048da32cf011a584a3554d2ed9a04321e48037f15ed0fe2187b93cd2d05f5a1a2c1ee42a898dd64cdbfe5125d2e863cf399b6f31d3b48b0b45c938ffea129b76c31e972f10abd3ad5f4a5f961adab1dab6e76cff39946fb8984ee5b1722281610b3140047563c9204a9c46220f525d8a394d0711ee41493049e1ebf4c028e5b265ab0f8954c516ed5101ba46a1d0ee9bd7b9e0e9993633dbdf949358bbe1d6d3e65f9370dff022479f5fab762ad3957e3426ed8ea54bca47fe39efa95a7db574ea1670cb36efb956c52f4b0854d24d8caa1f451443ef2674526455447daafe42353e77255b04db2309a60a047f32d42e58c0ea237254fb896c4bd941bac4a6e953f63128e47562292da5a340d3f43f6191b9cf62c5b9cfb00f004866cfcee78bf522d73d607d331c37c5ec7da658f72bf8ca582e94c798889b7de54d94e2b85f072acd062f1ec7cdc5bbf8c9e8f00cabf8a9e6c7c5f7d2ce0e88a01a097238a8f09282404f09b1b0fc446cf5c2b24b5f0817eb6d5617a810984ddd7a86523721f77768ee9d457931efbd48df151b834ff949f107082231357dd3a090a1b6bda918cc88985c0016cbeffc5346f31d1c3f4ed6d17848e9e086f96c6476fc1319d20bfbe57d246da297c1fb7e2207f81f23104337bf63a405c4e5b4cc7301b1cdc3694c4cf19905a68158224be89056828e5709fbbc285a547afffa3e8a73f33a28c3f1213c17ce9cbf19bad25cc3d16827b46666e399c602b1299707af5467e5a80808584a1ddf6178b69573c3eddbbc2604a78755fd4da91f6df39d39916978b165b4ebfc5c1d65d60c5527e776846a141249638ee9150ebd65a7285f4c445d05773f8e63605405de09285c9a5676a8f400665dce66923e095a1900cf56fe84637b9b53276ad918ab926952263976bab951cf79cff2725c560c1ebfd7a9e0d67bebaed0ce386729a844634d4d0eff4e5f11838a28252dc9f820351984cf0f73f4d274a2d8b9703ef82c164933e4ec0a49010a48695221d9a6bf41769d147278d429e41290df53f428a3b75f1f6a00edc51aad1894fbf201cb7cfead7e50ec0c5ecd719b2469a267125b4c5c2a2911925fadfbd8e37e689aaf468502fbb91daa2f35f0c676860bf7634a468527d8bfbcf260c02ce4f6f077bdc2829094e9e52c01ee4970287d2aa4cc7e439c26c3a38f143b155724747479b7cbee1fe4c9d73a87ae61b5f911b4edcba5659bef8e10ef90f8d757142f41d592d6f530c24f5530abc633cae92766b6bfb4c9dbbd9196704d87e94f577f0cbdcd99ff5b562b6e250b2cd04fb8d20d4a2efd1940b8bf57fb25feea63eeeb72ff09f167d7997e44bdce18a20b047ab1be7bb7bd9f39d0a086a9feabbfa53faa92fc95d712cc8768721b2adeb17c141402feddff2bbefdbf933b661fb56af1970f5984747bc66a2993a3de8a6c58bc6e345faa29d3ade8732dc1395ead135b2746202eeeb97455f535b07e7c981be97405c7d04e0bfe10a3fa04ad1eb4146fcc70eb3fadaf1d63a346be90664a2996d7dfac571b2d4854b8d53c3e7b340531f778617d7bf5a1ce5fe86af2485647a405655d5acc4d958bc7cd3ca685783e243f1c6c43a65e43fc8eb5ab129c2bf2d5c953dc61e7dfe5fbb4081926611d045a4426fd694d601b25c2a7e2bc10ea1a32ecfd55d153f5d13372c8b713aeb59daa1b5b5e63de294da51dcabd7d31d65d44b1290874b71b4f0bb6f254544f809d944616bdfb94763f89a21a4f72e00a3a5408b4a5b80c7eab4b0151883539f9103bd8acf955c7e0a8d1f4e65a5914845b73f157fefd2f086f91a766c0157a2cee84837c93ae17f08ac9b532d9ac86ec830379756160b833260e00d003c494f1d88155f3209a411d149876b383debe842c306f195813873de8d93bc723968624864c5aaa0e83ebb229cf36c42dae73730a2f02a2be5a8b422360bc0a5a6ace9532bb8453cfa3758f6e11c1fd7feece80bea6af2acf44323b2688e4c40b5bf5cc70fe0f4e1a54e8602e8aeb56577faad05d887b79b765cf7c063dc3491a61b07d4b2a6c75f1242cd48e14e8e0688a3e0abfe09d71d213c377331fc28b7a319c19c1c2f75146963f243a6e67eaa78e3996dfb250411b61f77a0dbe5f73bf501b53c69a4719b7efc5afaf2c8b5be1a48d1e9a45cdda9347db63b263cbcbf846c988dba29fcd13b2e9325c87ebdf08f3e02cc7f2124af1bf57c8e77ad4c9991ef20ab424c05484ecd63fa2b197b1093ede4032f1f031269c9ab9dfa0dff8c3717d499f41da08b38c8f70ac49e5a9e4040346c70338eb7fa230e72177b1886a2e1abfc2831912c675711455369ba4735ffb7221df7febb711a718d2083ad92eb55613f84df98b2e998720e8b1444ee73b2c855c6e8b06f9e0d5354d4df08a5e20f36fe5a024ec4a041e81f2f2db37d3f9490926077b45e5826c3ef638eddaa52169943170e07ae669b6503997e48176710c44ba997f4cc3bcdf40b3c34648a1544e525b87062241551a128a5bc4ea189df0887a967e315b906db0ea0892d015e084568355ec8d99bdeb91371819f5b496c4561f4532d9ddfe134fb87333fb98fad78188c60913d1ed09d1c2a6ef5bb6aa874d4670d02119550cbc31bda39e35e9359e4484bc9377d8684d8f20f42897eea787d01d43005418e2686deae4a4dc6c2aa22dca137b1c2c48cb08420ec153391bb3a30b93f2d4df9cd7767d5390c6f6779786c8ae4213e1f17c26ed78d2e645c040f3423db634ea61673d86f000fc0f9ed7f13582372b6bba208113f8bc0b097dbe15a68eaa8286696d04ed56af129b4dbb52f68b759489672fac2f5b5818de33bd832eeac5c2d92958c345c89b0a48d19b95b37bd7c39c7051352da1fe3e70fb5687e58d5b5b0ca0c7c040ae725b799b1b90dd4b5711d82061479adab02f0b14c36b3e5c0774e070bdbe7a6b88e9a13a12554e4e4f507478955e2b4bc4351317bfd0aa3a7812f9486c5a25102dbcb49a643771158db9f97acb8bc71e7ba705d414351bf3ed337302b88f66b0e3da28870cfec37b271ff9379cb1f847958aaa032174a3fb21149665394d8e2dbe6f8d6299868bd250a809b1410d53416c64e858d41a52252640c60b88a633c82b0b4f993ff99cf559ccefc3e2697477e9ac2c81e488b2c5f61d465c93b26a952624d6d442d58bb476b5819ff6f20fc4f55d6c75458f9cccc06603778d212111bbe35bd06e7555ba7132383de888a68114d873e24479637679454b4b2bc4b72df57a90a4939919a9f7ed28d89d98c3816b9dcf9d6cd6bb43369ffbc053c82136718212da9a97d84d15b8a34dd9d8595c8cd20bd8afc5edcaf0d935d7b031a5db32966eccbd2aa340eb1d42bd3c8b9d518f6eb7c08c063ec67f3b8774148085e10a5d6a47659ebbcfe9a87bb216b607b8a122df2046b111ee40470d851b811e11a1d0b9f39117f79a1ee6b1b9bd71aeea46820780a0ae4f25a54c800652959d96ee6f95e0e45ccbdf87f71f9b3fb3f1f5bee08237fd8d9428174d5e6bc8cdc18010b7858783f15737d75d3e50824508740f64978d84542eddde27a6986093d0ffef7dffb92921c257174459523ea853b33e5243bfb788cb9775f300ce161992a19b303a40d3b1be84644e634fbd20ade273e7ed3179778bbfe3e1ec128ded4e0c5151cce0c7d95f90179a70fec2d6d090f1fd57a97a48986a3c0f87baa13319c1231806bea700db02e7e35ff4638dad29119187a5930ed8369e745087a766438f43c82b88b38c19a18af70587fe75ce8560fc803d0909ee8702934c2a98920577e13c27f1d4be590b862567c314690101775d2649b35712f9d8ec06aac522abee7f4fcd02cd10637c1f02b82ef4e2c363eb2237e18a0b640be05f26188d27c5359812c626a1ebc81fd6a6bf38cd15d239692feabace866067c446a0d6f341e44e03df4b4090c95d7751b2fdbf1babe61306febeaf5edbb266253964a93d344871d7a721ac08fecb72ff9dffaaf6363256d967d3bb28ce2f1b8f1dc7fce68561abf97938f064ddbee525ec73b9fba67fbdcc2b294e07ed3470ee131bff79f6ed4c07da567290b694bc5b71e963ef74f62d0b55972f830f38bf426390201a0c5912b67b19bc138f845c9cfbcffe619049dcaa1e2f6f3fee9b3250b7d3d6a845300c07b3cc0eff77e96428ef7d77cdd55d49a2729acd4f18c9f59d99443e0075730ff0a423c45917329926dd9d7fb103d71551e5900dd1a205557f462d6a23f0dc90adcd69ddee902c3bb8e6f4c7cab6f31b5916f69e0d4fe9691836622a36c448b7c31d07d2cd8da4dbf7c527cc71f7bbeb0e8db16c6362669ae0597ce3f352bd2ce5937636badaedbd6876392f02ec2a49002e283c47b318255b5c2ad010777256ce3123df9cca45d86ffca8766eafed299a062d430b908bc8f39cf76f29cbe23f4c094d3e51044c09ab074298cf0ec53b532e7488fc28f332d41fdef798b737465545a28368a3544a2eaaacecadbc3f64ed38693dd8c9bff3236a09ef30549593ffc43ac4b49db0a8b67ab8f44c517ce7fe2e9aa9a9953d43688e23a53c007739b6a213cb849dc409461577bd600229beb6e5b3ad83a7c2604cdff760c6cf0f13a570fbe9b1b97e7fb3512d335b6ac687bdd7a8dcd2082c30bca7374330b991250956523f6cf5cc9d5ec89e01d648e00abec5b01233214f750b429605a0c2e34bea32cff5a3114cf26b7de13197f97fa67f196a9772439b5644f38043fafd88c1e40c1ca7fa5501fdadbb7076c4e1d621aa824bec317a9048beacebde6aa807d9fa383192cb425fcca2e90b6ed59d9536b9db67613889babba97ffc82c6e2a8465e925cf2ba6d5885f53df27acc0ec2ebfdd533322a340a14521108592baac78107262559242610c449e846d514a288025f4fc7f12d98ef6db1e12c2030cd93665180fd79ee0435358ac2e9dfcd94fe0641ce3de720972d5290ab03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
