<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fa383afc39e1d4c7e87d088f883aeef3166ac31318dc6bf2a27bb9b3a378e0b393eb451d50c95dfe5d682c7f61c05b1afc1f576862781cbe0a18deb8231268dbe09fba621ee4d479e30365df20db0d3d7de5a480ffbc1d8204763b74a1faa08d8a9faa529044746127e37f512a270ca210cb1abf270f5c8678695b31665fdae63a08633b94bbaada76feec3d11f233f9b8c0912ec5c9679be90ce321f48480431e7e0950ce56664e0c71ff1cec48401fcd0613eb67a7444f312401ddb0cb00047eeb5482727a2ffbb6a14e833695ce654533540aa301e48e9c5374722b411ae58e0fcee1cb3aa9dd4a4add5763f542b7f5be5a1ca158789d7d0e8ad3c14c4b3054d64a5ed41dcb4232d4889fce6545d7a19a9da87541dd354b65078bad0e87390f68d153fcdfc6c39ea2f7a2dadcced84496a770d745c47b924b263ce700d3f301cfeb9c92eb48d061618e2b7614e27403520d84494e293f687b32a8a7d4d233ba8235c6319cb9acc19374003957609c4fe9958b32a094632cb0bbf7ec780a80db80e7f10459f041fc94b8b02d28e5c2b09ab3c9e30367d38e9f8aa5ba827fc8f9376c019c2ef891e525b66f050ce0a5e4bebb0326fd6b092c798a61e87904cf498c7d474c5d1f9231ac9d4824476a586190c6b5e142a04b5c320a3a3076be8a1427642b98d363b5b470fdc3dd4b2aa794ba52cd9fb8d3a2e925801e67509ce903a38cc176f08b613df46727b693c8c21f786374e5384eaa3952a1ead4f3176101f121a4ef085808a744b7e8c0eeb3a178bc4d21dbe2718dff4fe9603f563412f2cad14469db56fb97ef9739a37d92aa5e54913aa04fc0b000dd7d082ae27bbd31ff6a9b6bf910f52f04d2488a11fbea205cc93e696a8fe37883d9b356f0a83cf90f628649f44ecd1a2a935a30fbbdafda8fec7f6bb3b5affdff467253fc38169fc250b998ffd6db69e073bc3e40eb5716aad6de26a1ebbabc83793f734cc79da4eec01f636e447ef99b75c9441d5e422cc3af9ae75d5744f38e4b00cba28ec855becde17dfccf88ae507aae14435e1d49f6ba14416ffed435fad816964c2c9f3d6eac9d282489ee4de7fe57895441cc939fb883255fa0da2714262c031eb9b763ab37a78161597e7c06aba3e9d5a5ddc285081718e8398cb05f01ceb11a088ffcbaaf02d8ab088e973be6b3e46c0b4014ac6072eb366f28e355d6d072012675fb8e894df946975a80f078d8db74912e0031e4024a8a4a3c30002a1498b9e6703131eb8dd82d42b7698b1df5e9cdec5657317cea80750ab1db3c31fafdd2ab282644ede321fcf8af072e01d922b0cbffdc8da9490fbd567d589b83142a408b7eaeee9253cb05ef11a265abd9a4c198b93a4c0aa494e721d1f1eccc33c74ab33070d10ccd6da112f2635d7696401f24c51ac992b142fb73aea8f9f9e737b517d9bc72f6bff56f89ddebeb294c9b0688e98a28cabe1507ac3e119ae06705f56e4bce4a937a8da5a8acc8f9abbfe534e9be79b0c314477ef7f27060d06f546ca5cd009dd66ebbebd36658109585a84c810144f4992b361a169d48aeaaa29971870102b4efb66ea6b7db3140d952b53f4fd5c40f3a3e4467a0249b167c4f9385e2253432abb93ad9bd5002071c2d5796f6598b83e61352e194e0ef8bd66fd1c4fa108e77bda5e667329044ff778d929815b9aca7157a44bf48d9e7bd915a1e806ec2c6a3b73577a6360b81978c0ebfc64de352d12be42584c182c75515bf019698093456adf24a51209d135d90dcb956a18a98a184a2773ce81882eab1d4bda798ef378e19f997b6b9158074b35298d320244c0d73097b5b944bc1e84a599e1ba14a7466d1126b117a4364e4099e995243c8e6dc03e0d9b1ec83bc12e9f441d6176ef2dd520449d5a9beb6863ac1667637c47e69ae981e8f28e3050dce8432e41743ec6278bb4092d007996750ec8411e5949382f5f5e3f50020ff2ed7443adccb084f57c7bf93774300ebfaa2cec75b3a559f98e71293f753015ade124a8d32d3ea47499bb0d2e1db4b8c7c920f337252de3b1eedc276f981ce4be18cfa4ea841b7883b4e1328a8c890a5f872c7bb3021bb0700ccc0c5f3f9136f9285b6adbcd2355817e9f625d072687fb77b1d5b538dffe51efbf6859f1f37763e83ac94512e30280a6cbda4a080e59bc8b55e755ae071668c18647908ae24176946a5444890a3ee27f133ab8b993a6dedb8bb65dfe9235f855261713073029fddbf7ec9366ec0515b78f80428bf24b4d7ee3a4b05a5013d0a982933d760d5dbcf67c82c5cb0074a3c4264e515c4d41eb5cf971ccfcb06c61f1d2201ee30c6e8fb89f1c68eec0e6845eebd6916094cc786a26c6eade7df32b9fbcb55f786739408e1e1974196460b23aff207b897056eec53b04d8d90c2bfe7456e13ee4d9bc8f51cd22b9d7ff57c7ee37ea70d1b167847af75b106142e039fb79ebf619b27887fb529391e99014377e58d1d0c9ec8c9181694348edcb655cb3f5b708b5d32dac153aaeb17e6ed140252d39a75253fa405a5e0a854b4ab3fb9df8d67d79c5efbc1f8c5197497c3e030b7554bba02c51cad88d5cfb0740684932095dca9f206ad1052f4e07154108805b004d3bc9be3d2eb93ece0b0e6c08bad8d1a8b395acea20c32d2ea9507e14721bcce830aaf05b3f04b8c6f23b5a42d577993413ddd142af61ecef16e36972bdf63adecf635c76153273dd65a6039fa9c2b52d52177dee57ca7f6f3e1b9844ec525fb07b7ab11ec81aed1bbfc27822a28e908ed9e92e859822fcff845c0f1da963415d99cdead336aa2d83ae88f7e81dd97fc43ece9d643d4eda6004f6800cdbb7b2ce812870b8b9e3dda8cf10f3f2d070d39aac6a512111233a2f7f0065d3584178d3cf28fbb0eab6cd50bcd0306574673ea9a5ba891e7d1c46402afca24d6dd768122f8e8251dac11011948c52f8438ed29d4f7736494c06b12241b12131e27f89f927ed9c7d8335810492f40dd594c6cd74b1562d6374ab4b7ee5c1ef7b6a8d101eb2f27c586a69a71b68f5821a7c25d4d35db35187f324d9b898c4d7937725c04f8b7ada94c4c352bc53f4812b63af43b1f7752527b0c0b90ec9db028447f742db8efb7163195886de13adfbbfb10e0fd0b0ef0c56cb92a7c4db0297222181de33758d8deabb6d8d3e4bcc1daaccb57aa0caf9cc1f137dce742715e950fc53641a1a2eb43a0a0dab269cc8abcadf32c3fcdbc018879eda4ad8e7fdf979af0ff36aa6cf3f831d9798084edc54520df500e2adf214996e35db6d09640e863726fe629a77d9aae4356d059ac0d32100457cfb46f4a94393bf9b09e3aff0b778088070122abd3b0be9c8ea6b041c8d9a67b17bac223b64dc8324227550b3cf236d654b841abb55f8849749bc8de15681f60cbb01d9ae18b5e957858d4d923cad030e2d553227183bfffa122b2b448912255ba80a9826b488535a4caa13256b68259fc000012c55269f7d4bf49cd03587745bd95747d3aaf0e2a0de6086baacda228c1074b9dc7d753328d527c0999db524a6749540a78b8bd491480b28b9d3a6c06de8115e0cfd7833bcceeef2e6e2a2fdc9a134a9d92d9a5bc7eb3cdb619383b6db7ecac5956d28e1f4edde8f4779cf6024c561ab47693f5b86d411a3f174f12a5f76bf6d198786820965347fc4151012ff1be229e13b8da0cd0af921bb285e132ffccfd32a0ee1e381475edc3d7740c3e2a2393ac3befc399b4e28f60704a662be673d759ea8b69a2258479448f64f871ae39486d53c24a6d3a3b4d145deb911fa1dfe44a0e9ca76ee500ce7c415b6ecaed6839237a955d252b66526f54aba1d222112c0e03049c2f22cc57737e3caba19847bf9971d4f0ed80bf6d41bc4b934a874a13bcdf75fbc07a0ca899e73be94e45fcfef57b5a1b1cd16be0fb4fd57fb97740949da2e4620c627f631be597770afea332fb61411411ef5559b1a6b235bc30e364323f9b5640474238c41cff608a18b6f46647d9e5b4be08622f41da075a68b0614ba0a79d6c1c15ba29b8c523042ad87eb777d64ee761c00a890d0084d082592070e555a282bebfb4926833f35349e596cbddba8cd6a38801778e5a1aab25f155e36bc73021c663027b05a335ffe6140d98f5ab23ce17b9735433af2f3cbdb2828ec5dc40140667f3474ecfd7c2c767c92ccea158991760d8d88dd1f004f20e33dd9e337402bcf3a24cb2fa163335c74622b8883bf09743eb2f60ba4214b31b2a9be53de154be68a78bdf7602373e4e63002983a0f88d29147a75c69e5f424573f19b6eebada0112c9b32693452f0b994ace351754e0be9a1ade7519d214eec00f3157e9b5712e1df8e66938bd4f307021d85a9be86ef8016a12bf54480923621e5a28cb6dc7050d61ded82199f2eda0b46bf0f54a43280c7029275cea00f7900280479f8588e1c42a773ff1de41e42d82bc4541e2f1e2b4fdd20929f1645da8a3b948564c2a8e191f46d61a3df80e7bafcab1ef53c542e140776e14706b5b07907ec5fb13a3413ff0bd64fe0cae7f4a09c2e90102a66094e7bb83e01ac6fc3f5d7e20a4a71b7e060d28e2126f43f93aa13a13c5c5d696d2b736611ef1ea188ec8d1e84e2c0077ad170d3a2b53b6cf130510452fc78443a3b30ede881b6ff5005dd8c8ac2b48d59c6c61ecb5c95bf8016d82ee7c13de7c257332511574ee2b303b61ad68f55b1f37aafe8e31792644927de39702c5aecae7822b87ffa95ac79cbae206b1cbde4f45c54c33be28a3a77c34738b5f79428e69c95f25025161dea0b180d667b73ca9e48efc7e047e56abc649c60d8acc984acac44d6bd6d7d77502d6f27a098acacabcb70ca4332a27fe1ad3a3a0f050da5b08ab1d0cc2d4fabc9b8f0944662ad2710dae57fa4c3465071b4c4a4e99e936bf47cc65952d39ca3ac6603c2e27bc0d67007a07c3691f61c731f7f0cdd2563da906fff7b6eadd663b8af3f03e9dc7d8ac2e34c345e34ce1e6a07183ac1506340096f2336020420e326d6d70c3c1167fd95c1fab3a21dade7640b026a09b40184deffe2702c8690a9c27261c4ffb494f8fce96b72ce7ebdb68b81285d4d6f0333bc57c2aa433e32a39a418f3430a39976fb4e312c41a40d398ca2d5bc6309a6bf179ca3e9887f444295de2193de507cdb1c09361c3774d2515c482c95830ec16e6a2c320cd73600de35911107eafaef505056c835722854b983d30aa5b043feb92815073cb37a815db5a757ff72e51a38bbbf1506299454904571e44197871cf81327f5e748b977449d659719b13061a4ae1cbd21688d7e0f2bd869275806627ec673ae297ff2fbc78694363d9854bedaabbc6896ae901abbd9e747d5aab34c7673ade388e49b3fe715e766aa6335def970b1325bb1b984eeeae15aec321b944fb08462229db8e8d98a1b96959e92d3d4d2a7f58237d8222f97b28bfdd11d7570ae4db566cd5d881b39edf5f7a5bd931ee9e7169175c554428a59b5af589e263577c61c6b4a43966ee6bd3f98805e007d7070005d5a45263a5505767cbfd1e4ad529fc9f8fa4e1fcca981c6c956611606edd66901f2f2035ed05295e4db5a35a82539988af4f780fa85845fb53f8120b4da79eb9d4ae82660fd3bf8e9317c20eb162e1197f00d747f6c7900f54b2260e89bf3204df29c286b0334ea5e0a40fcf3dd192a01e55e55ce7f028120f19a7d35829e4021e8e7fd820db96a301cc4e5d41b4dc86f71d516723b73e0c910d94cc8a6a9d63695e9eff9c11935caff03c2b3ef7d36ee37abe0e65ac59a64fa466674c8720f68a049e3b1374fe85f9c8df0c9c9a3594d9213922148c6a607622c577e25061932d15bfbbea616291789579c5d9d10600e014ecc042d1b7673601f944926e359a956d334ce6740b5e36aa2753f7f6f48ef91447ce58647edf583654b923587c36ea1ea1261b5ad1b211ac054a016141227166f8b80bf5cca56db4badc22a6adcbacdc44f52bf4692b0e4710ef39ac21cc9ecec83a84518cbf64908cc7e953f24575eb4ecb83e9899b099c90111d0bc7406f4cfa359bc86c49eb8294927419b5be8871ae4b38cb02f56dff9434fe56e250997ee8fbb18f1bd3a7ae0035a46f255307c60c59e47f8e333fcaa26658eaf3ade5114c40639822ea8260b5bd6b3df9193b8ba0ed3d8933789d55fad875ac47573550a94970c6c3a784dfc34e5ba71c466d653a7435deefca3bfe62894e7b9f9d42f17b0fcc1c0379514ad00bdc2894a4b52738daeab4cc2171a6610bfcf9677440590fa72d3647dd0975212014dcb45bb33269712eb898872dc1e94b9382f318d8b4140760bb9ee8453106dc693b8112b970d6a712da47926ec2b87d0285e7fd9907b838a3ab04e60e690e6f6ed6552d08f64592d06a5b17a80c5e3c233bc69e7d5330396a36c1dca519d267bf271bf5108ee24d19295dc323c4e913a5dd585f3398a197f4e0f7347e3b4ef74f468de9adebb271b8f1f989077bc2cb6a10f7dee7de562253709d39e9bb585c148dac4fd26abe824303d08f21863e1be951b60959fd322cc8889edbb78d93132686a038725e76f3a0a95c10db4e76884d297d18d4d4c8eda0afde485464e7f6c405aa454dd14bcaf0d0953bbd0b061903a84481b941199506bb274f38f2c5acc58b1d46f35264c0dfe97015e5b8a19329c26a4a85c3e0d94e984e72c4ec0d43405abf79743c022f6ee14c41090a484044d30e804374dfca203a5e6fda848176a6b3169b5ea9e2298d714832651675d11064bf79a27faad4b7240ae8e365d03b57c8f8682b12e06fb51111f88b4892c33edfdd6c7169503ca27356c976235d08a4589e3a06f400ee614ca88666f697bab8403f4e9924b7a82b119a66d9f4c00634583885ed3567a4592b242874ed502b66bfdef4f098f2f825340ebbf8a605ce421ba8b37aa3a2cb3ace22a2c261641ac2172d2dc516789d95e92921a95e5e691e2d2647c0291b48450bfa60a1889305c99cbe2f3f4f773b31461b0a6749b262a6404ba743f0a330ceeea125f5f014d4ba6a22f1934dbf5ac1cc1dc7d6dc069301b2fbc8d0254ce064d969902bd2674714065338295bce284145a5ad432a787efe916314ead9b25f981e0a1579afc38bd499e131199f5f48b35a53726d2121470dde4bf092659436ae4c34219d0119b7e8275d592fab65141432e5f63f057b999e4dcb04675ef850d0220623876120d3e2b231ef9c0d964bcd5398cc34ce1b10fa49b4b9c5c8cd40b28a42d3da4e4e1e32a52a7e7544c44793a7ab3f29ac34f375fbe8160d0d90dcebc51bb6924a101af4650236023b6626e9d67519e90035e4ebd487a67d56bb9dbd89bd4dc7c71e7797ad6f4472f350cd3143f5554b58df0504141bb9be0a1ab0588220c658c3fab1f047f62d82b1f1e138dd9e66353a621736038c79a0ebf95720b545738e89dbae708ae86c8300dc10df4466b72797baefe91f1b4521afeb6cc1b07b255820159461f898698c48d854566136910d59a34838340ced75a185a0ba7eff267d5674b55d2f202ca8f5643c851c9f0681b0d8794f551188a7dd0978f1ae47b4b3be0d4b0f9037ad4e1e5861a2bd12b153b5aa9846544bf52fe13923fd0df56d03377d3e0009f4fbf1c0005aeba89d777632f300dbda6f261742fbcd3d36c8d9e00ac2ffa8e08651a8cce8a535a738059e7686e18ba874821683764fa6f32fe8ce25eaf0583a659580f069964357e77e08aaec0b8fade67a926b3fcb8807910b5e8475c9bb68975917b65d13dbab25e2fc3e5e018f7e7ae1571d2eed45c9385df1d32ab666882aa8a8992297aa43433e2f826963596fe3db2e0e755a56b5244f0898e6ec172536edacd764d462b79203a8156b1d58504abe88b5d33ab060f052eb321c7639c45c4ce0eda51c0b2a3c5a6d2bd225d27270b98740fce00b02652fa0d65231d99bd631f03386d7ab5185ae4ef44e688a91e8d661c76c92f19587ace8cb7d0f54086e96c5aba573f616d80df16d0ba7714c81b305898021d7d78fc445f628ae54bccbe71e452cfdf2780ac06af3a67a80b4d36db52c5be1b235ef86953f70a15f78eaf475492e3468eed18f4ea43ec14dc37918c7a783f7b690144b491fee4591d1ed518ec23135dfaaa3ac50aacb0b2e621fa78c8b32b65efcd30caf5784a2aef1950e0a0920ae6f433ca884d313339a0821dfabd6227155fee38d0f9cd07337376198f4773243b3ed2c6b13a3aefa37658ccfe9c9c0d51a6b23428958f63e4f9b053592e4054b2a4b0e98b5ab25307bda58099658403ec1a486996d5a67afaef4da2d0443a9c593dffe3bd1dbf1684f7139a7c01835b07568a699770d117eae5680b92b6e239d53167537d40920affee99f6d08a01fc56dd48de3253233ee6ef0b656709551a26259d62603888921147d44779c152e96b6618ee5c1aa2280fd0b7d67938041ee7f6771ae184b9abdfa401d54e42671250dbc669044c4f42f2b84e3ed8d0b9ded4e34620e075f9484ac2e17bd33d6f1958005a9bf52b062b5d6a36b65e195dfc04dc194ba1d6ed28176caae0c392c5bcf9c43d8ae84bd995bcfe76736deac15890c0e5df210fb3b89594a150233d49a0e58e4ce69404ab9c30a89c6128570f2aa27cfe250ec4455287a608000a8cee680f5e2910539119a1f00c68e67f41dc5df7fa5ff4f10ce0ecdb712090b2d3f3abec0a5176f36e4c5a60e22bf0ad00f1e1932c3e4f447b7e138beabf886deab018fa7db194177eef488a3886eb253b11c65f561b06dda3e655e257458f65650b4827cf98d186b9d18d2b5d1536c0c75c5c5b2d7dd77d263d936e81a688d7d20720e254f00e48062fc012842455f37ec2fb7dc0086a3bd6ea2f8d9af14bc733f869a5ca2b95b02d29ee9267d9715c3df4d358e043b23c391c1c30b4b82c83700509e32faaf5618f2b1b60957dd604fdde0e7bebb38483ae63a8eddc4940927e628f07f864446f85f7bb4cb94b09b3a2ce7e7e68091848e236a7eeca4700b99fdb2278f71a1a6a5a14beee77f668a164193306be239c0ed807c22f7741155146665b9ad2a579f4f48c369785549aed5a4e3bbdfa280517a56995fbe88483390f9ecaaf75c9b1ee62e0933ca86ebad0f689584779a617f802aa17090a8dd439f6f55e14cc62e1f28ac8d382136a44916731961cd42dc2235fb5bef36849bd00c04d8b73fbb44694c3b6d6d666f4c99089ecf1a55af383bcaff42289d27a382b1aca7f7397d9c82b33da7403aaadab3050d652ad4baeaad6f81a327366440787b155ae8b6fb51017703addbc368b3e662061f693b842746be11194a8741fd70df32c80b5430f695750738042abee33b8eab2bc33d81002f270f4059213f07ab01c48b847031dd3a0004832edb95101205b207e24b580062d083e183e615df842ba996a3bb4e7df776290d4fec9791ef00bcb68290f638d3941e2f99bff66b18d95ce5e3de3a8e23528b95ba7ac164c290d2d846dec7d4eafd1a93556a1c1db06c6db4c93c7072aa667f47680109b698b8de933467c6ad62b4e18799af6ee88540407de76f4d07fec3ab7558f49d920a25baef73a7160086b180545e4c4f2dd5778a01359a819dbd63819e8b256e8a45dfaafb644685a25f9ad0f585a46833921f7a5f1df35d51632d9f14b383c574908dbf8776686168297b5fb9641e4aa3a20fd7338253b49b45e7651dc6275b7d99e41993194f5bd8c7bf3c93e44c15096ee2b9f9b42b2013ade07e491b34fd98b94728914c6ffc157e9f986de05de940f6dc7ed49cbe82d47445dadecbba31ce31c07ed919c3bf715f80d88246d5310454d127fb4e2a6cd28b55ee544e9acf5f0a91f1c9ae6eae6d30f76f35c44ec22a506c3b412d8995ca198e055c656e5c91a71d52dd0e84cca0d7620058e69c826032a87be84bb859891a4f32a79dd62a69093286554e130a52e7e9dc5916031a2eeb8de1bb8fb4d09b6d1f8ab65fde5b85f698fd139d0c5940fa6aed9b9c1a762feb82cf6eeebd499bf66251537a9e6f52f28bdec7add5a99265409b3c51009c92b338f9421110efbb41a37d825fc9f1efd1c9225328388d916b4e86861b8ac05d7e90f373c0c1cc70462c02212660b0a21f49d1ffa37b77098396aff21682ce6835b6cda0c888cb5882a83876c7e7531ac2539204e7d989c82eedd6836974bb1233ffd762099f33f304adb5741676102449ed38361b4b3f7abe77951175c9d6883b15371d53dd5ba0494b49da4e3a407fe808a89ce9bf3925062031d555d426b75435031a5f17ba8e0b062fd63321a4a691055c744cf3fe08b88859da3c7290b1dc0ef07167d080c92f28d4e71c85caf439d4dc9097f6c545164e3d8ad4fbe35f0de38d0a3745cc6203b1a99cc982144d27c9d00d47ad4f7beb59718d6c5e013fe3bdfe367af6c31c7c05c8ae01adc9f6bd7f87403c6d6bfeae7c0fb1d9738451edb9d07f1f5584a9bacff1260129720382fa1722b1bc0bb0a32e18a8893dc81461a6e8c57f0ed156fd1fe6fac7ba85464d26269db70ee2b6076d86feea23cc51faf1299009e1a3098b9d90018ebdf7557a543ec312bcd65984a624e6400f87ea84899fe35f7005f6e4a4b76d56922d32784ab27aa4e01d6b68473d067058430ed18ac23bad8533dfbb4487fe488fafe5d7f02b5d216b02d53c0340b9fed5d15ffd8cb751b86d19505607495beddc85e67895be636705df5d4b903fb3208babd0e715cad4f94e4b08fb023f3e5e5478f80011e62b93d0b45037fcf92b12958b10ae9eadb36f338055290d39b61790d52976ff0513e89140de4970d1240897111ee31d42942be2971c5bff2a183fcd36da78cdac903fe17446396f7473078b1d7ee9476043ea4d0c9a8c5414c2f7ab81940aee0556ee0a11ef4d9bf5eca8b8a3e79e9228d5926dc087a3a8a9c17c64882b6b3fb40c8e76f49e2dd036373879894c5220c33726a52f481e2dd4a60794a8a7c5926ae563991248c533f8362dafb0d9cefe067d8b53bec30eed5432975ee2ed6f4ec0a6c17fd83041de817925fc1d347d5bd47a5e45ef1870af9bbee60f5ad3eda56396211a558eaa2137cd6b0392ca09d1178d2811ef1adb5f23e57ef3c491510829f985e8b326131a9cb7c0a691c4f9f399ab27b98576fa9dcfec5072f1db37f1775b643c6df03506ec38fe5b731dfb3906f981103005bdf1a527ee6a73b96ff990bde86e9c83b88b15294caa65eec033cb94e52060fdf2ed919398e0fde97a8f2d403b19911c906650c159ec439695ec39f4f44d7cdaf6996f10adb036baad509e9f0d728ee04cf265c8942c434d44e0852efbf6f8df91746c22339a8f638898dbce8ea86d0e6c58abd4c776002cb1c5746eb6de4bd95b255b2b247251edc9c44f6da29f1f392c9dae1b76c9dc2ecdb5a3c65bc0527490001c0c16670ee3757a0cc1266f345200abb74a9c61aea6a4091bb2f617e0f4f7d7f45092043bb896b5d3c06af6e9fea729540043b2c8414903591670c1828edab17672ed84f64c20872fdd62cdea520dcb25a94cbb12120476c45be18853b708957c2d628beef43ace02429651f7b5b4dff90bb44914eb0e42cb41768e21f67a0ae0c2a32255b2d716ccd2c6716976a32e663eaaadb26ec988eadb7f2a4a1ef94bb9e0ae1968fc49729d863deea3bd6c2ccaffe9523abc1961696ec6b118d8e8a8f11179550c75462f6f097a4f9b92c7cb93d31e99b5a0aed2cbc898b830ea946df5d3577a2527557c40aaa28e90ce6140680761132470a4d59c7fca2e9c5a27bd822eb3715c1cc3e816f710d938784eb4189ad2d75b1b034cdb03c8f4a1c12ac7dd4bafb2679493","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
