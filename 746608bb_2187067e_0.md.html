<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba4a00ac627bdfb6b567e71e9c5329de51b9a3796f3a33cec80b8e7df5ca748375160c20fa5f67961d04d6601a5b9d60e0b667a359b056215e6b28bba1ef04d3d2d37d1f4f6c320a2e076b4971b24cc7f47bb918f006fab3630245298ee53bfb76bd0cecec3214db4d52667a9e53b3df204a23bc9f9ff3723692ad3274f23649ab3d2d92de4218ea664c48e945939754afbbfe8d885952e8480c5c59102c6b950b473221add0b538bfee773e74da700789439613baa10948c051acb9bf74419bb0f6ce5ac34b182c74756046e554b572f6dbfc8e4e97e06160819d4eba98941174b61585b13484eb47f57fd215198a3eb117fcd4e6699cadbc8f4af4ed177953f7c3a91d5c8b5a44a2847324fbc5a5d36356c6f4e0a8925f87abce25ab03a78a3dfbdb976d389949885fb4e62b20e4b297ae2f33b2776109c72d706e3caa949f7351fb07ad3779abd3bb607d4979aef274883a7982d24b412828c18072efea587aae489514fcb2816b57b0fc467222c25226304fa0c7263bb5540c3f81ab7e8a697df299baa540b41e49e4002bd585c452569c76d60339c9a5cfdd9b575fe6f1ec340d9188df252bbda9a6019d6404a39a7baaba6aa6849e8e90411fd099bc215381663c7fcb819b9791902a58b1517f263503f0eb4788ab83d673046f6206979c73ca76458eac2d9cd1f0ec34a61f1de952eef2cf49ca7bba28e13418ab6f0fd41c0abbe190949d5d6b4c33a19f5dc4cd71d8c7bbb2cba32103d7599c934fb8cdccf68d3a6d6c281202ae8a681e3b00e9177de20b62a19869d9d64f5c1db813cb83200f62f8885cf8ad17f01e94691573ea76eed703947db95f35d461b4da7f75e7e6334421bc0daa54b6318a1a9e3fb1bb83702fda2e39367ae4fe3c64e60089e5794fd3a04bb41632e832258e88cf5e110533747825136dd3778331d802cad1d6555b46811c1dbe9f681a19413cc9f4ace6df6f56996b1eea033adeaec73092c80f07bb46a14b4477248bebb6f4fbe6f696c1f7d5f3634d19703f095e1eeef4ebdae68188247628d8a243ce0f2f0903cab36c4ebb807e78831f7c32345083086b199aea68370622f8c1c0d288e2b9673c6902371421ed93b682a78934dc751ac3a6686aad79018b40357fc33979eef1c1b82bc3f80d386d6196a0e4a41239fe0125eaecdc1895b6e3a0aad97eb7d5e2c58a423d31e4d9f798c65b234bc2ddb8207dc17d78e1f5e51a929047c10b81f1d02a9afd5552db5577219f36ea694693065b1b791842f66a8b1536c40c9e13e1738e0a368f948e7e5a466bf1fa714f8d64507c89e696237f9b45db7eeefa8f7d78ed78b348d1fbea395f471ea5c70b17171776a3b7de51c11aeea92e0e3778441aa9c91c22bf1f849d3152115419df8e68250c6143fa46bbf40491598c0064853bf1a7f9ca452db159034ff37b549fa1829a972acbd73f4530e616eeee2a7f1d5dcd4eac778bc07f1679da6c7dd17a1bb0e36fbf319a3cccf53c30f4f3eb1747118ed8a72bb31d55027143571dfb8b78e66af58484bb410a6dd6462fd126b83494ba0c5a9ba9708195785052f19266ce93181a1e221e0ba85f4fd6b63150d70768288c693a6521c4f8606063e3b84e478047b1da21f00e9abd24773573b17d0f50e2bc6193e1de7241c486d7442d3be3488fb1929079f599e945c421ee72c4248e35bad721e9dc5478efa38bc09198e41d3450b0542dbdb6915c57feaf438b8d880fc8262443a5e53f60f04c715e6bac3a5d8d5c857479c0f8aab1d8ac230b154f565c1620fd55abe57576367ab4c844abb3daf855b3488b93b39e7d3ce275b45d77a3af23652598ed647a6e01807c65ac27cd76b2369ad9fd2783e64b4f8397263c656f10755b0aef675de00d8607228bec06854eee3e384fb6f466a141646c9d2d31c7b5107569060c649c47a2910c95b04e4052b0bc99151e5d7e6242aef98de792687b069779f490537ba76f7e47f54fa42778e566ed1a2ea0d1c229dfb85b9bee40465489e69fc0f903421a8d04f9e85b9b98cf1d327f9d7590b9c7efaf9edfbaadc614791634ad785debc45b845e8f04aa6098f9247ce3c072a08bee6d269ecfff6b0d8052993476a045d67a63040a5b20ee0658f65fdfb56c6e4cdf726c1f4109b2460da113e8242b53a022bf9ac5838a43d94b7d6c5d9062840aa21af3ec8f5d0205b00b2971137f9fbad838c006fdbb69146aad496f447a479a6b2d15655f6189abdcbf8661a7b6f609ef851bd4fa869f09bcf0900b6be72dacaa1d884a0eff9b85fc14b342795bf22a7efe6a3b66c8340c3c1738e22353d5f604f3db5c332fe0a6f947c0025ae8185555238805f7f3153c7217942a6416b191c98ea561dfb40be445e12c79bc0266f90e9786e2a976147aa41612488f5a7226e2ee2879c2442c2b3a5911a7156917390cfc3c8ab6e551d7bd4cf07abad60860519fc39d3e5dc16d887f4754a1a2eb689b844d827f26c5a0638ab01013b667b6ad5ebdf206b68b28c0af7d0a1f93f84ad59310d24067bb24223e6730bfbfb5a29c2e5f49da9b816f128db1cd329c0751d24aa6b8142a69911db50fccfa2036a92d8688aee4b2d69f5ba5aa4132d71471195f7756e4cb76f7bf8d2150caf8c633ff755c81a27d02d3375ba2c16fc40ba50a4448b15a67ff4d88b1fa8b2965bdb5f6961df3d2fbf664c1038699030e3391176412587e17f4f222efda271bae7789018df4b329c1f3aa33ce4314545a2c053a29487f08d43e4fa832fe8348a1ce6bbb8a5cbff18ca94ff8205caf938250f4b01cc6bcb8a467e8ac1e93686d4771937f35bfb0e122f4046bfb0c342551bd162ac406ddc01901b245142767127697f49181ecc51acffe4e3ee8f18d465d8fac6fa7451d47bef50287d2a5c7b776003754644fd8281c765d5d2322a3e9f2179c3e5e58f0e00971982f46723d0c8dbb95c0b3d99f71f25c51ac0fe05abf4de11bc76c93b4e726af08270d6a4e7fb8b1e99db92df31ad54669aa77ec6f0c027e4b6f7251c915d9ae74165ba13b54624f528be2da77ed140f94ec96306292e6482f0133ef936875c445ab9dbb5125437ddd7e8d134ac28f1deb1f42dd50689ee666f44b02e8272ab5c25724e3e08b71e0350b13b57347dc3d144b159ff6e3e93124c87874c516ff20575fc627a247d5c909323057327c49fe073406c33af37dbf0b81620b8aba3ae28d291547c3033a9a6fce36f695dfff5278104d52da988576e2b0d32be927aaf3ba8d9f44b1df7bf5535729bacbd329fd61731fc82ea2c3390752c36aec22eb5badf6414aeb9635042ad02d5b75737e7e6043cb17e331d96be9f93f6fbbf6c16b1932655a488939d987dda98e86f472608637e67fb10d2d05a62b592ea1e248f9e6b92a2260c5cc882de382e98ffb7850fb114f29caa8ea2c8b7acf2eb11d3b9e78598f4eca951699a65772026116d53ae3171a4fae45290812de2652aad959f23bdcb436e5d68041aa5edb14fedad9351c28cf55fa242d4307edf419e73db6cd4f07d302f7d241f548ad343c11abab65064b508dbe0513c7d68a382026599eef2d51143e3d6ff75a724fdc5ff3f1de7b1c16ea177d50644701f2d3f91241dbe0e0f66ae6c78915ce1001db4947224ddd19aa6a9541df8ab4f941685c8452f10f6dd3c85c7686e177d9575a5b43be01042fc71c2bff9faab571696595b36d8be9c1b36a19008fcb283717d9a91a711767d5d69d0a8489f542e8d449791f0cd660aa16cc627b5b8eb17c42f7170c1ff14ca76a0f11e027274286a105abfb57f05e7a9aebef3b9c06ea30f52124d4afcaad3c3867c9a9fc14d8a975c5856f3a9c6541d2fbdcbeac7820cc8a28e17bb77e1ec8d7f93499a9dcffc4ea9dad48f3d0626151c1132ebd5ea041afa112609609f9b06ad1048fcfaa224110da1375abf17187a0916e5b6904ac7640062109508835de7ea108c47d80e51ea866121cc9f31acf92f4788922fb09f1c49076137673bcb4eb86543531df1cd5b253824fdf4cc2f15bfbebd5ba066f699f5dc06f0a645551c9f9acaf32d0ba715aeb5965d8272befe707fe921d2075b1a3de8b17d47cfb2e1646bdbd4ec02c83aade6d2e557d66a7f7346246a883cf57167c75c7be2a949e80f761bc3eb69de0d8a72ee48a6ec28f010da435a06c2b3ead32019dee437498393b647bcc44476e8eab690fe536346ab6ef6112090250daee88f12ca43c35ce0beab0c034f7f4fa7bb906d83ff44843031b5aefe12c5794e12e6fe241d890cf6dd01b4e24496d8fbde9c2743e66ecd7940964e49122c06afc7477adfb44b5ff677079c0f8a7d6e2f01fd3947da494f57bb2c79e0dc68f7af4deb1e67e3d4d1f39a73f62f95e4de376711316e01e03f75dbb11ced918a11a97ca6c9c71f752e22179b04d4b8711e7474283d501d10cc0b39e8b21828568742b06f573a246d5c3a2a4992780d17d61cd3fbb7e8e884381eb1048335b1bf4fafc22bb43455e2923a98786e84732579a96d5fae85f8d8b7ee6cd7c522f5f224332a7167337b8e53d54567b3523d8031db513d5ddbafac2df5352c4d341736a644c4900ecc2e46e96b6e938f21ba16f57c9bdaa5a3c426f33764dccc4c632603b833afc45263ed1a0b8f7886c938c2c2b9cd337165aa0e535612dc3e4d90fae69a9078eae7eba118fea10c32902cadc64a62a91e17654773dfaea31a78b01f9b283ddc986cd042bbb2944acfdb51dc722c9200014129d0a979155bf072a5f1afb1d836ea57d31a4940b3821de9155be11bae945992507c08c0c9d249fdd99aff8cfd8906bc524b197b02f5544d69fe7e41b2161354b46e6e3fdba45c45dc87469132813bb895136dc829256bc7d2e7e07d97f27f479919f6c05400c8f3e77d76155100a094e2aa189120f44548e2f06089e01cb6141b5914cb6bf9e0aa184919346a1006fd3b23d8c8db58abdcfdb675a688791c6fb5a05385907dc2991ab2209fbb16dd0471dee6975b7634b21b63f9c60bb8015d52d7cebc7b2ade4bc1df804a20b03b2d75de0f4a1b4b06f43169eedafee1f14644a34c49fe0f2372a7f142fccc90fbeb31029432f17c1b77448cc3e8f614c79c6d0fbca27f5518312e8ed7129168ba8046f81709b1213cce47a08b788af63f85461f35d36804c12a9543cf4dd5a917bc3c18d33f35bf90b0da48d173cbf0e59d23a960e4afc0b5511ede376cda9c19f4fdcc0ae9f37fdfbef4bac34836b0901d9571ed66d6719d9528d7d824fa14725df93cb76f4e067e27137a53004fd0eb9e36604f2efa6624683e944d341ffcd3104ffdbd54dcbbc26259d96a4783585f45d46ecda77dca396e5ff1f61aef370ce26d36cb7499361e9459b6d54cd393d1d6c324928bcb1cec50023105aba0ec6e64fb588e325c1b1c0d6e4d6afce44f719ce820df10700ad67d99f34c3930db52798f75f5ebafbde712a10fdf8b487eab493b8b572da407980476a3f32c609d2c0743b501d888d8240d857640da26cbd487c4e2d66b7113bd2e78fb394e9b9ff166ca3dc1d9f79c14e73367654bbc5896122cf3f27fcb579d3150ec0d05d153a5b9dab9153fcbaa96b78f3299a6cea9858d36a7a4608cb29eed419c1cc54c3faf0319bcd37dd630d1c45e02e12b586e72bd90ae5fa12743f89cc4ea5559abdeae8093ccd3a9c36b57eb28477c6d1487ae3205a3aaee9fd9736da079985f5d17da7d27aea51e35f33fd9d9aab48227c43f3b9baeaf971eff6943ffbf5b8cdc4e2ab7460ef24d9941b14946ec75e005d75723a1e468f9365a55e4dfa614a8e2ef11e0b37b8134f8fd07b3cba89562c0d82aba285dd318b49e6c1663d5b802639ea58ee351a6baba1d7608f7e6cbdcbf082acd880840cae1aeaa270389831d2ba7833c3535b70176cefe96af4c907698297d9e5b503792e12192c4a6ec46741f55051d2ea871e4dc4d67f678f6e43d8a5d4121f88d2947c32c453654d7c5f70bdfe3b7794e8692da8ac114d591f2c6447638e1811f7f21ecdc7d6f2aaad7dbcca24b913f14e0895719fdab66d411dad03692936f5412601228b43618d3c9d56699dcebbb00c5b39092f3af5d5103d3aa3eb84a87d90208df754b379c41b5394d1e3f23237adffcc14bf8919bd8daafd8c15a80bc3caf17890b3c23d631e152d7d2e36f24723204fab68d12be6f8c24390a785512c9b832a003a3026c15ecebf4660366ee079429e1bb348d21c2e32edbf98bd89884a0edaad6eaf84f62a6feb020f07aa07596481837ca4031820c6a181dbd1cc063095bb984f089b90fbde449b0a35cc10e3b5920f7f3ce25c5dd7f9c16c03d95de128da446c69b273e2f0f983d097fd772914abed634b1628a8d5c3a4dc491a169a42b5293490891b7b2fb3c58cd731426fb69efa8d44a2f7fe16f2c6aaa3ef3a31f7c0cf7e7bb1e042cb3a36625eb44b18f2887865eddea9bb7023e3a78a8cecefe35dadc3368374c8530118c5d5901bc4ddbe84e5fe0196894c923b763df644f521f5445fd5c89dfd4a989d0bdc82f061560d52fdde0a5cbba226c2358f0ae24bba85e92c6616aa026069f6972c71e45ae40cd7af866ca305c97379d2b048c3dd4abd71c756bf1e0384ea679f30395388f9752c3323a77c2dbe8ba4bde14d8c4b758e6927b1ffd0e79f6d0cf8e0b5d330fc476453f2d5d304455df3dc2826acb1baca6200cf686faa151c2a4b49530fab7413c9ce564e4e18dabb746eccf81f65655f21881404c7ab1fd384e0cda8e920da7938399d5f852f815aaae5d41770fd2953345dc66f9e446c1204d5dc6d60114c2ae5964de64fa3ea5eedaf8ef62a49875fc32b382b4f2aa585707dacb7f60667049b5f89b2522995d0a9b0c6e9af25840ed8e8aa10f58e2965d620d9c6ade94413f1b1e04e4bf08c5f830338c9308fd59600ac07ef0d7629951e48d39436596b5da42b5abb6fb731898d48ccf30f7193f13143d610f76ac5e5ade1c3b02e7d2b95e67eb6238d277075ee21818c2446d89b2c71e8fa93173cc3dad01bdad33658f899707c8d17e07d08097052c99b8c40e3af073816996c2bab308c96f4bc2326d026803c541e0dcc3dabc02a9f113e62dca789a90bde0d29a10683c65828a9f2b3e1ee69aa0d5397a4f4e5dfc7efcc7c4e2c02d6e569e7c75eaed168cfb35cd7f0c5b3bae523094082ed2e69433618af2bb2133d479014ec755f93bd148d5f231e9ef4d1b8cd2bd009a01c1775e9ac0d9ee7255d5f6f9253917da9f97d144f490d76067310adcd45db883d1703d0dcca0ec914420a9bfd8cab6f056f9104256c0e9290e232011cb1abfcf909252f7aee76d667a55afa01e481099a16f7e060dc04e40e375185b6575f5213fe4834fdf712abd85f717fb9f1f61f284b36aba372f0525dc06c9214b38235cbdf14946b28029732cdd66d343fdf30ea8504a2da6ea7ed4a36326b671da0e67bc4a0bb3190b4e8686dffb2b2adb518268adfab173255367a0459130f3f55cbc1373965d379e8425bfbc849076fd2f2267e07a0b20fd301551c5e3cc5fb9fc9fbb5e4d9414b8be4b91f460e78fd50cef9b356114010b14dca4635daeeebfe7b160efed423bdc078efab40d8a2970e9440bf253c1572fe8b49c17873a72a34a2a61a2d80783a8936961189e676912825a5e18a1b9fa6afdebb4e867de1b06bbb2e0fc150605a52b0584b99a5e1985f21570c274d84acce09b1357e0dabd554624fffb5987450c6e4f952e655a3be7016cc293ec8cd6e528646c9c378964bd6fde12c6f2338c5851f6e437f8031682071ca646644517842bf030b48a903288f5cb8ea583d2e1059febe665d6a818907b66f05b5caf020516e173b2e9e801bfd1fecc8d5d882c42f7b127bad900e13598af372ca85ed8f41495daad0ca6486ad6f359221a4067257df214973c9cadd551db2c3f0952404927fdb58d9c962192d7f49f5926bdbdbd95a6a3c27e847a9dba1dd22ccf00f475fe420d796e9f2453906a4dd845f9c1c0fe008a6cc4e3191168d7c3ba8577dfebc3572fccd18ec9f667be25ea39cf9374e9475e430d854b6d0337a1c5b16e9dd685cb95816f851e2b5ae115ba3d0a7dd10dd5a539827e3e2b77bd801e5da7daaec602a9e52ef932bdeafa4af13063ec833d89fc9e4bdbf6e5ddec2a810c58cc3e279d91119d0ae98388a555963f3b743d3ef40b1f6dee5966fa5339dc59151188999039cdb9c01d47fd93bac06c104c1ca68749b045d2a7098085dbd622185cb00800149fdbca9413b4567e7a2b57baba3e2ffd9b5dc2bc37f26920105f3b7c802b644ad72ac1f3e6ee960964b4881f470abfea6d7607b51d7304bece0b197dc693b1b90b9a6fc05087d0720dade6cacf68e149c6e96dbb8834ce08f4c493c772fbfa42eb1bd0be1bc8bde945706662462c42e57be0895a8970685bfb67cf6aca2fc6f9ac2ec62680a5c23326f6030924bd5a3943830ea06647503e8da77522a1a27883721f9d554eefe81e08a148514b77d553a18de0ede35ca19eb63c0cd8b262328ee7297669c76ae8c7e2249517135ee61698bb4ed1bd5e161761aa3b2bf63d8759054f2db28a559a447327402df4f684d830b8e0b5907f47f675035c5fd6060ef5932c4cf1db0e5ff585faf4833fc2cc7622d9003ab6f3779401c2465b45747410a48aedb66814e2b679fe33bebcdfd51788a0db037f730abb49649855a7e4c77110fab73b7cdd6338191a3b4d73e5cc7a48e94686d55feef756c550f9505fce1a12df8f2031506a77c43e891a504b8dbe4457679239489ceff9ca21acca5bd1f5ee435d7cfa13c42eb48021b1222d4a0e278329607899aadec78ab2254056a0402b6daa95c914b6373242d5f33d660fa594de229c6a2c7c625688d44cbfd582cfea899ff1411d96839404b3287503113f6535adcef918ee6992c9d7f1a5421970e503b5ec073a5c74e3d983d27f35409926a5b7602eca995136cc4238b8af7b8f298ab428a06f3465b347e2705dd2ed3d7b01569448d1997b18b73f4c6a6eedc70983bd1525612500e54349bb91d8295342215054ac526bb47101dee3a83cbc645e6ab0b0728d91ced4fb93f2718275fcfac62a404861c8af092e6f96987bc7d587de22bf616e516f4eb6b19287105957b0303f8d686b89d129319a368b64683f6d392f0235e15557a5ddb922b45b0a3ca0192a0ed6f10b428577af2d2340c7b31fe90c36037b25fe9ad46f87f84336ac7c59f8f624f4f7008679d18965070225d91994deb8e5786d803bd2d8e0c0bd37ce1cb57c08dad06754906f9055f4eba5c9390e3543446366a8b547de4bfb279c60c3a6663fee4292114935851283cb722630378aa29b11ac932041ee1eede71e1b22d400b962663a6f95b147d1077be64755f9cf7af42e128aef5ba61bd1a0150f187dd2aaa15eefed633724edbeef7b3397342248d858618e6126d636e1ecbcec726cf9a80450aecf4ac23aa868d65b7c816d19c2ecc31968fa632af908ae59e85db9958d09e8320d670414723386528418236f22b728834865b0fb8db72e35efc0ce82baedc93d9bc6d41664b672f5cfe0cf0179c9e0a0141d34cae66b8d8b2bc66698e07ca2a436ce331f574dfe4bb1dc19be0b195a2ce63329704c0dab480fdb1c6e71e1cfb78cbef0497ac686ddcf3d3e08504f036788a9269aaff8fa6974a0179e2e09348ac63ab33b2f52f09df566c19bd491938f7803ec6a0a1b368797c92a96dd7b5befc97ddffc3ab2c1d31be1993f891029e630d37391289f0e10ab2d5bea1d41c45822a7116339e34dd77861f05d612704fc7e6acfedcb1960ef5a0919bdf101e47770100fc391f3ea31ad0f661a133b9306f0c4437fc68fa565a6874bf0aa2aabe5c7555e99a7caf39e1eaf3e10826925807f0577c5d372d2c796a1154a576c57539f24b1023f49b9b5110db29118afaee5ecf5ed8162c76b069c6c3ca9e67e3b343f99d8621aa55bb35b477198db462f9c027e1dd5ecdad7002101a44a03e507b49eb243e6eecc7bb0d250a972b261e63d5c4351071193f4cdc6aec054309abd539418207e292db11d80214c0e9549ccd1d508a76c7356771430be8cb6ff879dcccb2a0e037c84c09e728e353a9d91c10ef6020ba92077f28df2f2c3db2e2211f3b49b667ab98783e44f1dd68c7b40fb7c9363157b3f4e1a8d5d1b6db0b3353f6b45d5e25ed6700d7a8d7d482235277fd750013e7ead487bf837c8c072e6054ad5882f7cff298590e59c3e62f24fce886addf87a71e798241ea1e48ca8c6cc99d0d1711259ca64144d72ae3c7a44f54db4a52ac35535d041edd11d83b3ac21ed1170ab64093ee80e7febd6081547ea3038da12d526e0cdf2d3f5089d17b870c6495fb24d98a6f0c0ef3725bf2f8cc7f6a34e94b13f4d640cf86a9d2eec77cb8b22cc590a2fff951faa43d117b2b549091f0722d319366a6a43f7f8215153d0b5eeb53ac648f0cab946441520610cdc5dde39d6d4f5c6ca4e1ef59ba6778d36f946eee826ceeab6ceecc94c3ebda6985cde471aab3b53426bfc8bb989f18a5f61d6ef5e85d62c5e5e5a640abc1ca9c2cec4572896ab6eb4eec14fd2c404e7881f229a9ada44d218c8a677f4eab3e7995915cdf57ce2150b890632f04ae7559f798d52619e97a57e22ff1ec948ebf34369b981edc3f91e1c8112a9b080ff31bdff150e90287daa878d01219cc581f7b78bad59987b27e17c354ac966e2c5febee49b96c20c7fc054cb27e2a4060f5e84940917aefe8ea21ca0429ce599778567daa69543ef367be058e43bfa5737f8efd179e60948414262e51b2b1f838a56deaa434b14bc3d47740604e47d987386d325ab200b654a7912e3cc006475ee93d75d03614186e5c6cc25082308adc40dbf3883bfba23d4c553ccf4aefdf790b018d0589545df66a2dec6bf9b2e8ebe470359e0bf8b1fce9235569895553294210016f651801c902f38288cb0ecbb4e9224fdc48bd046459c9b1f3c83b93dd69048edacb3208b23337ff1dfb7ad78230ddefee9f460247855f4cfb168537a2e5624b13eb7451544f15761c81e05e9383d13dd4ec087d6238e3565b3b4d469c14d3f9e78103e7c2aeb6f0212a7c5cc0ae89d83c2a7cf62def5851a3f696938c235460ae770c0f3d7ff5ce3d8822045dbd1d4acdecb57b508aef64ee9b0ea8ac72f677be2a0de7826bb0d7007476787f4e811e139824d30646f14bd700923e4de615b709aba44a7f97f4250e9e0103bb7237f7e02af1a2cb059aee834fb2ca31e6293495c0407e922c7f88e2313611b32b7fb48320bc4c3ea101f953fe0df6f8c7492691bc72a2fe4fef44280844afea3f2c257898bb6174d617d0b0bc7a7d970154b68a3c3080d52470fa4f15d46428ce1f1616cc5a12e512e0af2cfeac21e93423ec84c7835e8718ce0fc6001237450260c92aac114052be06add0982630e5d1a8277d2535febe858e24b8cbda464fb149a5c8a1d9a8c300d820fa4d0d7122b691490edbda60e37144c0aa3c6e077cbe90ab2cddf58e327c724d97e8a3cdb3caa81a370d74e4a7a96a176b5b6c1ca61f7271f9999d718d7d19c46d49633db6aaac5741f64f64f6ce198b407dfec7df09ce4c3936b5adb6f7a7b64511cc3f6378fdc25ec3afc1caa6a9463383debca2e5a9939e2a1f551af3b9ce1ecc6933b1d926f7dab91580600ead68a20754346ba57edc97f86bb09010cce7f11af2be410af487a782ed9ebbc721f94ea6485dc902859b33d214b2cabd89fb2eb8553427c5c4023cf1ff8a94ee922ff411efe4731dbcbca1748366b840987d178e24e789adbfa0b6fe00546a2df1fc39dd5f61ef4f44","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
