<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bc4967ee4856b0e2e2c431b4144ec74f871b16a13c07518abdc11ebbd0148399965607a0a3ffff60ace5f5291c8c9442f1897f747c2bd9f1ad040da42273ee18ea558650da20197db1c5680ecedb21e37b5f148f23e8a8083f3e8895791fa8b1a6c843b8000d03b8b086f290b40854048139c8fd0573037762faf7727b0fe92bc6e50361655d7a09c8073cacb034a1f94d8b1f9d1cc158bac37800e95322c2b139d72806b4930b2c50a856661ac727e39eb839effa701acf4f5020b091d87bde41be05ef1e9659760aadd9cdc7ef21c6192f5dc1b13a40f6399e80ec4bb1ce2c2f1b8c5637c38e4de92e078508c5eddadd9dad541c6f176379c977917661e5264c9a9c973a7db5503c4a8832e2906c43dccd70bd8fbd2c99745b63bc104887d77786e75c02d0ba7dd1047c72ba32f85bd4f34112d2de20f54766101a237dfff165808e277a6b4512564be3d925bdcb263b5d79fb72297337f9bdf2af0d97693a0c5201baa664f7e628193fa850df64e75bcd08ea3dd10b31b936ee39ea3cc5c55e012f814ecd599d625236b581f66d9a8e59dd456a8934c4ddb9ae9ba8b7172fe114a995cfd81da0e7c9e29c76ab6f8fc6ed54c9ef6652c8375e9714617189a46ef47f85b693ffc333ebc357998ca56c682dfc2d1581c21f5462c4a9d5787e7acfaa9f19927ab8d70226648c01d1e0315f5d6a5712d577ef50a2e5019114ce7e76d3af182837d8a8c5a9fed80abf30c52e2b8d476f962f691f59b3594014f967762a8276f3da974f556e510a10d3a8a307e4eabe808209d8c2816f28fb8336e8c4e299679933a12ee9d67e84e90844d6c1c4f0ac1fcfa2ee6088541d73c588eeab85a430638aca6236cc1c645e31ac2f487d910a597094b3332f890ba41930d02ba51f8af232018693b53aa1e74fd25a53e69bc2c9632fe32fc4697ab6fa80ae2e4c208417382e8b8ecb2d1b0c0a2ca430d853bd0a27f902dfe8434c99b3663407001d5ee63b0a29b71300ba6d6c6a955366fdbc15af0ccd61e6d21c753c7723c64836eaa2a6b80bc55da5e5cfbcfcd0c022c5de047f7c85e33b83d91283e91206ebc9123517bcdbe269a5e5e89f8257dca86c0d6ea91c3bc601383bdc906d298d5617f952fd21beccc179a8faf7c54bab953a4b6e695b7994ac501855cacf04fba24e8da3aaa252fa7b49a8efdabc09fb3a3633d2f9e5ee15c377bda8e7133437a184e7df1b32664d57610f24284794b880b968972b2f18da2481ca5ec35c787cdb2f91ce2433652eb540432a8fb79cd345df96eb20d20bc1813d46eadd489612217c2338c82a0955499d54961f31689898805934dc0c44cd2dff499f669bb956c8482cf6b593d9c78441e02e289db95f038f5bfc0c4010f1b503fb525c71209df8d989f4a2dd86ac48d1ab2916d92076a074d00affcfd38b5ad4063575cb606a8fa0d63e8d798747691003dada93c64ed8ac55af932ca03f2d7ee4f34edf3e38bcd777ee1c41a5c29efe973595b1671cd4d8b2a0ea4bbbe9bbadd5468efc2309612228b4694a945fba09fa84e761e4ba3bb668abbbf33e6b9537f07b09bdcea5ac7aa149def1691403c47f8e98ea32aa2aedbe9d8132f0d812fbdc32e1414a0e535b9a50035d51e06dbc66c9bf0fbbd97e61447f89824e68d7c8872b168df0c1a7f47cd4d7381d17a897f22ffb906be3850b6bc50d410edeefb4ceec3170ab46c0186122cee7198fd90ca9e9f63fad6fe9b9d0547038135188d179d7ccc3e0016d08b6e825f958541f38567b8889be1db2d0266498979f95403c3790293002604254095060582346cdbfefeb36887dab5b536c58e6d3e6395bea3a6a806ba312e2aee9cfacb7d04e85fbb45d9d90a76fdaac0c146ff71d522bd5e9a5e054aadaef9991ec16135b7d8a763ebaf3574d5a413eec98cfb631fa44ecb1c81686e6410e69646f26528e560120f0d5437aff39acf3c035748ba9b6a5bd6e0cefe3e5d29bed72a624b3a8eb7e24f7453040fbc11745b1e058a288a2ed8329c935deedb9b400f0921ff9fedddd2d9e66ee5be760ece6ed775756f6b9c7ea6eb992337c4f40ceb1ff15e10c70f15751e897e56eed86a36718d419242ee90604a21a7cf058e900064ab61d433d5b39ce269c130453fa3fff5e9c0497c4fe732816644beee5f0cf11215704887c0565ad46af0fe8e80d9d01bc2fdb02c1f2095b0609e3d7030dae1a4ccdda37b6de6de2f43948aa7ec619df7d9d976b9428a0a77468c25c1b722017ece266271951dace0d7d7c7249ae683a0296108dcf36a29b432bdfaee69534d914d966f4a8efc2a97f8321a6fac3d73d71c937b8ac4e1a7036915e5aff11a7a02780306658fd127a19573f2343fc6fd72ab1020b68bc37253db022567691113617f7ec3c2bc3569571ad905d7925d37068196e7d3ef49037524160d331127afb4a18226d4ca37305080b7846489a418fd9abb536b7b6b1ed4fafa54998775b99283be171fb8e1a0c4eb8548511f8d92b27d3b013c65bf0044d2fb0847b0a3c6eaad9767ccbb162255bb0d143cbbffaefe37f927c039de3e497a2cd88bbd5e2f9dd047b61b68ea42c28b9d4299a604742675fc4866789280bc3de83a43c8050d38fce34e9e32aa9df91831e7ddec84272922dcb0065ef612c025548371b5171ad395b6b45d248ba31db548445fe8f73918663e7a93090266d1735baf590158609ee3c45f463b40168d1d76c2d5738fd67dd3d867e0bd0d73d943c7ef2b8772fd886fecf7183c2ed720508c3ea280ba13c760b8c9821a676fc3ee96c2b19c7e5599fdcce32e83e1204a3d6c3e6c10f7e68d1593b2e8b13b345d2e8db3edad8788606330bd2984597b7564148214340539153722181b667c7df58d885b3f354b6a9ca589e75daf119caee90bc9d21bedab0b4bb5c785e8804bb2fb33cedac72dbbb2ee811e417cc515df130aad6b075784841cf0bd1bf616c83e71d633ab6cdecd2cc8488b1e6c282b809be902c9ef26193b5d1de1bbce59587559639101dde8a6c0413c4cd2dac68df3d9f8900d3bd7d3b886b24e399c93cf0c7bb404b579ffc6f72ac7a3ee51a3f0416726dbc8ff443efc05c046a05232422bcfc7528bbdc5d6f112212efeb025d849e80b178370e5b6bd4f8c1e8bb37267d743d08d9b53511dadd6adb58304eab93a8b5cf46830154de425fe23519c2f4df6a27263aa0d14d20f837ebbd69ed29dca041058e385316f42aaf592b3ca62dcd962cdeb7a4571fdb36370c2112d34f936eb96904daff89862d2d62b2de50419b0a56fb1602a412917bff4553bcdf0606eb653f2dd916f1fa0074fac2d67489a29f463a9da5f309421a2b7a90f32f73521eaa3dbe7ec0ee9bf07438eadb70ee7d44c7b70a7e2f3391178d58ce75d6ffaf1efaef4a235b9d09a7fbd768eff8333594b000414251a2e9d7f27559bbc82f8fa1fff22627308379cca82afb166a4a186910155a1b80e2b38a17b0a2a8b90659892a9b2727aff09fa2ee404fabb3234795ae19ecc756d70e4c444562e8e66af993b186dda06488100443387a120cb97bafe02f59e65a72a7f62401928fb71189db099255c6369480013d9574b9ccddfd863ac8850686f532602bda382c60bb8575ea8e3da332214d7063caa3b167c84b18c027054546cc151059ee65f3d672e0e69b41341bb8af2bb8df571159954a9dea2fe81081df80e640494d7d295db901bac485c52ad348af66f7773a51def2aaeb2b1951bce0c411d385f8e5547f2dca884f30a55907454898957ea0f7db9d4bbc79da0d80b4581f4a510d0e72098c4e98663008ce48ce0b222463e3e170ffbe0ff146ab97826815ddd87de0fc7ca76e94a9bfa56c22d149d6a49af5a6367381ef629effb57f770b21d7abdda75773210a03486e329c4e58db7214c75707e64a74c13becb1d819e3b062b1db6c2d6a4611c5c89aa9b76051c12082ae54e4c9d57754eeb584e3307721c92f9b286ead24d1eef03617e6b86d4291c69306746ae527ba6a2718948005eae9d5d8b5610aecc40d7c34a27fd242e4f3597bc08a49e78e4e6cb4b1e0674fbe7094bd4b51f067e1943754d7157cdfb4a39f42f87a396db47b42a941a7d709179f02399a16d5fe88d6478fd8a92c95fddf41c42efdaa3820b44b632a328b2cb6fed6d36aeb84585e7ef4605b9a31a3115e277182c54863c4272608e670e3ff9d0fae65fd8dbfa92e29d6256ac5ace3e8a09bb412047d3dac8fdf1624fbaac93cc77ff93434442ca65c21d971016bfae90d22638c8f8b16455458288027b61db4a6985155498b643b84c677073ba3e932154149a74bf8d47f78f97294227ea488c5e194ab126561781ae1c343fbf0dbea92ef0ca7369ee2a1d486fc611b68c85d013e738fe94c21f60271e7bce4af4e36e6623f5d088019287ef4a077ccd4ad43b7dd17092b086e818265fe1fa643bd91782003c115805781bd4f54a4b9f86840b2f6285bd2412f1b3c1cf1ab37b162adf6222a44304650cfb48fbeee9a3fdd35165c9328c55e4b2e7f2a78971ad9b3e18be824d3e625fddee14eb0a253213391020257bc7f3e821b19cbaa16a439ee176d4f7972330df384230c82577b234cd025a4873e7f4f90b902c9e0ef1612344331b12a440c0100bead307106437482b3b7b1b8fd7fb46118d9437e53225cc17c1eacaaded9f7ae4191e3635f4c0a5f561da961784e31b254dc0e90584ae0149806659574498eac6726d634b30292110543257ae495f583b34c50b23e3203fb7b7f2c6c2fc3fc58f47ca5d1307dff7dddad07e87b19be5bc418412c01856a85585895aa2a2159ff711f975916cce27df6dc0c1900b4da44fbc33aac715fcf573993b428d04d6a82f2feecfafa1d250cbbc7dafcdb7df60275b083d03a25bfea17addb86020a1d60fdb695a3fd4719e6fc148e3ba23e357e6401643b753aa1238f144f93ecec38d16abaa7e20d445bbd1ac8c97ed772ba7cef687953012a1e93763936adc0bb8f37d4584e0dc34275b23f5ce3e8663a565b9c77a250a3dc2d11acf8a098f29c1a2ecd74588612cbaabfd7d476a429f1dadc3ee67c9f47efe107b0f19b991c15c623966cba24b9c0800aca1c27bda90b513fdb2201ac8c208a6b56c3d8ccc8c5328d350b3fb5b14e6c07b13d5b78a8f2d460a2448c8417c2b7e6d95f4288610b1d463c0c9496ef3230f9cd45a628f546fa34ccef82264ebad4056ff6c4c4b5b247c77d016f0820ae0c9d7f0e106278bd915934689d0c34a02bf8497be5dd950cf3992dc53394c67a8a7c8f1cca8e06b122a52cd6eb0b990ea2dbbea98ea0fad24c1e4184f1c8107782c80ddb2d0cd051b55d3d9a06a020d37a85e3a6f64c0dc2f0d5e83b637f60efa41be0ff6573a43c83c6b11f78f6f40390ba9e699f580a934004d2556b3b85d44d11cabd5c23e2752e362610585c836f7036b6abd16961046d7eb36c53c74571f888abb0f33d13b45061262877db6d84bd79ab4c40714dac7e19e72ff02b141481fc6a13221c06846ff2a49ca2cf0213f0aa16fad090cc5a0d3fff2e3254e14b0cb26b22385a5dfbf01748e65763a35ca60d27901b944fcb15d9e5331dc50710fecac0c011215946ad9fa8c1d54bb6fcdebe58e63c8992539b4af118eceb35abea7012cfe414962a4096f6526400a71a4ea7732addba2e843cdc769dc4fa1205f567bab457530dadc67b88a80dbfc8e4f8441d8f39af5116f985c2c423e4c8e2a0409f1cd61e4a359ad110a0b276aa935eb50a4e83554b68ec2efea1fe505a3589289882a5735847874bd174ab11ff1d9c4c3f892ef5b755908f18325d54e37445a704179a9da9fb2cd7a4cac318a81d3b264e7391e421881966545b1458a0c39e6788cf612c500582fade9a0bf131e7330b48062b7884063add908bf4bd2507372b2860696bec86479d6705523585e9282b4072fbbf88040f6188dde287adf4a76d42f5a2c69933db181f7ddb977c49c93e352ac3a3b80588189d4010cd23b9e2e1325fe562f97da85748d0c0010afcf23151cd451bf418486d74114403930ba49ab68aebb9508c41cbfc37308353e2afd3aa76465b6970f3b29ff236137beb1b2621da682670c01c55333e30be5b30684ec89dd39cfa033a02597dd7ea2e9c5a65c9696b71fdd83a1bdec5ca9c3b498190a552327a7097399191da7b5f93cdfc6b121a1765a14df78a3846695694a63900d6d44c7997ab523f5bdf9d7fdeb8aab4140487b141bdb7cd78ee19861c66a8a9f4329f73fdf92fbbd0d71ff0ec06609ac9ea63c86a097a1670b7b3bcad35fb6584e338f9cf02dfda90848bcfe9d7e8413590fabb247ab6a5bb3df2409b86e7bd29af78963f2a290b08f4cd953f4e45b40b21cc568389dc889dc702bae0a037fc842586d9f5eaffd5e5f90a2083da2dd144f81728134f79b6031cd31f64b7d366e140fd84bea2a43e94b531fb8de78091612c4c86d19a9bdab41f22049b86bcaa38fc9f7f19fd2a90f4fc99ce8c6cbebfea715bf9b775c1b2f1d9f89d0e4c76501f3a8dc6b8463e218f1e5e7b4dbacfbfbc96f5eb389af947b2e019d639f0f37cb6e6b39b1517bc716faf2021e3929188f65f87d1dc7bbf2b0a33e299324439096a6f1a9f933c111343df5e681a927587b3d523b3b0a2ea6efeb5361f12f47d2b33c253bafe0e93554b33dd0c7de193d761d5ded2cd116894f69ab6a48bf93adca3c0fcb3641bd170e8898e2516c7f585486922ec99329c76e8ed06237db70756f5ae3092b67bb89bf8d327451680b5b620b147991a8ee91cde7360de5bc5c8ab7aaa7531da9c3506793fc8abe458d8b6a5acf48228f4d4105990ac96997e95bbc8d81deca35775c97bd210339818bf9bc8e2f3c15cc61653cc13842bdf6b19c9caea12c1931f55b3f7f8e475c2267a9cfddd2314c52eaa7f3518d9bdd98a51e61825f261ac92f6393eb7be4d264cce0ba38fa68cb5762babe6ffa663e7e5b6bbdb84e1929e67a794ee00bc4fb2f36304711af0367d58ae963efe6d28a724b2d0f0d1ad92abed530206771ad51d2e40251d7a158c0c6c1f733376308dae09accb7d333c9f3e90c8e9b994d50a12bcf71ee0d176ec0265012dc4e3332c0c5abac4ddb76ed83006f556a6400e0e219a91c4a8ad8a19c7d3c40cb0985137e3d9eceb3fab65d59189d4c27a67bd73880598e322531af76baa125f7348302f4778cacf4a931e343f14e79df2dd870f49cb97f6e19725a3af1df2c698e91947362bbb7b3cfe04df08e411da92fe2bb79b4729479efcaf955114230fd3f8dc1ef22348fc24f7ac28d5e3d57c53c816270115ee506f9b03aa2284a8744621ee1cfd7944513daecebd64cdbf9ac6ce7e9b556d2c4d5b28613d02d21d3a97f7a2bd93279921ca93e448ab6bb6bdd093c2863ac30333c8a6419ef7974f3ab11f8e0ac8dc93a5ad55b4736a065f27c0514c01c0bf48c77e0e12bbb8296c8b6bf5d32aedca04b8eb807205976b468dfcc29f2f398a923124328d21baa8cfe01ecc28e0fa4678833c129f8dcba7c06c95b00b537615c6c18d2b95664659e683b1a388847a7f6f4eccfc4da0a6f52397fe4f4f234c4807a9de92a4c8bdba50af45ce63568d520771e974e8d6a154460040da1bbc93be0c131843c48b8395b4f8b220e9dd12cb74927f4bf4cdf593815849bceec4811ddcbc42f8ba2f8cd5dbcfc9fcf9b2a2dc3256b7a242d31dd4c7c1b0cf6796cce4ad0cab8086457b16cb0e9940e7436575115b909c1c88beccf974fa0f9d6f8e0930e68fe6b878479f51e122add023359a0d73cc55cc73bf6170c5e14475093ad7c4762d083cac91abe7414447cc8ee8ea41f6d7cdcabf6ebc8aaf26014e57a9d8bb6670d4b36137b2edf68c00763a9c8139162236d8ca566bbd2f67d990535b4abd351719155cf69dd744cd8141c26b89cf0ced6e7eb224aed30f1b5289e1d898491685d0abb7376c43e46130541559c3c76bdf0e2000385d788edfdb162f7e2d4d653611b4a30919aeb2e0f1c584e5d4e9f2d1252427e5d5e816271b1f018a1429b4f3ac01043ed177f3f20aa4943e9f3493da2c5b7491cad48fbd8e9aa0d02dc5cde7589362cb136a90c4e8404420ea73f456558da506596f36f24b7b365b9cf5a8b8255a5c0ea7a7893d1a3bbf713228eb4ba7e5ba6751839b88ddc2de42e3a67cc50e94cc81129f5f4df42a409b8ecca96fae963f5d760faf8a040ab681583be382c173f4619e15a1bd7af404c7bc179279b97b117fd2d28c6e1e2a79d421a3efd131a2b5e68698a180bab3e76f7f2222af9a610eee37db32b5d4500801ebec964b4d436c330210a1d3cc7e764ee618dd9007ba2a74063a7a4d49162fb9993936d94dfaff6c3b7e2b27bc0080321fa0cc9ac5eb7d2a348d8e1c478a3adc1befa721f6017cdcef229182597d6fffcd9041d3afe9ea533e73a40b85d1c26946719790c3a6e71ccb3faa60232d40eb9faa665bbe17d4a17c6aeb0e0975d3d86492d47561ed8f4add0b2e84b7ffc2c7015001c55325f998b295882deb7a390b6b9d93b422ecf40c0da6f02bd68829d80296e68bc569ce6ad6e38703bf6af12e7b10408f8da158b55011a04219e753ad8a67ad79183aa27af0b5e82bdf5cf03b52715eec5ffaec83f6033813a4891915e2f32aa1268944123c6dd39d89c1afe683b6b6ebf196004ecb0f5b1ea08ba440f6e390e06b72f04d7b8edb6bda6dcdcd1c6bf2874a53a3b3a07952350bda54216ccebcc980432898269c72ea6a4597788f95cb19d46247dd9fc661354e362db876d480a629aaf5641fdcc8b0c313b66610a59c6fbe17e191b0798c2559b855c16d66e4abdc915e8bc06d13129128a10e70a07a1da16c7efcb7c96109bd8b347a4cd8351c971dcab38dee83c3f15a3ff3c650b5317f1afd55803b0bd7cca5a673a3a2ecd71960e66a2abf590ba38b8e50e439c3ff08ade81973b2c9300d030e06f30691206e5ab0f85d3bde09c55fce0d3fa86f478319f1d44b4072223aef6d9141012fc9e0f53aceb10eff12042ab2f9cf80059bf0afc0ceea222f469e819eb38ebbf9d1de6881747ec24bd945030bb7588c4d024a8391e89e9072399609fd0e8c6482abe021a985b81aa757672755bcbaf23790c23fcdecbddaad7ae3ad3ae3e5e46c67a32bc2a129caf838319c37412bbc2feb17361ee7943de83b3e2c9c19af78882fee16a066dccf2057c36b7b13f9c60e70b1bcb847b87ded1577488f09cd7b9b5e301385f8cc513de8a40f6f9d206d02577d718d9676b578513491a225c5dafd9b6cff7e4911136be87e91ebf4d7861edc0cfd72cbbc67e91cd2c1f1629e8dd79fa71921bf172e0eb1a21ba5d175f4e0e36e03d846fb6941ea12b440fa63d9578ee04e5f0855d3239d8f7ab882b8375f2ffa99190a7e276e245db89d0f0d5c4317e7f8fed5bd23a05b2b645fe5a0ed9f1f929722e6b937e7653098849e7c6243e050540a9edc31736ee694eb6586533079bbdeb579f75f1197efe5a52234602a6f1585ce0c98f97d153ded49b7a7d735fbdfb824586a4333a06f9bf691f1cebf5494472d57a4116646d081cf855b95f3d874619df7c0b2b7ce28550850ecdd21353edfb52ea0b4c4c5711786ae6e9474b18a30f229b66aa3884f1935579b9806d6d1f0bc7728aeec17b200ec9793862c72ef6f51a750813a1780603e4d457d8d62d45656bdf6ca367494e4e87b34640bd5b4b64267c81d2cf8643494afb56ebc763ca80def880355d3c95cc0ccf266af127ed2420f98bbfd1f6821d2f6a3e360cd2c02524432b1177b6c5d8d7f997e35244bd0dc736cf2d7fbb91b57409c2bea0d59b16bb841533db03d86c9c25dbf1c835b1dea3758528f42e1deed0f6fbae96cfb57209d0050268150d6262657a901043a79553304c6595d2255a24547f1ed63e5197f37329335a02e8b8e55858e5c16aeb42fa128dcec4a56f1755c80e5d775209d657e228e89f80a5efb1f9a7418855a799576ea4a094fc4241c3193dc9230f773773ca32bc743d9f84afbaeaf14e18bc45cd6a8e98c4c93f88d04dacb620afd86d5ce4eda41d077e951940990e7e8cb43e60ea85e602f91dbfa1e0def3fd69f145c1ab44f2ab23d85703c29c5fd87ed717eac3a236cc434578c39846b9fe98f2ea25f8b02e6abf4c86f23f9f266939f39f14be26fb17a1ecf9054d62d47a933888999ada0e8202922bb44132ebcf8390ae1df908a9ecb77678eef78792f9486bbee3c682af28c6a8c662c96e7c11ee23e2f9e2329337537206065be35f531bd89741c15305385279c3ad461909907b0db1d6eefe470775040d01c7957f63b77ede9af09780c57d49d0fe9cc2331b1e644df0a58c12c0c4736451310dff161a0d7b10278d87f5ca494472ef006d0055b23cf541d65ec6a2b36e8385a5d86f796444c06aec06b46d866b660acdc11580966334904d665a24db1dbe51b66702cb62553fc1d0d312713269adbed8499407edb162d48de23066e052411709484cc8105bb8bdb37eb35b1c4a7fbd95d70456b0f8da0fd1392cb5f90348443ff1fc9dd2823e9c7b2fd0e52a0badd35027d2403137cb3c81767a35cba3c55ed380c35286e740507901d19b17b11c4d4c5f705ddaf51f49474e16f304fc9c7c75b1f27aa9620ad5f50174b8f9504d4c9f10aa21ca96246caee49765e4456e60fa2dd834024c19260ff3baa49a81c56b7b62f71a2eeee1034c751708c5d7d2f50399f2c5d5fec149f01e3f4f3865b46ad3fddef8d9b962b12e99fb05fb6d4ec1fb635ad867161e78fb14aa1c6d2d71e52735d5e376aba8def7bc0357e22a3600d6899fb3e27a26c720e08f0b9b7b9365486f2d303bc1bf8e770bf7ed18400d89dbaad99bbcef4e35d19636b7410d798a21d625ff79f6dcd61c7d53aca5f2270356ba52fb7254bae3fc2b26264b86087ae1adf3c1eba22520f3b13cf046fcce702f1f1297738642bd39821aca5988644a1534cb96a21953238e3e786ceeeea769e45fccc708dee42cab8871bda8371c695e065b2b92986adcc0dd1656e06406e397c43d045d9cb3e25a431fee3994ed1c6368e0db0434f2b744e035fa2211b38c979bba9e195ca20a352e0392d449dc86888960baf5655d3f8cd8b674253f1b048a3cf0600b5cb9053b676eadaeacec85360ba00ddf8ca1a16b68b34cf6da259a9c024297ae527adc3602ca77d2416619eaecda56637cfd2b2e4e9ab4c43c53946d0df9eb43f3b604663cf0ecfe49011ad07ea37996e796ccf3104825c99260818c6cc7997f90580b1899cc325050e3f643501a9141421f915a35b96fc2b4d6daa05e97eae4ffa35d0184cfd8694195b3024063af69fc986b6271dae38c324f1b3094d84fb577e73bb28f02a0438ef13692fbdfcbaa04ff2dd108b539d7d092eeceabdb8daba9e53902e3e18435061505ba12b9bfb492c8ff7742dd1d223e89a86c38579be3efe5772ed6f4b80eb24cc34b2fde65ceb58e17f5c098e0e907a3049934e5b0ccdcf5373900e9bd49618a3aa18d9bcd430cac51a6544218e0cc91a0979318c5e8a8386677452312bbea55778a362a0f414e6d229248e7b7a08c3fb69430ab0da9f40edbc55be3c4e81b0aac850c48209450331e69530ba6d46eb48164c0754d8a82974b37a7e515a434566c2179990f6e7435895b563af6ba9d490c77ba6d0b09e79345495709dd4ccd149a37e686083b236164341afb602394e44ffabdeb21972e555e87d8e2d499067f81887eb4a01923f61f3506686d40044c569def6082eba4c461a5392d6f322cc5393dfc14c84de9f396d734d087689902a30a65bbc46daea058dbd243f7de5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
