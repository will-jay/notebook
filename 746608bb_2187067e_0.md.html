<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f4401d58fecb4bac2d1b35c4dd4f50391701c4bda0233fb24ddbb079ac9ae82366454351175a0841dde09a5189bb0a9fe2e23214518eb088ed94fa6e2b5ee687ea049ff2fc07f1bf1bc50993e2f9a5349b06b2d540b10d50ee84f54bb951e79273020e22bd07b6c5834c39713f06eecbbaf6f2d2505c574f1381d140620e880c4bf0bff5e3767d70e0d96fa6ee70f68c51fb0d16c394166540fa791622a4c9693e9246d5e4a10834b9484d5f10a5a145bede7341d0b805a43f67e58a8fc3bbeb06e7f67161240886371a6b76f4e1a1cc083262561eaa11cafd6ec856d5bc1d89675389624edf74d607e84e5ac6aff8cd0e22d2db332dc8db33a71f5abcf7e2a3307ea0b2352bb5f769873f1fdbca157504290a7bc23ebaa4e4074ee3df7aea9a7422380941855d40ba643ccd688e432edb302fb35bb52b86a9e3bc443ed036197260ba04c1b1d362acbcff21b0ee70b1f6b2b969425ab72787f7e0e5e86b88e77fd9910ead2fc06e882eff803456195a9708d2df0a3fb238f179b9244816c186f26d9cd4e0e4272561004c7e5c63b3f473d65d667cd37992ab064b30f589ec70ad10895f60caa17a5df9adf88fe9ef39a9ddcbd637febbebda635e6804f0034b7a48a359ac123303bde768eba5a4065a7d871bd2d7737b5a3bbde80060429247aeb0a34fcd8c3b14930066b95beca59a9b381b6e4726256ccbeea43f19d0afd3f768299322a3c3db049aa1a6fff30ee474788ca24e27208d6c8cf2dd590085afaf05c5cabc9952e39208c8d3ae147cccfd39f6debbed3df8d3fb9b5651e0d28f629e7c2d08c18ffcc9b8395befdc98052f0e2288c72d4dad16d50ee8d7f3a84b6b273ea49e205dca0c74d3fa6a503ee057d60a60d9901d3999d4a040325ea096101c89c10a55f01367a202798ef6366fcb75dd7b54843275fb62a8fbd848aed3214ebf9e6f69464a9c8eaf0ee5e78e23c9824606102ce1df2ab64c0952996a17c5f05ae63ac700ea3d6fee32c98c0ea04124fee122c87d7b75fb68280bf05e88272349cd0c03f8eaa278659efdba0938489b73fcf2d942f780390b13846fba027d68a7e5d8ce1d6e8efddc2e5d522920419af6e3a45bd40cfbf7784d91fbbf3531e1235fee5b41b520dd70bec73cbc1a0fb19672fc773a4bad954ec7d6e9e005e470504d4230d4ca98ddfc65734d634f9fb5794a88db7eea806a41898018193b76013dd497ff932ca3a881dbbe7e47c20b39712183492edd7813a892ee24bc0ed3348be7755a51bd80917b9b9499344eb048056f1a972aaefffafe8010f887ae9c89ac762f41a1ecbeb7f25c0ce50f69ef4e63509aad64a976faa92610a3761d42e275a06154b55f6455d8e99dc3f178678e0dc4e60ccab13f1652594cd751abd829e94f0477b4ba67871be41988080883482618e7cc5d8531d7f1158249c64742235a908f81cf8d058cbe5e3117f10c5768562e6bdc7e871c9ed1969e8f68d98744efecf2cdde43bbf20c8e43d37f0d15146dd8adb3651b5c6c955ff71929d174bba1187a32d1be7233db136ea042836f35ee71a2ece173f41bdebe6b7e0572215f22005a842c6d7b56ab2daf8c224432eee64340d00268cf45a4de1dd821c3d680b2f39f9e5fe6cb8fc3727962c817ae9896f07024150b60ad0ec76e2eda379bfc40b551cf76a9f5eaec7ab561d291475a26503c3a163de0da1bd7237ea04ffda1c9d2c0fa44f9633bead7607a7e9add55c6cbb55ecdc532bf31e0339aa99c477fac1d6122ef15790525d9904d6c99e91838d461e64696b25e4d57eeb2fd2e38dcb784046e95089defa7d0cb3f2468726ad811ce307fafddb35399107209e2b02d8d30fed0f9a0b57e82c71d605ca061ec1cde76a964d6ba8a2a899ec306df94a2282e57f2f7adb483a2205766398d37d329b70f8b1deb6b05fbc901f4d00c98a713f2092564873f5ea6979f45c70d343f215bc23de8ca2035fe0a6e60ede916dee39a5980b20a2b0732d3a5d8f4407e29040e1b81429f799ead62b6051cf9f6cf79c9a22aab7779c6bae3b20fc338814067e95a43bafb928d25f43983696504cd351c8801af36416d3549e7d9f80467eb6650b7665e7f01421c09aca202ca0dd24d96d993816bf767d5a62a1ab1a5a724239dbf2ee78315b7336574f8935dc754b8d284780d73d9d5861e2ec2bf735e71ef772e53f7537e0fa47e54b966e78d1d43956cc0290e6518c6698efd3ec12adf5cdee3375d5d33c13c462d7c7c44105a8e4e7b61a71c72157e50a2ba464681d10b1567e1f47f27365638a15e16563a560ec8e8715236988f994a085a7336519599c3dfdaa5c97c2669a03e5176bf1251beda0b7d0a892d3b5fdbe3dcd9d6b7e3ef3fca6daf96fb77c3c9aeb0d321106fc6f18463ecf52b62339cb6a09a6a89768c5af1677527eeab51fb2188d593089efd0fd88e3024e78f8007ce13c0020dd29e22ac1d81d81f373d92c2788db292674b39daba8549c6429a47bd2421be5ab31503c16eeef56e01dac3e313c88e93d7bc8d9cb5b5cf751bb4f0e2cb0154d8ed35e477583f80c4e10326a25ff4e49ecdb4b8404bd1548cae52a565fffb089cff2fb7009772d05bb80cb9df2d4cb3295111cf60d60aa959478f3ca00112a8fc51b5756b2d19e65b1a1fa4f6bc4db33e992292b221b02a326e7176c1f723130198ffef65455f90732ad137c57f826f2dad41a58f8c204b54bf1be8bdf9e78a476358117d729022414617bae2ca178e227f7ce7e03c990ea17990188dbb4e43be06a54eaa51246315c3895483a10089280cb5762132af856511ddd36a0d2c85de16f37a6d189a542a3613be1fb86e3c3f1785ee7b134b4a1155f9206419e7b2888f62b7879ed41b3e34aa9236c4191abad02d2f58813e35fe9337e0f2048333b0bf2a4f34204d1ae4e44c6650deb8c3e485dd0a43235f730bec1499d18c2eb8e9c60c6fe9aff6217262caf8cc31a2c208d05967772285c9b6edb1c475e8b24c0500b8d375b7c604037d3b66d3725acde67b55132483b36d0e44f596f6d1ae4ebe6d4d207cac234235517c638c9050e897fc241a8db4ebf1483a6816a7aeb606c86caee136402f78ddeb3a0400049fde2ef8650a9a3d8e12560f6b554d7e84896bbda883b37a245bdc9193e4a177f2be056f2c2b2bf40811491d8fea00f0ab77ca8c3d09de4fe4167dc42b89eb863ec2ee09476d5d55d4d2fd38d074e77bdc94d9690019e558051e50dc18f71c922edd7109ab2e2e33c40d43585a366314eb605d3a2015c73c19a0b9a7a51602a8ebfbd698b22e78b1d9fd6b649dbc3c957ef8e0e3a0791b9ad8d90735d6120c0ee21682d5440949a20111a712a04a5cae548ef78c183de70c4194dae5a68a73ef62f203a7b5e4ada1f0ea2fdc3c522518e8958d6b65bea897db0329dc576024ba8da0d9be14b76c8c38eca2e4e3d6b26a7db7e674d55dcc9c3395be6a15b3aba520270a94168afe4293578f0bfc9746f7a421c5dd3d043d47c7b8ecc9612d993961bd1f3255b6a5e4f62a0a5fd27f325ef85c17cd0f4b0111928d2639c4c1989d6880287b1cc073d8101356ae50c41eb5026146f470c0d8f5471dab2065be052996b8f72d7e67540dd11892f8eb12fc187c8f6deccc28d5c50b5bb350c3c5beadcbf9d3eb26ba92896d442056d370fc66e175da018b2fe9331e3743a84e686b8b6bd562c86813b5fb3c5883898575ee3a01713db94f38acb7c68e27bc01013a5be5e94a6584605a39ce997286e75ff02d752b719b35ae0d84a6cbe5e10f6a699159eaa55fc73c3972cbf19af8cec8b7117461112ffac67901c20081dbade2734ebadf4229dfc5624801870aa0c731a971613fa8d20422a6573f64574785a6558ec5e3dc4fa8a933d9143422c6b6cdf1d5a5d8c9a26acbadb42abe8e12d3062cd04040f5481e6b2875d3fec7a863327a2c44d51188516f831b10cf9d9751feb9d8ae606dd03e5af6d292aa6ec8e67e0955c59849be9b085ab06ff2f84735a0cd637fafbd773ad180a56634904f13efd25d4dcd5d64498dc8a619606380bcf4884ea7980f2b36ef54c7a20e5ce87a8d9a26190d6907d2c8129e033eb2f942d3c9ca8ab58b12c2c7c702aa7b4ee23deb01c14c1e2271b45519fbb3e6d475d31d40c61374b17e3f7757b2d1a3deaeb8fd31fb96f11e2d761c88b35975f9d1d99e21ed87a617c821d797d5db014d4e906fd1d3bce3675165abd258b9ec5bcc6928a8ee564f66d338260d7bf0c18acabf01365c00f92fd576b2136eec7c4714c05ed2a2722c03f240f99f7fab12512a48cca44943379730b0c0a4da9f7143b30fffd52342a38c976999ef702133cec8bf250f428bbb9a0c1c9c91a77d42845d64cdd55a69178df93f69a779d55442fa0c58bd5bcb2ec28a632d4d0c95664caa0ee9671db1ab314f09543277db3581a2f2717fade337b3f5f51d8cbea2dc1f218f332d3b2d7d01a0fbc188435f8f2e83ee7711b05e7731b8f808585903697918718f68a7189e77d193337a1ce559a6f9ab85e7cc027d084a76c8c860badfb9b612bdc5750d0323d539630cdd7569fc018bc79c7a5352629e48b7e0f6f5ad42257a02fa4fb3a02da92daf1c23ff8683632ec08eb44997bce273f43e09ead6afe0b606b5a8bf596d483afdf6c98ab304c314e4fdf808ffd487c0ca71aafe5edf246bd22f095e48b7ef4f900ab4fed76bf67674bb2b65bf712b8ebe61e063e262d616c79212f46a738ef9e15f44ddffe239ec7082cdfcf8578cea6f14594e711cd45da0d9068ab26294e05faf715582eda0d2587f9e9a1b5e21aec4efe79520a1a810cc2925b1f03a695ea51f6d8bfec3e1d9ce4c650bc8382384dde8c8b5434f986994ed77827eea73b540ec9db6bf41d8c96f5eacf9d9c992d80aa52e67367b5677613c1c0306d7fffdc2bfd3d20fe1bccbd7e9fa6c428a3e66c136c58fd461e13d351ebb30eb2f979aaaa205487b46d8c4b55818cf75500e64bc35e7e8a998b8999aea3f88d0cddc4b9194d9a9bb6cbb5207fc2eda3ed973ee8b0f7be4d1cbf7c7a70559ca27fea72741575cbc4639662b025921eb35e8800d4f6e7178e3f42f146632824dfc35e859f83dfae5c1844a04655da86e35fe2724ca2c89d09092e1e26440ceeed2ddb864b789b2ef9c0f425d9700e9a28cd46c05f3f7d384952983d8660bcd6e2f5c798bdee33a188ce8c1417e49816f822d437d804d98d08d2023acda7ca37ab7d087a57a30229bf6edddfb3e68a7070fd1e2f0ee488cfcce612332d862b84a104ff9a90ffb04d0faa5370ad3e71440150737c140bd2b1dd3e936826d75e06d3024f0af50e3458254efa4e72e9af68bba1124f52d0bdb35426ecd515cd5e10a6c5a801d9da308319cc3882691079b725c25587824a7eeaf097d171e7f978bc8c971bd29119299bb109beda83be9fb6835ef7ef027ad44e52e0cb4d953dbfa6aa5ff174a7b466c6a97f79ceb7505ed87f628d07b9424a5a52bc5a8b1372d8fad857da1fb07492d7aa1446ecb6498c41f26a8947d15f3adfdef522215e665a5798a0e8862c09623661c051f8551c73935bb0e8c85120d2dd32f920b8187de0e7cb86b59a589ff0efb1d57d7c5b1a42da732225c90c303b4e22e72158f89ab277c7bbfad7dd77cd28bccece137165f7dae02aafd3d7f45c83e5ad8da4224c1eff48ba0ae4ed246a26f434926f5e322e58f045c9aac93350f8fdd91d83768b0839ec13a740d91ad37331a9a0b7a94dc3311337211c9d2b8bf35057f201679415a14908063be1e029cc017df5298f49ebd842b7a5062d6945f91497da3749af38ed6d403892c1305ecb7808dfd8473b6f4dc99ff304ccc6ad6311107f5db9f565007a7d30a308b32167b0dd3b6794029cebf6212d1782100cfd3a07fb5d0bc4ec99b55ce7e09235383f8b67f7f21cbf8c6af884e5f3c93dfea6b8f4ce2886b1c69316738ac0db297ea12c5bc3c6e940bb1d0e60a0a5bf97f2e464ae0dcb0b23833bcb59304793513fe7f4240800621241a323bbd91eed797c7d0f60bc8b7ae0175487e217ac11c62198a04c4d539518575dc89a5e6b1a71b0b4f61ed702abcbb290aadcf62133afc80dc42a54b423a4c7ca9765ebd574efb6edbb2f33937a4d030890bada913a30d328dcd943ed0c6048b4ed9b9352641435c48cf3a92124b0aa6f7b449ee87093438bb5f6dcf5912214ddc7ea5179d63ba33caa89f24425293a0156c0b1f445e644f2a6984eecb4604196c5652aafa7d6acb11894c4b3778969ed75239cb4605d6483c097b3567cc85770af6c5bdcab935dfd838f1db5c326ff265c0fd9efc464c18c2f679830fd1c84af20d97ab9afbf8dcf90737f23331baa2032e1a753db1c64dda6b74dc9f184f3f5eef34a578080afcfbdd58371e95156aa3f8525e2830f1d42ad90bdb66644f3ba5691f5aab718b69aca4016ba72659ca3da1cd46ceb2bbd5d8314bc3eaffd088a53569e7a2206fba833ff2c32191ef2194ea5a8fedcb95ffb70057babd215337c97f49e81ab3d0087e9de9731900bffe37d52c71e972629db7f38cf0775b40e8579beb3ceb519a22705ca47a1e32acf9b5077da2de4e7360cc6faae17963a34e3e29adb122d7316f69f59bd965dec478d6ea8314fe96fc3542e1c4d3d9e3b20d6ec516c3124387c3328438ad983034f27c72244a685372bcccd81c6fe4d2e8799bb974f967e50d8dd38c75d726a7381665cd22f877e6df3e5425728e4788305f682173688430cd72e3d861134eaadf687f8db0df0e7f583a40c9df448ca4ccdf1d59f89d6efbf8de45adb333ed19a1d0f0a747281deab65d8c3b58e28bc1b576749e514123c5753e102486c065d678750f78216e3b8bf4b5501846c73edc701562365f77e58e0866b5d9fa4d5e5546e8eb84abbe225bb75860baba2725dfea58b8eb3825f4ee5cd770273663040607dc669992220481822d43f8a16f9f544faa60dc049103fc88d41fb57b08d87ea75c9c47d2beb05576f5f1c15cf4129ca77715a6eabf205529c8e265a9e6e3bbafd941faf2de66178bf27b6a7e6f0117b667b18740444b49a73a01ff7963863c59d734b75565d1bde948ab23eb4b9f666e2297d652efc63e2a0da7fe8c1c4490efab5cc06ccc90f47ef3012139c1560f9141dd4a47ec5608775c43b5cbdafa261449f97147362c2e2762420193d27a7878f8f361df0ae697ed424471044a63a8eee9ba13c36ae52e7ba71558b6039812436e0797c21c01fc732db9cfae2b9de3616c0121f61e356beabfa02d6f12297180f1d8f85de4259dbb08c9681533956a26b3bcce259476d72d94fd0369c9cabcf8c3441bb6bfca6d6bf4e4f4a9bae7984e456d7e0350bb661c518b8c29935b863ee41b27f3a2f54b43cfb426b92991da7f1192c67ad3493e919c747fcf6d815961c113c555e42295b8ef359fe616fa52f105fa8665642e568999bf061038e76e02380dc1b3f8c84473ad14ded09baedd76734bd488e14dea26970d3f5641e3f765a3859590e264953d44c1b088afefe2b45a4eb40dc48955ee9d36521096838d9b425eb18dc10a58b0260e54ee9c4c341ddb39d550378ccaa81790683446396849db92b65cbb355ab763c3cb403092d67fdd5af7035618df3772e977f92b43111831df7a6c3a45bb5e88c1c829b05292538ef261bc4006522943a388c377ff87aba9b54415c21eb87f7fa0f68ec6be524d08a8f18658f15202c26fc734a818d0a59304a7574cc876d73cfe14eb1b3e366461676e98a5e546ceec023160494310072258b4a1cc6d07f85f2878028737db295dab7bbecebdcafe29edcde843a9fa50a4daec7648784d068b88eabadc107a3fd62a2f111fa4b4c906f08f8057ce778e46188c820611787b2c390c96c5f77c9310635959b909849d8897952f78e7e8da575822af063bfb293bc904c608990fe432ee054ab30a2ec815e50136a6d4fe2864186fb698ef6cbf3c8129b6976456511dfa8290843f4b60297b9321e8548abb5aa56a639a80702d5d899f4fb63186cd6bfc779d5e49a17ac2d7ea5bbd863608f70a53ac0722851bdaf4d4b199d952e7f18844884b6e63d206b8221738dc2b8d30e396b04e55310a6902a2b1f8924c2bbf68f3e3220bbc95898049c896f60647aae3473a8c35614a1acd59bbb90451290187752964b2b4acee59b8205152b4812efa64b11bd71621a307f66e9287dd80a97c8dc62526f74d3f395dafe88fc72507c485773a188c2a24fa273ba3d86ebbe79afc48c315862d01705fa7a5ae82131ef1cc1c5d04c6c35cc856fcb0033171c8a5a4d6135956d4bef1a7843e133c6b6ecb78614cbc0bf5695904e0504afd79b2e77e95291a027dc86db8f032da43098ab43b7c53ea3bdbe4b32647865745bd3f9c06b50cb4ecba4516e601fd8c021a774676bdc24b5d0d1adc705b4f8a01ef7f3c00730c630018e4ba3ed3a92c609838e0c8c1bec6abcfdc758da7f108a2d5a7f300390061a0a68c69b1d853adb284a9ce481e2efee53ffb7d5ca8991bbeacd04e16b6d7a8af000fcfd80b3f481c6df7f4125510391035395ddf95d04861971ffdafe4355abe1a98bfc71fffc6cb21ba1b053aa16ba56d2a952fa03d7543faf6cb9433aeddf8418b6b9ca77601c71b02dc318cd6993f8b3ceafec2e09ebc366fbe19a604a5a11fe7cf9785e9ef3fa7b5899754a21c0cd4066e05eddd2799b2bbfbd79acc8f71847377b1ae1b9926b9f13c33de1d952014e14db745fa8dab2b9920d9bab39d04dfb9de66cd0026ff3b82033aea6b944ed293045d901b9c07dedad6a7a6ea49f05e11c9e1662ec1c5897b61d63f8f28b2ad20023c4539bae1d1711c50b7a0cb3705cc3225daca006ee9d6e4b81e8c9ec8d4dd003e27afabc586861dc50b65b94968499360dbf61b55ee9c79e6c6e0f2ae5d10713e73f4b871178d9aa789e137603678084cb620d9d93f5e0cc250f81527ba99d59a8ac6f56dfa926e081cdfc41cddb49c1c0106afcf614d7f07baa702c6405a382d75427db9e51a1cf36600ae81243688de12d0d1d821aeec4d473451f3594a66231477c819ddda25818af9e3091e2c5884509c0d54501d722789b8184a8b3742c014e812d5da88825fa0825c1ebaea00c1e2e733b109c86bfa8d7689d196b70c2c8cfeaca68fa2684e93ba0868253ab7bfe9517f5eb5e515bb322b3716930d59dc604c35c962a3428e60cc661647c51cfe64a876c68659490b9079f6fdc17a66fa3f98ea870acafaf09f7c54e5b4d7a59e4d5914d3a5572b8473562a98fc7b3611df9b78de405aa015aa63025bc52671337f8f9af310eac901ee9bd9e76dcd485ee89e36c3bd46c2f04cba62ff4544915043c14f4579d1a9b54858ec950d24ec9c9637a4cd88cd236fd5230f5316a802a518ba6ec3b560b21c4ba30876483feab23a12a7804b8306f39a10bd502da3df9d84566155a6785c22908311e2f678175335f5e6b5bd759df5fdafff0774bd1f0e96edf31fe21638b33a60f1caed4c88e1414f9e1da7ad054b71a25533f4b93b55dd9b2b913c93a659dbfa19903a3ea02b91bb437693956bca9e8758b25e21935dc360db157dfdc89e496fad85403113a2c488a8e64a09e7636b7d2f30e083ad7e05ec67d75a7c9491efba23a428d2fcb36088355dabd7c1cfbc6acffb5016d948a7a010592144c3e65f6333d6045fcd4071f937c939029399b29c987f07a055d131f2a6171470686968683544a1c4af8630bc2ff7a48c93e28c04d6cca5c01d391536e8ae6d8dcb2559a1dd01f04ede580db7091ebd090b2b201f6bb765af39023897cd76fbf02fb78ce0e420606bcfacd7f23ee97a02c2d032f987c4ee9541bc50f636f48b0a06d80e4ddbbd8b06971dd66c521e5e8c7f87f76baefed9f94edcfa5b0a070760f313ed6f2eb5ad6ff4e997a372d0430187c1e6eebf500ffb1d0ce255c95ee5169e16bc6574bae954852ccefd21b884847ecf94bd93734eb3744188f9a6945b4ac9467b326aefb00f7aeb295ba9cb032bfdf7f761cb3754a3cec8f8b0baeba6a5371ea066a8221cba012d075b5092286c61ee2f4ff269b6ba9d9d4fe7f124977f2a161825fc06c06e201386b072808d541ee9c87f10dd9cd5f4b707a6e9fe81292146b47275f6f46e0e0399f398c354cc3a3368ba5504c82d015936d2549eaf3224fd7c1cd29aee1420c301fc42db3238b917d49095401ebf5246feb725b5e17c999356e208d79c4eed6dcdf77def4fdc418256c98cebef733edc1f3fd009c3b5a3bea44add51c213d893cc69fd39698e4725066ce6540e2ab73dd242bf7b3487c2587e6377420d1d16dba0982e57499959103cb4597ba80bc0e8102f25e70835c44a260ef946492cae72859c2c84844d5206017c0f5f72d353744daff5fcf668678ee322edf88823a890019003496d902880bac952344f399eacb2019258654604334fa3f0ef73a3b672853c1889dc9d28b061083dc770d0181109f8d0bcfb993ad38624d2a1a9f412b1f848007e3d32de232a1de4eee5b3eae4b4fb2368f696d0c0319de7f469883e6325eae7a2b55ae32bd2fe5132a50c5c08c29245367616b275f932e2f5c4621589e16d13d93bd89904c3c2dd2eb0a4c244cd3b3b77438df2ac5ef84d1080987981ba99039aa2b5c59b505b40f6611f363e76e69f0033d08c1acf4085894c3640e1db64e3ba55be87b819ec40785a0bf1562e7302a807796f6891bdca26a19586754007acfd66530f18da48661334c84598567d7842cf7ab1937cb99f75e20bfeeaeef4095e4aebcad393ecb8599f3977c94c90bf056b75b1e6f27d155067db60299e683bf4e779530ca3c87a9fc9769753906216438cb63b5fe04c2d00086c3134fa4401052498e58a999a04e391e41a784282f6fd04b661a606982745da634e53c830182d75f89574f34b895b1f668df59eb60f1359407c96ea9549788223a204c486041bdd1c502afbbe540dd4e0f27d49a3df672fa982b4e055c6be23d39781edc9138b1c500beb69a62db7ebe9db1ed4090157de051a9c2ea55a0f33605384f2fb8af7d4aa9033e967384c4d7deac6bce1d457bdda772050c1d21e932f485711d23c105d8eb121b706b8edef3c90d267c51bcd390e054fa18c0468281d535c1ad0a750b72644dd9c5cee6c85923625aae7b55f1d84790e0252271925533d62d8cc96cea41410e2b929cd4992dca7bbe908d8fb37d3b472e2c36910c458c829395a91faaa126d3dd5f9a3307d185e5857619c749bd655edf6c7ddcae52e963274f0cf5ed04c4ad685084de44ce55b43d7c3cf0683b9f9b0ffc60f133a08d8a7f18974a3268b5e4d7ab2d635b52b2a29c97afeae751295d3a4d68af38c53d364251cb1599b4b0b2feb44ca724781114eeb6c71b6d14b9df20a550e4ce8a2f552ec7c72aed846868caeec6b7fbc32e11aa8c12df89711a13bb3eca9e52ce1f0b5fcdd5db6d7dfa7e74ecc3947ac685d729ce201c3763c285075b1cb1c29d9277d6262c177969cc9bcfd0e905a40eac5bf5db0766a03621b8e425d995c9d0debb4c11e8e3f079e6faac667849f19ab652453a50895b78fddd75265194a1f3307310e1d0c88b35902e179a25da03cded6c6a87eea2c1e00a84d9ff8732199f85573612c1cee446fce2790696c1fad6b4eec0e707e057b0084e27ced96be4b31d372df009ef66cd83269747da5d4581bc1db57294f2aa62dce3ec84bf03e3d5425b956cebfc6b89e4ada794b73dbaae9ede3590a978102185aafeba5bfb930c05a9f34a2dd58a3a7e4df1fef1989f000629e654f072dc5efa334f621617b735d730904e21a964c45fa1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
