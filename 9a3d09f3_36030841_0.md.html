<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d81c6014c58844bd3800452d4a19004bd04bd09afaacf26cd7cd068f7b0e925d1f792e5e47947c0a1879e57aa1bae9a58e7b4e2d54eb45e0b2def48021109a5ba7646e13f53f399683db4580ad12de4e556f96b3c7567f6e626e67021d6533ad1537cfb5472ebfceb87662422b4ce6cb1fbc0ff83e0dd263963464bd2d5a25e561ccf422506a64716f1bc5d030d648bb530c84d2f228feb39d2e48bd92c39fc17d393889fb51d8e2a4940323c9d4ba304407994cc534b3662d0cd807c4899109eefa4e5e94a90325f0eb6e8ab3d70eb22c9c75fcf5a05e218d1641abc521e741b1139fcd05e47ae1e16b856e6228397b82487f58f5ee633bd0c0643106cc983ef61edb7d6b4855f0f87943854426d9d5390f84bd6f54cd369bc5f3d2aa28c8bbdf88fe07b4516df906ea4ddadd01e25f79742f6d19c0b5f3a3b164f9f5897d070c0fa1f470d3bd70c3ab0d1dc18d3bde10a23f50567921a3a93d1d55b8670cbd707acd66bbbcb017cd25d222696e49c6615d9fa45316328046c982a8f26afa30cb21196bd716bd1a023af294cdbf8ae552f554b76e815bd8a4daa61e4fb2eba789c54320ec05309404044459d14fa00d0e9898ab7f53af6b47df0a5bd542672bdce8ddb3dbc8b9b9e5de2a366bb539227bf0b36092175af2e01ff65373c2ed4105c48dae741a5a78f84d6a3dd0941f75913420b0456781e725e79b8fe87c3ea7d29fa5cfcd109f5aed21d92365c0949e89996cba44af316346440f1d4edb0619c9f3d16048ab7dcbad4e52c23ca7397478ace47e875df86b76bf74ebee64fb71e9af7a5e46ac5962e6af493e79566dc2af1246a4cea29fc7deea9036377f6ddaccef8a41a481df636142268f432b9bf5db02a92059035a2cc6c923a741025493d0bdea5e378753c10367e2fa84d86e6de52417ad6434b9125a54b0ba5137e1f6a3b26bcfa2348f78c1922bc81c299668b42080714ff347a059ad389b3efa6e9dfbc44a1b72dd578b04024743b82ba55575efc47d758a9ada23c07393cb0d2f4f9d61d6d14ddc53f6203b862cd2d093092c6674a11c7cdb8e695931b76ccce710466757c75bd345daf45cfa6107b3e354e1d54dc444c7b2f53282f5bdf29512c45576ee687dd4b0d0665d275276f8f9980b965961069b97276748eb6f64a297ffc8345fab0c6f7a1fa327dbcaea0f0dd07b631a2c94f825d9bb67842f7a0acb8d2ca5082b50433b34d26ac5ee1c2b4e243a97d27f6a05d04afed8275c2c4b108ca0bea9b0d286de87743c80b6dd81eb8ed9b1c9a60d8130d2cea50479fbd3f002167ea69fa99796737c6093484aa759f6d42549845cbbc63fa5c54bdf7f619fac946fad25c5e036ef75adf23e5d5be461c1ba53ce1e961d1ab09222c141394ffc2237221bd6fb652c595cda8f9149de8ab21c42c9f601023a78fbfdf29f8ee085ba77a29d9d98ca5120d958524585ad4a7aa1e35f90164f024b05cf52767233478e4622f47534997627e6bb4ea2380b682f63d1dfc15eea2caa0ab376f917644ae6f292f53f0308963b7c44bfa8e65d5c1cd672c4291b0411c9b0546e37956ef122e4cc4c4d814f9c0e62c46e6956607ff9af7ae6fe08b37df0ba18eb01c8fbf75b08ad3289d6933ddf0cf1c885860c741d64f278087b236d210b4a8625a3ba73b3b8de0dd86a75478b733427b5447c787284c1cc0dea194e7abd11bfa43b2d8e920f7ee12b9f71cd90bded32395974b9f49a54b6bb9fd1c4bb1d51ece331332ad792a17fe886d73d11fa0f37abb223ce15129bf710392cfcf90813a865bef92f1ae8df3ca9ed24f9e165b6f139a0ffd24ca67ba0dfe5bb74d77a2150cbe7529fb9c93718ebd165f2e5182e99cbbdc5df40f8e7961cdbf2ce171cc430f5482923487ebaf2c893c28c3db039595c54e204b4afec89b77363269ea8f53a71fee148a569a36e894b87da543b12cab08e7ec49e4c105ed7106057f510415aa058cee40fff08f503cf02dcb5c061dd1138942261a2bd13e8d59d360d0857293802bb7cc002268406360eb78178df71564e803c35127dbd84ac3840ee9fa0bae46b5982acf68c26a6bf9f52a02dfc31e8f46f7af489d3d68923c2ed7283fecba29a111bbb78a07511000625b9e864409e9505b6a66a4886ce54817aa53856cd8e12ee9693fac5b5e61fd1152de58113a76e22a321b79bf38065e2aa81c522a74339974817dc87b776021867c7d27ca1e00f02a2b3266d4d8893214ee5d61a4e371447d8effcd6494fa2af5c8ae53233813b3380dfc3e45f03794f9854818b9bb43ec0dae9a9953c3bad67b54c90a3b1def98b0f3ecc46bafdabada993f6fb8624bab23e3b4495151b63d3d1aed36da0c5a6f770601ea903a9777d9a9cb5b7d1e4e6fe0646f4bc2f702f089c75e0abc2737bc0b09cd842a7d292fd70c1579c39a25fc3672074f9fb3eee3ab697b7b7e05e8892bf1dc71b4cc9b666353b23e08fbfe9c4f8cca5e9a92daac318b53856324f842430c7b33dc7b9059f51032d27bff2360e4038c56c8dde76186ef6c5ac6aa06891f6f2138d0adff678070aa04e224b32971868cef79dff33e1f3480f65dd16b753b2f7c6a7b4067bf4599aaa0c0418623008a9b26b53b39fe6597a6ce297cb3852ab89cda28984ff7ce0702f67b7dfc2f8459bf7d435d7840d57c204de69cab4d80002eb89b6bb8a73a543c4a98e4bc10195fdd20c0daef58be6d1d239782384747755055a8838f417d58642b3d171577c7af343575324cc7f80e67b03b5121645a843f2b04ca4b4976c022cb6db71d1f4b64be7a6fabce01fce2af69e5a1da675778212e3de39c3eabac3870f69b4f3606b1e976064cd45b87f7896ed3e9ec6d8e0faea165836fee40efa9aa09ff462817ebf192c21b4378f8334302bf7f992c8165d122ee2094d10781cbb2767a0dd7d2a012ea8da308a9ca51924abde552a6fd36306b59bf49dc71b85161191f38cc3735b86cbeb508eb7feb29f3ba2801d1e3b2532773bae56b4db55b50df6e2d39f572617b982812324264eae25183147009936c0f170d351d5d855dba0742d6ee5a15b8329f07be06eecc4e9e6a1bcf6c0b9afbee2709af11f6b0f4d43d3cc29b4b0dceae6cc0d49a2227da94b971d7ce1198a0d146b85fab2f8ceea2a166fd257f09968984e210e4237cfbbd765c50085f165e6ce239ae374fdf38f39b86de6fe0ac204b8bdd2cadc8cf5125ac2d26a35837bfb988bf8e825be04b02ad8dacb9de33237bcc0ac05b5f21345e30b41cf461dbaf24e258733f662ca890280737dd2fc7bd05d5109779e9726ab18234aafc12d8c53837b684f5aa11c5c5b2834055c78e25bfda33341916da0c89f79efe9970b9ec44aa9dfed4c541763a31f28a3d0c86876bb29d7e326114f7b0a519a9e53b4688dcad4810b21df5b9b805c8cdf30b01fdda250fb04a7a43f7d0e39157048fb8d1bd5e21a5269c71a315934b5df55747dc4afff54221ea38100b3dc4ab911a11407f3bc5292df0528b0ef3f72d5d4848d92ccd3f733b59b9a493dfea78d6f0a9473613f9772c8ea51a8e44a0941855cf74ce726cfd8d721905cc8335ea0ea9eb8e0bad6dcd23008473d3de4f2fc797b5487120f58a94c9a4742c3fe7cd2bd784abc140e3e4ad132fde9338fb2e38197f582eab83b1d6335dd5d96ed137e3b4142dc2701e80c94f221e49964a0e7c2706441dd4fcc13506de7ee4b048b84f180ba2931a3272cda4a9ef72762f2b27d09ac7519cb44b15d054da09d4f95581b1ac70cfc5d5a4ee76a675a49970b8643190ef9746b00aebf83fff64dc9ecafc8b490b075c38c82a898679ff4d23a70620abe849d29ccccd80b07b0a9716d1dba2832aeea4e7642f07b54aca973a288998a681495233e9f0507b3a9be9e7baba6113faa7fdc1ed93653e11707e668bf31f30e9c5edae4b48d48c498420e2992e95f7a8e367baa3ed17cdb6850ed3be34eb5b30359bb630e719438736dfe2020fdaa83b270df4c954d38640bacf8684f1f305e34feb43f72461db8cc48741335719f88f3c90ea4f0ef4d540466a11b82f018b9f6bdd37c12868aa01148b4a8192bcc456d49d680e14d1efe0678ad0d489f1b8bdba2a511d7a625f6ad2b83731259f3765f3b3487fcbeb586afca580ec99bed82ac9df3ab89438790849fec115f40da40378f1d28805414894d448a058d63710dafae879d1c8eb16f237d98ce31045789c5c0441834e4d3f05ba61ba310621760a258f640c52bbacb1ab298e848e58975c4cad0b19cbe31a5353256e5bc988f91484e428053d46be1b0d47729cf1c755ef717d530ad1ad444677b1ab42a62dacc25538c13d0609339af317edb6e4efe39bdc8b3137b31c39bd52b0d286defcda74f3fa4d346abeda1cbab24c688e618bfa1d49c5eef232702d3e86c7f6c926d5110fcd6a2d497f2ca720d481b41da8c32982d3fed84fc9e75f7a8c6340755657247d5134843ef9d5963afa24e622db4bfd797fb2a9ccb0d3a37e9cd73f3be1dd50079070237137c1493bfc946444ca986d2194ba48ec38197aad33b3131b2488b1837599273e44ef507dfdf02166cbcc316a1ef1fb5aa3b021c3154621fba670913294033a467b85d2cd262403ae2b3ec150e548bd6498ab9542d98d3ae93eb39fae2e79307bb0f0a2adefebba59a85b640d56111c40b159088e0cdd12addd869238e903a5b170b74cff1d42929536d03825c34503701864a37f83404f9edf03f12935dd66a4b74e5d3a1cac39d07c5931541f8a67904d2a590e9e2a3a2ef02dd89582588e9c77665f70c6a89e76d5963fffbb478331c62846f0f26ea4f55ced1880c57913b9cffa1b5bd1ec506124472049c467e3d74eeab9a3dc11ad997e08e031bbafaa20bde11a753614e35433b0b5bfbc03189e622ed9d564a7039b1e0d0e185bf6fe2d5e15608e3f646a9e55fadc05f83c20e40a23cbe6257d2157e7c76edf023ef62b6aaa4b051bfa8602921933ef179e48bbd4d1d12ef1bded2c4b4b35b23a3b207f945c2c11d540f687289a91b87490a582f8cbe9ccbf08fe8d6cb45c262fbeba87be1f494253fbdce23b34b28465ec16a0374ec49862d6f9cf47d48d72599bbc66d6184ae733eb810151459d8e931ee6f568830159b66f8c525d263fde95aabd730691df50a4f04720b815e0d0a044580db7d552ee3281f7caec2910d51893b21a5557720490f304edd9704bf051ca999c083af9eb858bc2e4f5f821deab61bb5f4f051d648bbcacb5bee063e17c18c86000022d1d9419ba9e3d01594539bef76140adef328fdd18d22ade6ba79efd7bea968f292f55f8d88dc5c564333bc4ee4dfe52da9fe4533b16418348f2207e038a27ff397d614196c4aa56d84d5fa018e9bf5d2bee15f7f0b2f3979474f4f5fa8ed39dea606ba0450e7a5ad283140228ab39eec80cb7700d7c52d0dd1e9a8c333db413f5b9ac1038429ea9a4c3e67e497102b1636571ff586deeb418b4c32cca44e9acdea20914dc7036bf59a09e0b21ad47783c07e65aaaa6765eb392737136db18ad026e7141539ed5fbc399a303cf242c7ccd32bfe2764527b43d524016f17ae8d574dc73ddf3bfba1dd8183a3ae647dec9f4dc57f3f57b52a5493d8545ca07835e724518ecf330e1eb3cbfd5cf4c69849f45bfa3d087de64417e87183822f1b308f880239e1da01062fa5bf66a82e12bb283d53cdca977eb92c2398d8ea2872c0481e017cd51f89c3c3b901427ba356298c279964f7081683f717bbfd02b1a92a8f164f11337a0272434b23f3fc9e34d570df39e3a59000e3267c83fe1f404d4a2b8bc33cc51ba25a6b9ba5a0c648e54c581f39ef38083465d60379a16daac633a7afa22f0a85e0d3e983cefb8e1d2b9de601ab3887ebc6ae3b7ece61df430c108ff3a5153118e89aea8a7d8487733f2807f0a1674ebfe953a393138afaa30fc3e5cf3100a80535bea45dd5d78672c4fa5c9d52266c22d201bcaf1f7833899ba40a0fe6714e9e22d583c806f1583dda4df22d775224463395fd66592f0f7d9ca5c5dff7230fa6fb4e8b0d0100ea9a6600f6585e4b21643e88e79917340ddc8c1056899562b28e72aa507d335995711c3eccf74dd0305e4c2e58185372e99b258de74eaa22dae071c03634ccbba4e8939008e43330629ce46e17729457e768ddb85e752c2549228cbf96a40aebbb7596b8ccae772bb4420c63d4ca41d90c0157c4813585d7e08af5ed64149a6b050608ac2d8ebbe0cf2b104bcd60193469789b8b8d43f4c7b4f842632d3aa427618486149ae2461201d3052c2dcce07f20c8a75fb4b43cb40b1f9e5fb6395072c2a1f3f62f77810fe3ee44a4be338f2358b8dc7b1b4e4a84614569cd3d72e0c9b0046cfe98e18d8b5c2a96a942794bfcf8bad4567a7e7e82c3a9536a2b36e2858cf0b2c047b7712af79d697549c0e856f7965e59cccfbb4f1551f0cc69224a2d93a9b0889ac765ae63c82e668146617b9b69c12a9a40248a8c8b32295f481837cb62abcbd934ae0b0b7c99098098030f39eefa70a7002ab63739c95a6fab1ae0cbb087e8cee9f165bd23ec95d1c362cac33f8f7b4764105a6fa76d33f03f4d9774d6e9685adc6e1d0797e0edb60bcae2569965eb8970f1048f3565368a33b60e1141bfb6c16fe238254bc9b4a54b4fbaceb854de0f07fe6a96c4d94d2eeabec8074f5a18dac2e9bf818f35209f2b84540d999bb845235e3c6b2a0755fa184bdaf64113f3738da928ebabfbf929b12ee7da187eafc78057fd3d757e6a3108b416b07057408fcbb2fb4d192d07e4bb4ed0d9ee4572fd0643048ed248b69add563a72c6dab34847e17b2b4c04147ea96b29fd931c6e3e23a12b71ebd1ee9d5b6963e3c714c00690cc3f4027e115cff9dae7375d121aff1e4af099634640b917ae400fd303056753ff32d39b83f1d0c6be5c6c7cac1750ddee7fc7f9223e19b8894f8fe9146a837101e5d1db7784425f391333157987e5192353ef6019d1e8885804e28f356d57f3586c0f9b505c7a45cfc00514b945e692717ff0ba3b49089f2827f4e3e41770a3a7e36cccff944a991a1c6105d2a88d2e70d71eaa7bfd5804af9ea479e1d3bf4feb495e2ecaaf7f42b1d02c25682b1246b06560a65de22e3df69cc3e3ff25630cadbb31a8d3521dc0d3ceb1d980eb1966fd2d85c24effc79a14b1de0d02f8ea02445d41931eb5461b9906065774d2d4ef2a582db21324b2ce07fa30179f877836788f60c6724b9b425d1711057bb7a2bd19552096e67d70ded4e16b47d5dfd459f6b9a0e1573ae50f84be4c47ff9a4584c2bc86a72be54d6318959cec0f35228711e52799933b2e6a2d5c6dafe220d7fff887d7d8cc528bfa583f6104c01ef54f2d73d8e145e0f6b97708863c753197bb9112d49a770dd85016a53d29163ca0e94fbd4c8c4b54000ec09de839d570bfe3e1220716b0ddd5e871fada6b3db68808577572ea2dbd2f5190b68047c2553383ad8963511fdfe4b651d116c6d885629b60f897e6a3308744aa25ccf6dfe130851a958f664122a8d237d19646dc633735f97287abe5fe1bfdafd7fbc12c1c8520f20a31430e1bb4a474d5674837cc772d8ff67414170aca2155643b3cb0f90a860283ae2f18a70d7faaee54d40a1ccb53f87f8e8592d1b28b5413751ee42af8d06aefdcfd4981031dbb50f4efca04fcef94fce1e5fd05a6e69da836bcef6b0d8208177eead907c7f17bd717167fcd20ea0a8a728a4c48d076ea76b9200f57cd419dbb5aaad41371493e2101078d4cf27f1e6e2eafbb27eca3167204e9d43e0ea2c0dba6d9cfc4642727f673c9423ba91eb4e3e1362ff9b1960fae7121189251f96c0aed005dde54619456fdaad9446e1f9971ad279d6da0acb9eacf635f67c257bbaac541e62a60a553b10f3a25e36a40565ce4bf2a2712d3cee23f30c44596344a7f56b226bb885e4958f8ef25e8212366b3e13835959667f872718088db84ac1a01feed231542d70ab069dcb4571ed30c8096420b058b617e6ee60e09de4f4a6730060747bd435759b2727c6e9330d26114c398689d3ff427d7d50e352952311444d76c2e29c57031b3b5d654f3881de0de37ac5af25982f56972ae165591bc6c7504fb1e6345342fe180b2602019b6961b3d2b9c5fa7fda05b8ccec9ddeedf70ec466fc1f06ec196ef58bdd804808ceef08dba7e4e19bb296bfa4c2da017f82ff88ff8a3b82d393bd6cb47e0c5283f99c69efd88232058de42edbedd30306f36c6eedf348d800aa2060bb646795fdadd61a2aa223d601afe48a706cee0c6bbe3f0af7a0637692c99dc7cf351754eb8173a03d416797d0a287e49be77c6785093a95d1ce7eb2bd4897ef0afd086a0d3802136b819d50c53599af83522f6492ca68fb0d5d8a4caee96938c10587194a93600799ea24f4b18800da690a3dc0f3c984566c0e0bf1feaf2bcf23e33ff0910a60df5049448a6caf6082c5b7a63a468f80729041f463481de1755b29e986dd7f2f8aabef5411ee89e4c983e18d151b682c631348412e8639e867990bab5ae91bf15256d1aac4f236b7a9a4397ee47428cfa89a79a460d4b2afc905f1336434cb3cbb8412aef712d968b248aae9e0813a9c560bb9acae4a45568ea67301414077416af32a47ad9dc2573c40bb5b36e12bd460a58a2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
