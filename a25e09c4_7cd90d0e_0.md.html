<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13be552f0cbc3efb3e3b60eff4638d8fdd0cc2e2b2ffc125f871a4f16c6d82e5e21c6c6360d3475ec20ef7547b80d65fea4471e4dbf2bd8a0e2df12f02fd6de6136d159f8d8d0023e14f62b4b4f238cda607105c63fa6e691b3a07b47e64e79c36e87eccfec36135f16d0e5118ee9cdfcd70a336496b537d8ce1027aebffbaca601ef9efdc0e1d977654b9faf291e17a48e00b2ad58cb119fa54110db14acfe30e1220edbe171559097d5d7a69a87e4f722c0f9c6ddc0db53577ae71b4ae7546ff73766499d1ee6364e288cd9cd34316aec5c14dbd985158ad42ae1d30b15c19e356beb6d271ba05307e19486dcb7d4fa0efaff7f6d67760a254c1c7f68c869aa904f84819ae6e996901c5bbf90f7da4883a2b04746080d26d97996075a2733bc22ab90c740901c0b7a2f7b3ec3a00539565b9e81a11c74745567326de89ac55544f0f6224969bae7c6fa4a49db6f85c668896fe502e67764d2f5daf3f2deba7ab1266bb15f48b7c43944faf503960f66271a3d1098d720cbbb5e8dea5c17dbd2e0a772c98520d6da7b6bcf9b2b25e100abc6d9276531148d238c6b8462baf2afe15f42cd3f9000fad69647ca2b45a8c9ca742c1ef10836b5eb320c5a2333fff5550f0b6720236d81678bc376a2a8f946859317638c2370970c3c54617f1103689b5cdd3625a75f950d70bef235583d12e8d28974c7b84b60014d41f4108a9d9e7411d14d4e0bbf66db41249b8346f3caa3f66c5aca130f01c0b141f91a56b18c6e5ba3dce7a0a241d87e58899e679a6355cc4580ce5cc57aa656eac5b92e9dfcff6d8b534f94749e6415fab0b9a8cbba6d08c43b7d875e189e82874936dd351745d292c9b8a1b38e41202d5b6daaaf1d3a1678faaaf89ab672f4112935a85413b45ccb1ec508513f6d3b482660bba6e17f130f7e0d969fd447523752e112f3c0baef445a89cb97762678c9b76d472e9e6808c9bd48ad40899d1e987f526ce40b9c9e562e6ea879f50541353d8acab26f201288b6f28b9cbbb20d092c6c1c07297074fa82457d62e31cf68c549aecab4849f95dfd919131818f936fd62981bc85c14b6f1defb4371c1f3fb7b92c2708da1d4ff37b40a25bf813b16a5e700b8ee91f74d7da1919c7a0551cf0aeda2a2a2d6be3f7acc98297d2b5941dff32cbe53a8bb3306946befaa50cd02ce33ae4b1119b24f124f7450b2127bfd68513d92770637b744c441242d465f16e40513126a8698981640b8f13fbeb3ada6aa79ef08e5ad5b4249c70d1d378a35f9b518cadbda5d2a0ab95436cb766d57f5518aef3dba0849eb9b5c6fbacbef8e5a8f561b67ff91428025d94bd70858b190da67d8a239c81da2fcbe06d61d2d606615b62af5e7a6dbceea08cb0174e616da2d3da7a7790ace4fc450010bc925cff8e0abfa08d2da4b4beaf1f50537fb8e12524c1785054a3c17e605100722da4bbff121447034c19acd9626b6f719857196f9541ea4be0e5d1aa640e75689644d54cc65b40c5f22376e72b04d7c8e4ac38f982c3633558d553d3a8a0a197d4abfe85b81a7d6b38347ed9ddd545114dcbc751c62fbe834a7ecf5abcca97baf40401760b28c68fb828c0550858be01b4d1fc06c8a2505cd7966301b164618db79bea714b618ba0f30a5bca1aade9651ba87d22b59f1322330f4728975556ecfc70011ca880e9408bfc4444e8131044d5aac0ede7e03f6aedaeebe919e0dbef2b098bf5c0f8a8b8078febb88f5ddc20fa8161ff037f07a04eabaa072dd6661aa5d96afa9f1c109dd4df3c912e255c98443798dd54ac022a7c01cdfaeacfee8e88ac75a0087b12c75c454a0234abac608284421e2a1f4ebc8659b2f9f8e8deb3c4f1e01186215be8bf4e4a779098fc86782a1f177f2b51d78ff3a9fd5d6bbb4ac9a1e3b9b30752358dbca819897f299626dda19e108247916316c49b4b3725d892820b6e593ea1323be0fc65ddf6f7424da3ddb6242d6034c2fa5adcfbe14da74e133fc44c0b48d79bdb67a04f51aae71ff8ce5c842a21700e2cb0062c873128c8cbb7b7588dcd861e4977a5f9582836002bcd3fa5bd2ca3a082d179997dd36d007a538bf9d2430699fdcbb6f904960936c834588e6c91179bb2f83ae907d1d4650b95a4b7cefd8fd6ddb97559c30e4e7ac0682439687f466967123e14c2584b83daeebbede3e7fdd4999c5e7c7a150fc12355b6fda629daf946a29d2cc0b3000ba5ed6e8930ab1e9bb5400add71f41ef36627387ff1d35c6e9af081992c047a2ea2d2a512b364799da99eb5c51510457d4815881045b4e34d726f8e5d5ebc2c7f15b332c4ad678b44e8cfa5771adbed5e57475eec9caded9777550c3617b71a3f6041e6d99153fa343f586e3d2d0f198dfd9891630cefc3ee2ba4712139f2b59ce291f4b9f0b1d6e04c9ecc7b262f15bf06e03a8d0a76fab1a07af5c90ae612099678a6f42333691dee723748a6933dc2541732e286482195f0c1f4e83e1ccf1d31a75271944c00296a8146e2299353b1f001a6269b31a83fbf3e3fba8d5c0d2fb336027484f9a8f00bf43ba3446f8144cff67448e35939a10f04a108700a428e525e1c6b8ff367c3239352375c2742260c07ac743b348286440b8a4b8afc9bf6d084118e88304077f6fafe2b7c279f7deed3e36f9a3e882e0a7f2742a7a17913b2d02bde345c3f05611d76a5a58d87db40a54696ff9831817da1abe744aacff4485c8b4b62b6f30480294b7f959a7a86d4c45cd2c3aae6ead5333e50e9df27022aa6fade59e4110cdcec94bc409c3b42a724c6ea66675a2a41717fc9b871e1c3933de3a1df0f6ac84e2034640d2f2ce0d7a3404323cd0044c475f0068c08d1d5384b8e997f9eac08d8485ee7880dc4bb49ed6f30c2edbfeac3133e43250276882fdba951f7d35ce8e5d9fe07b9a89686f6a4ba228c6633b9b4bf38f29f03fb89aa54b984a46b1700ae122c26183e52962f42529dd7986d9a1ae823de89d69e8977e99faa71be0104490e6b57352a9ea7a250086ab4d7c9722865a0c6f5432f528aa535058576519917b512df9bb875a63d0dd65adb82b292a3e51036e0bf3885176257a4849e6ab2ff9511e79842e1c8803db44446344c48028e3e794c408f9e92964f60c9dac3742e9c667c3544a4845c48385287b4dc57d492e9eec392623fc684b901347c71c27331484a926e4458e3527a37f979d942ba62a63b1a09c885265199a5afde77d3c3e6c3c85fced987a25e7b3c2fce7cb7efa6381a2df51e67fa13f87bfd1f10bc3cb3229d0035d50165d4789689315d3efd38099eb656d6c902e0adcf440fb11abd9fc88c36c0d2181fed0f312b2ff5a19e261a0394e75b2645bbd8d5b7014687d85154539ff12109eb16fb70f648648097472344e512902e4a706e25dbcc1b9275a4cf70b6b187c006d4bef5ee3ae388dfaec85b9722ee3f7a02a5e9b3bb4d7a13ce95a8eebd383fa4737275fa03ad08b249a643964143dc182c23986eb919c75974d34d402ada111e85e3f5448d00fd96e885bdd16464dd5d57091eb83e761967c98340b6358bc8e8be2eb16f057ab5a0c43b14383f964857130b8e044a7aa0fc53f9fda09cda4565cf3e4cda29849f1723f8cd001e24e9bc1de59c0d9653035e749bdce5d507b1ea44be8ca371ed16ecb05b67408fc84392bf1fa8c3416dafaea37874ed8199a39eced30c4d53078bb30398fb5ef9e53af959056c7ec48524a43d1589bc89441c76372d25bfbe4fb87caa199a6d7723c22f5ac93885c50b0c1f50729172b2439745d3f35e79f7d1719290f88dd50b9c696c99a973a61cf634b96cac5cf184b525932f51ebacd7886a90f5aee681c8ec713703f33b16dfe4d5e9a58a96ecd11943d5a7cb01491cfce4791f7a7525ce16c1e9d9e7fb0e31ca931456e7e8db75d278260baea86f45ccb824c85792ea989bb7a7970d60b7c7cc0c06975b133575f3ce5d6d95d908f2c48c4630558c6889414973912ad385ed88df5b478c3496f99893b9bc9880b7bc3a43c5c6d912acb2cb04f2b07bc95bfc00469a73a78478348086327597c2633ab5d2b4c3ecb828fac3acb3919a5ce1cd3c00332d40a56eacfd4b4f07dc8c6b281a8dc5ac4b2d38f2cf11e8f2b0e185ac0244d999ca161ee401dad8285f9237f0baa4f4986ef65e130b663a1c8ddcc5bddca6a9ef0784fd0049ae4ba7aeb73bea47c790752a5ede82d531223477e49c4f5d99f046c5db9194252d070eb3d8ff56ef80208aa7afb87ff780c8c8988fadbc1c58d457755911ce99a36439316c7a7a9d0984c81ed0f232100aba51d00275319a805f7b97ac0cd12ccbf7a594577cef88a481f1bdcc3de696fb69b660d3bf56a3049667deafeeb536db6abdcdad982f6712e4194895dba60f7b6c0682719d880a4b4cbb4e60662e24122465ce512f222f73e26560ce67c32e6606075cb49af97dc5d7c7ccf45b489e37c85fa79098c8f90f453f1b29e1ab6ff332565860ba5b51f345fc32df3fb465fd26603496fcaf7c9f39bc3e1e5b9d1a9714586581dd9f1b9accf660c4772714b75690f8a48e267da5082d1973d89f50c4fd6736e2807d9705619468923b5dadb66b4f1e8bdb6c2ddbde81f9fc1be4e0511df75e2e455a7e1cbbe0da4b781db472d67686b669b0cfa7ba50a79dee64e57b0baf67ba9f1ed3fe324fc033a7ca8b81d7e971ad576e3218c753f692e27e2940f0285de9dd690d13720eb88b49c1d4128f06a7d1dcf65145acbf08fc88e6de52a2632e1f042f9d89b3cdfafc48fab8d344e2c7b172601df0af22656da20c0e0307f494fd6b99e5b5eddcafa77c8da734c66842c2c5d154529cdd876b66d2d65787c5d50b97c02c228a73f031f2583a389144a29a1228c3690e509e0580466cd4263e1ebee6cea12104227bb9933dd0d1211cf95f27d48604ba2408e60e79c295c65c14b4688aa9d1707453c0d317d8a95ceb333d33486e8a92d5fda841e3183fb02c35853ba1b421ec92b2f2ca04c7c88a1a6607721130e70f3cfc1be878730c0620041544c0d20832bf6c8148f560a440e346df3c7e8f695494e9ced6b4a3c3b3a4b9e0713234f1a465708532d8a6722cb091e2e3280da5d799a9424821038f899472948652ddd341de1542b361491801ec1b206092784c654ea695dd7a5ce065aeb51b3234d5a1cee1a871ec2ee8e5aed7fa8858dd9b7131a3decd671725a6ebcac8a1a6997ac9c7b07224884a15999e829228950c15fe2455762c9ff5136b131d9c73ff6db18c01bb73677d9af8245f71ebad0584a4d3ba79b56d8e1f0c573392c6c8c4a7df689aa2926ac841f9d1ec434808619c620899d57777f283f3aee786348e052adc98b96e81c2b5667d8f14061e1247ccd2797fd72d650e2f449f0100b11f0a1f2e7f04fb60aeaed19206f39464736105db9fb3e1aa5557e19748197427dfaaca8149822ce27dfc8389f63637d5d1a35971a3e5648b9c202fc80014b10a04267876bcacdeae2ddad82ca0cfbf74c6a5e7b4eaf7791bd757503a7dcb4860b27320b4a9c45f9f244f8bb8c29d25aa6169779006bd40186063550b75b0705b16a4d371d7a6074d6d700aa81b1289583237d955ab3dcdba6588a9644ce5bd5dc2420b37364e763ce68aa33e4856d160f0f92f86bf539b590c4c03a7edf9dc8845b72d47ae4486a4c775e7ca5932fbdb330b4c52f006bb4099741a7e491b6dc3fa12705f05886bd505a9c76baa3ca738790b5ad9509cc0553ab6e6ef9447ba7569af8ccdf3397bbe71575b9d5e6e929f83b5d2d457af84056c2747d4f3b429fc8d510c735d7480f0d2249a6de7677e1265541452061aedfed6f0c91a452d2207084c714dc1c5000b8397b5132553667b241cc4a97a71733876860bf509eef5404fdbd7649e3c15150278f6a85796c85db0dc8caab915ce30270c131a7c2aaa2fb97a40022c7cd069c83620cba4e7d8bc49b2e40d51389051c9f6ce196e7005fc37e2ca7504223124b53b3036caf9a7bbd373fec47c585728a62228069f502b0ac46c99803c498afeed0f0861f0e31f34cbfc8a7d4233dbfb22154f7fad16e92c6d4a11ba49fd307b5a43522e2bbc6e59f23f075a0e1b1ed3da6a91680b95386811393a9c87d982aca6c273b403ac7bb2460fed019c528d01266138b6ddb7153a8cecce1f90547c17a8f95fd74365b8be23410cbb8f172fdcaf99bb8ed5f1df67e9c7cd399f0020f79d76e574f129f831f1b7bc0d1fe503f6734748b061b397e84caecc01c091a5380526b7a164ae251bf0b827686e7523d198f20f61c4d4c82df3a68efd17b5c96b8e6504336b1b2132be2043b34ff32c6b65b853b9bed54f10851fe15e11212dfdd807741035081ce78c3bb600ca11f8685976f605d39c474bd2ef24fc66ff14663c1ec91e64600597a566674bda3790c2ceced7c6d5cfbccb9e157141a1efbf6e62612e5a47c409c966b6282f929f0b6e58c4b10d3f244bc93e9eaee75f89059ca5dc40d8dedbaf9e6846a95356e0d63aeba2744f11fc128cede060cc02916e00b362686eec363a055009308bbe5b8fbe8cbde30e6dbf7594510e75d1b96716eb672f32f522021e694d968a8d3466bd037d03b738e0da0d115a0b8e577569efde646f1f9da26b8eeab1e5958140d9112838072e9f6da67db5c9a17c143422c294febe32504d81b53b977b392605ea7dc3fc892e0931927c92ce86e89e8fce657c2db8990757cea4a1a2c661e5c1aad7bc54a187576beb99000c4a701cb310214030ff5e4542a4c48c3b0776fae0902e6a329d7126d5fcb87b598f0ba8ac825f9748ba47cae345f022ba9569e2f41bd4877204dce78a0255a40c5fe32ebc3e695eca4bfbe0b1401648449c28d060f11f17927feb5c7a2ce7ea5e56c9051c4bafc032ac7bbf3b268a6fc9d8ca38ca2464d75cf3d303102c3d899d9b26e956eaab17cbf7108805b1bda71aad30730ca337118e31afe48dae55fb0b167964a05decacfd9f75108a47aa05d6a4424154f8f1baa32f1f6fe0de86faac6fc8740120f91d4c1c171aef7f026e70fa904dc7a898ebffdeb47b76d50c47647ee3b9b5c0d535e4d58d4d20b94b5d51b194b6f458276c93ab89835ac109155c385fe918567470ef456d0f865d0a62c97c10aeeb6b9de25d980581a44a95347cda5433502b0d5bf83d8734e90638d55da033a6258c792ad22fa3cb7d3878bb26f8e3d8e8f09b79ca436adef5a0dfa6b2b09feb86f297642a7c8807f60f2401f05f7ff579cd1047456dcacc22b2ae499762f81b2ce8b63b8fe74eb1bb5a551cfba07ab50501ab8a87056adcfe43c3141d7a71b37da206f28341d377f24ad106eb99b0e3755958f49b4fd3437641b35c13d8ed4d759c789aeae142c26782a452de77fb85a08516927526ce89c6069a22a3f1075673919ccae59e9e42ed7d3e7eb4012ddc8e090021615563b26ce3b8a14cff2dd31c794fd98dfa5c7ec0485eaff80af6b62cad2ae7c38d36c265d90660eaae4bebfa78d717409fcce9668ba1f8a44578b1a72c219b418602247df5cb8c6568074fe3e6c4ad07a74037a19da596705104e2555a8b53ee12dd6254c7495a005f90323866afc254491e85d4554a78e1afd1070361d58133e7f96f04ad1d7429543a3b0a1ce05c165e884bff50cf05a1f9eee27fafd31d6e96c5fb6dcad42908e501181629e9393da04f78586d54025affee9b09757d56b1b1d149f79aae3be8195bf8ebb1d5a099ebc4875f9c2bf4c76599d56accf48fa3fc79f128582bf4f58dd35c97e128ac3ad1bd25efc862fc210a1e92022a7528629f2fa53d41ff0e681be5abe8f63aff709b05b17395ea5b7ae523827f7dee9afe0e93f8f65e7f03a15606774162fb4262ac591052ce7a8a21b69cfcb6155e55d19410fde0fafff6ab504b533bf9819cab57cb5155a995d54e1d65766f99624831aec4972453f5d7958865da96a28564fc9d374ce2af3adac51e3543151e9b6439ff8109c1e2da1be89e53dd8bb7b2486aa9295ae3ff7029949d5d83f42ca6927bc6fc126800eef714714d93bc880f365dcef32131ff2065afbe26e4ed0c9c84680de38b6ee5a9ccfb66cd750c8a9cc2e60aab801d2ea9ef1616cc9138c139cdbea6c599c9f85056d3eac94e62714599c349fcd9de52d3a6da8a19396ed5ccd2a5630a18746d252b3f890faaf4d872e7e6de9b18d03967e73aa3b6e7b3545993f5a1a76373d62d9b2555e2606323cc2fc7a011b9354c73acb7f34f4ad90e1d13acd63db32e06ab1e929cb8bb5980a837f5f07e43568519b8af59cb0e6e6d998cc4454a37c5d7ed9770573e870e3269e544e361bb8929cd8a8a5a96d97ced8ea7e09ef0940723cf340ab87629a24eae69b0f26573521e3306ae6c6c5b336f397ab8cfdc102ea73ad68c34a6d797f31de7259686b795a633421503f6747c286dba3d515e0c7aa9e7b11dba5e22fee7c747e9a5d7b9fe798fdf39aa3d383acf37438af970773b694b09d974a7a6295096324412c51c617e2bb3c4fe6f704e560dd3c634dd220e8f096da5f9f96d567a8d07db72a57d171ddbc8ad7e57dce742f667b060f4244e7fb94ae9781dd8eccad2884c72c66f7e4d4e9274f2d4b90ab8be226a77d0d1a38345d1becdc5caf458227591b510c7d871f6d4453ed3c5eaf100ddb55506e06c5738a6d076c9764719ac2277ecba9f6853badf5e12d7042c3404eedec085cb12156bd362d2e33b37ac0861dd8e8f428df0cf0073c2a49132e8462e7459d750e5ecec69ba023e26638fa456a0b68f84688034455ce02ab0f944d671481972dc33c4f124d2542a296ed563773366d282a08b22612df12437dec6604dd88a8eb0ac6f62e3612ae492aa12b3b19fe7c1845b7d5e95f448c6568e0dea63fca8f8fc31bdba36a239d0a4352b7ccdddfd71f5dc0659deeccdadeba641efe2b57ebcc4174f13815f702f2f2c8e278ce91fcb8d630d8b058e0a4fb2a99b726564f3654d2b1141074a62fc85d0574f02d367fa696386d3a8468359eda161c0cc5911e8a8a979c108c0cffdf800541ce4101a4ac27f3c4e94b1e545a444cb888afc56b2236690cf8d393b377b9110780c280ce5a96658c808e6381d83aa4382ebcf93be8c83d343fff51b1497065267f71d3b2f012d056214d4174a7d2eda6d86c920e3a3dae055e1a575ca15aa10b26c77754db9afe91feba0e6e4bd9499aef26fc79ac91ba2100861ea6734b500c5ac6aabc08ff17e72352eba6ab650dac5e9332062eeac99a453cc8375b746f3a6d6fd2c9e73efbbdc404c7d9e2fb2a2e1bc81508615b2460388dd5f05e2e8152fbaccef5848a3f6939bf18579fce617ecf4cb298fdf86530c05cbce479066c765849ddc066c5341da6366e18aa5da7828525eefe03901a566e9e0414868744518cc1a0215f9505ed4ad29cf75f598fbd57c25175b0c64a8f9b4ad0c186268487294b52a79ba3fe8b5bb56b3de48736073192952b4d2a05fec8b542111aa3212fb4de601edb4c1fd112a709da7d12a7b1b949bdc2479f3fa8f6c36b9e821cb917cc36929bd7f7f79d26df6ce135e6ba911a5f98a4fd6e5751893a3d97d37ffadc40269cfbda94faf21d2134e2438b68fe46a1ad1c8d57e016eee2fb66f828e9400b5a899bbf573d2420ef55e33f76749126d4aa7f2d9900fb3441cac7a7f7da9e3f6203b123152638542ee0d38eec9f3381a1838ef796149af2ee5a0b00b806f8752f5686aa637f7276d29521e35e641b59bb8d57f44677c03b61d0fb7ea529dd2175b2dda1b339e513618a955dcce8e95a83de1cd730d290f2b726eb25a508b32be66bce9c622cdf32e813dd34b745183349c8cbedbc5025546e5231ea9955e11db4c227c90fed6d278c5a5085ca9ddbc5d97492757daab3c0b1a20c8fae29b048a4e962ca5d9154a03ef2989a694163b6b662356689a0ff9da8261b732be1b3a25da2aefd99e8c82ab6936e437f7a40c144e641b1ea631548de317793772b5f1ea96855b7ad69dcf89009fbcef61edf9e403c8b914ccb744963c7f20af0fcf0c292b3b74bd59085afdda6ee71058076b187e87fd4e16054f108f9c35813d37034609834bae6444d9688ee6bce8d86615a2ef5b73ed2f0274894bc76d773e20426bcbe5161126fab03e42975429263206b084cb3ae79223d58803468b6a4e0650594d3ea9b6504fdeb14e5172d7875d3e59d4e2600e7597224f70499713d037da6208fd96a787e6d09b42c03847f9acb19197a706ad5619e2e4b1ddca874f0928eb68083277512fe1324defdbf30f87462bf65eb63e8e99ace6449102cb4cddf6a52a937c212d069b6f2d40eb42e8ca0cea70b1914e338dacd778274ac4dced9480045d1d7ed7270105e364a06483325101657bce31106b3dfe95f2a11e812d88fbb68b7aa93efb3e95f0956a43e48c1bd3f6746cc4555ebf6cdbf5da932f0466c95dbb0fcb83676e97c2b0e76481ce88cfa5e5cb7bfb1104fb27949e067dc7d5b70ad3929c14d7945a36b173dcd9545b66e6d9d7ac16654628aa104a2d5b5fe8e23730deb69c2225c01854cb75ed64369fc9160889b778fa7a35a6bfd2206436c74ad251904d1bcb66024a48398b4c232776c3ce4d173a979dd82f6dc1c1ffa61dd057d71838982e7d46dc0b87864806de89912f45e98e5816cacb855243ecfd2518e17cd530395819d84f8cde0ddd1504d5e0b1397ccbaad88ca21ad093f48fbe9c1a7d890fab21fdfb22f1b5a65f9e36399637f0ba6f3b865cc5e714cb0b0f74195068045bca6987fd6e1d67dd86139e6ce1771c2f8eb61e80962097e3a96569a122915ba6f3041a1d14c69fc43c16fb70ca3bff131940e8d3aa87c7d182e10e551906370d36b25a37eb242c5d14539ea31b4c6cea9c2483d078cc249b0aa115890d21343a413d545f0cbc9ae98ed0859aa2cb2659ea9bf46466019cca2ef024d6e0dfb7eb04e40aac55427173de03adc4684c80386702ba41bb78e37adc0a0d0181b8b1b9dea429a6ca889ed2b43dd177c597bbe434836bcd8842061f49661ddf979afbed8f4d11d5099579a27db390cedd6a43c80b1942043283de3545bef0b2aa5660b891fd8592f418d1e48b96709ad10ad6137213b814c1b3b278a6f4da839b9fdbe3daee42c40f6225da7ebab0996f647bfc6eec5fbb5cd92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
