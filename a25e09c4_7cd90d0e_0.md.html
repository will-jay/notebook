<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef22825ad577392ec0fd34241f2827e0db7054832e0ebb925fbd95478a01d44ff080b85f71684f50c4cab26c62b5f67206d99476cf72065962332af8d581b87a3d27e7d399b3dd11f8f20f6f80df4220386b488f9c0c49f88a2492998e6fbf48abcd1cac4c0289987f8cda697d10679172b539bc967f803ccbbef7d5c001edfe468743c3f5387e51fdda667d31a9a1e571f32b84825c216ff10d99009d402e02e8fa0f6e74874f4b512d8a1dc1e72d78d4cf1c2f5603e6062fefbd4c6498fdb71a03ba311cf5bbe194d7486a00a1a2ad5332d8bcbd4887e6f27d5fb46e1e562d455d9df1d72ccdd99c7125215cf0a35af0c6c9cb208a7ee1d7756496d3a88dac1d8efa04449f01852039d51d9d2b8c081900aba283a8f22fe84588bfd5f0382ac905e985c40c5be969396282aae1ebac3fa9c55fcdd25aa3a608ea6ba4dee92762534b9bdb69301ce3afc3e09404f10061d8628bcef786451bc80af0915fce89fb86fa6e1d37a71af89746901945874d7f38c5f9d40cc4943441ebe771b9409902fe083f998ab5e1de260aef81b2f8fe37ad78c639577f9ff1ee9d17ede1e9a69f3f4e4a80a2bb6913c2c1df95774f46a5aaf99dac1b10e9ba278d7b84a131a7a58b2f6b34776e6c4b0c37fa544f8ae6c42552a5c051d2bcd5f20dda2d80a3539556cdc9b0be283c6e9d4040ca8727c8c3b8180ec509c99f8fdaaa22e9c7f731129cc0499c54c68c5d23d1afecaf135ee1d28c67e61dc43b02478d08f4168075dd8693ec32b6788eff4178100c4d3e1e013f339b835d034b6ca1037c94467af81e54f07ca53713305e77bbe7d6f23a820950bfde7f0803e89cbcd972f3bc9a4e0965cfe23ed4a608ff78dc75031b25a00f86c75c90c441be7c5ea74dc60c535edf2991e5686e369bf8566091c1a910518f12f8faf8c9d4f6453281626761d49e0e2ca09bcf326f9591781c5d21dc6c3bd4289c84ba64ab08978c7e0d1adbd5ed692039fa52ec28642f2d758693fd67de148feda665149c25023c1c83aedc4eac7d883ac2b93884933b00bdf712b61138258881ee0e9b9db9504c7041d60ef5cc898963ec95af869bd8b351f836c2d7713616ab9d0cb8e6262c9ca66879a9175a22c9b313f1c62549ee1669bd1a7dc3e9494f71dafd1bcfbba959866f54aa4a97d8310186e911a5c69261443220854bf9ee5c7643a5c8a87a27eeab9f924d282e1ae85ffb2644eb5fdbe26e1b3c6b20498d234771bd93b58559b836523f9b2d882be96047737f7f1224b9e499f09dbfd210ae75b2712e17e17474a78c8bb2425b1ef8c7180e807e8477aa8b04ada12b9e1e5e704e4aa766a9b43117dea51869bb9babbeb4d6ec6d75dfc87b9406428d981c1622495166d3dc72606d06a055ef041a436bef6e6a145cae9a40f92d098cad3620d8f0d4781373edcc05180c969af632e5601610ee747771225fc0a3b31e148c3237512914a1e7508eca235a20d482a13ec5cb97103de0c7bc80c50fe09f78733706d4ff4e239cb0bd5a37d5c4ac1342997e712781eb7d12f3ace25fe142e8cc64b6dcfe0a4f510aec2773d2be5c8cb9677a594736eede846691ac6189eb56870bd41bbe28997457a0e0abf3ce12987bee70213cba31aa975b34097b258baf653c1d53381e7fd41eb6059b9f1f56d1cb4e64a0247d0fbcfc1d93912dfa739aba469daee5c5bb3e70ad9151bd1b4e68e58d78c14e8f25b889c9f2cf2916fbd39753a09afb7adbf15fae572b13b40fa53079f4c6e4c1cbd7461908d93e2ec5f4d7ea7f2bc6a82e5b5250e32d1bfbb2839f78cb67977876673023e87a73b177d8bc1941094c8baa3dbe26ab89cb32f2ecea407426b94c0278da10269a6121be12e2cc867a854fc6641176fbe9c92be4ffdef0b0a9b20c1ae6fe045a04e0201b7aebff5b174cb357b5bbf95a727b544b2588e889ed24f430f906daf5c4933e4258c530792348f86a814fd8adaf1f6d3453985be988329acbeb6bf4a65836de707e1689c7cf1e7064cfaf0fd25f6c40a9281f8f3a4de746c535bf687990707f2edd23e8b96180a8372ef892df5635698dd063a573da856ec8b3e2d3039a90cf46f40c6679856c4a9f8685d769b3e64d11cd4eb6e8f88c1acfef03519d31649dc4f3adc46796ece1aa36e34aefba6c1b2246113fe66b10616bf203a1e172b4e36df55f1923136cc7825a6fbcd012a41d39d376cae85787aa6531bdbd2244af389638bb8e525247a35c3c6501317baf71b3892df231b933c2714978cedfb706a248de095ef5b807a23f41520499513ffd9d4f8c851189dba26acd8efa0e4c4aec83d9900bd4c516b066aad5ec0f6a25eaecb974698665b7224c0bcad6d8c18bab6a5df6ea3a6d44d776e1bb963388ecd2bd330f3d1d39a85a23945b851d3bf5a1c79a678d7edb25e4840b116ddaad98705279745b587aebfd4f6bdbc68aedcc6dd1309fae3587e38aa7dc504872a8fe06b974cd795a1fe963e9cf16934eb8690990bc1f438272bc5d1e34dd555783a154394218cd4d8abd3821a1df78368f0698f8d66639852b6887f3cfc50ff56a9e5a5318bb1e13946fc7bed97d55c14972bc3951bfaac9cd7ef23bfc983a6e87b9d54b43d15f3e2e43fab18cdd120bdcc8760250aa2d7319a511349989d721f60d30f24bb142a78bd923a148ab58df277c96695426f38a4e93a078f89c086caa26e8e58b32c45bfd6739beb58d1e7c6ab4fb38ec8f8735c4f87f15e26c9b8eff9ffdf18ce5352e45028e4f6c2b2a82d7488570576310eea26fde57f3fba6feb7f95626bb928e2ca416b337aa47f0b52abdb523c03a0bf59acc726e9e77acf3dfc2a29eb3f2772c698f9f61f913f046184cc095cdf06846087a68a192197511c8dc7b0801bea668430d81850987bbba053409a576b2d58d7b3b3f689db7aa30ba036cd965ef49a297bcbfe0862491665964c080f2801c15c1b72e5fb7b6d2e1e334a453d543cc802d4715c50f9a25223c97ebdbf2d6cd445924e5fe6beeaf8e7124b8c022950a7d1d947fbf7fa677b4860c73db44ffe9ca6dcdc50ec2318355ca56873fc42079885b2f02a8907acd2fabfb4482eda43f7b1504b9a73338f76648ab5acb58c40d1ce69f4c301a6e1eb995cf882c1aa6867f730394ba013374e8b107cc5d9aabd18c8144ca1dff5928714949d36ebcaef49aefc71f352f6f08273264390343cd6924c84c8dbedff16b2f0278b6c85d6283d7ec926d595101ae1c24526c13198e21fcc251f9a2da89502d4c81a0d459078fd891c1b23d664377d5275ed28c5e1acbad9a18e6a08d804f6a684f5253765703865a137be062259188ea3bb6cc6a7c4a90deb5c7d8a48d7d3c27a07a28f782da2701f5528cc94a513f830944dd847966d13c7e3d7615a74c287318661e70b9d69ce7845c7b4ce8d3fe81c783c5dede21ee63ca5cdd4f210b0e7664f25dd28884e56b836e5e78e3a66336a6abf1a1d872c09c989cfbec434178985887a3ad0824f7f6ab235d4bc8342ab91c6b15e98a50ebfdad5b7b66fff4285b61179b5a13e90fdadd87fef38366bb4268f527c386933cf4cd3444ef3daa48e52e250c26fe9fe02e8b764fe54478742fdd2de8c64566951ce457dad54ea5ed1c695cf8aba7e65e3be429305574f4d9850f9c5ee970fa450a3b7d074dd36293e1019fd9ea6347d0c5afacc0bf8a8e61d84eb0bb8961c62500fe18cb13dc27b230e0af399ffd16971a374ed24fba92670336c59326eb1633eff966e15f0a1d927c9e2672b0d206b537b1d10129ec96b74da6bb83cdca64428f356b15156f32cd36b7012bcae32588fb70d73d0bcf9ab4f3008f35c9547092c63f88f47e963bc383d6a1e70271709bdb4fa400296b3803d8eaf7871b64311cd24ab4fe20d0d7bca612c0cf8db83ecb22dfb94ac27f1691ad2bf05e69178ffc95a687dcc97199aaacc68dbe1e02528d0fb3d37d598985df3ba9e17d2c128bf40d494f9829f56792fa69a8896ca41083a350b1863e5eeb482f8ce77c24037e095fc49102cc53397614cefe21b9f73de260c50d8c0460f7ff53231f1cbb7d05d9c01b4b88351403f0f74c7c4ab45803372b1a5e70d2d6df83b8e0850ac2194719a5d9ff3c0f3bb9a1f3f0d66bb64e12a4a8cafcdc6eb3a55d4f3c880f194741138d2f6c2696902ec01ad7bd9aececc5fcac070cf75045a15ad8668348990b957d058ec6ae4c8903360a8733e19356f0727fb237450a2ce82ae134a37bbbf3e893b06fe860c36236dcdeb1dcf3f7420edee18d3559e84319b911aec101ce00762bd95db341edad925be4638549016c9beb0564b4274022202d1a1d66dd6c934e81e714786eb2b56bbab9edc28cb41210842b34a625ff7b19c3ddad1020da18b0a1af005f3c19b9ba231c39d60b316c0cedeeb6bd3b60fd2dbb562e833b15f6fff30314ba3f7c73ed25431443c41181d40e8f580211414f7fd16ea2d14b36c79a68e6b62635fcd9e998bcdf2f781d35de250c78add647451cf2168d875669e95452871c65bc5f4827dd6cee6acc3fa6e13f6e41a52533d665525f719db45ec2b74da69a5fc224cbac52e9c385663f2960cc73a4162c183ec466c48737c21964f62daecfb1c0b04f7c0dd457a063abbddec079f88f324683723bca652b3a54a60258e3d58e5bb122ce9ded3537d83707ac711037b0eac079acf1f323854e2aff753c3d6eceb8b824a77bde4a6030143ea2db44d920fa4ac2539e9d0c346be001feb16d143370412fcc080152da1b29aba5ee2703e193da92409470a090227107c575066b3ef044b28e15c872f924c013ca4da74abfada8a23cf9581d0bd43b9fe25ddfb56e9ed1715d83cd8edd41c34cae10d733610398772b9bcb76a80e230d596db0bb6a700f1c84005c1a50efda33f16eeebc9d0142ad0872e610708f1a3b04e63c08f2fb04a256e87ac1d82c2adea339b1d459a3015ff64418a72bd5d61e9b3ce4643d2d68c250000c8c6a78f39e7610e6e47d5dbc1a5ca8acb02e8f2352ad1fc4e2c9ca1b28002426a8d2f59819cd3818720e19610daf4555e5a3f304b58bf19778b2dbfd5bd564e99d7078e1e56c24f90498acca0005482c2a53f4ad6a2b314507e191932e72b376245088f75f573c60aa87f377d90308790c812d6bb5297d1ae4c4757a72ad0b4ad21a6566636f504b592ab4ad80bb5da4d9779cfd7c74c26d000685554617aeb441765545c2ea0bbbf8e5762270e47b1e9207bf162c449eb0b391d5005ebe3271cc32d16ed950b86e7385c6462456913647eabf421efe14c2a98b9094a3c62c14afe1b092623c6a38b243de16e3ba96dad77034b2ac082bdb31d2c2318367b4696191cf1c1b2eaf47d48ea05326260e0a1b3ed8c4f7d263146418a809333db28d16cd191c63a6b3863df5eb913ce82a8c7b7eb9f02443e5d164ff064758e2ed10b38f797afc5d0f6fe8944b82e22008f362300abc2f98a05095aee61ad7819603ecb9b43158434a93093470f368b3f81b562a8def69bda7870a2686f58c4a0e7f61128f3ccf78b40e77395e3a611de59766fb06933f3cc4c197f5c38b6d8c4fa2120d85e859a0688cdb7efebc9c618c3363e047b95c260b3d33ee6f7a71ead13327f21067cb500151ec1d99229718fde418292f38de2e44562404131e066adfe561cdf68ae629678b524d6c60bd6e32cfff05661b879bc6ddd524f601b4befb7998afa566a34eabd285cfbb8ac6ee668c91d65f0045c78941a9e84be2c2437aff2fe23912fb3a151bc03fe914a9b4fff728929fcde29cd5ca2133f851392cfbb247d8c274eccd821c56353607ba64b00addcf870f3d6a3ef8db98f69778a8607b2b7dd5f9235b1eb18ed571b8933adb7d650e703fee5fb294b81d6a3992d5990365ec385a654bfe88a208dba071511b8d8c518b2f4f764c1501427d4b47bcdf6cd3faa0ef1b5f494f504ecfa8fe8df8d86f152b7a80099c8139fc6d0df08a1fe46c2c421d94344fbe4029aa90f9d6cecf10191e941ce7eec60edb4c1986b597478788867a10df22b627485785854910bc7902798b0fb63c6d5aa8ff5c7e5b8867b9eb6bec27915309df53228e9129b805ab1b09798d050d36181acba12f0e53dda482b42782017a1db6aa505d3544be4ba247e90da338ee4c0c6266e39d18f1766b2929557ac2ada29a6c30d2f527b738e698cf28be460f02aa9cccd0278eb650912ff3f4a2bcf57fdac493e7d8fe585175d27605693cbbe2d2a0dbc1d65c90d337c4f9aedfbc629554b010d4f0d31ec7069ee2cbfaa3b6e29335c097a2fd00d7b9edb1cac90539f6b5e1c6fe10c7dc7f7051707b3086a3831699b986b0fe92f1655224ab93f7d2f4ff5c8585d58bbb02c5ba0a15fc77158f0f4e63a7197c70334e0b3d3420d420f24675f03682a80562aa2b9c8b08488a3e9e09aaf42a83fce88f4801a932e4165b06161f9a8a0a17610baf6a9a226bf8328fb27d8ff5321641ab1211a6c1ec9fdda454202d6a430e1498337b89cdcc42d42149bcdd046edae3710b0f911ef07d5a69c96944481c220600755411aee3bef3a8bb7f308c1cf59cd4d21dd253b451447a1d8936085efa39893a8a0a39fd8edf0335184156ea212159cb874a5be239f7a22215e7b79384e956de25188afa99f95dba564577f4942439701a0e646489150640f32556d87163b947a639464002a481dbdf665af5bc0d1823c98db24686938a6fe240c5993ef9f3ae00e4e287f5687f617253d5a024c0d9ecec4c719d4d2c40a8e6db26ee18b2e810180eb50a48a76aff7330fa059a72eddc49c184912c603b490616fb84f231417ad38ddcf9d49843ae383b8a017223ace3957cf1029aad3efe4678c333169f91616adda5ea8dfe77ac87c0a03dd7776451253f63a685e8f7dcee98f41a2844c8feda03366aadd0fd41398880f3fe2bbc0151c8b1fdf5c49ac8d41cb213e7a76d8e2019a503cb4dec3fc3dfd51748b02ca860e138c4297ccf3a387bf9eca918b4a3dcfbf5439dda702ad2c089a75c64ece3abdc818b29904f925b61db2f4e84e9967a0fa5cc4d3b822b76f88e6ffa980aa5572f9c22e164e2636bc578d228521605393ee644ca25f6632c3f4b4237e6804be216f0c12a356db7bc609e603663ead681e0fcec5fdc605ee1109ac9ead0cdb0a5b670fc39be7178558aec300ba195a5771f8d54efb5cef99e29b40ca36d70e094fda0b4077a0f65b6c5727c28ce7dabc468d810aeb9adcc8a94558e50e74802b012b42cffdf1ffef998a1dbe1355cc95e6f7975e542485b1217c5f182519b8e747e1fa797831a2463f659026451809895ce1e6b83d6a67357e31fcb419670fdc22d9e92952a345ae1167584d2b907a2bc9e8c010da771fae68ab2a1ae5a1ed0e09a531719ca43a20bb613704b486b6970ec60bf9ce1c2631c5d664b671d1952ec0cfdc6bc12b79867205a2cabd313ec299f2cde5aeaa29738fd74f8e276eeaee46886e3ddb58051a344b793c4496a84ba5e6d57036f4d8ff6ba610dc62db196fa758cfabb4c3a522f2a0de11f533e05c3354cdb14c0e44f9a88ed19ac57230185c3802b08fcc02a7df2dadfc454725a4efb7bbfb17c7ed294b16bf7c98542cbcf7a24e407fb42af1fbebec0868dd16ea037a3b88da453407a27cd77efecf5aba8ded7a4be2ef637b21ea3c3c49320fd2e69035ffa0d8348479c3bbec7d3feee756762a50b563d5a66b0cd316493c5e0e8aeb5f7167d2100f2aabafc03aa11d2cca5f3664c77ad4efad13b57feef65c20e319eefd6c3b46d4f530f0677be83c4cd72f521d251468804cb99c0ebb8db8f80e920cee9b663642533fe25db30464ab5329ba458417217527fc4aa5c33dff4ca01d1d286a780c33faeaa601a75c970e95426b4ece587f585a1262b47adee9e26bbe530e3ed843eb47467947c9593dfc260862dcbddc7d4dbf934ebad340f15eadd763c0ec2d15fe1f94242b6b5a284d21d3b6a0374eb16482e43151d68160e8008b132f6b8291b133ed76bec145e24e46da79b71c3a265bcf882ad8ceecd597998565a2a09ac01b423a242fe1817f9a1742eea29285d2de361d1197aad927afb5af7e3450c0280604f95ea8bf9125d09b850ff78f32db3c3ba0523e81f871cdadfa3a7bb6943cfc63d81d6a934dbe1be05226ecdffb75c923dc04cb2da29ab433b45b5f824a8c8b4b14598f7e4a24c3bd37a290c19e03a000454deb1a33ae0e71f9dfff11b4c0ff095ac9ddad5f5841d16881edb57c24fbb53ec530cbef518e421c2fddaf790689e5e481366537b7745d3247e3d56a0747583cd21a09cc37d48e0f787c908a16f3fd998d8869869ea4e914c48b884ac621597ea3e3595941d4477bc87fd2b3a40434a3452ee0bd0379c8b1bedbc5b3fd52bd00886ccd71d8b9ae592cb6591b951cfda0ebeecfb51d0c11b4bf93a30bf990bf920d98671559ae2c643a04d6819f3924c15e557acf15b10659d9a6876cb555d3a05c606bf0d276fd4ca50028d6b22fabe20ca95115f1745ac00a829743eedba822e82a34c990e06c9ee44473cd1ff6e3b618f6671d77939065fad03703cfbdc5242327fc464d06016f558722fb4a3e6b26d39b50acafeb91b838f24f4f2b24eb1f24fe9e1b69a73b27efdd2f7fdfcac08062b980bd60792ae63f4d62545a632de4b5ca2e252f759e67f9b7a62bdce52aca16b8fc2cd3773cdc6168ab5a0e754e1661368d7d2718edf339b97ed81bb1c8341efe2fa9f39f174d48a423d9940e3f0563ebf4b337d076e442a47f8a76127671e79e3d56fe0b146bbb62ac88a39261140d70746e68b832d7747b7fda5f1031c65e589b887c1f7ab36c3dc9c7ca8b935da4593f7658e631db7fa99efa07293bafb7ef41fb3e26f5c52d2b566953954870074fab4df1c3d819608e0b71177d61b9ccc7657d0c70389709c7a929b47f6495a412d4ac13c3f5fac8f740dd146bae3099e9f11fa732a432c4eee1a6ef2ef7675606b6d27a879c9c9280ec9e4d67c5be12457eea1222fe301179d2bfe133522eca526261281abd3f3558bb9f27c90d40e97f046f2fd661f99ca07430f175b901d29f4121944a37c249d3f2ab05896d025203a251286a6e8cfc779dc3579b444e2879f2b354559a352b2a74e818d93923da4f3af97cdfe9de733466a1eb3de8ee14fdf0ffe81fdf34805240cbcf03136fb6183c6fb5ff7374d433e3eb3e8764cb26f7f3a6b860916c1f2a104ad1b4bbe0c65fb1e0664f8d012033d678e238763b3eadc53d83ce175dfa4f7e4282f4e165313649f479816266d95d3550c7ae4eb973478331a6aab123e43002b5a6ab84df88c429ea29e8845789f23628588e30d29c82cae0047d60e9d45b6ffcd8993a74e6a05b9cf705e0f7bdfb80bdb817d7b54a12105785b120e6da583c114bf8f1069bb8f5ffcfa87d0cde1e118214c45c3bb4d09554bb3cbee05825ed50b9b496920b5c3245c30d387a01591595fa2d2ff4e03cdf5baa05943722c5e6532c2c561c21e1ad310ce40f8a36c39ddb4f8c07c8085680ba5ddab9d50346edccacc4eb0a84bc7f128ad30316f9069ec25c8de2a16a3eb7d801fbcec37d1ee8468881f6d27bce77072676cbf58bac8589594fa3ffe7f6d08241f66c8b28a1380339dfe0a5dcc637c191b65b6aa3f5ee7219f07eab238bdfb92c9cbdbe0d579754fcc4c4a7d7a8e491a6cd2034862a2501b189e466392d91094af2f6562bee0828f19cded3681154d2863fd660ce8efeaf1658e639584c560144eddffe7a0316690988dad75c587c03a6dc9ee422d4d77b7fd76bed3c383f65dae5581d2978c6e789c0a095d980c10c9862d33432c36bea496bb23c2d4ea408c06ce348294fd13ac976449dc8d1e90e37aa8fcded9018f84d176ccfbbd7ec646e06fb97a8dddbc18735c8fd9ba2fec721a330191f187debf2893078c5714008e5599f513dfebb5e410f143f917aa19182abc05851537d4478fc8e461471f33cbea066fa5becf1e1a9bb963b76cbf20e72d0d71a62d6b22e5dd02562d578453e609c0d9ee3ffd47c33a68c37b80f0601bf1429267ef23d6101352fa2a67786981caca40fe64a2828e624974a81e9b92126ddc99312dd507c183c2c114d1ad55a3905305c40facd269e9448804f7483babccdea345b7734469110eda57ca033f04c5ae5591c2f0c8581e68c6753dbcaf15fa0f376f210dc535bfa1086b2fb153adc110493bda896ef3dd90ecbeb5b9c3adb5c17c724b5ebb3db31e1ff3de22604815b39211353e15ec17487a73b258fdd7f9585c290d09c6a1a7cb6f2e702816a8277b218d045b249fc371905ef067276b73ad4984dca50df2c752dd67d2eb108c60ddb2d5f0b6296730ac728268ed4c44d8617035ed95b2e00b65787a7440fcc9a5797c8514aa4c951b16581758ccd66cc3205a3568bae868dfb8fed813cbc7058ba5d6262efafbef7de60237f7fde4935b1bf1ec867836a64a1c666b1ec59d04ab3349e27ff20a7132f4ed988dfe864817ea4b8c64459874193fa0b13c298765c54a3866ab8b54c7b31757ca2d18fd02e55a0a8d4844240d712f9eb5935126c24159f63d0eb0597940d0a23fa4fe00af54a7677284bded0505c7afab0a9bb5e05746bab9da31c1e78b26836a04ce5dbb0366f5e4f89e20261c1a417dab4a8a6743d416b18a38af895213a85b31b70c4d586d30248b7a7701958643a2d3090b4c0bd72c9b19180e4463c3e00735ca45c76526ba79ad82c2a9966954f69358f6c98f37e8cd49879e97f95b7cf686b40d5920ea83f3325f42fa7a1321e8765cffe62ff829a713dbd7ef262dcc59e49b9033a6753501dae02a0ef62308dee900b240b25e726b693211046f211ca98b9d75b2113d57563479a1bdf94195d18c182efdcc5b2bbaffceea76672f27ca4a627985159d065dcafcff744451c8e7fef66efde5fff5c92453678447152903f8b0731bdea669164e3a4345afa781554177a25379ee054885b6eb1d6889b222308509f17c4e0204294f13d0f3b435f260b5869115411bc1268f5e2765aff33727c2d76d514877952b1c5ca709217b2629dbc00089d3d3bec9548d83746676517098cefc76a79fec2ffbb7b4ae643743fe7dccc6f639eae13725fd9f0bb2dbd0f7bfd061d07ddd89126028bbf4aea19b5593b2aa4a3db3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
