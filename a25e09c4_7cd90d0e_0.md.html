<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7ecc17a6ebe9ed4082122d2aca8040199dabd552b7ac3743fc21d96d99c6f0a074e314ac75f4e09dd22e10eac50855811df1487b96f6775b40a97e29915ce8de900e9d8db675378ef96a9dac08698f94512bb8ee496b415b08f3db77e73a6a956df908f2369f5ae82bbb68e7ff4b9ed3fcbe10579928c8c98770f52a82ae1414e27b7d7cc79e360c43ff0b9efaa4407e704ccba22139fd0f243915612f434e470b10470d0d30609121d39b93b152840eea17ad0f89cd04166e2a0565feda20e7bc22e43b011a6121dde07366d444c352f03c303a38973622d2f94b92de39ca9f7e4a60949a74e77fa6255e1f87db05cfd9d5885866c46e99557be65eb0cf87aea5b3640a07f74bd41ed5f27bd6cb0ddc388926b25bc4936dba55f7e2e830db50dac50e86510adb70e5e4e3e073ce3e6fe5c26b9e73ed6cd9bcd3064d8146ea4fd467761afc4a5caeee7b1c5c972c26113709bf4894a5c2bd2b07be70df8d213017e5037d11d50853990f9e39b731520f5b7385b3622bdba4b42c8f423f0bf39c9393e93975e41d7bccaf2a630b620f93e0a9e21f23fc26401aaf092a927fbe30c7ec1bb7d7984ea808c0d48b7f40c7e7b018d7c110bbba2878b57880b030d4bbe667b0c1d5fe64c36a91d47d9ceb04e263fc8bde40771a67cf5f12148c9c2013c2f7907fb78c4e6f64b1cc108a94f2c6f58cc6833747e69d38c652a3dc07e98aca8257a95eb71ff844147a1ed5047d180891690f416f244716f27b51621c3b36df76f3cf890a691b6f6a5903a434753873b7ccaf03691f92c7c7eef69fff99067e3597680506b863c7d8a212a04301c504a9b6c8e5e8f4733b59c2464cdc3e2c038d81ff4ae792cb241ad6708627ebea6fd68a8028e74f0243d07885ef912d43e2a391d49a65b571d72a9f7f7af742446d7af1d1f02e7723a7b556135e0ac950af431521ec74cc90c29f41773f5206b019b1af17dea0150be91268189a141fbda15c86f8bae99b9e60e93376e71a886ffad92ceff27e8008a0e3d4657887f53805e464e289eb31bf1a7bd00acc0b1271126a4c4e75d4a7c084832ad08ce06270297b816256e4998f41430aa1f805fa3bcf6cec9718e8b9707bd13197fccb36bcb6b59b1785fff3b47bb25444b8dd4325de97e77d10f87c4438f3c95f14d0ce38a77a67ae55ad16f0a70eff441b0c58cd630a307aadd0e0d1bcdc218811a85f74c9e0fef33442d7e45b9434e89c0ace066aba6d77d4010adf7d953533fa1737e1d3cd354c3030290e91142897248babaddd124d0f07b3fc5f160b59aca7ee62ffd411e208eec1d25efe848daac817b36df0fc8db79e7d846ebf770a29d42c31beb6665c0c30d580dfae4e283d2e0a81aead717c10c947ac05d5d88b848a4a18ff1752ae47a6daced6779bfd945979684f6e82b9ba464087757937d572556ef35c857902fdca9976d2d4b43c6666dbc366876b04fbbd169f786d756172b1425c6d9c127f09e6458b12a0a734f4d20094f0066795cd7292b200df4922e20d819d2f5de85335aba0078aa0604012bdaca5c1767d337890a9b69f153ff03107d0367415da7820e40babb89afee52f6bc95ebe789b2fd17141795184e47817e89bb39c1a4185dde5cb60a99be6ac3b66ca7d298c1748a9b9566174ad828c5c85d797369a10f07d84b810bf4c5859e2bd950383f7a173b4ba02c053fd77d92c189d0f37e51b798346f88f6edd86374cc17b25674dde48b181701abe60a7877c6f0965f645389d37c53f9f3cd8234e1248b1bb89387ddacff13cbed175a6ba72f247e30d44dad15aea7f5b6b98925cd22b39d0c0b419217b16acab245e9af754dd6873c58d63abf4c3867a746f98f248924848561d29c75b273f5a7800d24ed51bcb800ed9c1d1110ce30d89a78d712891638fce284813d17b4c7a126a0a4dc1ab823fb858d94b5c43f672ed949731dcc81b8e07b9c55f324ad1c84b2875db7f6667202aa61223a7cebb3d30b7f1f294f587e3c95905e1d4ce92346d4bb0f30cdf829376ccf607596bd3ec3bf5bb5aee6ee46e871d68a7c8d54c6522ceaa3f8963891a1d4b549fe56e4065174f140f734ad9303101e3ba0300c14a3d21507f3bd558080827e692a451d512e95f1f76cf3fa930323f94b1fe883c78a808eda9fa0be1482c3557783b9383c6967ff7f41aae806e2b2a62e85550d070c40965efc3338c7ca8110e8362450c82d3d84e4b026fa6b06431c4f75f749c8c29ba801fdb485ebbb8b2185c2fcc37421a8556544fc27b31d6881b285e27d22532fa1b1157263cb566fee3df064dd01d6112a0e8774ccd578624f85af7a88d7594c3cc9c99dea2f21eb61f33f36d261164116efab7a022d2e9a0079b0defb949ebf09c1c3de031f5b2959a31a784b07e8d8ded19da929fe64459f5b2fa1af521103f54e8c3c23affe7f264457ad44134522f35034e55b32db590bf0c6ab200563b536f058e3bad99f570d4b78178979cfdc74f0469d992c05adaaedf3728c791c064ace9e9c2610056f69cac6470afb7732e92baa7b183263dd266b926109a4cb008f576c6a75236e359cd5609b6f854f0612206e276a93641441a302f8ab837fc7a118146289ccfba357f6b8d0f519240e32fa4d6676bb97a28482bbde458e760a1b75a95aa8e31e642b64c993dcde397ca0827bb87eca33009319d0a948f09eaa7b03543fb9f6ab6abcaa58b1fe25080593f2eb9ae986acc1788923545a099cc916f95abce7bfe935f7abc5d4ae0075a113a1686b614a4f5a945a65bbc9e4795920834817fd25a8744d0bbfaf4ccf3e5f9d6a5d4e414304adc268b1e77b133f46d4bfca9eda570c96d678140ba64b7f4f88e8bdcfc85b204d1ca6556791aaddefa7ac5bb905c7c0e2f7dc711bd46518bc696dcff29cca06bc76de1c5bb1458102b3a4e1969bb950f066d163003598c5cd39234f1cd98790ae810ee2ab2642c2c8ad9a1d595b439871bab52a8694b5a37c77395d61e63c3d1c02f3092488071dc8fe4ff1c7ab9d03febd8512c126705369e99a1c4a8221eee2ee9807d21e04af906acb6ee04a209388511dc6f0691e3afe68d88cef9061246e88ae907ec36d2a04e64ec77a45f657578c32b01ec0e14a4d0f4ee3448238d3bc4a0cd3bf6491903c8e7232a4c25675424699ca36743f5cc0e646442cc97ea60038230ec680066cf8735a740310977931d648e9357400b7c5fee6a337e60107059699081ded349f902e63ae5d7cc6775a736cdad472d35d48a98a52ffeb7c3be2bf99db10bcdc3ccd66a1abdedd6fa1a1a2723edcb0c425bef3b22e1e327c67e0b7f8de308436ff320858ca5d08b83702688921555042f3ac9979d3db3170ddfffefd1f184d21b41834ec2ad822562e4b3bbf8bdf9100e36017c8f98066cd9f72cbfa222a4e272c4e6ae5b5a7c1ce4c3a86751a8fd4368df3746427d713780e9bc87f25a2044ba9f26fa0c85c600f43ac7ae9077c470fbe1e723a872d0af8675a866bce56fa83d1a510fb4ea4c779016d1378b62453ecb9a750b9cb43306d863d1a0b17f348cabe5478159bfeb6e63aca5b999380ab1bce0b1239bbe7624d016742810fcf954dcefa930d4e1fe03c628b2c1c7d13cb7c7d25eda45a52e05e0177cac9fd9be1eb06d878c514f702e36a0f5d335e54109de8b9e63fb17391a695bbadda2ff621d3f0bd0373d74347a81944302629523c9ba16da1c09653598a1e735c1f22ca66670095277186ac3e1dbd822637933f6a70d88767bfcfe0e8cb0fcf314705e131ba757d891dc065a2ce79603b5933017e657666dcca7a2683b3cde192963823c7fa3bb57734dcfd84dc9183ff0561c83ea13e6b2a38d1dc35f47eb952716e4805f0ade6d687e790489477977b8b43172bdd1a20efae441acddaf1144ec8b9c7a7fae0f1f939f5bd9f0442c57511627ba3fc6fd164b2e700d51dab45f1d32a264b73fc3584ae1351ce2b61f6286f6adbcd4f6140a53997820551f446471c9b52a4562cefca5847ba4bb8972b9115b35098fef37fbffbc560acf77eac62ba4ef52222354b13fa661984f94786d5b0edb5cee1a22a0d83819441cbeee7273c4517eebb3a7eb660ec91552029a6819019d695a59c8a893e4a30ee91303867eb4b613f74daca86bb95d1dd273cb07c9004b8798993878f1f26bcbbf823e82df43271716ec96a657955094cc66a0d2a042a0425b5e8818565ef1b871d7dcc3ad95196f8d596b177f8d56caf17cac8e598200acb21f219bc6273e31416e85156376d5ad2e985a449f1b0653ad64036f32df0da303c69287982dba24339ae2f9b5c3ef83848c9283a61f6e27062d78827b572e28809f72e30274104085d2046ee51b56a12fac99138de7e0af8a2ae5ddae604c9ce708b6dd403d61fab559bc7800078c34af0166ab8132949fb559a6c837f23d044587f1b152a2b6b6ae6c132f4f25896c12883cf9ab2133c231a1ab4acef901275476b52f726ef520966abdb28c4b1e2cf5c816c6d4aef8270bd24d5d68198527b0331013b5138e199a40461dbb175ad26c94d06727816c242942f7711b26c99065b291824da8d50b386956ae86b76405b530da91955220ea026596dec51c429014b55869f77b50430378bf3b0691954ecd1a53965d4167613da00a25097be501568a9f716ce92e327e79e1488767cc4e582f959986d125ddb647bbcbdc15b6ab0dbb5d963c0079ad6bfe7bd43fddaadb14d05dbb09cbd8581c80a17e75cd48804a11cbe2a6ca69ae364701cb24bb47c0116e2a17e224ea06a483d1cd5b9c0e3d6fbb60fe3dc6d436cfdc9db38c70075ae620dfbd3ddd53de70fc8778cbb0e1a9e6571bdfe6d0d9cdf62adf47b0ddbd07cb8961cb290df58354eb7621a67337241d7e75838bf8978fcc8caa98d9d47ef6890a9f756bfca82234046df5e7fb8fe5af883fafe9a23dd1486aea174ae8b3448032a3c0ce1b162126125f4729a6d5531741369d1dc26e4dcfc47a5235aeb2779686a0843506f3bd36a3184fd0a53112ed0823194d7a45e558b3177b0c67eb3298f0fa9512e5a22024d32abef550c47d7675e082e794c5648796b71e480d64bedf1e434a071a3d1c64215ef1cf759d52e0eeafe990103ae60f7ea0c462688adf561e686d5947ae82c576ce00a591d117d5d3dcbe51f1864446d2e2a231a16423a6957891cd7e30cdbd2afe4d8c1dbfddef1374df05734f471c60a1177f1a5bc55e1aa196a7553449f2e814e0f5d3b49855719d7235917fe0ba31cffaf8ce691e4e65ca6378ce994e40cff57fee80d2213e08652cac487443dff83a19ea967584785a311b0533a73180ece4f9d196c8292687e5273aee874858ef5e0dc5fdec7fb3381109eefe489efda3bacbe5610050a7f8ac781c856927c546d1653b6e3b04faedce28e135c7deec540b5fdc90310259c72030694b2ce2e8b76e280248ebd1286ca2d4d665a7c318866ba47ed75452e13b5a0493c0716f9e4965a321be18522dcb3668bd27a8240689e8a194eef9b7b5e7aef47bb8b4c5aa9f796f45fe7152da8dc11ceba0011c7088e8d3bf09b8d7decc096beb7eb519ff9174425f06442ad73f9235e987501279045c082bf02c3f0738d576aa4f03c7c839ca8c24b4b38d9f0ad6c6cd7e5ff18dede3e3c5d58b46f6689105f2be4293ed21aac6fccad4c250db6980881f9e6ad5374d44522b97a116988b1d0070d83ea917404ea45f8596020ad393fdc4b6a4256ec65112f5228f000bf0ff15afedd1a4e7571f05b1ffec779c39b62970093069014e83709e22954d861f74c3092e557eb1787085c4759b76cd60121733a3931bfec630add56381cb819003492f7f6b663be64615e20ea754c974ae2ca09f0ceb7a74803546df84075fcda77cf77b6a360588cf88e107e608635ca2ecdbe8dad4fe2c4bf467e60df480fb7ce60a3dd45641d6c08d6ef62fc29a33c098dabb380582b4db2b82b713897ec7ffe2865d1abd3cca934121ef15eb6a6853ef6dee4310760d8fe189fd1bbb73237c6a4c9002c88b0ce8c2f7740e6619e50412c290dba6c3fa9ea7036aa1e17657315e075da2bfafd050087ca2d8e5da8c2658bdc904930fc452dad77a020b0b6cbdb3ce7a6047630d3b629b96bbfe337642cff21cf9cccadce88fe8a4ee6460be55f33f339a0967b77f8dfbfc6327a348ec728cf02889faa7bb7e4d177a5ddf50fc4351f0b4130c7404d7becd5d289b795da711725526a51bf0ea15a236e204eb11446a0fd2335eb1684c434e7a6c015c7d054df232bb81853add45dd6c9d1bcdcbeb01c7e854d53d6530b4ecb70fb46907b6fd3d57d218ea3857200990cca90207c13fe87a3bf7c53bffa135ad4930c3cc1dd719a1684ce2b236026f10e112f12785e51aa1487716f4f8e8735d90377c3cf793d64cae769cf103473537763445c981006b8b1f9c5765a37c5589b6a9a66b72e5afaa06b92ad51877e8d3900f61bd2664c41cc6a7d4e285feb9a8f0dfff7093a3349995fc1d7b0c35c515b09c6b562a2ac1fa1a54954a9729cfb7fc645d20339b13e133d528eec9dca20320b8fadf4c176f07cb8877fcc52d9436e793de126fa9629d538336d749f5e91c7ca2521a118a5283b1c0c05fa89aca8e5dc9409b4a95771fbfa7f9250198331b38662014feaa154b2b42e84db485d8f8082085eb3777c8ad498923cda220f2b181526c8a43746030862a16b143a08aa83f02ab7d4d2ac8eb08e384d6c488cbc2e50fcea969115dbc3536e7ee456fa63f9fdfeb430fd98120633c20554ced1cf93bf1322406ec8d80cc492115795a0fc31bec4130c808eab2504ca39df4a40ab3cb6b5155148d5c53ebc77f416fa53a3a0aa941077a190fd8ad0170155e95ab48bba96ede6e621d1bdeb33e2f07f3fd076f34869327784a04ca95ac0c0dfcd3e307b1bb0719bafd5d0ae7a57114409a84712b581dd9614b7a4d782eeac740e974ad7bcd7f61d7d492caeb89d3606c13eeccf704dd6bfe9e9ea945ee7ae60d632463a1aaa3518e80490595d649ffc7337ab4692dea96293d559e0af56a52b4c7552d461d5bfe9f94cec5fd11506f5ad61abe8602d1dcc12b377f70a7f8a7895a41a0d67910037f340b38bc78d09e0dfe8aa4d3cd37713ac05344c901cd572b110cf46c0b7bc15173c432cc42fe4e11871376e7d813cdfa15ffa7f138a875fa009708893b28301a7246f4daea035006fe806ee2e243e416d0c62929e42d49a9b898fd509c28b57a7979c6c1d6fbf251f6f9f6933b5026f025cee79644ad431624480b875653da707af7aea16074ac5c53f8bfe3b523c6c119a5080b6273d4039f9228a3c30ddc54176ddce503c8cc5b43b57bbaa6e2687e48c02055a72d6359c3889d0ab79ba9d7485ba275158c3e77fa05fc95867c45dfc50d7f32b2a1f94cff84bde42013663cbcd992d3bd567c6bff8838e2f9a9a36c082ae591cf73f518b64416974a2b0e92ecbb652fbbde7c25cb6a9fb59e37e69231563c7578af5811aaa7c054c30e2c711b197214458729c51990388632bcf1538efe771ec2674fcc9221402a11c881aef0062af56e7c510f84ea7a4ced6e166bba4e08075ea8b0b91870994a38a6191f88a8b38b2672bbdffd1a86f6d540d09e6eb75580dff14c2a018ed25a76dec7385a2eeedb763ecea1b04e7ceddec3c5a714810b88e6cc421488441640ac550f38be7f03e349fea57507c6d2fbb776e649037503bc7cfbb538206aadc51d8223c7e00b4a9ff514045a374bf31747523b7f5894e005e3ea792df9b4c84dd221f27cb722e678f7d04b891fd8ce2843857f10a73166d31944efc480107fc7485a3fdcf76aeaf25c275b27a3005c3361f0a4bddd290b89da53b56898a312743c437283339496175c41b82cbfd6963d767ba1635ccbbaab39830a683604e8220e9d662ba4a93b4ea7999dd30115be150632a3cb86c2c5c26ae20aed1e395472af532409b9e51ee2d57d7fcc84e62339cf4ce88c029dc1837eac96e837d23fcb208fbbae074fbae68009e8203c482eb9c3c84a4b2d0c12a89522c9c2e5d58bce3bea648b0871ae54d3e25767ee0683e1ac0165b06be6299407d765652e6c14fb3bb268c69c07b52bd1df579d5d106437d812f2f3372fb1bb0cbc682e00d9d278c75c936d523e739a760f1be2fbb304389b91309f29cc5d83911f9b9e351f3e19e92834d010b32ff4f4b41e31f3e30b9cfb309ba65f75e05f08fb2d578cece11447b12afd43fbae8f00cb69a8d319be2c5e2d7f9253f85054887c51ad5735fd7842895a11275af6218ccfd8addcaa028dd562004a2e53bd66217d0b835e3ae0795e3b0f8f448d2ff1e5b437c2803e5e0034f2d9e63e491c7c0886a5a9b6c8e73ed68352ff3652dd18cfacc6c8893c6251ec8048ed821e2d71ac96041fb98c8d51509c8c9830dc8f606db4e3f36a4bdc1c2c37e2062ac5dcb67f1d098090afd2ea84fa2be50b9ab7b14ec48580f83a7caa4e289a61487fda29901257c346d387f94d09245c2d1e68a6fe1d65dbf8c560a054f77b402e81e2e3610376cd41fe009a8a972b0af71971f1f1d54da48271f5bb9f7d4f5c68a08bc3d8a9ed1f3ada425994dce73cd35e7d337c90d4a380e4b7d3b1227683f8785ed45bcc596494c79e812ff118301c093dcc8dcc81bb1dd55804fc28435249b737d30f0e2e64bd1f0ca1b53f91b983ef7539908cde184e5fdc916d6aed824827bf396c6f051e1123916926f1544ee5327b28b9c74eb09dadfc8c775e50be08ef0cff80eda726ee7504a34a3e334f2171031b8519c941ecb9488bffd649df477433bdb059b793a64c598cdf4e972939c45490be32dc33c711937b5ff3f0dbb42abec9fc170ef232acc162ccc86c9b9b5e3963d348f6de1e7d5e00e91151c200de243ded47347743bdff7b54742b6ecbeadebb688441d776571b94edca37ef6ce5cfeda2b89883e6bf82b593f0791772b79a5ec587e07415df030bf92c9c45a9f466bdd911f7670e6119cbe754d014cfd8520e65406478208800f929f9b65b190616fed063d6b38a5f620870fd0fa2793c48e60ccc81ce792630004ba4bc7d481c9e596f2d80ea0346aa96f7802f4af8199e5358e540bc85059707d8e867917a726f155b18f8599b4808ee10598f5b6638e915962cfa1b284972660144fea9b3ca963d2c9c439b44af727790023ac413a2b22ed95b8a94fc1f143f7792be3c4019c1e65a2d9d9fc99abe8ffecb43982b8731bbb594780815c9f2b2e545bcc41964af26f27b37359ba0ecac2bec70874c49982b30698466061f6b99f59986631b12ba45ddf04356f9e5d57c8c47c12fa7197c30f028f625f1261dd0b07815053de9e287ae6607d861c021ff9b3c2b2a9d810f0f5723098d11c2c3350ccadaf36f11dc3fae38b52633afc24dd23fad20e5f9927abf19b5743ef4f85960c5bf342c8342328c66d9efd10a6bbf1f4b514b77f138d8ed782c72f47bdb2b92a8418eda554b2c320516d08ec0503caeac42e7f15f826adb433e4be848a7f80bddd6c915b148351c3ea13b3bfb727cde99b1a840f9a4b5114346f14ad130aa28664f6d3fa419019f188a9e950840292c56082bedcf2ccb53954af387b6619fe4dfd76e2893f647c018ffa8d6b4ab94a38549fe1015166a2f93e559a0fe816e77dc7ea06310ded9142ca3b5842d45a34a422c090f602cf83ee9e10d4b8c1dd3b6be62ee86e3703eace858c468d0312ca7ed06be2a4dd1dbd834c13fc619ec1d76998a091525ad492ea9e9fcb6526a4133330a08a9ed7fb5bb32be502e5f4a01919b63916eb12cb7de3ac6bfdf129f4519721d2cf1ef11a05914101c09e595461ca3d9b44205cff889a93eee5b8d9c69134228897e30e7f0a3102a985ab72d9c667ea82f18d295ccf6fc02eb674d4e33408edf06bad9259806acdc311fb0cbf9d8905fdd3ae2850295bfeae06f628d50c73b5002c939d4632ab9502e4ec8050982c78d36c534c7b28daab2928c3905cf5ac17ea9ba663b83e055b53bdb7eafceda6439f16079da5a4d56f8356b5c4d780888653e2ae08c439310af2ec60dfe6f8ccf0d67f2a700d01a29d433b46b1d75dab4047c291220213e2cada919c9ea31fa09ec95e40e7e2878a9f063f7b771b0afd84258f03fb54ff623d303b3721b3af4eb7b200e5272f45af016fe9c5d00c7a7b44dfd6ccea1cce62c698b055c9afffd54288a96966ec7e331e4061040739d301087eb73c933d6e451c8a9e1d214fdef41f6356fc3f6750a0ab6901059c7937f4fa10cfe1f942b3f80e6c609572f42464335c462ea1bfb08152c5bb1c8064e30f8aee4b0db07ee4459d27aeb60c9635fc7533e4de58edd29afc4827d89d2dff5bed6fa52abf43608c875583cc440d1a8d3a6a21b1b4e273e4f8014d68ba1a5e8a5c8777e5102cf8a5e75e80e64a36c8314919f492a4b868150ae291cb7f64fc651739276cf31cf1896deb9ef122c324c33f48b9ad765f7059450b9ff0bd0b51d1da4332efc03ffa5b9f899070b8831c9770bb432369d9996ede31014ed036537bfd89c34025bb72d4030995b9c60417288040bc1742005d404a10b657bc0cdac97382e196ef44680f0501fa43f907f604ee72149d0097440dd5218e6abe2fd4efacd2c5d5bb8afcff56288bfecb7d41be499c64993714a1be1342a3b4a0b961229aa9208107006d19cc34381e94579710717160676b77a2831a962885b7b8a18f1e2292b2a92cd19c72fa2dbd774c0865fa69e95e5d4369acca62dd33f2236c0440ccf7c8af60b27fe1afa2b1d85b9af3163a2d5bfed10cc71c9912418aaf031712cd3872982a9e54a7ec2f9f6362fe4c55b080273b0a726c8863d9aaffcff17857a15f3bf9fe3eecb8025937930826db8a97940e3fdb3f9a383edf45613eaf015cbb609f7cad538136ca3e5cb169c5dbf37b49505f8a4c8fd7c3729a5c7fa9e0c6b23203065ae10e0e8e195396b63df0625c1beb783c10290f240ae48ec485d9f15d8d1b3e2b39a59b07a8d3d319963f5eaeab086f5adda98c50def9c1e1c1a4d80f451813f33682e1eb2d5a54db5dcc5c2394d1e6d105795103c6c203cfca5f505bac6c03479647bc2df55c960a4ec6496877816416a43cd0784643e4437bb8218ef60ac037278477c8f8969e5f82f57a8b2d9b3f903f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
