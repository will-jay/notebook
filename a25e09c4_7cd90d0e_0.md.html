<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bf3923a7e613bc223ff44966c9ae76c17250ab5cdc07f32c649126e87e99a7d9e576d70025ff2e10e583f9dd33b11d710d248beea9f28d7930fb3fd914870ba9e1b0e421e471c7583a245c5c14b58d4f9930c84eeb6f7c301e293838391c2ab8745d9d4214301c7ae54425a54e320ea74aac5ac14bfce79abcad5a9058e1e8014c28bcc1a536e572dc2fbfe1c1f179cbb6d5b8dc7c971f971cf954d5112598e673d8bc035a9ba711158e7ac65ef5f8d7d1808828a81fc504883e726d9e9b9301bc6005c894630651fb9d5a57d06d13bebc0652fd0435263a470bd0ddba5012087c64cdf6904e67f6707e108087bd51c85462b63441bd1c10bf88262c898b8be3f5d64d71c66748030e78aec125fbce656a35d6e7e0d751089820ff59441b89ce1c47b6774a194312e512aa48e7927a13f2444a30a1c9795f0608e42fd95ed9f61140dfaabd63a720d960a704aca9e795eb2264f03b8b6e934152a6250b8ccfc2193d693bd4c629a577676056175741e36bb98d853174505415e3b68e573426691030833a5c1bcc52827099bc902be262c1491d685cd5948f03ef37c49f72ccc25acebb3973d73765682128041cb2eb3ee67cf69574aa4e86fd48e484da1ab0f374c9bfc232d06145b8b8a0336ef8d25c420dd5e808290d7e7692df538d49400d8faee614e9488e006cc0e5162c042eb83b53e565f68cf814937b4a793cf3069882b52ad1aace424796f0e07b4cde54279f14ffa040cd020c6d2358e86e06abe585d1a6f385c35f431479b35e16953f96cd1da6cd51fd8f0e92a1126b5c2562abce8a9457decf19f3d3dd9cd15570114ad04bf9dea705adfe2453cd1a34b80b1ac8c016fb9e769d7842fd0c074a26e2c286ec5fde82a52f55d91463dcd9a2b38eb1c3a415caf40c51401f1f57aca4b22d69426e14fe7832192f3588a7954056ae549ff9fd9793fb971e6199d33756b5b1a417c87cc3929401d5b1d9c4b5fef3a6dfe792e53ebea315c96262784194d711f6553c4110dded19f138fc40c6ac63a8dd4263e626a0d4d1fab2866ef5dbb703a4ec55901422cbe6e9735047c31f5c07fef507cad5136d548219b3ac05ad78855abea1156defd5e17f107e026600b99c84690c0155e4cb870a213d1670ac3d255d38739b9b0e305f1f2d60b344cb6e24e8186547d08e813896ca2b53be174d6066e0842807f9a884e3b47de3c5e5d1c27dff4457fb38e9cd00f6a47b0ee0b8adca22d9272c2f17f4659f216a7f6694b2ae90d1c9357b13ed88ae781ea32dd4ff08970c251c63f31e0718ec22948347fae45caac557a10f9e347c9834328348a415793c8c476cc8eaf56c19260ab1672f61681611dcaeeeaf4f52cd48a9735f5668ba4b76bdd91e332cba0b03424d867a4b656be3bc91e4cedcd935dc8410cfc7b81d5c9d4fa0c81a17a9b05012a5136cb576ee40baefc7685c3f57b62d7cc7acc34278ef788a44bb05a6c244496bc99c2082731d3d6e3331c79b75087daa6c3d1a072c4cd1b6cea1a6bedf02e1f9fd57c7dff5d84aa22b9d7063341c7e7ce2d983ef3303462c15d5a617faccb47d0fe55140dd10e571891a8bd7ffd9c4cb4f4be98200e8b361228549c12b027df8ee29577a9d097a4f08469c2921a7d9067df0e286307b2e940bf404f4c452d94e2dd8fc6f1a6f0f19aee52ccf787f2e51c8f064d06f14c365c13f5def6a802adc83ad1fef1b89f8429f29340daaa4a73296129500263cf9ce7410f8546f2fa3443c3efd20c2fc6623240f0ad72234125e4d358f755ffd52277cef776660a57257f9b9a8e92cf041cad15c7fe259eb57600cdb3725cb02eb95e68d3b7c1be226c214a1bb044a2bc5d11654a8ce527bf98522b0028e9540d8fa00394a1f34e1f4a8a62b054bc95efdf34fcf5dbecd9153b79843424026106080cd806d5dc8ce1f39aa13ea5c54223d08945b3f7fb760bc2b5c09db61b2e39b25edb1f978439b357b332f3d50695c0ae4e7d0cf3512e1061a8205b9c0b6ee57b5bfb763f6dccddba158bbd57b6944041f4bef14c46fbb73cc6418f5a6fee0a47889e5b5c550d472cec3dde2292e4e8c47ed0d92772b8fff019837d7f37e7d72bf23e4b9a96b39abad1960059ae587dde47ea1c101eb1b0a0fcc06df046119e3161d0ae44d7dcf2d51f42c5e4251f886fadcdba0b7d53f9667c5809a71bfb88efec268c7f58692c13e47627f8f0fc12ae4682b547c16690ffae0b63afe3468fb8465717838386bfe7156493a55532c5822ffde7f823c0d57389997b27ffe7b1f32130fb249930dd7f12dbc0ce76330d0aa9c97e94e1ad2dd36f39e1d95d88ce9164519bdbc02f171b6f4735cc8fe4871ad8a2f6de5b10f2f6c8e6683dd6e1d30eca03b7b6f9e31d646ded98d63051b15d478576e69597a2a66722edbb64851b34d7d97212b835a533cc4dfa95fc7239a441358c6f5f00a8bf4734f6185c0073a832bf24c9166cddb89d8465f19ade699d159e838cf458d27ef8b96761d8a965b1a1d2b42f5016888c2838ca3561acbff87c36abb2f589bb29d2320d92c7c675375ed899930bd2949555be1b8f24616f4ae5134937ee5bd1d80274e752f32047b117351a135baeda51c6008cc28e31eb5b3833e11ea42cc98feeea6d9ca8a3d8ffb1abcc5c396b88c4c0109a9e1ba1cb33c97016cfd04d8718f512c54756f5d3c9492cc2010ff3ba48d28daa348ebcacad4381c339c0e8231c5401046e3b2c95cdf07cc8f372ea72ba2deb23085451876bd3a08deb5f7d4dbb84c376b27bca2e2ef136b70ff79669b3152f5aed5e19925fbb542f3b6b231349ff0edddac49471c87e12b3b62d93e28024c145f2a0fecc9c0aad06b9c0ccdfa1ca961f77ce8cfa6a665da41ba96c0a8ac014503360de64159eb50650996b00934fe98c42913522eed1ebe3d91f03af8b3127e997dbcc4f62f8263ff487871a31463b894d5980c67f20c360ac4d9364283b6fc913436a9713ff4879d2ad498d23321e1bbb6832d407731899e602bd8eb7d855eb1cf349002824f8f7067fc547dff0256201c82cc90a5cfa0b8d329ab377f20cb717c2b055cccd3bc2cdec17689cf86c5c0d9e17579177c1e7fedd601cda9dd66bda3ddf035a859fb940c0df27c9ac6aa6d16947fe8819b0094a09a165a6dd30d98795a05dbca3b45f42f18897b0847443dc5015f3cb2e55b8a249e1e75a8ccf753aed31318063a43eb77eea56e0518b1360dd79e44b80f5f237194f966ab7209e2e2779e1f2e9880b22cd4aa07552cc08fdfda9cdacedaa317e5a3ad078a7a405b1d8d96e0eccf99e389d29e3de019790c45c6397a42932bde3dcac2fea10d8b3f08cde095ed4a5daa11a61e27befa00bd004355ab85551e69ad4641be2c8b584a5e0511cffce012b92bdcd55ef88f7a6952cb4d87391e360521baa87b2c6d9483f2d4198ef095278e11a211c037df2a02cccae3986b7921bbe28e0df59664988e3cf8b8df07eecfa6774dcb7b7473c6f23296363511d12769c19124f06767522e3951284cd65cbed33bd5f417f361f6b57a49370cd11c50b9733413c07db447d8074891b35a049b6147851b81493393f1e7100ffec9b337a8917c82d423789bc19125b62655e2932e248bf8d33d2ca36d83a12d47f68cb9783f8a96fcf2af43e8dffb7dd36b9d351307d4adf7d067cc5bc19763da64e78d0a1bfbdb2ad793ea21a01d2a238bc2ce6c0d1bc95eb69690eae2413b748a3ecc22cbb421cc6682461ab282e5b5bf4d2101dde560fc8dd07ce231eed97ed9d5549fed60165446e9cf2669778cea9e50b89c4acf6ea25ee0cc9a4c155eecf832b86157e61ae56386b09a7921f1e8092a14db330bceefd2495e69d2ec7ae81d7ca458e450dbfe4d493e6091b63c90fe6f0110fe46c847ce9aeadaa0cf8cb2a2153d31e68ec47f463d0fa20b217a3482ebce85762efaacbc43e24e97e418a507960881f7e85096fd3586b434557fa40828d1b133df6c7d4f2aeae87298549c86788855f27851bb3dea83c802f30fbcc50e8239751c0e0b239bea974aecdeef255e4c186eb51f6176188a2295fb92039dcfcf91df003cce67ede5291c705e846bcf475173acaf4decb37df76c98860dff3f2d586c4aba90de49109edb7288a174a6dae3def1f71b2a12d1a8b6fdda4d75da67f87e30dbebf96ee1a2419f3b023bdfbc93f77a7d2194bd6ef78561b453e6fcc2ca55ea4c20898a1b7d475ca6c0947d81319b668c4cc104a7a642b04ac2e5f06509b2449d7581b9a075414ae060d477792032de3dd0954febf121bec55358f0c8695a4a2c2adeca47b3dee055c066ef597fdc0dd6019323165eff209dc3b9f6c3eb6401c56886e41bcf73d6c2237f80cfe21f98669ad32c8344e62083cf877c04c66c3ee5dee638bc11c8ec493e2ef0fb980c8ab618ef935585afb589bb0480fe3386acbd1e4abf95eba9f6c58e1aaf4b7c26c1cdf768d05500e43cd5b439e96c93ecbae58b520d89ab7f022f7b2aef64d31da5d6a80c54e6caa4f837e27b2414c22b4598938ad12e728e27aec3bc8a1077d0d0a1220e0b19bbb12437973952472a79d0f6d81ca9ea652cf008befc4c0eb6a1da719d6df0e7bb54a15a45415afba7bfe030024a64a7ee713a7d286d11fc0659918237faac8c0744fb518b2537325d728765cbc36b431b99524f8a17bae22f66be8e286d190969eab413fcb87dca2e4a0bd4ea1dd768d803e8e5432300410b115ed5c8003a66a9220d187cd1306622a7958635fffa31bdf61221b267379b6379081b0bbfd76623c2c508e59eef8c1d59a1fb38d4b752cc77e4122f646f2c7631301a57cafc10dedb9d22924cdcf3eb2d415e4eb3d284120040247af092f374eb500d210e8c667ac7d592afa80a37443fc29e8e953d370ea89c69ef091c26c665ddcf5997af3f58f46067706310dad04dddd66e8787108a6f5273ac007e367dfccbb2ffa4317ca7cbacbb16f354b9d2cf4a8a3e56cbbe10807a3057dde4de86c124131b0eb3f91c9e620e0ae21a5f3e96dcda50aa0a16769f0c9b1707957a0f3b07ed178ebff0812e67247a1270b322ba9b8cffe3a0dc866a7fd053be58d80dd2a1fd1a3206d4a8b28aa657961bcf30c5cad9c29c3b04b24755f3bedc3e8fbe2bebc766bd5854d75708eff403def3e90a2215d1d866054ed5fc0f013425f84a8de1d1856737971e456473ff735c59bed3b1d19367fbf00c80ddabc74390ec6a6aa3ce3efd843278ae80cb5d320d26924baa15d6d9d4899842086ae1d1493849ce5ef92a4e6fabb918c6f5264967112e876af16f0a6f19bea5bc5afff4fff30b7b17307067059c2237055a723a8ae522d8d57f609046ed9b4630bbf4b10653b6b7df50ea17cfcf16e774f3a7f59ed508a459aa5d26ceaeba796d223659e7dcf369412f0426a244c63c4d33d7888e5bbaa2358cec8084786747817473a2a9721de3def4900de883b74e1a2929fcb57964443c781d60f693f597711a0978f1aa245ddd2ed532091b8e457cda6dfb40ee0ecaaae71055252aef6a97c9ed672d1d144cf45ea6e3138fd79785f0ed322cecdbdb54d2613283b0287e25c77cfc3b04d3d88d6d9259d7911065b02eba6baefe96c6a18c4428380f4a4cceb2b648471e610fa771764eda706900f3860b8f239240409c21757a1a3a63071ca71a7f0cab69dc15ed262a46ed3337e53c00599b561b786c4b328f40ae1f978b32f60e9fc04cfe5f0ba28f417be62a23a985d78bf81cb3a71df9f9680ba4d0c13e9459a321b4eeb7c0f0f28414617659704673ec248c0174a584937b0bf34aacb8f71f986ba5062943d142bd29a43815d4e2e0afe1c538802054e55481dd5d0c09dc1d69c821ae5868be0502af76828dcbf4c2d237ff23d555f8ecdea522301861cd400e10ed6ffa1b6990734afc2dbccab732c3b854d7c10cb4116664bc93e9a2caa6c21a0b4536f6752c1c2c7ac0ea5db702b7de1defe91471dfe572ee6637e96a00e868ab153e8a82384975e87a7da2e43624d97df14d39b0bcedf669f5d0dd02c656a95074ade69f324998190e36db781b8db7093c38f67d291924c03fadad0ae78fb5cf25b0b7a4556ecf60364416796c7da50bd3f42025d676e7ea6f01e6c9296f4e8e5fa9b6c90197e395212a9274a42bc0433074fc2de02db0534e8b1d7a749aeb29cba3b1f6d57ca4ff2c8025e640fb603efe337d11d2a9338918f550c273184d37eda405a80160ffe027c9feb7ccb325033d9b7413af05bc100059c7fe245fa21b38182eb3c59a61322c84e35e2b7bd31fb84e44cf422f23898f4148f33fc6a4122ef3a740be87171da4b7fd9503ad26882f9f772cf10edca462cdd82a38bb185fa516e4bbc6e6b4a7ac9cd4002dd287bc55e3b96301994f0d30d0e590c291688be2582f0ea90a27117da00971b306e32b64ff7ddec60457208f6b444d466cab2bb636dd57d9053ce3777358f6e1021bfd758537f575acae0be636c50a6242f9bfb10a271a5b5f3650b01a1e98f9a053094d67d3a393a03aa6e54516ff579eae601cf97b92d2e37f540ad0def587e11f9b543d0fe9ef71f0bbaafe234b7da243cd288ee52f9f7e115a0e858548f13e3aa7158a2aa06e3c1b860b4cd4ac416220cb618eead7ddf2ccedc5468b7bebdbda3141bc1752b8e83d4624cd52688a27cf1fe78cae34b6626bf3f871295071547ff831068599b3f03b3eab30ef84c9312a886f4fcc504afa063c16484991c1b8a6d0794c1df71959e02fa9800da44fad9b7acfa4c5eae516c380b3441637fd4c14bcaa67928d551d6362716f35ae6e606b3acf0f4cd3d9feaeb0ee74b97fd7e92d1d3c693044bb39c941821731f455cb070136320a6b1996e66b861d6039337cc258e592eccbfe53f084260c2d11f8ae15db96e12568fd7a4b924c6335857cd29a55430919411c826eca062cf3936e2845adfc9f9c445e03208d7769a9d683800c56634a2310c59afff34635fad20c269900dd8dd65dc07b2bafb753c6224f0f13b78db4c9b5b67f6cfafb3635d05db1fa9b12a0f9bccaa5b20369560657197163cb45f5838f14ad190a6c3b88c47edc8251e97787be1710b0bf191c552b4cfc88d22c7f49df48e2c5b1ce1df972fb14feca22a5ca674865702f346d7930c16867747b66766231e5e9d013047ef7143f4200e6d6c86d6f56ba3dd929cbad3304829283d3bc0aa415b23abeae2dbf8e3706267401defa7caeda4350ae1c19e09ff3a13d50e525f93302335c88d7fa51a648752e7f452ca15e82b9111e040fbc751d500854fcbda8abb126fadc562f2e80b970649cbc07f68d7f0921b3a5cfe1fa89543cf1e18aafe3395482773bc209b7fbd9a12e17a1e1a1e287d628ee360940470db8cf0f929725f614b1b7371942899cf98a70f7ad899d0a3ea2292c77b5b83d5711d82ae082908ade67a1172a6050c7835084c2fe5e90cc0be177750352b304b83315d651d9b8022c0ab2b27ed993add60f196124eb0d29d7866f0d052948de705d6d9f60642b701d93c68f30311f34ac9cb580f75ec363c12ac366ba5a76fe076323024e66b9cfcab314969173efc149603563fab9a8658b119b66c4f8ac86b2f2f52db703b04b6ff8c31bb7000ff112a4d361fe9129d43e18830f59b84b5fd3fc9ab88e03339323131f6307b10be480b9063cd44d67f5663ceeec817748bf9e0d1bc3d307b4a61c3cf1a5a83a5f35c34216f79bdbebab78ff2ce488f4a07d7243e6a5f5bd34b0d82913bda993ab6ec4ef67176cfcc478254514bd3f059e24f8c8182b609439e4986956586f84e52a9b32a0218c63247248c3e732ae3d3b3c505ad3e2b5939ba69117012a6e59153851febc397ae5dcace6472cf30c494c0170d9e8d0bab9b2313ecb1ffc0e141d23ff561e594240d98d8854397fe297738851317f5c05ec960684bc36244d940e133f7ed8cf74eb7a4e970a89c8363ac7142b4d05363f28170bc65b9b001758c812ddff567f7402660f6e067aa3eb365d53109aeba4000f0200ec8df5b1625d1d8aacad2dbe0b59c9c860933d423b14d07141771951f7b6f2780a0f3331207bd4289036c8ff385483d435ceff30181995adcd9ab0d469ce4e684cc0f6b6ba7bbf0a1d8ff70efd12958d0beb37786233895e51e229f1fec56d56ef694396f8a16cfca5d186802e08f3b9d74da4b367256dca93a8b7833a18f821f998c7a3a72daec84a657af43627b98220009004e83486ceb2dfcf51ead3a79c07eb872dc166bc91fca11a35d30429a5bba3a7de9fd00d0eff257a6cf82027e13467af58f4508164ff85b29d9f117b3dca80c0c0257e27508fdccca4333d9f0e75c707b1d5c069ce746a76545e0d3e0d1d1d0cf1270ca35f6d7ca22f48c6fd0734a572856e735f45858f3c3738d1de8d400963b6dc12b971eec0dbef08b6b8b6451c4da79090dd78826c39dbd56fe87a5ef35468ab080c5fb2d4022a1fcd26180848ff88cd9a0009d0b51022a331330dc6b0f27492a458482f527cffb03a4eb079deaed97175d788e0638604b02fd4f74d8346c5a9722b20fd039d3103518ae2aa32b14d76ac7d66eaf09130e3fecfd0d310515199b8d97ccea57380532840bf1412da1e18a43703785a3632f2f85e9309ad33ee560fd8191fb75c7b972b6d3db5be4b3e0f8d0d8f9197bb258d1fb16b0912b461573be65b61d9c562214257552d9bae603b05404e61aac3e69d67370b604bd01a057adbc5d00f357b710871883eb7c0393fbf28920f00d006a7be166208796fdd7061884edfcc416e8543199f9ee18e814dd555c3981d724e80a38b7a82a64dd6a9d7a7ae4998d22abb9617f7816caedb9bfa29559a2391ca762afcc1f6ccf43088cd32d4f5f9308cb0d45a0449dd70126519384651db5a48d753a4d4aa96cf6fbc57c5f3248ee081d52aef2e624472a152efca3af117d0b663f9b3e7f7610d3dbbf987906d2b551cebb3959e7bbda185ef7e0e284e984c4bfdad54da51757cc018e7bfd980c2176576b1b7c518d1408694554805cab328b94af268cfb207ad3bbf67513143d7b51577436322e8c3aa40f4647f46924a360d98c25520a67e9084672ea92c735a61684a6b66a952efbddc7113afc8ab814935de206c11088bf4a502e5516411c35c70768ac6b62757df27c4ad3a2ab6e57a71c5950da5432baae6170d649a2ad59d5aa9d5b0eb72011ee116a6e4fd9c00817bb5047b943e4472c343d0f5d23a4f7c995128ca395aac529d54bae9263d891ac5b3d1081d0c2cbcd4160329aa6c894700779d71c46ec032db0bc40ded0e6cab5e3dcbf9ca796b86b632866be2223169fc77076f6fa5be55a0ef223aa9250bbc861f85ad002afb3b6795969175b250b912726d8791f1704e017816c80684d0ddda192a925b40ff3c8eb13a07c19b687dd230e47b0efa1272e32d47dfb6598e3ad274c42039fa174b69a139c5e678ff4f35974d7959396331a39d74f685864ae47cad13ed7c61053b24c47a346fd4b0b25a89a55e7383a0bdd31aa005245bfe20c508edd1a5f87e5b04c364744fee86337e47c3d89f8cce248b085b21540150cb6a1543a17aa362d38f820fac1eeb00120ce800eaa91d777c45e337da3c65b399d6b34012d6c1bd6a1d019fb3d959557fc672b51b0f9f71631c8d9c9b5c0d349d7fedcbbbb4293117a772d707077d0ed6a795d28125083d21d5e8f3740abda5aae42966b8740720b542324e61803d937a7eeb53f5627173f346c0bfe8afcdaf2109c1d0998699bf2a0840e3c793ea00f2f7833130285187518690aa2182ca50b46662f42355abddc3e6f623801ac20da0599537012ba708d561b8500a59d527ff8fdd22af7d961c25bb494f5b35c8f2c7665b3e691a05ea40f3d7cee1e2125463844dcd286a7af65de8534594c3fb1dee8fae558bc2a2f766b99db79a0aa05ffcbea33139198bd6098d04252aad0455452cc78571c86a2cb4e02fb3b7348115d414cc30bd07a38a7616172a99965f88c2dfdd6fae6d7d55e99147b856e92054e57d6dd807713196cc1a8c008914356b07de5bf38e0161e53b84e912fa4fb8fb9ac76d6ac3bec7ea236f98d2567109ad7cebfd50e2e3404c923c4220923a993d3d47ab0d42bd78843317890d44fc71238e063f9e87108ad273e7485a6106ee36833518badd12cd877b7e6c5a6f08154166cb73943527b95fd249c2c7c1cead43e5d092755c96d2952f573661724c9b605912fb483f7e14313e68c5e65d7fbec7a5b54d05ef8288e3060c15b1137132c730316fdece210e2dd3bb9288aeffa296dfb23233ef9d857f8a4683a83bc07162a6dd5bc234806be38a260a6853a570306adf18d5205a64c6ec244327f3e87a01764300227bd3e26d03c6204e5d4a24eecc660ad6aa93684add00224bcdcd14fd068020873100f4f15634ecfafea691f58ac836cf946430321279c6d116b9f4b0ca4a204b7b304eadea150b9b025bb3b8b2066d3e4142d6fddb7b0af697e3c195b7963ec409690c51a2e6028c2f1363cb7733b9783de1123fff9f4a82e8610ba4ec8579779b31194aa04a6bfacfeb53e277324eb4d6260f57fc8c35ed222a36a41c2d2f91b2b0689b8f396de473510dd8238fa0540dd97c87cfbf20c1a5ab40e939997d5a9f46f6aafb8a06e471991d9cf88be0814f5a27b024adf5a2cfcc0841095fb7456be4a81a02251c2db20b3e1dbb456d12feea8a52fa62eb6050c9c9f3a0a25d6f843c86255d75df6af677055e74ed8199511dd56b281b06089915384d901e85090d9447d000e300d321563879b9b242d350e86259f9671249536d87b7916c4d822e98b2b53ad7810bbb8be7ae02dc26e554bd53bd4ee185be8eb3a813405596b402b36f1b529eafd02230a10a9664a7e733e4a66236f1d7a8f817210c998986e445de069483793d4d435805f04ce030feb87d329afe3153b8418f737707dc8fa5b0fe8acb3d91e38bc5d8bf41f680f28aab1b139909cba462e64a0a1a38bbd917b2488408f7bc9fc029b566faa65bc08417ada62f835af9b496d1abb1b2808a85ce68d2aeb7dd3a78022eeb09ba416d57d01f516cf6e4dd4e108ba68a8647a8f282613ba89370eab4af4baed7f7a87bfef5a6ea5e1804f71439ecce3749b747b4429ccb9ba82040f210b5269171c4b651f35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
