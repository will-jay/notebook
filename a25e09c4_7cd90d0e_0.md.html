<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ef61ed3d865b970f40c5b4e916bfae9f5913ccfd172e4fb6b15dad400ef804b0607c0a1b063d08f3b4915b37f6073fbd75e2620f427fccb95193a824503afa031e1e4b91a94a8ca9913583169516a17e233960979e3bd0af34dff0d69754cb925a31f8e7c5c3243c3057f3bf3883428e8fa152f9b222eda901605717c058cab1d75b6c2aaba0d57923334ceacc4a1de6d7842749aa274bcc8d05d4b8e637855ec3c79917eaacc203535caa50b045e48b5c6e4a2865af6daa7cb0f76b056026b9c36620ca94bff5b61b87f020814a61f43d9b4ac01e72b1686a22990b34b83246e83808caa5cc9bd054db581488233e8c8b5b116af8a2d6422f9bb1a2cc8813ecc82fe404a5472b42165f0374267cb1a4e7c7aa19325bcebd8bdc2a1721c340bdd916e6f244ac3b8f349484ea89c2a27162171cb8a881ca4e8fd6258b398a7aff359ae1e86c892414207d9238dc629bbb242a5afe028be71cf2c082abbfd05e9ac739a5d5c438c1483c723ffd75cdbd9256f0e88af31892bc9e75084a0c651b3fec917893e6fb6b7457c2563b462f2bbb99166c514474b1da406afd4f65ab8f2e12e9b14abcf6463be676994ef399543d6a8674fca756f8339f51a22270a5a8db8dd0a4dc9df7ed0f19cc3b9cb546e6cbdf6e1ac9e48f59ab447b989651d8507e0ef3f376e82bd318b6b352440eeb2acd9ec7f2edaebc187e3eb3541d51c3cb70f38166ec3bd4387c0cc4a72fdc2016b82fee2d52c5b876ffb33e923c163bbff91729a330aa6555d873651f2ec01a0990c31c593e77d1768fd841c181e8a12571f4d9ba95c67c300e7e3897607293317eace98ad81e3cf6a69c311c4b34a3568a3a7afeaab23fb28b4eee669b179a4b9938d65220b484e48e75e95d7082630b72c2946576f92975b657ef77a8ed41b3938ce4c61bfd287707bf28112e85410d6512061f6c9b04246c366b236356136b1563f809b15fbaa37cd5746e1d46a80916baf4b73f712d9ce758865c82f8dfbccb02ead78271e3c5f926667da01c78d2bd4d875db87bc70f246c7e583e5492303a5b0c0667b8016d9f297b0ad4d74409571859110166327942ebb8755ae094fff050e5a9ee2ee66bbb49b45f16e5ce552efbda46aaacb11ad5aec0670c6e279156d653335ad056aac4546a403d191e671ed2c91406790b95d1b24d7c563b93d8cbf5f222f612c60b9d8f4fa0729351b3e24dbcfd939fc6d5e33e46380b6585cd6e65f2cfcb2da88b99f7b0c9f7a04ff5bb5dbf79047681661f8e97a25939e343795580fcfdb0d2afd257b4a6b99ade2d812bd99f1e5d172e2c1f7a54b14990c04f7ecb796dbf65257696c3c6055ea2121e79d39467368bf9a629aec1bab65adb3683afbb37e3a465fc038d7601c802baef5b4d97926436963120647349fd9b58143ad8d550d13587a4711432d53613325029a2d4e913355c19dd9133f5b5a97c2f2236a2950e50dd873f19988f6603f16b322447a03c7bcd9fceffe75c0393ab9d42545f264dfdd9779c6f89c8b35640fdb58d660bb784c0559b64fda511a13e293bd8f6d1fd914392b7f4d4038e81daa37372da34a1b2e9acc9c1d4f38ae6012e08fc913a9af30bb9450b762c13fb4f281c1336d4e80608bb337486e58a7fed38e66f2bdd59e8140ef688fb2662fd2469b127ed6f1602aec81564c52776846be1a69635f63ec05bfe6a28578126387aa37e203ada53cf96705cc3429ec6524c6e7181a363725e6b240a717b608a2cb1a30f319d81f6a91b988bf711ebe89578127a7944ad64dc0d321bb0d84d9cbf219c6879d988e4e4554e31422ddd04c69c8ab8730fd015a24fb61b302a8d5e329d01e4bc78d80b4ed153dd81edf446f9f822eb9fa30601c4eff6d04a9fd82ac73ef5054ad8161c50ad4494b8332b419a82869e0d36da554e0929e8d9387781a654ee1bdd38f255794604494b6b3dd1819d4e7835246b33aa02b166413906c990a6aee3c7ed34cecd9b345047f6319ff45b6d0345724c2ca2699bd14f5829f0092aab8372ec5d0ee4fe931267a5d7ab0832b61fcd8292b690db6b488fc2ca8f1047b684ffc6f2ab12d0e726c0f40404072718ee0f8fc537aea95e0abf40b42835e966ebe0b8f082d3d9448696aee37e1b248a809a974f911e8e568a334c6cf8c457c4f67f8ebf61452bece2ec19ffa954bd27990524ab2ebd3467dfaab81d65e75ae02d6f0e23f1370138db71753eda6b35da46f5cf267f52a6d7619eeac5a3311a72efa9fbf84ade18b3f5017282b755008b7cd622849473e28987b77da193744ffcef6eb1be8ecef404cac77d7ffe3cfd6a9943057ff694b2266a26a8e630dca858bdb3d03c6395b0c470f02296bead4b70944eb91e18f79c4a12d709653b1bfacbb671f2adb5eeaa0341f4317d095531d01ead4955be21e3d32add99f197c7ab4fa3935db9b900f5d8a61b21dc1338ad8748bbdaf9ef12d793b4e9fa84ea8c89baa90ca682c1376f627e75f932a23bbe495e87b5acb29124b18d7f1e802e89d2127d68d31e78d79f8ce9b8a8a22772f568e9be45b004d2000e2b7e47499d2575e947651d5daa167627695cff1102f2e66088224c1b78660e692d4ce81f1a386fab87f898a08d0503e07e08033884c911f5a3d541272fb8f15f30cb71c6a6f90a15115445b6c6f6c24c14552a0fac4a028052a0743283aed4da1d9a58104b437d8d4cb41569d2c503920c65cfe32e9c8751779b248800d5504f4ac56a6999059f629fbe693f8ebf2ad25572af11979b2d20a83bfdad399091f282cba8df2b27520f808651b9427314656ae989f14bf8d62b8f64a513593df24357de9ce3b54c522dae2d1520c2448df0bb9f956491ccba59e6b90267289887f4a2c1d517ae30253c47e08a3b60544430fa19be8ea1d2a32e378c78c365c40ef2275b0d3614dd8f44ff44812e08221f1623c0cd8c9de7b5cc8d236c96e99cc47a142870dce9143ea240455c8457578011b58038aa3738fb7b8f731ae181a1bc218e0e21c068a937350d0356ef7a5a5f660b656b1ba89c48b4915e9a2d03f50ae8ad714220e3e094e7f50d5c65440fa00c3c2082ddf0f28ff3074c936452cfeb9c14bde9a03e96f7f3068dc1092c6071814b2443ca2a191dc1dca457c7ff95e8faf9acd5009e2e3f0c87e1b7fab7286b74545c4b30796a02ebfd67d7b9765866cbf5efe732c898ff4768feb6c808e9bb0f5d38b1a6f39d9aaf8869496bc8e435c287deadd680f428107504f11e8e3e1b9c3353e8a7e88b24bc53597ceda8d77b6b4e236d17b9a7ccd97d0f50a96f7f0cfff7d2d3faedfacb9903967663aadd64628ffe08d9329e1bca6185e63f3a3f5baf1d13798b075b8b5741a04fbbbb6c2d01cc5a82dc5b39e671a34f2423e5253a1d9b564137f0527f1cbe9eecffb3a58c0ae755852df5c2f9b93734a73bacc31e707d345ced42fd03ca73d4dfd1c24dae524f5e0821cfe07645a6e9be067d850990bbd51c7b5f69a2bfd89f802b41c167b8cf7a92625ce69d7c21e7a8c502cb00b8fae27015e4d96166334b18fdd401ef78da0fa59bd3dd51afbfd5c1cbce5d9ac1a136c21f4b9989ab929cbf567388cdcc35695ac71ded17176b4d904387956277c977f02957c2eaa14627b819ce3bb327fbc369df8008e6e3566a0875d17f41cd64b6e9a19cd56c080fe4caeb6b681c7c54aeba0ac90815c64c443f8a27bcebea9aa1b672aa60bc1c95c0c032b0689b15ae935d7b0dfd8d50208c290d47f530c1d846944d52e97e6c05ad4fda26d3ae5e75e633d899f8e4cb383993701de653b9e3361de31fb1e4ae1b80d2d196061dc621b965593ba612d0841390a50d08a3f18fa2f5bf341ef4590506e0fc37df326211bc1e7975bdec821cac8b126d67da3998e982f60af3cc6aff448e656c1da23774876cf195c3230b2ee0917e4e4cd1915df6b61dafd0fcb8c751320a3598148164de13b8851ea19375358ea30a6833fc1c6ddfdc2fe0041e3c056eed782b270128f1d60c0cbd55a8908fda9662e1d1c88df627a72718f07e2ea898e327d47f52712b03d46171f1cac50aeb42e6cb0084f77dd9a579f50481a33dc395a029692bbe09f26a398b3bbb633d6445bc3977ba3da8f9dfa9ceb66a141d5daf0bb7b311cb0f6c2e2527a66253c44e6c796bf4bb71893a97283a0ef0f32df05aa6eee56dd46c08f7b3909438a17da6eccadf18aca8e831d808cb9508b809979180170e430b2c632affd4396ea6b3b2ee4255f9f54dbb237e7c282b9724886fd1d1c8b4f92777d679b1fd5e7ec44d3dfe79b7397953c1f03b5e0d1b2cbe8b587bf5da80da67f53b268307b8f891850b7489d9a22ea7e094a6e2d8d2ae87d1b33fbef38523d278d5f39f2f8fd7071032cbe1e037a6cca9e87cbeccaa501cf1d4a723789fcb483ba10e3146a2295aa2f8a737fdf3b2e871d21e8c1e2bc19c1236629cc51f55ea759fbe51916ba56d7c694265759f6d2d3718b125da5e6daca29f75d70609c609bec344866cee575c9dc99a8dc4d66ff0380e3f81daa2edafdab748a4cc3de52fa8663b3f7fdf23b714992e2dbd013fff2e7e1db57ecd72264504763f21566444dddcdba58bd2f2ce833e7e7eac5b3c9a6b7f15834ce85380aaf87787f2c3d0f7cfc4e7d8f29ab2714a5b268b87919dcc76bc62db4e5227aa6e1909d3a6aecdb10a7d390a4a52c9fd270e630f9df89173da71d013932bf960a70e508940be5409d7b0c1c279cf655457cd6437107110bd9f7f0ae4287d6d19b48142e4168f167a15ee3bde4cca02b0cc580a1e31859f283feb528b371785ec60fe86c3700484ac0c26e6335673159ea0655f7757c5386b232b2f58b6d24a74943110640c2879ba9cd3d1d11fec5ad04914d6ff3d8c24b424c4e5802eec5c09f9086a9960dbc2ab6ff4157a294cd4692ac43dd5fd6971a6acf67ec2cf07f93c4cd21beab3f00562bf0bca1dd268ec8ccb1fa68eb476640eaec4dd468d81c94320292885f9b5157bd3faf49f1b71a326ebd2df0a5c0e08d5fa68d314990a569617f8ae14d9b4a2620456de7bcf036ff57435d7660ec8489172925f5223d28e6763aedcca2750accb374a5caafaf498b1eae039133efbc3e109f9d7b5c639c44e0b307a8c9fac235f2c04b94dea1d16362a79ecc82c704b94282ff93c0ef8f44ecaf2ecee16cadc3c2e664c44b3194785e53016b65b274bf85e21ece3167ff8c4ee2dab43a05be4485875bccf9fff364d419b040371d006a2aa9a3b7005c1432a5e4f3da468409879c473ca781cb5dd9cdee7e8a46aa206d665f520fa1f280f64f93be3d0833f98188d7deb6c827378234a47d7d1a13f141f36c0f8203b69f87cdb7fb5b4d712b31a0c3e1ef337ce4520f9fa8171ac9a97347999b9702b1679c35895a5b6765fcf26b32559548addc292edab5d2634ccf36638d18fe0c94ed1fcd52ce7fb4559ccd44d4c972c745cbf74063c02529fb3c5f7f1489650fd883fcbe05a05e2eea8b5f76bcb27ccf5b7a4bb92219d2e613e30f581a2a5de9a8e1257129394cd6152290ab2880aa12151de4626c5d723de4c66573a4e6af8535f90ce496b23a976f09bb65eb2d6e9dd6eb09c4fd7517ba0fcee4724ced51a36260a8f45e10307003fca08955e3c6f5d7024e4439aa4db9404dbaf69ee47f3d88ca3e84a1bd16ae4a912489a470788fde8c6333c7fccfec0d4bfe013a3f5f4c024ef488a9cd9f5490bcfd7cec062e329643b372f7c3b98dd98524f30cc5e9d18268cdaa704c10de3f8db9f0a5bf3cb4c3a909e0077cd2a87d777a4c1e7e63fdb0713c0aade8ecd46d9bbf7fa9d70c62afc9f3765a35c47dde930be13f4693077f2ef1931ef9cdb67b1db1d326c7e901dd1d2aec7c0a8125296e53344f83b55fa1b96ab9033df93f788b1c10affe3b5319ec21bc96eb751cace36f95da87fb93d371ea8be9860981ca37973cf500c1f1849fb3b59e1b8615a8661b9bb13ed08428288be00d354340c871c7dcbdb3b0d0ed0cd01401bafc767cc3e35ff34edbb22850ebe44e39f1d247b6039db182775b8e4f1e1b8ca5e0df1afa13b980be78398dde12bc97aecde82b38b149a3593bd9786ec408445c78bb433511141d204841ea9b8c290106f85e2080b6eb682a8963ff37d594861e0e01b7f2eea7bba91a95579a81493129622cb7023fd62990f0066dc162677bad92dfb5953686c94c9e4f828313f594d556177408ba2f4a7f5c87852c22c5328c902c2319f9bfa12a4ccce11511dc0f5a47c0eb6ba408c9bea05800e471da55cb7c01079a132948d525443068aac45a9010b2d9c7350a4c227d15ad2d8531a03cb5822347a6eb678f368ba84b9320ad9d0bee7595578c947327571e269ffa1ff4e3c442a6ec2fca94462dc4b5e6803a16c211bb1a309f6f08ce68323196ca10671690be70908c0429e776d344170058ade695e531af9a311643a81ddb1e219e69fae29eead6b4d1fe2912b23998df75e889d2c374ed7a749d731b34797bb450fda1d9b8738c34592c0a1d2ea791ad7ddafb3ed7601593e16d56cb4fedb4da7b4f878db0d372c2bd0d86d0d9135c2f8b3a7cf52c32f69a2ecf18a003d050c109ea285ba3e7351c878c59c4863c033feed0f5495a73b17478f70c31c3dabc95da4248bbf7283e2f073d54e06691cbd36349643b9cbf20e4093ee377bf25435271f4572af08ff3cc679f21f37601b29185d67f25edd83fb6ce2041d2d8ec756c833e59b8e412fe92fa7a8dabae9a5fe54ac4f86c21a70040c3a4a18eb507ddf473f2ecd8aa84e19de7fe3d21d2be2a136a5c5fb2880366b1fe5b17a8559e8c754157ebb38b8631d7fd1a3df0ec297015c64025530c69d1ec358960970d4b2add50ec178f9bab2880c711e2f6fa1ae93b67595d7206db1a68d46dc1c6fc359a6988c392ed72258b44b349d346da7043778ebb590d931f259c8783f0a9fd09007452604c5f17bec485952056966c63aafc312aa701d2f8d6a67da6932b3eb2eaae18df472611c55f2144b5be228da49abc5c4ed685b5b423f46564c1af7c056b1ef67d5826dc8bdff4f2231e346ca01de2ff5b3367b48eb4b1fdccc9c5459b05c7c07b4e61cc8c366d58f5cff4ca9491f62b8acf22fae109be9bb70d685e5eead4904cf09a74ec48df35d59a16b3e8acdfbafc044341811caa86bafa5a69ee9b2c1f6cee85acbca44c82ff1a55c9b375800fece344fc4f51aba67c690be82583533bc45cf5e4160950f35ba4e735501b7fadec985a80c648bb8c5c232dec1f2818fe299a7a5d7723d8dc65204316f6ba3bb9c00677bd857414369e8514ece2c9536f6472bada3d81dc62c72ed56ff1dcc502dcd4868865888b2f9b4f61b234c79b6eb164d898d39fe689a1985f29ae54e4da6c2116a6802c376c51d1935fbf984846a7119bb0808d509ce9eb5abb7fcdb962347f749d1f52cf95bfc872e985d76960aecd9ef1e6a4d47d20e1ad4a327e835ce0fe62a5bbd02eb147bb336483d67174d444489430ee9a2b3ac5c8476667c6fb000b1c6383675cccba1a28c1cafcce5446b5fa3dd7d593a52662eec378a80d7cf3b72c8d50f51796ddcdbc851484138dfe9b008e00a5888d6bc56ee7107ac373b1949c81507a5d7bbf3621c03ab14af5fffc90989df87a035890824e2c5904544dcf166d5397a3e5e10726f4336e88dc476aa13c98df9dca200e27729602119c679ae1b1e973709c29f70cdd5a287a765c9e8298df52f5700e7ed31cc17167ef071c7b9d14e044faeb41e54c32df22b3d5320d334baee6755d386338cb1a10605818f8cc054f79e35b609a076cf24fc69cc633bab1522facf83ab4a6696f418c4b09a761f7869ee91daa4a84598b7ef275ab978fed6c7d9cda038e205732ef5956f393752c3dd133359509610fa0820bb54b4af7fe92c3f7aa0e708f2c3233ab8fa97f7ef878e060d7e3ba1aa4fc1cbfca0ec7291264d1520391b37c71fc003773f2dc8db21aae2352ef50690889ec9bc7ae506f0d5b022b64bdc65e0d46b478516df253e216427c6563da167a6dd30046814174dec711f804b401fa921f6bc50cd2d152cb0e544cbf15ad79a751b4c29bad69f803d40210656121385efc35464d3ac27955c2798554b45c0c64983e5e5035ff8389cf4e01f91f15bab746677bc3b9afd892b6b3f1585ed5cc7dfedbafcfc154adb9adca8d99685fdf0e225e87f79f437ae66ff88399cd81f0d8d56f9ca031254936583f831ad17e4e2c9f78f46e9c6f079f5c919bdcac12726f4897f2148e535f235b7c2444ec444aeb4d44441132c25bea1234fe5579199d36c93ca9fbc917b288d897fa17de9795edb9b99b6803c70ce9198a4e5bde72a7f52781a7d8c5bd7ac1f6e15e727ebbbc3a78022dd2c676870c346bff9319ce020e26e9f9c8538b4489ecbef5b9daadc0a7fc06ab7df1cf4f10da7bbdb302ed26f6983bd03fb13bca613ae2eef4cbb40ebadabf0a08b322baad83f3827abba6865df161608243a47d4932e9d1d5181e426679539bb2005331fdc2f94a8a948722c7dccfe22d3bcdbe747b960a78df9947e6c167410b8e1209e1bc0a18ce01f84fc4452ccbf0c432e60b0f84dafdac323f5fe99973eb511f4f4c5b58a5500107ad71a52b3fc9646b28b91a0c66a71ac8e92a4ce848a664615a03291dec52850e3b5d7221573c208f08847b1a04c5e12e47a8b1fc2f468de1f5f11de9585de52fcb16fd50752abc7bb9182c279f0786e8c9d62bc72106431e879eef76f881da1b01894a80d401ab4cb5b953a5cee56793e66c1d989b3266801c9bf986cd9dabee2d31f181d58780564f883cbd8ec2ea6a3d9e8781b61a4d2c011f98009584ca274a5ae55e0b1cb344c977a7b579e93dfbd42d7ac4c8831313e9eb4b42d746ecbc1d792fbc3c6b7b58d5b29214d062b90a467795d0905f1b9d492cf86f975793e6ed082b81240f0505bcc4d52022168d94dc651d204f02e9a453ffbb9940f6a397b76f3d14b02de34e8a3fd513b34e5bd0626c090e8ac9e3e068eb170f354b4b52ac5804f401e9d2799767eb5da067db5472547734cd46920e927c73677f097c01d435a396081a426050407bb85707cd7110088d1b02e5263b8a8f9bb8ef415bd941f8b7336313fd75f9fcaaa2e3c311ec1a936c20fcf05a472190498390f7f2ba6872855862e270582e840667795051d037f927f8eb37da12e1f7b5e45c0451f05eff1f76913cc46dd8fafef3007df436e2b659f49f81d2f4a2932cf76e1ee9115bc625440689bf9df9d727437f9a63fb0eff59dbaf730d15d8087af884cbb0c4daf5adb659dc55a505f98d6e251c8592ba173230e6c065b29b99421d9a163c2fcbbca650a281ac2b756e48d8a97b299ec9bcd645a2a215527b82a7681cbd66095127390bc04cebf5148f3999fbc20f3ead7aece9389753baf03b7a94e7df262661019b9bd4263f4e315bc33671bcd6fc5e3b0a3e5d11d0c8fe00814843da793fe5d905dc9b941d9db2278a2cd3a9e12eabcec6423d34421ab22d8e02e729a61f8c3063c825f7630706f1e08f277bf9a78b4d311251ee15b4657793a22775a5fa883d43d175cb2ea509211bd03e6044069cf75095df08fdd535d5f9b7a041ebf347db7b976b57eb1c0f7a2420292f189264b9c216435c89febe8329140b90b414b9ac1359b9a191420c53dabff202ec2704744e6a03cb37eb1ee3806edd126beec0a6f50d6f5a28cc5cd64eaa642555f5033c1566b1dcaab852cb07e5460f77e01c9ac940d39fa14e190b56e0e6eb263a2adf897f0f49a2a4446f1b6adbb3ebe768d2ac75d7607eb3ccc592581e9cc19a7ed068038439adce2ae47f3858a23906dd687dc1174c73719279cfce509793c9ad1a5b0d372670aa2e58b5a0afd5a29a3bfe7e06120a3b066da350fe9fa1d42b65b107f5390230a3ac100786896b01542d04bc6802084c72108ce626a7d22c0ef013050518f729fea65109287906b4d73a1795b7dac3956944b08a6aa69fcbf7471ead6c8df8c69dbf2eeddeedae1a764f6da6867b183f8f82ef7874544649ab4af245cd478768277445646a095186fdaf98fb2733d955829a0ae171a4f580080c3a583440f91ee8b7a90dab8fba7a8ed52571824600f250a331806ebb91b10499aecc4479de2e18435ac7205b2503fd8abe4f973771499357e830103e2cee91f16d35b1a1afaa8fb8c4e67625c6895d6f707731448211b99f35f64d0e7e8b5e7ebb66480a88f2b76d378c7048dba1c87099cd3a6e73474a4b8c62fd53f4e3d0d79fdccaba978474a6af30aae8c8b128810352bbc96ee0581a855e2c80151a553593926fcaca1327e923e8522eab80d21a82859cf08cdbbd509d21bb5c31a224dc1ae772efe6898ea62188d5276c22287705296d6f2311cf8eed6566fbc78cf9ff6963d07fafe3da7eeec577f8300c16728618b9066bb5d1b97c5cc594664595ebb37eec03b4f1b1f40a0e653b2207754124efc519bb768da30c5160f3b50f3740aeedfbd4f0dcf82001b1b7e49b85f0eb6f412fd7559e8918e4f712560ea35862d6b347e1546dd6600f99dd1b098cb7f074ee7b4a30b182966b61dde33a94c4005103842e974a1e3ab415fffa2f1b1d3491e161619515afadd250555276ffa5525957e8902fec318f13be40ef9e61da33e9a5401a463ae73e49f218ea2f593837c522ca836bc9c0e25f6737dc64e39de9d574100c0738156d4ad84384f38bb123fbd57bd5107c08438c853e702a6d128a24d08fdb89c1ffcc8bebc994127e0c4fec27348acda0cb04d2d869b470f552aad0641a60e661e737d013b052b6db42f8227f800921d668337f4bd307a3e40a853928190defcb1b84f0c50fb2e4a4e20f92eb4ce8924aae053b816ce4820024619fc1228b63c097b2768a114f2036ce9d706484355769298b89211f79a9a4f0d1ac10b3047b296f5f4d4276548bf093d1a8bed3a58ea859ff7bc9a6629719710396db070ddfebe5bf7d153d62df2f977b341986cd4e96b14da7c16ef392369ba796e9714bdaccc0d9a68861d84d28f1737e350115e6c9f7536aa6cdfd2238095fcf654e12f8234ed80135dc559c8a9de9da53f7aa12cca488faaf51b913263384135aa5cf0f5d709cd12460dafa714666209b879ab45e8684123c36a84eba8601a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
