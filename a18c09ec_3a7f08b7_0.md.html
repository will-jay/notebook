<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"223d2eb47d3ccf1cdd3146657c627e02481d3088570bdad7b42c825137a09cbde243fe5d35055e9a83416e801df8dc09ce7e63fbef521facc64ceb502c4a3cb689a5a57d968b28bd06194c147927b3bc1edfd711fdf5eff9b1ea651256e5a1b58faebf567bc7c003f70be924211dfae5fae852a9cf45e1192e329de025334b53d4e86a9e761132e20f167d5caa07cb4ab6adf6bed2d5285ccf11381a1253bf56279eed330fe8f41a0c5d039ee8f3eeccd5ffbf8289bc4ac81c9defdd78895dc3555bcea376d641103d961c8f39785494c5050a77ec458e0f215be8188c9edd7e1eca5ec7297d4bfbb493d9ec613a4e0619900cbc6c37f13c34b5e5aef2b1588233a559c483ce4962d04c2a0cd25b5c677f6f4574573e66a7b227192abf94ba0f612f523c2c98353e5d57d6f6f1a48032bbfd8476d77c1d962740ec9e66f838307a7fd3dea09f02ed6c1b3dd959519ece367ca4da2d9371a6996384781c864c86d10e046884c80e4b2048a180542fb7472b1002bc65c84d7b80207ab0dc22e2630f720ffc62bca4cabfe1aafa24e9d47c69b631c6277e378e2400117be3d7281004a6107c8d0ed0b37ff18c23ed8aa8367a610d908d6937449dc6f7aa2148c95e91bc81c909bd13817407b9072b5146e176c3d5e5221b13c7f51bf94cf0257a5b999524be7f27079f6965a89a7aa436d6e05033949c229af2b5030d46eee441334ee3e3c837a9225a3d88365521d927da6577b5a07d004fe94b7394dc4db73bf74e28abc3263524c8691fcf20f46289a0120f767afdab7b62fb51bb9550adb8ca8b881bcc9a691941b94e3f01c3aab19ca18a296468441133c341e6712654d89b13e2163f34874b861bc6eefc8efebfae31102eaa98b2d35dd7ce2f9297c6500d99f5d1333fb1226be8f6de4fe396e0f6f1aab3a0ef3f14fa7ce3280d07b23795f4d9ebe7db71a093d67e31993920a1ed639c42204c558b5ac1f03f0053b3c44453034dd77d7d1ec5390a3301416a7d0b629f5de3df79cb5443d96aec663b3bc27f261186aaa841bbf27a7877f1f2142c03fbf6b4f4192cb387fa522438d7564cea9725649a3fd92432c261ba0144a1be0d374cce24ce744ac9b8af8573ae56963cd0b7ddf5d015dd63cad7003878ced3a905c6b8b5e03cbffe07edd70f2102ad727e8790cd5cf0fa4e21d723115bda524605c55972b59be43a9bce78126dce64ba3a370acdf2e3e694fbfbf7d2fb84b46398c9e542f7e4b58ae961c4267392669b3d5963759d8ab1005fb82ae394fee0fce04160cfac506c4cf7a7678e3bf8d0b787995da21f1418f271183482e67c0bc0b41407ef739e0710ec211a491a5620feabc4c0f1c03b3349d844222c1b4e2b6bf7492a1bfcd47514d78aa59facadc44ec23c93a8ed940d7014a991931d2624e9f6831be8903027fed084988f354f670e53459fc1fc2b4b79ba5a9323ab1130cf3083baa4d8131449003915a679ad29c5da51ebf8e32a18d7b2e2cf69b0b9d449c0894db4e6008afd3df474f6e9ab1d02256c4295565cdb51036c7e2796dfda3f6a7b0cc655ded3602aea26974cd0791138da62d36658a8483839f309da3c443ef51bf67767beb0f3a5ddc65c05a063ae43aca84a4a9d928d3f2364dd323a0992ee2828045d137cc832a25bc8c2825995b5fbbd4680f86efbe914c7ded32869489d4575438f25d268b2aec77c260331d7ac9f1df8d66c1e70183f8a3abd150dd06d5f0276edc849f1b166babaa50f5db4cde5561305b7db478794f38e44586ed7e5dc63e653ac6a5539ac6ff0440a5469bc60d7c6f950307a621441ed8dca7091b6ccf28b51a3459cb4943c403148e6b76ecca7b3e09d163559e78fcc55a18b4447c77b219a2ca70518a15c231b089796d6b1756c217d023d4dc1c1fe938a3ebdde096cd89079397599a078c0c08f8817a67ac82810e16a4b28750d17eef1fa8ccd552ec15a5c82db7964ad0c4adc2212195943549e4ca1da25cc18ffd2e1b926a2588ebb5a6af6a2cd344219a936a45eb8e92e1d303935c5fb4f5bd8db2e4fe24ac03f183042f9f66350f2f7b7003985e39454362a3253c16efc70ad2724e1f4505739c0ba0bdf59a2dfe19005f05c0ba875911414f77fee12311f7a3b66a7848a062c1521aad7451646ef04ad260091492c61360a21ffa7edbc10fbf5163f41f92c0caf534f892b9b49739b724df042ad516b8a9850fe1d7950cd62ea1e886a1b7b008769802332fe324d66ed36d62d7f7525cb754f28c0597d21814191a7d39e1699f7f849bee16bfb41ebe2a885ebc5d6ac68eb18251d5ba053c8a6a5ef970b32c812a8f662a6ab65ad25c25584dbce56d9094273b1c7473b8671de5832741a994ef35ceafca5cb5d94b46566b32eb76f005619ffc938cf1d1033a443590afc4ddc05fb20283a8056282d1bd33919f80421fa67e7701010ce612df3258a2ca3c7cf3daa1cf395405a98f8d894c68ffe4067d03d7c3109bacfb0c4b0cd3ed2fde89eb0ae3d27a1a9af6c492f14dd7db01ff214c2367c829b44d1108fe2a1e628da4a68a1a293f098c33a67812be7563037e878543c7eb97191fea00601dac65311c39b7408bcbf2828386e420deac698e1aecd5739c27ac5052c728263139de61d59a937046c5718fc9915d479dd46294d65e41cd663981a5cfde5dd0fbef5aedd1d610c1bfbbe6cc4bc4fb39e00212a11215f1602624e941ae09f715ec9e52b73b0a2ad49acc5b7827dd2ffc73eda3898f56098cc2a08b27b1b743ccfd0c6606cde949f99b6cd6e1c9707d80cb9d2b30c594afda4d6a25b48415e137b87e6318e37ef110824f5127f1caee0d23d6d8d74490f28a83c9de97ead7276ceb19dac66456ba859c2f11213428a98fcca4e2165d245a7508803c93f8b3bd750e062f9f63e4c4397582111e897ddf070213a702a33906ae5da418bdf0fadc4669062190c6fb4a7d7b58dc2082e04374d7bc8d2a658f7b61f6b41c7621bcfe3de02c21ad1ad06948b5807d4757b5a5cfde6cea7c97658b6331fc9f8b06e30f7629ee7c257a532fc4440ad3b3687c9816b127aa51227c05ed94f47b5b92ce5a4d81f24373d5779c7b82769acd290f8ba3f75a1ab51da0fc99e9c32cc46572cdd79032885e90edf2e01ce10e3689b731b70dd5342c8808ffa9091283916c4498ca0611473494388cfe5125893a6a77d9f22cfa5ac2a272fe1edc321abd273fd28ff77a3304b8ad6d55f3b3d3a6cbb8c50b8468a28f4a93e62597131e8291e3f619b5b0c7a9dd82cc359dbb8d430bf3deea844c2eeabce40d3d996e0b2bad49e38434b48a9b0aedbc616bf1f77b6bd6b66d54ab3280625d0d99b327bf10ee44f2644c24b264e6bcc76a5f52d0fcfed7cebdb5925c8da22a0868881f073126bda5f317a388dc0a592a9be1ae3eaa6af502d557ccd6d940e7d4a4430535957e81cb7725838b2069fa33d3f0585982bb1cb32f0a6e59ed4e52a01ff8b0df67d117ca3f18f9b92309fd7711b0942fa561c80507683e5e86e3f6819b9630513d54952de59a14328da576b94cc984c3c8024e8790dd19307e2f29b7d3493a5224fc41bfc9c44943221f2b8835454fe04f39827e07533f27dcd831c2f54516b56eec9dfa57ebc61a27b9c027e6f6685901919c15a37a975d1e5ef196af410ac287a7008d3472f135837a542a117f31083fc02b673f16349923f95ffbdd5ec71e4e5325ed21b7f1b9c4bc96affaa1d2e73b26aec1a179040c7f030ab76c2b0a3b2a3a518f472acd4fb32585223862c77ceda5972552652f37fee8ae8bf12325cdde73313b2793025cd9822c98b33d92f07b7de516ce4cb6b7121968157ad00eac6d8b7ce8d6b12270b7262c624db9eda945780835cad729ae6c4b7c47a81d5d6f7b56ff505993cdd40add3003345ca11feac6c1a8c7c580a01f9ddef581b99b77e3655cce1b85e295348bf09072da248164377a5f1e8f1dbc829a40046aa2c795e83cb72ba534385cc1d32fbfe395c7b4737320d82a6321c7ee8191ef7e326606fbfaecfcb537aa91e3829da2582fcf14145923df7b1e1f03a5b098ac4d517542924e0a46d93aa84e150e78d6f5ef72b1a286142724aac52ac79992fe5d04ed4e72f25734beced14075443eb3227a71804fee77cfde99ea372e39ebc05d2f7840b7bb65f619bf433cbb6d22e8e4e71b076c04ca7cd052878e61d567e721b1b081a88e015aaf24946ae03e1b640dc4784fc2bbe5a58885b7b3ede246212372f1c78023aafad055f097621ca36e022c36af6edcace257892b5c1a8e4930a09d02bfc1c5937f4f83c097b5173600bfffde9ac325caf4004ad574155703215e5119b1cdc7c0b2f34317d3a247953f1ed47889bb31b6db6d9f71cc89f28823be34de0f86fc96c8652ed76dbf4defb891cba821b2ce1608492c1698aff31506ead871dbd75a622e8bd3d83558a450c858142ac8d12368b7c1f7fd644b321f94f463a355766be3cce4282683fd4416dd7f2dd04797bf8d4b47d725f47e9e7a8cdf83b7c32d6d2a3f31c7a4e5b20c992349224edb63afb9bc4aa8f2c3f23a241abdb9e9591fe4f901246200bcc820fc417f116557ebf5e127923f622a73e66cb27c55140c4bef7ab6d77edd30c258b52562ba439aa8393049c74af1fa37100e397f872a42e38ae54b184b881f30b470e5a94702700044b9f68f95b02e5a3dec4630198d0da8c4539f51c1eb05bb40e9c78b18b61dc7f01f5191b1c053abf1295ee655f45886c664f256b3d209c20c4ef17b4a8dc9f6a83b953159c991a163b89b661e17a33152b76d35c565de637a08e747538975183cee10223ae28bf76fae8a015bde4d5e12be7a201749eaecdfa0c0dc26aba7c60e57d5cd5c601c00f58ead95db53f38b1fa550ff4942eee487c3891a45b332b9c46f39d79480b971cadb853660f473feb2e3c778e4d208b47565533b023dba5de3f2ef12c77b6d64b0674f83086de76645cb9410e6b8753480cee078bf8d716a342945389c9cfb5d9fc8dc84cbb6f874bc3a97a5742125301bb3b64e342420d3f749ecaaaa4b266a0d022c9583f2676979bcdf389c776b8bf7aa3d20702c1e121f01b5b0f871072bf9aff8d1218469cbc4005d27daad34a9d4b849e31a02faf03a9e112b6d7fcd5e2468ccd720dc18e31e56591f564e78b26a8c4eaa7a5f089805351cb084c24e48cff841c35cf28b78abe7d9e512afa92439cc67191ed3ee6e8ccd1d4214f0d4ba0d1dabba5c6c275d4e350643aa4cbd49c379ef99f09d002d6fbe0553daa6b7cef029849fbb295c6bdf6006fc4bbcf4c1f6775edf340556047d770a3b4f5520d0a761d5b663628988665efa1b513299e594c018c470489947a4c09a62ddaaafb3195a99013faf9974802f2f43ed64d95cd295095b18bf3e89a181f193774bb6584025d61564afde9398b1b7699a9d695aaf9695ad5b7854ff4e926c0fa6e55313592c5982e825bf07b20c02d70842eee7e452989019a17b8bd7e30f729448cea92fef90ea8d13554a93853baff54e0e22070458b8e92e5a94d456a08ee5f8a1b12b2bd37acd17c5e3909dbe5630f86efd131efe3f9dbacf250db1490ae93867da0e9296444704c404a999b063be8b0f6c42fe50562a4bf3cff9cb1aa026d7e4a86a18c4824811b1905a3aa88968c594d393129f4fe9d6226a8cd7e6440a3e2781d005e3f933eacaad157c3f4a9323147a17eae20075f37bf570a769e4927827216cc9c1f2b5c8417983e167ae9cee9f88dcdf1279289af2786a8060f23bcaa99f8c2fccfb42c30d55362cf6eb4eb452f0ffbe13ded329c6096d5c2dcce1476b82548819e27667462a779bb0a5e02cc257212283274b24a007a94b45d23a12d9343a27b79f0836c39dc6d1ca0f056486a24548dfa76f7e13708e3fd9ec01bf724b182248ee7ae8ec5f189ff9a13d45b28dc42880516b1c51c1a80c1a3110e8739568635a57ca11dba5155fe74fb2482d6b766fd86c62b1098ed188a68b14fdc26b32131612ab594b74e79621e0aee8ac3b88953b6dad998fc87f5f4d3296463dc094d7e9ae6b2ac8608ffcc0421d6a09515e4b1feca32ccb0b59bbf374768fe8a1d6946ed9c154d8e6222af298ac8a9f32b4cb3704387f404b01d1cbb9b04e553200f52d1709f6d655ac2b9720e80a8ae1daf159c3c955a7bd0910379651e6800ee89800d5bbbda659fee1275f9771c7ea6de3602846dcb48aff281761e469ac4bc8a8ef307f391ad2b92ee2e5dd930259b011efbe1dfa51443f24088d6a2469cac932d3b4eafe8f88fd0f80d5f5df67811e8fabc669300eeee874d08cd564f5fc81b3f4a7814c0f39a4052c0c70bfa0e0198b316a05f690c93925be5c6f31735668306e7052e6bdfee4be560610059ed83c766b50d80ca6cd48a1c7e7109fee2aa842459cb06fe465b12e5d0575fcf3d34ffa46a9cbb0b53fe71d3be47170bdd8163b1170fbf52dfe2f7ddf42f1c752566aced46c904482f512c059128cf4d7d906f2623c17a5a21e85731a02c9d325da9d289462f6e1cffb1f525d62f20d9bcd86b2d9e4204d8874b2a98d71c2327f6def303ecd0528e66681b7c4246c0d5f21ce656fd0911ed77b6b9a2d9f9c27cf35c306b9e9df7faf3f9ac955cfff7118a46abe08fff780995afce0ddff302775d47f71ec6c57b429bf4ff6ae0ecf1575b34c063642467d3d09d6fa6f84603fd7f815f0d6a81ce2591b8b4d0b92de444b4a068c53ab668ad5b0ceddffb81686a6617bf74115c6c1876df6808f3b95bb98fe8a3edeec13d23189992774b4e1cb3a1f09d646649c7d97bd00e38cdc162976b4f64aafa2ec67b45289ddebc9d2ff661b3a15d7f8c8895627ab119f96208f1bff071bc8c32860f580b4145344a3b20ea8afaa517681acf1652eab6db04f78c095d203e8bd79a11d62703f0f8b7eceea242f98184cba0da94a769b4b9d5a7277e9d69bfcd8c9a6e4d765b5602066415e9fd0ec8a520da7c080993abecd7e39b5c30c2a579059b7be1cb9256350aedc1defc3537e4cacad4aa7be1c25b1cad6823fd96f0bed291a72a300bca48f14589cc598637d7f6fd5c223b2552345e866a9c30ad23328640074d4a0226762be5fcd1020a6801f777023dfef9169c2c62de75890fec502fc5776f27bb3db725c09fb34c30afc1c4135727cf0a11ce2ad2eb9c947b527a053ed649b17cbce89e6db26ad3de9f4d19fed87db7c6a17030159bf96ad2fe4e12be14f7d4f54100e8476a887a85474c92c13779a8012ff097faad6b00f300f94109661e063ea4ddf887bf053434d780d5e18f7e6c07a39d6ee6e437e25173979e76e0ace63dcd1ab9032b6d1206ae863b3e4f70985ea48193974888ea4278284fcacc86f293cec6388df939925b0bb295d20a33dece09e37f36345203a878acd79f15626353ebf7bc212e041321bba7c704d867316633059ead31ce5cc44798457b10a8d6855c967c8961e5c0c15e3de66d4a606fd1e2f37411f92f619ff36a7b48dc40de161891a202b030ee9f44d8ce13684ae1da244d286dacad72e754a98cfe69ca5ddb06ee7386354f68d3e02b4c9356f2dc1c6b75754cc6fb4119db1bca60cb3d95ad413acf620f9ce575fec86ef7d99a99c78291c74503e3b553fecb9a034e16afbf8fbd33413096b6e3904db558a639d5dddc10b3d7fe384d9bd53d7b810c0d386f9047b95b0a4cba56c36549b9bf4457d565d93b3028977b30423f3f7fbdc43e53c6f7ef27532642e3e381003b802fe9d166a53883fc0255f9f2ccbd83bc7c41f4dd0be850a1dada3811a0e233d0966bb989575c21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
