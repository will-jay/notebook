<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b00fb37b2e33dc5051660fb4504dcab202b9d9a06a6f0dde765b0a95acda0504e69189c589ff39c881eefe49efe9b41d4e32a0e88e15eb7449d4b0e89a98483090847c54fe864c205425153ca23b28f1b74ed4b7f2da817134252eb38633840ed7a3f46d619c3d14c9292ad5f6a8f3f87217f2052b5f6c670896f0445c8bf1143ec4b42958ec73a6cae54571efe5d39d7a01aa39d1d3cb5e624c86166e30855815d3a8718a5d6000199d2d71183e87892dbd70f01883eee4e69255e1385e16607a5d62383bec40cf2aebca45b753ded1f376ac6d05300a0ff65bbc38e8a0fd1aa2739489d89dcb892e57d6ac660518dd936171e628f4589f73be04531d8dab40ed205a4bc95b24d01db4db1578f6b8a60c0f46360fcfff6dda9af95ba2a7f7decca99ba0f08d4021e05f789be474f911733e9702093e407e9021eba51a98db6c79d8720a7141e4a0828710107932ff6f0eb23fbc4245ca6227d083077336b2be7e25f82ac80887e76f33af0497693f918c89d30dd1b2a8d0a855b7c479734c773a09185cc35f5e6e4d38cd54036c3996363b2f162f88530d779d0a03a0c0bf8dfcf70f18d9d1175b67212bc8672ffa6974694702bf2e9757adfed174cdcdce21fdb021828d7fe98a4b2ee4a97930c6759d5c5f807093a61acfc8a330d2149718988ac323f10869c1a8e53a8fbfc66d2a609354c04e83faef8845bef69ef8429632a0b47e998c0b15813676ba6798346b9a532017eab82c45c190af48a94eaac31573a9eb5f8d9a52304d6dd47ee64a3f996f53f179ae1af9e2a59db91946b6bf6da7ddaaec97a2cba6481e810a50000dac1ad5f97bc689f0b5469aee694d016e05d2e5de9940b2fa62f9eeb3b3d5668a7acbfbc7b67d90e890b82249b301e1b99c44cbbef445502a702dc98af438ce760db63e56944d1ed56a746836f7fccd51c9c1a0818e4f2e7bf04ce87dd74b34ee160427a3835deb7d6377b86a0810faead01ce4eff252339c0401c4986563f744c32dd70d19cc39b9a6eb99cf3a94394e3007f701adfcf68b8b83c1dbc7292c399dbf2a8e9bea9a529bef4e0a9f3e2d70aa511c7fd462f56b44e59f2cfebbcb2860e3f2e4f655a3db51b3965653908e98d057783ec9cd01eb3416a3a7d9b04edff13354b2471a29631533f0865498d8a40c1994b1e9f664d5146bb9f7323323b07fa1fac754cd1e6c206e95b5c5c533d749c380e67ff0bbe2d7fb9d0524d733ac71fdf22722e21131eb52b5be5e178b4ceded0472fffba9d0bee5404e7866f2152dd8fb748850812e40942929ff95d6047f0201ec5b337a744912f1cb8272990e0aa46d5bb852437b4b27e4021204189620e2e4e02ec086721b48f0455ffdc85065082635d006f02c7145bb806e1d6d4d595016f2db853d88e08a3bfccf5ea1ea0a2215192980cdadb842e4f29969484333608d3ddec5e46a947b947621177baade685db1352ac98e38796e8e132ce720753e08654a9feb083db11955f717003617d152a378e2ac3d1939cf259585af91d229237c6688408390a01768ebbb40de1ae6a1ce495af32a323eb6eca1bffcaea62bef72fa2dd671539d0381bbe4fa48027296cabb72255070f5964d9adcacd51ea219b1600c064e3e125e2ed847537fbb4f9627b0ee7bbfbad607cf0200369abf0c61bf18da3b861c31e3469ffc4417a54bea2b1f69a46685a817f8f4d265d18ffe9856be6ddc7b5cc82572f39789ef0800fcfdbab36701828f5e551d6d856d723271f479a5ea0b0fbad9e97006bea9776f270c69a6fe6d7e6e1177157868bdfc8bde40ff5297e027017dc7e79759318c7652ea7ede87e65feb6531c34a201a1c8b6a8b178e2e4dd72225c913c893387b3298a9cdff373c5825f072c3b1d79eabdb5470c8095e385c0340d10f11962211516eb820ad95ed2776862a0ce9ff62fde9b36d33d99ab9617571ffacdc1732502479b0b09accfd6d619c3d25a331ac642e9717333dd7374cbeb232d93286b8a95b873cb76a65d00de7e2e205323c71992164604ae1abd831f93e38ab09f0c7f3a09bce6920abed6e124fbb6fcab46b70435fca73c154709ec49976dbe3672c79afc1d0ccc1b57789b410399e30c26e1b53bbe124bf570c1281afdc5f4318fde9129ff20c9b1509c351f48414fbb1812ec4ac0de7f5510511a6ee92efbd8b79278609ccadfa814733dc51fee4ae10e1b34a657d93146d0a8fa1cdc331850c595fee70d09d9919e6fb395d299a255ad368c2283ef0cf8bcceb2524c6e54d1f69c477de7ce96f94296641a6b19e3e0985ee1cf499014a7cbfa7d2b1bb7ef616c741679a321e25ac158f3211c189a0c768c83219c648ee9da7b7a087032c8ca94a1142b95f95d42ed0e16e8ac8b41d638eaf948ae69df39b9c593b254ac9829bc990904d890a03873fe6b8464d2f83694c1f6937b4330dbe0abc3f71f5dd83d3004a5b6ee45efe14f2e990d1b8caa004c69a0e732cd261c2f531384882d1df51d724cc86e7b86f3c88b0d7cd399ef7c8cba7a90349eda054f2289bb50b65bbec208d4947e9a17bc650f5834fd6fd4dc815d4033aa3e73ec1cd353da4f0dbe3802afb5341509ca93b247a42a54626185f483f625cd0d2de1fd4e7a982db492fa3abae0e01cdd67030d61801086be2347da5238ad9b20adf228023547f38cfc314823b98b87120825da0afc218075e2cb978f176a312886204994212393aee23b8e105f719aa703e27f6620983d1defdcfd5b7a3b38f1fd5309e0e503fef6d1c199ed0c73915d9a5cce15f209e31385d39a05e00013947ef92fe8c051242ed591d17cf386f745b998563a86a9f3cec7ecf710ba95ce84de7d63ecb537cb9d46140418a3b5a9ce28f95fd2e5d981eca472b43d2f8d711794bc8436b4095f3c790a8f296bfd1c0d4e0a848e3c4aed40dd80c32f75171e4d6c591bc713d13abe808379f40edd504f8e197ae311b72073f6900a19e190f72d1ca981a434e90bb9e5cd43c52cc870a8cd287873cd5fd35b6c24edf65b239ca9eff4c295d9e5853cad972f42a4ef4b1cead89d13d178cceab5323bba91510fd2013116893a89f5fccdbd1662537de73f0ee5eebfa50595b300fd43e088ea53266efd149e1b09b055f1db26dcc28fd8a51b6aa25f77b724c287903581c5916b23b2527479d8e45088d30cd20ccaa9f33b3f9df4528c5bac0133e12570b7cc6d84e267db678cde5bde05d7feaf8640535358f9cdd97573707b295b9a6884a61b6bdc930e2ed08f7884580e4bac13e32f4fa6313c89c793cb073ed64250af887f2ffaf316e998d31ec811bf4d7c6e74393737c800722a185906abb408d8353938b918a07921934fe825050d1b13a64641569ddc417304ef34b5f5089ffe4ee30ff93d2562a3e2f3fabc38148a5acc35100930ec6c16f02c461513b2f8fa0014f44eae37f2736da0d29e0ce239cd27876af46bb6fdf8c0cd102e9a217ea235b4a4a7bd9810e752a1abf5e44fbf99a1698effa059fb454c7d5b43c1da836bc5a8a211c3cc975b81b3c5e3013d7243915683e55539cd1e796e4195e836b6bd2581ae4313d0e31a9a14b5d1bb707e47a68004296d42cee108cc593b13de9a92d7dc5d7420b2e77733fdbb82012cc7ad0b828da9a44904c42046baf00fb1258e157c6585182fe4920192ab5c84343c2c20a30a66bb9969b96e25496a68beaea703fcb817903dc242891ec5613a06188e3ec9ecd1cfc1f1bfd143d0452847fd188425fe171e25921af27a08b729987228d218816afc93d0bce54dcceb086c753dc9db40287e947ecdfc6e10841b8b20f4fcfbe2c82aab4df7503cf96b95cb5210a754600663105be832532d62841d9a6452a02034f774e21aaff238e7092f32b628ebb6e4a232d71d2d1bdd0c0287b9db07a7c22df42ce9f4df7b2a42e6e4512dce63fa55ca504650bb76269b773912f3cbf9b835981a737164e5d7b4be77b0c2334663a811517ef0bc3b63e45499098b9ab3833bf4ee04455da96ee10b4da2b7b507628ba990a5c36accdce740a68a008c3796a355d326fa3b0cd828d92105a09976e79788611af0a913c679c84e3dcf52eb369dec9197f0cf6711eca3bd7ab2c6c2d84b387a6467f70bdfd26b1e09358c4bc88291fe4d59d37af444e3a3091f16d87605b9043a615ae8c466361c67665e2bb167823ef2f9c217b3c495e1191105e35a37992342858a607f62c863b592b652954d78e23e3f3e979dfc9a2789bfe8571664c874c49509b3889359bfa2426bf68dfad27e776112580f00be6ee1089230c794000f10991232ac3e2389ec32d765d9b6471bd4f672a855f199fbe3388d7a8d130f58f320f433d2572f5cb9a919d3bc7b4c7451fa3342d62ec825feb3e8bd526ed36c55164ff8beb70b42f0d6bf91dce2bc362fb6a7fc2f508e480a42069f87ee8fd584b97e83106dc8b9f8e1755e28d828620941f85b31f383fa7fbf06b3daeb67d9a992f0aeeef3613ef307bc7feb0452bd380ab745a6ac91c25e8818b657a60ca25adeca3e56fcf1468d9ab5c1dc9f3d2658258e9c84d317fd2efa73f2b515f09dc297758eaf75a80cfa37b643723e0d9dace211918ebbfa8348a6b2769eddb83809721688e199a66e9a6c69ad1a14a466f76e9ad92e7c971204885b7d49b60b0ecf45bc1c9e21ec234125d8c9130d82e9737581e9ec4dc88a3d037c24d684f9d4f1456de74ca3e4904a1427416ea479fd295669acec5b1d3197994b640450fbf8f8e7b16e9e04c583a89d287f69e871c77ebb0ddf4b22d3e1299181e6069e68fde636cd620cbf5351c895d50d936b56564c63ad380a1d2ef2d2e28f5b19c01efb21f128396b77584040f426575cfcf954f5b3770248a7eb846c5df59c0ff1e66a8ced9845ac3cc66df4bf8707d281a5d5f7e3d4d44a264280cfe9033a6ae28bf5d830b7673e85b194fef583ba4cf14f2682e377f32fb108d4348280e799fd421f8116f30d06a4cc03336e6c11a96129872f20093bb064390fc9486861977dfc43d928fba4030539e77dcf6a2832d6b922e6837c0f7dfa84922c4038b66fd6801ae04eea2a6de8041b40c4475ec3f5d5c9c6de15af8e4185854a72992292b34e5209215acb1eba8aa43a41f4353d43bf1c40e773398168bbe0df033f9746b145b1f61f4e3e6504bf944e36f0ce584cf4449b061e0ea8e0ae13b3dc10cd8cd54427dc150449ef3660462a4e1d3718136304ec04aab954de7857a5c4a8d4315994b526c6954a5b82fbb5e5a62c285fe518b71aeef3a4f1730940b929a3ab8ef03a9cfc4bcfab5a8c4db509da505a573f727f9967494246c214c4112a6005241635d20611ce4440618b8a423c24e5dc18209be86c70907e85226e4e9784fa323bea81095dc0e9a9040e0a0f9a97d0325835bdb7798d1cc2d649f7f043b6f2bafa7ea2ed266f0afe6da7604f72aafaabb6fae9c59fa0a0541b00d6f41d413a4451f2fced3b1455d629ad46c0c3d16060229058e2492245e25884c2f629307e2cd1ff36c0b12b0dd3aee7782cfba92518ccb6d3fe0e4f54138f62928ce2f80cc09c1f28737463e6b817dc6010692c58b15e2f22b1eee228545fd7fc5fed71270ef13f60cc0e06413a743d20f19e13462cce2ff2b3bbddd538b00010d47b645195889b75c75ccfbc3b9344206665179df366666309cfb04719504693c67a41a0f3345adfb660d892c74f9ee9d0acf1da6d67168b166a8b75188391d6e484b446b7529b5852067038d670f5d233ab9dcdaa95bb38342358e21f2cbada714c06c8cb9efaf826f98ae9ce36ad26b8be75f8d59760cf62d842729bda3d379a94c11d4a7a830d2f6d556e5c2275dcb062bae1b7ce05cbf04904ead8f6c7e74b9fad84bff517d05c600710b38f32ccb87ef5fe174fca31c609a00e4a9ce6569dad4909d0abf8875cabd8d0a8dd81e743826f4d0c964c825f889eae2145f221160a36a3ab96198f598b2af59cc1d319b49b146eb8b8edfb59ba2d2a4f9e3fa1a9b4a5b8b219da73083f96f980f02429dda08b1804f48b979b05eb940f7ff177a27b44bfc20ad09b2a7c1725938f9459e12758e5f08eaed5e1870bb8fd27dd8b34e337cccc0c9c6fe37af916eaf72bfc9a90df318cadfab78ea0bcad8cfd7829aece83d337d22067341036db79d56c48d4a8dc914bea65756b479fd6a0fa23e699d351d7a099f87c194783e8f3df0c1af790bca150cda55b222affa381e4ccc593fc4a6d775e8c363f87282955858ad3572777ab1507315cf6b1d9ef0c45f2b6127ba8d541b968d54b973282de634114b1bf3f977c654cdb982f4c179a4681b37a8745fd7afc1eee07f9b7598e150d2995b56ea20a7f7cd5c542a5fb0716d75ae944f4723df5fe2aa14c0b0e0d327d41e3061e47b91371f8c61027b27e87ce0b401e06d8b500a2556fc0044a4feeb90d838111a443eeb5245af6e3e2a96e4c35514c23805814446fa77306a65ceb9ad4b7dd0527c46c5723ace90965b0966afec0c1090884cc17d7f90d39f3acdc53c793dd2e32c722c65b2462d29e6ce11ca734df198a0898b79602f915aa3b53a0a0b47d3210d36e1f70cd6d5f71e260550ee24fa078f4db2775e3b42396d8f844c03feae8c6721b6671d0a4e6088416e559a2e4be70e63d7edef2bf69c261e819f7640f8e0936a1afe00eeec1c70a8871d9a0c955cf7ab73e03348084ca7ef9f0eec1d652f7073afd9616394346bdb7a04827c0bff92d98257043ad9e0f231c8a38baac99ef04d3c6a8ba80ceb90d3626869030400bc56401cc331c6dfb25d51a6445e36d3fce8718c26399b83ce3115b6f4544f1681e14ba97800fe7c44cb5e62ed9278d269bce61394798167a8c8b710ae217893c47c76c424b0f49267fec033b4a5dee7dd6bafe8d225c88f729b7666623067cd59bba229eb68b5a0ee9695531fcf9e602a9a1b1941bfaf36e828c642fdaa23ca90d1431dea58be5a4026a589df8e853e8a0dfc66769646eb8d65762c6db4cb425df311444c71679ff62921eeb1fc293feb18ab0175f65e45158d71b713a259bfe1ecb162e4b77145cf7017e459edb92404109c12e54aaf02d9787c7db5afd5eb5d43c2a47f1f5a163d18e6d247714895781826d74eb6829b23523d97494651e0cc1e8bdc307ab4661fada946c9537e5e10dbf6d5ef4dc69a236cb62920264741ee9eafb8f53c6b918996046e535194965464ced452dae9d8766d7cf1791b847b31ded59e65e496d10a2a8c6525b81a62458195a6f28a441b81f64cd0159c7d118bf112d4e7d7748bc8466c7abec64ee5cebb50c9ca62fa672871fc08ae6d70fb0bd195115be51908c14ff1163e0e03f3b071054d573f4b600c2c9a521132c391eea15f3790f4d7390f7f2c83c29f4f87c071e2225e8a48ae9b02d1ce41a4dced2682d5b6a494d54fc3ddd9aed4b12d3170a68b572e63c8fb6ae98514e374859a08390f8bbddefd6afa941846d9e28810039575770dc06afe695f6bdb69e0937ac0c3148bf9bd0bba69a8d28e9dc3da7909b776ee1ce7bcbc66937baf32005c741f06e3466ca711126c947b0c8d10eddc89a365164e23eac46e4a57702e4b82f6ecb2dfca2f103c1950c0cff9a0f28b77126c5d36922c8794c14df5894acb3e0b6d0dc8026c44e2b1d862da4163c16d7afa7a1537b9d172fa83b26fb564f14a949c31c4345179996b5a2bc0b16c8894e008c6e8ad49f5f2f9fb2ff10d2cecae8f9d29dbf69b5258421fada0ddf9f655a75a52eafeff7a01cea6959d9e00989711bbca3a2d73dae7312c37163cf21ce0c12ec2bf903d70a5352e2850de041002c44c08b422636d83482167dfe25da62462a6f8df20c7c7299ddd3e698434968b907f9158a9fd3d9256431e5e8a5c8845b8b34091b9cb075b7cb477e55c47f1f7a88effd6483e944d1f83008b450a18a8c1d3a3d695be9d75ab0c73540b14bc7c52cad4edc81e177bb79d8be2f1762219e9a924353bb6c8c3090e87b7ccf5688bcdc1983f81d5e57733854038fe66908268ed6c4b7e33118f581ec240092d4cd9440e1d0425d85b9664d377574dabfa1e787f80d08d83580a43ec7c132325163ce0d1aaa93d93a1944b82e8b04f0817c837f3f846386d885d2cf94c8f7e257491a8fb310ea0277e899b659ba30d0daaf884f98676456cf56cf2aa220e7c55d85bbd20bff613dfa6d7fc2d7493d4e3cd0bf47eee034a63f9965d1d35bc5535a7ace0f1df593e5b2fb0ab50a54b16511ef58c5a9992a9deb4caff045ff922a451a679ec5c7364d8739db5043d017590527629b062cce322009653f6d03e5a3960d0307457004577c125f8c74287ddda57f9e7d21f8d26a5dbe4188f6d42732855cfd52721f1a612dbe089e6caa8b761925013dbb1ecd08d5987f342a7724739530e6b086e4c83d0ff6477d962ccba33233076e3f75e848edc5fb841c7ce9d2fef8720062de2d65bda3af56e38d460a733952cae71b6f840f6617067de11e3931354add267ce9facd36894909f335024e1ac7ec785ab2d0c018ae0aa46be518f21bbc638ae5cf7e86f1a75513e4dcd6c55ff363b9368c3e7d5168e261dbc7cc13e7b43693de74a3c2c62115d954e2a0f1d4143a8bfeb663085f3a303e71ec5d01cf5cf217b0b9f05f8c092d7641dab940dbe306ba175974c889c3be317f4731fb9e980275cdd4fc2135ffe1da0976bc64bda283bc02f7b4e76ec0d01d63bb72aba4436b27cee5e4b7f7d33fd9e6ac33757faf40b47dc791d1bc807219b432153b2fc97f743ac468aa886953fe7e3662f2de5872d34e28dfba291b1de034a2898ca6e7245d2feaac1c376d16711e7312857cf7e884206270c5ae32092a64450488929bf8d254ee93fa008f8be82548bc37862a2adea738cddc6c81ffdb070005e20e62fa641d8f2ef94253097e890773d765f869b503d8c22f3b3867f0e465d49e1d3a44d899339c331299f9f3e48bf144d78253be3831b9a73a8bb30d0d75dbe355c62836a9c2fae6f655baec6ccc242dd8f749de57d47ce79050d04c89d0c6c053771713af8cf921e79eba0a5a014238f6591f9caa8e6e9c220117c0b1d284eb6ef3dd05f24809b92a4f24467718e2e083a57f5c690b0536cc17c980c9024711078025117095387c55101581bffaed34b9bb70f1beb029fe42b6f2c59cecd197a6d2dddf0d6151624ceb979036d2ac262cc962788112875b59497d00572aded7147ba673f46b1975647af9fdceb4f58fcd6dc997846ad94fcf688d8f8d66664d99791d4047180c4b16afc7582e3fd69da3105532dc969bd3c4f0e709e0ac8b001a4e2b956e05f5255332c3c53c143a0afef9e544f077c313fe5f86a81a3c7c3c455ab6bf3ed1c21893bf3b4ac156c4406205801cc62314d59683f682c1168513b522f3bfb4fb44cbb104380fb0989c471e9b0e666254801931cdbba1b4a064f350eb810613d4a05d5779b64dc0e8bdd29c39888f6448222898ac9dbda8ac3aae0259e33d4b0e7d434614fe338ebbd1856a491b7c195b197619fa2978e77872b7489f0a4448113c5b4bba5d9a8f10c482c9d042e78e1ab61ca9672f325b2f486422b88476a87b1480d810fed4a88d2491126e805febd2dd8e9712022ff41657640bd27eafead9c2bb5f465815c01a8e9697c594ccecb6be516c35ede197e2f036d57cab75fab16ce028c4edaad32370d4f0b108b978a1865328ac4f90865f9d24a458e2629c24c7bea93762d5935e7c0d615dafe9ba53ceaaa745110dc4f358c8b6a171d8caea463fb1325a03040cfe00d4a12fdc04b36f6732197f3d0d644f95b052e6eeb961fd88416312f2951a5f97ea92a856a52b19553ef33b1e48672aef2a3e439865b70285f835bd864bce350557a26d8791b6b215e915fbad783945e4aee4600eec480725b4b6f1a7b41b53e46041d3f87a336e782b4ceabc7fdd30c7648da9cec6152096c1481b27cd155a65c89b174ee8f1e457d4544023998c5bc28647ee71c9c1672d175b8647bdfa6314b4863c5478eb4f9c8818e8bdba9176cf70461314f422b7f49980e50d85e61d6684e90a3d233d0d3db0e0e2a9ab6b2de2f7a619b6feb7725e6908b81cb031f3b5912b2d040873818c933f6db5a2f9dc411f9db5368b557761ccf724ffadffbc55b96ce9ea545d59a61f5814c01867a5b7f5964eaf86915a9928f2141f4cfde4623b5515ad441b5478b368244135ab4ca04a184192b9d9f822ec79d7e7309b3840dd7df322dfcd69db720a83978c12d7add2f52526109aa6f19cb110b3dd156ecaadecfd0bf7ff59c8337044c5264dfc86563aa98a30790eaa9d03aa46d0eafbb7d7691daeb45639c32a5297973e45e95596e498e75a3a74d7314c92bb38a3b10803a97d51fe0d12910812689ad7b8bd362d9763d9ec64cf528794b604dfc0798ce090d50ff483c31b59b9221b3ad54ce6d17bb7e052a046311a2a8913229c89c06a59554e40607ae78f4bdd990ae9af3fcf1b3513b4cc8ac83965ee4c5e9ca7d9d61b9816b7a76aa3b3582c0242c5aa84a9718d9904f34cb5de9728aac3cfc7479b2aa00562a7ed835ec30142a088429146dd5e87cbae57c511f058dac4a58cf6699ca93ed507ec69b6cab0da43ca18c8498d34486321b8e775a90a47fe29f6b15a21a14e1c305b1fa8a767f4b8f9c4b4a36338b366149fd625de3acbc0de97f604374c41f27b292a09a98006f64755b93a20410ca1b3dfd74c3510ac3d4a93dd0dc5eec39786063c223c42e23cde2bb50397ee41f6f9e12f90bee7c49e9f1b3b9b303ae7e004c635670c2ce312bc109fc4a616455bc8ee73c02ad5632e9af9923fdfb1a321bc1318066ffe4ffeb4df7414c3e6866a7a6e0d67fbf8a4e1c04540c2ef55c7b621b80fd7c538f0a7148dcfd267e34928b1fd4843b4b2b7c7ac737e1763685caeb4273d99b62cbef73ae0b3e0c39854d7b591c1c6e3a5766184e15a19bf1259f3ccf7aac8a604a5b856d971a76f0f6895c860fc3c986c519926e5b3ad1472d498f3bb3f0aedab5f074aa8239aae61c87154a04ad8c9b12405e5e43b2278a5f2fc61ca3a636f1b971ee3de161184b5c17de5b4496f778942532a5959269fa852cdf3be66a6b5f615f817675659312c0f07611ff450230b41c634aa36032c4a7b00e55d851f0407a1f740fca0092ce53c8ad55c6a02a8b41aa49a8686d8df093612222992df38f97ab0ebb2ceeecc7e1eaa361afd90aa472dec39f760b98ded8d8f50ee1f3d6b181e21cdb92c13ae07ff58c0fb85ada826088c0053db58e1b28aeddcbac56511f26abc8d700878a333e7cabde7b171c5ad80d62a8b4b9c5646963180c5d097def07a617731c2f35986e75234d9eabed0cde1eaa36185784ed4fc72501ae075e23367ee6a7fe6b4358d04f85c9298c739801c231a64580856ad0957b2a8ac2ccdbde99588e9e3da0e5690fc9542a1742c8206bc3acc7644e399f89ac243cb4242f600b8e530017f35f30500c1f461b056f332a14445aaae1b27c3ce4e5731eaa8587b7d2dfd2b440373a0faefb31db00c27b0b7d0ff0d6955b84b589b099ee9c209abeaa49afc04b8c64ab9b1f9de45aacea9b0e9c6bd1f5e429dec4150eb257b983847c81fe7a9a08c035446dd52c0614304d9fd83257d2a0228cf3f084f215f2105bf87f4bb33bf1d31b6c2c50f6cc7f8663773e3b80740d7c7cd35ecb9db61a59051b267c566c185f762b49d589540df4bccb0706ba20a5bf047eddcc985282a4e3b2b1425ee97deffe3f35305a23787f72b8aaeac86675612408adbbf56150899ea9eb1214494937b1b817d335d7c3429e7c6f675d45ba2eb795056551cbabbf725301b91bcc4872488bf1a5c948d68e8296015ce3247ecfa7f722edc3ce2c74a962db5437f32efaf09d06f03467f6a13040dea3ffe6a2c5ead550a271384975870f58fa0231628a807b8a08d75d5fe73e0f66e79ed5ec67c282e85b6c9e0e6c92d2ad8f6c6c89768f25617c1783294337f21bb10486693c5f3d6c96f9098b971338369432baea0ec50219d72464a17f5c5249def724930122472fe41d258320a3aae977075d8a21a299138d8bcfdc8cac8ecfe39dd8aec4a77af333820da5737c079e6d2321afc2ab445a513d347c73798a42a2a4e64fdc1b2d371b60ea9764ed81ba38b4620899ca04e8ab293f7a14efdf33f56ecb89acf819fe9422f29909e73f06b37cc71e5a4f6a645fdb070955928f81aa4cb6ac1f1824d565c58d5e25b9d12300ede89db0f2c72bfa0bd32a76a41c865e5dc0bef9bb3858b54d12cd793e656e8f7c89ba1604516a4938caffcd70595d0284722babd19f2abeaa743c65f4c064d381efafa154f45a101024242f63e919f4452538a9e34154b7eafb4f695dda88424ed8d84b6d29686e03117be31691e62858ddcab7b7e347bf6906b962d3380f48a12ed6e0959090cbc299c900a21cd88c5de9aed2fc189a70286aab2295e0322a9ffa5eec9b9cb670252e9a2573614bfad852a8e9c7421297224b556e8a8c6dfd9c7e0fde98f73d78c1146026da5d8a1f2d89c02e9844de30aae74c32a0895d0f0e161c2881f6aba981dd01957028dc6f8f41e41d246b729c6386bacc3b768cb1b35516b27f4540c9d2a955562037746eca83a96687986f5f77bcc15a454c6be649f6b31c35c47416ab5d19c6993d448a05910b9548f0fe80f1bc10ab1aaaf2907a1932ee86f625a1a57545c65e782bd255cf247551c4ec32d0226c815199b5ffdcc87a58247a6ba13b0ac54629c02ba0c3659fbed0a92b576618897058219c6250be4ae93904c138dee474e9e7b6257a50ca8c07bd565998f03d0f5a2825ffea57014f4c2f45e5f42299591ea8357c2bd399ad91560a757653a2b819cb07a2240a1f9c2bf8e6e2060767e6e2cc89b33baf953c879d1a4bbd9caf4996e046937666d3f1b0271db48be1cbc7ac94d131ace02f6f379c1f5fc4b39c1bef6bf56f02af17f623eb154f0b5def514faaa81159f81beb101640281132aa4124445ab47a38a272238701ae9ebcd1eb48284ac37b9984ae33da423ed9f9645d25473821252fcf4b5e73d95f217915e11d636c29084ff93e09827916ffaa7776af14ba3f0639fbe3b96d38bf321fb1d3f535141d5afe1cbd80462a1a95fb8fd66be8a65b9306a17d44d304c5ff897d625bea534626398453479c0d249a1c0a70ee418e81a36014c1d44fc8a9b478b7088aecbdceffd64cda0a42361f52e05719fb83e8e4e6ed88b31557dce4a8c603a8db1241598b81f03d579423d08d1ff13eb1bdb9d753e7f44bbb4fa804ddf6a23e19b6cabc59e47ec5a8d68c2a89411996ca04b94ee063e0eac35fa7ea430c27d9e2a3d878329fafc4964cea8b921abf29b49e1db6de4ba0943ec27343951f869f7e6b9e1c131d4d13173dac3d5948723dbebd2f05f3f53e1d2e5b6038ffc48b2f53de283c804a21c3acc4ea52ac75e86d81c78ae1b9ec3d717cb51fa3eae26ebf1365b921abe77abe84b176124092b5f22dea4b43fb38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
