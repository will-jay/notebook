<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc11a0d86edad37fede8c07016e0852eae21ad4a696b08cda67379167e10fd67bc87e19b78587d6b078d8ce29f66c1464afe48b2f6a8ad774422a61c69bdc3bbc70e1c564a5b66e3d85b79e6c7262d7aa5a1c480e2aada408e93cc0fa55542bcf7b7ad94c430f6ac153103d2a859713f4b6a729b9ce4f0cc448cf5b2254b87ac5f0ae3239f0bbf552064d60fcf5e2eb9acad96cef30965ddd148a12aae5ca908a91edcbf7c3bc1c140f30affb21e5307bef894622c23b18a09982b142602a986cfa954d3bdd02ab89f3d294f578a90186e8c28c26880b93fcaa38d36ae519b65fe946c2e172e3beae29f018fe9d5f186c231ca51716c508d310986e4969ea04c4a1e6b60a6ca6cf64deab52fa51b19647a29107aa73e94ceeba6be059ff7dd854c4e8d5f6da09795630db24fe816d46b821855edd47778372b993bf58929f2622940077818684d403165e0590148ef926012e29c643e8ddafc7e9c1cd1b28c863b67ce751c79da06a98f9067cee42149a95c9c507b854bf624ad2ea4fc77e5ae66ea7836c19b667b6acecb905c8175b6d334642b520542a0eabd937d4cf5f3be4c2d02bd34ac129afa07114aa2b1ac2cab8e8c85a89e10fb54c7b31b9fcb8a157bc08fde499948a0534dcb69724f4319adb844a608a41a3b3e7978bce99a4b8780b814dc39e7ac79d8d1a8324726488b41b4f44c3a61644fdd5be572c0fc5ca7d91f28f801c23e023d14f630faf5b21be6f99faeb7c72af03ad3cdc98637fb2be142fa6f40e5ef74a188c29c052364e19e7c18bd5253b4215bef04ccb6324b65edb06f320656acf64c96661f9cc607243acbdee51b4d65165b4d61651dfbeda1262ebd03480c40298374e25d57ecacc5981201f5edd4c430f7f7155c13ba560247beb25c56e8c9c25a74c83de7ae724fefd098dead1a926e7504b5789161027da8878d956a46b9329f45f42b1a9924b7f36f9ed8ac0cd0eab9e9bd50e0a037947c4b3f99632191fe887def12ad9543c4ab786f8415ea0d8fc8d98eb6ab6dd64a1fe4741c4fb947dc7206c7a59481577f09c190ce71aa876b4c82ddcee837bdb634faea8433fd82783b6b5ea110c097b91c38ebb3460bc07f489f40b930d00689567d6b400fe48cd39d67ba7fce19301617d73f4971a2d5220030788cf067b893ef4621d8c975e0e1497abb24c784052ddbb891f1df988739e173ad3b9f62a4331989ab322acaeb644e6401357a75a6b69dfa424beaa4204035d9e819621f5cc3db1277866168e273b33c6b06d1b110a65e20170e5f20d0809e714497a9d079cad6731ec6788fb770eb5da2ac07227c19860d7867d90160836a01706bc51682bd87f46e1c59c814120fe011d032ca566737969b4861d1f032f04bd77013eecc2209ac680d87094729c98797376ea7a794197b25393ef33a630b5a6b02486c60e08d1be6fe69154e20843b052f631002769d2b7795273bb59de729796a2fff34f7bf2111f897e7108c34a8656b1069b15b24bd1dbee199141093e85d06dc2afd051f0ce6cfb4098f0d831ed395f5b1fe2d80582860e1dd6f19ac35cd4b7e73f63aba5907e9e7338ea04de22acda74aaa33fa97a8b472c2470781ef47f318553274858de9a853508e25a5e182d643e2d4e3cd5a8e15050171467a87810ceb760c842d28daaed12706e46996f3e99ee085914b37e654f6f91e59172767b6bb46552600481bd17304d26af59ae13145969dbe9541067d5e706f56deec00a7949c17c26f78458e2aca4585b1c8dec52ec74e24e35e7acb8f9bbdcc4060008b3a068abc2a868a5d978fc699f0eafbff8562ce15defed1907ba1abad9ae4016ec7b2a3fa18b3a33bb164122fb30db447d448477dbc9e44209a6ddb49e5b4e06305441aedd5386226ca5724a1835bab92197d659ec6822d4f4b8afe7d888daff511443e99cff801e30ba1451827199db07d4ef5451131c2d54ed4e919016f8375deb397cb84c1c1d2ec74bfbc1214fea048660e7694beeef6112b7cc72b7d8be3ce1066680c77c9fadc90f707c1e40fc5ea82d0be069ee1ff78c6b839d63c36ae94a588c047b491a350c6e8bb0c0bf2758dda22d07cdff9c45af62b77f124c5383ee9be83b091ad016cc3614cb09b0e30e8cefad01d8013087fc3d75a7f457f205f1d6767048a43ee065fff7709eb73b607232b811afe33c1034d76d25d8c853f23df3488a69cd4fbe7db37fedc2df476caffa4db40476f989c697203f6c87217a50fc1d8182229a3f35d0efc4df7d9b1febb814dfed2d7ea0a264c4fff4febc3df8eb4cc4d7e4356f198c61ea97c69bba1b5f5e2dc1b41fc46330f93e378de54b542acddd512bab897706ea8d868262a73df82c5716a048b2df5e2e636cc175b51b6d5caca40a163b99992d699a67e63537b345ee48d96316c8d750057a85a59f8190e42667cbd24289fa04591cc5bcd6fbf9607b6b2c76fcfb37effdd67ef1a66cfa77b651a7921bf92b0ed66d0e78de1f816570b229c69f4812110f04a888e05aecbb11809c0092d79b0bce670d43e9d444380ca2ccb345d9d0b5b09f71f997297625e2f8b9611b90369dda25c430ee2387f2f38a9d0b268198e3e6c71d0e3344e67ac1c576d7e24c2d6a8e5da6135bc357e66b33c3bdc32386af04a09d7b8e7270817dc597f887fd3ff8fb03ad45211d920751cf360e05f74bfbff5efdab233409971cb7a5e4ceeaf54f81456c492bcab8411575ae1e41ad76bdf93f9a962541890f6ea0a711697648bec7367d4fc17a3293d39709583772eee8a95a0649ec3cece2bdec04b623e056b0e2db867d1c58de55d89a888cf73b6210ee3dc6543b96f0900e941c76913cf861b47b3cbdcbac49d899529fed9998c20b559fbf06a47f17b34d0e898b5d953175047b51913e3fac6f213c76b4e24f2a240414cfbb066bf20e8b59af720cdce4566d3da530df66c892613e2c3611500a25a7dfa36bf6f7af955e8662bbb915282c9c16180481105258c2cb02632f57bb39a2c88f4ec8b1c97dc73f5dded393f121a8e62295dbb1ad1017e7422034dc6c8f789661ae3f9f74bccb0e095dd56194e9cab1857ea5194686a26a38e64fa525cbdfef361fe007dfe86f993bbb57fbc8e2377546a7720ad637dc7e971dc7a57c86282969a809ee4150f4ea5498d24eba249ebc8985b78489dba6008684956004c3ecee9d2d6057ef1d60772f5523babb1f3cae26769cb14a7586ef134a18a9d328dfd143d3bfd417fcde4f4e892d202d0cf960c6c73202bd1dd75c88bc827f62b05da11fd94833e7236bbb88b3e0a8d82dcac0545db75480228e8f29c17da5cbf97cd9990a4af34f293fb61dd4cdf336f7b790bc48e59ce77cc6182baeb5785f75e0fd961524a4ca91089867a3ad02b5933b841e433542658b98cd1a99d10fcf3f8f992707ce405cc347f325478d0690b212db88720e089a773a1c02103fd1d09be7ffc52687c0f0de5cc1b73f43b81475ee147407387b827c5257092ab75ff9cc0393a3f9f21866c4eb84be2b6cfcc15a3d4c497f4ce7710fd752a575abcf4f31e86e89aa38e0fe98d43243d8c9504586bec692d64a63fa5342fc78097fbe3ac9ed95b2d15a2debcb8552c5347faa217759b32bc2046d36106726ba0daf2e8e841c8018cf96785361654717a2cb9a12a4a200c6eff760e2400e4dbaf889736ca3b1b5a27d8c70bd4d4b89ee5e429c082d00e632270104236511eeb267da36917e2d7cffc07c9a8755668dba15dcd157bf822d0835a06df982b0258e17f8522a535382006360289c5ef9dd45f4a21d2e31c57a8595bf18bff0487e6750fee6548f8ee566d25f05f1c8312133c3bde3989e45d2c146f65c4821abee8a4db669aeb19aa22aa28915c80597412dec0bd069d106cfc8079a4f84c8ba25f4c8370a80d77da0a82c0a15a1060fe46020f13b46ae575d9bc8462729d1ba59a485801213dbf4d042813e981bf2af219638167c7cf26b0b4185c271bb3e004b6c201aec78c822fb6d574ead17e31b5c90c70dd3758a342c9ef5e313fd0010575b6b445d9049790a8d4184a6cdc8d2b0cb666015068020a91fbd1fe54157525967ae9143582c8f75225077986c2fd7c579a9418c709ddc9a63c6988fc2a3d3808cb47d69b01a9f8f3d544dbd8d8eb6e0bf8e34eb6814955b705bfcc1282106db6450b392b4b7fa7ab684f398642727ddf579d5837c388defa9328310cc02b971135b7ff61b2690b13c3bd18d3c496248dc2d056d9340ae52730343eb38681e7bd18f3afeaa9c10e5e6ff3244c46921e018c98228d8d0d77ef6898440291ee2d3bfa17557670b0696103ea7293408f4e7e8d2cb5c464219dcaa3769ec236f1eb491036415df5616abdcb3e3bd0eaddeb246278ff38748ef45f7ad513333944a91f62a88d4d1fcacb34da0b7cb1b04d00970713ad1b463172f45557920bb1d77a97c14a15da32f9c81b6de8465039e737fff6c211c9f92c2a4842a22335bf755a72da247c8a5fc30f65738d80c7bdb1206587b91f931ef43ec3fc5969a3656c02347d5e6ffa91033ed75a2bd1469605b87238ded495fd9ee62a0bd6a055bd0bca10a6f6b843929eb995543d669b2a3f38d4bd880694f8d5ad4dedcb9b9534e1cd313ac3d91b07a73614a1c02e63dd0b831dda1aa30f4b01edd23c2d44332a27af833a77e40eee35a5e883a9303ee9a0b047b10f1ecb06d06cc693c9949479e5b2b58cfccc41202c1dcf3977cd2f43691a337ca622a358f0349c430538fa51cc4f23c7b6e5225912b8d0a415eaa883e87ad773301482b60a48dd1a688ac3214a5df314f5fe45826e9cd99fb78fea39816b95b08acc4a088ee47d5852bff3c5acbc42470a8a18c1522db6caf708cf8ee833379784fa1430ceb18dcee668b83cd7e18e6f31de091f87c8c51114cc1f755aa8d4a0b7eee3133a397b6cb0f764d4b9c60af98806f63051b7e59a771b73def8cda6d84b9bb07637ddd333b4ed660c3f2ae8417420bfa325c1f882599642c67e144adc9033c3a3ce5ba24d6892e684adfb39d1e6cb803c86b18d2d9ec90d5239da4f15c35b29cf8fdcf6b6a8acd4dc2404355d9d454df8c21b96ccb1da9ca2e53184fbe2d4ef702bd5b55545aa31b3c5659fa809932df7b7ec9295f4fc4e0060379a6603579016916928425a72defd685093f7da2ac154e6377cd0d35f896e123bf86c023100fd9cae99ad825730062eb2180aab907ae735ab48e637c5696220c996e867284e8d45fe3a36a512399755a347240b3f1bf7b4f833852b8038a5b84553c5d86eb079c9899066bcd89d7c135fbdbc7da404de2e133d63706ac4413c5bcb40f7b5e0b2903a608fab6fc7a7fc875b9b00a5d2c8f40e97f0a47d1d2c567080e2312beb3fb616d6dea5af39f918b56de1661f123ea302908a783b5524bc8448d46749e5a6bd537db52c9c3437b9047b5c2d93b1dcf8fffaeb0c85596f80a5a2e866095199125591e87b3a6bf086a885f60b6b16b60bf4b9ee0df7290b07c685a257e576b1ce06fbb0fbd7a5e6cb83b292d4271589a2c34d90f060627883c14cdaed4251755925c5be1e3c7edd94b5bd2c44b1e5c1509c21f9275286234f5898a6ecfb06112c6dd99e6569902f605feac2d28814d8c00f4c81110a18b99b5de553d4fbb0152f6a48b82536d3ddb47d1286e10a59d24126d6c81ce086d8f592e92c8e4b1be694bf19de07f42104916c1b5938c96ba266856ffd32773da1edb47c140ace6eb0b9b3efa8b6fc87ea669275b61846ae126c8b4145a4ed20e35475fdd6689f0927d852e09efda04d05bd726347c50856e9b663b84de68ef02f2f53f71fc76bc4cfcd410ca582e5f22136d4e1dd6223480a7fca0543909c7f3ad99787eb6c0c280b3d4b72145dcecde61449b47f6332f84ca8da55d76c971f91070df9c3872ecccf7ac34d01f617693e34612567f2815fef5d2aec279ab456e3f62e17bbfac85793c537628046176c93cab270306f4c83f8babd6fa44592179e6167ef868e603493a07765f4230e3ebe5eac07e00e7da1ff75d4a6d26ad37bb6022670349df8374e66a7e5e5b530d835b1c1591dea490789abf9c75cd655ca92482875c14b764bdc2b2c3017a4d4e5aafabe0d879e13da399070c3371e76a3d146faa4d682c8e589ebe9762908c820586ca9d6114afc5b4e30d6b84f5e2fc7ad1c47c0b75d3852b847652002d1f55ab66550150fae6c24f3a7ef7fca56a206990c1d5609522efd9a86c1dab51ca4fad51dba45822450a909eb5c23ccf068274d57db7e8d07f0f1b8dcc9df837f3045f73a85fefdcd357b5bc743005ce6976b6b5e5595ea8ea3288a152e5c1354edef6a8bbe220e79f9f2d995924d2363b993317290f1cbc88441407a209c55b8ab6cd2649e78280d19a33a2cf1c2f97016fdb4b021c6cfef72f3c88d149a1f478bd233feee863db94220af131d7eb4b89bd4200781b3e8658e30e5c331e87c1ee094492624dbc35dec3b821aad3fe7d7a3be86327ab85f88b0ae38b963d740ef70eb9e77e316243c4dd21fd1b00af71e852f05b637fdacd976b02f23309bde8f88986351143d0e4a0d228d32be7928301996062e1872c5587ac9f816b4cc0867063299c49ec4b6ea35ea687cd300b8d3e5c4b3b026bab72b17ad7eb1a7432611f7027cd8d4d9000b3c296afc824efca26684060deec87da35a22241989339d4f85d56234195e4db28e454d84f97bcd9e5ca7bcdb110fb9ac50c719990ac3eb40b8c368b10e851483225c9fc4b38a529c29b1e75ba8cc778f1f87db4d7020877e1c2b8c3d5c4d4967a6a71cf037c348e52a82bf8b7b656992b5b14db054f6bc2cd0136a7614a19edc8b68bdc55a116c6754dcd552432e1a2e3d9d74ec5ae8c7d1b6c95e7f236a6ac309d4bfd72c15cedebd26acfd6cafc67d119a78b69984f0109dbe913ec572f1db48925a275b8c39132ebb02f4736c85823844b3c6fd35474efdee7815df7e6670ca8c6a6630222c48abefb2fe5e89e4de9bc76368701a4591edff7ec60989370e0c3e4e1add5c346513f3f9d24e488b46c1aa40ce5feb8510d78defffbefe5727fbdcedbc7fb617add5093861a7c083ffbe98cd614dbc0afbe1e0aae23093ce98a723524412e31b6a3fa58810711a632012d34985c237be21a7d932e9c16d0072a57ff3e0c20bf5dc1272a58ac8f18e7c3bf2c390789e4e58d953b6dfa678f1a309b50a4377e798c880fce98279d48dcb870bebc41ccd254ac327f4c47165ddb8e33f89e899b825a0a4a82310167a39f03294cfe8e6ceff2970d457341c0910bbf30bc4849498d9fb15ca82be5dea815a76402967f87881aa7c286d3eecbc0a92c9d70e3515d54c81ba135ba36c477217db0ce0b9da1919ca012d964976c9539b88752ff066dc78dd1239d54988e6f4dc7571dbdb21e4d5b203fda07ea285731795d9ed3bc894ddab30c1357165f25700e507c038c6f3cd0fa547eacfe85bc339d087651dbbeb71ae1cca131ee462b3c69d04fa1039db1a83361942df6ee54090bff5787d5e7029872b2d11d8e64d37b192f9628c23f9aaac0b7591582057e22c6c9c9a1c5bc2fbba6ad255be6ccd551598b6c089dd59314a7f92076b01f736146ef2b0e5db1015b08e47f9b50e0cc4d930fac534b8f5017a678f764d199a24c0b30dcbf069821f8386c12e2863fe5510605b266b836c1080f0aba17a7e9127de76b2ae55cea5820c87e08f01b0d5a243b7321055cd3f718b48b64b6512fd023519673c7051d75a8e5c3cae56b227bbb94ed1742ddc7077df871b6d7fb919ca5c9517994032f6e1e64cc4b21bf5ede140c6de569069221333ea743195bda4691a8bd60dcfe4bccdab1f26baba2238e9f13dbd4727719f004ff2b17bace19f32ea3b3fa2f553bdcdaca2d8136fc5b41d83f64dbe6675d74175c2ef0b1b4a25286c9b13f16880fec685f8e6e94fae84aca834f2487317a6b673272cd16e97b5c2c4e71696044b95d1a95c82960d0354af094f1b7c6170a57ff01009091d6cc058207e74847eb86dc6ca74de81e7d5d8151bc7af7d2b75e1b9d97687b4e0b23822ac2f815589443f19cc8927c45780bbe26feefdb282f53a76f3950b13ae97be0f4d24bbae8b6fb37e35be297f5bc61e284dddf3622e3dadf72899d7696f02f529220d4d53ed5b0b8dfbfc48dc91dba2e6b53825f67a9eb4490c4d329875a9394a5d37c6d327394899de1f50ee5ba530f45dc3c853a766efa2a814400fb0dc5ffe540731636585f4c40d5656428f029a529c70c33b7f910c44fd5246ea0e651f8c30f3e3fec13c5767e2b5d9f710aef6313aaab7f52ee731ad38b9231b363916a761f1656a4f8e887c1275349973c337e06b29aa8079b6c3e4bc95e8f9a8847deb53184bcb42488f0cee56d1bde10e418f3734e48df416f2a87a6cfcc6fa1d87772f1f2ef5a20bd47d9dfeb8bf833c9f817ec1affaf0f00d03f91ac89d2b437677b09d639babb85ce41f5a10e679e063613c9e3ded23a1ba3473271f069bbb1d7a7c1f92e60092b13f954d3b0dda89e78d2292daa17c8b72db8c87f6247d8a3d92e385a7a51789300147504115efbaa427e001e25f8ed9ee6188340377c96ed455c3a32f0166c674f4da807924c602b0527fca337e291eccfd9c7e0f552f8fb1d70bd7cc079ea7aa5828ee77af91cca7b09dd0e479e18267c6c218f8ffb283bcd18dfc9eda67c14194db4b2e1decd34fdb1f99bb942cc05d47179f9d6d076d34fa43eaa9d9e56cde90b1253b3c8dae11d428223d9d7e08d8c1821c7429494027795b1431586d482e5af1720eba155a9c753868141c5569fd584cd2c5c701558f3ab544ea3556d7235e577c2570473918642d59f71b24b681dac0fc9c87d74483524e3cb0bcdfcfbe2b25fd5f24ce8487ef663d33a69903ab2ca091a92478be9c74765dbf721b512c492c2517f5b1357a9d2b895d92efe561391fe6735f175497ec1de809cd673f56a816e8f500364eed1aee484559287ecfdc43703d006eea7da48aca775c9a416df7e9d6bd68c90d5018ef39c56a1549819970c4f56bd039a1e2000e388c57b7b33ab6229d4270c1d99272296cc5a118f2d384a9e99257f4c60d0a8c5e93158aa33262f28e2f90e73010ccf9c8ebbb123fda112a2d20074fc7015bbda77a9e1604e28f0e45075eee82319fac056a4c1023fb4ae2f9c7828ee58f00da7f90fe8e7eb73c012a5847c9d60e45461229b3c29976a9c57ebe3029ab673b7b42e5aa8a02474c94c63b309211332793ebb1658d00e52e056f00ed99694b9e8e9aa988d40369161bf07fe337160626c50f24705b76b75015f9324e709f2e662616986d91263554084ac01c28e5a9e9a0b561e4e6936e2937df92cf3e73b79a3e2728feac0a025ba478a44119725bca642a99bdde7acde05b263a42da41f31f527bb18d0ca2000bdd64e075c05d3b51f65e02cf77c2825d0d2d4ae393cd5a34c3e98584875d11b9d10c4e764d99a38c6a06a47758354e10e6ef5bde6ff334a491f2bca254c4fad8fc31ccd626257e0f5cb45e8f5d9012d73b71469e32fa1fb5b2b62d2d8c7473ef7ccb81e8b9ad27b675879a64970441acc54460a38997d7b97a470c5f282953ad7ac9b0e06b3873e5abe4b644d77a7fae36fe8997e6797a928c352c6e350390b765b5af549d7956dee8b220a4bc8c48c7dd9b300fd3570d03fb5ecb7f78c70553c4fa891146ba2028805927ca884ef2830738e6c6a515472a86fbaa7ede76533dca38d6caaf57f82b1a5de7f9e0050cdc8b8bafa63e947f34837711335d16bebfadffb8d10cddf01341d61d5a9003579c3f4614980634656542b1f9aef2e85d13ece76cdc52a0c53f7191d8f132623f934b660300f870cf996f99422fd33edf33a45bb9be95fe778a8cea9786acd364638775752d8a9bcf67177c227ebf33e0aaf15e4c6f1b02f155c84454d6fccc99f00dd49f733fcb9ca80392f367f1d1e17249ba5d11cb59c90b4d78c2f38e0f3dd07345e009eb780b171e0e38baf13aef82e1f79b8a3c3dbf3eefba3356ada2e40e47f68fce368a0a1bc28912a8d82729fa71d7a2698b49a7f018b8c08edfb8c4fe3bef10020b6a257306f1356da2f0b2aac639dbd066e5ce2db37934f9bfc934742c7618ac39d877338a1779376b91b468cb0ea734e7e3bf4b6ff9f3a33836716cc5a244958db1474885e7045f3e8c84ab1f870ef45ab64185d2e05102cfd608ef8a93fa75efe918ba91cc8e1fe44c9226da80d96fe1ceb597b93dbfb185f8242eb55fc5f39f639864c11c2292513e00d907889dda17e2cbeca9dde0b7f479dba1aa6fdb2b52a618a7f09a436db452337e6df46ecffe4f7fe93c799871a004089ada254c190d7b79737681d29e9d70f55bd2159719a7c69a727f41f812b50e3e81073e910d1006dfe59e92b3da6023e5a069847393f796edf036867ae4a2ca2f3a0ae8f906eec813ab2248a9a74428d6f7f009331ea1086f8d37fe49e0da673bf021dde394e20159b24df09ca13e09aaf3ec1b086fdbf8941ee708da1f65b3cff28240d2882b3ecde513082077f16a81ffa7b34f47f73de6911387fc1132dfbfbed448f64424c19998f88283759721ae1d231eabdf608231ab2965f1edce8c9623ff2a4932692e142750f9fe22a71ee82cd8a51170bb13918856d5065a509122d4d26a6c0b42f461f37e792e93726a7406216e23b763a16c54eb7c391396cb6a2dd41bb77bfb9ed7f8a9466a70924710521080c7498ffa41901e4ac0b82b77fded9219995bf32c3fe5e21e9652239ccb3103684e536b278a0de314cb20e2a9879245e2aef6853e66b463cde31369931e724be61389acf42c3746fbfaa94939af42e0b02a7f62759804a374549e836a5ad15615a240f688068211fb32803a4c957a1783245f616a73b9f386dd8dfdb2ec5689e321034d13fa27c4c2294d4a5ab2a1218c5baa40e6ae2108c8c92d6197c19dbf8d61d6b1513e3e1b3842b18a1511f1a6fc3b1cc25c08857383c2b5487f90714ae5c1c2af18784bf5ab891a695a8339a4779344c6383a30ba394618c9ec7a580a320f607f832f3dbc64d226ba240bc0c6a2651a2b1e4f373fd424bb800f3a7bdf02fe792add65519d079afbdd362a1ce03cf5e9edb31a7e8d886f5866baa12ec742b9c156018697248eabd1459c5e874202f57b7dc4ab04d0ef472bd8f64b4e778992411e26cdfef44a320da45ac64656947880c20d80ac51d5f7aa07bad6e1aba87dbb16b70169b7894570fe90a06c56c1e7c464dc0392bcd2ae1e7620cb8ccaa3c74f891f625a7a53bb8128e44a85e7efeca09ede4d4a0c389f085413d96945149795208eb60514c9061ee06470c3bfae9b11a54388a555fe713b2e5076dd3955324575bc50b859ebb461bebb7b682963cc848f642338879ea2aa422bc8afeef3dbf261c230a37cf214f617d6694679210d6e54163284f70a8eb5fd49cfb258a121761ab3d6172ee28385eed53584b11c8ca831ef3f93bb6513a784f528bff0f30349fa4178db7df2287c2b36b5567871315754f6a5e9a92aea011b145a68fc9b5d979b05da6b50002c04bc2b0019d22cd2330a14263cf55fb1122f1a36e7db1292eeb8999630d99eea4e0b7d6a7654702f43497995ef143fcecda5d5cfb7261e2a0c898fd952bc7ae3061add427f01e9cbd328f0b1d9fb6a49d99ff609c6407a5b1263bca43460ba708f4ab0cccf049127f7d35bf639bbee183d111fde3ed22a815499d144193b769057ee956fb94e4f93b2c184e4c1622f2209da832b10322accb7c7df55dc501a38e3535b1fd2dee8d517012987ebe700f3d4d0fdfe89d07b41eeac48b24f4381b007b57ce3277a165df8e2b434f8801b0e6a673558035f050ed75e8a565afba4f0bbd0604e49b0811a312a25fa763a59b3370032c93bd482207289c2f172fb4e6121823a8facb030566e9579f95d908e01315f5703d870c028b679830c94fac3a854df3ae4b32448d905f45f158cf8294a34314ba2ae7b57bb10dd784936841a697e6d76aa65b3a178e037d06b313e73d6a446c2b9c5980fd99d6f9e18c86dfcd04faba82d33e7821d532f98976a6836b0f095ceed415351db1d88ab720ec99369f08c0ce9b7f34af633fa5da642827464a1ff877cfc26b7a338edbe180b817d9f5f3e7a6950e7b9b70ad77e91f48b06a36c58b694822eab6f333e9626e5a1b0a2ca0497bafaeb653c43766bd3e967a22019f38b64b37b0bdde7cc2f1acf2525591ed9a160fe40fdd41dc3bbbe6800eeccde0342f58a8501a83cf331863a0df5df416ba1cb7a29a1fd671c65c590a9b7903a2b8d84b84aeafe316ce9dfabea39d9aaacc9bcc6dc8adbe007a4ecf3bd5e84954fb28d990a3cf90c37df7654c20af12b461c257a66dfebb72e1fa9f1a2f66440dc9e93076c63f575273deb2666b4f11ab8b2d0ec318e3aa1b363f93dbe0cb70dc717a11e4002a62e397af6e143593ff901edc7f1572daee2ac6985d483b8092130315b0487fb722dea0d461842b12dd22ab08ee32ac4f8365d91862cfbab696a6c12f6549a46ef26a3fd76bd2647cc480770d91876b7f78ebd3d27431d034b3acda25e28885bfb38193d5b3d3d4c85e989f3074c430bde7b3b7efa0a1f134c0adf0e910632a4723aa475a7c324d2ea4523f1e1cb4b1350c89f2fcbf711f832f3a45cf4242e366bec552239e0189ed16c79f5a2f5165f757e21de627c42b76ae527c71fa0aa5c452c842281f794c3d1ce0509c9974c4e0a716d11f28fee44da8b0dac9ac118aaefba6a6b7279f613c801081fe6c1f47ef6023b635ab33aa575cacb70692aa786ed46238a2b3290a5b5214c36ea19c976dbcc48c992a954351ed8616eb430658399d83f3c542d3f572d5b23f67351de99663c490a0ef5110aacdcf796b4fd760d33c68f1ef0b9541af764ccdc8d08518f71243c3298bfa8ad81767c592c069842531fd528dd8dee584492b6385bd59707cae0b202924d37bca577c31bd647991280a376e8eb5b7f5d1eb33f66b8525f3e5a786d86729154b217c460772778319f13ee8cfb3ad0cf534d3badfbd269641ffd6fba49bf40d6a60314b8280915051572da9c959db5c9477f42ec755ddf0d20d8c0378639a0d9b2723edc574e0389e61a86d81651fec20b9aa21e2ba225644deebf5f7cd13b7db88aed7a4f28e32dd66d028324d855069c05283eb67c55977eb02ceca0f91e83cb22a0cc298c10c4895ada7f4867557c287fc4823b3adadda3a9314e1316e3cab9f2f86abcbf38ecb382fff11be66e703f4155c829cef1b6064691016b5f57f7bfb7ee2baefd53cd43fa11b01913329cdade223d945ca553dfa3b319b3abefb35e4f4f5f76935573aff8359f64028ed2358a7bc83d707fe3f1ba22b13eb622be077e9add09d3d0687913a61770845eb39eb4b64e98ed96d7a1496ccac4ebcb7251debdcea249a924f094c81a07b0f74484c2352e7c76382426c6273ef4db4b08c9b6af667f4cd05e40b50b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
