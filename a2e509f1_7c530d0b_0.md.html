<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65a2c98f02b8852b2e66fb5aa31964454aaa9bd8c37c56369420dbd6c161fa46c14a9a04e645e03753084d99f2aedb31d289cb4d93deae50289ade023b37b53448a78eaf04c3180963bbcffb2d33c18e3412ba00d693d590489a5bb3394b92e9c1694a0a69d3c7867281b402e26501b95f758e8b0917f2c0bcfd109202b7ef99b13f02d18a9a6ca2facc09e2dfa97440ffabb1ec3590d87bf5edda25c30133078bbd2a4afc6147d102b5483d5bbf17e65fb0e1fbfc945bab0c317b26ead912402b226ea816787a88105cffbe07d33966756a5d9f39819e4200d676d8616e9e9044a92452fa42dbfc9faf44c866bac1d60b7347223cc325601ae00ebf7a127bc770133e9d4f37a4dfca765a46de9873421d10d2e7f2234e5fcc38e108c8b8022bc9dc569ac923a87bfaa21c39e55f7887fd70a15fce93576cbd6d5505b9c17eef59d41fa09e3fbcd20c2f315a045801a6f578922b8ef07048c159d95d27beef4963397e39e4e03778bd5e1ac774e838326a531d9a24a927433c0de7a26114d04c35498d3eea240332ddab2a57847b9f13a226b0cfe794cc875e1ad135850497155c905f414ab8be5b5b7b6d958bdc029fdc013ff9cfd7b8b4e930ab079dbf7bb27c04c454ae3a4812cfd4808e70fdcd256cdd84d7022feafdd2c4339513d8d7d987921e9c0479284f4c2916de387519256a4b4a97b52dc54440c3ae07baee939883b0a1240878d7e8096d65487b23fad77785d987bf76dab9dbfa9252f40a467f448288b4ee74fb0961dca7eefa00d3d37879559daa5e0152d90ea6f42579233b9e4283d98aa963c0cc2b452f41979c381408715b0ab3f94c7a69ef2262868e07704be3c08001607f029efdf90fc24613c9aaa77cd9d505dbdd5c00d054793e2233a83b87b692c42d03e6f22f6739533d72bd78bf176104861f3c653080dacc963d1492e8bb9855334b07e1e3c4fac6ca1dba6f85a870a7cf67b03d9c111855d80951a48d8f1aa27718ed6f189fcd4296e582aade2401b1a15ceeaa6a6b3f853fb03bc7ba845a5211f5a5f2f713b955ccd429b3d78bd881737dafaff39c02872f5f096d6c65d789f1d49e09588cf8b5cfae53bf4829e70d66177b673e0dbe80dd25edc56ab732e2d21157834c878e2cf499d0a51f8e9f4ad8f87a080fdf6e75682977609f4e9fea593c795ecdd9a1bfc55a884b775acd1912a797fa03490066fbf6373e48ac2db2400a1f6c0687c8ac718463d76258113862da42063c795a6467e694a65cf3518f2ff6430a9150179931adf089f25f1e6b5bd9c977c037d484e3fd735339c5d220f73b54b4525351241604550506cf5a1825bd285ce2944cf88fceddee2bccf9a153c37d110d9d49bd6f3ea3d2ac9e63e66aa7b4ab577358d6a5538919161c977a9e112adaf81fddc9db2c9b2979dbe335305f226260a9cdd0e69c8743f6e7db59d2e45c619073bf1d1ab91acea62a340119a37d0fcd011187821215a2b5e3ae03bb861903a74a3fe6dc068f2c983a3dc4d018ba74d6087245cf04a2aa9a44545c9483431fcc08e7f0ac88f6050de90c6ea0cb800d5789eefec3f07d44119f51c7828c61404364d03763962e3eb93bbc7a401edfd8bc582a6ffcf6e13cc6f208f6af4d1b428d6fc362c3809cdff5c3ab32d19a091d60fa38b1443c60addf4b19ce845cc1d69310b8e1b8a986a78d1355d1d3d967097466159ef40f8fde16d75495becd83fb0ec3100e2e3c2d60a75ff4f32de2dc16293bf1b7e0bdf0463da108f7800cba4db62bb501238254ebedd64683753e879eaa898e89c69e7a450be7b04c14097b191ac425cc0691f01f45dff755528a2fff9567aecbe8aedf0af6f6058f2f78fb74aed09ac8f8d2667b9851c0664ff8072d60b1273b1819180e1fe13c8b5b5143e04b13d45d3ba0e1c87fbfba3b6b73693b137320e3086ab88e9f5a919ff87f9fe578f015dc6a0349239dcd585f32e198dfa25f69644ae9798dd486887587424aad63a1618ce21d30dc616e1dc9ac6d963d8d716fdcefeb4a427453767c35af2b36fd64923c695ab44e0208e40bdeda1f2fd19186392f8ca8415dddf18c2ce67040025931eb959a236b74ac54639b0a8c7f0c190aa20f242fc92de06fff9e84a690c06e2c9b7434cfba4971f2e444de8453a48578f968d39303bbe7fc37f1e65186c01e7f3fc9153d2d2c0d4ceeed25f7db92e02469aaf9b4114f6643b0376ac99e3d5100f336d25a6c6b705129025bca813d5b64513c02bf3a2382e332698fde532b4a7da16d062b6796a84c432d3bd0e61a4e9d258b788c323a3fc886d5564a770bec589c8dd0783e30a1db011b76b63f2bf8fe12f841321ca5dac42cd3f764982793bf8c9c0077c71c0ffa78ba7f619baf5b69c67297102a694fac378ffaae3bbc119d727230cdbbc351d20b969efdacf0df84e08228716007f5f41b046d93084b80dd2f09a89a5e938d84fb45831c9dc6ba4163a82460d5bf17da98260eddabfe2fc93c2734c5d5737ceeaf8131ce863859adb2967818d84eba07b8cc81e233c96a55e2f89ef6489070046d94dcea8de90f633eea42fdd8cb038628407aa1ef386e2760a2e405839a8f0d235e7374fc28387a163154acaf01689ad8d50d15288373200c1dd2005a8a30cae2c061b53e37bf2c5d2ba798a472657c870735898a7cd7075e976234048a198e7bd1531b88715b2e1cbc0a350fd00d1250cc442abfff3cc7d561d33784d048d86ba590ce51a6f76d5b5b939f1c52e455606285ee9f2f48605dd3476de9ff0d5b097847c56a02d293c91aea236e8fac0f6dff001a155b98247f949a56e3aa1085b3b85584f805567b80be6954dff91bd084db4c5739731d28458d4fb73b6eab16ae367ed2df49f0022cce3309355c4421c9c46478978810c7a29decbfba3e1eff49637994d67755dccc34426a23bb2c33c535d005925f08e1a4d34e188158aef31db18b86ae4f811bf3959a478024fc2bc1dc7e64ca0017344396aae136d801197dbe7aa56055a24d95b8fb43094d2482da4bf131bd800ecc1ac809ba0e2268a01feb6f854ee0f956cb3bc93d5784ea93f784fe1a182c6ee420ed73ce1dc059c0f3eeac834024ab355da5c77cabafaa830ed3747985be2154f2bfbd988486cc4ab2401c02f6c633c5fda076113950590c849dedd5a8ab06b96f521e2d6296bd9ea8477e69aef13847b5e0c573100a8ff6ea97be7730072c270acb2274592f61a1c9e7d40c205fdac535bde22a5b35d319c64120f72af4669babfb9597988826c93920e970271f98a67d8435757ca7ca704c0bdb4963925e301696d013841f68d66e0d2410335c924859510f5e441fb4bc27c9fe39dfb0f102bb89cc925af02b11eee8603b426d200e14efc945c4cdbc60768998bf3d001e2179b3c3d24dde1acda2a61fa27e1f2f1fd7c86c148a2a383dc0cd1dbe1859d2d615a94c6b1c088f29296cbd4d86a05035ba9503cef4625d342ea07a2bf2ab56934712291d132b0c4b2293777c594540c531ea864a7529137f66d4e459b60d71005bf60b02bb66aa3c35ace0ae1e204e9dce9128beb0831ba6552eb8ab6dd4c7d0642b7e332e66e6916c55e05c31d5ad9e7423f3bd536d2204027fdc04906003428f0e50f1c44c44ed1cb9fc1d33f6c40149b35505e0941555c995eabf629589ce2061c9c185784166a6a94b8c11d21f9e9bf2e02aa7351fc32b32bf9fca32b4d6bd796bbbff0547660fe30fbd61583c8dfba530f973dca353d3662d01f383f951b6ada0b4eb219b6779146e9f765e7aa6067a92770b0f6c810599f579bc6c57eaec3c2b74db69dc032289a5be599d382d9c511f34cbd13dffa06270792ab8e8fa0a8d411d31338671e0a3977382d9e0d9f526650cefd1d892a0a9df7da4267b19c28a0b3c9addcff35e6b0bcdd0e5844ea06fad79022fc8977f92fdb4b386f546223d090e1563fb900d0d0ffbe7b1ce5afaebdf81bcb1fffdb45ff97ec378aa9b95c5ff2fe3f60aff154078e6650cf669afec28ac40d94550a7978cbd0eea41a13beded58ab0059d270e486082eb27d7aa349bfb908b962485e7049a35b0e402ce397523ae3bafae98d957da02576eff88f3ccc8ff70d9567c3931c8f501caa2cc182e20072c9c8ac219b9f703332c177adaf4232d12f4d2724a64ba0e0e3ded12f77e08fd75c7e2aea371fa32cf7b07b857fdcdfc8967f1c7e37122357219bd3050eef604d474f799f13d055b258e150b010d72819f4aadce97bf683babd88c4d4cccb6fd6d9c15230973442784ea72898654021aaafcbaa8a18b633198ab1cafc41b93b64d246e070b4ef4faf574b16409d1d0c2b895546bd758d73de1d8f11f1c98b597cfb6969b22bca11d3917a7567eefaaec90ac11038ea32de177c317662a2e680b403900a5b5054f218f5d9843c7e75a669414f66bed2598a975d432d1cf7b5ba4c37fb5d3da3aaee39022ab02cc99db0a965ba6b46fb16a6b7d5b90eb65bc45d3a6d2deb2f6942bbccab1eda735abe6d4efc53353006511e758d36cbf136188fed6ab6451129ee482ad7edff5b1b00928582a85f6031258be2c6111f406e93c754ea2f6beb0e457a6d560dd5475217327c1118cbfa3321e99d1153045c0c5a8e56184bf2e1d5baa367b86cb07c1b299dfeaae2be2286237c4b9437b329511eb7346eb5f4c85ffd3846cd8b6d3cd2af9e6433742afb6142bc0e8d9094a8aa4cecf7faa4620256f4b5259628aee2c76a178398c5ac800582196a9ddff2d27987a2760e9d859693ee0cc88c30b846353e5da7cbcbb64c15c8bc126f3ec0911cea7a38766298d7333eb14755049c22f4470b3ff2c83b1f74d26930763ce8043232126e9aa7a9c43256de7ec3d8bbe69d7cc4f445dc090f0a922407c3e4400a9b9d24d525500c2e7c2e86c389bd2db93a2873c4083fafe32fb17548a296c0e5b71376f38fdde00db6a868517d83208aaaa9b00db08ef0169a0b7c21492d65cef40d5b429aca4408ed131a475656dcdbb5f135884b4118717b1e8c46b9a50202e28731369362039ff114b1ad05d145ee45be9f428ffefbdb25284204ce954aced83e4ac586f3b6623c51d1166d443d3423d9a359ca342714d126260fef00979ef5ab980ddcce8e26a7953d1cb2afc5b75f0dee4ad142eebf63f061f1b75e1985515a4ebf5fd80225beed52a06f847c8f1e4e3b7212ae251cbc592da627016ce9646892718b37b3236643ff1ab83f5074b25d8940fe0442e96e0e4fa919c2447e69fd25d94c58816f566f8433761668be6d5bc1af867a0fa356a73d59bae909cfed8b8d42ecb164844b5bd683246afb8d3800193adcf326a86ffd7507bd051c5642d68400608e3d087d6525e262ec3ca610cbb156e04761ddca39c7f21ff065672dcba9ced837c48ad689991967806eaaf9b37981d6fc2043e98d3372c6be777b20ded4020ba85f696dbd6730b74839d60a7e866894be135a828e020123ae39ac1e37e5918a1946b3e3055154ba6d51ec32df01cb2464bdfd096f28b51932fee7e1d6728935893ca7a773e282b8caa875e90fb56cefc0621574a5d2f505dbcd721f359971e55217795c9a9089d306c4d5fc5385e17364b87a43d5b89d852166ed940ab9caac0e428bd1c78cb9e9c56e78478657ad67f888097a7fe031bbc6419c39124932946614530ea26767ab6a10ced524ee5117c3b51f29b2d21488410637b20547463c4d204ca8efd9f4ca090894379f8df5690e0355bd55e6578edc16fb8488d63d3b065c3e911517a1eb9aea71319a80095a2f4af77b95d7f0fba77fc35abde656bc4b09393451af798e977949ace28fe7bb3989a6509855e3104cb0acfea611c4a453d717fa2648d8fd4407b61ad71b0b56df73e5d9ae0a5219f9cfd379df616febd8303fc98aeb2d3797e5b13801b3e95434c916c5259bbe63061a17db74367591e3f2f281b73db81a767ef9bf97ab4985ab747ae155add65b9ed10b239f670ab15397e1a5fcb8ddac36eb3895a77ec2dbc2b9b577254f654f8f73f44b488105a7b33205fe70016385fd55c3c14eadf5d6b1e8f2793bd63e0d7539355466d3080a30d02ad45ffe75865e561df15aca2f4b2b4fea60d51d855a015ab638a396ebaef9a10af96dc3c2b1fd4b079297786e91da28d7cf899e5ccf318f7351461ec93cf230ab85f40b0e43391c98cfb50d736c958cca9b2d7a6b15e60662483cf7fd1081351d416a0428a85955f0a51e48b869177ed2cdc53c2507e58c6a724be21190d4771b0151518595a7256d176cffcb30c21b13bb1e3abc6267a173d7b86fae8deeb75a7b078c0e3fdd9c183c46f174c9eb0c1a529620b329c9d744ab4e301627fcef78f4d79c287ac6979502264ac621046f66ce9a257223df6da862155b0525a603871ba4ff75cefd2e57cfa91e931370d78b4505aa138793d6739866e05a50224ad9b932129893292f9ad63e5a231d52ee2ccae4d56b34ee22176b8f4f2d71b37b3b6fbf1f3b86eec1a94c8bf92df67cd3b651bed4a0f6bd37eb5e1641c568846f3b307ababb84a2ea1c91698723cbb7b25c57d1bcff5b6c90a91c509139acc4ecf61c1fbafe3d5ea1d701463291318baa68e1bd03c340482d79a2825eec23e07d857a3d5b193da1dca1af289b62c56f977c7dcebb7f68f19735490d7fbb5b3ee60d2578118525a4ed48956211777778293d42fb278d4914c261b07101120867428024de8e3c4aace12192752520b6f5b73c65a726c2dabf178e13f966e17448140c9b982faa0759eee18d6cde3fc24e53bfea4b2a657d93b76a12a7bcceb1fc8d0f16d1eb84b8852209702e34957476ec060efc4def7f992996f9f0c92548bbb0811c1d65036ee6659a72c009bb56e78121121d2a67203649372513620b4f442e4525a6e45d6ef3c95aa1c7380b75048694868a75b77fe90896778340684b8a73a742e9c60213fa7c54678163b67cfde70a4f68829ebc9e42fc7a2d8d8e0b8005968aff8d93cf9ef8570e8749689eb1a67cdbc9c52e1c05c26ce7146d62187566cdd4ccae56251e0fef5fa1531a35371191e3353620b58da32eff8e66d95469de9cee37f416d526d092ab03562e291e0feef5d65eeafee7b9d57e2d7df3c302489345a94f738d10dfac668796917541a9d4c2db079eda8459477b190b34c5899d4c8ea19846679c87c9a8f81ef2563783fe81a39dc55a09f27290ef0cc73364650ee356eeabc4e0d7df001f7356f8585c9c4c5cf37d8d8092798ff924e9a96c3a0c479e4d0c6a4644941574cebfcffbdb1b8021a2918969f0b53bf9f897ad11d1ea10ec20c399034713efe01c18e88870f5601d8a7852cdacee1249a3b7ca417cb26186c84f522fd05e20eb44c00b0d9d9e02ae47b5379b277b6e1ef0d7a8390d8bfb3e03bd2055e8f33d6a59daaf7597cb3751e3e210de85ac35d3544247e9bcf698a7ac7e6a0399d50c0ae26cd75014c7cf8c8dde2a34db87b507c5933a21b691ba2f606745c636e2bbc47a8670356471387853433b19debf2cf23c130f56e36de651b5f003b6d26eb5a009c5663b113df237a6966b03217cdc5b3873bfb5e73593343f59407c29b6ba3ed0e72a8603c5b544c829a0542c70d7fdc2d3a8958256a7e0c0b998ce55d525bc4e6e77c220f74306450e43ba95bdff801e52a703fb986b22045fd02c91c96eca7fe586be84ac81d3eaab8d2613f6fe63556189e3e4782a1da49eb7e5185a912d57bebe2b88dcdded896e7541430377e0466c94e3efa4e6fe4fc80e57bbc1d1d916469f6d35922eaa7134d90ebe2897b9d3e2490aa0435817a5f02f4b2a2b8049ac51ad172c059a993218bf028d249bdb2559fc85f3c8a59fa98652c53d01d0e9ac6d0428a1cfd2cc01b0cd19eda606ce30edaf5f2cf8689a7d552b5a921e88110bf3b1c33ecc63db87714a87cd904963b3e9c103e4d4adccc66f1c2dd093c42f25b707defeaf1a042b1a1d4a483a27ff194db26424ea74ec9dd1f233b5765382ba112f1d6d948cec93787c6c0c96ecc782fab35e8ebddd0084164b00384bb3911415f0ad44d8b68398243b09ccdf77d07ca1bcd2c50f6a8e3eefbccb73f7fa91337d6d905f801ab8191d3fe83a3e0802e3ce6da794e911cb6df12766c96a466e224aeaafa64174af1fcbd80ff1b8e42fb59677d136d06346c113594e14ea8341d5f95b8f4af7d8d23b32cb8f7aff4c74041bd7096b92cf2f5d4cf3fe528889d5b6f4f9d96aa409448b5f3cbc6e47cca5a6e6a276a37452efb05c3adcc46765268a9023badacfe68507a1c7dbd65bb586271729df9bdd039d75c5f495f198d179f3aa79fd786958138b66851ba441d342921ea9ae92aa25e942954b1e93001e1ed2991451c7b3e22ead7d49d2de551588ea360de15449ffe0ab5ed125e641f3f2d0ce63f49ed16f5147d31c501ea769dd974a0546e42be730372ec47419bfa55b47ccb4bae176010167faf2d7e3de4aabec0ab88c2fde4a6292dd0c424f6b6bd4518d61f8daaaaf873538637087c1772b0febea98d4ace4f66feede1a6f9f992a3a44d5539e0ac0a773b65af94b693cba212dfc81cc46b2a5ddb2d519f69c6cde4f31f0a3c5859d4496a8f1d19a9d717d6359886ed751587c1f34e8667119394f1041a082b41bdcc2ee356c0be06cc4aeaffdd7debe5d3e7a3955089d0484a067db81398614b2af2559c21d8ab656a238c2b4ff5848fdf4e8074664593097cb7510a89ccd3d7469966bcaa6671e31b8bfe0c43fe19878e7b3d907b7bf8c6f058a47f408cf2577c18cf724fa364f83228c7a94f6da60ba8412a7fdd4cce61117b026ad5ea9985ebf872c3001c01e52a59a5b238e0177072f4b381c9602671ee3fea7c000f1c1846de9773159cb5f303493677ec7add7a11208fbd1fb8046f90b7822d7813a8a831b52365141fc65232baba419c14c0f51434ed1a371bf2940482c0bb293860fa3c2c0371d81c8ec50241a8d382bad06ae443a5870726fc9c7f28037deeb2ea9672038abcce68e79896a06bb121bc1d471a325dc50d90a7c6f3eea1859be84b9daf0609a01bae3a6d799b37816d174f7e4344f03d09ef9e681f3213e690f7e0e72da32306832cc7b1aaaf3b81bb5fc549a9ef79b85767887ce6e97adb7fa90ae764c0ecd0bfe9eb0f20be53bc6c9cf318e3d151860e7ba8fcdeb33b227c97c3d9103bad30121c4067c0830090270040b1e56980d9f29e61727812c45d51bb7c565fc37d472ef20af25db9306daef2091157406b2b37653fead83be9035c76660d39510633ae414c33c7fa16db4e1a8ceb1807f776dcc1e2a6883f1a7e85055a43c40e882c5229a7fb2ca51a5f7e06d225ff5d4bf768822dfe947876a16f67876831381523c7bb30ec00771b9cf4518d14bb7b3705b4f7a0f723523adad1fc09082d2cdac5d3dd4290ab77964abe62088d27d5da7522388430a164af3397a3c0567f2c9ba518a373794031e3151cc9c40512c0d70c369256d73deeee6cb216455beb023d3c4de0b60169709ebfd750e9c6f99d8d1346a4a54f85f25da5310ee342be1e726a59718dd19abac04a677f0610ed3f04bd07d2825e0341a4b9a2a16e5c144cf58ec67fbc9857e3510b4ed642be89889dd5cc2c41a1d10b5d7111c1f8824bad918703e73a5c3189db2d9890246a7cb9043250881f9dc3035600af7125e4a458e2b9aa5cd963aaa4717ba50b96b256cb207654a05c4ca5ea499cc28e24181cbf82fb18d2412ddb575bf8cccdb0ff62b618f32d752425dcbe6fa7bc565a98e51a0c81ae4287110803d77d7beb2f0d741f623b77c3215342bf05ed3c5d66c31496031a6d1e65bc8b547e492b73de8cf5dd5ccdf99cb1217309a5d434ce93b983c9f7b921c8f359dfd27d814a54fca08393986813b9aa539553a59615c73e4f416ec36ce1fcdadf563a726ae7acebaf7b925697f9144da6d111d33a3be0134c91249228c95adb10ee5cd4b787ee1204f363c6ed30e90eea33d505e35c409c089c97d230547a2625a99438ea3c01540f10331d4d0a731cb1e3ab62b451d31249e3ea62881e6cfc3a5536fa107ff087a7dfa26350802b63defa079b1894f8c6249817a7854b01ebd6289598117891f3ef15c9a76a97eecf763780e3fe6236752f056cf4b693ea77cab115aa5eadfd6696df15a25c23622f1e2533aa7f1e6cd77c6cc12071d9fdc036410d91fb3c18d7df659243fb925c722dc6abb8ceff05945fea261e66b917e22f30c1c734ad9577a3c8939df75c4f1ced4afc8a8e767a43407ef7f697def571086fdc14fc9ccaf8b99d02bbcb01ceb4a514b1fe4725ab5bff11730c8338e5c225ea77002091c5c1e44dc19a022690feeae291121fae17d54e9e7a867a229345d78879bfda0dbd45d71f1523eee26c4732a8f3ef84b08a52757420c3cc445d399f98d94c86112eec6fb84ea5671e5b8066a2e4c0684c40fe3ebe65d47049c41643105ee286c2acf8ed0fc8a3c9e400eb86c4740c48cced84095cf40cf34f96a7b8feeeaaa691f4885d45e9656744061fdbde94174c0667aa9ffaab096e511f13a558abd600b02467528f5f41c5afc972056e16c4d7666e9335334bfde0f3ba1bd57ec35c5d9fc9393662194eb9351235fecd0bc204a711f650f3b00bb980e905f2b3bda61b820f19ef49862c05f23cacd8536270438f6705d49f4532fdca8428edc8e3425057b4d55fa0d69fa035740375f5ee79e4780026071d7f3d32f32dc1970efe41e0c19ba24a0a0014d9a14962e30b7c5099980d3a926ccbfe680ea7931fdfb5ca462b90e56624e8a5465a254680d3b184cc3e3a32c7919b11373bf83899b55743ae5574034e0e968cd6089cd37117890cca6500f3a84abeaaf8186ae32e2b26a445c822fcd0d0c814482f7b1e34fa39d119628b5e4ff8dec1c67bcbc3ac72bc0913b6e0465b7aab80d167eb25a9acad6388d6284ae78812073c3133978d866c0d08cc0203b2d8b05d00a90f3a9ad96e00fe97ff86811361ed6a01e67c58d6781e963cb6f128ae0baaa9a7b9572f4913a36c5ca8355b1357d61252958554be3021bbc6336d1458319ec93bc83f441e5126a8c5679cb825833c95498af84204de4b044f43ae3c10b4fa700fd6d446628605831f8ab01cd990984733ca1afc93c8b4c69db8a90d8b03c9f529401f260407d925ef48af72d418a5e438837915f0eeb74280221428e7b949b82d29027e1a91b47ade0adfadebdeeaf766ba939b9039abc7e6ea7ecd49a4c26e1e79a3c9e298733c65bf29588360a420fe8657a27a02bd7c8a64101464716233a13978d4e69d8d5176a6b405779a6de44fa894883416aa98fa537a44cb41ef4b7215c38878499519cfa23c0f1e193716602beac1f2c8db5baa793c42f5f05faa5f49e8173cd21c32660552c371606600b3f3a04d6636847141f1dd8eab868dd41c2223a18cd76a714fd34c9b2c0fe484d5069649e8b07702351ebeb7f4f7d50d098945fbf89c21302d9109b66eb9ebf07d9c50a8951c8c3dbe1e83d8ada8aba3f2bcfb38890decc640585040f6cae8a919c512b155e9ee8e95f346820adfc238bb632bd6a3e1a49f24d5e2768884491becf92c46d3189e6e21f0f358766c3a343120999961ecfad14351b53d4af7fd806497b6593cab49c14276dd66b32d89e16b6c11a1074de20af0e5620bc31e60df84347e8950610b6062b0c7be65e09f85d805aecff5489bd9160f211a1a1bad330779a19ddfafbd3382cb400faa65e3315f20bdf48e83ea47b3f4654af83d29d5b8ddb9a9b9a2b929e7a9c91aa05c608581e29f7156cb3fe6f3e171f724bafc2e82f24b40d035a761104930d01145ea383e31914fc43010ab1723e60578dc2f027ad9114748cb4ee753ead50683bac482a49ad006c79db45a03501eddc8c7bf382dcfb30db6f78b1ed815a9507ce6b1a84d03eb62a2ef3b446dfe5177898ae4263521cf9ff98150c8405bc2b69daf05a7048c8e5521e48644477c7856e6d4c637cc40e34ace795b0d12ff5ecfe4ca8a50c191169cd45dfd9930dfdace92d6c7da821c6511f562e36ccd0cc5116f61defaa14a15988980dfad13bc016095f7ad9b477b828a14ed2ac4f01480f2eb8f86736bee7f3606eb66c220aee8edfaac4f74bb8225033bc1bc6d7bb2ba22e26335fc79590eed843f9350b908840d5aae5073b2d493ae48b76283c2d2efdee71e138d9a3f1fbb1c818e5376f2e5fbddbc083f71c784a8b1b305f741d54bb41afd0d006c98303cc4f0469ff148919429ac5eacd1558c9188bb139e59a3a4633abb85ce8318465b26ab61078ff5ea12cd2eebfd4458fd449bee21a7b328c654945d43a7f46be3a934be34f7ac25f2b75502d7db47f133f5196a6c9bfeb2d62bb67cd22f1a0210ea14bcda146f84bfd291886184fe40915416584fa475c7266bc5f2d8dc0ba47c4a0525c421f12f5da0980120b3a0a79a4d927a8b5c3d9a163d764c50d05de91b08457ade821381db0e61e953e78bc62cad0eeda9703d066393eb51dd93a6a9b135beb43f624de845121f661abb9398ba1bd255f35ed6ccc6a6d1e053fc93b329465fe0106b9f7bd4c77734c4e0c62ee7046c2a8de2b42e2aeb33e41802f31be7c26795fd3273623b71ddb6878a8fae65c5713651b3060c33ae6922de1c4f3e8e953207526854e8f7cc02f3235b328468228fb9fdfe847e8cad92a792f0dcd50480af62ec4e4ebf129c4a178c0147768cf61c298ece96385d12c31f6675b038759bf5e2baeb903c8079206571b1f6c4ecfcd74f8e1284799473be4566a6e8120263f51c923a14f9d0e82588676ee98cbcde8b921daf200e9fdcfaf767d84ecf8b86d38b716375d992d938ad335094250889a8a51505e00a3b0c9dc9836e1666cb31a673d986699bf6691a2430967ef56d27f07e136cbb56d5012b541d571821d25ed425c766cffa9e05c9ce2043acefb9b7c6dd1a0969658a5d4c338cdc93b227f40eb7d589f8e43045b60d957491e09bb3208d3e55982259027c070512edf89de9434345ede43c2e6a28509d8cd566be892f82bb25c7729d4342e545d60f52117a6dcef8389765cb1244e84e37f87f46ab8a89f7d0eb619a8bdfb454179a0285681a501cbd994bfbf14310860e2e2ef71d485b56e50907c6f122f3fb7ec2cc6f9773dddf56b3791669bdc95f6ea0e4a03c75c1aabd475e9db8c8052f286584ec896404607a8e91f1730259719a565207e70c5da2df75c2e2dca981559b05e005d4affab1187aeaf76c2813795ae2a5ba671091a53a8a27fb05a85a201bfa377a242bc28d08641ef7cd8ba369df89f35554dabdfcabbe1299c7497db7614db5a51aba4e2210df01b5e75afc8366de2c25c7701896aa31ad8ad5777e39be8f83414503702ecca533df734901b9a7d77f594dab3ba4558f88f222cfc85fad70c16a36e5ec3e127204469eae313cfaa90b09eb66f5fc3eca3cd0e23bb633b5b6ae27f6a1380faf22a272dd49ba74738b7e51f899ed3aee1ddc1ae21c3a77210468b5a8bde","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
