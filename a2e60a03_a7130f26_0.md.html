<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f20d3fa8f1cb0a6016c75ff36bc22c5509f586a033f23a351aa195d816f6e3c5bf15b913f49e7bf5b0b42c2396a6e1d5d65a35cc9a810fd916b911984e440fd97d7b60087a53a9c13fceb60a6927e818cbb86ed2e3c8dfdcc31255be4f35e4092f7bb0f76efd92d44d3fa194c971e6a077e3faf2010dff50dc4741b1bf817b6f26917256ecfe38e78a62efd9118a51da60bc23ae99cc2847a6bae465019a4d7615fa26d50d0a16d512e49be28a973efa264f9d2e607ca8128af10cf9f81414040bb3a9df1f709d04ae7f2d36285a6f6535b638ec71c86834726e26980b13847083862e2d4a61dced424a9882f928d8e509013d2e8210cedc41b9adbb94f0a8fe83d43301e30ddb3ebb7f9333000343e3cbee4c8b1297cb726b37b37247e8322a291cdb7c1276d75b065bf29387db0950c4c39a76a6d75c575e5cac99ebc60e342f25b13c4bdca92d92a2ebfdb27f5cfd8503a9f1be505b1406dae28598b34483f5a941ebb499facf3fd6754dc0b0fae54b3a805d949050a5bf0bb27a500006bc16d06a1fc39da6590da0a5873f6a8c88fd1e4f82028169a7d0021fc43b63588758e35c8aaf8c56c069865f17ef9d22408c4c25f2ea8347ff93416c3a3b2e737786192d618385300e466946cd8ad6053c0e7c41acf91dcd6fd6dbe9e9e17cb36aae73c1ec69a90947d5ebf0f919e315df68a6dddb583df03c261e5075e0a22f06238cb6dca6c07baa4639794266e76c0456e2e7ef89b689062c6b4380b7739126291fe529dce4a29a6646ee540174bb555b9c317ebe242fb019c0843082fd505b0db3dccf0093124f770e32697cfe500ad51f8378a33939001fd79882f4e90c8676729fc6bcdc193cf4640c3eba52cbf78a4a944231b82d725e2c1208e245d0013b28d9e1fc7f91fe6b14304878d59f920b119977075440c4e6ba65a0086b82e970f1c9a27541399d9aca3e1b1bb7b0b22230b2a5110679e064b326a6fd9adcc52235d4d70df7799cd8526552fa74947dd8dfc5727a13610624de83466b830636194cd590a5a13081fdef4646fc025d47c698addb2d39053170de777156b4dd6307751884395cef8c3d4a1f168a6112a28a83645667aae92f57e04f17b86fbd8ec6690b3cb4b45880b3d871fa04c4d2c4bb1eaa73b58a4720e6aacd3ebd62b2bd4fff52581bc7b9e6c63e3edf82148f569c14d2f2989376b1b1f1a76ab70a7eab8cd1acec591bc6fa367f4008ddb2be43d59ff19f64b797cf8c508df8026130f418a038195de488af75d5a4789c1e2c675ba25603d7183c1deb18e393995cf624849cb1ca632d77512001e477b9ffc661723980a088c1347033f3c1ed68ff1868a790bd30acf11e82aaba09a8867ac9145b0f54202339cd5b84868381355c3c2896354548600f39c619e7b31aa2fd8153d014c49bf387ddcda3da1007323d54bf482c2ee2f7399ccfc65eab462f5009f08f763ff06f308343c723814ba2695ef8dff55da11eafcd43381d6ffd791172f9b6887ca512378ce72cc07f68f65d1e7cecb927bdef55aa3f9ac31b42aa454e81726668b45bf3deb4eeb1a26300d5553f93bc832496ddb9cb9fc8e0af3d5f4563c23ac2d3153d8e89c43ab97851b77c7e56e33243c64da88247dae8f1fe83ee6b4bde7a6c63dc1dc1788a3013f04b188d7d9a22a4d14bbcf68e2d6fdb444d0474d6483388771bb0d8df9a0f0c1f9337008c460e71ced3f7911b7e721302788b0c9f85058e722ab503575ceecd78ac9929eabebbb2468921bcea73004ab03aa79ac4320583d8e3dc8c82bdc573153efc9f7af3baf8c7bbd984e607ee5f981f8417b22b0501754ea03a7eebe7f27b25d687be8df752dbb2957baf00b0a94c8c928a002d5cc3120f07620c2c8672759241a69c6996680a7a895e5f31933f59f2642470b1363d31dc0e82d3cd71478d883d98eaf54592496353bbaffc016c44e7f8b36e234799f0d4bb98f18d700989283c5d24d0aa85738f2436032002fad86c999d32c34a10be232e694e0b9477e1500b21116612facc070dba9d89ddcbeb9119ac89f657f36951dc3c9f2f6f76d97c79a0d66375cc0a455b825bc92063cbfef7f3ec6afe423ddb8b845261d882addcdd9b4064ee751a3cc03d82d815b30546d45fff943a0aa72498cad96e8cc1e8dfc5bce40cdfba120ed35473b7ff849f949084ad324aad8420e12aa4c29d86f3b59993925342d77ca96c0e996bb1a578f3e6389b2087cdc50e2efc4065be90115e9937381d80953cb5f865dd4160651513fdbb57f259f4ff85562ebd8a3b126a05679615f79b18ee3932239c63a80716f1d45e758d33829508f4d04469bb45e871047a505aa12573ac60696ce776084af7ece31680a871b4d4b6636104dbd5773feb8a2b38e7e5b08e33468e40297eda7e420a7e28564f3667ab1e259521e2f59d3cebdf78da3650d1c33c1a21e2b2dca65fe06a1c50c214f747c113fab5e07ced928ad3ad489f79ff67685ce1ba8866799c741ee0595d1adf11050d1bc4dc7a206947c2fd251fb5eddbb3208d90e6750f1bd53bd1e1c449dc47bc27c1e161e978cd6439a9017e8c469a4c8859aeea8309348ae4d46151d942f3a7cfb8678154dd0ccc36db25111e1c1978d942a2a1fdc15370418196b908049f885a665f6f729c6c7df8642ba32840c72dc8ba481f08cc98126d3fc74e2559fa7174619f6d03e4e1c6052ff38aa279d5db54aeb465735af5d534d12d3396a2b7c58ef0564b873b5acc341aa904ab510a3a3351d5e64f23685ab039f7ed58859c0f7411b5c9f7600af1a114347882a74eb9735b9469a4b981bdbf7da78c5b32c92004489d3dfac1426e60c00ddc24964b3e4bdf882f53d94fb43c8b35d4c35f2e258e1ad7cec5b9d108932376a10a9abdc0325d48f73b035f3eb2a3276b7776883ae9fb828e0125096aa2869d8d0dcf032d89281003d1684894cd928116cb836647ed55637ac309492d717990f0ba0e2041f3baa5b7905282b3399c0fc014ffdb903dfc58b1ebbf7e1341d001e0eee4851f349bdb3460607f93ca393b960c167d76d77bba57e55d03bc40b3f6949426ddc20a801cfb1ecd4d02ea3529ec40e97fabb14cd3927f0e2ca0b47123b50585258ae7a784e1fc8904b1890b9484a5d47ba519a97dc0beaca3316f13a175335c4c1d95687d682508fca79e03d6ae297109e272effb8a3006d47a9e7a8e2ec269d986705835bce053be4ffcb51a321729e221bba918b99e63f4096ab32fb8563369206d66a9bee2f655d2a652f6456fd92edea570935465f6d1565d4527b90fee4fbf030cb474652c907c54238d86cfae964f91faf42dacf896258f9852066aa4a464df691a4c70615a90e1b1562fe646adb956ac0def64a78f9aa5b9f2fd21b0465e6fa32b9f43e8a82acbddf11a20d501a1404babde23a7d4460aa44fb3282b8e12f05bb87e83d6cdafc4024975de7f911cc81baa17f45d26693db816cc9882a1c9e76fe08d3cea0da32cbb2c2810ad3cb9beb97cc492a67177c3cf16e9617cb397f6c429772d398580aa5c8fa154db79c76ee22b1f9c023dc14e0c4374f0afffa506b86816e95402db6a4225ec0bef657a4d937303e9104955175d50e83b5ccf6283b81f6db3afbb304282340d3cdb26943216bbd6b14bce924fbd4fca2e22469b383806550dec374168aa111931adebbf1ddb2f528e5b6a9f9adb85b192cbc182179badad229b793153e7b623c99dd85f4a01b60d17b28f2e9e59ef4d14bb704fc9910da0efef2bee52752de73c167990c8b2e7f6399aad0569d302436ded9e0fb7b033c47da476a8feb7ad79c9990f4ff0aae136738eaee0d8fe195988b9f9df84146af1ea549c98a55c77f3528dd35c40a4128fff8fb729dce00cfc54505d6a48a99f51224c2afd3504e189b957f353920cf49ef5379696a71f85781ff5072fc056551315174dd12c5d57a326f74a6506e36a58ffc18aec70529fc025783a386803d18b0e244c8e6d7db89b98095f7618b1bac1d0bc0fa191495b04b09d13e3a17d6c80851cceb0b4cf8e878b80761839e26a057c67d25b958ba7a6fa6ef1244b6b615ab849b8e7804732288661e25eb29d331f28144b04e2e2116e6af6f020c862fe8918cbc66cdbdf9af0ff45a7a017d5b06e6fe6da2bf238c132bdb4f434d860aa537549b369f492168734c5dd21174660f68f2a8c7963825422472bd861bcfe0ba282b545a6d76a8c6eaf4e68a0dc7ce14a5913e4d9dc01d0d297d6886bcb6467128189717b5d5825f3eb008795d88da0fa1401217369404c832b66be7e0603446677166ab5d09d68ebbbd42c039c4b68995509774da7842105a987004afc4d88881dcd7ea3e73288702bf315eb9bbf9b92dd746712f45460c3cfd4681bdb8ba560f2cbcdf21fa672d06fe602d7ccb246544d9ee05eaa4d69b24ea2817aef76a1b0cfb1ea1e83d23e053ac15ae58c4f08432c9b9dc6abceb0e9ed34b424ff38856df7df5f1aba15eb358e20de8c931631d9ea09d427cf0a8e005ab09f3948cc4dc53640d29e8dfe1cd85098d0987405c9d0f5f614fed7ba0520632e54ae50adc189aca261b77c7db345557e88aff261fa7f4eafecdc60a55a070b35e5828a535c22f47245370d4782df1e0b1ba7d868d6f57fad614e7ac5f1aaca29778f864cd34d32ce6c08bc91f35a02fc72e789b6d781ca4162191b8784573ae28f81050485bf9e0431ba721b3ef6358017649fc3a24c2297a920be75f2fd7f56edcff0d520c922982732520e4528225e2bb339c86b22f1b35694725b48a275e090f818dbcc2a6535bd2ef120e544c0e5dd8eac2de74fa4c4957736d4ce1650377916ee5f0a0a1d9ab816a459ca5e6dab8cd48e613e1782482f333b7b1796ae1bd45835c8f37c38dce48ef215248d38aae0695bef24bf6649c051f3620241fbcf8ee6acb9b931f57025339dc3479941fe283798b74b705a73f37bc09e68bc7987dbb7a84f5fbf3c2b383c5d9cf6cc4460fccd63dc295b281afecc29bf5fd2a737c65e8ed7203ee0e62f7c72e9a0a167d137857427dc0f200544fa5e1835c5762a52a614383f7b1a4a510a593ff1f6dff75378e34c268ac2979164b93837542e668080feec0c2281ba49303c8a1c588af02ade22a04bafee0627492996563b25483ef91068285c9c8efa04f2598cc9b3ca3f9c5e144879b6d402e1101b8aba624a56272fd44e36e28b6199750986ecfa58bee874b7f45aa5f5ce72427abab5d0cb94612a6f2232f5d50a448b712604a609c5cadcbebab1e1ac4e8d904843d5913d74b4decff9ba8152aaf7d92c2d6ee8c5be263eb36045fb70ef7471a88e8cef8727fe6f9e4d973c9dd0c962dde99b14ca327dc60ed2e5294fb2fda7da924d3699945f69a310ac5c1bb34f146116ed889cc23c511d0d7d27abd9c2735452c90d45fc6e2714f43e653f785c9d58e2161149e4e41c5aa4317613b8ab0a5bfbb8092ca6ad31f710e9b3ceb94845aac7eb8bca959ffadf4c3aa465a000da10a520a6721e60ff6617ad14f0b7048b03717b1d4b97315db1ca31fb6ac550820a069f794a47b19609956383124d85d727141575afed47f04033f9603f392c486a375b2388797dcda5c19733d53bcef60e148d348554d281cfff534a23fd9ee288b59c20082665f2de289148a347eb4bfe6c15f5cbb9fce91556daa8e1faf24f31d1fc6c0865e5daaebe3e73d1171ed3579d18ba9a7b5ea7e40590e7f0cf446c04101f84d54375f90a79d34f2e89b947b673e94e3103f29481c027ed275fa38aa43ac5e6eec181d9ab0d7c3503237a3a2ffaf324c906073483f6206fc1a8d8edd68823f1c06d6790604692c0fd4039a45e0bdfe8e702d9a4679459115efb4224859dd747c27085146379201ff19a0c7b0c1e9126c0c0b39398d03d7b8bf931a948a0e6d6466c38d28e45ed9ccd5ddee194b81386985d0c1b9163080db78e3a50d033662e5c92eadb8ead1350981444b895b531d634cfd8e7c963a430e2f46a82969e9a9977d63e08fbffab4db547ba6d5d75ef7b608e6aede301148c1d695d159702fe667bebe363c0e0e5abf5e92d5bc38db1eec4034a0b92ead8d3ad7533af60fe2ddf11d80253b7a6a2b452ef0a9b7a85e51929a72896da70a845be12aea12376fba012da2a038d1a972aa0b22e22761ed4d380eeef4c5c3e19b081bc3aa07e56c87a06ed509e1fc26cc0a6df4df032b751102ec1696b9c79dd471679e0265240f7d5ec40723438eedd807f8c546b05c60dc32bd7195d915b995594c7af5aadd87b39c61025497baa3d4ed256cf478793f3bb335dcbd5c2404d6620c6d2c1f1f3edbb43e9eb3256ca87c306d5f243ee5d3df358f7c37b98646c4535d1ddbf620d0cb4a2463dc3e86a99d66d667c0f2009f0f6a208443ed3077d59e26469e79b4506e144332165450d9e093fc43f2af57fa9fa7ae85c3c8d0a27a9eb8c94d77fc3dc1b5693cbc778198f4ec0080ea3eee63a8b40df46ad68b1a86de8be27d1b34211a8b1523291d2b63d6d6bafc669b80b835dabbf6e4a9ae7abc740760bfac0ce784548eeb8a60c0a58faf88961cbed1cf691fbeb31a18672a58a91c7b2474e0d7b88f73fe0f88c42a23b3da3df18149699523e44502478c0cfe556739bf41dbcf9cd1fd33b91d83a3a59faa1a51b9b7d4df03e91cfc8de17b7f1d68ccf29f446bea7f0b30e99a8fd747d51cca2cb7e5304dac52889c3882ee6df70bb196c08dfa0f4fb6354cca68956e2dcfac6a7b2e90897ab078e4138f0151d8ca902d38e8a6d3cce52a7cea86c4dae7f34dcdc252020205b9b1617d33b1cd8408bc5706afc38f83d1bd33f2718c28343ed5bd0942c2042718cc9d9f7e229fbcc52c0e387a49859f1107eadd399c6196792e3006340f0f8d2eb4f922d3c7ce8660651cfd6d85a73ff10edeb9ffa2e5b46ae484192e038d0a227f80e280850ee561d29c00a7a29029548c8a4f1e7292fe5dd3eb69527e74229b103f1d3d4acd44f31e35b2b73f5c65065bb54c9f4aef180caa1d3103390c2d29463a46df7a592c3cc16676765a0e03250bf06c8146e3dc9c09497be7c8bc91def5410b0ddd27dc84aa804e44a3357c04dbce377b06021575abbdaa875953eb4a65bd6580245003946e72b55283acabc0699dd83e0af03f07edc4b12306bab313db9b3d4d91280e9130d83b78a32528631a1df3a296a09e2ee3302ae9dc1bb2912ff95d98e6438ee463dd47d9c21af355be64fce428f7d3627bc9dd1f0c0c6dfae7e1c115e3ecd2a43b8958d15d4bf06960f70f0d4afc793b59eb0f0044e8d6d011cf5c430cca65317f920db81961743cb02cc4b04b07aeb0d8916da934265cf54529b454c7624acfb92381472c115875b7211d410a4ee9abe8c28f12d19acb47083b245f1100bfa7f85e2863a4eeb577baab76aa4aa513e10cc6abdff618c057572d0676c44e2e7d0fbf853ea6ca12448b219ed02970dd87225c8aae2e7d9933f0f98093e325cfb571b880c4702b26f5508b47244bb457ee1c30f6e54d2fb3c90f6d51992051ce66867601d1f928a44d9fa2d1e3caf5ba67d994a175f3f136262887b3544eb879ee0326c46c68d0b9e882e8882bc91f6bbbee5ca52af3d5314c6afb4378c2ae1324484433ea195ed7728faf72e0c2e7e85a2909e6751f3ab73fa24c91d51178c8ef5de0c44228494586c2513facc92070f541294c85b92853768982de688e84f8a935b04dd9898b9cd7a8d7903be13c9df634a2667c649fb1c6bc07d9892a3b4776f3481960af7e6e0d7f7dca37efe58d9fd661d34a43c84ac7842c934a97eca31ce15ce413518315615b6fc987622393a71e749b43fa5214fa08d108dbcc12bf5562c9a084d90a1191ecb2b137fdd20d83d140aa7390ed88ae3d9f660d53053a760cb96907557f6cbad8808acbec9139b058fe1348de8d2f43223e0b47e42fbf67e46d3008bee0e77f8fbae2d0fd488c24647860ddf428d47c073e3a881952a9fa0e044fada37d7a9080ebd8e0299ca74cade96f9afa58e9372119eb5bb5418e5ec74d6ff54450d0492d03edf16098d08281b26606722c845751698e3d8d4ebfbee8844b7e1bb741b33bbae08109a2ffd536f50129ef18e14a4effa62799ef9f71f12c82b68c91035b8a01ea5957438448cea63c0c7c9c2267382b1a1dcefb978035aae939deeda20289dd9c0fd3c295d7eb54f63bdcdb5678f808db8ae69a252497b31f365eab1bd1a34bc04bfcbb76d3b6e3b3b494fc6f9a341eb1de85c2fe1d4ca4b2274492c8ace755d45b6c7d0a79085fc40e572f73e3858f8d975f0faafdf5103f477ad75f675f2e06deb1b3b3bf2ef262e868903d5a59165e3c3639660f1c677414fdd34840e0437a77d66b554dae50aec62496cbbbc1d90c557bec69ee94fa7d353b1210dc9f663047344e8d982710ac019b9c22050c7b2f1702112428370f6d41f118ce760a27276ab6a7558c9389c0ace4792e2c542ab8b1426930a548893e5de9fdf5480fa7a405a797242f0dbc5af28c654e6ce006c8572ffe29e069ce1190cfd73f4a8fac4ca7ff1b32bb3f37becaa05e686cd15d72fefd3e6be4facc90ee7e06a5dee1257df99a985ee234d88ff68bf064320bf6094fa792ecbfa03cef9c2c8d95d5bc1d5964c69e4ad930fff1829ccff1652dd8d40d91966ef4a152615b34159b5410b8c65768e8793ecccd2dc4072ef35903e107f3bdacb51e7e134db0e76a7c91c9b950191f676f7fe3bafafa6f00fd17b03f68982de320e805278b27bac1388b98a10d6b9c299a98dbe3274c430374c1cff90ce26fdf3467e6d9e361728285d816d8730d8138eb490e5524a47b6faa6399df7346672a4967334199551721a1ed6978fa2775aa913549e4a9c4973163e553e89fd5d8bcbcfa01f7610fab54b96bab559e4c06a8a3450fa8f790d52822e55d81c786f078a04230e5915c30a06c582fcb5e00c80b54a62f502707aa6dc30199cf3d29f5581deb068ac70fca7b826b3aed3217bd64e552ccb6a756c48a721de88a9cbe73e9f2a1646222040968cda16bf53ba4b743e9dab42074b2150a87b782d6ccde93bcc04d5b1d7f6a3247dbfb0c39d07caad8ef712b8d15d2125c3601b00844a4086c956af91f7e1b6eb285f635f8aa30ff3b7e46a2ff4e464cb24bab802246ba865ef51177528584879979bfb9170bb511c79057fee96efc5817fde6b2576d67793efb8827474b4810fccd3b26cdff25652712554bdf2e8b78ef2881a95c7a7d61187aac73b85505f9c63f8c08d042177aec2acf1eeb4ebc2632c5d9d33b1de2716161a7f0d94ba1fa968fa7e7ae9d03eac0c3501ab728be35c182fd55c074c10488bbd57326054c45c32a2dccf759a7728d97241e27df008bef6031fb2a02086f616eafd3b5ec504b860a6972fc520177454261f5c6602967cc2c2e28cdccd71638f5330878da9a4d6f33a3822aa25e45b3a64fe3a1e677d28e0b346a55218266f20bd2bc3cafbe28a6505751be95fa6c173c6ddd4d1e811bcf87fb41f0411ec81b76136b210f29f4f811e7b79b3d917f5ecfbe6bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
