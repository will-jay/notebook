<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26f3b990dd148b1aca088cd1aa712e2007ffcba5df598ff9098dc1d1b8f0e46a0d83ed6bcbfe51bb12259e22722910f1a43d5d2ff6ba91e877638129e285427416444a89be4d9fa7407da2d7633aa3678746277ee6f81634887ceb28f1bf959dc15aa5ddad2f1ef1beb99811b7acbcd6156785b7a6956a00ac71078d2a483d49e96c6d2c2fc0e4dc2a4bbe024afd8a06809073af5370d90788b79a53687dd9d6187251d353d293b969552edb10e2ee1a3e7e90f23eb21bbc41a662959cb1c313ce1f31ee0813ecf08fff692d43e910879019bc7e5e4b43f5bcd862350b70b1762cd7c1fd2143ce2def38c5c6ae64d76e0a88ac3fdaf29823a16f7cf25f12b5e905136fc8ac80889e27cb1cb6d02b045226c78234bca3e9f17dc4e5e268ced4c156af1855de19240d1d98ad9627e6f8d816195287ba4cf0e52a95e3d8e1f0dabe5744b91e04e0ee41acc2fcf62804f5780f1bc0d9d1fa34449245134c9efa74e488d5b619c04242d4b5a2e4ad52e1f3c4d32d1030003ca028bb9206a97552d3fc328559c0dfb110e65781c72eb52b186b3c0bbaa9c119f56c84a22f0d0e0d4ab3243ede11f95a313e3c0445a935570a7809554963f5467c0a0328e5645628a094cd23e72f4757a59af8789a5371b5ca776e5fb57533f0245acd279456970292e1286ead1b3dbd9fc9ddd58ff78800a7b8b75bbc0706178a9a4c04a314dfdf1a2ff9a22f070127e58a0fe55e730a694d434e1a884f8f995f94deec536e768e6945530ea5a82d02799637dd1995aa902d4ed9d3abb0ca5959c96aec1f3f7c08920cb7500907ad4774658e05c3f69e5e9f7d9e7087850d97ee870a29e1c4f256c0b10875453bba71873f88ec14f60b5d2955397ba8947b61c0132aa709035f8462fca7474155373e2c066eee5b875369bce4df669fd3ed8379db91f14ec9dd36832ab37a08f98f608cf5266b87f10aac552b4257843cb1bdc8ea2ed2bad3a79a70827dcacb50c8e78edee75019dfff216d29fe01684325a607f12d37263472be268b240c6c7ef845b9c01301ed9632b2284c3081dbd50870a2c24fe3ecc093c08b147403abe241ac772b79656cd4b26d1278ef4ce57ec1289c18dd3fa4bb449baf5145e72626ad55043b843df9d8de3103d1dee64c004ce120a135c6280b6fb9310b136c69c8a661f558f3bdef298fdda75974ff8853b7357d5747a64aeb848e7ec8771c44a1a3db12f03c2dfcfcb2c0164c7fcf2a144eec7ba05d835f9bbe00bca4f94c670f6d16fbbb777aeb0863ed44fee0bd64284ef6e92ed8b445b42918d361c855f568674fd1ecd8e303164cabc102a8e2c4b55d41f8452865ef2635cb96bc1efac9c878bcf7010835908d6aebe290700cb0e687ae436711e2213b1f32663dbc31ffdd288596f20b0922b233c449b4e9b0035f3e9fe263d7d0948fa7673aaa3b9d17cd84a1c3535bfbee41f931c28b05ee7886ef679d5a35f13198b4992f771237e1e7f0785adb9d05a222e0d393dbf754aedde91ca4c2f584ba04e88bf39ad73ea3fe3753e4d009e5ab6ee3b86e7bb7336383377a32853f50fdc694f2262c7051b6e607e3f97058e52c9c9bec2bec6e0a1b974f7539028c5e484c340d3c9e7c92cbe073b972d391e02f31994660243db31ddf05994a769eb9f380442729ec63ef0e8316d4f50c1c5b0113128753e8cd247921e522247f70b750167ff3ffd19b06a298da5eda49edc9149a778cac8962c1af2b6e74a3e2c195ab658c34df0d7b71240c63492f49b47dfc747e7781d95cdf8cb2e4d274852e84260ffe7a780d6d3e6680ea408924fa084d5bcceaf2f9e18565dcfa72ecfa84158a6b7d1be52df9b33a55e8250fe683bab0d182798ad1b05c8b4caae85f789e83c0c63d61ca4ba03ffa0fcb6ad418451f7740e6ffbdbf41570c23139f9fe8aa0a815aa4315428b36755db35b1874cd2f3db12db388c2c14ca43fdb7a5fe632626ebb2d92279cb25384349ead1f934765d51ae7f94e59d2e1461b24bafa8e81a1c89e267aeeb872e9ce58817c6b65e8574763371aaab1047a9e9eb540059ce542452d28cad6116aba73c376568a27ac346bfa930fe23a22b5d85043c2dc71e7c87c4c9653ab9f245515993925005b07221b709217488695724a7903adc46fe6e6acad6782b1a7fbf46eaa3d11c458393473b03d3fe9adfaf64a6dc5b411121527ce6f6ebfa2ed6922306e80ca3aa53826e48cb16e5b2cb9cb7272c411f896464b4d71fe2793ac153fe9914c4b28c4c8739488811ef559a072d01970ae378ea7b587e7fa4dae79da420e21a0529d6b8a17cdf8edb7db01b6a05bdd5c47769a716baaf6958f2f8e55817c19eba6b59d364852c9cfe9481898bb23681ad24e9a2abd93de59023f05676ba7b81cd828bb2cbd8475b752ce32af3f4d1f975e65122b1d32fb2fff165f56f710f095773cfc8ef0881fb84497a16f562b1f4e576c62085e9efcb028cb38c0e429fd12792c47a9f73c21a914690c8adc17e837259c3b95d6047c2b3d2ca7c6062aca7cd3c2a85e5b5c4bc3ea2216c940b2a490da3cfc5d23ea4f03882e898ad9e369792c9b529d10b5e6af32c803aa26f5c226a71e1101840685838f83b6313c344c005949901b0597043790831a20a6678d312d4adc523657440907cbdf723f8f4ea481d9f392aaefa98f9646963ebe1054ca890114965524a40107c340555812cd642a2692b7205a615df036ac70ad858931c293bd31b3f5b997331f1648146bd6329e58275effe39f6027dcee5ea0280c9a594d66b1c508b58fd7ef9113c331099c827e8bb175367e992b2e4f862e6f1e01ceb402fc7d0d4665c3c52e59c2549fdd6308124b2d422f30855286da75bc167566a5c733a78796f3b90d50d6144b1c6ff69e477412bdd7fd4f32b646c34a2d2e131596daa91d9a2f31d4799ab792b771a2f1da0af2c5ee7153eb347d0e28f4c2776ab07a03859abef272374a94554454ed58bb16c9c617001f8a04bed9ddb47fafce01d666c40432eb64f8b580b43e4b888077a07b814966085ac0e41609d20c79b0eb65a7891a378c81c9c977a81b0bdf67d8184548b2e382f26e64db1220f0640b1a6ff84e9ab684e2d624f8851d74bd3f4ba479aec78982bd026fcf4fed8e39a8d53bd89699c643db7a17f0b74afaee592adfbd5b43d96e0423898eda2e846578e8063be22e2c58ffe6c99d9717ed9fd5a5f1a5a253af83f7f35fc5ee2b4b9ab9377a45a0f3b36b65e90b3166df169efc83c3e5e40f7fdd1aa4447ce2d28287db9e33cf92401576afa3823f57cacb6b037107d5b6ea5bc1cab166e25a7951fadf2e994b0799389c2748e82ccf68675c438452f501d9383738bb73e45444dde12430d77806c29e8104e60096a1e15430ee0209b98ad36548896dea4d33cab6acffb5be50004d4a690ff5464eecb39bf51c5efbb9b2408e7bf0f1021a86229a8442150a5378ef36d8fe581ed1d4e9baaf3a3ad2926aefeb43a14a0c6e5bf6ed47e6ef1da3ec777258a7c50d854677af1f71602af06ed4cdaa84c1169600fa7869743bce30b648c09db61dd5fbb7fb39ddea0b1df96e533e5b456436d38d3ab4f7f05f8be7a804af9350873ed0e668a862f44a2627f9bdc036bd18f68c00182d6a4e0fa54d32bd45d9048cdfb6dc519f086ab0738bc0868bd642ffb0619e66290c7fdaaf538669e98a006accc5ffdc7a78661e66791f137a95fb48452b6e438b8c5adc95015e783b78f2254fa8dc3c215b2598d836f8167bb0084309b6ecc1ca7a8787651073a0c489c16c302b1fb1a43bcbc07926b5b5474cb659e164190abcfb66b5d3de7c0681e1a68a0745e3d308b7b2710e3bd3753a2b2f3cbbb883737071c8d7d466c7895f473db174404df45446682a6d83276b2fc270515599c20c9918646d71fbaff5793ad57af4d8cf9e196e032fe4a8a4a3e3b3adbadfde57c9d4bb8259ae1f36a26e5e791af3f75461fd233081f4a19063120e57efb1eee2c51f26e71864e2c1e9b336cf102fddcea45b8bc8091d5cdb412e7099f157a217b8787401aa22e9d34e9bd6e2c8b135df5e183b8c3bf06f177b0893669813baa28a747dfc29a251a688c5d7f66f4bc9c0d0edcf0eb544481c0d64f76399206fd930349723d4208e897eb604d9b5d3be70cc4dc34032197c72a5d030dbba5302cd73b4910cffe7a248b2861d5afd518d10fd60416814c5c0753af82efe04028ccd647e3b60d0be90641b7cc870aef0e37b4d267e3c3dd0261017cadc54330f83925e2917cc14af0c7439bc52ac9aa17ef71f4d7d7d775b1df6f58c68abafbf95087e86b28fd6a9a36fd582e3459152b9ffef37a69b5e1e6c98c7fbcff46aab927e90a00e8128fa13e15d22e44dd365bdff964ab8f415f0c8afd1d464e35b674f36b9233815dfa858f6d66c71918db30c9445b45ff7cbfdd28616399216bbc5e1115fda201cf0f13156dfd23a8d2e614b15b357b80c982f54846afb14047efdd69311cff031df131ee780a6b22b30317e6d551a7d6d095db37aa4c191cdcd8f4be2d30ec62760c706720105647b6253fdda6095929191531abe09b7a883e646439341e05ea8b99936c4438674884484da085bad2e0a5ef3a5349383da9af5c6df18288d44779f0256239bb1532da4686c729d9d2bfa476b8be0edbcc19c96f7c0a09b97549dd9c10215bba2872317d2c683a8fab8e588ca642b8a4c7087c8fbb1e5e21cd4db120eb3622a91e01cbc7cc5c9c0b330f433e97e4d335d16ba79ce44851fb17e390c4ff6fdd210e90d2d3817c2590631bd98595a049383e42b2e8064b0c157e16913b3f184eb471e1e33b3bd1c119bea98217f48c00b28c3ccdd7a358e767a67d2b5b6fa34bfa41ed4bd508e0e7b347a8e58991e1c1960b44db58581464343e6d138011fe81949ef92bde74d8d1835a67889cf2bf0889cbd13762930081d7b2237b58ca552214ce9d06ef435fbc11e76220525ccbd21238aa0437b8e470283ae4e53ff2068822d6d25ee14afa9354bef3089751ff7b2ced0482fd065eab0f60372d895ca9878521dcd0c867c98e27aef89028d85828f32041cb48583fe5fd50e7070d73876b65877906f59f1ad90b370c0f8cde2b7d9396128c948c6f84dfac12e643dae0555363a52ea92b8b73cee8428d01339add2f0906dc6ea76ccbd54922d52e0adcee2bbe8d85dd9bd5b3c1b51ea490d763c804b82ce30adc7f4a8011ed2f1143f85c8ae0f7cf10d6dab2954d80d2ad8fb9c1369f0866a19ab5eed55b61fd02d50da02de62801c2c79b28a4bac5b047373c21412995f9f3633f3c3598e04b85ea893fab9a7bc21349c9e25f361c4284c173f7c7d50e14c443fcb4c4648f859a72fc24a48aa3c4aac4a8f514a3e22a3a6051bf33dd5492b239c2c5425a5be0823dfe4192d47f2deda414441ae5c7bda8419c7d2510086557b1eb9b2b2b6e585d0a079f79982c8a0ee8c100ebd0c51d4c9d74714017ecfd14d22d4cb2c54c2203059d8aa2c66d5a6482403d3df59da128c3ecdaeddfb72033183f9374a729a124c7e49eae1bef9c801f5953255330c235cab21c0173c397f7e5e4da9ab861b56ec94222e43fec74f3a5cdd2c0fec8d7927bf5a3e4d24badb786b352654fde5954c73e3d15419e3735515c92a8a5bfcdd4186bcb15adb85f75a462bca460e58d561f1993b2f4d111d1f5e761bf589250ced6a642453f72aa3a9142195a293c47d5a9b4c90e2f9eaad64e16267581be855482005d6e1213e637bad5e801abe46c6a129e79a4a0ec31c92771bc8f65c0803df8422f5a0ced3a3d6833710e056b6f2d9c080f2df272a5913b04a4ef5092c9683e2038ab49b1f4d0a36d0b1d4fdb128b13d679ae923544d752333ac02c1ff8f131562d330e6137a935e8ef4d64324f443dbb12070f97494cb0363979ca787c17e9d68cf76faa7da2676d3c5d959ece156d293e97aa1d614d21d5d5a406ba0bdeff5b1c361673501ea1a5845dd265b24e311c84e738c130c25c67554c0cc6bf0cb5c233584aabb695c38b7473bbaa410968b7f232c3dd75029dfdae4a58e3862752c66d0695f389a578cdac9cb5f40533487f4a1d48b8f7d8a9291cda864fa6da915ad4a4899bcbed9168fc9cee887ada71cf3615e30de0b1729b766186ca0a6adeba17c0ff2e23094ba6e1dbdf0d1a4f3692aa536ddd8f42d68534fb919f43f4855be50f462da1170513181ebc260af514ac7d7609f10e362bc95d59df78918aa3a3317de2aba95c549f4710bc85f0adb8a0dbdf1dab6f5541160e5946bae95830a86a2cc72b62de582e73819d6a3353b1f89af5698990af3e2e9a98617bbee512486b4436a0ab9a2757e43dab01f714c1075d1b2b95d756851a53a743b236ff196227928277d28ee0bd03bea86243151d6dcf469a1d7878d7f5cd99109079002b47e730f1812c8747ff230ffd4aba86f1a03e560515de9085dcbb063b75a6b0f6c1457025f9d4e7b3d8c50dbb3881837aaa39f7c8082b8eddc72ceb1c6a77bf67f4b7405920bc6f65d3a466bc6d47b0d69940ca7c64cfb8eeff49300958cf4b3b7673c5e66e39a7536606a5b17452c8c7bfcb8452abf424d99f651de1c21a9fc7f5cfd13e555d05c16105d0505461d4219dd73571f6fc537a395c837d5746b1662ba9892bf83ccb78e709fa20cd36453b4abcb0e4f4a7f39d7bcdb25919d042bd182630d05d16abb1a37f8cb3d75e0f8797dc7ad8e1c3675b4194199ed61c5af603491e1755e55aeca16fc0d1d265c48332ad95b114ec89e45c0526947f211b3981412e13719041671bba359e0e5a12c14607d88d206d53957a7b368fba13cc81f8a255b3aa422276e438186699e23e49dc3945b43a51da09c1a7ee34530fac10a92a7ba85faccebeabcef3f9451bcba998271749b6e85a97dba9f759dc79a6b0d594f4d36f2336c35bc37da86057cfac76fc2a3a28d4dc27326ed439288b69fdf725bbfc7976270d7bccdc144c7044bb313ebbd443c172ef3bc8a15a7d498bb1ce37b789005edc5f1fc34f1e02c9c21bb505f803ca2ab7917779a9e21b299118b1fd66cfcddeb0c2ae5b59f84639c204744ea27259b66dcf2dfc3a92968e0005fbb69f36bbbd181a174942886b407162df6c1f22ca01ddd013b1c6b92d3f3f5840a5cbe610600583b3410dd240465408adcce4b39fedd7cd2914491aa449772bf275486769f86e1d238da1ee7c3a14e47a4ff62df9f0f28976319eda16b0a19aad3d68c9d66120a79360075f53e71300488287498ad9216dbc767dc74c1b608d975d8e4876f19baec22479557617bb4866eec3e8ed4cb80fdaf41d9a7c15aad36998fb00dfe2698bbae540de75cdeeb694c4f794be1811f952c41b356c20018ba5ba17281287007d44925a8ac41e99112c60a5117b5dbaa146a5276fcae13eccff193cdbdf8d7786ddaee08d0599f1e2eaf317949ac9d987713a2e4bcccea1ee252acfda8d21008e13aa163d7c7054e17493e41a27f7de58ea4722646d286eb77e9d95e73cfeb3fdd5eb6e97c3f089641a26ec57342c01a710b1d9a24ed0e4d291c0928cae2c5893a0cc7b1d97db03b4cb62e6f03ab35b2a73fe563d63af02161488ce3f0c60d583335b3d165c20710a6a9e2afdd93b6d39e02183949713e4103494eaef7818b5fe56e48fa7f7727420ce5a7864fe680c09298e289eb6d0b6add25f07dd1760804b3922dca9fda2d44b8f28fb1e486a5f10e1fb3876d5f131cc3dfcf23174dd8948cc8f9bfa3357874e09c3317e3e92cb743864154957647b53ba7f91535dda96aef37236b86e1bf055a3d67b885f188109bc8c86fd302d03ff3cf41178e01573ced08919cb320290b198f556ada05098879f0442457b9dc0e73d26174a8b250059ee1fa99ab37f4d8c0e7c1f0046b63965a1070180cee0bb0c37dd9310fccb3630de69f1aef49c83ad8a712df6f07642b42baa1d67d094e8e9409614cd19153f7d388f4cd8f185ff946865b4a411e01a2ffa090c55f8c27f5345458540991ae9c0e2cfca30d25abf174abb02e46fb53a0d1c1af8fe66389996701494a9c338cf3215c31ca843dafd297d8754fc8ef03c5953ecea259b80ec6973af4d97e9dd5091fdbaf9997217b9911207bffaaa8f9961cf3cd0115fbf4ab36bf4651cb6ade4e26d2d204733278e6523bdd8303e00b02a29af9c88583ca629f25c02655bfbed23da9121d409d7d84d66641b9de470d7754f8422918a8a59f3f78e90d31a0d4ff2032d4c701d78ee0e393180ca9893cf54b1f2ac9089a497c324550c7d3e2d94a9e71589384b1a3ec95424133909a10044cdcbecd27f33e2f6de19e337f1bbb4faabe3f8224fd7cb1af439aeff89a591df732a241229fba2d057f111021bb9ece8749dc2ac31a9e69abab95af12c0e1aa388714f96b32c1d3cd860bc6b3ebc23d10c2426809172bbf09b76bca77aa0f65e0205aa33643d60f9aa82f506799b2cfc6cac962e140bf23d256caa02499031ea260eaa434e7034c7850b92f5f6737167a3df28f0d58adb539e49fb86fe9596547fce8cb91bf8efaa56c84894c8547fa7c79c8a38215124b2e3f3932284055e59cab459fc6e9ae79ccd52a616b74a6208a181076b923e89efc9399f75e21fb1897e9d0fc54eda8a5619059d294df46841e95d3a290f84f901aae37fd8f73d0f399404bf6167c7e81403cc38fe75f22a80cdaaa0de57691351d629a0c2f9c5e29bb3e030f8dff37317a9a9d5ad5e6ad3f7e91da48e99b3d0ba4deb602c7374150b3d4a70e5c2fb578e93199f3d08d11382450d5cf9af882e0f35d1674e362baf19973e737d16e0cbb1a3713b566d9b722ba226b1a506e0f2b5ec015fa4023cbe37df27d5631d718309b1e77bfe667250bef9e9602eb75c0dc07b9c8993ca31fc76733d3a734f7bc7dbca1bfd7bb4a8b369f93c50b5da3780cac812e835f186aad3c68a4feb1c0522edccffed8d4943ed723204b7840735af187bc27473c3f4f69c4873bc488ef0e31efd3cf6a4310dc6d1424d4d0537ab35045e2d4a271ef154d6535a60bd02e6a5fa797848981b87421c5627ea363510c88894f9956d1a82fbccd421e8a45f1ac0ef6bf8e4260141f5c27386464fe630e9b1aacc5a305fc5db019d172f90666dd3a4fc7d4be026f2ac96f4fbfd91345ba8c54c3ced729ab2c79f6ba2773fa56d738347cef9ceec20586f877e5d4d135ea8a18786d3d27331593e5c3a9c655b39187a249bc4a4f26a5b309380f5573150e654d27a4b943eaf73a7396f45c96c51c24a365ec76dad0c89517f0968994b7d8443143441d07e672efdfa63cfb340fde824ed2612d4b839392d416ee0b88201b184fb0ff90fe1015b160ba838d4a786b007fc87cb0caac4a57551a1218e28ec39b018f9d20408c9f0eda854a1c81861c42cb93f828e4f36a2c10b2d121670be19a706e1abb66eca05dadd58789fc225563e32819012eabc1a2180edd94ed33e53f0907a41f882c5fd05f433204ff926f897f1dddd19ae9f790d66f0a121fd09883b7f2887ad07ef4701b4390a57d84b978328112ec058fe05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
