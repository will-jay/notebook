<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d8d4bcaa702c76b426a75839f6693d9e3f64372badfa388bcf10d647eead975614efefafd6c56d0306bacf0e02476d024c0d4f3dc665e7206d25ea9bc9b251c086b44f37ac86a4aac44e1c7be716c0cd0a2589b2f7445e2617c6844a9f398c4765af85a774bdbedb037c5a5541615fd4ff7e20538dfbd45b831b518ee683045d81f767128a1e0501cb6dccc9ea81f4b3e56f50b87d06971ae7ff505c0fdd7768ae27aea9ab8713bfebea736ae8adb81497b9d7a015ec8038b0841c7551694a4a15ee2878bf26574107e3585cd8273be9876daa85e65204d18a5c0a811c1d27f2f72215004708ff1699fee69aa1893049f8ef291d9f046a171303764b319841f2a0bf34d5a6fa997869bee8fe700112e3d55e9067aba7a3aa65c6cb44e1df3a7dc4779de1fe85c8afb1903a02e05dbf1195b70904683e9bf154538f99ad05289343fd0116a7d0096b3202aaa1ddce5dd15d470fc346eb372e6f5dcb93eae5ad8ec0f7a30ffa734cb1128a4f1efc5637a998be6d0ca12614199172801b214e9c851a0d21222e9369e44a98774e4262e0b6ad5d54a375980ff9e99e3cc6a89878f98305f95aa15172223c34ae83478fdf0738a9ffe563749a757b879c8305a087272b7adab860b6079b5910bd69e2a84205a1f9896773bffc62af4bb95cd2827ac7f84a781e6ee9632f9bdd6c74cef08d82e8bbadddec13f4ba09ffd5ba8aab0ffe7b72f3992526406c604a284e268782e5cc7688199b46cead07479b64d5d9a2ffaa7eba75c734c09a4c2407c09729b8e8fb7e1744fbb09cf0369c58778b2cd995d8eaf3c4f8520eefc4ea4ca3e68ccf02618da8df35f5827d57fa47c8dafcbc630cf9fd31c1ab99dfc4483430924d022f1adcde78dbfc3f8f310202d4a35d89ca0444659f768b8bd05cf1d916da01e4b6d3d3c773b521111014efaf95f54c74a3017279fa63df844cac68bdd38212345ef39e35286568295c7719506f632f79f80fa6c3cbf5a14710029678ab3269332704a5089ba7c4e4130fb1af82ca7523ce31714ea9531096555d16544a8d6fb99d5dad184b99f820662afe89c8d664d6d5349b7a6670b2578dce8ab65238171bb5715af371940ff54ee061557981113e7bf765a24a32b58561004c182a5b82a80042e48db6e1e0f997fefa8a0c3a099213d676d43278d1c04fb0f523401344881e8c50a9f223a657136babf4a74434a10e2c30a9e20067c175229457280c75dd37f623c265a7dc148f827ce1731277dcc13ffaf91d3f6898cb78e5e2787b03e894e6d80de27c6aa4e213705e6290dbe9326fa0ac7499f78f324930ce261155b6fbf28194cbb1899a84fd761b5ad1d0a3f0edb2c5f4b217c561d4e2877ce66c918b1f17b3976314e1301a50ba6f4855a6b1c2651f8816e0ce5b250aa3e14ba94acd71b9471e7ad2a8a0ed014d159ec80d6c02ac03d20c58269a53f84d7e754eccd3a97b65b02927d1d329323d3f2e01781d76df12ed4be8c98a369d45fb49e3e0383442fc115701f558633cd92c8e323b99a971c3ac8bbfcea890d13e99665c28df92bcd8bd74c86471a55a5309cf9167a1eddaf99c9ede570ac361cd163ae36f79bac1c148ee06074d412bb113b462819d7d7546b96880f753cf458600d36e51187fcae8dbfd0554671b95cba84f21ed81e7fea405e5aae34ed9c9da0cec02e918dcd1b592c85f449eac2780e909e9fa173f02119850c0de92efcbd02b131334187cc40efe3fd6a62d3c8457186159f3c29910b4d334cb9f78189fb2e25c5c0917177ba10a98896b71180e5e231b79c3c176ed4554e7911d6c435c019f9eafd83622948f4c930d9a0d54e78c841cc67a6153b30a3602772a7b6823d2d7bfa7eb925f0fc01cc2b9ddec41996bbf6ba396b13ca5ffd498eceeda02eeaf4e8290e05d35bafb5f02adbfb613685932b97ae6d603611137d63177b7390809eb77abf0d8d21de97d436052ed993bfcc2b1b8ca678b6ebae4f9f7d86df7457fa8a887a66a362def33e22e9b8e51cfdb647b1126bde1016423d4a0870c9d86a501b6f3cd88c8c1e4ec5fceecb78297d1baa646afb14958fbb2b69a42e28e1afb85d93f7dabd7b2fa6b81304490664693b463d79679f2c8957ab8765248663e9fdd65fbc3e1fe453eca52879d72fe7680a173abd9f21330be23c019f19c99e7a7dbea9b9bbf9375937c0d9b1aca1fc7fd740cbb4b20edf9fc90b9935f1b1e1894e308d2c5b831c94641ef251ae245ce9fb7f5eb1e4a8539ed871b2a909b3546643d0c9d5f7a4ffc38a45dfa223714ae8b814d6d78c09949cdea3ebdf205b46426587ddc083647a5ed59e7e0a33ab7853ebd43af7040adf815803a12b453d282ef7578f37443c0135a6e61c7cf337e17f2e423cfc05334c831fb680d8f98432661e924aa69ad5f26a7868e9ce5185527e841592732f024cc747dfc06b83c66b13ceaf69b2b83b10aced4f6259bdd106f3ff1da53d88a02d5c1f6aee60ed44723bd4b6b5c0b24e6174bd480298bcbb24b2d7b4e64713043ac59a3e7fe754a0ac601bd39c71b04c058e4a0c56bf32319a294feaa4478401991bcde2242e68a15476b31a582ced4f0f3330a5558c6706ec349819e709ad90f6615b8e5065a0caf7a12ed15bf8bb7fbf2514557bf5b84783de10af71770cf66ece7b2209825def86bffa27bfd6706afc763afce54daa856061331f9b648ecf85844dec7e59180b172517e45c56a45b85dbc8a72630449701e292dd4de5909312621ec0c3d61c18359a1457e51598fa63c16ad35b6ff43b8946947631876bb23ba9969e460fec63f5729d67c42fba21a3fcc34c5142f60b7d4c70636b6243f755e599a308ff019eb3630e21580b99456f1e7d05d56696162540d821624fa3f08e2a509283829cd6b8e6252381b3e836ea32888525c4fa28788f4d2e733a0bf380e3b6accd59569cee94692090886e7406a95f1201751bc1a0a81563c6b2ed3493e5157a1931b1d429107287303ea9343fdae19eef3f6495d8dcb8834925963d429e7bbad5df7fd912f131eff1b5fbe75dfddb1576efaf662dc7cbff486d35043e1893e39ce6001df48e0fc21ce09097810a3f95959744fc0a2794357006d4cde636d98b061ca9118877db5365674be94f1152cdda254ea1f340edd671a27e3f7e80762020c30b689f135c538012ee6ac43728e28ee3b2e818b965a8cfc808c8ff2b4ddd6f483bbf79f29c9d120623f11b531b82f870161dfa60425a179ee9399c4ff3a7f427991d359ce57ed57cc7bc91fdeda216d65c00ff147bec1c20e7e248794d901e980601aecf1a47039b549a0cf91534e3ad9595966d81882ffafa9f0bb739dceb7344d1794102356fe043366ad05a313750b776731a68e5b461094120e3721b8557a15ad1c9071a8b11c581c05ce8b32c0a306c49ace595912c510d85e6c08bb10e1233912e6689f304edc26786d15676e3d7aa765341ff8eebf52dfc2ace585fa510d6c598d5cb34a75e8aa82e47b73c0454c57a0a5ff987c596f668b3ae1b18c5e0b05664d61fef06e6e1d8f008834b43c11ab248c1969bab6e113e2740800c14288be66badcd2b0b60f9150595b9ba5dc08457a81d227c3739eeab8f00fee442f1bb3b5563e2f4bc9b720be29116cf563954e9bc196c12a4459861aeb63db89de8622b139e9e787b009240c5becdb4f4cce89314beee8b040378179ac93dbc99fe8dbe788c262533c9218b2cf850d9f2f8878bdd2aaf565fa76fffaa2b664df52361f8d0836e0e21014821297cfffcec63f4e4eccc0beccff9285f49c3a4bdf771e8af06faa1ff08b59fa23ac93b3f7e34cb339e9747d185bb7a95246a86cbebbd16ad165deefec02748e51faabd1624915e40a284414852bb691573e7fb1724336559d1349a587b7fe10e6615e0d58c5936426bfdc5d79b127a9bb05a775558f4dc55194e61a4cbf70379a540dce017e25a1e455fc34618c07347107cbeeff44638e1af82f4fc6e87a7e465261d017b1ff162bf9574309c07c7aa65ce28ca8098742d35641ddd72c904a420f1f5162b06544524a6a44a0e15f77139b1b08d1033cecba9cfce9d79f8dd273bcc44884255f8dae71522678b0b21903c94e2812583678506bb125897f7535dc43f7ec84c4a2a730c858544e1b19fadaaa61130ddaa32bb1f104374f3a456f97f11329d507e93e18a6c5ac09429c01f8632efd9bbef5f457baa715e3aa36fa0be4e65b684d358224b5adcba2fc768b4ee5d129d64a75ba7211d019fced654c6bb161f04ea7e55b5e9eda41ceb072a0233c72b2947b5ee852726e2914bd75604d57b0b1301a0da1065280e646098bb6ceff6205879f34fe02213d89939ef8b6f53db63c2af1918cdae6cd5c0c6baf096bfc4168ffba2fdd7d96d9de2a2ee0a0f4730793cd66e9d9a84b600e6bcd684363ee679c4adbe8815f7a8ae72d15a42b7fd849a0a868828b63add3fdeca3bb25d677e1087a48e20e6fcb5012fe0bc89b1d7d8e4c666516f80aaab8d3bbea1bdbb9bda9084434ed90eae685274d5ad4c87addb21211d3d49ddf2b3c430be8a069f1ee9911057474605081f380b7a852db243f1582159cadff479af544808227b401c7cbaa6fe603a35323427c94f6dea1c1856b3dae9af2b8e5fffe5a9e29d71b3a00f642edfd3c69ff1fe1d238c071d7a031b80be166572dd476422627b5c6b65e67cca8464b77c81013a8756d6731503b10a30048364193bbce873f7949160dc7c703dbafdee2f5026ce857a69e62c6b445ea6df36a2b1be957e9610def15136ff848450cbd07e3e6dc09999181148f0fb6a215606d66fe2edf6da44d1c4a0c1a3be36a6ee79f614ead3962d6daa5333ec3fac5f1bef8d25d15434f8ad80a145b3eb20d71fa80718802c6771da5e3a90ab331a5c9e8df61e8e416590a1df51fb9dbc32da477013cf697b733d5c08eb9c0147f76ae6611bee0275484c0aafa064771cff661a340a285217a9f42194d632631a79d1d452658d33bed35c014ec7b7ee04fb02f1f7ab89a261926088a49270eb4e2be0abcf279581a59c60b2c58ead3ed0ffe8a69f516293112cb9b105711aaf58b3cff470bcd3df0fc0b87dc3c1685e9aea47404414f3bcdbf013073833eb17b681979b6e042d039b2de8bf624a881851d5a11a258262707e234936d66a3d84537b98ffc2b93dab479e0fd1bc61aed04e6e020c203737e9f8ccc82780bb9f68553493ed4dc4d7b43d8fbfce21bf70cf1a9e3d91ccd2958ee62e33bb7dac753485ef1591e3d516da237848a293e14516ae9a5b0e1d05306330e4e5d72e85019cc8e5ee062d67a6b8ab3f619dca717d0a4b1892a8f3de6e2eb15772428d63cb9b3d1fa4eb0993aa31242870f581194f99c95beced982e1da29681c1c64a04177c5e83d581adc328aade2ecb61d15bfbfe3c33d84c24aebf857563584e4f1294ea649e6fe6f465ffe5ae591fb6a0286c1890730bf2a79169377e54d1ce91168d4fd585f0cdad00cb74880ec169a8110529f2ded627645804530ca8c4d59742298afdf93c0bbacf8f38afefd4729f3eab59705d933946226a7defbc83279fb3548fa68f0063fd7812be9aa418e5be0bda1c150459b6ee5524e85d04949ed770a02f9683beef3d5c908b9ee63f8ca92bc08444900511522fcd77caad4157957d7925866f0f3bd87fb95d18de02669035054f4a976811d6db0ba207aff3009d3986486e287046b76b8c56630b1b3c405c1193b2b5a785b6c222bf722c7a4495573d89fb1f041b1d113367fcb9854f670f91e76f001e86142f7efe71a79ed5a538ba1486cf14f4391fa9a3cf107452b2b3faacc953236be7244f5f981310e6337e70118aa95a0dbf018898b7944f095955653976732c0f7ce7fc1e9b1e659cc17554566fcab06878051131b68cdda653d5684b8cdbe7252765e8b03094066531749b7ab43c88ea0f99a86334661473296acd1fdcb4a29f1fdf816f105b788a5dfbd265cd76d8700b707e7c67abdf50f007a2187bd78e83998623ad7c896354fd278f8f39a0c67cfd32e7aa7e5cf67f3554b242514946b2923d87f26fc17ee680c2f1a02a079717460faa56e9a045ce4863363d952ee7ac28e15e7d70452bf818f519c887cdbb524c7cc592bb6486301e33f0ecfc6a870949673f991fa8367bce122da82a27dfb633e13a0fd8124e167ba398c5e0ddbc144abf2fbe5603bf1d190399e51e36962f9133cc6e9150230275e303cd0c85b0493802b3b1f3c40cf4fe9d6d75188f784fb02944fff6631f319c1359b84987794a18c9f6b0e6203a35e4570851325c26f7b25b197c8083a3ab7f9e86ebe7d1d5fdabb63b0e1c8be259d389ff63d2d482c62213df12bb87c28d1e4e0f841ad7e5dcfca9b4f8c33fb7ade29f96b962847007ab3396c2d731a7dda6949f285dd12ae462a0cdb4f4ec39a295c092499e6dae5c16797e34db139daede66a654694a5354df874f8d567abfb815f78b586cedb8fb5061e8813843864982bc543348cd9dd859cd9d05159f32650f9b61df2adc5c34b6e4418417606512604b71aed2c55a3a5a8dd3a31b89b081f37a176f645b71ce5b5e86f347ae86f3b6ebbcf01bb86a97339d394bd687ae3ccbc256b70e2e572b151a0b8b634c78aa91471ae6dbedf78b527fea481468eff58b6ff49034e52cb0a8ceb518dfef88338fa3618dd3ddadb5f166cb08f7debef388a902034c4fb5ee11bce787f54d99b31a33f7b51f78cf32cb669e438a4025f7fcad1d52903a861e578e92f7640023a3b48bd7efd0bc799013b90c1014ed62c37124b9d18641ef72df49c0f53adfe7716a2269d73877b9b70621914dc8f21ba11029d67ae447f07451e2a94f51604c4203afa2f22dce75ed8278a60cbf279f7bf6be3369b5afdc2e55e594b9b9d0c74389e311cb0c645cf5c19f470a8bd545632365aaa25feb8af850406f79566d80eeaf7b12a84d9f9567c59afa2a6e9552d4f2a8696676e65f3a7c4e979de2e3b5192c614cc21aff5021c1bedceb807569d044db40577d5230f659cc7302b9d023adfbb95a691d9c062a13a014e1bac0cc88fdd02ec11b0b1e712da2aa9caf864bceba0088a22a158d058403ddd33d0efbe7eba4e4367218547876589e852412cad943797325dd99192a5f54fc632af1a9d918f8172436ab78c75e3f68f6dc3ba1eb3d351d9744b25f5d329921356a01ce5ce70bee69daa27d0ad30d1d70153756821f5d5ef0d5db5d91c2fefcec23d902dcd28a3e2c87aaf56be26634e57d85663d0c3602ab469d58e4b1354cfab21bc157e56ead0f3a2c7b3d3d4216db5bd92785f894370faeb2c2482acc75145b53bd9a60bab5a46941f9924973978ea12746e2e7dc400f9c0e451c8080714227c14ef9a6260edb5614ce1e81cd7f52ea77b3e86c7858502d91c8db7e186b939c9b111588f6b76f657d8c6f6baae15a92735427a32ace932613de400f442aa79516ba9a56bcc545eee4aeb059a8091b61e25f19298947680d966fb2d58304e977e2201774692a0072c9f0c5a1fa4883e022f699f530b3210883f4aa99a7a24e4614dba1543e013713a550b5efb29e3b6484e895550de813d0d784ddbc41e2055bac8d76f45f9378b09d41966b5a72797ef99a0bd85a7d6f5588e491ea5f4c329d866b33a0a7711bfdcd200b747366334ea72ff8c640f012e79faef1cbe046bddfc7af6b03a63ac9487c136a9850b9d31159694f20700e5e6fdc45ea53e98681d2457d374ac6f60de99bf33ef45d3aee527caa4878313da30780b38a0044ad8abdf7637fed81495a3cfa4a92e2705721978fa29b94fef15dc3daef957fc9e17aadf434a59432b2e6c7823f59aabb31f1038c70a45b9df99ed8c86bc6bef122f4a72ab1b64d3cd46e5973757d194028aabfaf0f3f7d896e653f045f8f16b30a876e77ee6066e7ed79595222f2b50ceac2d5283de79f07a99188005c705a29f93cf446c688752dfbb05bfd65ff9159a2d3860603f659431c9374c10283a15177dd5ca96bacb1528bbf8eb7c169a3010e39fd92717e39bace8e7f635b7de9256e78f2cc982586065ffcb3200d74335a7b45ab8755bd1082cf6d6d6605b7925b58b94c2b45cdcc070e9f7cbf92c4d03e977df3c98955ad47f60c6690986ea25501f012f2003330fb6f95baef93f662e6a6f6d700eb7c00298a33ba41a278208fb35765eeffb812152364942da72f0f4bbd9546246f15a4f88fc7e2974e6be2a11c1cdfb2b785ddda951b582b346e0200d1bd67829411796050ae6ed20d9ff5b9f4e4f7ccad712e1513e2d5f5aae0522832e710334e2235848d7a5df865aa34403257798e584d589edb5b395b649f4c40d4d1c82af4daa650a908bb8b7179928e10669bd3a00bb72a576cc3671f9091e3762b03ab32e4effd7bae619fe3894a26138699107719aab544b19043c59c4494ee440f7c3ed3e03b84a78077cbf717777a894a19689fdd3a29247ac0418b7a3043e41ade7dd9e4b09462fbb2730250d8dec392c8b0b0328ab6e90ff6dbf0b5275da841b9cd487cccea2e6e1ddfed18c375ed7434c0a6ce32271dfe10326e8c82efe61c94f169518c710d9528a06d9d60abc8d87486e4596f7ae1f1a195a67836f9ea52043d1e8823e65e33aecf1735e8fc3fac7d3af1e1c395edfc5c6ef106889322c5530c92b74df09cb6f1e498ec2a767443591f164e1550b6793b895a99da003c0cbef0ac3403623df9ab88033d4a36894c1f7f000e2adba328b945b36e0466b3fcbc78ae0c1bfbb32ac9896c9c068ec755253e8f6e5627ce6f4fa0edaf4306c85aef13cfb0acf5bcb81f80cacba10bbb8979e1e75d5355b2eb5754b6625fcc9a193e4534f84ee961e4e1492d4a6edf3d477435c7959b1054ede28589912db83fa34f155a8ab4556a12b3f4205a7e6dc341a769cc95efbd076bcc2f3e0174f7f61079ba54ad593ac0f2499ba58d34bf2b0f9653773e932612dce24d9c4027631b16b4d73567ca2dfef4333c38e7af96ae1719e232c8ef1dbb6fd315aa32b0d15d654722c1dcc38230d6cc914a3d7fa05ef8171681659dcaa2417b456f04a191e2f590c2720aa03f09dc24b684e4e886535eca61a11f0b7d4a7044d7ac57d953260bc6d243232bcd54367586046a1def6ba79291e1c4b22a0503bdd3ae976bd45b383c514460f9714270614d6be8adae5905f0b2614d59af30d6bc074cfefba4171e1d336182af4cbb10dffba118a1d3fbc36d7e19576b38e3e2a3bfbf40f80d0893e97329063bcc519eca36315a2574d8ade90c20102fc8be5fee2f851852274dc9e41d208ba2e11958b2cb4aa3e8d73b692a4c600a7aa3fc9f8996ff4ed0ffbfe1a3381fad8e5149a8398ee45a94fe0f765aecfbb4ccf99aa7d453a62497167c1f457bd2cb0a984044bacf55ee8ba421e89063db344e972d99ce070c29d0384a151078ebdea189333a83b16b098321c34c607a0f47d7815183441d59ae527fdac3d60e5d229d84f7138dd1aba20015d175551527d004fec5271205d7d37bd66c957798155f1267daf6a50b73f325545e53f1673c58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
