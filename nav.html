<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5653360aa83191df4fb086e88c87e3c3d61f8e582bb2609b1ebc1c3d4a615c88d42d11757720472987c2e65f21cd4720c1f170f04675451f5cf46916808fbf06e7a998acea46baee93c093a827ec310f7b87bf93f43d009b11a9c8ef8a51f5661c0d5155d739c7e408819a6f2953ca6192a3710481f66d7548d1d6664b54c8e74ccf2c1fa4d18ff6b011e52fe80d7a027a238658c8539dd61d60e39ff6249e8891d5d8a5579bcf25f8bb9f1b045fbffd5fbf3775ffd803dcbc1f3ce00736f56a7263e20f7b0ad724d164930445e6f7d51b405b887a6a11873c13afbd84b6db8682bddd45acc910bc0c4d712c5f10442193442249b8ef8c7bacb73ae94ef743ef3485c36b6e8053432c3041943aa859602efe9c731a310f18683850ea1be0501fbd71b10faf9b257a54d753cb77b87292fcf295bbcf449f7cf10079c9f69f2fce6c47febcb3d5acd3b21df4bbfc60e5c10d14977d501752837c9fadca9fd3255e9df7d1e0dcad54432d79710df410e2ff88dfb7d91c024d41a3f27fc9ae80ed668c4edd4e4f11e8bfe13af6a53e6a93a9ef9d661338a6404f28d1685da34fc0ae2277294773ce24319502075cee816cbf1a08eb63eb47b3d463984cbda94d17d9b8099f354f8b2e8ffc78b678e8a60fb2e2467900e6355da05bbe503ad342527bbaa0c9bbd29140fef6a214e70104b084f6efebcfb249842ff5ee0799bbe6474d1cfd3e0bf6d63920ae360f16254658dd9743088077eea06944808cf3c37b6ff771a93f80b208a9cb7808d6f29c058dc1c0be9014ec878906fa66b5317f7b84e683f8ce4991cdd2af0154f8b8103dfaf73149d40f3377ccd2ba00685c460b0a3ccc83ec7d73aaf9471365ee9cb46483736c57c66fafe6470f822fae71700ad204f45d8e10e3a7b2ea7e5cb7c46a456e5952cc0b7dae068c3756868ae3ae1bb576db9b68b0311932a23344b686daf565fe803fd4058d1f0d5c006fdf8e8a1fc1ee0a55e6f78554774d334afea7cde0d39bb11d121ac24b1c24933602fad1fa3f2c09060bb1ce2caa172930efdd9b10871cd857e88647e297d4d2aca5723f6aa577f98f98536bd8947c1695a4bd89c4ff83571eee64dae71b799e826569b5e0cf5e0d5c73b21d51357afcb53bc453603b8edada6024a646dab2d14d373154bda6be02efa230db47ccd2ddeb1a5932f3a7411322023572a22faecf8d6762b524deb14e7f0da1e3ce189f55fd6adc820434ad8204224862db8a9ae8dc54be0a83e20ef9c3cb92078c0aad042232dd56544dbbd45c8d70bcbf1fe42bd51cba736d17816c07b671ae16e8c5452ab9db2f998f11ed1fcc80b415b77f67a3c1b43b3041f143e09d13c70a7502f43cfc9b93e2a5a02eb174a6fd0a6f3e24691ff7dbd85dcad302786e4ae6ee3d0934bf4638b046364b688daf70b56920c2b5f30cbb3fca031815910bf8276a7f304c646ed6d93ef1d2db5e36db53c713bf17a6bf53b97a89acbafbb4ba13e47455546845d7f973d881d6606dc71aa7fd1f576aa8b8e82e3f3fd3193eaad0fcc3a0c4273ab82b13c4cb789222efa31630ed5729d7d6a342aaa4cb6a200cbb3dc42fbda191971463936a274ea7d9cfd7ae3ebf13d346539abb687c723dfa7a84e284880d5e55898e237b65efb5d08e63958a94523677e37119b611f4a79e2517aa4749a88a8deeae3b74bc15fbc45322ea58c2e81e940986cba1eb0199ca13bc62df789c446735ef60100997f21c8b9735162d8b4086b4bc78f1373206003cf031a4cfdf9a65776d47946cb76b8fd6fd03551a7ebd5979e3fce225b46d96e7e655e129e299f0ade2b1e46cb65703c7ad31473e2fdb2381a531a7148adc4e225301b99a98081e6c27de5f7dffb7261c5e4a9b478892cf87c0804d16c0707a57b20d6c0000770963056de8db04d0959d940fced2191a0248c88eecb0c63781c11587e789997a4f33f911a779c86d1c971e29a87d08975fa06889b8e621bf2561c657f2cd0b93d45185b5c1d6ed5f2f1d70767476ee936b62c168b521e11f7af641ddf0821c37d3cbcd203b8701604582e6b973ebfc33d6094a0a09d120ac94fcfb4bf3f57de429bbc143397dc6862a01a5b6a9f2de4abf998d445e2ccf85b04e5c6fbe219417dbf40d980a4eeb5493cd772aaf230c34cf508449e32560d05cb49822545fd15a359197f849ca8c4e9f814b2e22614ce284678c2232d6f985a2e18e220e60c964f8ed9720100e8c7b93cc82da95ec311a4adbf79c8092c5469f23d550233eaee8730f46f5e5950d6e8e8f45cc5a1a81b2e16a9f2dfa2ec25db8a43808bc11b280f696d0d33da744710cb09db779360e54dd264e594c66c4f97a03805bff71e6684b939308c1b444525c972cd202afd8da6a3eb1a145e7fb917363b5bfd4906a0757cc8f485f9187f85cbc334d946a09c568298af9c11a4549cf275e36334885f1127578d9e2855a1304d43982a4813f3c0d142f42e176b15c96dee9e83187088fd2676b12e69adecb8f0c3f2df84fb4e35b799951cd77ef298489c995b58a33f1bc8b4f33a66c97975125a6cd31f396ab51c9503d03804059ba0f12b92bea72effd9db9316045013336546bb089656c64ba64aaa353c60db8eae0d2428aaaef210dcfda91d106097601ca9e3ca8d77e6e54f2237c24f30c024644bac7365b1155eaed3d5987915084de631aa328b0579b7f4abe80fb69ba807ee5af47328e3f34912d55273330fe37ab2ed0331cee91772ba29ca24b347ad3e62591e5231f7ebc86af94c6add519f74e618d22a0f7c357428975385528eb46a244c5b075475d383043f3008fed1c1ae53a047cde7895e47ea9e2f2c7b8b7c156a8859fafc98184550e469b0d3a942e9bc5ace5577af541363f257600b4a7e2dfb692314ec56ec9498bd1428fedbaa1b7e5a073640dfa56e2bf86e71f8051d9d4beb665343cbc5b1d79750dfc56b55dae2223951d313ef2ead0270f319d28bfd765f1c0125cf00de24b4dcd12210dae25d1a3be1798d449613ab2e8181f8ac959fce3aad5cf42cc36cb5d5c33046c383d61bb246fc9d25915b07d8b62a66f5bb9c975e606623a7d89957e11a12aa237d91fc05ee097fbc25edf06f593aedef76ff17183b4f7d8884fcb1ccba9f0b1599e1cad39e437deccdbcb0e94b297fd9fac41fa89304ba4f4e9f3a2feb08bd7f25e881c96d22513f55816a29cd66d8ce5b649990aa9869b2fb0d47dd8c60c71144a40522e539e2be5a6a3bb97641d32e726dd3262d2da026ad5be6f8a2a6c050b25aa32576c6b150251a08e2c325abccaf5375beed686f5184b2daae577aebd2264361cecaaddf2b8af8fb356926522645b95b25bb004168604fb8c6e5a9b0ff674bfd616559995725b4355d26c8dcf4162c6a55b3629f89893c3aea13f0548178bcb6c74c7c1adced83614876309c83554244627a1bae3844b107bb7d044e03aff37874efc203bfefb1c18826c22047dfb1428084c10942f3fdf9c7aeb2d17a8b926b43b493670cb7dc75a064de760262ebb1a51e07ad8ed23a2738126974fde92975bd0017f19a41f94f94ea0adad805a2cb40ee0d322c4d19f3b67a4ab5e728077ad4c5f81c9022570c828b19063c11f5dc90e69c637e3a431f1504190bc8c775daeccbc5fcc750000d4c0074e015724f3afe0f587e94850e32c168fad82b658e10ef367ae8451acb894e3dbe3f2d58267d0a01fdec72c871a03fba22042f8c04704b7921b07970ca076f3f68b7c0d540a0008a4394553a63b609b467d094f2e80b1e4f0f69a6a1254bac3f5fee2173e2b032bdd91d592ce5b1ee0cbc04f8c25ff7a522f82fd7195fb2ec104ecf49f9b89bb7131fee27bc39be8823919ac649b5c58019b2d36fba7a89acfa4a426addf75cde085dae7ddb55250afa2f4f55b846f88fee9fd25214c2d9af8a444aaefe96d185f47614e68b82167ef95884204997e2d58aa17365fd0625227c7eeb2d6b6ceecf8c0c9e74a4ddd8066a57a7447b1a789b19463f03f92426bf18c8fd4a413a2dd41ca92f31c58400edb61a42c639322dec343040e499374561a2e9d3011f9b352c98cc05435c65bbc3a10c7d4d69e1e6163bf2ec120f70a2c1f018a8f60d7b28764975b30f7af9b33a81314bdfdd0b12d64929986904b1bdff94b3f042773bcfb17714a2f89632b62c0ca2bef21a39dacb5c5d4566136e847e96ff4da5151e987fa3d7367871e2be82f19f537f92819892c35904660dd2e042143c6ed1fbd4e0be611e6c59b77b0223a2f710621bcdd9bfa4e92f88b3ac9ff6d69959d24a447df0eb5ef6b66a502e3163c7720e4291a3f63355df10abb8e38ee756ece809cd268b8e64f9b6aaf9dbd61e1bfe864151ad4e2ca3a713d7600fe83e70ce43647c50d7ac50ba1cfe096bd9c67381593837efcceed8c809dbbfccb75fe631e2afd333de591193e15123f6f946f61ca0830c4da5a08b0a8ea3271472bb65c9d36fb9a9fb17dd044e309843be0c90ffa0ca5e501418e8a82efbdb9a798459e69520d4ee306ffb1cb0190d6a16e0582bc715a8b7253e8bc7b48d3b4c1d2424afae548c89d74d3a5ce6f683419a4c13efa6356719d546f71eaa32b22b94b03b5abafec79347897dfe7e116b5ed39e99056548079f0f616d316260aa3a7bbc54ff2cd4757aed73f521ee385d2cc398973bca546b06a9dabf688f6c935957947166ca63424a79c47144e81b3d4272839c0f4a43aee3db0c1bb01291d1d2f41c94f501dde9c260c28b9a91738a4efba43f7f17d16b74d6d2fc9fd70f6b921db8f8e96abc5dea664ae89453322e03ecc7cd7366f718b5ba1061e037b9ec09a39eaba66df5c0b6c5926166376068982f3da3f80f7c086e800f612ef22e3780ccbdd622127ea65555ff2ee82ca1d4c5777de1d735d127bcaf474cf71c07f35aed5972fa8792e962629ea370700ab62f2e5430c7c2d9e3c5933598243d8b4549c8c608ff960d39855f0913249095a15d8366ccbc3f596efc1aa4fa3dcf6e46b83baa339ebd21dd92021356318d99fc39fb1a1886a5107df506483db710660fc3dac2d940ad3a391a46fc44fd42dda64f353d64e19db5da0f345f278ba757ca3707eccd40080671b9d391a0259c32154794a079271c34d79fd7d245d74048540451ef3c3f0e07f51da7adfd13f3c99ea72db742504a4e0675b7968a3396f66bb9eaa66605b2bac3d1e227f8d08009dc3315a609fcef76159d25662d11766e0d6c9e8cdc67aad2b7587e861b6b21a9d7a9b7488fd09e38f518c56193c919b416dc1596a99f67fb0b30ba0bfc245a5f784f516d331da038fae4486a82217879738017bb3d563780ff91e2d11f6650486846d97afec82e7c1085aa03dfe9ca35198c8ea02efc834c0c6e260d3744a73427b2779b61b2f4bb6bcba934ab032ac16c24e3b4a85c7e699ff9ef4290fdad7f20984eca3e543461ead77e7777177195c52e2b44c72bb1817a89fc826c8ad459f6a14569ed2eec42ec44a00ff133d78aac8f40dc6794839e9dc48db0835041d62d79554ec8363208710e71d533cac8bf317426dd8976bf71e229110353488d7f3cc4ee8d4119252bec19ef41d2296eca9d9a458a4a665fe2cc417c1d5d1c640c05161aa12f99c15a25ecbb8748c4003a2d355569a6e4bbcc63e0bce7eda8b4329d2145cafad67836435a581c442af720d7e55fa71d460d2988b42aabba5ebe95e12089c7f5eeac355c8f3348f94b18e60ca10ec2aa1b864dafd0ad9cdef81d4bb2d61be602c026d705ece722f2fc7dcc218d0313319c184db9d1c7f339016a92bab4e9caf72425eccb73d0d5f183c635006df76bf14d46f716da10c4a8de6eb03dc8d8c7890113f50db3e0696cb630c5da69074fc68ca341be8202043d7d5c2fd88a352bc2aa4f9264d1f4e2c5d69cff2f5659194b7d63404c73a9779f38a104efb8788aab53f0ddcef1a59f58bc12e095e8efc6c213e0c3ba6721ff0bb1f48552e9f861d772489198ce213d60d1b5cd606266f62a737255721f3b5407b541c01958be21737ee040ade9deb32f0d133196fe844ca7f6d8dc32490cac1319081e875feaa9ee345740dde8747cf28706223969312bff3412aa67fe11d8b2bfc62835becd97b5dd227abee2bd256cafc433757434c9881c3a082b83d6001295434c41f06b5b075185c6aff8b0d2bc7405891f5ab8c6c0c7ec710aa1ea2d34375a935f19eb4ba9ba9ac3c96f1b3f956f9346ca086150148d70c3e53524529d55d4b1f42cfff285193a3239e5a317b180ed82c57bf3c429460c5e87ee159ad39ac3d00247064904b59cad3ae7a20dbb4a11d227ca587286a0ac6b82b4223cac1468b0b7c0bb2cfc31bb296f9eeb43f829dc3f0a3cf5dcdf2c7c27cbc246a5f03bacaa520cca56a93acc4baefd45dee403d827d8598929882a5093c7cc63c8f7d7d57eb1f5ba27f795486667d69fa6ddfbdedccb7557e807f07de0c7bf4f3b7b03c81a330cf8251a281d32f959b26ffa30dd80ac36d8205149150ceff48ad0f269c6a9e4091852a6dbe0ff8e1d3b3491148eb67f4be5258c75b0c4c46be1aa0c68566e33774990cab22e3f043336169fca228f799622e03163d77f54fe8c85e8313cb721bee16c7f6fc091faa6c5b970defa90fac87cb80191aac6a06920b184f87618b44c19eabe2d496a44ab2be11c2674d92fe617a3915fe48df43428e5bba2d7b10ee251f33e3c0235a840c371697b954e7450ab8f5bee4f49f95597b2425978ea89419f7cf6a8b5a88b8384d38f5af39e3865263b7561370776b9b448391d7ed0b681d80e974e53e1d6cd23573bcd5cd95ed00befbdb6e498f24b6df804fc988746feadbfae6d5d702284fc48823efc89f9e90ae8c54428082a2ad0852bd000759735f60cc2273c9143bc58f0994de89435afbc80630d3d850cfdacdce5c16fe4f385bb15088d2904d56da58a08ad102afc82e4fced7934c6004433a6be480fa3ee6a53fe0ebd3386c599c6b9569a850abde5fe9f24a726cb4d2f591e8e59fb20c74e0a7629d05fe4d8dc36baef79269d1eaa4440937e8e2fecc54a596de1c19ceb70b3e2e01ec59797421b6dd451ac3a4e42689bb9bf45183c6f88a3c0f2fa5f8dae0b67ac00effc3546423c13bd4ded7798c709df47fef1cd369555ef8dc8846d4a93a08733a0286e0b20883468d60b955860cf4a233dd370fb85059169da9524f84da127745639bde4a936c9541d8c9d65211cb1979318ac7ae21b7c3a5777fc975258b628129cbbde5ba167fde2675a7d621b45c05f0d682a8b0736e17ea8804d776f2bc193584ea945aa01bdad7ce6688cd6cf5cbd5fcbc9c04ba82f77f728ffcacba68e442f6cfee35baa63ff9313b0dbfa503375cd049ca01a3b86071bc59ba1bb4f81a4db36b894294da2942fcdbb44e4f325fb144bf194382ee6b901a4c4764853e699542b4752420db1defc465758a591436a12a0e7975d8c42baa8ec2d233c4c075d53ad3e8dee487de8d86c0eff53147cede98cea71b80af1aeff5fdda92c92457e722ed7ac29ab90b88112f79c6f4ccac5e964760a4026bf53ad279f770bcdf9b8379a505fedf93b24340d799c6d5cf04c721f7d93d08a841c6558fb949423d69c83acac44a49dc04310bbb16809a4bceeb5723e8fd401295ab1b8c49d38638d557230f9c626e17f5251a83302a39f7d77ad9eeb97f4f46c164b2c05fe1cc49ef7b5cbb31f75c6a60e1319448ae066a700e64e44f2a4011f84e8dc353335da8797da9d103e56f36d5437bbc8b88a9c74be7d9fca3284b1a855992c73cb2257cd246b1bdf346a91121088839ac90649e8f1fa7b58b0dda50e301a0e33cef9ea1495fe13359031505f84e0a6905cdb010dc3f39e869b3a5036a8c60d89a9818e6e72c0f3764d05b928b28baafd8c87e8754586adc4dd6ab9096ba3589207c72051ea98ead310d97bfe0481c992d96c4d3996aaaf587efb8dd59d1689634e8d189fb5dc46e59322efac1991528b4267982208fe811cebc596155818338c19c6a434b92971b81e8d45adb7c27e1e037ee349333ad99ae4e53a051091df30dfe889f5d7ae20e6bae623c1581a652b77e471dd266202a7dfda5320fb3dacf6f6edcc7571a1a23169c178fdbab15fdfdee5a8f4090816a51f009487e2013f935f0d7ecf36ec5d3cb9860f47fb2d2690da543db4ac63f8c73c6f20c8f3fad513a3166e38b9dcfcccd0172713b115894707810bbb4e9811f9f47dd04c5d46cf744682713863ae3f2759b6f6215314ea147ae5ea538dbfd0c9ecf6f2ddfb8c97bd01ca469ad308d4b3748429792d0f0f59d6eecdeb560804a97697a172175b108e7e0168d4a3857adf6af642cd680d4eca5030ca44ad1cc74268498a4ab76b0ac386f429a22b351000f33c2ec1b72e20c75e08a13b7d06e9c9cc20fb479b7780fb5ee774abd300c7a4cad25ab7344fee962b2d47d461dd4a842ff39d2aadc563e6bb188408e49c0fa4ae1bd68d07181601cab70c52d000e096154963bde6e125f8b7cfcfbd4958ec7c24577222c91914ca4857d8b3b4b15b6a13242e66b3a6387f8b3acd951c13ff87e76b2e9fb58d2f315841dc616311860c45e98a475da22aa76b554129e4d9a290d18bf15f0eead3786b5a66be9372271d45f81300e83d7e7fe6bc3bc812fbd87692f1dba621f0dc59bd3825873698452f2131267593cef1e8437686e73cba4d86c9c677232bbef757d62ea73ccb6fd44a14b57a9639b5ee753ac26be15f69ab8bdd5618e6d6f9b4088e86707c9bad0ddcf0b82aa57ff2cc37af74ab75eba7984fabdf9a81cf4f470fc514c4602d96379ecd105db020212be2fce87f3679a5d4e20a112c3b932415b280c30106eee6761e2e791ab1aa5b43f075eeb9fb4d86b8b707d50bf64683ddb2fa4da1eb313d334d9ab1e39401b9c873937aff5b3e614b56b83c39414daadc27849922a014c9584b6e27aa58b0963fcbfb3ec9c47deea0f2b7adb8ae3bd23b8150dce14a5aae6a327dc169d7ded5d9c3d50614ac1d22b12eac0be1d0c67b986abf2ca29ba89de1cf326dc5853ad7cbfaac0ae29c2a8a0aa9438e2b15bee8a0b2e3b13615d4e7b0be8acdb400a62d01c96159737b0c43287415723bee2df25dc4ef3e7875e1c0d93eb02533fc32d73a1b2a725e4b71b93338944865bc558a5b8ccfad20a7fcb48baf513f33636f18528a8399873a244dfd9fb7eb19fbd1395a233ba16469288a0a23c23732b76fdad12243690666b29e3a569fa272b49e98ca298afde3631d177ecafc85de7f07faa1913e04557909de4a6f469e3d1fbb048d88220b110d2bcdd7b819c6d309aa79f289bca04711d3e74e1e0df86df655f3e679d34174715f11ff383564a91831763ffe6798280b12e707a92c8d5906943984cd9e0bbd4b5276a76dea4a079c1f22e275f52dff1d7d5cd4d1107cd5e1111704886fbbad5917a5a71d9a321b38ca11f6e382d458347c54606cf034cac34d218438c8f88a35634e4e61e6cf1c01dc5273efcd598d78d501a4ec65cd6e0d6224240bd1990e217e521d8a6ccab091582b31235453b1b64783e78e3379222391e7af73fda3364de6214ac6e61893f02622bf5a7431218b4a681df2eddf5356a379a5b997e69729adb44eda251f04a361bc2223fd02794a27feb1494545da864e2caeb0a85727ce402c853df1c7010f9b6a3db3c01b9fdc4dc916185c6135c5788df90ef40f3809841316b65b8b2c7506f94e7a7fcf95ad705ed26f4cebe0114bd0575a64e58a56166b335347969b17e7f3162bf3ec54533851487486f062d6116b6e1cd91c3b470242964420ef7cafe612783c112739a89078f62e8c267960827182b35368ee1b6f1fe183d6b758da4aa9a88d9c9df58f3fbc76d3ceda200181495e830a24d9b3441149eaf2f3d6dc7ce24adcc15ebd707f2703e84d89e36b73e53ffdd2ccc86943d48fc835347421d44fb0f90f1c7b03e73633a6aa9d28b5f37c1ac30db10200ad1ba8ae744a06288a25b8856a198447c3dc7272c362c77cdb5a3fb488fa66b38700be6f3459c90a69939c1c1299fcb1d6e5cc6c5693e9aa0c658e26eca2e7e47c48c075969406d61db6503509f3c1758fc02c2b7192304398098f2c996e32502ad9de9621eaac3d83be9ca8693098280348108f71cd195673fd9bb2a2ec8eb98ccfec8f1cb611e766d542a697c705eb978d4c630430874a1ab304a7e848f035335c7ee43cc10da76df53247e11daf7a8a49d6ec9dbbd08d05676f0093fd83f6b84bb44cd5c3f08215a5907590cf8e98e4f312e20039f0e0f80203297eeb9131a5d78826e9594fab4909b8490fe3f8bb482c7a4044b942eb3a32e5ccd9cfd2d87ff4341cd8db94acb0ecba7bd0c0561d1730ee4323bf8ec8f2860b7b727fc03f0d481f0248f3f4271be76773bb22ee0b4e47bf5239f4aaec556da5b6ac883018dc4014f5499b0fd02dffc0f4272bd80bf9e85e367e16a739bdba08696e22efc1d33f77bd746fdb683d1ebddb2e01544f48c4f56bb03ae386837f82db8d5a2ea133ae7519c7e7a01e953f17c29f66728fda5a86d869274733ed0c3828ff38c2ec6e38634ac756963bfddd5a774fb04bcaf6b21fabde99637b7749c090aa96850ea9cee8713bc5150028a4bf8697fc0ca9ba368b29ade8c6fe20fc5cf7bd037e60d4f7f34cbe93ea4ae91a1e2ea7d110e15e089d5a02132b0fd4800cb36a86caeee52b97cb611db961739b31c08de6a62f4df3a013490736b437c4c0b287e74e9384327ec14544b5edeae3b48f35fc30a01481208fa03ff2544a5366df0d15b664e2630a55e36dd5b03fc8dc27b31d19b8b2e2fc545cd126eee537a68fc0f9313946af6c63c3e2c4a7a7c961dd889557ff08856f834187923654dd472bc4fce139fa7cd4f1a4686abde2962b5e26a0494169a225d9ac5c8fa5b15d4d2f1a1648b61ce20545fb87e0b06391d5af0645e180ad5850157e97ddafb845b49ddf6a8842f5eb6c749554051d74c603fafe7d9f4ea98fb31c2f5f59c19e95bf3c24d1ec64f48d43322207ce98c0952aff1b47a01a569d57c428bc65c60663037d7fbe31670936245eb1cb566689559fb6d060c1674580ca09533d657200f731e02800ebd731010aac18993bd9c2a0ca78dd81a985e6751f0bde0988170c5405de84b9f59a4c8343e9df6608e74f51f870fc1acfae28852af452b483cd46fbc848755b7b98d70ef78d31bc5720879e8b8a67d692a880b3fb9c0149c5f5ad615b3f6472efa58c2a1d9174eb59a4e4376f040e296e90d0baeac639abafc3b4c099fa043a817b4060bd73a2ef731af715c1b8fb9242f9083638598f6dc0427bc3b1f9f0c8270572f387e20c1a1ecafc6cade3f20204cc5e0b47a342de1781c0f947d25cdb4e9cfea417da253c1b19f7dfe5b72819c77a083c5337b352f3d52c856c5f58a7351a8aac9b2637ab6ac421ef2691a4fc724b732bebd42a50fbeef6a41e8e4848a5e78915d2eb8fe159d6c547bf46667f9627bd132a42e06b2b09ad78a7e79837dcc36ba0f72d8a7f9caac336cd14be03efe72123037316231a12ca21102f19b1e273570d2ac564bb7881b13b4ac02486f4ab4c0ddc8a1f76c8f15c665c2f636dac20f688b17d977fda247f8b340807939fde29add155d9a5939c7a1277570de0ff6f43297ad484c2d6680d75840c28d2e3068c9eec4298e3ad2b1ce3f539316fee73dfea8fbe60ffc2d277887bba79d136fc8b8f11db4c929b5f4f904451876c24d9c3c05b414922d1c9fd0e1abb5597cd741ab483f1a2cc90fd402fef52ad33b20ffcfa89047bd0b06fd6b4ec5e7bc64e8b232d6e5120bc72a313decc22fa68b81302d4449fc6b2396c8c10e0721789b9018911947311fb8729199efde8cb87e79df88558cd24d0ebac78586194759bf0a55912a0a3d046e5c329b3523e2244d11adc62a5ada6668f74e2ffda20a004de070a7131dad207d6b5387b8c699269053849186eb0e21aaa4477f2a845bc6fb2f2bbfe0956ebbb11868b63d530a9659c7f6c61579dd1560c1124a870f7496142b3882136883489d0dc69b3171a3f634a5637a460cfe58174e1a70f7ef03e9e3f8881780c8bda35d903d47ce6ca5d598fa4137ed58f46e0ff5a9ae4f470b3584110719eeb5a5b0c080c14b9691daa578692dfbd9d790903381fe636bc8b7ba1f4b496f9ce1fc0898a4f264698901789588e804ff456fb37641f7c962be82315e8b49b61c85d2209db8b991daaef30baed8dbd72a42696120fc35591f7dc814febe277ff3781553b61a620e1d4e24f959d036b50709b434c8457b15494d019b194617ec5602bbe636ae5e08b281c5c3b1c92577a47c00490242ca2e0cc6d25573e6cbd1f0a99aec8472d5a12d1309c12a71f536d1a495a841d2185264a37fe53eebecce588a6354a06694f6e5bf69e1d4335b20884d43ad0e56bc88efa2f8222ac36b44705193e8fd46f898751ce403963603b0642aea6b06e9c40e833f1246c45dd18ac63c41038007e35c77724d29cf4b43cc4c56b8efc4f8110300e6fbe49c515f52492a4b3afeb2be377fa5bdd5164dbfddb68c934f8315d7c6a268ed407be78dc17098b1aa6a96a762fd047845f41ce1ff7c5fd330e9771e93e4de4a835d56405b87f78b0647e4d9b71b6d6ae30367524d7c9ad046ef03763668262e3508a45607958031cbf5302cda960d243b2ed0ba29f1d35753323af567a110396086650b30cffd6a2759bcccdcf8963bdbc521f31091bb845d41f2171ef9bc1d0c736c407cdfe7e67092d9e59a6caf5cf88397be8c606f6b3ad20a6f54a119d96fc5e8273501162af8f1021c1c75ee8a0c0e7566851008739d0be110ffbd628d3f900cb33a0ebad1742382faacd2c504d784b62796a896eedeffda392df8772b99c48b647d34859e5eddab6b64ee870557277b66d920b4b862e499ca4975afbe49ca95b977b3bff915648359fcddad5dc02d8dc71464207b22c184efdac80cff706b093187b13e297ff50c79d2cc83a43358effd50b6d3b9f6eafdcee215e857bfc346764dec539e0699425d760b156bdf1c571902bb88de7532eae89e9fbea12e22dae71082df64ebd9943f55679452cf7da3d4f99d43b45d5c4e2f66648361ff291d51e917492f1e54293f6dde289021489b564ee35f1a3fbdb499112523007749be41d1e5ac713b4026677932fcc7a733e1f5e8c85007d3f42ed75de53c601d6bea2e0e67fcef0eca0af7f2d2245c9fa65372b2ad2699df1b34eb214ff0f0a59825c0c0281a64731e8d0702f1679bd651efce9e7c77526daaa1270b109c09cb224f969b882c4e67be54b3b8326558f4b5a9b90b40eaaad383d58b65cb8c2f3bd1ffeadef39025f740f53336660223b9e5231c2ee12d26140281149c4c31914f99b0fb01af13b5912540848d76a7b2e4c6dbb683b6aa7404a4a86a516d62d4a7892ca3ea3f36b18f558732b14e6fd00fe5da8f8923921381292ed7dcaf29a606d30cef884e40a99441ae2084e6655a365f7e99d06237300e25fb600e6e84cf5e8a4b9131b754e88a2151b4a9b65bbf8359ef2bd30f735a637bad8e0d6aebc0957a02b02ebd7c6786f34bd1b5cd577bafc8809ea7133758341d9563807e0157efefb96f8e9b98195cbc3b6c38dc42856dc07dc7e05fc96b2852f0832417b7801599523a6849e8c0f6c8942c9d455ef69233114ef571a74b2cb9f4abf1a3084bf39c0d25fef1fa1b0e3f645752791c4261938a1eb796b2a1c16beab2b31787d73d37a3444f19cd162bb0c86b6c82a018d0e38c4691f967b43cdbcbc5e58000c0f5e6ff55424a59a3c260c9f93221b52ef3a1f1f27d8716ac79a36e2336161269472b5ff83a2284351ffaed3c0426ce1691b33626fff65cb410b0788d8589de82a0d6456b46384d2481c929957ebd3a1f87350ff9e9148acd4965ab20f5eedc74f15e707af3dbbc5e611e1bea578e81b561d704d1fa823dcc92d9d8d4b7f20ede71033cc32c566e8059115f85a2691652b8b75455d7bd5b8976ce15850ee3834a3eb9ea4d377db02aca1b943ffc0c5f076e8acc19cf7af36b22e5a518219e8788fcc7a822edd6eefbc739c74c21e293861230b58db37a72a4a11a2aa3c14c2a03cdccf8fc7608b50fb7e793008f9d98ad02d7dc4790761a4d4436c92c375022a237f4052ed7b6a54b22eb856935e6fdd162d0d571095d35aa93775977acfb3bf5c4e0c5749b03b152fc08d96bd94a9c49bee27f0ae7fc03ac0540dac5503583733769eb69c9491e2f5396dd972bae041aa3c95d79d501e2f67ab435cb10d3921d5915b56b9d316d51c6aef6cadc77ca9238b267c5364a63ebb1b71c3dff8fd65d889ef5286f5c337c7ded0009b9b59f6dd08a7db263075761adf243ca41b4180d3e584d403967a59d17f294cbc554ea1b99001fcc4b985b6c605c8a2d5cfc744caa1d81f7245f2cebe9a842de647fc31063f37a28d5b882f5df5c2c8ef55fd797ced111d1ea00d0e2e33786800339a9e388aef03d13259ca66d419226b40895673f37ce799186059fc75225c4bb3d2218abd437b5f11fca366052b40b1baee694c705adb41f683a8cd29a0208f45a6685cac607a9bca9788197f9b6b8d4d9f014772a39f67e5f8484ba6507cab0c62682bf3c3366b19fe238f40502608a33b8161c238064ebbafc3bc91ab7e20ac4d5e784c3e2dcf483f8c8ef0bcbe4ca7837c42f93a7db215b1427e30c6d9266a9df9ef6e798b353edb337d38050f06f39dcf66665a55a77044b4af1a4306e77d82bb365aad8e4f3d81ab81f2e520a8b004cb64c2b5678ca3eb10de879a48f8b07fa2ab686c07f2bf95df0857bac975577ebd45b6176964ba51d2a06f01f21e42f1df43a2aa49d4232ca4bf7891f5e8c55dd8f6fa101c90d0b623cd8719f79ac51dd3c96d00caef2753e284858d5017fe3f35c4a137e5bccd6511c1c3ba2f300833857dd967ed2b8976e737e5c6e6d4e1dcc07504f1cca34e7871c8ba28f4d7501f08731a425090a2924bd2c3e7ed0ed93a6dcda0ea9a861a8d71005fe9b8a54f125e96860eac560fade85b479754891f1020e0c9b97017f22e706029a8b01af74c4ebb4761c021d92a01f57a6549bc42504e58065294b863181bbff0259bfa4ffa53a1b5c75b9cac61859c8bfd286983bd167bbd3275098f8a72092a2dad1855fae3044a430f633345ddd8ce1cc1cf7a1780614a42f285f3901cee6d76352e52972ce000de16c9fda673f052fcdb11b60337c3418fe8f9d3f3963eabd3675c867c7e2786ad233b3332fc4d1d05985bed19ca60db55c7cc01bc07224ec5ab35d7589454c7e4e84dde633610715262b06ae9b784eb6523144946f643636f1308b5b3dc96d71ab4b85ccd629b42a56c2ec38de25dd4e7ac6b589758ec6e1efeaeb97ea00587db8d1ccd271ce0aa7fdf2dde76d14980d98511439ec89b389fbf64fa87ad6f7230b514f2c8a0bdac306fb757187bd67863fd48b4a057309a84e144195958d07d06967fb2d2045f07058dc2f2afc1fe418927db56ac18447b20904bc05aa6f05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
