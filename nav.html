<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"690da5bd8d5af653f9b5ababacc37c5260e34c2d0ab52457f26d72698adb94969b53d86f3a846b45dcbbef1287c825f6fd85c3548a99d85d921145b27837b6e66fdfb81c35e3ddd246e818b414da10866fc0385b1a0cc7f91a4a6eef54ad30903610adb145967121fcfe1b1c9e8a963509b1caef23cf52986dce33950132643cbea0eb067c19134eeccf739609e204370b0f7966ee6a3bfed5a34b6d163f90b7bde0e8a8e91209521a402c311f1f93adac2c28d9272de9c9b9e4459532365996155d07436a4511b0be71628b82f898e56583c43a69cdf4bd1f68b65b5e4dbab628a1dc903656c2835856d69ec8514b18fb01ed179a8deb3d631e486b41bb4a9bd7fde1c10f4b923e33bb101f80b456a3938b94a783c96dc1ddcfc754df5b9935536473284a2255b1488dcc7f64fd4ac4773caf267fff7dab7f16f863c90e04bbef7820a89c0728e8e45958fa1675cdd310ce326f5c0acf92d9a4a5f4a90153226cf22a34095af2309d27a47cafeb35e592a503a2bc9c9d2a80587e4066acb3e0a09269a67787e68e6b02563b37034d896f54612d5c610c775e04d3e3c675cb67db0fe898b2c5777c3ef5826b23faafbb42d9934096f8aadb6535e3a68b6357fe404f671ac6ebd80d550d2998eb7eb67883ece50a0ec117dab35abe7f6b93f6fad1b0f5f1e36dfed56e4280dee8c96c5fa315a95a8c51ba9105e6f90d8681f4cd13fbe05b8093e2331273703c333085bb359d34792276f3e81b22208b6ed8af82898758c9e556f5dac26763249d2366085b72a7247172be13564fe354a9a735a736ccd98d307f8fe34bdcd5b5439be3dc150ca0341b3404465aa6cd702cd48b2af9fc29339680e0296adf8969b0cded0b2a7a9948ae51b5034cd30ff8670f3e4355d20885708a2df25cd6f6d3065ed35143854bea2310fa3d943370f182a3b646565a0d963ba268870fc9d3b45e25f022c2f4fff6fbf0538fb6342b25d82facbb9086129200ce1638b9e9d99b033440f8f39ae9a7bbf6e669506280db5d246734854fb631f1c4df0a598bd9c1cf817961b37e37b2217b2a5df4d6bb363f4c82b6641f136c83a0550d4f91263c0fde76156dff8844c4c5f163f618e6449b7b00cc4b63bad8c5d4eb6d2e944a68836799f786a2dddb593576be0a813ded358b58b53ab6ccc7da3c9d51428e5b502dc073742a547788376e1ae129078b027c8d8a90d4629137f5f76155d0221a1045c24c6125420ab6532d8834fa0f29ee2bf69f63d6873131d12dc81537243a633d897948f8b3945a7c9947c7881472acd43ea89a555a0bfe833904693043dd752f261c7acbb7be3d6101da0654d46549a914e9578e036bf420e987df7dce20a999a01790697380eb676c5392fa25fab6dd8508969a36c9f0721999cc3702a3a7e1c82a724ce2a38e5c3b12c7888948cbba40adde33d29bd9bcf7ab4bb62cffedeffb9a35956fcc462fe38c9f8669b0d955b244ef4921be1fa8b9fa5280a94cec57a7cd56855c0ad6b1c9efacdf18b6c23256ab64ef84d10fb9ec6ec431b815e63e15128331b558504a16eeb4777a7185340c8c26bc86dbd5cd35fe214e5af86c29a5932382d77b7539a49a91d9ee8789b99694fcce5815accb3497e315c526be0bd9ca7935d6462b493792e2d995758c5409d734f3a453fe972ba23c8984743db2b8f4656bb3e5cca652f5c98bcb30c3c714b658d0f6247e3b48d0c1168d0f060bf7b6fc164bfe1ecb923272007481e4a3144b64c8384be2ca8a4820f204ef9e807517d040ceda7e069635c9e8bf55562e77a6f88515f4fc63b58db774ca76fd9a1202e2b9c061be7a869ec9b052f8c41dae7ce59dd7d206fc6a37c85a48835996889c787e65d87220f96de5d2005e7a15eb6047adce47adfc6bb6236e0e9ca0280f10f2252c93e2c1d25581d5124b8afc742e6c5da4004859275015bd5f20ed30bfb0176f8e57f21a60204f7635e6259af43174b898f15d3e58c6cf6cff5d9eb6db42d2ebc208c94f237a40d8f238e32f70e9a3a73f9ea515a1c88750ec40f0002018f989dac4843f13106d05f94c3be5343b34857a31ed7d2c2da02a817dfef8b1ccd12c764f30c8e6c852522a0bbf83896bc0b540e1dde5b44dfb357af305cd7e775e960ec1c2bf63985cc7e8e0178c41ab8326056d6eec6268c2a1663b6a8df0139f1ab3b21318495f634b8995a0d1fd94d2f4bd5387e4345c1d2e422add4ddbebe999213d275e2d08aff0dc8c9ca672792b00d1ad3dc6331cb71b2ce1f053a52925e38b2bdb02ff9fb5c868624c14c922564bdc8fe66b190fdbf8126a36c31456880d12eb7760d89cbd0b07511e1c3e94ef58f9581faab186c61af502e881b22f33a2e96ae2770a63f2c7f53e5cf1a736fe829ddd14c2503934e0619daba316a3c2a5a6b1d6bca7c60281e5ebd0813dc3d65732cb4f10cda0668fb713abae8c530c7c6bd7b38dc710e98951799480ebe38f502f15ee59799628dcb4c715044a4a5a006a0fcde922111f5e1c91f0169afa7de355bd946c1cedeed4e8366ff0e9d2b7d1eb2b01f9a2854dd84b90af79bc274674c55bd11ef967246c3190f725c725c3b5f4288e8a805c059b3a4f209a97410b2a4bf0ad6c5f7950b8fb0731f85632f6fd7a8eb3181ba9fd5663190efc5a08b44b96b06ab9ec7c7a30aafe93c4f19da2a31a42c8cb03781947a0c9416a70bb1cfdd1eb2380ad48c47e5fbc7e9f9ec6db3e136abfbe1db593e48de7dcd0b95bcb832d533434f31706e61d496fd3d9e047bfb9b50cce1859eea6779b18578e62540575b0685626ade634e3b88176f9bb6a8b4e4cd186a6c98b13a0567a3dda72d320c7de156732ae071a36a9b91cef696fe97ff035b026c0a846411b68b91eb0e06d92afbe476159062bdb395f7f47955e6dbe6a369dbf0f0f692708e37c25441c5941d6ddced2fd53faaa41408f8d0182f7b454e1666fcb83dedd2f25f5bd1d2ee304c34f8f0bb39290f64d663e68efdf40da998fe1c82c72f9c7df8e0d0a40bbc996ded52939ce905e6655317c48e3837bfc25a83f7f340457ba0d7935695b09a61e1c1ed28bcf1084094a37808a03ff1b3ecb2221c0092912d10e5d7666ffdf8e6a775621cc24f31294e711025703b78454e8923903bf1584702b9a04ba5b45f63eca13d7b7853e60f67610953b82c89b7a08099dafe1309220dd1e6b125d4edc4b434097d7570f35a7918e0ae95a0a61c4b03f236275d28c21ae132c1fb6402322ce36e21402ccef2aa7ae3ca415ed397e8ffdf7056f12487073f5009f1ad0a04aafd17e6fe5363706846478f9a81b70431ed35d572a3d32a8ae13e0e810dd95b0d659ab4a34605b6a48ddb2b2e0350a0180c218ee16fce039867b2f6ef4ae5ea6f7e0628a9dc60db55ae380939245a13490b5888277219e430958ffbb7a48e5fb9651377fe4b60bb5fa83f7feda05131b31606e5e305b80ca4c7c8b17b21f3155d22cb8aac55a72cf63b205f0eb6dfd29ccdf39493db770c42cf22875ac18da256a7d9cae82d9099017726610d0f522132addd84d1b41722261ae992b79896bd1d150563df5eae2833f6c2a07f6b786210b399da24f39bea13916a925d772f4b5195330df9a0535d2934075ff850602b33858efffb9749d1d2db857dce6692bc21070518f902ffe364d232fc9277fdd5770b22f9b99ecf2ba04b4e3dffe8c5e6afd5b141f074d5a66d93025370dbe31f513cd910b4249d423ab6bdce1fd31cfaa0351a898142fb0a4e78c89cd1ca3228c21ff85a5adb58415aff3ef0e8b51dc3beea13d72bbf85c0e90796a3a10881eba894804bba3cc4fcc2b1d6ecf9a2e0c181cf7ac633e0dabf86e8ea17fedf4eb454312777a2dfbacaa22e968578ec3a15d57a8d0873aec473c4af4cf86669ca278a1120ab01ddd9fc1f9e08e4b53d50332c508339e0a08ab690429550d79e88753b27e8fddd04cd667026938c6cf80fac02b6a482901b362bbb0cc2aef80e76656689b1e7f5d842bcf656c072ce0f4a0c4c89292b8bbf39ad95b21b91aa81021777d22f7348c5db3244775d9f081ca6f65e134536d894327fa53bb542dcad9b28776ea7ccf9621b79c7d1d6e166930b129e2997c7315ea821d386a9bbc343827fc8499afcc00016cc2867cc1021ae296307ae0fb73fb66587cfe8e89bbc9d66690fca3d47bac9e7559ff1dd583532c633ce92bdcf428bcc93f00cf6ad6dcdbf2a9cbe41463ac3ba12bca45487a0f6981a7bc73357b82eb135c3870809d5244ff43e596ade0820472f3ff2cf75060c82e6b8983d7e458f45572cab241578266026a16b609e5df0dc97c9108641b60ed79571af25171067fbda425f92fe2cac9840caabd5f998697345c7472318816cd306ad6cb11482aedb1c5076cbf949a031086e27b81b67644d0dae47ed3bca96e5c9e2ed0bb89cfbd2ceb2ec98298353762dee08656deb8985defb7edf2d3f71bfafa2377dac956297a26bea38b86b303af11a612216fd1f556b1190e8b155fbffb2622d5e111fa14157718ceb57eb1eabf962b448402de2b67ac64bd496dc2cb0f97345c94c5827f499deb5f427a3b6e09110def67838cd888fa72ed9a75b9dc0814714e8e6f7a9a0d10099f2678c20648f4cf41ca876f12b77f1b51cd9ae01dbfc17a43432c9e426c81e4874c63ffd7a146f33fc597ac45173a1c5e15300ef6c3cfdcc60f469dfbb483eec755e73cc6147b760cf1529635ce7a4d3d2cde350d5d9fb2e9565617d3373f88eaf7250a43d655c59e8d9cc02a4e128a4424176f9de5304b871aa1301001495e91660dd0ac33a133ba8cbfa0c027b85d6be19c71af0aa0f830a753855c9ad409dd0d402996b65c12b4ca484f5091fb0410e3708c92d2ea255b30d4300ac656ea33a5b0ef5e4e8f63831e566d5a0df3cf54e1e8025c9a121ac6b24f2e00b44fca916f275ba50d025bdb50d907d3dfb81b668c62f4e4e3685f93757191dd7053d9ff5e7b8b42c3e74191fd2b77b86ac4b3c8b95fc0264401e55ab8832469b6b364192eb7469a3b9f00059317654300c2d6d5c9e0646ca8d84020b609bc2d8cd007530f72c06d5c0a719f628493743e2c14632fbcc61d8d13af779074b1127bda90024f49bb2c49c0e4573e3308b2f2597d32276fee56cf890163c7e12e4cf75df48c6919075f76ea42bbc3924f12050c1caaa1d0e646eb88f1dde1d650532631ad1686aab84d9c7278b7922773d656dad2cf0a27415425ff6e9390c85bea9db6e59f1116b2c1b51809d18903201835ac5cafeb3cd8ae38cb1f63a329a5d4024c8ed50c9e504170ccf554681c3ef891d870e9155b36c5439587f147b0e0bf6e03d8e37433f47cbc2ff00f7824d334ca363361f8818b2653bd4bad4adbb0893b2113055c2c7d09d1362fa2d95a661efc061ed3787a96243b738141af54a569aa5e5b96a3e89d1fbd8fc393445ed688b63e253ef3e15fdd31ac8db6df86d65079e1dc82e268af08d58420a5e8dd2104ed8abd34bce61720a5622af67f79190ecd131b652eacf01b60b18eadff73eace98234a6f8df6132ea56535559f74b76b4c29c311332ad5cc54f4e5bc2262efb5f97dfef3615685e3d519c470d7a6d5273bfca12dd6c0d9b76a94ec4b302fb53471575aa8a63f46bc47e77cbea22d62be07d86b4b047217f997a42f324d577336cbaf3bddf3a71d443dabf497acb8c7068ccc71bb6965325b71bdc055320c5f0743ec647f23393d4837639fbe6b549b616f7021f210041efdee2c9b84e8b79ff7cb64cd889ed80238f5a3b933329dd0f34dee169787369fd8fb92387b0807d10e3c697aada4393c53e9b4d8db58403fb2371768a416b8cf5aba9285b27f8235c2f79b86e7dc937bc14306a68adb9d6eb4c0849052fdc7cbf9a116e0029015ce553a27257b210cd12dcc00592a426cd5e235260dd7050ba924fcbd86bdaaaf33a80ca8559120ae585c0152463a7294f7e27f315385cf68cacdc232487b8ee3d5eab894885190057f162e6ac7608edb5e1411d3439dcdc917614b477fb07ef2711a07d9a17cdaf74125637083c3b46c8743fc1ce0bc8d4d9c46d5fb5e7f347b8eb9961bddd856bdecc245ee8c10812515d1f13009ff9769538b83ce7b91578acd1d16fae0ab06ba9b5aa25685402962fbbb97ebfdf456f896daf1e30e08779e912e37bfdd991621d159c1dd913fa9f2d95874d643dd1f1f5030f42ef8b77bafd769e633af9918747b90877d1f216a5ea4d7d67ae851107da26d2d07cac5b5e13302b5b73d95813ed5cb2906c59fca0cff2610627c3d54422939c7a1585873aa7c1006d19e67a7e0626bd2a66f1692a62578f242f7e361527b44fc77e149dae4b0445e4ae999a6c1cd429d46d82b1f4fe281a4ebecf58fa77133598e2833b824e5611067829fdd405fca7950107c5b001d26627eb6f1612b944c6438fba6fbd4fbbe2085763f0ef6f4bdf51f2e1778350ec5444549e9386ddfe4ed3df42d7ec486c9513ea64196d3e4f232acc4dd4f0841b83c839bc9eedb3d7746d5975ede76c6f0dd911e2f8d499bb52bd1ac10e9c47eedd917abbfa39428eb8ffaa40157116bb4ef461c8bb54f0b2f4be657b70c11b4627d17aae1b30c7af17fcf28fd2e5628468b2b404899146fcb289f9037a19dc717b725f4f2ed7dc3fbaf33516a9bc5a913560dd0d533afe69fddef49e946e9f037caedbfa2cc66dd2317cc5fd506304dd91e4ffed86276f9fdba30a7b64f4ff6fb64f87661ce0b44bfb729b862acc070c28d39a5fe6636af3279c9ef84bec483fc930f689f31ff456d8567f4dc4b3e576e4aaff09b27953d511a5c92411f433be8e562e09a74797f13351592b4d173e8d1dcd16a8faca5c96906a302a1186d06ef37417f1aae768128505d0f28b290814459efea8d0fff73cc6606c76f3dccb73ea9d215ae40e290fbf35e118077c660dd6fc9d5b88b82be451296f45dae51fa500c96f91e841dc195d4d2fa85d07daaa2f9d6691b28d3b00acde60a20a913a59fd6f5a4319a42684e6966a00d5406abafe1b5fd4061e8b848e757a87ac06ca32d8efd602aa7f159ae5fe2e0d7291ac8ce988a30cd6ec0aac0167258d6b4b500fe7a8a4905a357dfab716d7cb16a90ac6cff8aecb54c87451c1edcafeab83c4e841a52570ac57faf94b4beaf9e394111dfc223c31cce914b1c427258a6dcff3a4f547eb471dab2c68549ff2befe0d1304b6261e42e4c0f509728ad8dbeceb13bfb436bddf9ece350f1966684151057f3a722618d8994931cc682e4750378b8b44b41018ef106646b9c7eb72d1f576425a4159c25396915485a7812894b13494539ea22a3cb609fc90debc6b4ca3bc1dc9674261ed1d329fa743b58bd4dd29bde890d5f0317b36815ee5dcdaa806da0e1160bc375fea53b297932f448b39e0fd7646abe18b8dce59454738232f74c0fe88ce4632a4ac08cbf743aa23191c36a96208f7338e8344eed1772657854c41c45b36d49f61be42cef7f44efde50bccb55c548e5ec9e492050c604d17f2484acf8a1d8aa5a621c37a5febf2f0afe3e623db2577ee104b2788cc80c38216f32a04c2161fd5e6d47313d2247f3ed310164dd810b178217fb24b98195ad32cd7a6bafe685503e3ad3d5753adfd4e1273966440dc381698b94ea69707ed0f7e58715dd57db492dc20180e31ac1e2b8cd00539f6a8593848483c143f67b2bc28ac1fce6152d2ecb90e0217ddb4f975757e8956c22683a52c4857bcb8881d2cb7eca86946e9184a8eba4a7a050b657bbb56bd0b33819e12bcd5c2a77ed663dd283f6db2bb200d64c76289508797b0923da482e8d2091b956f562737dbd6ec13653d608471ece1b73e731d5e2268f717b52e1cc0f5919d0321a372a05e87bd44e2da90686a656fc0b69028a8d05586daa44d7cf425354a4cfc059f69ce23142e15c6fc98d1b7aa702bfbafbd21b1996d37ba9b3fda0787fe981c2a3516d7f01480749bf7f53a9facede14a1689c0ab160f4a867ed84af9bcb257f9dfc254ec5f3cecf1eda933c3aeae1760b699d4d38817c95ed054cbe399c2f7231d3546e36d4d8c89c120c72d1b91c3351a8040f682eeb5ac324936f7b52ca98e7067d2a0809d5995a38b47fd503bdace4f93a34cf25c135cf3b36e1d8a86ef15ad5fe3004310e24db384a67070c4f49186dede44a65f94884f7b6a1b947b945f5106fc7eb35e9782188e8aa8d658e63710bae28357e5eacabb14f9b81fac387c5f85af2f779bb45478d60ba29e6c6156f50b0678488201716420b99b6ff8c5d8bba9a0b316fceecdb8cdc2776cd3c0ed9ccb02bbbea3a887944ac2a9c2d378c3dac886fa727d74a64c186f7d0f05d5f1d84ba4221351d994d1303057bb9299029e42e31b447d209d2aab212c8f0f33092ba3139109e228dc5ffa17402cad14bf862095e787cf16222e6b00a9fead6305a074c57bcd0b41d5e5f01a8996dee1806537b17782bbdbc66101f4e4cafef653a01ac9800fe4bcc0aea2bdd789c56e97a71c72a52ecf35453165e4e226f0e1ea3ab05b7618d776e8c45a83b8ef4c2e3f19ad153e3d20f224aebafe0dfbe596d7c9e72fe35d428e19457a943b223b20c2ddc2c74d2ed2f0819368ac7b8049decd827206d94bbf215fc5c7247b9ed858840573f442ee35027c2f84faf249a8c58483d29128ef6ebdf1f099127dc1a6208b239a855d8d6cd0acec75f31c080a22e9f48b7b32c9e51ed00bbc7c518f1002593b7559d631fef39709af2c76c03474da431ea0593b890a06a5a06d0811b3f2a160d972d481de250eaf8ced092c2dfe8054daeb8982ac56ffea855aaafdef62c10fae087df1260c4eb950eb90db43a2063f688beaad27fd5f1da529505b8df64663ad43240fcf5af0a4b17407cb204281450bff6cff6984f279e47c69bccab3fc8241ce68f7f1b52ca370519783c3e74d2ba9094591454cdd959eb5e63c378175ebef5e69043fa80e2cb16cf4fb06612a8e8fbc835948f9324e49f20ed4b60ac963aedb066f3f2714313c252eb5689ee989a1fdb3b14d4c248c9bc19144d826fe60c800135c1433ecd0cca7096de93c696ddd2a9147e967672815fe8d53a0cc0a99d5876c4580a228bfa393d53151dbeb076b21049a28b8beacf7583beca43cd9df563b9a2ff44a167c3234e503881612f681a52a070f33d305c2af65a900f5fb2603529414b1a967663ecd9d03a740c45f0c39296a1a21641658ae1a8c7a992e69df3724138ef7af83bd4f8f3428d513321426eeb93b0ce713e43961a94e4870806cf9e6a54a22e9c9fca8b4cafa6c70c3b8e1c3bb30f2c9d063f8765257e6010c21163727d6c3839a1fe82127dac04511189e2478e28ac06ac46d565175b64837b8a03a4c08d7c344587ec7eac1a71016aca5d4aed62ff9595eb07085ab55a6496346df8e79c9bd114ae0196188985578fe3c18a6dc5d394913c90c0311223ae80d8170305346e9a9dfaad06e4c977fa6073fcbb9473d658d805fa7a28409833fae434641989bdf387c94bf9dfaeec1f57c9b039c4ff12d938dd935f8f24cafa19bb088a6288449bfb04848440814454a8c54487807f1a26cccf9948684418332c070f3cdc1f0bae18072dc443fa6c1595bd5faae17f5ed165db0a2e20bbe165f5a24c9c54a605488db857edf2710439e06e469da9b0a079ef88911c4e6c7eac72598867e2328e427a17392c13cac199401349c70b59edddcdc2ae00ed91d69429238d468ef2b8addc64b554cf9139667756a6199ca230b39178118968bd20495ae008e14c023bef3bd53b0136da19d1696143b29675969264297c1dfef3bda0a9306eb35c0da4816f52a47c816608d886e240f14956c20c9d1be183e83737236e44630d86328035378711c6fc4400943acc106774d688bf9652d0ae02250a968bdf5ec213105fb0f1db95002b7d6f3374800d4daac892a1f4f628268ec0bf8c32b236c0a57032daef4061b9d87d1409e9d453d517aa6328afc03e536d71f4422b738359969778d10e644b901d2a1e4820b35a1ec45cdac75cb23ec69fc884148bbfc1e0a373691b6f2f9c883b16825abcf05d092ea246e66819838b9f578e3231f7cc0081e0107020271758c62bb4dc7df9755afd6a2579ab93c483920eb45709c9d100801197136a0b827ad29cb00392f294fe2673ffa49a2d5352c3ea418b7dee0bcd7df8b75af906a89dc29f3ac180c9cf26c1dce76a252a48ef04afe8b2852f904524dbfc2311749cd08c48880f5eb4f0ed673ebe3334d4235fb338e7aadfa123f1c7743f90c4b56f8707f90bfa21e795e1a1a3c1dbb8decd8688d7b0f196dd336923ae083a8c4114fdb00647db28fb463f446198e6c7d6f9165038a70b8dc90b4d59122a13a889d8de268b9c3db47e8ad0c0f104e08fb3fca639818d6231215e6f7e2358df813d850a8091219af61b047f752c7814ba7b050dd5c0d10ab1e19e4395720570f0f35e32af402a7e1641990e41a94db995fbfdd5887ca8d9423f1ad6c2ed6276c6bc4e0200f42dbc7e4e5bf413e04ffc9f6d6a87812c82df86dfbd3b8665fa6814ea71967ec882bc679d3cb30add77493a594c6d4feeba75fcde860abf24f2fb14d0f4cf7d5e385b271176780b8d535ef71b8c831d8b39a578cb0b5d9f433efe9dea55117872ae3aa33ce52949877043f2fc7da563c0ac4e8e9ae46c7a00bf8d01886c11746b3f3f8fdb6769ccec4d6956ab39068cff895e66036682f67550be4edc97d9e6c2896a6cde45ad9faa03c52755c36a933e407b706a10d3914b86fdad83bd4996973c0fbffec9cdedbbe277043756dc24dbf49d7122c2a0be0e25b8bbfa46ecc15ecd713e11e246ec8baad2caf865fe74892bd31b10181bb20e876079a5d1f9377c96381ba048e993cd9e056be2ff854740769326a1945068f472d6d82474d19efb9eba1dd5c908a202884be9a6c9f7f4398eedab58b6a8f681414aae8ac0d21607aa3f10de62c364f1bac952365c66b95b11bddba11fffe4e2d6370bd8a64c51e52a176656cfbbeade162d4ed810db59fbc67bb1925517c34cc2d0d7467bc94cb7eaa357a005c922dfdcca354f3b94811133e570ae7aa6f43cdb27bae6faba43da957b582e2c7e49e4e7e002cb9ae3bd846dea1a0e5a502dadb34df9e0d689bcd157c8bc7019b23ddb8bb64e79f7f58d4f8d48fba62d5feeae68093145aaeeb325e9a2b7ddc0983a54242f981cf62aa5da11575c3b0789e9e227d4acbc2d786ba680fe27b3b2eb4b0c2302f9fd6df3c66005058a3db4ac4ddcfb13b40f088e2866ee5f82f9bf02f4822692fc2c9cfd41bed3b0c9870aa20fa809cd107b9f32f9db7a795e74d33da54298d68ece6212b55d221f7bc07faf289c9cf3a45ddb35168c7502b29bbcf485729db10b735778bd67862f366b756401cb2a9b1a28611e003298ae98982bd12b8755fb44170cadd6ab59758f12e4774bf4d0184b5a0cc6df9bc6b604b86e18d0f8f329ee911295a6555d8664cb1bde649596912711707df233bcd4b246adcc095a823e75c5d541d14ee91e3f379708e0417218218409224a06ee1fcb54e0ff17848bdc0f93424a165f48cbf6c74bd19a5a36dc6fd4ac451a9e82fb787178d148fa32fc7c41faf64ebbcc8daf2b0392593793d610375442f2b635564e22616b4c266a625feb7353359029881bea6de2b94b7f6dc6359642b794a244ae4eceab45fd644c5ab55614085c671c2f581e42110989b5cc3bfc0227c60d1e0503f0b5295b6edd26a656efc155b1c358ae19002e1ccd62c51b939f272381f93c286120475748488615ef9c11e5022d7f31b60a3011e5064b55af2db6e745c4f6d1632d5e5a94132189d2102c51a5ce9f3fd13444db5f98a67261fa3981ba89ce0eb44624ba1ff3a3c372a6465c1dc42e0ac48b6bdfeb89fd9a673fe9c19b03211751e362f47f5f4802e35258f694e858389a6b8f6e70909c545326f54f1f3fd4b9b3379b93a07fd2614774ccb4066e96a8f905832533d04df5c663189786d66cb367face3d2e1213fc3b76c300cb95c1515629be0bf491accc9c7b9d58696400e5fca4ebe5dcd2bbae45dbb658a386f67e75601c2cf16e23539033a571ba8e999737fc046610d54f57541cb2df343a362c8996f5ddcd610bacb249abf912ea15039f368e3a69255141ed4bb743d4d94e72ce5f6bafec99a933687420e6d7a225f445538d1f8457dcb455cdf7b62120c8507aa5e7f98304088c9762dfe8ee3350cf2b1a5ccd522b38d63eecae6db0ae99da16929c40900994a613211ad2eb2574bedf8c2e1035977d0e28f723b94128c142042f13c13963dce36190675be8b6e80d6ec0d5c568f4b43b91f7ecef2ef1e017e12adf346a5107970e1dc859c9abcafe11bab7ba2753079173e3cdf989e76fcf9ccfda7609e812242a8e6b5a4416523482086453f7b65ca9841cad721189e585a54b267f55b4a0610a6b34461cf286af6fea968d14e3c30329ef08b90b9386ddf2fb17e1ba3e9a37bfc4e61abceffd83f1c64f703dd8cb75d5e708d7510a0c5ce4ec1da5a09aecec76da40aaab15e3f2ea2112929dfc2abb2cb0d3d57715f36fb5d0cb12c844325accb1e49b64b189e6d7f0da462e37a47c607c8e03e7ca87b065debedbffd4c98ae06ea41a6aa98bbe50e0aecef9a22ef083b0279a8622c6b1ddf3e1e462053aca0fc430d4b851a2d8ff9a4e8eb73fe6c3d2649d8517f7fd7ee8e066b9b18350fdf60f5cc7d987fa4cec4e07fa50f6b7b0c8162a2e38a08cd77e50b22aca775b4efff15a735c64741f7a4e82e7b395ae4dc2d7f5c808fbf717bc5437e6356e831849ebd8c809ba228af4387f6b3b70502a3d7437574f9f54d181cec5b3081aca7c4d72a974b2617fc192d9ffdd06c232d3ed376c8c8b7d0c96bc36d9e3c55a0e0298a25060967349f9b29e31102684fc89adbc8e07735e0fa6053eebb9d3bdf887137c4f325451922b8141559b80b2b63edab560e9015da1d50a994fe4a658e8b64756f11924c6185963ef836a818c52fcae653de66515d1545019d5c1be7483a72ffee16226dfa3172a5183d1268fcfd5015ac1a967c1358b1cc66977e6126bef19042047844545707365c1976e5993e52bbbd1b4fd6a5af1aeeb6c87121f7c2ca4564427ffb1ab2e210047b7df8ba410c40e9fee090f097085b8c160028bcfacf2f5b8aa4648e05f2a7164f40877b6f3ed9e6d5f0f9aa49f34773048ca75140fea8d68f8ff7d438754c314de2ec250b21fea122205c83fa4376bd1ac5a6a38062d1f062343b33e9c857d4114699553411d4524ad14668f609070b3a1d15441d99c9586e938495c7b2ebde43064ebd3f87c0607830c7161afe8b834254298def6a69b54639d4f5b7d73f7aae708536110fdb136c93b924223d1aa090ba980444a161408215f82369d74576df4758d38922312bfe4c1e34a54872cfbf3c27df4c092b825cf3741a293a15674c668c4b7d9263b4ca735d28a51a92d827042069a48f9e85b0671b3f91817f955e04fb007eb9f0b5752e73c4b1779e2dfca569bf7cf5b4eb1a3cdf129361223a48dc3d90b67fc4f8e525d7bac3223527ee6cd47d29b879b44724861728bdddb8acd0288adf4f3bb30d70858863341ed6fc65c387f2d179615a5ec3723120984ce53e6e1988195915f6b6c7eceb6f33cea4ccd7ae07d23b75e629e688437ff4bdaa44702f1f10922bbe966290ebec5331b33cb6f0f24c6c637b70f4deccc8a965b83e5f417ede1fc6afad860a719b73196499f2ffb1a53eb657d2bf35f09f2ae799cfabd46595562a8311bd01e2438c90786afdfe54db9671e75560fac9e0e826a73c4a7f62249ed03e9c9fc19ed0773f790aad3c6329222289ca107dad74d04af04f7fa6e506aab9fa099bebf95057c7969ade1e2d79231d544da1929e6d0999fe292067064048d299c3bc5006359a4705316035d26caf74b53cd006d22802df408a0129d9c464edbd5dbe09277d361c80d70ae6bda24e9b11e8e4c0e19f45b00c4d7c2c1a312da6c6b7e76743d72ac400c478e08a7813f28e573693d313e2cd411a1c8c28dd7f32b21b76e8b09f8abb954c11f2e2f7414348147675a41023072a7b2f4e4bbe878e6c43e1648dc6dbbd360e24ba1704cce42180cc677b673a488c5a0bba4492eaadf46f90208432b7234757ea162ec4fbf82cc1939cf1e2378c55c1d9698b1b52827c2af022de7f92d4ded3d46f7f9741e16ea957af6b4aea0434983a4fa070b433f1dd0c92cef982d27c2bb8a5908197d3579fc10474a6a1d9afff76a65a4b3979acf1022d9b786b159b33ff2e985f555045231627be09fecfd6b56dd73bf261cdca79ed20527b1f7765d02b8decbf9b09fda0de2f804f5ab9c570aa3d5e6ed911e05c1c612e8c10c981c78b34a34ddafa20c661fd75b22f1358651c301463bbf671a52386bf0ec8d88f1152cedb42c72cfc3e715d32274e78b91380e45de2666303bccc7611243d8df0c266879b824ef47b7085886c7fc2f9707357d6634efe242eda0c0b4d930f32067c667a6f767849a7bae3aa412c637ad598feacb9bab1d0f7ec9dfdebd1fcacd1e4669ed60722128a1ebb234345dec186ec6937fbe651f4f1c5733591d1bc4ddf765fe4bb9e8cfdb98435c625c4847099f42f5327243c0b74f92559c0aed3e48149cf1fa23f25e8fa5fdb5fc4d528983a95ee80c85459f3edd747bcb1007ef0b8432ab43aef18e7664a59595f16e785866eaf30bd33e61b618f421d8787051f3b7fdcd35d761c4d87b407801925481e638f8e0527c58ace1604beff88dd796c60e023b372d6d1fad33dad5b4b3c7f9476edb21e29080e29a804682e1137a2091e5c47e9e07ae9d6fbfcff2cf92b2bc978838d14e8a1ef22435bc1194a63d9648da730a1d2a79851e888937fe2bbcd58cebf3f108b6d4072ff388db70656267a0b45acc6735f5b6b9c44920440e49fd872c0442cd3163d935077cbe869fa1a401de1df03b367838375806c4884ac3400d9d655552174d8cc5462c6844c756be05f45f8da97eff6de2945b9d3182d5e8d1aae9bb6914cdef59282cf3666af9df9867a6f0b6718635710c765212e9a7466b017a4b0678dc8172249b98a2fde7f342b89cf80462ed14f41bc0d2a54df80e92210dbce477fcfda5ba637a7ef3c4703fb76b4c725cf72ae1e5509c088db2a53e38af6fd6bfcc5d8905b8810e6ddd27554827ae95cb01ee73301414634d0a29c53903a31bbc1fac6e147d103e8d07af67c03f216cbcf165e81f7f0d9e31c7d1465bb2b8f41fa43021c06ee6304c9ba463d0ff8a2f9c27259b99479e43359ce33aec23bf88e158b0773a66cfbcb89a416d0a60f12d521015754888a798f96600946232d43be793e6b2fac6b8122c9245fe389db72cfd4c758d442f6c32be493bb21c377c3ed17333b2aef9dd05741008d2f57bd5ea137d241b381be911755d3e226c7f205d39e8ab41bc69155fbd79a2be7d142afe802793dd0b8f9195548269de65e603e97aeb8acdf7b21f1bca4d50319dd3658757564c701ba26d6368","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
