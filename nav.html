<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11da06e9e4cd012e5385e876fe3435555803bbe36cd97522322234b9c6f7694113c0f4306150c091e2684f8a3a1857bdcf4ce5f7f074edee2d04f352006a2744b2618618610aa7f08bc47f2d29663ce7fdc84552d4089ef9c78415d33c26da78d6a0c7656cc323267ed2bbd80a0201f8b1676610734fcc38eae6efeb5e5c59e728bb0c3e0c792350ee3dd5bb0279e83d01a9d853d285c9a06759e5c191e8d86d4db5b9bec44b6c5fab0527d7d4a53c35947b642e55f044484268603931ed3aebd0222880d13d6aec36897144cf3c40939ba59fc3ad78771f42e397e829ce5c035fb0a6287bbe7c706070350b2189d046d7426afa1e24d5ea1da97075604697b625c94f2363d1e644d7eb104e3e06550492a93dfd6450ba1342299189afc6cb23122ac66a800a0a38e8951cd9d39479a2ce71965374b488ffec48698cf0fa5f7744c112345bcdcfa0505426a2ceac91a817bb578027bf890792adfc9c4442a15fa037c76264f7ae283ef50c68cc0d6b0446983b569cb45a4995b11f0392d5ae150efed38cdd5e0308b853b418e12b9055932faaf0ae5fcc1335d9faa7c2b99402bec2781dcda70615753ce483323ba244e823014dce06db06bdaa4c192e8737e68c9abf380d6cfc1436582380de4d0df217bbe5ec0da7da4786a79636a3e224b55187724d4fd821a308b618ffd289c2191bc1e741ce20f067436df2160912eaaaf5503543d0796e1de7dbc15e1e8f92e42d8926a54a1af806569053b3bd0c037f8ce217b72bd58bda95e4b151212e23ea2aa81f05014256c4063b915c38e94f4771587726aea5f2726b73c978ef20747b93edc615468d0594011b66c169975ec30890e96263c80243a9478aa04f5539f9209af20883d47b77238c51cdb1d4868d9b01d904b89cc2271aa2676f385f0ef10d0fec337bec3e223c653e0e6d5b80406a9de1f51996df04fbe51398e2ffa19b117233116502b15da28f0a4a25e75e67be32d630a1b3ef39da564c5a00e9480cbc35115001efc427513e0caf8ab7163f60fddffe0cf24c3ebfaddc0a514488682b9527656f6724a6e6f4c2a1a64fbb0f0c199a0e5db7cd1856bcac38886c1da9ba37731fe0aac6e4c63c2744a638cf32fbb4117ec955f432d685fffc87aba37b032e14394f8cd9e555a2ecd189d05cdcc5c29b892d4dfc06e63af0e0b18d33db3ea0208adbfe2901e52ab8d8a327765c89b6acee8f76ae6ac6dce79c9ba19eed6350dd3d2a1bd895de8d8f3ee9a325ffcbf1b7880d46e9c6a60ddb01967e7a9e24048520de6f9fe6245b0f936322e77500c0c6d359bdb262b5b732d1530a72be583a2eb9b9cc12bd6d0048f7b25090828fb79e2d62bbe5ae8a20a5a7f300222cb8b8702a968fa3bd3984b8a87de41178c5a0de2c925c2b8f9b618c5e19ee49e0e33812898045de7dca8e41d9d348bf27f44a294a37ed2ef585fab2aaa8327117a692899bc5dbfaadc978fbfa56dd2a9b2db7647c4ad83f619d1c8b190c53fe3c119f5a2301108d34056399f6f99badb4871f831bdae32fe9f12f2c4ba99b3aeae1c14b96120a8526cf910cf013dda26269a9867124ffdf8b70701fe0125762abe63ed465ab4724ccbbadfdb675b8eda026574e2302d52689570c26dea22d5cf02e6e512f15c16fa23eff1e716b0eba8aa90dfc9d1cb64cc50da8593cadb07c8e22c9bb21c82f134ff33b64387c07f56902049699388c3455ba4347d4b4b72afb6b706582938e1fb85b87bc6f0d78835943b79fb95b544e32dd7bf441c8cca696fc98dcf58f9d6d0e887683358f7a0d4c82787ddc8d60f9109fdd93dc4d0c8a748a6e803442099f8a2c9f07c24ee25239d8a03eb753bd794ec797f1ad1d290c44aebbca576404089ff493c3707540c876ca4b588061b791180aee5e13b8a4f98286c12402660a97b89261b5a0832c534b8d27a096019f9fc4bd1813011a7a787217c35b34e60c83df687ee16cc17da672ab51032e3570724feb4a63b5380b260a562109f1362e3d845353eb03b1651ecb397b5b2d890ec4ef9b623b02fc46ce077be1a27a1ba9ea9d5aa425c33738e7e549bd62a1ba49d68ea018c3d401cfe7fa7cb161f1d6cb7ef8d832fb94670070df65ccfd9ceb98a7acaeae6ea1139ddb76a4ae95c4bc5545baff9a8918f71c81fa1369c37acc5480178c0c3e0984e54cffeeecb0a073699dea94ea47313e79c4064dd6dba7e827c4e801cfeb7659da2c34c33c78299aca1e20479f721c55bf98f0da10a3c6995aae4f57b2e09f01231a46a1a203b254d2d894f33431caeb8682ddcb34ba950f915914db5187344cef748e9bd5a5e5c8f54990336c40460427f05b13a8de487ab2f513624d730b8e82ba0fbe4c3d6366365259fe6ba01a1c45594648003d72d619b7401784c9d39c0470655971aa9156e963df6f32f46919d46750f0907a975fef15029455b522a3dcd68809a2d63e7893de97ef596b53aefdaa2a13f948a1f337c927f15f4e96841a725e7c2f0028897a034e7b6bd0935721a6eed3fe2300d69ea2231a0fd3490f2c6c2688fe8b73257d2ccda9d202218041b7bb87b6e7e84c7f7513ff52362f815784a039072a95f73aef4fb64a5d90cf2f1dea43f26ac043eac8e8605f27d9c8b23f6ddb7006fb1ded3a54ed94066612dc752270609e04eddd878d7026b2bab35db02546fd7e00cd8ab9efc6726602ba23c909a7e9fee3f5f969e3ae8ffd91244e6bd4da6375cd701b3a1f7d9d3c7fdfe6a6c653eb8dc5ac08f6c380881960e093572e36013278b8abc3a909fdc80e42a73ed343bf5a9a722a9e932110dbccf3de4430eacb6eb1b6f0d368f8e96c10abcded2dc5a7da512f966cdcc0f5f3b2aad81e0d7ae84ee330929b4d4a8493b3e0a8b559a96c4081bf02a3de8be954a46f1f6fc4e0f0f5a281a85229e5630a1f2f6c7c20bce5b59c9b27cac8255289a932ea8e9b1a93ce3f83bac596fd2892a3bb034d6b59596b64c7c79262d6db24cb6f07c0d1c90cecb0405681664c73b310e28b71d6c3d719df464920ec63a3cbd7772de3bbd40d0d00be0152dcb87cc32e7b60e71b90c3aaf02b877a7da66fe15b6bfd204768a993b9646f79d85c915a59b7e463e1f89983e78b3302db15319cacf4771ac90637805321cb17da9b80eb78f1a80054f070f1428d6f6105009de3d549215c96ad525892d4d33238510ef133e0d89638884a24266bf68831bed7c49afb8879667db44533f12d6656423f36f5157e689108c48af31d2e31b7535fb00fce4e00b5884df7789d079d7972a68b738e3a5a0a58f0b6871c7f8b114ca7de5cf207ce14d9573a8d4759d48c00df94858b4045e18d26aeff9783f1ed277b6f88dae86b6ed12a1fee660ea107a6ba5c88980f7a413e5f953fcbd81d1ab4a1bf09637ed88318ce30b4d1d86c82def46117980a472cdd7e7b757f3b17f6f065b91e15b017f334124d0a13a9fcba1be5b6c4d674b6ab81e08e4765c0b51f687c2e396cf7f61cbdbadc1be8cb99bc8ea7b4e8f38ccf09dda0387d9d523a306e8b82c9e3434005cddd40d4fcac5a06f28ebadb79efb67b4a7a98f8d870551e8ec35f5891f7ba1f47c53508ba7be2b149571eb7bb658903a34ba106e6e5ce2603636a08017e0478b675b573a4f1e3c99817c9095469cfce11ff28bec666499a4fb00012f94724e44036e53de119e7468ba1ea2342c160a57caf0deac52ff823e8066bde5fc0291c6aeca1c0cfbc4110a591b22079117e81920c0f6d5ad96954b4115d35f4ab5c04872b0a45853b3ce0a262d5b84063ed39f52fe1afb27f76c441e2feea76a209b9f584cdb1c17d2888a7db1cfb96296bb9d07024c540d08479d41dd57d92e4eecdd988030be36ad0c7487398fa451e682cecd5d39518a04661c386f1f6c475e70a61ea77542cbf58959c186a01c1d88eadb6841fe6e7d0c9932b2925dab752f7d28b8f264ccb45cfb0e7eea1286deb4eabbbe102f018208aeb13dea26cfd086ba9f0a36b59c28114c26fb834b0551cede41299c44a0cd943bcd9aa618aa598539b78910e89632488417d029067509c5a3b1b4ec3a23222a825775bcd2db09be323a1e6ac29ee5d2b45e266130a5481f1987909e2dfb3d75d0ed6d84b590048780735d2fed48790aa25f3d5e9be33f23149720957ab74a98b9d7146200a1240f152299a5e8b93fd329af1aa46f60c6dad12547a5189b7ef60ad325bac57d7f96e579bb961f677256ec087104483819631bf152c3103db560b58bc66ac8a0f4fdb349b354fc3c22d0b437bb4133de24706d36d836bcc72c6fdae2dda66ea15ad78e475b03a59c770b61e08fb31d81ccbff1b4d84f4a0780dd94452adeee375eb8824af23784f75542a8c7bb607e3f107dccfbec38ebf59ab7165b54b7a696bad9af47250a265ee92a632dd3b5d88cd6ba560f6f21983f2cbd368ab869bc7986cd252c6f631760d2f42bd446b970c0abe07abe5d0e616cd343fd218af64e5d7adb14a0c8138a7e3d24611189d0df5303843001e54a580fd1d0bf956bf7916ecf58ebc8baba20e00c16c2621f759ea9162edb4b3ccaec8aad54fa26900cea49fa1515ad49484e2f0449a8c0b9c6a27c468976d46cb89c7195986079f3e75e63744e5e45100fea43dd0f7207f83e98194bfa602a0176d4beaef8dc6f940f7afcd0e059ff463207de5f3b9d62aad78b6b1f2bbd81230ba064412c913fc7a400093893dec341dcc9212ee2516334eed2db4f51da130d561a8864403a1d70bf7abc81ff3aa6915f6795b32c316656b278a955745d50796b3e4528d7f2bd4eb8c887727dbcd5d2da76e5f87a26bf0aea2cc88918f42328f97eff32f8c08eec1578fbee7fc2911c64f60401c6b5cff0a22b090c63114ac158e9018786ed51c2249a7bffea17ad20dd380aa6840e8b22fe5112418776113d07719019fa706dda14f979f1397e53cd09e266c8e5d5f25547985ea69e3cafac6975eb761a67818ba7c58c44387b5adbc062f4ea8b75c210f706398b8242956c52832a382b40f9c5c9e4356801a21eb372662c76061212c94e33c01114ca320094f75812691d947cb86d49f0f3176ec84470197f59da78868809f2aff3c91a11d219b88d06b1f4c75ef5f65f03685449d888979477761614fc7396853d2760a1c0ce43991da7862bd338cb4639b432d47790469a8d813a95768b03cb476b3251b9e4d29f2c0de5d2d303c59e98f408fc9e447ce9f3d6085a59c373e3c6cc096e1ca79ae2d6727c576d5e750cfb37c5c9435ec48f84704339d651017f0dd166447555bb8bced94f7762d23485758416cf51f7f64322c2f71f3c5a2689b0400d4134759302398bba94a87c17307748232500bd8651e05c6f6df424eff01e6160f771586b0dc927ee3a262ea92bb7e9ddccbe7beda4c6ae782cf7fc00a0ec44776a46ba151bb69dc05eee0e58bd4a9600c360c53ac96b157130b15064a0798a621dc8471187067deaf975f549619bca54e0de968eccb56f7937d2973872c2b9255477bf9ec7f6ab15fce174df767492dbc78ec95e5f06ed802420c99ae34ac7bf15318bc435b9ab6849377d7d5a69fd79bc87b11f2a29be93703a988057c6dba56339f76d8d7c727a9171e2b955e2e182511e2ea1ec919683a8cd2869dd268664750700ff76c708bdbf7419d7586ad410266a89c8cc2eb801ce65618c81d9b5a8b60766a5b55299b6ffe4013a06af079701bbab70dc40f48beac0113a5befad2a86aca1b872c26b3a11a82669619919f16f306518de9acc1561fafdab094665a0180d63514947f25b31312644282369e422d636bda5e9e9aba3805b1c312b68fac9ffb32384c901a02a42143b1c8180b452e5af58389b4cd0f38f0ab271129a27a435c3d4d3c36f13a8f4af3bec46aadf7fe20640e428d5f2f6dd658d72d1d809c7baa112fa97f7070e2b980fefef104cc4dc9650fd9f8a1a0b402eb618854d32d3e3244fefd582f62c8b9194bc5dee3a2fa88a0b2de41394462f38d0685dd24d105c6c8ac656714acf47a4d3f6b2ede9f396f81760a9ee11f4fcdf17aec74ce514fb03b674afd4e58f79f3c47ff06d137fa87e08987915b35082e2586b026eeef09ffe6449c5845aea74f9de0fc78deda84c230f1e7f978819d39d349142c6bd6da62a8b7e98594696efe19735dcc0c37da12a53fee639d7ef8a98ba24b02038f96b2e429360e31feecc471b63cb44f65a4926a6e4fa0970a41d2fd8bdb6b6eb78f7d06e15e4b75c5178e42180cdcf1b6dcbd32f4a74c9f8ed0cef0d182331818839743cdc95f76c7fcc1ff6d68b3a53bd4897c0429011875db53b1385e79d0bf40ad2664d376ee6bd5f2052d72b35bcf6daef4d6accd31feb780fa1297733afbd90827d7fe0b8a26f378b0acfbeb4f4b9ed85cc71239279b35e617a01123e03fe4710bc6c55368d2aad4bbdcfeb9dcc21d1216662a8cd9cd6183247bcbf0304ee38ddab962dd84175a2b3ea19940dc9bf538140ab89c4f22eec5b086a1f79eeb501880a91bf7fa1af98f0f3be8929fa64b10bd2c09bf3d847a0a5dc7fd3ed271a0a6b5d957ee79f5ba172b4b3e49b28032c7814e5c99b2281d461f9db6155d438a40c4d2a942dfbc2a014c71cd0da309fa321f85f2036f5a5ea6e59e486f91db9ed89f1c0bc9b290329621fe141b2f7bfeffa0cea8d4227d1a43a8cb1b097cdac8b85282d4e38a9e51fdae9e590b83da7631ea53059d7f22ffc298a5b2cdb2d0a03faca431f1c8a46ee3ed3fdb4edeabae699340d50a04b17442977937ec0768371cba07c923d8581006fb284d90a5728068a5c00ef1ce42d2ab0c967c890d3816fad49a71d8f6a045a66ee9763a5d878c4499c4f9ffedc41d696a614b0d705aac865b181a9e8bc4f43317f2d203cca36ecc13553ea8b0e1fc2da6f17f2ba6bcb181e07efcff82b39dad85ce4e830dbeb3b7789de84734f1a07151ff54949e0095a069ce1e05f71489b14a78a78e8e1c9f1a74e992e6990867b0a565ff0ac4aca1382cfff261fa63e9ad61be113d15612be569c064c5abb4c2d029356da509797e4e63c06ae3a459893a8b3788b25e2d483ba4fcd3cc4074d4298bd4cedf84c16383c934c90f61261d8f483aa4b7a69919730bc84d19a3b24d8be0de6b5949bc2f82c9940aca2677212e6735651f3104a02bf24ca7f18418f43bbd81b4d21c5d3a8ef80bd0ec4d5bcc934088e0986a3fcfe1c5e0d80ce9d18421359221a3b7033f57ff35880c57e8ebfe055c824e97064668ce57690d89ca6512bfc6a3660565a2bf74df4cbe5f3080556101b7630721274b958970bfd3bbe108c17e48d434c17d1b1adc04022d3f9440fc43a7d7c7dc814178c7d1f8b4569e94be16618602ac0649f53e64baf257dff419fb5c67f06560f5c30a4bf8b36fa5d4ba4b102a06602cc2b1d7984aaca0cac8e81bd29364a36e92bd9ce5564ee177988ef94c101c28faaa76cc7673381e5f14a642ef8f9ec501f7869a9ea8de17733c670ec257826a59a6084dd93fdbc59123068c306f9b099ba0e06e03041ba9a0ed7d4e6fd22c05b82316b35b5b7ba7573e9a1d6e1b39aef7be749c806c791f9c5dc275e605b0e6e75846df39286b79ef799a8e5fd8431d4ec3a1ff56a5d2d2b01ca5843bcc1c537d293afe73cea1a2d0cb915a224da8f71191c5fe2879581c0d121acfa9a291d00be128ef427521a52f70a733c0d1ec44ee74f6bc5b72cfb8f9413bfe31c9ab72d6f7460118647c40fed32b7aac8d2fe41618bf47a19f4835095e74fe6756d9503465ef85c68ce9d43cb25bd4981dbc47f26c2567db9b92a54bf22397a6158041eca0a0c63eb0a29f96ce873c149f5248816ded118d88853713006d627c36e42aaf69d072e5cf22bb20a1f19285fa012481540f8835cc994cd6c5c9af0fe640c23d6b422a0b9b12857db377ffe3263fb106329a5ec4dd40a1851b1961b94fe98169f319ac70bb5a22900cc620ad6129876dc2204c5d1094606cc0bfceb2eb9c9d4d2eda5801ffc9f06649a319fcaf98d86ef124b1afe7c12d40ee27add94d1a557de3498113c71f3178addf24b98acd9e83d8d8668872d99abef7d5251f03dcf1769902538fb3374a6b47ae2d74ca015758a41307e3721bc9359964eed9c2f2db75cf9c61a1a46af7b20e3dbc59b62053af96b245218d68d785893a9b8e9bc79db87bf17ba5a4c94f349dffdf1fc3186a6857f5439d591f9e422a0a59d762a20c34c151f64416047fb19dfa2e7e28de19e941cca679cd9434e8454f967172261d20d03e71f807ddcb35214e0d39500cb0ab059516f0ae9946958da402ed307c22890c81e0a2b15e38df6330e38cd06d8b1f9f82610c266998f5b5b8c41ff54ff913c7f0fd6c1596cd0f7514218388b155683584435e9ddd0d7969513a89be4be76db1833d657ebaa5c00bf8929745281a803252b7c92bb15026c5157a32513a182ecb03ab834a599f341bba237c5c76c966100b5fb4b70250e931d9eb893ba1047511f1be49b3439e85631db85ce95c6b76c8b96c1c7e3db356ee35aedc9b2b62e2e799c93e6d283aac2e6334d29123df972f55f9816347050ff63a094a78b57da07291d4f3c4c623eda3f2ee3d7c498ffb7fe4514d30a731110332e9e541c9f0809b63eda0b0962600df77c411cdc616746606f4c0cda6a7fae066dbfbd75803958fc82bd6e3c06e768f19557d73081a59508a2b495c3d75a48d0118012a1193aa7b70002c8a7b3bf13aef0a38d92ce4d5055ef4717d07108d5eaed7a169ba300cd4ff45a1970244d66c8d22908cd2f11fda2356210043371939defca8df1237283f3976c5f87faa585102ae5acabbea58974431f6f3b6dad487646bd46b56c3ba04dad9a6bc1c16a0a8a861cb7ddb30762259d23ccae01f341b4d2737b2c47a48ac7da4ae420377c850928b36706d1ab2d8ae0e95f0b89a1d2b8c60e0a9decbf8fd8505332c297d2edde7af6827ff1c0910004e6b9e91ca35ce452381129e6c8062dff56305d1e4fd698be6afc663aaa8d9b52ee1756ac0b982448cfd21151a9253a05dee391fdc68679f6c6605364660940b7a5e7d8e182eb3feab62cde7512af374875032e534f0c4c377b7f68e804a3cb42b1ce12ad67d4870823b9306c35107f7f5e9284241161e62aeeb5f4453b779c0c2388a9bdd2b065f9e2520dcfd602f71818560f0f0cad06dc28a41aeaef203f3cb2e0fa914352614a04e670f10a85b31f170ee08ecbeb4dfe1e9bd04b730a10bbef3175a133f455d8c5b898a2df08bb9d2e34881ef47331d9b42d32626ea95d56835ca1a3b904d7335be490bf0311af0310661650fa6456348dccfe33818d26d9cbadfc3d81be5bb2ef85961008366db1f2b14c17dfc0ac57307119d9335ea560dccad9830dffc15fd69519ea8a33a6bce4949c7789a88114507afb04d4e00dfd62efb7adc59a31fafca4db52f11fbcbc1c5f3d7b3611de11812dc381e9add722bec541db9232d24a282acc467c586ffc9779eb8b2a64f2196a1146403971b5b04596b4c4413e7e8e2da1fb1877bd71e6e52ab0875adef6f9c7e626bf037f826edc2cd59795c56b440f7e96e167e68a7854ed4d60de51892a02d1856bfae24b3ca09607f295b4efdec67a107ee70a4e34abd217664dddb94ffa7dcfb0ca92d0eef19d920b0aa3ef54dab5c76f26aa6baa840c8f6c60ff69cfda71ddf0f3ee5ea4642a9ad0923452baac2c093057019fa0b6a0c92d7239b3e86d14094e46211390bb69c8aaf8a7ca680a796dab69933e6479b4cb81f6308d4a7a5078b57d7c8e840798bc49c489edbde917b5e205789ae04ea751c392a06ac58a6366a78c503a810da6c2c3831b98abbf18fdb6464817c015392750d25b7bf57a037bbff0424e685b243a11f5cc1b02828f5245ed35d642543c008bc79b9c017897026474875e13edb5a4719a88092a18a960dc1d475b6691a9d1849b5b1d3e6cc98cc6a051f418f7670d4ed027b8672cc6a40767098b32073c609747dd40f3bc49aa6cf2d3926204243b9f3406dce285ce6eaa623145fa03cbd93a4cfab8dd8e188c1f3d494c4ec48011e3b86e7a951139a229742e0b2989fbfeac9080c05a90c9b63ce9e4119b8bb96ef8d08d8eb7728e4ada8f3bd76c02b544e948c058fa6701b71467c3ae39c04e49fef344541443dd10cd1d20daafce489c42a77127b013753522b41526339e82d2e41125ec47603bfbb75d2f9c38323547b1c6ffe3340ebc3c9ebe01eed4e101bf1dcead272830618c2b31e14bad815f2ae90a4c4e7d5c4f604376f772d3ec5b4e8576e0878134c710edc3cf58e29fb819aa8267f625b85fbaf9f904b487e421bf9682b94cf2038c8751e58283593b54bd5c15028cca109646de3e59b203e18c12c16f25288852db91128a94277bd3f3f7450954b92837bc62288cda4e9a1c6ea7e65f339255c65ce09012f2cddc7be712306ea1230d0d5edd87d75449a686b4c7999bc6b5533f17c1a7870cc96f34f08fad946541048257dc228d317dcee2564aed3123c009332cc64a722b7dfa05c8aa2ed4d99f7739219795f84570d34eb86bacb536046eb224320c993bf943475488b0d772d450d7eb743f034f541790bb3108271357e4bfdb9c69b67d885d8e156f7b24f31aa932b96868bd72ab324cf132a614ceb233848062917cc192fce1abbdbc4aafb2335f3be6b886d6b84d08172862307e9e5145cfa8b3202fb78bb65c844fbe92fb6d116a52e3ea0b0a926ea15a3e28869606d2da7d6c5428b5098b6cb43433164be3ff598944854a0411eaef1247d821e4ae357b206b3dd074bfec7a87472cd77d1135f977c2b3d0feb44ba8ee18df6935613f15f43acf666b1e7c601e3dec6825a502a2f509a82a5091e74fe115d5618a7366e707e8fbc2bdc021786839a7bbd0beaeafc756eec4e35f45c5da48a42beb516022d4801f3b74113905c2dee8b7382970515c8a3f0187e98cdf83cfe724a52716228037ffd6d9d892cac32617b1d8057e686858bb34a36aed99feee3ef4991ea6a0127eafe5b42b539b4e2889bfe7d0e0b0befa90af4696700922086beb96a5b366ee5bb5aea9829ed110312f1b325c0dbb46eff77ba1eb56932e9df8621386955a7a8ef0756d930d3d890ff1f84f7ff7fa500f37791760597804ccd02cf4e58550b4a366ac6b985af59e0e8ebaa80cc482755cbcd8b539c5326ff259f7c1bc23a8cbe0d13871c826baf7d2ca9b6b179bb7e4849a0c0d4d475248fc76b43a002a8d43b77b8ab20e0dfbaf38144c725e963e22ce6bd6a372ba2db5a4645118ed0441c10210fe28f09188f8eb30ec94b0038db1fe368f6e884676d5127508c03030890dd2905c0429f8b6a089f2da452f420556e227476a3d23784dd5a126a8f19312f523373ec198861e5de03363b619af2bb195179bef2aba3b421a8f89cde3459e482b375a3df5e3d794984f3ca8924c0bd965f6b2a851b8f78b758106a53ae32e7d2e58179fac20dc7d986e24950059413db8eef9080c3d537fbe4b8b6caada04543985fde33a5638a338a06a5ac947ea5cea79cfc65189b704950ae86c1dc2ded8dca2ad75ee8b8edcb5032220986b0c2d9af35b41b274becd453762869a199ffe234bc701485d85fae7d11fc0d0c491301b85c85b00f292fc2ad00ad8983bdc9d52d8feb7d9adccf9e4b9e79d5b427491c580d604d6b48cff8e0f8a4161e9797a101c062bfbd3d598179c239be317344e33b313ed0342d9a79e52fd36573c1342e8cc6347cddc7067abdae2d4cd6d58411bc2a98c62710461673fd80ffb67859c5c01fb2d8b1c46e1bebc9a495c0c2d54e24a0fc3dd07d3cb72c577054a7f41aee6160a55f25ecabc64f9dbdf2663c834ef8111bf9c2e5a055073cfa6cad4a2dd240873d7cc136c6eb504d42cf179b62b08273d7ebf7c1746e700d4e89dbe26185b0dbce1c5d26d31a5686e66a961d52eae99c00515581d273d8853e09ad623e791232d54f41239eed5ac7fabaed3edb0cedd8f8ccf119502aaf933cf829a1e0919d5ac8c6aa0ca105e87d77bdefcf2e9074c777c15a3bc252fa53dc6f17b8358ad45c687e08d0556bbb5cb0fbbc7673ec186fe173d69d833e3e7887ba729ce5eefce08c8e7c4e3cf3b785ddc3f43491865638f10d7dc46dca46652a08e8388150bc8647efdacd43de5703f3634566d903ea3d3eefa7d2512397baa97fd4a17ca2e0e42d7e96392807701dbbbca2d99005ac6299c17cf7cf28613872f064bd5ce2c92c539164396bebd08feabc8b37bb9f44a1d781bff299e4692a073b83ef3374b65fcefeb3ea014385fbb4525977052214b25b8e16158a43e8d8b00a3fb70efa455ea1865f4c809d78a3bb5bcfbf5a61ed5375fcb3f6799bbd9b95f4f9d1e9f6965d8055333b5984c05495ef88308ef479f016dc55f9031e85b9e03be05e3e9ffdfb42822b4c691b6c9d218762f6de2a7fa70016fe5e0782f48e55d1b8a02db8f94c3c838c8f361e9b1f5e3792a4e0a1747b8d671b79abb5fd982ed34e919133e89da2aaf8b519b01166b65591a0256bc0de5ce98ef5b303ab11a6a71cf72e69794568979428aa39feec74b405a4aaa3ca7928b5c8b8882857c3a7c4cbcf1493ddceed1001c796f8ff4016ed458b3df6ad039b0e88c822243b4893fe2c080cfc7173d10ebcc668769823640b8410f8eb727dd3f47afa028d887d51295f22a3a466f7ba2f1f7162ce20442881af5a1cd24e162d2f4c3c734e2c6c9b382a7fc13fc4c7b75881880827caa83ce319b9660de1612f51e691ce5613e51908c485ba0fe657b668efa7a6288f8bfc12feed7a9fce72a631bf41d1e351a74fba3c91f14dd8e08d5160a4f6392547cf09cc60826b84a50dfb7f3a505fc8e18d85318d5d46e3a67ead512c8498512af9aedd7473dc5a9650fcc4a8dc046134872f2d01f73de94771d5fef9f3ed41c61ed72efd0515fde4b1ea20c7db9c6e1ef90c61297e0bc27dd2abf8ac7b18fc46836e2fab397d69833be6c7dbc5281dc0729719e0a472221b573065ab9e0674bb3a8720cc6c780e65a65e91cd1f32fde64a1cb732e44356eb70cdaf71609bb729bd264df9347d71a19e979b88e79944a8e6b7f053b298049572196d6add89fe7f16e409abe6b04a35ee095c88a95420ea2b2c6a6c67882eab017e3d91df4e56543ddc11e6fc2e31b5f14295c62dd006abb18209e5ee875ded5e31335c5d9912043b6f1e1a0316a050690db5950a7d6f73b48e48fa0dac48e75f0e310279d7c36a9d3a007a5d0d8b9b3ebfa8c4a4a9805ab01aaa5e6548ecedf28db525957794f47d6f278e15211767180f3beef8b29138559eec3fe13b3a1d89fad15d77b90be77b1d3c8d3835e81cd8f75b185a221c11a6d1d11e722dea34290d9f09f0820e4ccf0c6e5cd6d5c584951b2f1c0e928361b9fe30cbac585c21155a04645dca14279273b822864d8a9a13f7b9478a301f1296209e358778caf979a3bbf0096646590248676ca8431affca0cd703771af2ad4a9b7a3970ce44dec39b80da088ace3e03431112254324f136d5e3ccd78383fa1325f22e088677692337ba35d997b2b9f275ec1ee23475c2e938bd0509bf3337a1fb2ff27ca4b65e9c71a30bafce0ed1e5cf1e11631f5feb9cb3979c444ed6c3b15e75116ec65408b9af9a1a68ebd8931d88f0b7567698c5d4e393120ef7b4c9f148d37a87ba026755f771cce3562cf80cbba052cdf0e7332abcd47178f563ec9fc96f7f73d4a2f4663bb597b10afc415d7c1f9c881d0e548d138970f1818313a1411e1d6affe184ee8475de46ae7690e10e71de4da9c931b9cc9d01856da506d987377e25962c59f8f27215223a18b3c652d96e57e724e27f99dfb5f45ac1932ff5451f1a1619e8df061c4aecaeaf730f34a3c3ed24998a73c9114befc0ef8a7e6c4aea644d0981b79313fe94d1cd5530079dbc52a556ad9b209e1749b5efb279bff74417f9807f6631e5d750731b6d7d21470378473a50e766deacfa3908c600d7f7e55afea43b060d694d6e0c7eadb20e735dd471707dfd60e85aa2fa69ba6ee70dd5a5b5f1c472a435aab685a87fd4483c8d524b89009e6f96939eea5ef92ccf5a949c594339d1a99cd890293abd4bda63cd6af9ad7a8388299eb2cec4e3c93f23e0760ab9612e1e5aa61a01a2a889fd04b973a0712fb5640cfcb54c788d3db310231e8650302ba79faeaa251f71618ce94b131bec081146521b64ae75ea3cdc7c7c37d6417fa1efe94ed6eb785494065a3206fb46720837d73b7101f22085995641c2ffeba04a67c5acceb97da445f008a25b04b4a54dadad99bf51fbe4ca79048d560be65063ce19629a7f037ea5b66283f18e6d67bf414bbe747f0506cdef107b75402f405dcf659c7c90ec92741709ab92eefa88b738d7f602c01763bdf9c52f43e6bd6b10722cc27111fa19bb738c5e0fc67fa1a6c2d92127c43249be7712e621b7a312dfc1e11fb303c0692fde69580079ec48a60c5f4733a1629669607f9715fb294635112d778562e7edcf619c5f1bb6558f5f03a15913ad278f5cb6df5e31824326200365ded030fd9d173e0a56b6d91c5fd1e1c81ebc75fd650b76783271458561cb289fc357c3384875ff972ab63302e0509ebec06a37501bf41e50af757bea4cf605868524303e48d782675ff8a7f88c22b0c83da002f118bb4b05fb7f43fd56f745967c51d1bf2d47968471e4132b626af8fb73f1213e1961888c2f429c5be8ea004642a8c8a9be82fe26305cd0463601dec6279dfa67b22e0c9daef06a103e256744066109205767424a571a7b18aa96f8e91577c3d2e56d48d4aa4f551fdff5136dfc47b5de608e8fd505c8f2ea6a98fe3cc160b9188189d5686fe62b356ef8a008e0c16d7044da89b4199d8563b024dd2215568a355976c847a6443792cd5786dff8dab67d6fbf718871710356de39e072b86d8a6c6e59682da81df2bf791064d80bfd9e798c7a88fccdbdef466681f0c3b525abc975cebb14bf5cc7184a53352c183a9c9279d4011396daaed1299065362e82655dda12a1faf2806e917f05b5ed161982199ab45186c27e34896e44987e80dea3e98e5a8e6fba97ba044957d659d337268f9c1c4769742f6d354f5ce54f38d8a93d7fb6044a72aec0ef6fdec2a3b40435ebf4ee0484236831880f0a97bf293841d795717286ba797a962c2a94756de72bd22878d43fae2b81feaa1b318f053c61eb255399b77cef6e975e9209fa64608adbfef212b693a0e22be64492059b45bc3add6e5a88740cee3a31ee8808284f5fca923176d880177aa2fe19476268280f1fde5da90258edfbbe31b8574ddbd341c33a8ef1d751c17a5b3b40a054d8dd3df7cc15608a10417f926a618ec45e40b3460966ba25163f2eab66ab9c75ab9525d84b92e9ae32466c6180e51f1a6ecd43387ce186126c9728c2c73e480172719e3f64af2c858ce6946f1de457bd339b74c472e2fff6d432a6f76db06eadc158d7e14eb299d3241b87481991c884292580540b262c3b46356e98bfde4b108db1e457fe6e1b0ce236a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
