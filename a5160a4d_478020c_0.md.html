<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95223c01324dfb7c4223f44bd9a77ed2e55db80c8e83089dcb4d0810aceed869274eada99e33847f68fe5d69b8a86d643d3004a4d3890181ce38438c005cf1841b102d5dabace89ae4196d6457e5a08c55c2b913e599397addccca221d67d3df18d9e9f1d06dc34b1c3e8ad5756faa70ef4035a28eb3922ce8df6aec335acf546c0eb8df7eef8b5caf5b7c92f9d67f6336386e2d635d78379f79ff16fc652541e6cb2eba54e5d963f9324546899bcd8d356daacbedbe0ec3b46742a41db5829236ab481e1b844bc19d8dad525eff30c91dd747c0323b86b385c5c3d596ec59525e146c5fb608c3e7da9218ae678facb7ae6c164b81ba9a44ac1aa43efd2676b6ac6f4344dea1e167bcf7442d358ee8790dcfa59c55bb217a8fada69c5ea3319d6884c113c2d7931087e302274faff4f7016d1fc3ff182d63c632ecd117e8acfade0ee11fb04cb7f857867a9bd07ae2f8045b4928550af0b85d1bab71b09459f78f5d6b42b0d5d7a59c77b7f46ee3fed6650ace1f02f4d1671b47c309545b82e677d580c8903cdd761ec04a6953d8234509f900808024213de0abb40ea7d9efbb33d9038d574d3b13304704d7365146991da7e185a1762b8724946b53aa72686b470fc12eb37196d7dbc0c45a874278f82172c7eea52b389fabea128cd8a574d1fc7a546865434ceb84e3f552462291ef882a1135e88e3359123df17350e1bce23e54103442a325ae2df74690af9a528f9952684409698d74a27f50d6a3b539103cf84e991d103fecb48eaa8a78918c2910dc274311592dc7e2807178576c79c2fbda25432531438e9a14d3fc4d5dc48c476c57ba7e21e975b06e746afccb397c6a7974ce35dc5d5b86086273d9f1235460d751caf474faa63c2d5b7e4c83a9527a80adaf426dc66cd5aae0fed5f19bdb898d16f85ae5b065f69a619c25e93113e9c0c477551c5d22c7698480cdb013157f8eec478962ac18abe6bfbf4b8aa7960c1afc10d5ef4e899ee870fcac4974e9a37b33efeca09ef99d7aac6ada69acb3c19fe819b835d9276f6e0216a47090ad8e60261de0d5262737559b30b6feac802c77f5331ef76dc4b98797e7ae9c771b471ae0688785f3346c1df699411701d6d2fa6a47387215b51d160fadcec2090f3f609c69fdab4f69b6f9d9adcf6866a5d011160e0b7e0dfffe8dae3e0491b036fb1022be030c7ea12434db79e7a3e236887a23694ce5cdfb8b78f4d5febd80bd2e8cb63116821d289cea363ffe6cfee592b98679935430cdbf6bb9244a548a5a599262c9d3220a0e5a6c77c2833f1113d84943a7cc6d652056a02e7ee72735d3a9654d24507b1433e573eef91a3251942660de9e85c6bea0fcf6a4186f2d2e1d454b0fcebeae2782db6def13a1ed4d52770100604f2c8be40b51705457bbbabe1a6a27126fc870f8991cd74ad91135f0b8b90f9ea607f3e4a1d9b7433e2a90e74efd98decda865e5da4fb0ef374eed010bbb17fca6954d8d9aeea32d99052bdce73f05ae99a57e416986b6862463cd58c41be6532386fb55e9cab1f6c1927db846b427b7e277db3b72979d2427f3ba1ffcb8a80768cfcb591103b2b8da0cb2c96dec5184c51c6b22c1ec36e5c527b8484da08a6ad553be16f9585eb9e864d48f818b58243acf80c3cc2e28f088cfe14d9cf088ddc5d1241938144a65cb14d21cf4e1ea536b2a071999bfd79fb1bd1d59fa6d6a3d71771bad74be834b15d4b4e8199eed0a5547ef02d696ab9c66662bfe2bfdbb597e51dd1018b1e4be532cb012903de3f3668ded765953910553bb54e0da20609b608225b5329b8fe8880e18042d8672f2738aba995734929b28da225620bec6de4a4a39695d978a061ff43615d69cbe5f9a289b8bb4b884bf0aebf4f190c3292fc0af73ddff3f05191a73d86f83def0df27a984ecfa69ab290c24e3ad2436cc0c927450222c1427c4715a4031e81265c65180d95ce9f4b8ed437dd6e07845a4b898062adaf5c8a582d59b283f5aa2b0ce1380921cac929bcbf1ba363c5f6367c8b2b6dd759715990c1b3a162b4625605b69bbdca8b73d960e8c28dafb948a9624ac166a0243755fc63f1498a3556eaaaf1a5a0955a60f48aa2734eea4423ebaf7dff0d90436dc268bd05e75c8935712b5b375f8e1913c7530122126c0c243021e77daca0e151b0c8c119756942b60969967e25cf8ea64e805422251ed3cec25fe490460c43ef7dd9bb7e73fa26866002a33d06b7fa2d53b6ddb42461c731de0591c0e5e901dade4aba889ff86dfe488a2387582f10fe812b479740ab6b96b8bcf34a6bc53f80fc60d8d8b0f950566e55d68685678cd8b7c8eadaa9fabde86522ddaddc347fc4ddccf42e3ccae346cf1616684985197a4e0582dd7af574b5165e2e9b9e6dbcafb9682586a88e8f990a0a76233ac8ff5fcd3900c312b29b2fcc2ebf1f57552985db3f781e95a27f27ed4d89995f46e586ced2ae9c9a9bc945297bade778a907b448138b88f9c0dcab5bbd4e84a13ce856f77c6b305a7b13ef504076aaa0ebb7e4b352fd1f1356dff5a7a3f110bc5325bb3ce524811ffc90b7280243ca5b3cfcbf699d8f44d3187c9d9fa590a4459daaadc9ece0029c2459af094c67566a725b41af0c2ac2a5bca97bfb21284a5f1ef4faa110041986f1302677670372a84404669b618739ebb8feeb04e55b1cde98f5b9be6f0b4ed8f1e05fde7b0076c035fdce349f3e02208b9da7ce785a370f819cc12b5533fec12d518f6886943efa93a35df72a524d0528985ce252000924eef66aa4a430bfb7c1cacff850d5a7efac785f6d7a27aa3b88b25b6d650ce80c0a9fd6f1741d76a025d3d31e96e2908729a53b651e52175ac8fc3065bcd4b9d429427cad39786a6c6fb37e080f1f1ccb69c158ac8eda6c5c139979830fcd99117c47ee259ebe373e4fdf929da845a92ef5612bca21a08d66537135df4b4ef4b651330e933e4afba5400c349d67e678f000ba2e35f3121c1c1f3f453821a132e588cf5f66a93d8a9b207ec470082694fdaaddcb1156f17bb01a78cc01740f6b01ae71dcda1ea9e5b8697facb6d875649e482372a9b5783fee28d3aba4612671ee14c7667bb2334a9e44fda9cafd32d096053545d347ecbcf01d46b74ee5894dbb19fa22dce9fc076c1dd2ff835c650183ade381987f5cfc60dad3ed8baaadec9fe204b948cee80bcf939efb4bea2928f1d9ea7d8a6104715af9c22808bc40519d3e4d4604c599a998d3e23c440e35d2da9389af4c6145a33e6210ff15e88034d8b288f945fb2a6da6b29cde3f8482c8fe7f21526745dbfe8d7fa7427d06a1997b9cde81bc867201f444e69e689d099fecb8acb10cc52f14fdc5197ff7cb7f5933765dfceb7fa186cd6868fdae5a8290fa4fa6bbe0c0add509f9439dd65e5abc646c3b0705fdf2866ee382c2077ae46ca72716d3f7d8c623e4f37b716c005940c940588a6d6caf0b470815f05f37640425e74976b30b088b0711f774662d37f77a727b7c853d4923ca94ff6c0921a78351f16a14732da61bcc1d7d31b95ea8610e5a8dcdb35bffda732cbc3730810e678b01ffe2e663aec346c25edeca2b7af738e5d8aa51ecbba8263b7fad1a2ddef4a7bb07961ed395590165c8e8a7c12cf82c98f0dbe47061102688451e6f87a30dd9649d9882da3c9cf40bc52b8d5df28b66fa74941062e6e6276543f5f4af68e21cbd98a27bafb789239ee3e29137b72243ede925d6b7e2dbe5f247a94d1abefb52aba575a41f909a1c484ee94f996259b78b3a3b837fe37ae5aa8223f8ec8e52fbab50c59bc1fa661ad82935598c1264d207eb40defe30d35633c4f8a4916ee1aa4c179f9c3f5be1001fb02a58027208a46d7abbc56717ef7a491e3d95f04188f05ca47af84c3753245d45089525b3b4c4ebf57b0cb977f7455036b4ea8f4fd003f77477044442e607b0b8622d0a5029a603e2093564bb5d15f886d56a7ac1f4cac8151d573102b28d9fe75d04417eea24378ab4e46af599728f0ac3909463509af8d820c1730ca6146426c354b4c2580b7a10fe0732b3e739e70c13f45040be36d4224c7f20c29cf7a89c2c1936ca7a9218d368da2890525613d48841870e5e0542c611a6e836aed2bdac18858aeb29ed9a2f319192f75e650b7d2e47bb92373b1e0c88d72859d08738e1ef36389926d8b488add18c4c30ed186056ef895d0e71a55a7dadd4368114e6aa3429c7150236cc2ab63225d01e878b2e3cb5bcba0a102b63bfb7f56825a98e583f57b4cc15e942d3d9e2174bb5368c36284e315b09db35b4c2a9788b6cca67da1304e17d187c99428e8643866f5589b04f7158c08938c38da024f80502f6945423fe9c84929e781b2339cd6b5fde0914d60c368298041064098486a64e2702a7ce5a39ac7203c6296a7ff8b4f8b5b23c7d628bf8c66ed437d76c991d1562c160e040f65e4fbc1b18eac61c6c6b8c0e5b641f116e18d31bde8991a2aacb1dde2857a77721d1df0dcc4da4ed9242308bb2fc4297234646cda2ce4c85510ddce217a359eee3add82ee020c96215e16b52eb00adc190797c37555c98a2223e46bef9b660995dc25b3c2bc084c44ffe03596b824da5a4a814422088a2f4c82bb727c3b8c74e8ca31aa1ceeca4cb259db391cf0443e80eabb3c552df147f0602656c2198faf50846591ce69ba92b118c9fbc31697313a7fd57101c413181a38171890dfa15ebad3fe457d08af3db2243123953e0c0e95600283455c8fcb0beb3683de633feedaef216288764a3f6bfad5b48b63c757b590d11e7f586a614b2658a37c628584eddfba1bc8d527bd46c2f2424dd4041e6e2b3ab8fb6602baa2648cc57eb906873fb07525242ba2aeea4f25b8680684231450dbcb0adf1a54f4c99379f5b91c47a0548f863aa0174da9f520b365e59cdfc64620e342e548f3d5b561c3e3263dfce50d23f54c8f5bb2e9e461791e723d3f16365ff24a5f54f1336d99d56e7356c5401b1bdb4db001447a70ec5f419009ecb180fb85f0d866245467aef1d5ea44a7b619ff79d74a8137554f0e4497fd8b05c0640928d4933ebb1f4b8e1ce19b54c251c5bc79cf9a7020008b596857ca7662032583b4fa040edbb076c991bad4a2c1e43115253f9c866a01d42a925edda1afa809f7009e88abdd2a792190e41cf1500ecf7db7cce5ae46112d06519ed71d01f9ea896952452003ef09c1615df19ff353b85e5b5d8b92d6f94d8a75b2b4b2cd6baeee4f00ebd1d04f80830599fb6724e293509b665cde0bcb7a27ced50e4c65f59b53588b87c4ac94163d5fc05bd0558c8b8213963b1f479d74681a112f2819f74db5afff5566ce1dff62a0393cb41792bde33d0fbac5c34e929e628a3b97f797ae99a1dab6e636554f1c67346a8c8d97d3b52b92e72a888b713384464b7181370b50e8b1a9e3af6c47932bc25bf6d23589ed1f04bd2f25d052581a76cfff7901e83fc74009e622cf11987c480ee29672ab4432f4be69c9523452130fdb46ade31f20a3e7d256957e0eaaa4fa4553b2b0c0980e39facab63b1287a1ccee0188afde693f3e9d4fe71c8e6444d7806d3f538707f96209dfe15944dd3cae972286c743e954125c73b325708772fc889144f8c3b4ac9f59c8cce18a8d65ad2e94b2c6dadeccbe48f33f85a8255405cbf2d8303a399a36adb704315d418dc557e9f544204ba951141f7b00b986aa8fffeabf81eecbc8d9eff6524ed86dd4764329b5bfed560546121110078846be1b3697a4a476274902cedfd8b8e1bd3e071e8e7193c4091a9d7dc751d30babdc1768c4c9cbaba2c3381d06ca134190e73bcdfbd34a0943ac50c7a204a52e467210ceab4106b0df1005c14917bf7d4b7ddd42db4a9d10c769711665776887c839ed875f5c519fb8a3febd361d4c888625ff32b4dea7485e0889c4cb5f5952a5e06f02898f8132d96f558977da7ea362c69947fcf2d0c172a074a2bb3d2a4a14d091b5f1cbe73e1bc3c5e412f0db39748a0c00f2f0fec22aed6d7e19ea578ed04c0be73e03ad773059d2cf9ab1e7442d61bd7048516b04e39fdb5ce26a9ffdac389104fe52afed3dd237b1f42dbf64a3def37e5f079e92efba456a44088107dd080c89858e41cc7923b27fef3e8ea6c34b3009e22bccfd6cfce0ed2bb497ce4fcd19941d1e59ad24a68e813ce355556149cfc297655c2830527be2c41650c16e3315b05588435904a0eef2bda0770c9c3993abe67850cf5a565d92c45661ac5c30efdf0f7f89d64b68fd0c4130885c825636747477e8ae3e513d32f4cc424409cad1ae2d784520178bed13fc3afed3ab000568e5b7116c664c6040c1774bf57053680a984c6365f31191fa1d4d428d9548ca662ddc72c523c405d7b694e8df2c15cd35cdb893eaf56be82b0d1d7cf07c2ec888310b63fca7f37c5c2c1bf3d5cbc8ccc70bcd7df8a7a5c4070cf8dd0fb242007621da279fcb6d9fb78e7d7b04c83b5fbb36a4e3ef5ae0a0bfbca7b93e6fa571b314474cf61be2a36f1216be9235b0ded0cb7407602b53fbd4a96ccabd3e082f2e39006eb52ce252076ae86e0a9b5392d3e887e2baf58a619e48214d9eb6821df70782c8dd86d42e007035e824fe6f543f55de02b7fe550345862523ab25b39d317755534ce32af151bb8ea5cb6eeef31bf2f39d325e8dff4e13894277abfdc1e5c1689b435c8e4976c659479100bd8d4bedd5739465cfcc4ea71d8db043c5b25814c2e072b9d4b7aa9d4d9c21025cdbd78a556634c8f7058791cfe7ed9648815151108f43de0630fcf97c5e3c7f42501e61afe07d5cfc33fa0408ad90aeddb15dd8909fcccdbf33a8936211d7e7a359efd06f58fb246e35041015d704df409ff9d830d9089096e96d23c5ade2ade25a8c29fb510bbfa74e45e8a4e67c25e352d98d2eb65ad26c723760eeed491a089d57c3e831c33a2e881e11496aa1cdce7c626c4f6f6e2156bdf5ee34b01029646abfad2b69bf92d032221471d82908f8047f25fbff167764d3205cb25824be2d8e94914d1c8cebbffbef01bcc7966b507bf1a7fb7a3445bca2164f733182a5a158c4a67895713d9e9563e01ced7c6c88a92521edfc8fb26c45e60a9a0d435eef4da3758905e1fe69ff17873705af6084f2926aa4be3b9b00d80d52df20e87d738c4c42116c535d8ea9fe40b269ca4eca9be3a1ad4458bd5bb9e101cc1d5a1b02dd4814c9fb8647ab2a60e887dfdb341fac24c2c8704359931be7ff20fe958adb74791818d118664f373c33245408647c29c74f9dd5b69c324de0a69e181f3b33a67ece834761f5d245c97de33a3d8ed4baa8e884ee190feac023083afd1a37007bb3682e0a0250c2270e2d91f74bad4991e7f8160f818a6aef62ddc6ed67e20d24b1538cf19d4896eab10f3abd80cb6b586efd5fd5b00b523556d609d1c177383100d055e1c83d2193dac0830297d0e5330d034aff7a69509091a8c965fb79db8abdab6538bf39d8819d5fc3285819ee90825946702883252856b7751c74798538b311ab010d96499c2ad550fd7a642574f1646549d02a9c5fff268ef3dbd153c28920f661a7a8c0f1ecb1f22e9351a29078db8f645d7db43f19e23d5817f37350f2ad5b16cef3e72d801e380d1bc06b37b6b59c9a192a0ebc12f295ab691d1e672c5d929d5ae3ff29193c322ce2d1e43934d488bf36bfeb9443e76881e50db0c1860079a594db3302001b95448761c7914152e70d3c5c3d8855ae862f4c609243d020f0d79a9fdd37c015fe85227ea3645dd2965cdcfcb4cb44ea8ace2408cc44c6b5b7dd643aa4739072f6fafc12d8ba71be64910406d8c096407fbd463734255eca75ffe585b880fff5edd923604e4ed30680a907cd58f18db1ecd054c1008f6c43d35379833c9a9b2d607ec567c79dcc15caca00ec7c28d649bd18178360ac8fef3fab7d2337dd79287402d8f860b8f6289bd6a8739016cffe588536d979ad022939e8fc8746bfdf8bc685d738a18e7d90f4ae000d08124935fc26c5ffd70dccf45aa6ba8d7940f92ea344c8e110330d01574d92714a8340b00d154054e0b00f3d987dc549a2b283859f2e4269c71b3272e9a142f0983b2600577d10fd9d32bad20c568fc0101bd69da5b9295992de88f4ba523ebf45daa346626595c87f01e30fac3e81243b8dbd718e531b612ee555c42bf77b193c4d325341bca209ce459ec92b16b4f66c6b32624c41ec10f4941c33de89dea6ef87dd99f235315de93d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
