<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87aa7c1baf4ca9917e72ca1546f6b6a338fae94448acb788d36429f7e95fbb85bd08fbccbc2b6be6d88e044ebe6babe2eb9a18cd3565198e78a354702c3a2d86f203c314b41bcbfd9ff005bea6e48f371f54520b608a5121f2230e32ed85f3fc9fc32d39a4bad8f5408f2cdabf48f67f37f88a7a1157a3505d4c4ef95b1105c4f34e71a6fa29126a28cd983b33df3d24d5cd15316e1cefd32f71d178bc182bfab75a214f8bc1ad209d99bf0fb3fa7f2bdc5f937911d950b4118d10a8a081ea08718d30d4b1906186a2202f469eb0bc3a0f19336991e8423b1add29150329a7b6330fe998fef26fc33fdf01ae994e98da4610eb20f8c5625c0a5f17cf206e9a62375fbfd8a86560440a12bb33a2a6ccc92db162b0e9452d36eb54727d0527901cf00f610f0893c583823ea59827e82cb686bafbea8fb487015197433c7f8c597506f793e1dd4a6ada6cfc8f2e6b2dcfa793ec972354e369c82db5ded9a855e137987658d2290e5d051f86c8a4c24b9ab2d6809afbc17ae06ac6a2425bdc5051e210858a3e1de41036eabccbc2d5db87b5cbac42400999ec2087c58c912af38179a052140d9320d89994a5f0e30ee233eb494dbc85fdd70b1b513f73278f82621142a0a0c6ba8c4366df54e13d10a5684d9e39009c513a44592290af99dcbc3f631a1f9e7b5d674210e2bb0220c5e28ece7dd79b8f5b5a827c007346549d9587711408c5f171289710e52f6ab949ab4f1520121cb9e0ed3409443ec182cab5adb1b8e3a55429e7932e208a6da83513a464db5a5be043c712fe587297be8117da370528ea262efc8f936583fee0816bea76d4fdb506f65243c5265dfd8ea478372f1f1faf8679cbb14645604931e44fc946757f8623d8fbb309d6d7c6a1da6d3ac5fcee9752b7c99143e1b77ccaadb48b66451f2ae5cb4c0a60a133bbbb7f148bf2c90e7e4574163c11c232d8b547ea30e034816271efc8263b227b2369c90d773cd83593c19f2037c0f04bba585b76b6e607720779f5aa0cacb9710e37ff8f787ab3aac16a466eac6329950af8482aa9fe51fc6b7e0f59dec8c2d17f7d0e39d1604fdcac24cf1fbe81a5546d04674b0a02a56814a063a9206aa51debf102a6c2a9e71d8e4112d1df8d658ec94d02d2c6072db135f9e7829d6afb6c67262771b84feee3a64ce321921a8ff6c35c83a10855678f981c2a4e6824e29bb4fcc69b7ea6ad7a69cfa1fdcdd4768c81a00524d5b05cd2e268b6f1df8718d63fb08661ac4737ec5b8154341fad515032cc7b6d4d8c7b9a6b457ec60f53336ebb883313405229739ed6e87684896f166e92df92755c03f9b9036f4f1d34bc99f53fdebeedbb2b850d17cb1cc9454c277a39afccf9484cae9034f33c0999511a24f3bb72bd1b09d46825e373e4988d64b843c3ba974805d09d6ee344b50ec73f48505dbf5317175b736b54509f413fe6a61f01a062403491ba27f7a62878e4372f61e55b3e1e047d1cf8f92663958abc33e1a00b571fa6f61c8e054df8fd3db63188f901ed5144f8a6b53270141cbaed137e0b77512179d3d61f2d75928cbe8e27549f9c30e5eccc6bd6f5d66040685a4726dc33db6e2ea5828a48b03a6014a7ce9d45061e55a67bc837f73885fe36daf13049e7e82a734d85cce30678fb8bb74735b6cbd0a9010e601814b5941957ffc84344a83646ce2e965a7343088021791eb8ee76f60d159e7e05fcbb7e5e0572e311ade3ad6867b63dfd2e0437863e61862cf56ef773177d17e323d701bbaef48016b2fa1e752e086f2f5b2eeda2ecb7f1b87ab229e69708788c635cab88ecdb8e4a3cc44035d28e42f226cbc713eb5640e1b07fecbba18244552dc86664e636f2bbd56fcf0ea25b50fd0f97d40757f491cc480c3df8b843d39d083f442e096ebad205d99bee3b92d2804e9c1ce278dc67f5ebe0eceea241ec33201c015b4c6c78fef1cd3bc31874c7ee375d7e0083da7500fd768b4e088cdbcc33c08f57df87e50a4beae4e775f8f7afeb7f80bf87ff8e4ac4f8c2721ac290133d5d78f8815c96155a93029d5e662a570e9fd5bc44177b1be74029203b446b95d2c774e4c634c906ab6284e9d0684738904f407dbe0854202f77b0e987ffca15da8dd99523147564b89742f1e25a114a700d3b9f44b1e97fdfcd804683917b12aacec2b5c3315b25febe886638a74dea526987f848628f2fe48f2fb1be3d1e1b8dc9b7d0f40a007740fd254b768380ddbe65ff72c5eadedcd9c40f96fdea13c268e5211ad238ce7747b0b1da44f79840b2c9092d6f76855c2497d4d47f99a8b074a12151c8f106da26e2b79cc43bd5136d9297c6a5fd29eb59d3e0d732b6184419271ba0ac4c44ee64429d31576a590a18a5aa2f4d820c989e17eadc0dfc461def931a6980bc147d6d5287e48a9e73388c3f23edc0d62181e9b6109997d2f94a59683cfba4baccd8b193a47c06fac1b6e5b14eaa8c5c94a892eb445aca470adf9ef90cfd411b4d82ba6640e524e80db312373841fb0e715ce199c32d53e89f05526b963f9932f68f136ab4d509035b709ed7117c03117d80da563efe473db9ba683bbe5f2b2297693b8f2ec5ce1170bca6661da9dc5476690dcab54cf6a54d751d1242d347dfb09b9d8f629c2ef3a69a4d733bd24229132f56e2ad1285e8843d2e9c58a2b4553a64248c55690c4ccf2d18fc70565af5ef3223701a0855f580dc1dbc2438fc19c91998686b698be6984bd0fef88d5d2b99fee25ea26f398468b00364177df9c1fd379f756121d583b2d09272408097f75ba606a52b9b4d9216479cdfed01538941c5d5de9ca48c71171ef5d1cbb1af9f7af7f75ff391cfb7f9e5885c0c6df03241b0bab2b8647ffde2e87d0e4964ad7d5810f9fceee13a075c202757cb4ad8a2741a0a877d6fa6ef8f6c3cc0bc70fb0b3f8adc27e8ffdbb047e7889a71d1407d6b3a6d523b41e8dd5069be7d269b9103576b8dc6cd6729adb55664663f987f68a34105c5a267e4a0ea225d423aa87efec77dac5b1a8ba1c9e4c99999cd46ee8af520bc02d16def70092ee6d35f2b280c184b5f44de1ad7bab7b39d5f07494eae37a96a70e1d313b540f9ee2ba9cb909babf670295e7609c848ecd11bbce9d30de9a4da4839ac309cb7a33033bc04d81aa5a115957cec73854dc93132ba57024159e069067ca601de280f998192040b962164c4452c76a9151ce140ba7951ff8091fba1f68579c0317dc6139fb47cb30b490b9594d09ce834b36b1034e48522632ce84ade7fd4aaad234a6ca77dd620117d41b2105d4051104877ff97bf5a1e110ab4406e9435050a6c512e3a9800fe2c11b753438cd2899e07a6cc34b9d103081fee6115222fd8f8eebd9be7b54a19fcd0e8088362eb3d9bd2bc5fabc6eb74bad3a1ed71d2a05fad364ea41b5470b6bce3452bacf257506f7f894c80cd86dcd76d7e7dc27f6ac4f5f88cafddf7f92165da822da07cd07e8257d36e3d3235b34c48f1261a1c27b63258ae6838f9f6b30f012ae67995a6017c1d75affb56d1ee277d6b0cf81cf7d45b637fd23e8ab30d3a54b3f95020e7898de23de3a0f3c2a3eaa5a2a01690b75647d2b8853992fbfaebd1c1c102582f3dea7cee79282a5c814e40d96840d3e82e76d18551989df30191591c5e852b07b44057780bc2d63f4210627ec68e0a6f6f0f7aa41299a5101b2028f038c9f653a4609fc50d8188bcb13313680a7751d0311280bb21bde51d58192469831d8e8371d2cb8729ac5972b17cb52eaee9a6b1db24f334b4011b82cb067c3d3031bc0002f91bfc27992749fae923b1744b5711fe5db8fad952fa2dd67c8ad4464d9d01d2e489f17fde9728270267f1c54b0c3327e4386b62c858c731744cb2d88dd890acff3fb8f3a15e4463d37999f85d2868000f1ed88f9183095c791eb6361666e2077f00cb835b2f7a8dbd4d3e78c0d4676a33fd6cfb1fc3e6c9ee58db61d12cc8bc54e7337abe12e623146428ab7beaa60235c9f013ab5972e24cfb351f0c07f949f3ec456375c522e6d83a26ce91b0746fc911b7981e05b49a6baeb03a610e4429161d8df22807b7b7d39c53a54a0a1d17ed659dedffc6cce3b807e71b25cceda17a6cda47e61b3a16c0eaa5ab4604ca0008fde2c72e6481a762d17ca1dc63bcdc43d79cb4d79b1f338122a9668880049afe50ecb32f287e14f5cb713c4e7130628e81db4471d8f02a35643e34d68438968fb36397b52b417e4008360fe7864a8bedba4df602c09e2273e24b0930c9f756b527ca6e3b879a4a4316668f5a8a543bf0641737cd4c570c27b160c99662a92026dda4f941236f120da8cdb1dc8b06666438afb3bf84989dc99e875f58dcaaa589b5a48841db9ac193f45a50cb9b761d62d2a262c33513d8b76ca367bc3ade1cf531af48a24104747e51ce12168268f234c04df235d59e4e7296970cd76e4622b7354fd2b65bd7d328b5c0b06141503deb9e87a9dff080fb5bb0a57b19d66f2b9938fd9eb3e11aad978d7b8ac9aa8d88f3bfbf4590a88c9134d3c8abf13163859398ce8c7990fe00fe0a5596b6417dad4c9ad5c53d7172c4d7126a3af410f5b5090fb1c413d325553cbb5b7a99dbf8bcb3e0de9061ccb0d8625642dcc35c819965154edee32a2127416ad16bd868d6caf215072c3c8af6044c4a42549a08d0dc133e9e9095583d1d40b20d6368e0bd2cab11bff75a27ff6561012570c87be407f81e4c2079985e9f571df697ca93a9ef8be9859b912e6bbf3d1ad8e441aa4b971eafb650855881a918af91e8794d43d1813300ba5f9d70383ad6cff00fc759c8d1844f8ea4d714fc7fc3f7d480f4c8f1181c6878aac30c1ca18d6651adf4109b1288b09bc83d5640332f826b26b780d6e06ef2de05436a237896a4b166a8031acb911afdf5cf4fffc3dfdfd5d31c8ad680aec12456e6aa5941fa77efe06edc06b74e8b277dd287f280272b9f414ce5cfcc2fa612e76f02b16767e0f6cbb5bca65461a9ddfce8663276faa6bbcfe9dedfc8f24b97dddbdabbdb3c55e516de51763b955c1fcd504b098d72057b177e6b9297121b149df5b6d94b5652c7dbdc88b377e5cd1751b81304253cb9ec02e20af1ed858526705d71ae06a8246a0a93ead2591e1384a90cb23bf6bbe36af1395e3643e87ed44ff7213e7e6a719a87de20f7ae9cc680eb537278c63e0aef65d08c1afca1593ff285284c37669f84ce0314417603cbaf0f2a8f022dc1e94ddcf8e4a25e9b7be52f2e09422091ede6683a2987eff0706bac9b4e2abfd0e83dc48f7716ce3ac2be48de9e363b49a8193ef54144a0d1992add2d59d68ff6bb7212df86a188f4f62c8569a98da71ee0f1627693796f3a502759e71ff72dd30e8c306e3db640af1e9c2bd631f1368d938f41e3e24cccb3b30599ad80252f087246c7c86cdac584d08debd9edb8fc2beb275f6846fac90db092636e1dbc944546baa817b16adfd17b2de4c882b0554c7d7229c88f3d93f0bccb9fe0b1f0d9ddb67dca1d7d047f7ed332c85fa29eb7f11df50b0403c8fa7851eba306c06abb049efffbaaaf06ca682a396738b5a48532387adb105315d9a36e653dd0631343d2de0e9410ecaa6f5fc9240ba497352e94999a1042e8edf1b7cadad1aa4ddcad5a17d066c71607bcb4ebdc754ad27c9806b5b9b0297921b1b5b107f3b00a41eadaaf6fdce1367fa0e1307d19d4702e1125969ee580b9c7fa93c9489b5d862689d7692fa6ee5be0cae33e8b19e41156b4829ff28540a89379518bad9fcf0a813a9e0668a6a53de622a3249f8d7144f516bf5959e7d20722ce041f9d66fd8547f3b554283ad5df364759d5c2f46ba69bd1995cfbb02b1c119ee998d54a2be639048b9ac7a1cddf0f7560058807abe831cf539669e6bf25e41f551a7d895ef9b09fa8efbd0766af1ad295f500f46b800877ae6e9dd67dfc36d875bab64852b5bd86bf355f2136dc5bbb55f5146c3215747d6e18c82dbc0b08529fc859bcbc74d081fb0f6d334a0d68c44381f8c0ae79b85aa5e5bd02fd956a89527ae275a43797d3098fe9977341a480bca1e5ebd9edc13a69681d3219048a47478e0355001e2c0442cbb09befb5eb05a6424b1656951aaa182fe0f16bb6557e2b4bd2d81df6be4ea932865e2e214302d95bccbf1cf4cb1e5de4fc8d7754c6d2fa9fcc2f24ccad2334a976f025862f325cffa288e35ef662cefa4269cbf2db9b010cf441dcdbdb3ebc229b5c99b970ac39471a298bbf705c3e8af2c20f2d9752c3f6b16421b2b2f25d222fc3dbcf43578b82965ec965234e1376b9c657ec8139f737a71f7298b23e813dd8b3ab6d6d02ac2e69e3dc68a52af6fbb7ccb98c88f1f1233d042e8a6c53ace38516db285e654e0b338c91706141e48f16cbeec94b80e6c37f531d03a4dae7a06f8adf3da233885a6893bb77653ce87e81c85b6fd8e7bac469ea0c72bd018f79c293585ab5893afda0e77e290948e7b7b1beb7329b0630781b8d06fdb44cb68e49c8a28cedddfb2973c9168e50ea65835fd0fbb4ad37dc6d494ae8e7011d1395f55aec5b2f67e73afbba72c2ddf77af5db1059c7da87337fbbc289009377afd474ab50f96ec2662df9e7af21efdc93021c074730c2c60c3aa1b83ad2f8229a17b5958822b2ab86c320cf57d75d455460e6fc1a87b01d156c0f68dd34ce1f4b06dca9a0dbf0e3b805e9aa869137c11e845742a024beecf9c98d01cbcfbb1d0917e96ea940344e35060ba68ce620eda0639f92ec269eecae186588c393177ebe61bc61e980c594781c4c06de51676b9d1adb21ef4f465e43726c7261106988b869c52107d23a482d6eac0ea5f562a204a48d40e5ad47a26f42888c44f96a0fc34b3f5018b20c6c240b813dd66c4cd710d008b616b9338b6a5ff711e133ff32217e2a16105b4cbbf85f1111591bf7f566aa18d6f4062e4d87b49216a13e9c1502ecae4726feb6a3106ba5c04aad967ecc020b2c18e1aac67ea7327ba431769df7854afb4a4d722df455ab58fd4cb6f9bff1f88576b01bad027e1a8dd122429f766655762adc278250f4a97bb27a679d4b40f9776f2d9f3cd1e33f5721b569109264ed506e2d469039c2a13cea1d746f22543f27d18507fd57e009ae5fd5bcd72d3e4779dbcd5f4551fdc584ba66258ef610ef6b536aa7489105d9d56f8fb78b1f936d1278bf9763ce0dac30be2a39e9b64da6b5bee83079da2363e80a71972c80b374f2af5e34d8778187969bc416283cf8fb1d882d8544eec0fb0f387a9f27f14708041ea173046d1703fe4e785d0c6e9769904e52bdd45333b978e6f3ecdbc329582dc2bba11d68e762d0bc3b1ba01a49068d202723f25e2459d31110dc8618b1d8c99f849b73afe29fbf96c507e515e7b811ef49044fe189a3d252da0be13969eb2a23523f831728d014f4f2bf1e9f20c9c6de91282d5110e3e716a7d65f76fd0263e44567e1e6a4359c5532ff80bcc4569157d0884ebac7855453dd557669bde94e7fdb962dd39c8120a74cd213d1d96adb3d5932ed714ad0ac03b35588d67d5fcb2fda971b54ef0265f0b726fca97b55a551b5cd9269fc7d138057074b96c3c7eb7e495bb10ed12a3aaa65ad5f70773910ef302ffc4504901bad1add4ae3720515ef9d78490370b0f64cc7a9b648ed3cd8184972f4548b58fd96b011c111ae0decb3eeef8b56514c4c190e176cfd8c93f5676f60c22a31e129fe21c05247461e96388f52f4a09866e7146a32e98cfd0b48a4338dc40ec58b0f52dc918231bacd555fa288d68c83b790e64fe491c9657fb0f276092ef8e1d490c1e759779b79d4106a6d7ed956c674d797f5cb62fed7dcb4da0a1940db0209a89291776e338c4638c8ccd210b097853f45dac134e1ed7f81e3575803f355b5629ffed1daefed860bb904f0afb6738015ad4623b4fa56f877cd20010435dc4fd8753b1fece103c7c6aa44ed15bb47f5101fafac19bba20a1d7ea1c53baf33b0119be76dd9e54f5c5967bff25746a4b654f7b731fffcd6e40f13007111ba16122f9ed324f18018320361667e389310357ecf0ea6298000e27bbdf3d380e5d3085b96e9289a7fcf776b4195b6ce470721298110b9c9be4823f1c17cb9baaf18ae2d4d92a133d76f1e46ab258c49273b7d26dea33d4db362f5c24e56017432947620af1e828ba33d6497a27a79e0209fe8869905ebc3a2d6f2afbc1ed34c0c26b29536b58d6762c5d2ea2a2e9f59337463dc73659068ef9f9905000252441a11c6c2a11987999f9fc1cdd93884e0eb7269a30f43a2081a720c11841f8142ee154fce92d6481670cf30928653617c8c46a260cb5e927869dbfe0ccdbba2f8fdabd7922c221b85cb012f5d7462dab5cc2d0df5695bdc4d092b434fc1843f47b416924fd60383cff6046d97a1261ac99494b4fba343be3db33cb63141926f6f4f20f1f71773b4dc8fa64c77d679571ab829f94816bd1695ef09e1977e946745d02aadf22f7a5ee9e17d8bc7aa01377d43331bd3a1cd1bc20a9ae45154ff0aa317e400a8d74416eb81965957cc9c09f99e96607970f37cbc8b30f4b36d1bcaf44a151c488b104145f349f48aa52778dde86f0089c6bba0c950b7f5948817e27ef609fe20c147abb8179d2af3f36afdf118e1bc4767e4fcdaf3038a1411e1156a09481164a7738fbb5dbb2223d72a965afedfbe077ae2922e17e6f5a9cf99f5c40e7c3a365b1b3fbad86bb660c3db48a12a3e028815051e0883b8ab4f58b9bcb3bf9e122c98f5e8b77f577bee9a9474121d2f7c2495e4362ba844911d8366e4aa920382334ac0e3ea69ebf6a6f42a7098de19c4e11d0bf73b36a620f991dc1ff3420155e571b0ccc1d79f8959ffb72e8e46ffba4a5a35724ebb3aaa303bcffb1dde4c080f1775e5ae68cae587d8686ccb860eb7512c169a78662fb9a43ae5d5fd0b58503a50fb567819503c94f39de432e96dfe508367aa8aa60d10bc8957b1001b21dc928d2bae2e226857113d81e340a5fdadbb2aba2eda74aeb756a9cf3e08ec61ebab687fc894892e07e8d0b788e2c5a217b6fc659b528b6c6fcbaf35ad21fe7e22eccd50a65fcbce98a55517bb1e7a8c8ed5b959e50f83a50dc772b154b0fc3c2a302e0ac2a84c801d9807f896ee2828691e2be5235e7182b6ba89809484c15e21c8ebde7b23342954fda4af85f53696199cc8b4d326666ef9f808eb6dd232a338d67c2eb9aea4ba5b29cc486d192a5cced3e2cd62929b643f491ce94ec570ece677c45c028b94edb6e577a61115f9819a28c484b80944421b2ab8ff5e1e919a33927bc32996579192834fd91ccca66c5f358be61bf598c361d97825477efe8b8a7b72197c380f04d76d6e40ce92da51c2bfd770e9d0dde235cd1c2c29441b7a05dda457cb1f743dee5985d602d11e79a23742b4bfde606802bf47421e5785e61fd436bb995ae1fa84ae6b2f93d7bf2a72d76b8bd849c3dc03b784a8ccba64cb05cecd381371a5520ff23f3b6edb24c64230449daaac39f522fa24f7d45b8dbe28d22414e04029eeb25ebf086a65d38d1034d45317aa99397ddda300e6ba0b368319545ca8cd52b3bd81886ed3b9f12e28b45ab905782601b818579d3fa1409ad1f27e8039a36b464abcf660a033920e671294b60ac548249a7495ee54238d3eb52e860bb4639d754a6338cc7705ad3527e1e0ee10e5d780eece32ae37ab74f32d6318388847fabd66216ea02fe5a019366879d2bab42dbd2ee4c943b5e81815b9848cad41c3ecc7680cbfbb74ddf7e040dadcd3b19b0c64528febddbbac41607b7a4258fa7d9c506bad362fa10a70bfe2447f024f5e74c61ecb5028bdfa72ad6953d0c2e3ec6e7d00c0cb2a2bcef3f57d149ac0b751bb12f3ec4e4b9d1a63d64fdb57363c49a3f5cfd8d9e19ad879a66f9ef9a4b7421b8d487f331706e88be05b8cb05a770bed864ac191d1296e4fbb59852452473c6875419847adbb0f060466e88dcf30a1b5f24d2c6d9a965b862c1a8789ccb1d0bd2909a41331065c3dbc2e0471d4767788513f7c352270ca6620f309ea82192c18a65329f436d7e986b5204e132ab12439610307702bce00f27abd162f565ac1fcbf6e270885999ccce46eb98e253100d5e28fea9e092a8bba96c7b57490dddbe2ab15a282ceeb7e8be420fb5558325a022a9dcd3b27380795d3aa9884b830daf04fc37f94b9051ce4a42277f5212da0f9c834fc1473fba38ea1c931bbd8d37f76b83e9ebd36f38f9b4f04b69ddc652a8348e186816ca233ca58bdf984c712bcb9b223d4d5a810d2777dadd422728d560dfcf52e3f933e9c2355a9fe8feec1284e59816342b3f953389a44c1350a9c37fff1ee45227fa4e7c5b5c898cf2506c63e026ac5767969f17ff89bd66a514965b0fc212bd58a6693279277a2326e1c8d7082eb1a11e155a2086446983b215b1404a9791467147840f81eb63ab0204836385eb2463a25d02de2cb7516b5270137a9b6d61a5d44bd725a2fa86e6abe1f24871d1aa2af3af2544e101ec985eddd0658395b734146929ed79bfbd12201fbe1b2c4710dea8d07cb575845745f2ec0cf4e6a22d280244bd7666a30c14b80c55b9cc30bb43f188ea8cc590a61d334d7ea451bc75caa1c2431b9ba19f3021ec5482a81237ecf5f10b0ada9ba59d5e39e3ec33e5ecde2ba78b059ea445bd6a0bf796c26ae89ddea6aaaf162d74deab25a0df1459e4a75361a382c8e6df7733acf8657574b6276b571e555ae06ea643220ec6f48a3addf7a77ca829c24dcad54c0c2bd9bc7b232d0a7834d18e09a9808de43742b18ba67ed58b6c600f41c43c0a5f47dbf698edd05ee334a5c1a7308c39f2abf18f93a4398f5dcef4c9339bb6f38332a759bb19acc451ad5ad9fc620afdc46fd4c4aa4780294de197ab11fdfe00bc9784ce657f7dbf3dd406b3689a6da6d3040a5dea6795adfcf6329fb44ab1d2df9e07d8bc5e53bc135f6497465dddf5881972aa710d75beaabf260f58516fe84fbdc66cd46e7aa239c047c55009658cb01149ed3bb3ed2694af08635057a2372a99947d4f54a1530bd36ccf9c51f2c19de551c91cab32ba746c704214c39727c04e3b17521e486357d09a57ae07fce2f275cf0d71829d0a26aac02ae0f71d04e5dd3bd947f899b1fbe5abd9197db6f9619d4d1538a6663b2f8f42371d3e7a5d61b06075598dee8d242ddb6de0591b650b45ac6d622a09330bf12a0054b1336cc8a3dd6ae8760b7da34d2d6e1cf11d02a319d507d15644f5d11094e38abdf39ab6b0715b3b27b889c9e2dc2a0c97591d6f1148f2f9d7a4edf10fec1ff8effa61e400424ba1e9cc74dea89ab49b17319597707276912b2c3ec514d88e866964d93b794036d7442a9b38836ecaae5541dd9dfd50a8c2d0a658b64c4380caf25859f57ec882a3a7319ff4b4ac3eab3f28ce7e3d9f241f87dcd3f2c1675bff0ee0eada8a40b53c1272af4ebc7353e1958bd66a4529135a1ba968601147c34539b097ee8d1961a652d3e688ba7d630276153e3dd53c62a8f645c7782fd30bc046a2a4728d571065f6362ef05308d512118b06a5daf9fcf7fc48a32ada08922290522377924ef215cf16bfb5a53bd7f831d5f5456dd4c945de6ec39b2517545762c31b7007bf2d41ea44340966f4066e0f54c1c37ca6fcc8f8bb62aebdb538165d2a44769247ebcddeb5826accc94a3d1d9c16482f4ff1489851fddcd9a37a84c1e93723986f5053709111418697486b134e8e0440cd86657982a76e973473d12e54304d299dbd0e6c1b7996d889005409dd59bdb45452088ca1312efdeafbc1512b249d48dc9ec233366e333f9fe9475b3376abdd7c6b51c9e357137953b225d544240d1bf0209b075c93ceea81ea6794559dd5e35392b0bc04afdc41881e00c8429159a875797f81f2713ff2af46b7edbe0c1e428ef5e47f86cfce8c9e0e6a44d26cbb80fdfd171962c2a0a77d5904fba0cd33e44d5b0d046f33da499c41d6cb002591d632b25936a03f2b1189ee7cf2ce1ef93b53412eb382bd3fdcdfd30b664f5e25f6e7af096a133e8341d898e0e40b54f41c30e11492a64747864996cf8d4d6a254a52b3af61d827588c5b060b2c14e36e750713fac7c99df80f11fea61ca63ea395c4366a6a6bd5160dd5c7a7dc022e15335f0d17ba23b64f5396ea23e84402677fc4cf59550c10b7a300e989fbc0f8d018c6d77b20d0b599c83eea71451bae381f6e065064a29058c735d686956e08690252275d1d6e774b523e34e4fb0660dd3c9c0d4d4350e62af2877bbe1b4adc65729e5542be98ccbb7ef1b178fd09055e7356a06964f83012f572f7a12a27ca1453ee0a7b68fb7de075cc2bd198659b42f2e696ec86b8411c24a362b04e88981c2a15ba55d18dddd2eacd9ed002c17840d49015bd5a40d50cb174da70cc3cdbfa8c806c6dbaa8e2b406bb2088fd4b937c26d26a1ff7f8b286404e34ed8bfee64b8dfd603b8b087f2b5b913ca91300d735a57e5c39d26f20e0b94b1e35b75ace02fdd2a0a130dafd9abdf8cfb8b06d06df3881c2057edf730d4f103181bd70a84cee8897f1ff33530c791532611e17503511802d1d7ff10e3158d575ee37cdf11a31021a936c889ff81b4fa6aa23ab966e1721c97bbb00a01a6c8e84b59d63211770c00ad439a2ab880abce556014761884dce7faff67e301e668a57752eaa09953b956d7ba619f85547c37f57d8ec70fa0db4ef31504a5ddf3f6180df22d392c7828d41193e29b55be139217ebfe47ae71d8b501d746d1cd607560fe8f507c189c5580ffa2752887c9353ef578cc57213af1d93763a87c7ea00a6db3fc651c626c5c49f339704283aefe0752f8f5ee4a2989da8741a0dc4a1865273f09db46ebbe35a633117ca939af8f4db1e11728c9e8f6b98ee6ec6f9f0e679d1c4307f2955467120fc5c7adc1cea0ef9673ee81aa1d48cab0623a13d23e9deca230ecb84a82096fb1deed34088a9d3027c31d4f0e7986f2f7488afe437bba0df0c346301d8e244b31006619ac7cbbe77873c400dbd55d48454cb4afaf5b40adb57f0931498c76b564cae0fcb146a4ece0a161eb293d0324790b8c0366e7e9c5d59fd147e033e0e6a0d886d1523b0e98c27ef761bb1129d877117443d9745e49f24bc198879e580431c2718253555fb4429ba4232380c986eae17b50f3c0f470108dcf7390b3ef1308b58c723e77ebeb1caef788ffebed5bad1a95f5e4ce4e6183e261671769f97d750c7552ac7a5be5b7f49e163b6b92081f89dff29190f7dda9eb918afaf18c4bd46a3ee24fe0392b2c9fd71610789f6d30261529c9678b2164d994ce7fe793ceedcc44466b234b9ed6d807c2e2ff6434cfaba3bde19bdd54b842dc6f084a3f587ee0fe16702e7e1efc01a47c54556a92566816d66607f6750540184bebfd98e3665a5bc8c610e66bf445a28f41169b9f409b0e0cd1a55d79177e2deffbbbe665d6afb2815266fff85c03b1c63996c57d85f70725ccf7b262dac4d724185035273f3203dc5898d754697f2c005bf15de64a45fc57d7ef93e1f019b1b48d92ab40bb2c5a59af5b0b9cc1a874743e03e8183bd87fc9a8d9bb04431b6c4821e3473e8ff3a3c84bbfa007629ad8a0d9b69baeb0bec58945f4c93d2470bc7c40f9643d7ecb5137e561612f463b83e91d1dd88945373b0ada4b8bf634f1a2ede1083c6986f6f333cd75029352b439a082e874796bf1e4d1146c84c7fb210ba659dd828965c00e35c3a1707e1e27cb136b0e77a0778bf45d427c63f0fc10a6a35d0ecf64b711c5db2f9842facd15d60a4c348dc55a12a8219e4f24f6c20d966abb3cffebf6dc787f50235cba64baedbff551e55e30a14cbc71b395d5a3ebcb79db8cb58fd89d609e7d260eff36a9f835ed23afafd4114f2c787ffc91a38c79a60eaecd01026a16e1d7b264f41856656c7af064b037be9993bd3aba94b03372e9ed0a318aea72fbca9cb06481b6855ad49cbc022532170368cabacc55465cd88e277fa85f51cbd514025e5207d8625c13592d6253fda6f07b9a761c9bd5cc6bd77c9de8e9e445b3fe1c4afabc99b9be792fc84320d47148acb9c8baae75401ea87209a15186d22e428ef37bee59563fd1e90dd90a1207b662bcac9f823d16572db467f29579a74131fae07b9424ac8c3a10b19e37f853e083239dd85822677c0416b4d798f2cbabe091e25142eaede8ab59534aaf9d4939f02827d8654332b23f3a02d745ecbb945661849b86f42735503f7cf2ead3a75746ec39b179b6aec12644081b313929cb315d633a7f9dca1bdd357bfe5cfe39e1b3e801bba40e0d1cd2043e307180cd5f5d7fd61d5ce13d9527f47e8f540c320f4cb50d6c9550bd8b3eb9cc866c2b2d1477c956d2a924580073d150b0b8eda25c18525a1fbd284a12b8d6e1220212bd079dd64e1d6764d98ee3c229f23a40f6c321770c7538d3a70818b661c5e4951f3c3e7b5dae1f1de1070f974cdc3a73e13678d4e37ff6492da2c97c5dec6f74aad7b115508190e8847f0f48d7c5cb494682a6d682d8d1c07a3aefd6421e3383f4449e6761827deb1b56be176f46fa6b9aa8241ef02c5e643f52c2645a86c103ed20a0399bad5df8434911d5eb90f770aecc1b413404f8767bc2250505bade19450545477a346a80a869adb6ed8b73d003797127e0257eeb8dec14fc49b5f63345b44ec6ae48d7c769f0c829ebf94b114d514b6e6fada39f4357efc7a2ff98518c26e79c7c84a0188d281c8b24f33ba90d7aea207dd3ed4c9d44b2e288d0e41214f52575159d3eab75b47184b8fa427a0d62f1e036c59001eeddc962c82a2246ecb14506c920a78fa57c9210698123f07728094e2a3bddf2031682f3008e556c16909580384d4c210ccf543bb85bbf6825e1c893eb0983f89b5bc0c7613d9e9fd7362532bcd3796307e6a7be6ddd1d09801ee0fb8e7855a6bb873e2a1342983dfd09da2d17a42d80583e959145fed54cebc929f5e4338a020fc3edcd9d5ac0223b4b09ef72ca90df68a1713220975415d95d254af7c68f1d34de116afb2f8853644ba5df153c4e65fb6ebef47db39e245e874afb46c4bf4dc29a0da910cb297a03d8c87a08e1c09be4a1c43f2ba3b38a40ab308d19d3660191d748a74a0e883544d64a5018b5772ae3c79a3e77853da77e44960b3b2f500fc8e892abeee9644a69fd1a2d7873b8e68b08bb4e830676c72981f80fe4c5c0421f184ab63bd9ff79bbef58b71b302a433277530b198314cb36c2716d3218c3d4307727a11aa398128dd090792570add4a7c5af17ba2ed628db6274acfc2c3e89c825594317906647e599b668d35142ba31a6ee542c67ee25ab247979674bc57f2ecb11ede1e64823c87cf72434f10489286171c381f87e884477f90d81b7809b1461f1622ad041a5490858c858440d6fb881573d28fa93930fa7f0115881fd1e5d53b6422d04ccce2307797d515638310afdf63c60b54b4f42c53b276d552655549a5c0c499bd5fd1e31f748a12ccefe79a1400602a1676452f0dc53232021e0772d43ce88f4222aaa52e64ca68dc5f3b72a59c4977a9061e4ed37075bfaf5845b03da6f7cc3f8e7cb9a346190767ee9c986e9bb6589d1c0e7ef963be9918c2c1c64c1ef331b33217535a5558228be2677e8997baff31555ec28292726df60562ffeabccd78a2b5cbdcf4e027f0b79a57be932e68e5c036dc498c34ee20afaf65d9e6220a45c40c2f83d34852736b7a4aab8b89e7e0b1a87d7c0afea14f0c34a005b46e7bc2800b11fe6a6805d836fc3fcaa25af6af9ad1f23098edd33ea247989961b4b31301a53a6093b1240f996ef1fc5faa542f266b4feccc2e8cd9c088cc2659dfc143345732e8f76f2eb4aeb43ff651bb040570f9f891d6f6fd3afe4bfb1d45941a33ad2c754e505874bcf853d24911a994d3024adab865d927553c3cb63cd707a314b96bb3847575f2ceae7e68df73c7b614c0f9215709f43cac7dfe798ba210797907e93b1a019ae9cb160a8a4e9e177118584715f52ad1b4a60f3ea52824d857648916bc60218373dead114aac8857cebbc46f1a5a8f0659316c04cf34950cd3f6350395f1289c7bd841272a151b2cc1fd62099b6d8e6d2cbd4434ab4b8433be6c45a35e938a275ea9d82c997a6ef92750f4241374cd0acf04523608bb6d7e514fe97489a44ea67e01e3ec9cda0b119eab4d242644aef265d138385bc47dfa8449a4492848e3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
