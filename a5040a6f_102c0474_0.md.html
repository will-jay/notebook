<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9ded14f13553ee0cd81675034f7f5ca88a3e9958e16690e285d76e2456aa932adbbcc3644f1a56801b5a3e4c88260a91a6ac802290a7690b52f4660cba34569ae91ac5e1738342fe91a0f99832b228cb37a92a463f4af7220fd0f72cbbfeff9f3b9b5abf890b216cadd91325b94545ee96a0a1ef39735982dfffd5dcee819ed57a242dc65276e3c1abdbab13d568eacce761b3fe15d9bae305b20f7049417fbe26a958a1cbd35d65e2ef78789545241ee5bd9f24ba4e61c8db60799a612d99b99574f15e6b61470d5b16aafc70f50af1ca78bbd3e2db6ac5dd72ad14f19267bea5655809ac4b670f5b3199a3be7f475eb6c0965df1205eac19709e8a5811a88ff24b1238f5ca28f83730c20f6b8c14d5bb240d0af5c8d2b4ecfddafec745082717d9f1329569c8ba5a5b9f297ea6094e2c679c86af227a12e81253401a21e9b427cbbb6e82db9a33dc32c10ca7bb4a0c9442f9d55da7f8ac65e260cc48d0cc911bfb88911b91ae6b1bcca053b8e6a305916fd3619182a0f96806059ec083ed08e7bfe099dcc7705e29314f29e17671a4153a95633083acbb167e4b097326e8c26c25929f7767677d101555af663d9e5241ac47fc834f2cb304c2fb4ede7d3796acc9960e1026fba646f3134c21ed0f30c065c0d57efaa2889c412b11d27d041532612db6df6d227586927a065e49c88c2c2fca9b7b979b2b19356317557680e0c63a930a341c9233b387f3716ac8d1771d18e62698a1d0915d7dc98818e8abf4444c5bee1d331a0c1e998a5fa158a87b05a4fc26df79d340089c1b540906dd0f0b922ee2d7b590be85df129d8db1cf80c9e07e3728311078acd74943e76c7916ff410fe3480c4bf0a23578e2a1e5269f0475a68ff926c4cb77a29c9192ad6c4c5d0ac688a986ecae5ae5d0c70136b8f30ea673a772bea06369ccfcd009fef20f9480b7092749ba0019d13e784bb8d317d6282c2c85e5a483d6e4d5667c72a45ec0df46a1a611d06e255070ce16866197f20ae7fb4e8185bc49116b90abf156996c0e025156fbc5af7b7d1f12198ed9289598b4ddd6a9fabd899e29b43e0e85215583ced065f2ae13667009f76e24ef08856cb3de15de30008f7397e93e245e01e6d0ffaf998dcf3fecc8a945955a903c4d01a9cc350fe524c44dbd7e9790e4a50998922d1c9079591e5f82a5b6067188be52d59b7ee9ffa63abb0ca0c51961748cb547172c096ca2762355f98a36f9c89694f4db8d319d419f1c9f87144f1d6811576dadc812d070fe187c5552ac79c7290c2f0e7b7ecd8af9dcd9269cfaf5af66b604a6100cd670e8bba66886756e06f7f95724f8bbe759bc4d240f353bb1d9964d321b70c4606c8b08500bfa6d4237ac08f00a99207c9cbad4341a455ed885407f4a25c71270fbc1048db3f4463c9edf3fe3a043a5ee67b2881d998e9dcf3895fb41dace75c091a3dea6dc5dec0201f285c0d5e0aa72ec07fc7ac328c14bf98fedb5fbe8e6de50bf304e038ce2ef8f584aef6604263b0eaed054d376a71954066d0a4aed7c15cb4324332b37030891d2ed05784bc92b9431d353b0742edfbada890fabfee7c6067ee86b247f3b09ba08c97d153bc582c99204ae5e64686ae0772b66c8b147c17aaa828bea21eb4b6bc7e3d9c55828922909c7ecf7cef691b11cc34e05195faffc0a0aaa1119255d915cdb3fc28f4f3fc9d3f4204e4af9528c21de982fc56bba7669132edf7eda7ba3a809c36193346fe3b8bc73102a9a766b0a136ecba03f9c840a1ca75d3cbf14eef5fc83fc4970d15693b3aa7b2ee93b7265d1373fb74d825586ef268426d38102341dab059db961fcb55230ed7df3c5c8efd7e5fc082005ba93f2004f9a6fc9d597d0eaf1be6aee713b40adb2d84ab48200793e93e4ac2c58b0b31f9fc0e4af1d60bac8d7b80dd9569c7647127c35ece5cf918515eb3336d565b6025ff93eb4c47933da17731b7ccc0809dfdf3f4a9e966140d14a8b4861814eda40fbbb64c1827b0a152d099f9495a06e2028dc8cea42e03cd3904a04e083f9698a2d03e2ef0d9c829e1cdb4e259cb40b64a8962d11abd24020f1d7e83328367df00718ef7eeeb0dd56838ae01c5d3b661693f974813b18621825ababe79d93ba13de1ecbcf815fdc3e34b1c0f2fce4fdac88f9c496796dd1ef461eeff426fa26b4949c525e365efce121c5b69cc35bf5e2f054577010a1520b14db280c3e5bab1b65589a856503adf24fcd3d476895fb0a7613edeb73ed309f363bfd365cf5e4e56173056a0c3132784d8d1b5be00afa49353f425b3b84a65ead068d807f1768df8cfb89c90d18af317c61031459e5c0945bdda4cdf589a9c20e30d7a06a75bb1d70d751d03ab9800fcdc47a1dc09d65cdeffb72be2c26f2e4d4681ebf176106bb055b5b14695a37fe2d843c25f15e9f7590114ef40c4a25648f0f5460ffd9b4a8352a6849020917b7ad8317c50a2370829b60a9c7bf74c6fb17fa597cccdc262d8dcb05d1d7e5d8f5da84163786fe3e3d9ee494b1650dfb0ddc129a60ff075f1f09f839cf5c9081d9f62c7fd190e601f1bec06988f0f332665cca84e2a5c2ac5a650d8bd29d47ca5bd72ef914b80385649f93176979c967b5dff428c1b639101eaba4671ac04d4c175c9b65d558e2d99a42ac815011c5418426c39ffe3a4f7b6c650431e5ee033b11f5a5d6069f581ba559d80ac8e93fe4a9964081754edfc63cdfcfce7e0ea432980f2b279cea96393f56b2f5ff89e36ee7144f0d26df3be1cd0aa917e7360d5eac3521cc5b2f081936ed43428f79697ebe7193e03e2e329d37136c12f8eb595515edaba57cd88194816b44ff3c4096f1d0e6d0954c29be7445098e4509d4a949afedf9077924553632b9c5ae3a5ae43ebf98b691bf1891fb12de2704e6eccac91466385e1ebea87388232689f04bb62ce35142f8d4166caa1648daec8cd49b7a88b7b4bacd2a69de1decb2bc22b387cc5470d79f96460702ff8f12e7c531aee1f13470ee98c8900b2728d897aa6f303e0dfdc328790673eb778100fc43d06bbb8c8a1b214220587caf7cbdea035ee03d4366eb1c9363adf6c42cbcfb76e5b3aed21bc5806a7208521dd26555392fb73df68a941a22e3041542736b759dfe9ea1df675949c8aa854bf10c46bacdcf325fb7d894ed24d6e0b276a44fdbca625618a8e945300d94a56ebe240861ee64e9fb135920c3a5ff7b22140394e04552f70ba7a76df4515054c9d9af907ba5dcfada029a98d33dc3d1097ae8720420c7a321b64437d20b0681383a5903d96e608d3a2508a002242fb02a9f6fa42b749fc5041ee207cdabb5a5fb3dfd42aa38d49c6cac54d80ac0bc5ea1a73b3bc91bdacf7d17c26082341349ba274d8687066756b4534d52b34f106a3a5a362128cc0fe9773c7115319ab7a6491a1689ab4da4ca0b4c060f3a176f35c233bf52133ade4f82b482802744d8d394a6030be904b9f0fe47449d27a09aadb723c0898e106de8f235886b31d2ba72ede91dcae0666e66963ef9f96d118c8885db4bf5cbc966ee2afd4311a2e687e8ade0db8f0f89e7ccb8918869a338d47297c65d83e998b770b6a549eb9128612af888b4624ae7d45be3ea282c85a346b01a4ecf8c868520efac7974172066e8a032cc102e9afb8a5fdf1360bfbc5088782b4fc40bc7d316f62d0a0ade2521820c4f4e0b3a068c8f863982745a80f0e3597974a901c21240cd8409408a9e7c2baa5ebdd5c3f2f7bf83e764e4e4947bbd414fa4e08714e81e5dd5a28b5d5afcfab82254787468d85ffc4b1800896c505b6e786154149d62d128fa52d9554ea181a43d19aa995f918887e59691a7724cb2e5404e75665471f4727456e30ae48dccc5ddb4ac12e7ecd5b57a5ae39cc832e9d9f9f68c32f59319c9b0916da282d56738ca6aa67c5bb8d0a353e69f9e72fce6e4bdc106f93c816a5d3ecdc450216a3a70c399a2ebc27f10f8b36fe0cd7ee33052d9633f708b68816f5b7b845b25657fffaad3499e9f457955f5e5b3e8197c355045bcadfa679a0d854e8efdba379249557f44a84cca45f1445b32c3e916cf27d5901968d3913cfade8d7a99addda411a78bd55ee51eb00430b73ff3ea214f19b332a286b8ad1347f8f9c1b4153c82e7382c7b543ae2377e6da1f133f96f60dcccb369ea5d937abe2acca4273463d117cb5df51294b261c82ad9cbb3008714e381ab21250b043e23e0fbdd2536ec05b77bf3ff2ea3b996cb08041c8aa0a075feb48d0a6beca722c26644528f38b24e933be3e6656a2d5f40e7ca19f7db8bdfe0a6507d0778370f6fc895d10ff7ad03b32f982a96a0f318a708af50de5a763c807ad1113c5aecddc00197f6f14fb4205979e11f1fe22764f80e26c7d1a02e2ab811a412433be00b38349d433cc04d422f746678d87a9970874583795ea522c70f2d21de7e00a303b6cee9f2795ad4e6897beea5c5cf58b7c3e8c4f798b0806d96ea1cdfc85d17d863e4ae3395cda18543d9c8442886fc47f32c98a7b8a523884fa1a0cc14305d118f56f16c1f45a527610e5cb8913bb822c91f617a0f68e6cb9ea30bd6eb9e5be55edde6339d189248f3101943752cd0c2631841eceea1ebb2fc881d69627facf84ab100adb4f5bf7f0fb8666a3a6674a106c64862a595b8f98796f2060750c280a950d35035276b50f2146d0671241958e30095612811401c2f5d69aa4573546eb97c5320645aee7b88d04df566842af249d231f4cdc64a8b8eb7aabab3bab2b6de57a47022abae84131e861742bd6d5a86e5345ac82d77d4be307c5ca409b8f8cbf159ac368785f6a746c7b8efdee1e59f3f7580a063c90436f743cc27a0db572a44987b46f84eca2ff45e9c159139a68e125cf430ab1518cc98093433def1b24853fa0123baef4f385c068e8ad8308c3bd2507dd08173ef8407b1ec42ba6889091f37047999695097f9800564850a14b45943456eda15cbabb27b569d732982f29f57f464812916c88ae6b06295a3e38dd6abd06e48b9f479be3c60aef22f6bf5679b3527c00a4abad8cd0bd458581774baf0a6073d7bf6ffa0094d0abaccee14dd77132a18404b423d8fd31b01fca9552dba5f34cfc4e5d9931171604d929f103e4c854bafc6286833b87184cf61f9954ee10615fd7bddefbb9bcc90bd9a7940cb32955a6b8f9921a7402469c788ab0d813bf671777d71a162d3ca04e99fe346eee3c5ee0cd52f0375aac154715c444010bed7363e63d49b9a5192ff04b5a370b005270a1d62b8bc26613cd8467aea21c0ffc9203d59e5b23dc6318ce9efb2e9f6dd7c7773542ef44ccb95a789f03412ea1d4f8d3009612a1282326ff053de083b2ab5f5fd24ff54d451b8cdc4fb161b5b2a5873e01497ce07c83f04ce52391f4e42dacb86a56a318195f3a48d49c241043eab84149deb37f1c6e50b57f3359c9639d14883ed5b44e9b43b971a489debc80bc66d0c86fa925ccaee946490b0157ecfd4d6da419df97ad2badf06174dfe3cf57e8fb98456fbac056e87ff1ab0d361c93e9816e3b4eecf6b10b1a3afc48b6a89dc30a7f1b28d593ef13d6fcb53a2d9766b71f08bac4b7bb5ae8e6164f67154dd729f3c645b0b8d572af7c7fe2b47f60c3e62fd7624509e3bccd6630be3be7a55ee822a11689ce16269f64393bfddcd1e1e9278c580f7a1af9350c75f5f28d65a6ef60603307fdd393be76fe583f0ce3006234e26503f92c4e628d193f39b7455558f58cda345b0139463e03cef47cb26e4d45458b5cfb9791172de5041640d95bab75a7cc251ade35917163526760f3fb86e053ec6460012e7279797f4ba7a63c42eb75a567a5243fc211ef47e34ccd1915f230d7af1101740093711154b64aa9d676bd6bc2f9f618f19785664a09317396fef1085f089ab0f0eef43984b8e6ef9f2b0627d7b5dae6b1476d4eafc56679cd6f31f4aba34a3fa9cf94fdf259b8938486162e487c96870d6075d99c9c3c75b4141bfd1bc9b3a90d082c88c94af1595686de1a64a54fa12235761d6476a94886c559f3f1bea8f54fbf1e8b1c25c7b48129c6b3b3d161ec4e54861e42efd4a7b012af8bba16cfd9a971da6fc9cda5bd3c76970b43fc59e32ca489e7563f035378fcaddfa12106e48e83f63e0a08e4594c611ba5861dacf4c34412c00d966f169c6f163acf2d962acd3cb2342f36578501f5fd79b835697bed3c3f29c12515e9e5b8d9e738c0fe18c221563e8f4d61a294c131ff12dfb108c29219779db911245f76f558d960f911765359a1af3d982c2612e7d742d795c74bed837d2c22aab5f315051d5a4d3f0c83a36cca74e5fc8c5bb94a6a593a4de9ed6366f2be941efa8a1c3c53458a4e3bf0dd0a3037751d5fa011d2af6e68209cba99a55017c3354cdc72c47c92c9ad65ec3e5b9fc8c2f9d9e0c2cbda3d7b2313da30b11b090d790ad62f26c9fd88bbac67a6fb3ac1f7c83091251201e37caf5d2b7d90ef143d98b13955624b45ead4954149bbedcc7af087a6fd49093f551f09b32d3620ab608c3b5fa1044a50967e503db23c9c52f5a4c8286700cb22e094c3e88e0b2029a4382413ae5d4ff95d6806f6f01317e8a94674e295a7b5b5e7291e194de3b84fcd38519c0ef08fb2771032619f333805e2218b9c8dc741ba06d78d2dd5298649fd4047605251d8c7a42064299917eadb841199d21c77369ddd9ab8ce02cd3ffefe9282c9062b8c3738c8e4ed9ef59ebcfaaadcad823c6f5a782f4806a14e8809ec724caf27cb983c9c8ec9b672b76c81e229efe4430a4d4eff3598c96f7baf38fe292ce33420ecf00f117ed8d24dccaae405148bb891c7723ba36ad59d9cb6bf752185a1fb0ed873a918b644012ec827993e6eff75f62dca8abbeedcaaf6ad4103f0f720428e1f0d42e56a84edca46f5b6c014bef33ea3f15a63048b5b6057594e4951cfde416893106239e82627545213544834131449594ab498e4670592434cc95e88146645aa820c41854df52327905b7bcd66fe742268142fb135bbf5d9a86f5926b87c8a155bed24114dabba2c7d039b71de2ed6c56736b159b9791b27dbf5779cdde8d51e3ccb9930071d09c52743997bc807d981386be2b825a257a431259ca0859afc640daaaa73b8a3a66dd8c353f79d87fc3c90e611c29e6548d074ca45aba6fd0f88ccf178b82b58ad733100fc030b0f3f495e30628b0e2a00297435bcff6030b144d31c2cc008016dad96bee55b4643783302c2d04367c34f414709f27704a469cbc722d30b3be293781546efbec2845acc838d50d6a4871e1f4b3774a7d46492471cd649c2b5bcabf23566828fd55f23fb5cb8b960585cfe9d89fe8d0e12af0b2b4439d148a8b821108ba6489942d04a4045abe4cda753151c2cd12dc7aac6db4a52f730ad5e1d0afe98eb8ef97384034e9f38b17638f1c8ffbea409a5750064ef37bbc795596fd197a7f823719961dea71beb2d5590df88307e856f157a1992a4e6085ab75de04fb2906c8cd60102b7a3930f8e278552c7c58ae9f4d156cf8bb9560ac02189563d946a53ab19de558689ea03b283377db05cec4dfd033766573d5c4294a35603ee4e3f8401e24bec2408f86da74f7ab49d16f6a33591e34fdecdd6040b810e38f52eadaa712525bcf8fb6b025b27bda62fbd3b4eadd263e88499ad12383722fe6e5b1ab8b1b64c17f95fcb5a329324119d0db0c385129c954c83154240f8b37b74fab6a14ab803d521bb0ac7a66759f0df97e47f19d656c07d7f19f1c7f9dc0b94246e762551540a8ba9d16ea3baa033baff59e094bcdc2b8681b39b3ee4fb50861b02920b4fc31ac7a84ca55c9467e56ad6398dea125c19900e6ba0b465be8a6493d9914b770e1ad841b97b848b394d6a107e38cf5ac3c6e94d0ea7a04e15f1257231e28daaf20701f0bb047d29d34e45a04a6fd80ce59d0391cf249b5db5544ee3921f522de27dad7e1674bc72b60368bf0376fca99e018c159fa6bae1f5df223f2ed6a28593b72c66c5a3fb4d6c05f164b47c1bce58683f4264e8bbfc786fbf0aa35373569a7b175fad36c5026e329b91209bba4602bd7c3a02e3dce9d36d47ea352af3585f38a2f9686732de11e59311e81fdb4e555d9027ae1d7c8118c678270ad5927bd2b30fe09032bab2595c4851aa7fd9565a8e37f8f6ffc983a73e992ba09e4a649f5afc501d6f6a93679d346e123846a7b81c59f68097782eddf7479359737cc57cfb4c4d4dfd046170427b0a0677ec3105cb039a752597baaaed28e28ee49a637fbfc8d9be9ac01134ee2a0818db6193a1169a138cef063692403509b4b01d2dd5bb5f0992aa654f387f72d7057629d13d8396378d9cdcf7d883e10c54a1b7d3abd3b8104237f91b742c220b386336185d97210eebc2b4ee89dae9b8991192d8ca2e653d5676d5e3237573067ca59aab8a739728978d9f88d66b9605fc006704a187781d2bf7d03ceab08487fadcd7eaec5b8caa2690827529ec47c619d1cbab523361457c44720502239711b5faf8af96ed1f524a0aba487c8d440265f06af9cb28d51b6610c1f233ba3b8e1dc86b3c9115e742fa073b575173ca114323ed8b8b780b262e7823f86db94d6e6ca7908f9b31dd36ed0975255bd7e3f106b0d915264062d7f161d26e5262deb7d7b91978c28e1a0a77d9788bcdeb650e567976ba22370a02353e642e012797abadfa62b7ba5f654dbd72b25bacecb6360c0916ce43f158b1bf842ca73ec13c5fab44e508f9e4270515453d3ec6138741803362e1b4b4647fa646dc8b681b9fa27215e8caad7497673323fc1bbce001275301219ec46c46bc88d02b22a16f94b6a28ab4407ef6a24ce154cf6d78cd2ecb2a044b9cd168041341444ae030ce434f7716c0258fba54af3a162561404d2c60dbe8935244716af4e758cb6b6ada02ff04e3e7d496af16ae12f3971e38ea0efbe925914fe70a09251e1dfaea539ee36f5e5c4c6743a08543557237eee85fcd37332e1bad58d82fe46b5d9043a0bbba73f00ccaeb6557916510cff43c0b5fe6a2d7dbbe6ec6ee1259c03435e14ca76054a66dc2e3f0a2afa2261b6dae19c514de256fd3e01cb598191dd5680bef9368a4dbd3b3f5583b9dd61dc904e07f0af2a1fe58cd6f269dee85edacad2ccdd133fff193fe84b2e2636d5b1f38b958cf815822fcb90612b5dfb629a7f0f7770fa6420a2e956a2c22f0728aa841a174ee103ede1779bf2699bf6e11697173d2b8df1e85d0cc7f51f8864af8ff27161884798e5447ff69dfa05384387eab074782193eaed0bc612b1d0278e8e7d0bc6892e23ded1b1918c36b5d7d479e0f6893f18e159cfb01a80e2ee18262811557a5a685bad7d4a54d25831340e425346be1420032d3e04d8394749b71217add5c0fc6bcad4b7e04c0e3ffa1a73b338ad8e9fd4795149d817503113b4440ac5d9a678f8e47104a5dc0b0775837db4b08d5b546b9c3ac831f3c72a6a32e841c541fb8e1576eed2f7d049c2f49b1234bd2ffcb2e7fe303c73f37644aa43b56bb921c8159549f41b51177a8330020e907dd6a122b667c65ff60f233f3365ede1e9b231994ce2de23f6b7e17444e0a8ff47d6b0889d80c7577f404917af411f78ba2ab2679e64e8ee9d5f10ee547fab7f4728d73cd3a271dbcb5bea7c16bd0e3db73de5ae4d136e5d9b52fd8506224491485332065f4a3bb116ee0b3127842e513d55848da634dc84d9cbbf05e713cce3de9efd974ba868a58f36dc76f4ae5b2effb16e7aff4bea1b01264d38d543a66705a66390cf3204ee6332fd3781627d5c8648d7e0964b6bc5475c364607ad0928bea5309e7636d2219ddded507d8cc67f3ae65016e9baad5df2aa26be5a7568dc8de8a7b553dac00c3c6514fe82582b5ee5f86253f908d483bfe3c5625bfcee1df32a311f7ff0245820d3e43fe5fc7793bd5b4bec13f7d59fa3caba479bf8c68570212e560c737314be77c55ec20a691898e93ff9a6c5626253bd9bec4bfa4685e360b0870127e861d5a729da219e13a4fe6a3cddec32cde5dcde5762b399bfb1310a20e177ba4cb82ad2b478e2c99eee9483279b69032a83a40387bbc04b3a976b9c15b068e1cdad14ed4c7f9a6b04db1333dbeb19437e83c79739e4f1b34a81ab69cbfd191c160fb7abdf5b73f1e60a61818a4d995b452d020609636233bc1075f406a2b7cd8d4d83b8869925b508c0ced2c8ca9b59fd2896e3175bc24ab636792a8afeb9065e49492789244a543f5ebb390d7966e2fd667f7843530aa31fcfcc0af5f00bbc4c54d58bc62ced6381b8f5ed12d12105f935ff88cb477295a5b35b4a39eb972795deff998ab05cf54cb6e72a99084358c8901cb022420ab8134b9c1b0e4cd0872d4c710ed03290db4efd0da7456cf5d3e6c5e8c5f068b37b1858316645f928a03de654e4a98a650355b3103b268db679f0350e634c0c8728c72529e66be0d26bef98082929a83b8ba2dd10732ceb050c18cfd372fb583db910d396513de54f9bf389a220efa6659be5bcd55980ea5a2b1cc7a276bdcf3c67e45132ad89b5397c68b477445fa4052c2e64b1796ef6938bd93a38acb778e632bfd8ec99993d28bc1c72958202f753965b72dd467c0c45f8dfcf36d7f2e018d511b544306aedab4d61900554077b8ed3a6744f0f4e19c1b745862a819147733f857a424e0d60ba7951c09f70b451ed7c9a7dce0f820f1a65d0898c3c21887255e21b6a077c3f9a73242eb98e766d063209aef6911a3c77a7bed8a074f3ac6654226bcfaa9485dba217dcf50638057aebf7204f19334d06f79dd43b644a030b80cefb6563b491dce46bf0e07615991c8bf92a1d652b19c2732e2e76720366398d91975e280561101f406d4df849a0ffb26fdf70f404614ef7b0ac50fbcf2471c2197dc4a9dae6fa64d441c7bd4fc345b713706e847e78ba78483cf3757f2d04ad9d69496900e8dd47d15bb31bef4e6c7cd125a5d3bb03abb7f1436193e714b5e53e26423fdb2067b46e31eeae75cfb15be3e12ec37bbef2ffcf1b9666c5cf9697ba4fdbe03934ec572ed1fb74984fe8dce4775639984a0a858be890c99cf4555cea987577b99fa2fbd034a89b25c18250a76f8af8f31976b3bb874e360062cf24a31fe681ae9baa822521549283a46c7d0e6631432022e4c86e3ac5108e908578055709380b04f9d83f1becd12a756d74ad0fa9b465e48308eac64afd0f9e724c71f5995cca42516d0dcce2982ab524e99ba4eb3b7b304b1b6f55c12b4507edd9c9011e50702357f8885a78dded5583414d12ebc5b6ff3d7a17f57908bfb07c742acf4c766c5c9bf7927e0a9ec5aebc2dda225381bbbccc21a7370d698d22a087f48349719e3887a04587f45c0af35f7e8c6af7a14d112b5085b70b0172d8b94ab4374cbfdd8914a5815e09e7c7c9ec64559bd9c5fd8760c8f5be54b72f0c96cba523aa00671b8cf210ef3e0301704fd7d934577a2265f80a6cfb22614906fd296e7003eb1a6670fb80046f30dd8a612fb843da04d02874e2c3c97368cf10dddd4f31a868c35667f427d36058b7c85a7e7ff49f2c90662641dc6cb64c4f7c403e56a23b32be4c7f59438538d86678e0bda7fc534e222ccd6b38d38ec70e1f72bc8a7cd85f20f1833cc196bf236a230b90374a9c65fb517e58223f820930a23429fd604bc44ff0a9304564a9400aea1c2acf491940c5a551893d3ff719e3e75810d7271b4450fb404c82703d40cb133732f57561ba94c80e5de88ddc558391940f433cd00108cdc1d222b54dde7bdf96b00b2e642fd621d5debb3a67c2f61ef0b56e187950a5b269b7cf068de7f17b9b8f63ed88a8c988b218c5dcccbba81c60ffeea7ce4f4f12537d83581ed6f912c159c772c9721ac6d82215676646c65c575e8880bdd56ebde9cf7ba6c9125d02444e70686937faf5670a759696fbaf824039dbe92084bdeb702d3d4bc333ed03f5bcfee0fba9b683fed22a9808ecf0ff7c400d4fd36706db09f2b3fa5d163b944c3fdd0a6852e02b1795ad041e3ad720011a12b672ece5c8cde67f2bb649cef8b4d8e76a8b2b67b8d4b03b948ad78f7835feb8cb7b62da60ac6a8c111e9b1ab6048be490edb111c087861b40685ded8c94083e7eb241ca6e978ac47f7cdf9f7b5fd68d5aa42d0cd8508e6a5f17bf78de0633760ce59cd3f64c6ab82e929aec8756b3841a6bcee0c3798787f9005affa9ed6829606f47d831457318c72b5bcfb1a9ae6dee1415c02bddf8e3d4011e1a69574b872a0b851e09bb6de3c4fb9eb467ac37134d98a4b75d1b7db43b6a4c47b9c422a31f46a243ec69f025f7514491f61d3d180a005fdb4924d4ed26dfa622e3820c96e9f7202e7f523cd0adf1541b7d87ab4f4371968cfe0245d9d4f4cc244e19afd1ad3229d7098f62b299aedb9612b5563f752ae75fe91b86059f028979856df1d3f25d375063d91983eb3e0a1c8e1c7dea82e61460a7deab4674945a902d704346c2e13220bf2a25f87e193b708c5e647709072bf7e6cfe724b0048b70191e15ee3a7e3d29b2e219525cf1f1490242586ecec534bf164f429225c46ed28d3e5c6c01b967d0d433661c24d1f750cbd6a591fff2fccf67a7dfea5258f89aec26e3423014e6a8e415bbc652327d7e505c91110f9aae00a6450ed6cb3c062d34739ae873aadd0ab20711a0c31918c729071832d64c151c6de9f8b4a4ad4b2dea62a94578bdddf7d50aebbac03dd9f253f1e3051858bd2923ba2b2a4934ec68de32b9f0b222f25a3742265afb7f1240b2c54766eb3dcd94adada5a44e3ac6ba74bdaf9fe127e77d04bac48fa491609b61b239f98562ec20fcd70c0aad381ace7a3660dc48ac7b11fd22abbcba7443b018333d91b1c58611846a3bfba8f6cb42586e79517e982ba0e5321bc3732b066f9e33f0636078ededeb75de5c6845763cb755719e730224f81a73c2fe395e6cf81644c852d8be89565d952eb9ceef8d5bdba204c9bd33867458b9d8e57ba2ac242c3b7f20a9da56c6c4f3b9fc302dbbf0a0a0b6c5eb24fb3cbfe431299c7d2a23dd9665a76f89c153e11f61c1f5da45039dfb428fa3c1b1191bb73c05fc761337caec829bf4923a8cfda0dc680a7e43836050bec0489a3dd09c9084bc1cf8ebbce8b51b84dab891d4fa2b95cb816370e40a82d291533b5054a3bb6ae9894602c1d9dae67b730be3144f558f872fe02300651ea0ab0c4d9a76e7c9ceb27332cbde89f92447c966f7f40d12b4054e668361f4e59da5edb2f951d1fac9513070da351ad3231169072d1cdb7800ba873a1524cb3abc874982b2079272d180a2428254a395aba47aa03de69a5979342b02a8195a6fc9e9289193989aea46b1d2a1411cfa5ec19589c0cad14aea48e2ee1fe51d019db6a57704abf28c310d874909fa2f6f7fb0fd6de605a205f17fe7661d46ffddee8fab3d7b2fa8d09998a5f841eeddae1e4cff63ce4cc7d7f0c74c7af8aa55dfb70445b1138bfb221d5604b705aa97813b4a03c1e1d5003d9a29ff3fe9ddbb3cd51241b259b1bdd76d0265f22a1da9f83b06d244b0b4b11e2a1bac9805177da40dda8692329f173411078e922a59ff672c00f36ba1ab04cc61cc5a3d1ee7f8470daf29454372b35d7cfe99d5772ddcc45bcd0b48f68e31af3bc5683282dc0e29440a144d94736b5b5957b2d37974668b779d26f607d31525522177e4793e09bc8ab03a344ed3739793f2be9666ae2e7e2583e136efe4cad38a50452e4f1e3183083e5d0d72305b1633cc9c326e604ee935165d683191490781c4c6528daf2f4897b2da7606e15f8c65d7f54ea3e1680cba9ad18b7fe58c91c8cff33a5ff2ac8045c9a9ab04d2876dbe5cc57bfbd2cae18c1900ebf8352705fe52f26f52636b513ecaa3398511a16c4a64f758e2c5458078183eb4c31d1795bb9bcc56afc1121ab5a5d468e3743adccd133e454736089287e4bcbd4e35a156f3cf244d5de2930607fd0e88e8693bb54a5d1d8f5f9d146760e3d1135b7d47a49edd7d7d996127c160b32a1bc64257bcce0478a97196a734f0c5ea3e97e2cdd90e73584fa6ed46d5653fb89669b5183204f51ab392ad37c121ad3d3a926c1d1b55c258378ef31aea80399a920411b76308b3a20b1eb86a97a9ebc084c02604de47cf91dfa3e4135dc2746d40b5cdab2be61eed4f78609319b581fe556f40493e4f374bec80f2d919ed639e762c925b8ad24318033c6f7656de7da6b35e75d0fc9dc3996e8a8aa4a0299a6781df4cd4d2b304f06b5a4515f95381550ce42f595b4c83832460b5dec41b7cdfc1277046bec3bfc42e7670d5f4be6e9e26d92adcaee85f5c313dffbd044f7d260e258531df77a1254b61561b48d2a0f33b4d216ea8f433d10efd1b51e900492e95d1de9a0eebcc63bccd1b613f1ca806322713ff1bd2f19ab954581b773535267748162fb610d33b7d7b66862e37e532902baf26189dcb89959b764f2cf8ee141300f5ff5b41b88f27d5dea4c13fc835978c60f4b95ad859be91954723925e782bc6f160a65af77f4995cff59e23ddb831ea193efb8aec53927ed83b95c0beefff31139f089b018c3b901c101aaa2aae6a0e2d15f9efbe5228736660f0ece01b5678342ec7d9cae73ad43a16cd977f27e7851e81a7f8e909f9ba8b4c4b950705a35f6c92e7a77a402ac3c0f82676884eeea276230c67f9267834e941871aed0a40a69ca8b85932f164e0f89e3c568a0fa69bd6aeb29e6433b479c757c54b1d6bdda83d48b7946e735826b8127b48eda83f98b8d70a51934dff1ead4375ac470c5123aecc7163f6882c8c1202ddfd91ddd006e00d040a4a99c8767da92829361e5bb1a7441806f87450990369042644aab136660b2ab7ff18baf0962f128eddb98127836eac7a08d62b087adbf7a57fcc2845e46adaac4fe81cafa2147622df3473484222fcd49a610119d3af9c78b6fad343a3248834bf8a0e2f86eee7b0ab811268ff6fea2ffa87937e937ec8e84b207ab4738cc82c39c2756e466109d1b38dfe2a6c0a6e35b5402a3cc55cfdf3bc388a2812292fae6685fe78566872c14500558a80c8a88d62521cd30d185c320d4c1036ec2b9f9556634537acc4ccfc31f53042f7220fcf5039e3c801650a079fff9a9c6b61d3d7280ed0da784d3ed7cb4a90e441dc0331a8a5104f2834f5ba28ae057012191db1c586bd119dfe9252647ed4ca5cbcc06c3869b537910dc5352a9529e996c824ba6bb43bf1512fc33dde63fce55503d4b57bb9f4d9200ffba0b6960d381c7170a407a61216d1af24c3f1e1bb5bb09e0110e6a49afaa8525c972137e9c9d5ec875a3efdfe831c7eedb63501b966c6993e181aefbda502b4888670b6d4533e6142a71fe4b04b538ea0a31bfb2a7f4a7cf84554117e1c6168796daea0e9eaf92b0da08e8b461239f34b0281cddfa847cd20f0b58f90b8cf939124710dd15cb83b25392671e40df2abe2df8609693547ba4b96631a1167b213d6ba429cd59e4e49f2b8f3bb00ae5a3bac8692b3be8fb2b0626d05b197274b12ca0eed642e9abb16eb9cf0315280e18b8ea1629b11d84e759033a05ae8d1d64d502b86209b86bb79aad6ccb20cbf2ce9aa508e0f290c4c5488c04ace257b3dccca943e1d2916b21f884084b5e68d96971e28080855be885db80f47a0ae057def7c5f23f5d2ae05e4e8ad892a432cb923f0f22b6438ef9692955e0c7c44fcf24c353a2479bb64b8ebdaee50a8fd9d1ff74e2fcf5898b6040ee4e0081e52da5a7074f5e7ebf8b2236add7a7e419b0886e9f54eac533d84b7fac70235771b57da3898938c86c460d20f36ef8383241469857cab09aa9f82a1c2fe112836b08b7aaf62cb56c1cb00c3ee38a05d7bb6ce16166c727475199898fd393fd9ac76ebf5ab6b42630ed91ef0fda40399a6e52351d6ff6ea78c72ceb81851f7525db3baf3b40aec9b887b5a2e1e65acd6ab7db8dd64104ffceb35709ac9881ec8b6678a0ed876e3151f8cb06cf3ad3c4f9f1eafdc3a76deaea88f3465a02c00404ce0db6bc7ed7c4b6a7399109680c6e98d3b9352a62fc0c6c517367ba18fa91c9e6bc320eff45ff84f09803a24d15fea931985dd653516904463531a518ce027255ef93bbc9ae33448b63b327a0fab25b8ec8a71cb73f67b91c9b8b2a2d469b00b0af7bbb7f80700078ab37680bc3bf5b6eb0968510eaf5de78323951658f6b5a7a6ceaeb6bc7c7bc20de50df7880b781","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
