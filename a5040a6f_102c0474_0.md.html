<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d16544a8ddbfb1249de0e2ed6a3f7cc5fca4bf082b906a1403d491b20e3946f85c2055aee548641955766998b9eddc2ac6ae2f9e6a81de363039edd029be858654ac772e644dc5322e97c1f3662fcd02233c83905b73a2e2642f7c8bb8efe7f46a871279c3a37ffc63f5e09e97fc8b7f95499c0aca2c81d9f3f2923c9b7f27acb1d45bad233a2b6e95499a73832db1113f4a9ac59540b5460d7c339aea3196b1ee905418955efb14d6107389dda925c2e549c44150122343534896373ec0d2a068f72fa4240a5ff30ef7fc1b9b649193c379dc04c7262a772133bcaab3e183869560985d05b27373503deafcc793244482a6ac08348f87342a4e71d8dabc15166937e2962de66fa222f270ce96a32c66a4c16d9f7ba1c044c939fc0b6c64d9cabef3fdd0276df75cefd0999f619577a3af497272ca02f50f7e0259db7976965bb17890c301813f35117b87f9627851697d25429f78882c3759972482e3b77278794a96e6cd04c52c900b3a1cbb962ddbfe1703464bb968b6b025b6d9e3b1c1dd3d2570d0c37b793f85187a2983611e2cc6387b1249d1a8d182840ea90f75f7ecb3cd9d8eebf7fa8efc13067b4951941401fb6c5852006301bf73a2bcc70b557c56e0bef6642814b852a0416614edd534109140b030b813a93efe6ff664c1361085cd700ce882591f414e2be56225524e95e6665288b3cb24470abf217836274df7f97a4fd314ed74d46ba05335d6a520dd9b6ff9a98fc65dc8904d333ac1930b2931a2cf0c67c94eb0739a20a527fc3a70b9aeb453ce2680944393bf211d638dda7638767b1ad4237b0d313dc5da47000547534a0f4621e9d33756e3e39543adeb285f9cf89d2e4e808480b9b841b3481b490fd702c1e92c52e4b478069ac9356a59f76e5bfae4c9f99ec66f368ee87df77213c3def60e66db23f7a2179c0ec485801f7d73cc175b6c8abcc525f8aa4bc2f8e30350c3b9e2b942ea80f7693877bde6afb5959acc363dd925accb49de7ce9c6430b4ec5f71bbb5e01f3f6c6db373a5bde6ecba358d1da58d6590d0884978f96aeba31e427f41f3eb8aa78228190a5000d9e8eebab149efe5a9905b2eaf4f02581b3b83b94aec696b10d2253fa24ad07a9104447cc034bf1057660b6ee89d76691f41a949192bbcc4870a083b89de956ada0c596d119b162a39d527f578aba096196c4a361e7d9f4dd8165288980f50ce7f945b9a69741bde59de3e7e2015639aac30cdf3c7fb07cdaf5808aef846162badf294af02b711ea7f18a61583325504430a3c0660340cda239d610eafb4aedd53010f806eea15e33b1197af097ab8e7f43aed802f8dca6557f553b6cafc4939d34e5ada659b6b3db51e8071d85b00b71054d75cb3006db8155a41d4a80e6742918e5d0c19e4e43f336a537f5993a3e5c1471dba12cff365981af1f4143a90e1a0dcf6ee70ef690c26ee99df23649c0cc0c7680ca7094f6f135f671a62768650f24e04d8e08e1ce97e6dd33ecab748ec51c118f125663f0566d9f2d4345722ba300b739b13fa924048ed0641eab7ed4b38bc6f379e70c68748eb1a197532b06c4e990323b0c3300462ca0c2d5e2af628774a468230733bff7fd71b43a9190de6042647ff5ad2b94984733c67255b73f32b4712c5d4bddb4ea9f2cd68f6d586bdacab970cb6be245fd2711e57c1a75e4451adeb59bba823c665461d0cd7b2dbe61826dd79ca60b823ce9c36f898566342f572b743fa26d844470d74ada2ee0ec44c65de0f918e1d1e051b26b0ae143e172d2725bcaad53d8837a4c513fe4e69bcb65c22a696bb981d7feec4540f59f278eb2cb55f51f25e3f58a7c516edcdbc3e31fc836f9824d627cd2cf9f54d44b5db559fde0a2d4d06da24e4ab99d6c44eded4df76d930e4b3f41c1ca9b18999d5219ba3a379061049b63e0f5c11d0d1f9b449aaf38356ea4bd8ec082b515c49650a68c52005b3ff29a9ce6971a98b6bfa4030325c7b3525bfa7489d3200514e11378a0732941e71f44bf25ed4c32b6f1646eafcece7d420390e79be8217daf37c4959dfd62df18de9308c3aeeb919a28279c66d1dff651d7f9a90e1fb5d081b16936ad0687685309e99f00efe958434d536d3d1226ececb5e73b8be96578cfc405981835dbd1367e69cb575bfe3d208ecf6ee2db05ad810b7aee0203b396b5193c2457ac251365421f901139a9af90ce1a1290c89f2f78c75f41602c3eb62f6ac126ea4620a9e5367b536697dd54cf265b1f93a8e944655f9fc678f35a020f5acce6801b3cd072ec195d70131e703683e2199935401f404a88a749ae5305b4986c6d831e1742e144d91ce28f7e2ba4c6839bf1730718d01387e6d49ff8783c177d4ab61fce482208519a96b7ed826b6fc010b72403dbd96ed7eaabf2caf5dc1ded2f50edbb98400b0a7f82b110d2a4434f55afe11fa21e17a1adf49eb3d900d1f9c974ac8bac340db7c5129ba5f4ad2c5fdf5b951d251f87f737425d0c8cbad7cf031b295fb3f962203d90431b3636a1cf9ca208cf7a2dbff51a43e92173e568d1858bd1416b7965793bc88723323525358438c0f9fc7aa098b776b562289d3df6e8f66c6903ad127737d837a013d5d848d4f441c461aa8ae40b70aead70699724a340f1719761c69f1389a3e471bc2920c94d2c4bcc15bdc72773b19062ed2c6c4f159ca566e2c7422c0152aab2bc1fc199871ea2c30e407b4c84a0b8c763277ae64edbbbbfff08be3cda61cc5c7e3f945ea09edb4f8f7ff8241a4b5b39971f827f2e00d33e4ca60789cf986c83b9042e3030c574d234ccb4a92ef30d9dffb14834db19df0564e98f85d8f152c839953fba2660b86653f5f26a70160e63b4e6c43d6597fa92f154b4187d5db0a98a2438eba3e8e419517b06e4d253e0d252a9152c39c7387790344a6ce5310af94c48f194c2e4704c410d35b9bfa4a986f3e0868d01e2922820a07f33c352c7bff0198a4b0f8b0e62be99aafeac637b9dc65568e8225b511689b2c9a0423f6df2dbeeacbab814dea05d0a9b8d75e919aed58e121004375eaaeee25ee3309e3ad43c4fdfc3dbe6d47ce8c117ce7bde314e20f4ddbcf9f0e7416771c91eeecda613cb78a35ba2bae1b85c6b77c9f7b289751ba496b8c8a90b667063ad38872270f59d0b044ba8db88bc2b12ea80f672d544972bde89b1f88713529e84f1535c974f41bb88bedbca395df276497f10ba75f40f0521abcc900c8896303a013da766bff9dba80b9e25085ca3dd0130ca0811e26ba2f9041bd81e247acab5595432ae8ee1e1bcd8714f25e8b581c8aa0a094f15330560b2616dcda7b2bbe8be6080b7eecbf3d28350f995f56f80c968d7e21bc23b265b3f215f5f4c5cde4a8cc427ec02d51ae0372088a2381fd979f07250d222fe92cedda052c4e08ddf651efc9a5be77fbe9a8c5cb278fd68cd63ab3d1f641227d83e04f73703105de44afcbe3383f97d1b30a8405f67795e1503a14af500e5cf9ea664b3b9dc325c5e789b96398971b891ef9b8475fb0b896cf983ecf7d3b2a3b90cd985663d775462f6eaad21c71eb2ad6394e2fa724e08c50b64fa9fce7fb75e230fa60561207626f61dd0dd54434ef9a21347fabfb6cbb2ccbb2186dec88c8511985189b2f1515fcf69a2985435c0a9aee0991ff92d10a3974c363fe62c7547c0f38fa36443054d4d25a7c112208cc27d6f89ef533327a2661e08c34f6bf875d3361ae1eccc3e26081d05639a32a287794cda6f222610bdd707153d2f312d43ef8e5a6464a2248a058d816adad2d56c7d716f4f06179968701939a470981c95173b567af6e9536958846b1de01863fb0f0fa61e4ab7297e2adfb45d5a88e90000b0d48135ae7050dffdb98683889ce58f5262570cc76cca463f8a6316d5b84147c4793db9f6c97bd9e36bd352fe83fa40727f733d4e5937c7a97c56846391c54b5f82503b7cba7737733e36346b4c84439decda5eb631a278ed784a885ec8caab85f4ee9f0ae99ca17321288c99665f5ad6aed17b2994318037e20d306f3944e65a760b8098b17a04561dbedd8d4cb165d6227134594064f54d6156d9fc25cb1ff9fd6d646d96bb67459f775a174752717e92e8d2d877fdbc564d6ceabc67da6d097adf14ec0c4379452744391e09641127a1fcf3ed077568c09e702a174a759fa34b7ac15f7b3eb8de7022aac947f4de397f06c643aabcc7a28fd11a00aa396ef5900474a4343f97d155b40568cb8179fc6fa2be228e065ddfc95264e756e9e1cdc78b9e18d85515d4c62b4103e84ae17f6c9c363e3bba2412c3481a2e41e2ca715ad00f0eb69cda2f43a51f0bf2f4a7bf30cdb8528d8d155ad5b07042da7487b50a26c05fa3d7633491eafa1b8ec8b03912ea56c84fd5e0c6c639e38303ac8a4341cb17442cde85569bf006d360e284d36b8f68fd5d5ec7efbefb4b8a773a5df9be8ffc026b22b981a22ec901df91ce8b6d6ae3b224c3a6a8412f45ce453f08a19bb5c09d6f00835d0b9efd5010d1063153ed4655fd6b5e88dccf69465c3f03ba56e1badf63fa9b09be0fe1e326ba5d5c2566f2f4ebe8e8d2642b850395dcdf4b6eaeccbf46faa97289a349da000424e668fea27ba24e286f105604ff76dedb0fd8bc59971516ce4e91ec5bef85faa66d82813da22734fed59bc069c9024f0d963b890bf653a5a9b5494285269987b736597b5bea0632df5d78e77d5bc5393d0c041c09244b998ec264fa6b63393b8d05faf4ffeaee38d2b357e7713ae1be0070d38333006542cfbecaa3a6639899e455df9bb59d9ff0e1352724028e51c06d980428526eabe05ded08915e3b8cb67afc3022bf3a274b50044632fae4cf28aa9b3037dfe7522e89520bfa291edba5934930f538aac6260e46fc50640e7bd5619c8bf9d27673f8f8f903b12bc4b0930e000b39d8991c8a708d83915643f5de81f8eac6eb1ff86983ede9f1874f9b622aed997832a8c63fdb7fb0742a1f73dcb6e2eb84106c498bbcb1f106f08e45f7936c7228f16fdaad51acc24b9a8cd6c2d6a3f7e752ce2e47bdaaaa839ed02f4c6ca16f5647709323a7349f09c29ea58588a00d26c65037b0350bc0c5d005d264eae5dfc604cf85c5a7d3997d5202072e3171f2ca30cc66250b6b9621d48f34d14f039f9b2add5bbf6460416dd3763a4789a65500a18f9542acbd7af29ea9a7302b6edab290b1765ad636fefdc24a2a3fd36a6e4ff100a672a01af1e5ca7f2f280ff3ff9144ead5d8e87e56b4849ccf3089e4d1cf06e0d3cb7b725f2cd6f88655bd53d318a45ef132123ad8c960f773a5d3db03d3855fbb28861be6e967d0cde37e37308cb0ea37daa8f30e3d99b6dc0e7a919520ea17e4f132b24b896596537576d3b8f304564cb658bfaf1d4fdbe3b79a146ee1695c7fa2091caadfc2ba4557a5e5648fc1eb4a2adf5df4bf2a5c2eb9abcefbe4049e44f3778e658d91ae10e10c346a446017bbddc5aa9e4d43e96bbd53efbebc81be0694e3f11710245f87ec6f783f050681855c4136336a2bcb9c7710b581672106f2bb56a3c3606897a87b20a9212ba0245f4061a101ca32a196c8c5fd130fce9c6d8519f09585f0b0fce9db46cf5514e3a47b75592f1206ae51700ec0b1e13f552b4a3dec04332799f47874425a9f7203ce2411a22c97b90642e043d9a4b6e460f90e701be3199cc4adafd0442f2aebece0670dc38826b9969afd2a29a27a2ff2b80aa11c8562bd976a355b70f368bc164b89ebebf3da0765fa376d3433f08ac7d2506caae25619792efc9846c81ac37e93597e99c55efb3e72f73bc09594bafc12d41383123716baec4bf231c7acc590348b9c9c31e254dd7ef3e6cf1e9a5fb1371df17c7212d384975e57335c10db260aa0edd8e879e70ef2ab142a09736396d254d66dc186c66197c4325d6188a89b27a19b17bcbe725af1bd00734a4e3bd6fe1480fbdd5be81c948aae9152069171807a46f462d72b0ab503a477cada54bd5e45cc28fde12fc586fd19f0e6f91ecebf0f007fea11b5a850e118d11e489c4a70328829bd2a90770c365fcc542d264dcd124e626126112e041db35d128cc08f94ee5652e3d00a7b13ac5453234d2602cf218b22c64c89e08e9bf34cf6b7fe60ab27634f34943d64d7cd018c3cd029c7f7382a2cded03f62e6afc29171207d35073069185a1e7829b64163da1235c15fd06f7726774f6b8c63f09a9d2786029e9cb772b905da44e19833bc3e7f73a4357f0debc19e410744a35cd41c09df02d4e0a98099fafe13df1ed4e6dd71231b29c4bddcec700582bf377891966f69dd0e6c506bbd1843b117811c61343bd4845d9ee5de1f65056fef50d32530d098462f8dc44b7e470b2da331a41df44b4a92e37cad3ce9c31368245a613983b3432ce18a909ecac8ec726684810a5e5321e3172b134e20b1816023cbb862f1a9ddd703c2a41db59688fd550976a7e64c894f74658cc52e2f709a9747aaf947fc1fe5cf9bf3e6f54f66e89c542838bbb38a41d1ef541cd03c4bf4f7ec5d094d02dd0f2420e9675513420b2b5df9662326eaa7ad96a9ce20daf210ea270ff20ed9cf0cd0c62dacb39a1a63d48be4f92f6e300928d22f9925760928d4af22ac9848830dc9c836891283cf9fb3d50815a418c4d7072bcfe7ac574905b176157b4c0a1fa00c2edecb8f93af30b63267ff566949549db33b4776ebb0caf42a351c694bf91a3fbc25f676525456d4b1e71bab044a3940f0bfb74a9be957e0dbcbd1ffa4101c9a58d18da148cb7ea1f30c9b9b49773feed426dc40b1b1216eaf4ac423d37d775888573dff65a9f56bfe8e9af441123795069a75a8e1a1ab56756f713a7e5116a61f1837a29e3b418574e6010ed7a29aed08a7c4c7e4685a73fb7d07be2dc6aef681efeea5111ede6d5adf68d89f0228f2c8caa1488bc8a086fabb7619752ba40e83ca4019f3f047e9f07c146f16ca69d8da79cc5b78e13e4a5c540411e121113df358949de63c82ad1dccb04310a40904220587fb3e5f8bf360b1279a588a9bea623e554fefab331c0a0161b8edc2c955ccc9e810c7f317b681887d25460e8860018117d5231d2a8c1ac914ea240db7a64ddb72144fed5cc138a65c8337465513c3ad0d3530e115c266ac9ca8e25d9d89922bf0410348fc77196774fc0857bdbf55e5eb2600c75cade8b5dba8e3fa75e88980079bc9800ed8449e522e498128866e05c0d79c9b510246ba3c23c2ff20bb4861b98d33544b5e78a1a0c96afb3fbc7c0b1f6c381e0c865f67c9b27bd6d919ef4ecddfb3f0438de597c033f807846a8c3d2ebb6dcbb9f2a7a5a8273f144c1c6e8dcd182135d787217398acd80fc0504465b95232998381438097e75c6cd58a4b025b5621d1dc4e8abbd3857d9cca6e00537efebeb7bacc2d59e97ccd1bbd73ec5ee034be51eefc037a80a8ec29cf8965865cb5aa88bfc7f088cbe134ae0dd5d5ed1131bce26c82cb6f8cff7b7bb3af0febda54714fe50eacc00d5a7f6e9385606f1a66281cefdba76219536981c27605e55359f105fcd44576bd589463886051305d62e55ffe75432e0d256b63005aa41b03d3cc1c827110ad74cfc4f29234214c14bec9f0f93b0e548005f66c364f2f21c109261bc5764215c472cf236fa7c77850ca882310159ad0c717ab67a8fd82111c21406cdce1f0cddbe250d3e185dcc6467361d7da94da7b4d3bf0505d35a0eae220a6a98ecaa653ea61dc6f64cb53bf7ce6038e86f1ce353d8a0f30c4a543f58e1ed8c31b454d0bdbfe953b23c407a1c533c4b5e51a8d9f9435cfc246926bf02588801c1b209a365a262fb5059774b8facc0a0a4c42e4e8d540dc63e390491b5449c0b188b30906323f3ee1ee0d3d062899b2a969d91ad77d5293503b9d3893bbe3a5e1e48cc955d30ad19adbd55d96e2d0d19a2ba484d5a7679ef1fa33c019a55971666ba0b5e333fa1eff3c30c42cf3c295e27379fb646eae1a44338cb4ba364ff341501d1727e0621ac3db47cba354e533bd9f042eeaf92ca2ecc316d21be9c08d3ac65e1cf2aa3c40d81d5f5aa257f91a58cfdd417b21a72ba6e422b519c39a56394e2a932abb60742f9a459fced656ef16c611890de3a386f3bd2379c2692b174c89b9c1470970028994bb7bc9725eac1c14a5dc0d7e2e046952a8fcf30955415960f280f74869c6a5071fe45ce8a1334c3896f5939c1014cf08d748acee35d333d79a2638a38f4775b16afba7f3fb8802df2baac84af4d3fe5c330d1fdcd9ca8c7fc3d0aae3d6368053734a1246367a53a1822c06305d3417650b619dade32b1dcc4ff49cfadadbff427737794ff954f78e62ea6c4a7ce13739237a42d0c7a915ff1e8ed544d708b6bb7e561f563c6260a467527bb9fc91c1655a66a9917e42ac1a12757912c5317fc6d82ccfc7abdb349c4225fb017efd08482cee7e41834869dea9cd2b48cbdf6677ef34fa9d6c463386d35f25023a2dbf8b0e37faf0e5f27a9be84969e1d773e21644295dc3e674d126a1fde595a1c73cc5d52d25daa77c24cdb32b187b7dd3f2bf38f063b0d899d0be0280cb77bb7393161d16da0b4c03ee3aeae414717d459d038401a91387198c053ffb68dfe12c181d5e916cd959d21e2ddac61893bcd5a340663b991a4d6163502801e5ada45a21c7e53f5ac1bf447356adac778ab11ab3cb76f5033c76c1ba6830b9f5a2b19e8ff64993c7d952d04e31d73d8cfbe9c6cb596d0348fb96a3f87e332ec1014a65f194ac51c4e23165ef1de5b34cab3283d1cc1b6aaf40aa196ab2b958e552441657c8f2f328444f3022c81f755ae2ecacdf3e46007da870dbb28576c17280a64d9f5268e82a63c511fdf5ba89373a1665488ecef087a31010efacc479c0223b2713b326294d6e8a3f7960fa50d95987906837f71c76fa47b69ec3b52b543ebda7b1f41e7db757328be354b30517fc23086d887d2c087c9e271a9faf786e0899bb59f12e6d43fd8951eabb5c10f20c4444f93dd3117e6b44b5681756583de752c7553ec296aeaa2f15177ab46d268878592a8c9d9daaae21aa37531acdb40fa46ac5fad66b237a14cb3733bb4d2aaa9e9d5aa29d441d58069e3485a913119ca351632c0feb110de77e5806850d7b4e50a8d69f5a11c5014ba28cfe6e41ce6353a1b969f0dbeb473b0fa8eac1dd4fea8fad572d7c42ed6809ee2d77b598c243f20ee7e285c4bb48d462b44b63a28b07ecca9e770d00024c98b071b3839e7950faa8cacd98ea4d84bc48023c98db3475e38f539625eeabe1d8df598a396fcc4c24506f3d290df13d1360de6276e5a40a71a2eab495dd5b9344a003facc7e94d6a61c0fa8e5b80ba494e28c865d01b718e0829b05233f2e36d197cb70b618022b0f4ec60ad95202c0194a0802237e1b891632c04e1c9fe34078000f2573591944e7eac211dab212473cc8d92630d19779b5d9bc4e0aeccb11deebef09878113aac7ea98908f0bb9bb063b84a4f2707164823624037b306b898375712b1231b5b220b8f1319e9c793f27012847ef3665e4c96a29c137068293598c6c9b0ecd7c2d79e990bea2daa95f640c3120e677470369e2076723aa166db5812e561e46af07903902b0bd3961611ed60a454dfcfc8f4c28a3921462e2d1abecd90fe537175bce21625c3eaf66264124e5332ad2a8896a9c5c3469c093e8b2d80af6294982b5a60c1202298d06981ba482ff23a69c415d4ac3638324816273debf64e576a1a4af9c871a04428c28aa4f8589e8367a3c0f6d42b340a7066e2beff93d23ebf31457d747e9a18b8c9a91e72155421a04b62e07bd26340897f3c49ce6113af4fb59a224b91b267aa01dc1936a48600d6677fdb6c801497644b09add8a696e80ac398856a4deba8766b6ac6a7d2f4750597e5f3e5123548870f392bd924b00bfca84b8a058e572f463b1455e59ff0a4dd366c14462605925aeccedca48cd5ef1311ca42513f77cff1c69f50fbc10fbd15ba52d86a90b2e4a29d9ac7926e64e7cbb1df0a888a06691fb10875133fad87d8c1d4361a0550beeca3e38e911fff51120bb6cf4a09b4379f6de6c158c53194fb0d75e23c1e9cd04a625df8cc8498586f393d6847e3da4439ba2f5c3aa1e089093588ec3f46560366c74430942fa6b3c406c47bc034691181bae597fa30cfad21da5ab420b6d0402ce6be8649bed3b0784d8c5c89e61b210d9982b14df44b72a4fea5cbdff078f69972a089a50024328fdd211ee73debcce49e12f55fbddeef435fb1098f73861ff48a8c37abdeece3559276c42206291f38187e2d798711f0f89b3fe755d73845e5af6d80d868416c014944aa7406e9756a753524883bfeefeaccedfc60dcd19b67618ac713ed56735eafb52f2d8a096e9361dd9df18de9300f50b872785a5a6e0e49f9af5f688412f17174df2886711436c28574457fc9d00b681a28be99b5515123888b28d34530c2bbd78c69d72de6619744b056eca7556159b94b636efda219d845109aaa8a4bc9b612058dd1ec6a5b3f9478d160d3189a92a647b5a45ab734197de883f760804f8f13f05971898e6b4c6d230c3f1558e0f278424c1af5be9511d0993c1d9cece7b20cbc9f235a50be14f35475b717c86be24964dc7dce9d1f0590dc1230eb4446d8ebafd7858c65fa97b78e00a1d2dc2750ec469c8de8af764475a93b0a5d9c3aec4801d50f1d832a261b169973427e93d9b30e0bf99fada771211d6d6cff605276b7e8e2580617e56f1fb66d90ee1b3ad773302766293275632ba7c9c2ba065886e25c157bcedfd9c3d2f4607185e95309bbd1242e871cb0a8af0deb6e1e1be8319a0e29178dd7908c7ef06d6d0617ba316ee09c943ca43822119b3e1902e08d259fa46c5455d0126ea9c4873d1a72153b90d76acbd1b8e2128149980b41e534cb54abbb7e8c3758999d37826688692d7deacc597487687005a89f0ece2fc741e94fe268a14b3a59a692b95c8768ed1c0c30dba2d5e5f1d7f76096410a8bbb84125c1dc941b6c5d03f3aa9a4a18511911f30acfce10a3f845302efacd17fd08d99fd1974703ab1ae6621722f71b38caa00129d0d5d61b8c7f438b03dd6660ef8071a82a9aa436905c0a66b44a157c74c67f8b47947bbce805e3dc76af1cc86de926f87011f7c296c088e765e68f0422bcd3a41573894896974c80fbd9cd1e8834f0673099c30bfc677be27cc10d5b595cde025d6a758145984e4a92f9647e88e3a99895906afd404389ce8cbdc82a9e8cde0d56218b5503c4469161c4d1438c8968c4049689ddc4e1a0aec9f5f0a65e960174afa8816345bf03d4e75c0d6a5a3aacc58f4631138dc44aeeec98b64cebca02e214cd2255d0bd7834792424f7fd77a79acddb33438ab93d26c44fb1e4621c00abf7a8cc291b0f09cf4c9f7c20f82a86d418344ffed464820b982c623f75fbfaf466f59b648a534e1b99363aeb0a99d9ad42bf0ad73b54882cb58eedf61649d7b77a2a44805441abd9973496de5528ecf062b58a34d7a3be8a0743312ee498b523662ff5b4849a99e835f2d7069a6824600176a9a0d8cc122d1d9b356565db5653448e3f3e2e010cf0ff1338734971231eec4b7d3f4c29b3b5128d1fe16d453b8fbec855133cc0172e7b290962467549f2dd5f18a12d6da9f27686e37ed8ce7d45e90da25cb91b21989f1a2bdabc2203c1d059944527afbb601c5b3ccea649c6639224265d241f4a3681df30ca3c69419c3944a860c8628c025549ece13d592d56923385fe54eba5acd2592c9c10ee349c35b341581c2addf3a9c7d0f77a64b7aef692e0c914bf8a576a11bdef5a7fd60ab9df9e9e7210ea866cd62f869224c59de565dadcf43df85a847783c2a2bb52af153051ebb0fdcd67b19b6aee804f7a78cdc09027ad65fd510ca7fa7f6b5f15dfbd6966a699fde79e3ae908a3f44cbed9dd507b47a4039cee940d73934ed004443020f6d6c5eb241c834bf59a49f0a9ab67c788a0215a7fc86c1507f76381eceb61bde7833d98f30fd39768d25f33934be3834e9a13659989b621fa54d4bbabcd9d48575bc05243344bb193a89a12d33336ad623ed2a149c5fedd0183a7fa5a2b01770d2b9b2d90d515ecfb6f397b1331e773f5af878b1b6264adb85382e4674db70f4073eabb51d03b5024d188b0f352aa86b461bc1a6eefbef357e8e40285419b04a5c20d604cd806a48a4a8b01519b4501813fc24ba3ee8fcb116d1c052355aa0328303e23016e6792dcb2770e8f769ac1749065ddaa1c88915aa0f3d0bbe37c42024f90a41f3f4df061c599054e9601e03cbdd9fbd694b0688676b3b828d9d6abf6a68991ba2a45981467a43813b811dec8cc12f11a2372d622d4402ec720a250783ebfb6fd043de287ba09b489c8579bdfcfb636c978952287e5b3fe4a83ee413d5b1e1b252ee7857c2da2cf455da2ba9bda84597ffe491d37aa22978eda280da013911c18465cb26a6ef58b9abb755e2fd88a5230cb0186bde9b0107c3edfe2fe292aa453779f776bf4cbcc5f4d091fcb1949dc9b5df0e9e4593cc0f1c579252599c80958310cf5d64e6b7de2b6f8a24be8c69a13b0456291cecb2c1a1bd7927e1adb159e966db7c86f259c10de1ec56595f3daef5fba9bdcb3f8116e335a46c5d996cb2d169fc8c4286d040e4b12cd705ffa7f8a3dd0d43970dec27bccf663e295fa612b0f9097dabce0fb2db0f19bdd057da97fed158ae6625af7d11a470cf5a5c09d56deabe7331d512ff5761dadb97c0879d8ddf454216f8cbfc71ea894a44f2a1bc1650d124f1e1a5c350bdf3b71cbabba0a222b1c32acdd46b38d83edf0bbca7327fc6718e4d0eca67f9b1abf4ef716a127e373c6ba5d8bc976f690e70be366bbde2fd5520d684129182f1527c18276677b936af1f69628c79b559b4d9859328c519470c83191c8cc03d2ffaa3197f2fc4dc01a8217839b153e802286bc66e4211b124efc137b842511b4a35672f00ac687e59044b64d6c49f87d09585434ef350ed02ab62504b83cb670e6859c307f128f5805e7df10e5e02d8424468cc4ae1053e7f541182f41c639c5f963f1db543d3429b291daf37e9eec72ef3e9605415ce5b92d7aeebb404c3bbddf45761c29e64facd3a1e18379b7b258872694df88d3117226284cb0b4a4a1a1b2232d986b2c845a24948b4976aecb38ba61fad4839b8867a9cef0395553991f2bca75c615b92125da07ffef19a45c9b98db30e7f348c10dc2119694d05794be77fe236d17594a53c5b3a08867e7d74a01a9c061dadef0e12cbce8b1d9895d5758a2f5f61162ee075849a01d13b218a17581f6a7c79304e0bec553cf24eb4f4a79df47b08a6d24e227b1ac4be2ee89e41aac3c9d64627d8ce036fb2b530d26c7c950bf335b5d3923e359ebee6e65eb7a879fa9eed0febfdbaa76b6e16caf2cc28db6c415aa02766ddaa1c511e02a10ed49a4ba695796143c7e298d88cad651970d3aeebf42c8496391fa84cd7792a350901df3e7b40c1a2d68b723734e65c7a8842ded06bb8abab5b5e6e5a09d669cb46a7d88455df9209b96395ba78cc4fecbabb2ca0bde61527ac2b35a38f0b1ee1e5e16957c80e6ae31247e9679b09f3bf624157482f86c2a456c4dd570a36d995ebd5d46399f6072ab6a4740be760665878374b3eb4f27e9d8a2a18f3898667ab9198ae22f65b7f3c885fcf5c8f81b0ac65c6013419df6312fe0d2cd32b4459cc7793220ff6295f223c7d441b98719f0fc0b115b562f0db4022aaf8b54d5cee6cbd4b77987087b24de1678e8a2944c1a1f03426f4d9eb5c44269a982b9d54df3c3dcea24d0c677ab821852ad682fec13ca85056479f4cbebb937a3ed3760d2a417070645e61bf4849fab39f40224cece73d3c0ba182b1af947a326024038bd7948e85aa7c2d4571acc209406bda898759e55f14082427c969f4f9e16c567905189eecd47a73d79c8443dffe74391ce7c620cdee030b88708a13b0c53d388e1aa4c18c080c1e839fb1251deef1eca5fd07bbd5b57a185b8719123bc90065821fc6b737e870e0c52ae462075b1e62dfdd6931c237061ce97a61aaac7c4bef14266745e536b2d303f3e4f46b59cfcfa0740a53b5057bec22c2610110f0a8c3d21cfe63d746eed9a226f3007339020217920419347836be69bfbc4437ef7b40b6b491ea11be7477c1b927a06824feeecf3b96023ab97887a2e7a8bf28fb9d8895b84ac47671f04d38c9d251c59835549e053a3788b00b0328f620198eeb59193b2afe2bfc0d7650869394eb0e0074598a9cf1fbafba62015dc51a83f7936c4c52c280540e22eecbf8e820bb7a92ba1726cfa1dd49e0fc80b764cce4c29066a62be99658d18087b6952cd79f7676257165c1aabf5a9e9740f21177b176b3e10254d35dcd544e4336f7d8a2b60cbaf762fc6bd698f0f698a6e106b45e6599fbcbe576b1e61d7625798b492c1aebef3323424800474da534f6acb8dcf7b92223258b3868623fcc431efab3ccc87ad63d54fcd102a9fa957ddd6b8e6b5a43c2bffd679add7d4fab743b0ea563e461da26d890368aeaf7519b804125d3e109e3aa05b9ae384a516c1f32657a38f62762a8518559b8e13902fae0706106b31639c31916be8f7f6bff056d8b4840bd9423fe7e954fd5d401cf0af96a37dd5c9210f766aba393f7b55dba13f00e6a22bf2dad876a5856c317fba050d999164158a43b7a0d7fa0c3850a703944e377e1d77b9ec640239cbe773c8bda4216edbb5ab10855e9a8ffdd1dac5520c07890a0207ce08ba3ed3ac35b6a4e93fd52488d1b429d341a3d97b68ca36f58961742533165b4c80bce43bbab5754308982a6ce94f7aa7675160144ba7942732ab080e28c74babfeb539afa9cd48392cde5b81962235c2732c0fc351a9bf528d41ab1a2db6eacaef2a2ed0c8fc71e9a1be0d387ad2d9d980d767d3d00cd8561bab91c1d86f32c768cb94d631f8ff3559025cd38bbabb11941493c283f319d6e72235f9369ec368063463183f1d7fca85a3f23d974e7e0cf74de27baef5b2801ceda0f4ad86c6215465254e335253331054935e2eabaa3d064eaa133f69c84ed878bdc525314a6a86b67416e94c1c7d81b11cd7e58d644be293e654c927fda979abe7bb8edcca3476712e633c9351f6eb9bc259408fa33cd9e1bf2c461763c5f1c9c03029894baad7a16abe89336a0bfac0f05a3a0401da55d21e74d206657b22e599dc055cc7369fbe180eef5788adc0538036c6fc1ec485b2ec3c698df4c3cc1896c06a2dbc73d4cfa59b761bf3e226d711eec16749e9b1b73f6da69a4b15610cada18cb5fa4f834e78d5256a9c35f142708047e85e0d339433d19a3eb7bbee5c93bf05abcee6bc27b3c8b3e129a06a7160439ae74ad35e1f74305578c219ae09e2b2f37cbcd6528f1f1db487374094f16b28819b81a761779187bf9bdecec4aeb940fd42e7b2de0a0b9018bd014e6f8573c09ed27eda903607b20182e4d6f580c496b38716fdf5c4f529ae7221ba11e6e9b7033231ac922ba5ccbed8c56fa44f74462f69c6b23df8b8ca04e6dfbf23806c7ab72d7203868958b950a3b44cc95b86b3e986e5b5f70056f66b7fa9b3ad6ff4764e00767948361a3d7998fef6e9b1c7c1fa993225d78c90a9bef1939510ed36004910b1113ea8b9479c2900365d080a40b83f6f145ac3b212f77c25499db1fe9065c9b98497788aa194510c2fa25ffa9e2ab017934f695d9c2e380d9fa3d673e5fe9101965930ebd9d820fe1b845aacad19db4451eac4fd895331720afd6cd452effd1b4d2e76a8f0e7599e23f12d95b3d327a5bac8328e32367352775381d538cca245fdf0486f8bcbdc9cc7c1e9450ad0d001f30be3a6e35e042e4aa1ff6484d40413e0306132550b74b471edb3429151e80ef4cffd82df58dc6cd10e55d01024ba7aa42b4972c780dce3538891e1417e37fca01685a7eee1ecfcc803a8e1c926954f8927e301bdabd2fcc0d28d7ebc174aec3cd97cadf1cb92205840016d2ae78f504cbb00ce39edfefcbf49c7a801c335e7881393c87319c3dbff4278062eaf2eebc75204d986c997259630fe7f84aca253b6514741625afb460d4e3ad18385d97d2b832c1f0afea198e940d5270a60bfe6c0a037882eb7cffae47fee6f2daf86ca53b8338dd04ff5ca7a8342fe4c89328ac17510047f587a1cd427a8b07f8c6240bd451b7b7418b076370afe12597a95b9870","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
