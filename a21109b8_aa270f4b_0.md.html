<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ad46c10adee1981c9c3207e55211c361109cac287e2b3e19467920bd74512c0c760d66b39f66c3d11286c1f5fd38ba0c3d24ca40c74fbbd5dca2b5223eb0a6ecb37259a667439ccde5e283cb6c54928f13e0919db8676a954379ede8260b047e2850601a65163fc889434c71b365856de828741d3ccba33d152ecb4b09122ee8cbf81f545f6a9276ec99e6f7900e44f13c0df70c6cf29c5934c7b870c3c0fbe6411d7e9992b8fbad60f257dbb03cb5bc03984606cf11e1ac9e8ff4fbe5b697f72bc2c6d43745241ba5b8567f996ae984e5bf8435f2f9c58de374d33b1fe6ce05b1c3ce4a20dc0ec856f41d9ec8f882797fd9817e2ce8c56f7fdc956a92b11a164023acb965dad12d7bf2ca10c6835e1edbf56312054c98ed228c883d1a670fdfadc3fdb01cdda1916175e7650c73a0cec6d45a3474b2326a47a3d43ea8a945c013006c063cc3b145d1da63834adcf41c117ea65df3cdf23ba86ebef4736cb0feaa580f73717e509e3913c8d380afa511a72ff85c9a400248fd246ee23d2040b279bc564f304dbceabd7d2a28be48e35ab7fefb50e3106e24462cb5ad38db26613d3d3bfac67d5c4576b2c3756e0ddd0e9973bd8e7e0b7f61a7a12c122890f4d95c285088676a22b374e04c02599ac367630b21279d6dce4fcb617a018d06517bd67b160d1ce782967ae3f6e6e2477f3ea5a5e03fd3b2afb4f693259672e92ff084275b5874ba9523381861651014fbaacb187ba151b3fca7516580acf0cf7701b7744a444cd44967108a29abe89fd21a900378d4554a0687ac1d17dc97b89a15068eaed8ac3e158d4ef75041108fe343504474a3c9c6923ad1c58e342343e0d0db6575b58b7bb107a59030a08a73158dedae4736681166310e20b8e923fcba85cc1e3a532875c1a6ef625bba79ffb5e585c3863ff8110d678e381b6b39b49cf81760e02cbf188356619073a15384314552523b77f32cb4170d08a4262479ccf06e8c2439d6989583347a8d8c688f16516f6b14d89ae14082c7850940528446d482e5b721c5588f6d99d7534b932ce3f6abfedb93b01baed865ddd710e236c28eb85a4081905a462e09c90f35875697ec456de2a4e4565d18c0b886e62ef1ea1c1a99e41089b1707dd2a20f2c842d72076699bb7433ab7e284fdd8aeb5b1bb7782a9bdecae45864c385dd7ba5d81230f088e7b277f3d19a20aac3b82ffa5efc357a2516738a59afbf6813e02c6176e27f47fe79161b9dfead0849b2a5f07117dc4b8abdfc0a382943f8a9ad572216250a28dd6d6457176dabad1126a84c45fd0de5b27204570571ad9dca761281a987159b7971d4f3cb1d5c2ff36988ac8c3aa2fe8ab698bec6b2a349f98d693c27e09385d1a7906af9a97dc4709461155f77653c4f5e443803c6615ed2870d4f1e88dbca6dd253f9957e8e5beb74fa7b5a95ec73200de1dcee2be1d4cde9e9227a2903602a353e6ad2caef1d88ada3fab6391ea4428628f34bdd87045c3775a3e01de3c5ca37f51bc61aa3aa60b1b151efd5c8f7022aac25b4680fd2e79751d5850b8901528ac58e5725ecef69a155a456152ff875a7223862d058c3cbba09ae726ccfb79df1ec54b2c9e78fa000e11564a2ce7411c2b05f71987bb4342ac9154c3e5639d4f1c5817b1f7d1a50e2ba22fbaacdb9ba661df99d40dc8be57e7d80c488e5e4e1d02139cfd74d6610e189679457c27df461383f63180ccc62fbc155ec58b1a1ab88becdb0dda47d84bdef35d89b5604f30f69ee72aa5b9c63f3056ab15bea1c17ce9395c2a10f02497d33c161e2b57b658b607159c44cd29d8c1b42d08a9422acaff153cfa3d39ac8fc67a754e1ead7cceef9fbcb4fae0e0e1aead1bc3de629b30a1bd1c008fd8dc760e9dde4896fce8b8492690372ea3dfaece3427a1c662bca79d1d5823832af3529dd20c5031387f4fea1dbb91725c33f9c339922977f59338860c7f1f53b1b4555891df67296ed2c145d17fdbbfd988e45793adefacaecb846bc900733ead20e56ea41a5b359f8305853afa4c5665cb5f29e2f4c4db20fff248bf5c1be790888a8a3fd5ca76c7c1382ff06bcbf341f9b50a819119d5d04b6a46a6f8c49a3aa18c31f8b60a14be2f118b903f450641111a490af725c2b6dbb31eebbe1874adce1af03f80e4c3c0d74ff674874127ef8276282c915f50431b616cf1eac3c60af8fda7e1434be05356b40db3aadfd11db9baf058305301832b95e35c251e411b4c2d79e422dcfe5b362b56393cc27ac8f28246dc439b92ec8e4c71491119f185f55595cfeec559913c1f81a8219dc649fa7e40b403f72232d54d0959f006c9caae5458d09d6c019e60c4c26466d55d9614be56e60481503cf4929b75f0caf19fc9509e5b2b13dfdc78f83aefab3d712bf7801e275db5d54365da11fa17db1f52b5b243e709d601b24c0dacff244079f6c0896652e2660b464a600d171ea046b489b01aaf6fcaef16db8c45d68bd7246cb63a2bded2083580529416d89c6c304f36b7b9778fc4aa419ab3cdd61cb424bc42a50f192156a925d7f3a384929312df1cda8b585535e84504586f3a1b1e34fe82f5546d95c5abc85552a45b9ca2e120ddcf48709b7ee146c824bf2f96c96625499934e856ecb2b9486fb66d664a9471e4d2864a8ee518941325f821bf9c1ac7decb052d19870be8b35a90a1a397e45718906ab4543d4f7f13c67f5a95feb8d367bfee872af54520947dd2a45805dc1f4a22733b372ce76847f7952f5e909d60e7f07797dcc997ac37ee2e2acd53dea8a9eb536d599fe6864a7ae40b8ee508b633212c0f98bed7188c218f16b5a303d81aef1051aba66cf9478aa6e3407fd4a6a1afd8bf07e3581c9723689676b740b1de6c16506209ed3cb336e5723ac7fbe971f22e86cbd7d4a9004ba8b812879bd9921f583a90e7fd18123fe8680bcd54bacb501b06eb30f0fafe3f75ec6b5a76f5d2b0004e92d1c8c1dd8c88a82a582d1cefdaf5fe75035f84bba0fb510893ad6337bf1efd43c57b5de07d2f5e7691769224c42abb63c93a0eb61e6ef7acaf647ebc25ed9c2bee7f012742811824ab66bd6ebbfafaa545ef11d8aadb06c8f60e792361f61628a4f155bf6d86505b0861eb72acb720ef00826424a5e64d21d5d5431ab4af6cab29a637950fdbb48ac6e1628af9c8712e9d9d192aaecd19b1366ad0dc16937a449e6da2fa10fcd285246ddd17724cb519963ae052101a0a56165d90da65931b26aacbad0af192b3723502f6db85d06df0138bb66b6097d8511b294650c77f214998865fa0d74f47ea12031d8d68a207a2ea18bfe58441e38b2c71401db16cc76de80b644796908f9dc1a75a406293972f6d8f007986dcea0416e5f41d5cb2b65d21ab96ad799fdc4f6f322f91882b60186d4308fc5604b17fcf4cdec6d961314fbcee95fd32f774daafd876b1b1346b112b1e252840545dade97436efed3aeb7fcda12e1855dc14a87277b823f2337a80545e0d52907ac6018e64a103fd3f5e16e5364553004558c24d18efbcf02139e063e5726d0eea37212757abdf1d1f434d231e5446b9459194811a11d2a71c49392585d3a2615ecbcab87b5d08787e37fe3fdd493afda646628072d67b3f4f41d9c2e03b2c41357eb40b4c5ce3403d1cc7a4736a65ba870c3dd9b33d96a13e3bf981a2c2d86c3117f510e9a18d9c3bc75cd0435f4955a2326e0cd8f8a4d16d5958e99c12cd319ac73c8e6262c1fbca72de2122484f9aa01803bec23b2e97a47217389c10733f5755c6001e54f632686e49b4de5e332cb24643b9a5d9de73d8841189e3becc9052ff0de5654032f7d22d264b7c8e7b597ed829631b501656ba650c69cdcb42c7117671356ab8df63740de086cf1e40650bdac09dff9f5701095caf7d66843ffd2e0205afed5066e1a7364aea459f035c85c5de56ff1469f801f3d2d75e5cde04de7904e4cce0043dda0727f42687869d0e609c8390def85476e0f9b462c37e266c796ff4888defa835d99da6d4e75f0b32f38190356ee07033f7058039d5d897036c32db54c331ed94a0a6101a24ba10130285b051e25cc574d55f0dd2f30c822d930ca59efc0cd6b08be891a507192c6cfde89f100fbd27873556f060159bd993b61b4e407b88665a991c39d5a146b7b96477828fef6f88ebf9245b39fbc03dcd11939d8d25b9a3e7d1f53bc6aad4e38e57f0fd679b5c4279b862f9145067c3ce4ada04fe99f269e5825ddeff0db14e9d977453575bb15384683fdec41624ee28731db3dd62c7753461df0adab9e151c28880fbd637fa755a7af3a72fd54ac3c8b545c40081cce94a8a75ada288039d6312a3f251e39e3bbd40e76b0be11510131925d67dbcb13efe52a4b5e56140808fd0eb305aa9ba6fdfa34b71b6ba23592f0b6c88eb0f5ef9e50a327f946c643ed1d15473c987e2000bcc47c58688c9d0063f18adabd9c298d2031028a9810152a2fb79e7f9465cb9ea13bda0c8c3e9f11c19078e5fb3c467d49ae9165061027dae040e71c1154077da4356276c0fb8370d3b35f0ef550f1d78fee89df6d20787008ba28fe3bf0ab08a8553c22038b6a148a09818e213406731b32baf330d94742199af9aa3db3b99ac10129c231076e587211880b228ec81414f5910133eef52b65d818fadc43aafd08d5cfc674825e0ebb4007673b69081f95f4e99d697a355eaf025a2932afe497a38f63e5381903199e1b9aed875d066ed1e4e54a4c6fab56ac0c1cdda97a85bb63d693307697c22bef9ca10bb42aa18a3a8ade5fa59c184d595f0d4901c93481b1febd78ca9fe58b7edc2285bec794472827faba86a2b977cb89b77e3b29069f305c5c85c854d5adaf3703b35d722dbe7b697145d78a77937c6efac14e037ac019fbfbca74293e5e63ff35b3f60ce0df8409f985cac366450afcc6679832403f0d75bf631ab691cfa7213feecef5335257222aef28a96bf5651b675b025bcaa763f711c9676836d2524f468d27a3bf4fcd21a4515fcdd47ef8b80e37d24733df003efa3a5688a1023e1830b55b1a789b2211f110b0d7f326457731a5b6a3882fbbe7310a748d04dcbc2855c3c5394c04d1eb8577cbd7a7f9841ea78477a57ef41f0d09a57219b105edc2c516d0c1020fdc5454d55fb431418a585a209cc11e49b3ac6c73d82a487b6866e7690127558ac77429c910b44c69d3bf236b74f50df15574891bfa963ab15124d06a4c6ac2bb3dc2b534e554091ddb5978b6adca2b78c6192b2c34728f67169056a23a56e8fe2e9646c168ee519d50532326b997959dcbf9ea3ecf4e3cf0be1ab962ecd967b5f8fa11283dafb72afecb0d0e2695128adfe7b3c6c420e86818ac392f8f8f498b41828cd8b5a7d32d06b90eb65175dae97948bdfd243afd6f00a6cd5f7de8cb9109fb93e8ea8bb963831b785bd40bdbed3a14554a3bdd3a8c876aa979546332c8d7e8f2cb7aae089a93d196e46a66304c6796820897c7c6a59c2dcae6cb685f4bff43d14745913644ad3039b34b67eb65162eaa511c18cec0105864ed9cb7fdef5eed305af072beb12440b75550b4b1792337e276200b51b24c45702123ca42be828cae4aba8589420a1da96819083ae54233215f77b7e81c80aa773a4eecf2010c300d8127c320b6220d12e4c8fd3d4299eaf730461cfab44ed61b3229c2c437b1ed463e2e3dcde9c7b36a5e2f5d3857a9cbc00b270cda8608a171f0b4bda84a2aea5528efe0d1f235e744634d35601d9a9aecedea0d492b79366f3d0994750b90dd9cfcfbc3d5f0f844fa318833e69b858091ce3b243997d67b7828fdfc449a58b8c9fa8dc486bc50dbbafc37486e5da5497f877c3a6f36b0b045f079be9ef7251b6fcdb5a56a0dcf24b0d3fd3a8a9fb8e785743ab95d761e1a9ad9af74159e6fd00232c0aa5ca1f249234cbae79eaab52b37638ac471185a4e93290670c84ded511d6d835f49ab5dd6795abaef8b0738948782c0a57df1acc8d0b91aefa62cd51d0b6a59414f1f86d9ab6d32b5cc88e6ad356103ce690ea2a25bec417f2c7c242cd15624bb0469586f3bb61212dc5bcfe4d4c6babc4f6ee39ab37afb3174666e3807f79f31dbeb72fd7e5bcc168fa2f8d751e17355e6c260a90d4dd35b58f0e9f606dd45318a9e43ba372718b28329e50937a4fd6f2675f3871da0f2acbd2635a5428f1b17b57f0d82c8a955e0b9f81f5676a54430ba1524c5dc700e83c3b740f7020c9dd2725a5056f604ce7f0900d41a7aa811c1a488d7fb9e19bdc08142369e0f1f49cc474eed8ffc030f2150e5e89a7427a18a671a03440bf06919876af19be8b423dbce9f3811af6cd51915f9e0b3fe0c9b061e2f44b040849278681da4b830885f5686a965300c20522c215c9b3aefc69bcf101df55cb497650f9d248c1776a94d601ed68db5c80875622b0a554c0eac9098d3dc25f47663456842d3f08dbdac4179d0ecc6c4e7a5efc689087bf5953f5b17b1e54c7f7941376eb33131851c7bddefe6e5dc5ce07af509bf6202ffa51f00f5f61d08dfef0d76cc685aaf5fe1560e438c6e50897ebb7e725ea4fb86481167a696decff08661f0b9ce940143a455f3e5b7ba56b2e3ae04eafb9c44deb25b361190a856458187f5e33380f80d642f7650e2c67d4d113a9b4e0d473b0d304d5886fab6df16c1ef8c855ea1d315f293a4a442e50fc82906ae3be3992cd011c08b51c8def4dca475e52697fac0a6e53dbfc59d331c5d47d37f8dd311d759efa6cb96bbacc3956896d584ec644edbf046c745c70231032f66cdb8cf6e3f8ce2815c0da801b49cba6d30ae75b7a16385614794c86d124d12b77fcee01de1c9471a7cafd5f1e4bebb06e059b0edc49c8e7f255894d8f45882087863d2c467590585d0d2d7119b9ee4c1fc4745f1475317e24179fbc710edc1ea31f601e973efd840c847d3f2d53b3fd8d0b24f7133e0625197c43d7a7ae706853e618c676287331b1d7d2011ff826247ddee900a3a7fbf503b0b4c543d0523a93f9fbaa9e8cd40f4050d5ac54e9da9df1684b739dd4d0335758273a1fcefe6baa296354b825953cdeef2de10f21da7d67d3882c4f46262cfde7b0fc3877af24419569827b57bcd65be8891d85ac67f54ce92b34fb87f998fc99a8bf26c83eca352ca06095fb69267cfb6a1d5bb0a6e6e7a3d0595b8eba2167836faccdbe7eb5c65a9176ca377683b6db0902a631fe28a2675cb442ba1762f280fd98a9acfe421023552303d7ac55691d97000ab5522301c05f045b7890825252d9b7267ce7d21f90604bf93ec6c399125d413a1aa575209a835165c8e06ecd2eacecd5cd1248480e258febbcfde2c305d5ab4d1ca18757695d4ae2f6e4be4190c67e9e8bd8516eba2f17b05be9f07bb92677c70f34bd3e76316eda574a27de469c5b33ba7e78e49900fc5d399f1465c8b94a3ec23417c3db57fba426fee88184c444b5866d49c654d391c4273caa3cf147d3f368c65fa075ff364eac51334f3a8771cd28b28dbe0692b7bed35a870322a7da0b07a142808c139399ef193710c4ce6dda6fc12686f5e58a0a6b84ebe4237107898bd9bc99fb999ca97e4e17a3e9f294ffbd5b23c17be0a8d8588c5ef966b63cb5a63049386b3ad8b0448ca1061a947c419b44767db39c8c560e858de8f992a2dad541090c28361ea276cd2c4561876cf91a5dd3e9b341531a272542ad64cdcc53f6a5fb13cbb65ed1d2a26bb480c9763071c039c61d53200af889f3337575aff3f7bb22ca24868b8b320a872460b40143fd2bcc4a11966d21ad70ce9712e5840485a40c11dab16f39c09d1e000ec039150e27dc1eb9c3b7039860e9b0b4db9fdd935ed6b0c3e3d04f67b6308e35746be147b0ce9adeba09dd4caee89608e9d6225839de02c55763cefe4b7cca3a71211fa2179e9ff93e5daf2293daf4aaa39e8f6d956de29e37448e662b084a328523d5a9ddb547ab1c79eb380262c56b6490da06edbc7f702fc90013f0d3cf5436cee8c96c8104d54299b328f64c23c9c60f0f8488cbb3252692b5df254801f29ec02c2d88a1d84790f5dff49d94e5cea5dca2eda1ba14b1351a8b8181e26874f3fd9f0faa0cd1f59b921d079d3c53ffe28b62d65d60c7baa4f27ffef7443c2c6847290dd602259ddd791ad3979ad1d89b6f5889749e25ba26a1360a367511b8cfd61abe518a443968b744cd1c9d1829f0bcd971b5c53a91e48767a25f22b13d6ae73262c6e8b1b1ed2642cd4db080b72f8317d0a98ef14775cf209b18deac6bd7ea54730858bd2aebea371874cbe56efd2a50c4db5d6fa822619d5f4787af81a3846a74a5f754e098c2878da0e8f7f2db9352b4214f7b44845a4fbe463eadb47bb2b451aabbff9b6f8bf6832ed9dcca12fb2be8946e2515b0e988d6a4925cd2585121e8caa640bb792516e88920116e143236a9898eabe501ec6f95e9699ee4ee75ea03a1660befcecb26532c2c64f4a6fe8807e57234638246bdf0edab0d3b209ff8a7791f013570469189e7cc4c68bd021b1c40d728a38e253572d20fa8b2f98c0dee714e8ae65a7c0c1cf06ab931ff7cd61f457ebb39552c6896bf306add5b76cb2867b47b24b7eaec40e6e0300714f6a734622c2cfc018f3ee841c5fa4e78a15432e977c526f6eaadedb7e8352bd4ea34b1f440969eabae0e75bb560757a59d11ea63fcb47e10cc5b3749a164a07680cf7d02aa18ddb8f4baff6e55c38518b342f5e706091a87555a15a146c2a33b8a8feb36ee46b3799571b804d97672ec1c0b18b4edf7fbad74319485f41ee02c6f692aaca03ef804bab438883e00deffe3fac2292389dcf8c19ef98f15e81d65f18b836d910103b7257f27dc5a60eb5d904199c42992eeeb6d8e43fc00b75d3712d61497ecaf0a9de72b3299234ad2b5b9c3d4ba80c8ac65ffd8769f333f7027bc461cc3d408e8acbd3818b71cd9a91fdf59e5f12520079ff9b085a5d3221b7b633aae93e0e3e808ee28455e9937bd546c5aae42c269b5de7a492a9fcf07b3d5d6a6f61007f7ce54a23b8f1f7c8b231799f2fcdf0d38da20dd2d907e9c941624a420299f6ca562f54f8dfe0e7fbe7d61170a04cefe4fe5554f5da34dae50f9758d36005687471cebaae3c422bdffc0c9457d54af16c4f2b8707437acab17f68a778a598e83c07a7fe0c80397f490f7be416819d680c4b1dd2058819e2a18094750068a3c53b6f7d7accf890ee9dcdc7db69de21a5851a9837f6a32014e94fd7fba81fc3f554cbe5236144d1496d3b1488b84b684e0e68a051772769bc2c4a360cfb2056ad1a95aef4c373015e8bd0bf027eeaee9e98d6c9f432b88f5d24b448bf6d8724a7b1719981dd09a68b08469798424c25fb8e8adeaee3976df488eb97f46eea000db695deb11fef39ee5e52c089b3c7d234445829027988cf57ee6d35bcaa0280d1e71e5af67c45255a1a4813b83abd675b4a2fd02fe01240a55ed0fc0342c823c557d7a22b3f5f42f618670b8d14b30006fa74adf3ef9d5d33179d3335acde7f07f14e4017ced42c6d0728bb7bdc72eb21802341959073a6c2c6621c5e913164141ae0ef259e8eca85e0821f820c55935bfdae6debe98213b410acd7e9dac31aa3d32e769281d6842bc64c0702dca8d04cbd72de320723a929e93a2ea2c38b1db25f34391bcac7d2c292fb5d1e458cbefc2ff0b45578945ae22899eb0af93ee732c123a8c54bdc639991d4f555bb09fe4f7f430d734b1a30489d1d4a3f7391d5f243a4f8ba877d9c32d7e4c8e833ede37b4447a2da31aafbb80e3dd05ff91df5e65cfd547dc5a21572c42895aed1f6b470663221b2253d507c0ec48217738eccdbce3accf548ca8fb7b917e72f625612c16e8c4ee9ee4eb0c692f24430561b67dc98f1243f621a50dd8a00a7019cacda3578202881326495c7d27f7f2eaecaf16468d8fa0693656a6ef869fb9398d816ea316ac0fcc3f30e2c09937666e74553575cac9a88f291f8c350944e881f80396f25420da2719bf0af868b77bd9413c8d0cd5e1c8c11bbbb40253937d14ed526c3410a8fa0c9b57a4e8c92c9f1044977c59e11735d28b203aba36b2503261417b1a37a44812be3acfb60e00066e28516dc067a9c7bb841dcb819f1d1dd1f209db689e13ad497b9ea38399229c29cbae72df0f08609e3fe66f69c48c4a870c0552dc716ad6ff7fb0dd4ddb216df1536bef4cfefb943947c7e8ef4c6196966d3bf2daeee430e0c33dd75e794af9a3a695e86d700d8ecef2d4daa4fe7aa69adcf595dfa8b8d9d643b1970ae2e6aa4dd138373b8914dc94cb46d666fc1223770f186366089648b22cb5a6a50c02424246dd42af1daf5f1e971ac16a50b36261d6f93b4c7fa943d14eb696873a4b302e716a53c95bbfbf5dd20e2cd63395d53053959fedef5fe455ae489c01aabfda6eae76f0ea3d9fe8a5397aadc5da9398327d26b63d461d34e8d9c5a9f22fc23e361621ab64599ff5384e09ad578de804b54a60c453a2108163a9fa7157ab393528911a9bad08cce66ba0acb4cdeafa079131fdd221f51f93beee2017aa58f76ca89f7633009891a3400222cf619284d5acec81e8e0f445e79f94106acbfb09bbac8cf9eb41895e9b96bd8348617d28061008a18f5fa55b1bdfc112623238a0fdb2b1e71aac1b08b673565385a9d637cb5bdf24e6445eef68e1a32d8b8309abb398338257ea0be82b996b15c6bbb590a400bf37bc7c2bdc702117a133285660c5c6bd9aee8a8be7c89c305cc9947cadbed2968f08d30fdffe057dfe78a873975f60e371ce686f3ae4a844d4eded29d20d50b946979a2826bfa2004a8aa03f0eed8d32edb95c4340202828f7ba49484a0e0123fe0a84bcb301c521409cb133d69d7ff0f4023c1b7993411dd79b70e07e385787f06ad28d8c52c89baaafa43e10aef7ee0c231442dd86e12266708111ef8b96d2a789d09987f4deccdd12f687dd703b1b0d942d3842c5d398b201cba6f951322aac507ae36d7524acdd95e51efce5e20df8d4ebbc1a2e924532d2530cabe5d2b344e580540daf4fd713212d52248add0379d495c8fe4bd567bd8b145b20623ef8a15b200d55fd09b9ba380ae16ebb7a1ed801c7636a6e6b1af9880f739da6569054021c51392db82c7d8642e510217633bca897f3e22505b95ebb82b158beb80e38df6ef35fc750245e7370b11fcab3cd3bd5851a6f7e6a8340dea44214c022443e543769ce838c4065397e36fbf51583161ff44a6833ef3be478b4a305c87e1382c91a92fd071b987a8cfa446ed2d31d5cc02ed194f28d48be300893ef7e7f13588519d16a6a1cf221be0b5b5e9cebe0fc5162d52cbe0ace61544464b31706ab79d94d22c07672775ca45de3f92d6b6c0928251ccb3cf3f551d83914f863c249df85fa5e91301f74ec01922d203a41ffb528fb00943dba99349066c51d7167773362c940c3539633952ea9f2fa24606aaf527dba382f9bd2843d6baa6db49b940a2537c89328d5f05c7b82b337946e66c6efaaaee01aea37e2123d32b919282f81d032e744bd1fb17e3e18e2b91f135cecb03a1491319f598b7d240dff240f55ecbd0b72b75b4503aaf8a2a7f2c09d98ac8c255eba518ba8824460ddab98a08891a7709e6f7272c3527de965a174651b94923c1514699c2d51599eb28c1b2d1c2ff59b0448a6608287f8d8b776730173165b287b4f13a032bdeff358d729140910b45969447e40bea4c3468bb42361c9cc9ecd23f0b0855534c07076926a33a46586e74f3dc9566284482fc40e4019b628554d666920b77652146c22aaf5258bdbd56dcec0df7ec767f231fa5cb96d330bb08d90cc7d3b6c0f343983dbe61922f30d84a624817cb0b8f7f45e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
