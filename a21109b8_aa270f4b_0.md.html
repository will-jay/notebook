<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9911193699ca3171b252e2178a55d609e5684e32e0c41d57ead16d9d998d479c60a07a20da3742d510d5eaa2605f5fbf7561468e5311cb9c85e86d1c0b1540de2c2e38c8014508034d4023b37ffe5450a5babc8f3a22336d1891f2e74adeadd92f0e2ef7b11e8e5a250a14d0703a5c70b4b2d0ed84e203ba89d1ff9cd8affc05b3467baac37596d513b0cafd1fca9fa233cab83aede668716a6e4098a040cb919c2ef8ffab6e4ed5734f126862bef9de0b3862e286524d0efffe642d2c12387bcc84bfc8db8c9f8d94b63db64d1181db73b92635f7c7fdff13ee9e77faa2c749e01b833660041db659e1838b76b3360a649a680247cd7303042f7118253a46ebb1b6845623e9224808da621b655d23c75061ea81b9756f826e20d8ccc7d3607a21dce07304d972bed98bedeccc5a4a6fe122d5e0c02ef56b2c96890c3c24f94b2e151c13d2bea85fbe67fb44a8ace344bf6ae78bea88a7f1c7d17a31a06b07d73601aabf93aaa4f1552e338bda8d9add639aba4c2de5aaa408722bb7da0d300add094b4980adc15b88d9eeb2064c85db59d592d1f5b6687a06549cfbfdc96be40a6978b8627a2678610f8ccf55d383eecade11b35d67f66c045d2e9b1f4c7bf770b9393f31ca6b8e345a7bf3d0f019571c09c99255f0ba6774aa66d62dd5f4ceb454793edb9d26296972fc9fcc32084f6cd02f60163f0587734631bcb785335a4fca00987320dd99d93484d481c7ad0f6277d2b9ee0de4622016c73f12ce3ed7b26637e7f30e02ed85eda1edca55dfae0a884828accda446095b4515c440cd24b0d5c8f30360830af8187e36f25092de959e4b8888163c4c6e8d73ce2c9be4a7cfba8b5b8c42533e30ba9f6a68d9781925378f5cb8f6a1fc82f4ea806404a86751d941fd69eaa6d95d6da5c6cf1dc5f1bfb244d9c86df82cb0e8336e5ae0567328168d10baf3ce95c6a8fe96c14a0b1fd821a2ea5f1d6818d60dfed65611311dc4e7db641b157edc517880e8584463b0ec2b32ca5cc13ecb40f5fa94077045bca99be322b829ffc42efd5c5db73d2c1c8db4e4d7efe63f25981b22a693448506e0f29a67f64efd5d5dead9558930ad0b479f761e9d9f80f83365765678bd4d96c3acda4d9fee942be3dcf87c771b1c787357c666e797ff33e43017ec637136f383c988a100e1c738f82040e66cd00c20b8a07943e5b1fa0fe85f96e1baf099ed7455570fcd19ff198ad8e57a44bda63e82c5fc21cc851456b0fe7954c35aacc3569eafd6f8bc8cec32292bbc3c4eac505a4bb64ac7c3e05e183555bcbd165c1d5fc057217a75c05fb6aed1a6b6852d9f7ad6c52aa5881daaa54b1196355768e457e86ab414e37ab84e0cfaef248e64a4652eb7911b66769693d4e1b0eb985bd1545a48031632b8fe45365c0a80fb151f6f757a004131c0671cf81cbf2404e469d0f101c6300c1238856ce3d8ad2863fa18e7c5cb88c121afa4fc8b54f9663977e246749e63c23b255349ea10f561f9e6c42268fa85df1939165ca067a83980d17517f64c167f7f8cc25d6b65c0bc413413021357ef845972014c123ca9f218927aa2a61455d1c5b990cc6d523b9b4adba894218c084b3bbefab89e0e24c1a05f4a5817ee37550aeebc252aba4d0a604e42f6afdf1c31f87a7e0ad77722fe07f3f65085689eb86fa6c6cbf6b07e7a06ad3a53b95885922cf8bfce5850ffcf67025c88b7caaa1b989d5e870f12688705f7776ebee8f1270dcbab8da098f652121d8532b5fac3ca32e659e3d24bedbdf0a2b9aa31ef1342e1d4a0cf177a3681debcc348abc251360846d941ae12324066d405a8183ae05bc816bdaa94a648358f00776f78760377cca57652b1cfba6a7ab24a78b66b76017c7f5cdfb0b8d18933c3b14473c5394283637bc67d07118041e52971519ed654a6c514dcb3f816b6332a603cff271594501968ca4af198da69bca11b6475d3a9087043cc8409adc15b384af0a050cbc317ecaf3b0b4794104c83fba593cc4e9cf5b90a48931b45147e19776d64afcf1538836b4a0f5fa1c079fb3e33032e86d3fe2c453913a714db609081904641cac25639ab9e27a3ded0dacdbb1b89b095e14c3e594ca5b12d3aebcf0712b7560b1fce8ac926763da5ab4fcfb839cbdabb1b4b3830fc0c2e5c9a581ff98499b9f332f5682f3f7b792de76862bb39b2e6dbdd72c6e600187c4778d8edca9464292741faf3c78699ef2ce48b769b43f4624e9d33a7d770f20254f7089392eeb4da93a6c40ffcd21dd0541ca53c69451e8574057b6541709265955d1e22049f65fad2fe020ba9946261d3da074dda6e47f7650bd025b28715844b5241ed0c12cda04770613e33c2ea287f292733fc089009e092d2788ff8394b0cd8e9961e091416c916683a7cdd9f53fbbcc271a77243cf9738218eb41632c2608953f3e26be9c19a071e6da15f534fe20da2787fd0c4561ac1afc3097dec7036d4cde831c80fb4dda9660a649d7be3aaa46b385bf5b24723a7c7ae97eef12a92b64fa78c66a993356e43a2b02a97f348728aac273462c5821c6f0f085604370519f7c8a4d7dd08b542218a2cce618c149c66be6ce67ab2befe36da1b8fbb8908ffc9e733e33332ce6a0153eba83c8da4ce6c2a65eadda6dd2ae2d6579bb071174a2ebcf0520c9dce94c104559977187d2ffaa22b827e48629906f63b35038006ee8284813f44bcecb4e444fa80112822134836eccecef7569a13f7466e75edf643a32c577dfa7e2dd89479f9bcf581f62d439be253e7896a60db325fb685ee89ecfcd6e61e53e4ef50e327f2593bc82f52047e0d5abf453f2d98764a6f730ca650d288b035f94bc9e381dae85419b1d2750bf2d5130dabfb365abbf9d1dc8b94cb18d343960bb5911e14be5a1b780beef10df704cc62ff050c6fe8bc374d382f789d72f0e44d0df9b2967668342602c71921d6d66f836de738a72d11a7553559b5ca77f0c029c45f5834b203b89850b8bcaf019db0cb5fb778480ff83fab40570636e82abb39ca2d8270fe5446434efb7ab66557e44e275771bf12aab0da0638da92930163ee2eb5677b970c9f2f4f84fe139628ca5e60dd452770cfd53b1a51c6d8baebaf2817af885f5d509447c340f414a194cca48d39328381c94928b2c76dbd09ae2f7c2276b6c8630658508ada025b4ade357109b1f64e37fab830ead657e12ed5b41c61d490fe518546c49b524b562cdf29ed209d55888092661e24abbc7fe407347476d10ab4014012d18cda4519fcf1d4744d5b661b123abe8bd1494769718e51fb2ab2b2473518f39c0be2187234986c1cc9bc208f3666f4b9fd3df39b89d52bdca8115fa8702aa67cc62904c07b28d6d3433e10be6bb5b3e00241de383b9d20eba920f082d889709f07a0829f7893e5846d34d8dcd744a2c8b8d3f4ce6f236bbca6cf2a78eee3e178de5838088efbcdfe42732de142480afd80c72fc93beba486192aab1ee935d5d72e616381d540955586c280687f32dddfd750b5c27af3c142285e9b87be976ef3897d4eea954b14df29188e975a1cfe09eec64660311b34e272e90f3ee66680552b555e59233035bfcb1ed149a6780e3a79af72dd13af401fbb41b87116cce48dd28db54eca908ef8a7fd58233de3c2345f0f4fa87ce1925d410bbf70060fded4cb2bab42a1a8a04081540021934df0761c744079f4e8faf4d531ddae9e5315012c15d144036d7a47eb2fbbde47774437bd075f66543a5563e232983c7b721297a0672b0efe2ab4d428fcde8bd08f3e00c4778b99aabde6efbee57536f7a3db2b20281a8b480e36808cff0d2007f6c2976795162e0e5ea3a2f8de7c743574d9cffcb9771316f714385ad9815e2ebc17acc15b1dcab3e90d8c1446d878a7111fd2b766f4baadac8092cd961536af1ddfe917a3183695d8f0c724b854132aa64b293e6cbba4f306b339a0d400cea582cb1526f7d0a8d80516f83f4d8e7ddd5304db6c2c32a98322efd162a5339eee5f4722bec9d544d3cc3f6c67c79eea1339c55ffe3bec8b580b9572283a75b5b376d389da538ac913dae703d661d013c0f93bc73985aa5ddb001403d4b29be0492ca1ac6b040d3d87d29ae06ea03fd4e042b796aca65a04f23bd14b1d1dfe211e566733b82ddf0c04744ca5466b42da5dd7c115312190b04832e4cd572103280a7de04d82f55d642d472f01a96fe5753af11403c41985129149b20cbc4a028882b0634eca520927ac44f3ca5a4bdaf407923aac2dc9e9d47347dfea4b6c866637c8736a870acdb9fa6daecbc0ad787e161f05a85cd2119d1c4a80d842d0d1338890857793c86cf1c35b7c23ac8d08fb7db93b09fd6a6a54b0c138d94e67c6efa0fcf0be499b4edb9271f2ecc6e2329e4b11a7ef656ffa0d0ec3bd7da5ab484ab24a246de90f002d74c80816b623e1d6f14635d9d6eb0b9fed39fd203099bdced9ee35950299043aa4eca0b58b6b2ecbcc47e3842144acbdc34d85ea4fbeb3e3e1aa68be61340f9f6a593c3b3d575499fb2d6e5a9bc527788eed1d9956f1d30e2ba5bd010dec099a1ff80a239032b679117e69b23d747279ee604f2517503892ab937079215823cbf026cd27fdddf4bd22b57380883e8e308da49af80292855928e087d80be8c09ca453e594f1db241e79f464b2071a1c654c07cdd05f52357f6c869c646da35f9e823db14dc1cacca50adb4e8af73b75dc417dc18e5e90673339b207f648eab03f9389d8ea4d24f2d39ec7318d4befe6b9d9ee870a8b3f2ca4d09fe418e9ecbf1e7436feea7328da7500c712c2e8ae4a5f776b83aeaefc74563e2a8ec0b3b662065ac20f70ef5dfb1818921c56efde74ff3584d40b84a235bdd59eec911713fcda3e6db6075280a2ff63baa3c1943f7a3a47a0c4b6fc6216828d2edf8e190c0fb049c8730a102af20337ec41a33e563343436599b438bcf9889a80511731ceddc7b25168bfe4a96a22ef49a2064bd543ddc680a616f06d254f594f5cee1e0252140c0141fd430c869be0eaf4f676c079358f2d46c7bd76f9ff8b6cf43c117c23a33134c70fab4f89fc9ccc17bf94573d0be126619ee3f74b9423a2783531f01fac9edac86c724a7c8b61a29ef511e5c00016bb9ede5514c70c9188403a3ab5c55d27e3e90bffa0a1a81c04715962f9a68fca2c54c102e738f9d18ff9e60d90c38f01ff7d6ef67f7c754565bca2cddd34cd1de6e8f584ac7595bcaf9fd6d0b304171aebd65254e1640f6b38f14be1dd8f7d7cfbac7ae111bd3d2ee9a66bfdc0f78608577fdc127763954d1e0f362caf1186d9afcc81d52709c76ca5fe14550f01a0dddfc911cc17371f7865c04d7c7dd016a12b7449d8a71f4996af93d024da7768e2ab71e9ec6b4581f6c83e1d7a29b935ca4cc768ce49bf618be4d59db43d05cf9a32c4b14117abdbb152b3c65e488ab1e8a1b65fe3a58cc498d05a509b7a6d73bcc81cf9a0ffa61613d28aa61e5550dfe0a5c133bdf12f51ca0db6e84b33387cd95c8aecb29cfed3059a31a42f4a3e73430f1c6f1e882f89f85264afeeef4a2b26c5adad4a9cc152f4b8087684e981167f67257590c04b1d8dcbc19570eb3f8ea56aa275534d95b769067a055026e65aa99df65ddf49d5d9d96128a629c22f25af7d9e1b67e8fbac33bb463c026374cd7a855e0f5847c74f676ab0f8ba13fa1f0560c7e40c658677fd344fa5406d72a82327b7f04c4dfc2b6948e703285916153cee34bfb76f83462e4f515a883c657628d39129239f51a3462a1f5c41deebf449540b0d8875b9d653d6a6c84e4e4bb7321de888a70b21cc4b97310ae3c567512476a670a4bf910196c50f08e22cab3124f1798fdd706b24b0a8a55e6066c18d62f610c7ff986be29fce0751e35b5bac8f6614584ad16ffe55ec0108418fe8d309418db8c2af9f18c69722d58f3b64001215cb3546b7e3d7555a6884ff10cff616f27ed9b1a44b589f42548f90f4f8f6ce15fb9ae26d749aabacfa602056204b899fd54ae21cdc7252a51dbe8f2bab73c6fe49bef263f23b81245b5c791f770449d49c7d3257184a9a4fecebcc6fd980b859f22f6412f8537b2b2dbbfd63f7cffe5f139f05d8a45cb7f3e9115eb69b100300bbc53d12da06ec903e1fdd96d61b095fafc71286f901d983a28265694c8ca396d26435d4dbd7648c96725fcde0402ae1b831134ccf17b81190fea0d9d1027bdae81177edddd99269cea267488ed54ddfcec0fc4b912308388ab82665eb8105b3b4314f987c0b9743ac1cab83cc81a82baa92663b704ec0a49d406e8cd2cc3af9635713839f3a669dc772de8d5876f809536857b157d411810108a9632328d780363f40899331a780380b1287f66e934e9ab874b6684e1666a791f49b299e05f5cbbe12b08e003ec6137344d2a097c24ed98f3094c3e4fd02300aef48c2535cff625a04ae59d1479f7cb3dd20259e6c9b93580d40f84f03d7241ce445450d765a7aad738805109ac2b40b6ec682e29d86dc88161eaed2d14c299f934046397b07978e950d886856d7daf37311fa648350303077b195b5163e1c429e61b95f743046ff6bfb73bad4ad72485747c0f6d4648a972614df07c024a1ec9e58a059dbe60ef3d3787f7f96aa2f171f8618d5b116a3d72b7c93eb0e1f6171c0c68f093817779c1ad09cb710dcbeb213cd25095eb442386c1ac28d18857b2cdd34a3b2e472e9baabb95203c7b8c2b70c3bbb9513b15a52a8f11438db53981ac1fc7ef0b9cfb918013e87fd4d4e90ddcb12c42a92aca228e43514521d8570113c57c3382f2017d64ad6da2f0125106cce36b876a033c33b15288278c55a700d540e71073e809d651cb94f43f06e10ccb8e6cec847b1f54e1e1830cbeef2dd764ee5253b7f3e1e3614d3d79446a21b34787dedd3f4db9867a46acac3750bfa271d1b4cd13e514a5998efdf9a6a35dc152772a0a6bd99559999625ab7bf0ba9db94210accf5c5a757a33818da50246fea9bcd46e99fd81a20b93c40d4a2439c94ff6c44fccfb41df6ac53b6f754ab0de228abbea3cdddc60f3fb7b566b3773a6923df3f355d2b531d39c4e54e3b24cd616f47bf8a021930df0945af05e609db6dabcf122cdb03d971957cde369debab4dcb20e64c38f0ac5fa1327e5842e8107ba4aad869fd645d6f555c214c7af5fb270d6748451fd7abd7ae92ca62131a6909dc16000f5fa8620cc455c0dcb35fcecfde46034e1b35d8a1cab1d0be2165199a283c4ff84c4f65e1ee6168ce74f30b687fa007f38c6ec889adc0bdfa8a065e20682bbba5b30942db016c3362a522b9af2b8dced122f2fa0a7339cf26543b597b50f1b64f48beab6d76f657f14d4c858b9d74b55d6a731ef6d322a49eb433f64c0df3a5ef0ea9e978943c47ecfea53e598eac10ba418b45373854b241797ff46dbf3bdf7ace549c9203213a1b1b7b69a92edda5bae0b63c9ef6f1fbfa825d3384ba447885ae9ebf5c8da78a402fa498ff3587cf38a1107ba89ee72944d562d5020b09e477929cffd30f234e111f5ac37ee5593cae6b3e0d98009be3a00f5d545458ecb323ceec797489ce0a5c3b044f9d8a21c87aed9efac122f16e22310fd6b5aa4c33102fafa5a0a553512422b98f739035d1bbdfcc6d571b398c6503d7b4ec1ee893b1d450c161618d96bb7d271383e670974f7536144c13fc5eef410af121d75e9a20a0d547c1fb7c794de575d9941a843c76c24e38b600ee73c206a6e812b4b9588121b1e90fb6c0cfc020303fff1b289b749a97d654f7669513e62d28779f860f173d6c47089140cb8957fc2fdee077a593baed46a1dede072750f45cf917c7a402a5545cdf23b96eb09d7fbd0ca159425ddb0713972d9986fe83aeacb5c5f766ce7b74800946bfccd2575da14202cef9ef1a7b12f3c880f9ba38fefabb592b9b49363948cfd5392361b8f180a4962a5f6351cfd8c4f0552568eeb6f4c9626f9491aed965d243b4b6015b9e26d6e92e5a9b931b34c40800b8ea58cd95883ead2446a4d25bdfcc8f56e0181769a4f7f2279ad3869999e496bc75c6219d1ce3fd8e8f803fec2badc2aee7624a54106850d99559a5ceddf9cdd435995876a40e6ecee12bb678c0f52917b9b97f15f9d931f1384ced2503b904e0770164f18317a2c3c4395c1a2872c6c0412ccde5ccce5fff3496432349038ed1963518e3026078502d4ed91612dc14348b7ea1117f26e6e4e2dc0be1e66e75ba43230c6b45fe79639ffff5f27ed704f80c61c303e7aa13cd060207f731f922f7d1c60bf01a427b89a7666881eb80c3f259325d6f83943208cdd14f5db9b19469c58e52eddd8b4982b3d141bd26efaa1cb1897cf080f242f172a97c52b1021e5fea3bf73e75ae664878139868e701d353d24f1327af097480aab770b8f374a5385527506932750f84e53e6fa7f31eaf50e1d8df8c66d73069b4933e0d50b1f8a147811f4893be418f1e94d5e80d3820f23868f08cc773cd9df4c4c03616fc30c0aa2ab4e0626932f96dee8e136035f23341761c4faabef4a55ea676b3448e6968c8839778d299d928ba38c83a54a70b5196f48511f26852718a779eee454d4bae89c159f7d099935902ca1acffc01d8a4a424d52db9283b42430ef10dfd6cf52775820d84aabf18394ca12e2dd3d07254f46a4a888387306f3934d5b0a1280aeafcb034a42c592f4d846a78c211ea8b40c4a052877d972cfb4fffb83b4a0b2117e09c34fc4a038bb2851f7400ce1a447eab90519464fd3bf2f038c110eaeb18e31ccca739d3eba1099b790324ee712e36272f01b6625b79eab3dac2064d20ca177ca08332dd188d6f653b0b4a9e43d72d6bc54bbec8626d6291db79093a10ced8c603996010d9c47e1e83a0acdd7cf64b36e3b378441d2ba5ca48826ba45a01869fc5ddbf5607587339648d503d75de8f7db2ed8725837f77430c42d52946e7c5a6ee91293a6aa85dd753aa6661dece248b66e8cf52332b3e199643b852600d4b265ae6b6ede615efe9e670258b1189554b5eec7a85bd349003a3741e04f434bfaa7da326ed214802e6026e1bb759b9a9507ed69c236ddbbbfeae4dd3cbd67fc2ee6a41b274599fcde2c7ea48ce1a67e93649c91f639a6c5bf01ef6fb4865e7c2fc1c3a7070535612216e866fa9e8980946c2338fc344661faacb7fccd9f72f607606db2121e9cece59af995f7fe1f11ba05cf97fc66b3c10b000676ab7067e55f9935544ad553f3ec1ab3094cc4bdc143807d35ec1bad6adc275657e964fa85f5969cd9c6701af83e375668d12be022a17350b03c1989346290187a322424cf9d7dafdc44b99edd2ab362c8baed48e594a070d955ce58a7a15f7fad139ffb0100adf6adcf0bdcbf1e852da0852d8be9168a5846cf14b646d38567a8dd050bf9818a3f06ee7f20a4e1139cb0e29f508b755f1618ed03e6d75d6299155332100ea95fefccd07f36217c5cb8059c223a9f49b60a3be53a291449a7327302ded1aecc439b0544c8f546ad7285c2e8a239ca386f98f495b6c79375a4089d83c27e5f4a077cc85ac4d4351e9535f78dcbfddf9e58f85ae9b3f78b3dd5eba4a5c0ea11efc07489928edf0138643804617155163d2a964cd0b5e47ae2affddbacee7dc89a7162aa55943c3c3a0d5dd43afb64b12d45753bf98a409a378492b4cec3d0ef45aafa36b496aa8e8e99ef436ea4622052b1cd4704dfa094ed9d4589f666611e597666924fef3530cb4e9d565595dea53e31370a517b7de29f578784611c4ddcf105dfea27733756680e9b97d8167a10c6d48d3dc41feda14bc72d478f624b97eb97e02d28801ef0633b4119d91f50d6b6b856e941b514d79f2edb3515cf7489312f7b4d1c4fdd940579a03685729b93664ca214587625a1dd6e71b0b2ded6ec1e17b989f01ce5d3266f8692d7b686fbaf010aa892ad4e534de7eacbeb835b325cd6fb523b99721315c69c090471ac21b71d66f2324b0daf4eb0eaa216f951c661505937df705442d597ca56eb7166b2f47afbf60c84dad4831d5fd3956ac3bc8171c89b662e264ba0a01697fe0c6392f9279c222e906bf3850af2c37142112ea066fea0623c4cf30239f6513c81cc3a160e0a6e6c6c1f63706fc7653b57407a42a4a4cf98753f583274c8d8fd2fae23eeb42952028312a897966c833fa1e1dcd35eef4baf9118ed7eb6bfbcffb1943f03e814956bc55074b1e6d89205244a9a95dc14dbd6601e27c249d3e3d8235c1df3582b8ef42b8f134e66c6b6c27706c4beb946fbb9d129b390879b3be3d684f06c1702a839a2ee1599855ce67ee5d2b7b801aa0be0fcd7e73b199f461ac90dcc840b5cd19ee70167624c0ae39b9e946d66c54a331b823eeaf272305600bf2be55b0b06edad85d1bc00bfab5f26e37c3fd3eac93bb005db0137d55d6829b47f480624fafdb70c43a860ad8dd51e7fb54fa7636e6e0123b1fdde6f0cabcf33c8b3dbff9f0ebf7ed0f5f85ff336d4788c800a065094039381dce787b98e502a343565b9cfd33cc2e18dc2a75ff5282e0a99353cb6ea35bc0d7aff59974b31b35e5748966b77277949d1b9ef721e2996081efe16af8cbfdadb6c2f9a5d5e969addcd317850f08c4ab166f32f71c442364d39d4ca756ab4a79799c4fac0d70805d2ea768a772b1baed91bc0ed749b606eab702a9b75422a15e1e4a1c85bf3e51ee86c6cf5cb4b2c7d545a1623daf74a79d1409ebb6e420c9dd66c2d09ee82de6d3e20cd13757d6c35adaa709227c4f47b607c98cf679dee996a4ccec138b51e26401f46280218882aea9dc06aae327308b92e7a5b262ecaafe0e49ca97db9831d544a64c4a6d95c72a4e94be8e664f2940de2a05d0c22ac33f17e963927f9217553a798f5b45e85e11c321e27bce9dba765e05d9f67dcd6f86912230a717c95f05128a99a5e531b95dff15ee8b8ad8f3656f2f4ef329f0bbb225f51d38791d653467a8540de3adbe646c97f2eabdf4cb2cf0f7db310368a4b1b8b495ec8c860d7ac433344d601b7f0fd2d03b02d565a9482ff2542e384d4641304b466df36593792ab5a910ff48029b380bd74c2dd9c6b235f7dcfb93e8c1a560ee217397eb6990248d8d6c1508a00afc6cc5333eb9c20d5b2e3964c57c9b3f73b8e35924ba10c0b38e0349f60ec204fa2dc49cb3d572ba5f79f6c6802f6068a98b073452e9b1de768d3b8a14ae350ed91eb513cff83fc5ef86d1f791b8d0cb92c21d6a82422078aedea6b16fa6575d8d08bccd19e9967e02a398f087c00578733c37efa284bba98d87bfc1e4e8ec9e5dd10c84b6cf2c7bcad8fdb4aa7265b2c6fb695d3509c499fe266039f44928b45482bebc75d8c25b880772b69d269905227823134fa3cb36d0f0708e2e7737c83d4a6f253eae121cb773ceb7ae1a2675780465696bf34175aa35ad5e445ca6c8d5360b981e5a9379e7956b9ca72c36eed1211465fb0406e76769255f49b7019ed47d2efb50a9a6ac6c3fe26bb572fd3263b76fc0313f2788254cd334885f9a5efbc09074a6d878e28d1a1fcae966388030f4023b6ffeeebad98a1740db2739a44002fcf6b3fae9314ef23f330f2f22082030909a3520ec033d67993cd2801224d9230ce1904126d4d80191f421b35c42ac4647165b33bdd8f14ef10a5cdeda3cd8df9114bf9357b4af10eb8f8d18e1d7c61153ae99d3ee5cab566a20fc64fef5fb8ac0f49dc3090b08ed46f31202199415dd80e2eafa6f31883a79814265b8fcd0921540e44509ee1942a7d7451ceb90a377fcf0bac3220514ce3005dec7e93f1b502481a08c9e8b71ecb7d1dade957ee1cd7ad0914676226f652570dc533bf32ab8c36eba7f3b4e16929ba0e6e88369210667c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
