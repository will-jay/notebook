<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f7f1793dd7db65fa671a2fb0db478650c0eac568deea00048d964036ee409e2531de24ae7c5fc0bf01649f74b331ad7c4f88c2ad6d3b78b044a4778add343edb9d2793a2a383e9fd054c1b1f2aaa604239168a7ce813a9c39d1916b9e64979c774ddec5060f245dd7319beb46c49fb1e0df3e6a79cadf949888983454230ee80264606c96c5845fc5f41d646e40d3e114be38e9f24bab905585e0eccffd27a7802e97e26e8bb3c6774bd945401718a135995ad86cf07da02bbea314a8be02169d8a5a10f3eb1fdbf40d3b8a341371b4f51b2aa27a9acc7b878f4b11bd98988b7aa333f6b7625299433adbe4d975ea450a8692cfeb151ed292347d683d512cbae1dcfc7dbf6b3a06f801f7914c7f04000ef6ceb09cfc5ded92a99f93398c6302c9e0610e645611b2cf1a93f1ad98ef22e7872b6f21e32f169d8a2c4ce64af9b8a914b5edc720963040863414bbec4aef8f77f8f3dac9a5c13d4618bc6e97815702d04b0f1e4ced05eb6e8158990de5652d0429de7c59989217f6057f6c1112f515f2774cf086a4ffc9d8d3188395fb5996b82bdb3c57083ee6a14f0a05c6bdc032bd5b5e0263ea36ff484c1aa5dcc2f54f90235ffcfa5c0f4160330e7c362c0fb0daece64c2bbdc2f0dcae5ba60f03a28a34627c075615ada9193d935a0bea625833630d168af2ca0527ded4fe5030acb553ec89e3676ba7a8d6e2f3038c86f1a4a70978d3219680e2aeb325e847a7122eeed68ae8cee58f86cf3f65a5a7eaeb6e7bbaabd65e88f99c614e428d8643d2eabbc86e76881bf7a558813fbc69f7e0f9025f7e6707bec78f97fd6dea5894e6e629279cdbeaf897adcf184eb388dbcd8f19975adbc6b2006e087e6b6afa1444961fe09846dea044e23773150813c52e960e08749502fb4fc940f631f93f753b54bd8a07648200c7f5f1a8efd031468cd818022eb9cb9f4f480527c16546e84d7d9fdb632aba47aaad5f7bcd8d6a2e687b271d95650b52dab50f5f53752b55aacdf6e7078b37d425e1f1788b7f76fa9723f468f3d5c219049611ed20bd43bbd2b6cd02b91d341ea2165123f81133a2788ba494a459aea3dedd5aec0cc5f275ab8a8a779df546be71200c9b32480cbe866eea25a9fb7bc41e607f61c90acca231bf8809fedf0af4c3a6cc5383143839e25fcb58b9811ad0a90975893585b789ae1ab6801b1c6c335134af49a21cec60c0c0f6da5f4935bef9de756b3fe28f3c523066d984bb6a394138064803a7d0c0d58cc868f94591b87a965d9f6bb923d71e674913ff42b407d475abde6c41455536af6b4bead1703b35364cab47da45f90fa77f12ed98c7c5b2f056aeb9e94d8c8e2f88e27f4f53779814486fcb9c47db4e70ed6ff503ee5c890d677a8c375344eee87dcc230ef59915d59086256e4a7aa50136d79c58d91f2774e3ddc8f58e2be193ef17863a9e4c2632a6e088b51917e899d7ad989b2592c0ccb9513eae20ccf8a000aa4aa1cc4dbe42da8bfa5caa73b247fadfb0165f7776058d8cd9da5265ccf8d46323ebc42cf480bd59d83f20626cd7283e52726049a41b77086f909a949349d185cd803c4b5d0d9d20ddd4ac2b07ea4e34d825e2351b8898ac5643db234a9ae6647dc610410f55e539202acdb6f7f7eaf39bd1480d0b0bf6b9413282022d1d82734696c21b602ce0fd960af78c7518d225e437ac3e56b504eaed3f1c8f97ae9aaf6d1c30e7d955c0c8f133c03746067cb373a921eb08e3412fd60a0b5f5ab4c9bc21d6d93ce2b56f3a13302aa9c9caa60bbb19c218fdd0986436661a5a93c5c995ce96010d0975e47e600351a69d1c6d1ae2b43cf1f6abcda634b2e3ab9a425e79afe38aff0071e1e1748d187b359a875a3181ac5fdfe09eb3af8baacfff087274cafda9bfccf8e0eef0c12617cbc72c289c8842004bbb92243a90b61e5e1da8daeae4e9da4768a12715f847d841b0f151a13858644085442b6c40117e976564178efb6c68a68e8dbfd5e8ee375607f79fcec6d17614cb9173cc33cd516c0376e3e3f93250ddf4502f576744f717688a91764b82531ddf76307ce0931e89a084d6b3063f122ead2f5221057acf53ee9c3537041602842d44990919ecc2c9a5d94e6b33eb2872b95c11569168b6729a3cbbbfad1acc07b297252e20cbae964668d411634ee3fd6b193880f2829a2f53e5a83888dc3dc9ae2ad98a8af3e6f10b95c222ef67220a917a2f21e7dd99ebdf0ca39b3d60bcc7f2a53801a234d65edb44d43dc56b943dfa73b66b2476ed52c1fa9ab62e5bbcd3b0ffd81b23fc36cd7bd6d85e88796ce3aa16d8a73889e80b592a3ceadd64eac311b0fd90a0eb0bf0a9bb5d17d399f2d39e7fdf64b225d971fdd2fb3e9756c2a37b40b890e6834a17605f331a7eb715163474254032cf186e3588139e2465abb34396be91400ae952b150914e350d081b3b9f09c3fed677f470e7a759f0b4993feda7c47eab2f0fe678cb1773b93fbff167bb7c3b3c7e824b1ce07f80f7d6c1fdb0c6ef5aeb8b9a355f3e26b088ea66955a6fdc363f104b7b49dedc9da6f3dc9907ecf0f15d97c19078d03674fbf01e711876a74444f54c6ad56f799d06adb9241a0a125b42ea1d3db662dbaa4ded7cd1a1ca6e46b694f33cdf54e2a9956c2baf67ebf16a3426dc4b3e2761586689bac5b03e0d3fd86957023c71732e5ab1247b8f35dbf184ecd2329679661142c6d92a3c3d9db129ca51c31525d0ee70ba25fdae9fb1e3d5bba0406defa101f958ac3984700d41d5e8d1b75f6319631adf582393eb6d88ff1d96b97ec4aa5efe09eca8d31e35e743ee7304e4f768048ad1216839d7bddf95bf38c1c2a8d050f59ae1da2c0d3544c0388bc63f37c020fcf434980dc258697b3cc57dc50e8d7a9ffe63e6f516e2f1ca88639fa5cb93df525101110c9d8de268d5facbf6a24616dc184ac1bc17687adb435584f17bdefcf75a573799a4b9629b2ba596a74d0731d3a5de2ecdb54257b9d341c54c8229cb18b6adba05bdf78c3a8d42abefb83c13fa828a0c04d42cb7707da5f94b63bb2b0d9b989b89cf654e13b9a7844d51dab32a81dcb2c1cefe3df56a907edf2ee7710d1ff5b9d22e58db3545086795d671d7bac3f5d31fbb53cca5e5d5b0c675eaf7d654ba09566474a7c0dd95a07f8a27cd6e07c49b3b1d357de4081ef187ccda84e7186c594602cb2581aa709b2d82c952db9fd280170ee38a9b8d63de5e07821f32db35fbe323041804b9f4b85df11dc3572dc2317ca693d9fb4baa3fe2e7882c5f00e4716f49bc6d225c8e96ed7001548e7510abfaa251593fbfdfe66fa0ea46d041e8b82bb3562a6d0c5585c9c634bea44c71eb9978fe6766bd3f3ff1b044520f90f6c6f561eddd9b9267d219328dd0715ad0c4de91f69017bc5799a5d0cd79cb9565fdaf44512ffdbacd7b417c2718353d63ec00e3e383fed3cc203ad2cc077e9a19113798cc65cd317cab7158d600dc02c77f35ae0a15a085854ce25610e87e331c64c9252aecf001c0edaf0550a60fff4d65a88fd2f448fee2634ab1275516c125b1935fb046b968c1026da100666d1ba8002b4e3a871905ef172a2d41adc9d429cb95922ba90865ac391d78aa336db1b46b3210e4d5e4e40a7fa20c65915c26491252a1caead814974baea5fb155dd48ac823651fb230fde7f6d3f09235695d253bd3ade435753525545762f240c9af60903d981566914e09596f4551cff4703d9c56cce3f6b40f464579ebf46e0e4cfa2480d9cac3e619f11b5cddf67b99e74eb74ef1b0d5860a13bb00b4898c1896dfab5927f982eb9c5d10f82e1125d28521c3f0a2799d6509958b6113aa724f509633288cb4cbcc5fd8e3023f626afa5deee5d80c07b068e1aaa04291bcc38ad03aabb401c6c8ae8ed9da3f262dbcd63790c5229f1dd3f1784c01720f1d68930fa793c1910582986cfcf52d97e69351721069ba514627046513cb68fabdbe6ce7c78bc567d325306352092bd18d8579c204a4d066bcb6ff22b5b28a0cb91c3d013d2904f3b84ea40a865d1ac0921695c3eb7c1bc71ed5aba1929e47d4dc27b1c9d80d00acedf2618e5d76f3aea5ca5cd8fa5edaab3669ded0b1b71796fd0db3b10b0ef7f81ebdd47e535d73c875e88b7b366f84383c3e66c86eca78b982a48f5ecc030bebca3a32e3e0bacd2be0b27191cd443290a4620a13ae3c8e9f6dfdb9968ff78c81095e9c806139dd348a1090d67ae1cab1110282e5f97e8db8b84cf14d6ac19fe3358c52a29ec7c1f18a359dd802d56d393fb6c17ad8770961ae33664b89564a7b7f08b4fec73a869c8bb31d4f2e0801e9101fcbce6b73707c75ced5ff2ca7b8974bdcc277d997807e98db88b5cfa638f1fca05b2d76e05a9d45435785d9938143be184c05e4225942f665709c6087c4dad14decab4c2fe245fcddd419b650b09618681bc8d2c71a5c16bf5445ee09de15cc01085460f0feddf90642f6befc44157f09d0c6ed3f32fd6b1d806335a707fe2dcda443ad0166c74b9431d3a1a6d4d39fb4361625403b1928b263f4d282b2c598f9e3d32642f4e8ae1c469925dabfe588a3b312da1c6f24407422951da293759d41659fbcbff34ca1d09e7557809ae84d946e9700ef66e5b7ab93d05b892f357d0a87da8d3bea60663765fe1cb2a03d9b6315dd7baf1335c2337ac29e36c7df54a47d0d80ec01e1d01e2c29cafd0f61d1f643ccaa4ba3354344d5dbb81e73644d625de33679262dd6c596f589bf13099a3155f7ab684ef4fe3f55b8f1e8620e213bbcaf8241c5c79f3056c12cb1db87b90fa8bb9530714d802988d80a8f8480764f0d568d5fe10108379d4ed2f394e295013950178121000401870569ade2348a64efcc6323d07cd9901c28051db94ea085516fc2857606661dc4ff82fed1685c8fba19b8b1534bbd70bb3f01d54b5f6083438857ae928868fded8d728da8739ffca16598a145b03196ed781affe53a5900fb8ff7beb1cf9ce5828f39ebe60598810900bc7e86b5ddaba947ac4f9547f5ac974d0ac7c87c15512a5d1dad497a940ef7e201abe5e438fc82b3ba5d1976d83f94e06eaf701de1d2abea40913206b071a44b946bbb662ea5240e98a400386fe8621a0bbfa27fddc73ac752cf2ea8b578183cacfa4635ea6ddd2c09b68b465006386b0382ae5c102cf3266e1041b299b7cd9391b31b6823564c824be29fe453786e02dd001bbbf726d0a01d6621e0c8f65ca1cd487bb7d03d03c74c471e7ab2cbc9ad2845c4765eebd6d848ee3d46e34e37d827496982c00355d30f7cefec4a0f0e7e507cda956353ce682de271e31ea7a87c1a7d98aeedbbbfd915bd817b3f5ce564b768b161d39a31eee82d97af14772f9c9794d3caba8d0ff4463ce5504e303d56f6638a8f74edf9124e521a4d2476803f9270ad2cac719796718167d661a3806fe13373c4ae7edabc35cb4924eb35569b8c894b8590a5ed672f167bbe6640f428976353ce638cb88e22c7bc808750e18c04f9b2501570decccacbc640bf1eb329860125e7373fb3bfd8eeaca0d745a31f8e5f968d1120aac1f4eb0ef0e209aed40e7019c532d680ed30e88f671b7778cc87ba683655fa5088d4a5bc6461a6fb1e01614008e2250b966d3dedc5f0ff34e74daffe67d3b0bc935f4d1e8a5dd0c940cdc8c72823e9a5fbcb85926516531cc5d98574f7d9f1c0be3e0be9ac3bf57a7005ff1287dc786e7fa0b9c06016db23329d2660839a8be7e67a1195adbe31796b15dc261acdf5e22a02ff6b81d81030000e055d712fee321d015a62834b2ca19163e7367b6b3148cfbd3884902692b37d3a95d63e42a38781d6ed05c46b521595f7c791e4d2ceaab0e424655d0fc9840686748af82f3fd3fa9f47606bfe2da6084eaf95e71e7d4e8b8ecc68cb8df07bbc080921578397b30eeff714f37d1cb3436aab355d0049a4ce5af2ac4b8b00f2f867a15edff124fc183de3c97242c4c97be128f8879976ff2879499903607977cef3c4ece52ad069a09110f755dc5b0c2e0f7f5b0b728c7228bf61e600ec988b63d129d02f82af5dfa484d6672cb1e2bb66150b662be095bdd8f0d47d361976cdf91cb6bed53df2b63e548579b48504967759cf484355b519bad9230b656c26aab80cc4074592a98efd746a6704427edb4cd2edfb6550268d3e32c8ac853d3812050a7217362f8d69ffa1344b18fdd1f1d14eb53f50846023b190f9a1a8a00dce07dfb751b8c4a3ffed8469c4534c6fb22a814b9031dcdf380ff797ae88e213f7c7654d842d124389aefc1d8bad40b0abecef30e8e5ba4a46f306b08510357eec65d60a9d3ffcb9352234c9c4a4329d9d4b0c86a183bd0cdab52ee6d16feb74355c8d76a4b67d70580cc105bad45d984ea041d4583d717db41405bf7d3bbf58d7af569f6fdacffb32e8d00856cf39b67f873b3e26b50ccc39f0fcb6831f41715c3c18b1b0f0dbc25fc56644d950fae61f24591cfda147a714ec55e198b14654625f5cd13771953b34d510696d01ed98eccbfde07ff8ecba42a34dddd25fe3a5785c76277d85ee12beb38bb0078db153f8cda665251e522873d0da0a6e18e67b885c8edfc4b56bd05dd5409a967b511543eba5d5edd2662c134e6ec7d2cd5de50d543d931e3574ab336d7f2148a4ebd887600caa058ae1ee9c10c3ffd09815153c565aaa681bd72e3ca7a409a86751ab1bcaa6a80250e010e0d2d1529fdebea4a55af3797bd544b8150ad1d95ffa618bd5f2e7edcb8a8171e5e458f3451d841bc0f25486bbb6c437931a4a2a4dbe459fbe95079bd8f9b4a47ecdc9add2def698645e6edd6f28dd7ea3466f41ab2c41a4383c270ae09771fbf0afc678e68252e6bb14b31d4855ac3876b11d0a112ca3b407ddcb479871a5bf45a0555ae29e2eb2d1adb953b4ebd1db315c1aa7ebef24a2a9d03af473bfa4f831ea1aa787d4ba67ea493a6c28f7c976a4b1e6a0c9d6839abd5a24b8c7e1075c31d2c1b0c23bc731502433e1b1621cabdf848ee3cd184689ca3d65d79aae8407716fca4809e617568ae96e93efd98c08da10ee1166554bafac69210a8950e25a54b752bfa17d9b63e4bbc41c89910801fb4d4091b07e2c1d22241fe332646fc97bff7576ac972bdfc3e55a1a5480066b7ae869d94004270acde6430091e856a82944afb2efb3c228a728ff7e49feab2c456972f140bbd032387c198d8bf1fa362f31f8dc4472127bc467069987444de33b5865814027396174db05f9910181a68d65401f36b075d2ad625a05f325e048562758fde6f7b63374dc1b817fae589538ba95c14f6a8c25e49255f314547bdbce774fbcc05b0f9b711045ab10d7ab27d1e5f5b9bc277854c6bfddfa19fa69c16f39f2cba2f3d6dc4216b223664700cebc67318b5968f636add94ceba3417056ac574fca1ce924bd32faca29470050c2b9fd6bdc6bebae1dd002e1fc29bbffb2281612b555c2f276fc3e2423885e7ca377592d27610d485caf3e3270f007d076e092ece58c37a6868c33de5aef9c94384fd8fc707ac84db594e6ad9ea73accc0026af7964d043036b79ad420bd69db2061770cbd365995a2274d83b56d6bd0a6ceadf04b81a49f34ce1b9ed1c9ff83fd533693ba6eb91ccfd9b4e19cc6f4ea05797ab1be0ccd62ce34431feb371c5630441cd09711e105dd1ce6e45ea4a80a348d21c120df660f3bb45b6da57f78af3a15dd2381b927ab82f43c1310aec1654f41d3b4a63346ef03632f7861933ac2759814488a43195c4e13f7cfff0091c9fa02910d30a08eca5932d82eaabff295d5b8c6cc446e67f6b29445a4c460606f02eab66514bbc825bb8df227f7549a687d57abaf76b740fdb290c7c3f53f56b27cffd0959a80a22718ddfdabbac4d05aed0f5808c65d1256526767b9e93cd177d42ea19f78723f48312208e9fa1d481466a1c445a5551190591a7392aec6d379c9593280f4d4ea4e95c0c0c8e1df0fd0457f6361d2c789dab2fb4d9dbc6a0a0dde34c18fff00adfb366fda0f3dedf07bd02e58b1d8216502e7243e941791f250b1fa0d0ebafee5c7ccc805d35410c5638f55ee9e49fc84754ef751116544a026cfa6c562b9d0ec208c7485b0ec23928b5a7b4200c2c316f2cbe479453a889ec33f41d794fb61e1155f6199265ae1f08abd9ea7080b4b587a5e6cbb63617385fa35d1a3999bddfcdb775ac6aa6230c010deb3a79f88a4f8d47a1c9ae7340abc3c59ae7037dc9843c645b11e89b71de3f0570eb452f999bfa8b1891bd36330121f5d2cb56d822a98ba46a80b3cd2cc126dda194c6cda2a60b7a85ebab0e390d0cb8372d42e1990024def23b5a58bc3f13e93a450ca812d593c2698bc48f4f327ac910ba31727ac59bafcdfabf37cdc872b3f92e599eb22ba253adeab017208b1271a68c70f22b70697680a7cf9f6ff0cc6dc26c6eb0267dd71b7a0f15da09786a0aa16fcc6353ea2458b77602a08c3ad06e37c6c84e0b50c4ca1e90f1ef03950304a28dc660e1e477b8b5068938ed0a98866ede61987b0ca773b72f331fe1c2ed585cede324e15beb7e304f7707d7e41b74d2652b00e9bd53bb5d7dfdbc4a549990b3c18dd08bf4f45d72377fbc7d4278d269102aff1ca81fa4e64d644214ebc516d49b0d097fa4657da3ac6a0afa2b8006ae14716bb19b0a3c0e5b28907dbf25681f175f83e8f6f33e1fb28aa66be4c2fadabaa9779369d1d9399ac2f64bd24cca45961b8b1518d8705cf6ba0b35a70b68a30177e1ecdc2ab1135963211d0951e4c9cbff905ca57a5ab50c6fa876f7166d90a32d757eda5298fded4a9ee4dc0074712dbd3c084b680e7d3c761a2816019dff0c6d3ac37ab6c2c6463428ec51256b109c8e1eb4f6ae3385e960bcbbd388ba1ebf7119ed7f870fa1cd3e55547d9b1cbad7123054a510ae8bed47e91a1c9adfabf460d4313d243ced36ed2e510b01efb3059143e4b30a23c0ab705741ff29872cc2d6ceef9dfa01d4b759a1a80402f30a993d37942997ce8089937cb2756266ad75c739031357044bf7b30d5c6b58ea0149d78385deec9218a8ef773afe691d20475a365026051ca5af79905d20016ab536feb034796ccd9dc05d65d3c7d71a4484502b1b1cc10712ac825245159464d048fec40ec601cd23efba6e60a7f4c8414a69f6faaa0445a4b92d67bad0bebcab8b906a76ea9bd3e801f9eadeb93205456dd4dbf6a2c3733900fcd1d1741231ded41f1d9b0e98392c8e8f633438221f1420dcf2abc2760283d577ff3cfc009e688b75592c391fed46da86b8fdf80f43cef76fc0ed15cf9185fdc1a31af12d14cd1a069849e2052a608d620c44061e97762c63694cc6fcedea96086fbaba91ba225bcefff439d78f470d1490ddbdf4c73a720df5d97751ebc52852feb493ee714b0d909110f8eec54c17ad11072dbabeec24e6a225b42b10c25b8178375e602f394497a66ec3fd85d73aa7ad90ff4cdeb17588b036edf0786d2177e68ec6e9a1a017d0cd7b7d562c7ce86ffd492c2cfd4e7c52ef7c73072fa02b031e69b5c097398c7a0517d81c62225e496bbb939c98d7e66a85972d4c36ee1dcfd53000a59ef9ddb0eedc6a20dc6e24a8192945b60169ad7d21808092028c3d271ffabdd96c0bc3830c24923812db3c38f6f1ab77954ce0a7aa000be7f2bad2863b1a4361f982bb8f9ad1b2a50079c6d828b91317c6d371e041b553841a368ed833fd2f499fef1bb5c03c4b237e82cc5ba58bc249d79f383dad7f96f0f7d3abfdec8f265bc44323b2df4e4d750b42931fd0898d51382d72df91b9c2fa827f78f7d9ac37aec46643aa4b9e36b10d665ccdd20ab363a45424e49ca862c5d42197b25d5da48331b4c524a83cf5ca57cde7e2204c1acf019b8ef6fc3b78ed42d63153f6c68c2b7429c4ce60cb4b3707b6e0c1f7ce73e9e9be6dce148af96cb910db75f418190c2aec5e82e6790dfb6ba780d9753cc76c4a277d37b40b05ab80ff2930cad9f7bbdc080b556009c0bdc5a4e760d389416c381294112203fe318b4201f622a1b5f87241657651dd4b79cb99ab897fda170a2ed05d769088aaaa22db2ded94cc219a5798f8425d6bf5ee80b6fa6044f13abc5965ca3ed01a261f90ebff6bbab51093261a55b029cd71840b20716f6d0b6f5130dd3980335d0171e6d980718b0830f66eb70bfb91f22e1af322b71aad32b3f856f0902bdaede79368f6db429b91a99e5bc7db6af2138b1b4d4cf175a97cf66e46965acb2bed653e3023074d58c504cd727e7886703186c72402991c9ad19a567f938c0a7edef25ac664107ba36259858650e4d8da8154c906d60107e432b89561018b0e4459cc6e7940f2af8c2164a54183aafaf277734fede489bf48f221db565e3ab90fd75ffe67a6e8bd3acf3f430d4297e5a0dac9c775fcb24a94f0c7911c1e772cd06068ef723d901bfebd87fe9cec3b6041be161b0df5af2b5a2d27f49417dfd65d5847fc7677a9f1f36a6a403d702af776703dc385b28d6e7822913dd08f9aa0be8cdba626fb836049ddfa26aacd7beedc956cd39a39e8a32276eaf9d6ab448e3d165648fa7c54d069ac2697c49d40cd9291f8960aba0aa54f9264081681991436292422b815236874d56118259e278e322cac538dfecf13bc86df1a82ce78659da69a391b8840616bbdc14d992d23c68d58507b7fb9e09747999fb00698a7984df64b40be5173c005db4ba47ed2939d0bda07570b23fbdb6de238d0de9c875830bbc6f845fb78d08cd24cafe9509dd5ad79ff886c7982021dce6d910be6d2087a8e7df731c19d9f652c990554ecc75ed2f9939b6a64142cda744ddf7f08e5146cf5024f2c9d6318151cec3b7a766fa51f9b619ef1618380948545a6783e5f0e1924e322f6aa7ebb7bd9606fe96af8fed5ad8069810d4eedf60126cfaa204cec3cf55b77973bc8d1f7fd68dee34cf8d8ae4a17a2043e81076758a5ba1863880787c6827842234f4cdd39688d75b1a5c8303840a6105a569643b133a959ad6e3cd18a9c535e242e6a9f896d8e0c95bb497b442a21195156da7cd64f108e6ce30de94906a4d5ec53aacb28d78a3ebfeeac9b9314d75b54e124cabdecf01c1c27555b4192eb7c923f4e2473f7d5584a72dd4086ee243b8eb73bb17e17b01f752792526ba183a7e842e669ae36051502ebd99dba17ab30f869649008f0fa24d7c9682384427f9e858c2dfbd8af1a8307eb2f50447590badea41e3f76ff36dde43eb9f39ebcafef93533c35a76a276732d01eba3b4b6b2cff98803c77545fb7d2add4a7a627fb6e547357f22ae7e4d6031df7f9108e103a683495b06b872511c09fe2f1a6dbbf572b25af3aa938a05d62dfc48562865664520639dae130d24bba4f8acdfe6a84dbdb93ab6d7bf2d7ebd23b0e826d240e8b0a57edca50a8f73b547270c6cdb98b4892163ed3a9c3101ab7a104ca63b04ffac286cb872986f23b67dfc3019622115b2a805ad78b52def4bfec206decd6a5af9d7aba49717e8329b0cd82039a4130322046d680bd29b5d175d8cdab0b5cd1dfdb6160d8f16e1c95b154116bf7f4a997df98b33959f7cda55fbd10084983c1de58808d94fe31d5aeb0a1ce68e2250edac2be1861adfca2fcd39ddeba4072ec116509cb11cfbef6b501e20c2532f4612ccb59993167af266ea4122bcb5738c8f3e7e07bb935842323476945b97d3a344ee8580a4604bbfcfe7eaf94fccae5603ba6eac57e9352aa6dbaa1b266a6c6028ed4db579f962e4d369453a978d88c6e24e842fdec5beea44c64f9c8adf22072e89752867ad5adda9ac6291fef9fccbf2c5fcc276b02dc2a19e4bb5965d7aeb60c99c025d34820b0322a993fb43b76045e1233dd68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
