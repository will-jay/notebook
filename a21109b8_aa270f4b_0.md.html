<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bfa984dc83924f1d476f31b300a8bc3a7c0f99f20a844ecc554960d8955b399ed47cd838f107ba68dad84a825f2512a3e9c2dc9d3c045091dbea20ce4584ae4b5d4a11b2b94b142c85adf5b86a241e40bed0104bbd5682191193c21fbe6f51d6813753fd84efb2676b72a03596a986c4c4cca5057d6c00f8a621e227c208d64e17e196c364456daa71b6ece3fa2498bdb3972301b0d2b5066891768ddc41736a34a6dbfcf3b7436a7cbc08a7558afecc22227d4b7d60238b027ef2c28d7205d02bca86ab4d2478585307b4a2c8b823bf0266bb48445ca98a13471d4ebd1cc20cca8c4fb6c612009b9937a723a5f085d6ae9bc8462b6cf1be0db076ec9f248506b53333427f474cfacef0f767b2519a1c918ead4d5f3219fc8c1faa05da7937b7e794752db1c72db7c0917958bf0811fc784c97eddff361ce5f8a9e2f0e5476f49e34dc37ea857f1d855fec65bd4c70bce4f40a9028dbbf08484de4e15579cc0cf8664994dcf0d831cdb136862a363d65464d137bfdba238671436daa554da08693cbb956d92c02ed6d3a8340d79f5b09768d893b5046974857450d96ec53fa9efc1102a3e195b9e124be35c2718fabe416286ea5109aa784888c9a591fa76e277aa1355ed93eb5fbfe68b51cafc061027392d08f544b951684d288e254b4e21cf6ca407187a7548e698d675d281519584412dbf16503f5b50c0eafdd6cc4648430d62a4cf33c5bc20950cd1b4d1d69b72e65b34636a39b60cba5b5867c53cbdc2f4c74edc87de750f471af3e150e4dfd4021d29556e6bfb78180c621cf63973dfcfc730b59d9a5e11671abb570cb4b732caf172f669d464a947116ba46d8e763ea8e682275d85e96179c38a914db3e9f796d1d2332164404c7d106177bf3091273c84624a098aa2015acecf3806e986df9e2705b48e6fcf8fe5425447c04365cb8b1b199a0929428f11cb92e9c97fd412547e35abfe5ffc144108db87219d89c2ca700cfac84f870e3124fbca1c69742d33131438dab61fb3a653f28999d37f3db67776b3dc041bd87901b7b75baf753f210baf19030662c0af9f20f90f87ef7125fba9d2c1f0848f0cb961eb779807b2d15f53d5b96df357c067088d1eca0b2e4b13866505824f6c01ade88e58fac4d62f493899715f73c23cfd956fe8fb20c528743dce671ccfa65c10a00b8568cfb4a91edbb19ddb5257ca2c84dec8ba8379ed2e542bb126560999433b34974809951841a6acd17f1b0900feeae2daedfd70c16dfd17fabd25e249512a44d57ebea925339ebdc611f0b68325f04e0ef634cd4b548a6c29c5ddc4d8aae3b49459d10f5612067ae7b3eec436ee0ee37dd97afd91d2e2c581384a9b1f210aefddbc1945b34247c1f445f603aedb63f476afc9ba04ffac95aa9b80122fcaf122eb49f51e81f2a37f56936300864c439a2f037bd94e81c284d7d401a5076daef9a5ef524086298f8c050bb1b4afbd8e4e3e576b1f7463af36c558734eb54cdc9d984b878e02b11f46d1dcf3103523b1939c21933169be8a593a2a4eee87ea6042700c4d7bae8579f921e50a4194c47fa384bf5d7e78dba2ed9ebfa0bdd36b01bf8d2a39cd7816af90b73f0dcb8138ec8c9d56f23176e6164f6cd48dfd2e5bfae22de5220546e2799e9a8c120aea2415ab7fed8cba5d5d85d791a0f8676a0be5536e8b57a51a3d999a3990f904e6bf5dd45ce96b4984e11aa1e14cc9e59771b2f4749f65a3eb19f7a7e73b04c2940ebaf56e5d5c49bbc8c0048009ed523ef38e1e40ffe4ab5916a77330c5f3c3c1c482e961ae8d3a1652fd94ab1dcdc9f8b23526d70205694b44a9002b9c5a75e8a5485597117f378a43d3e5a5935b53080445c20bd5733e85ff0a94618711618d13808b9b2886a9fcdb16ffc6e65b40ef1b63563c45d9d7fba16cdda6290baf5565f7dd1fbee62b14d74a037d39d38043f0237827236f5b297cc6f6d5263d20f3d317c10e2d7bcd48a0805bd692d0f7623210a3f25b0f664d8853031feaa7d6a23e189504a2df8204503d9bfce55a7617154f5551f1eb40fcb8271d5c6d83b59682c4cdbb95c47995de63674689e49aa8fa2d05a0a437a3b33ac2e274a0e55377af35d11dad442789af5c08ca82a11e8be175e8c5bf2053e0ae4e6d7496be4c99a5a8e9fe1ff6b362d2f7ecf6db778e0f98f3ea870c31a06e14b47e9a00de1d06230d13c432705be43237198698eda7412e8cb1f5514b85467f9624d488723019f636848198343db860e95c7062d5a8dde9678e3c06f9c985ad0e9bcdd102e50547385f13a0631480c564a54471886b0f79a26159488d5a6c5d505fdf55c665d0ee73664ae2fd68f79ed4be0a47347215c66fa2183c7309fe4ac1bdaa27184988a6801705de444192ebabfb87ce87e2235f4a53bf5335f5521f77d45484843e7c7222010c74950fdb1b4b7e3d9a3c337c9d1cb870637c4c1c2302a36095b8f728da51d340ec2a76219d5f3aa378a498b7fed9350986f2c24456c03f67ea262bbd90b99dffba8f4336b8ee25508d5ffd9ef4178b3bde4dbe0f0fc1e20c822fb6845bafb60c9e22256ca4bebe2989c86c023c5444442603483ac2a5c8062ae80c7d2443a3abefd90e68bdc7607a27ddce579040654b300a5fc4affa839db8948be259930f09c9a480d5aa79855aa9583a80ee700462c6069decef23352eb104b359162b244dbc0d3af56a9312cfd5c2d1ea3f7ffd90509520c3e7182b7f111f1b9d843ff573401f13d376e1b07cdae1078df4f49bc8fe85985914e9c2c4daf0c9d5e6c2d3e69520cc493debeb38a2ecc938ad09d6d4f82912468ce711bd72f6e4ffaf6e0957ce793122513ce7f962aea13af9ad2f339f5f947d537497adff8c5b455a0114b52068beba73f6c4a0b8c5db8832e16ef41c116715f697c96364051b0e6c38440dea6ab26e93a56e371665f8ccf0c5fbd99fddfa45f9e5e12b5212c2ee6729609341f0c8a7ccd2ca8bfedc8111e38dde780394a9fef7e16630cc0919a512585b9b78044c41a2f592ab5b901cecd2a55a2f665995c8b5bc193752003cdb213d862a75629da59919fed391783644549ec4c0df339556d512e41dca397de350053fd1def818bfc2c6acb06d3add1249f5539935f7a6947a195097e9fe2e766f9b05dc5dc8078812a86c790ab14089be565c50231b2d6c606c7fb5bf3b756633bca022cce7c86f867bbf0d5f0c668e414bac346f95dbae28436847e730af52534cb655fe505d254f733dfe45cffb9334e776a8722ebb81a8e3386052834e71ce150d001123c2569ed67c980cf41939465676b6e20e972d7d99449943081815b27a0817cec2dafcf5a12e5ad60d23394aaebc3f4be0b108aef83e27f64da6c235b2761ce08bc14be2ef456a7a0075ac4a548fb5bd5476fcbd7858ad08e703bbad90da1740a3a55ac2cd87242a598bd57c959d47ed6d8bd6be8e2dbd852817af8ec5798adb159ee2e924956be29ed6defb2fe3417391c725cac981f63defaf3db5d1dbaaa0591118d332772f4ef706d08eb0d4fd6441932e63eee1fb7aea5361f93effbe3b4e085a033ab4af49b5c95e2b43b24efff8be0bb0f68250349f7f5f1450fe3498f5a205333630a458df35edf4832904064bca071e00d8c7bab12fef23bbddddb24e1dedc263f0fc2f9474b02451871e07baee730daea245f48c9e226cd4655ac90759ac1ab1446f6644c3e35bc96521a2fb57ab7ef9856825a2829d741cbc5e255f73b00dfbda320ae07a69b4a0cdea46442f8f1317ded3bf4a942db16ac0c4980c2ad318a503fb0400b1981b7772c307cc99c136d2ed198d1502bc5e4420e1e84a8cc6c31a6aea0c6451efabf39274be17ec74d3dfe75a575e735da4a14273b4e5002eb26a98b1698631d1ba121ea5cdd98cb396f5754bdffbe909fad7c3058c5be971c81b8ee68e28dcd8f2892196f3c0408d08c1b4e3920d2188f2581b705d6b86b9fd07a5533f776141fb5bdc2907c653f02de43123d0d2d02add16ae2f12b810716c2f97852b84e097d00a15c3fc7bfc1b76a4cb4955fb1ef75cbefa967e41a78f0de6b4712ec22871e9dcf0249a3c58fe0623743f0d6ab05878157ef5db4521669cbbe6fc2a843ee80a6d3f5c75bdb673b95551178d24da1584e6061f9aa73e8a6982934cf0d034c06108143577817c6c3b577f0175660f73b906fd8450c46f317699d45f976263da2a3cc445c5df568b231284b945feea2aa36f8521b8e55d60a6ad652e5dadfc0fc3c4970fe60a4c5b10491dda473bafbf240a85f239e47e620852aef94b1819b081b42157e83f7088652b8e39b7c5987e6ac471791257468a776fe869f9c77b002e1bbdeac4186fda3d59fa0f401ac923aed57f0a335e43204ecc5dcffda7edb9e6950982c16eb519b9d2ff9cfb2a3e1132243ef62936a6942930190f905b98488c07a61e9408d7b4325fa1ff96ce981087cc8dfd5c0b3a33aa551338b8ded4c18618ffeebbcb77421af4b231b0bc3ee8e8b99f3234f9660c0836f16bb88c7a36ba6ae6d3df34dbb3027c647fefb92f4efaf0f0b713c1df4fa647d87fb8bb9564c1fcf3d63070c87e69f030c6b1cd723c332cc94b34c87c5f3abb0edc96bed188eabd3e3a7ccc9a81a611c5e900bda3a464eb57f516cd6016dda68b8d9836b86c095ff791ae8be6d844d586339488a9c72c009262a2125ee28d3bac8a27087663144dbdabd8c2174ae5ac855922ec68d5cc0017f2814605431d0ff32524a3c40d1031cf896e9060da5d1c4b8dda5e12ec7bd7d052411e6cab2d4465b6e81a34e0827a16e7684f1e40fbd860c50128f6d930ab91f64a13d3c79fd47d04eaefb71418912eab314b7618b01fc6e18052b696efa5abc3c9da4a538ffd510cfd33b9392e5890375c2349831baaa503f1a83e188947928e3e1f379013db7a77cc40b6f3773eee490346d9a3bd285dce2c10e73a03db4cef273519adb2ad4f48fc46776bb50cb196ad3df92f3fd7d8aadfe892b27b9061965e415745de601ad7b89b0bda0bc7bfc2b9cd42cf7ba09a614d59f355b4258214df13359c70c11e1e46fe3a6d7e0ca772dcc8ace9d4dd771cd7c1da67176005dcd4719dce41be886f3da1ccdfb5f62cc099c9f4a15a1f3a3e6b59577f34536d164d82bb4b06759190a11a47561760b91a8b59a69fb57829c805b4999bebd301de94ea58f6199296b442c798aac4076db74bad34852af392c44d0d5f2555362c5558d9e3eb76086db42629aa772fa05e400e550adb33808ac248fcab1fe9b563c6f760e3aa99881d751cab209bf5d07c3df3d9d8f36c838a87066e676e7754eeaa47e2bc7af8e341373e76ad19a0fdb80568fde163029fcd1511ecfd701e27d73f58afd778f1c6113165e67fd3bc1e99738d980fe397eaac16a3d80fd6ecd3d6f835e60cca9a653ac8ed146354d637ae8b3584745fae5a289436ae72e8c31d2861a73e6c01a146ee6d7eaab1322d74b728d35351014d0a9fb1f42fbdf6701deed288f8209aa9397e558d4e75518433f878d7faac21f2ed4d19739deb1c177924f275fc1755845fe76fdd593b148bc3396924de3a295fba3c2d7122c878815a3c5500e8c728604425f341b0197d0294485d7da71260c781e371f4c53a4b310ae205b24a95dcfa65f371477ac324fa3840740b4a406d3830c74bb98502bfd6db6629a13e8cecd614ed3552bc71a48d70e6fc33f8c0f57b3eb7cbb82e097f47da5e91b1030701f9de8e6bb63cef8a874bb5141cd62339fef36b4f1b92bde017f564f74cc4cf44ef43e0fb4ea766f364cc2f6fd22e0acdd21e69df9bfa768f9911782c886ec4cc304f27d10de81541e1cd1082177d5a2cbf24c1704e3e0d9dc7948ebd60fc0729f959aac869f97544c16281d0ee151ae8fac5f8dcd6095eee00e57426ff23197b7e548617733c35179cdade4a538ae869ec18b3d07c0e822f165872a924b5e55c453991d0a7f04acef9099e70fcc57b5c6efd56d08f189025be84a4ca99122654f7c4cf73ebece0e84adb1acf23e5083a195e7e0bf49d075856e76d11507409e8f804e7306c1bbdbd133f9ef3531a065f2390bf1079bfa776197a968cc5b31320b45469bad78eb799221ced1960ba1010ad1c92c9c7655ccfcf51a13dcec2a703521084c6311c9575e0720351dc65d1ace3e7c94fed46d86317f492e4c309f4301dec086ae81939b639e74574d4d9d0a97597950a7325015c501dc72b1f9d12305e47d065ad7e3a980e8c213334eb5dd2a6e1f6e480bfab4b8a3d1de8e20783babe05e94ab97b4fd54fdc3f89cef123de370e32a63fbd22ff677fefe4b13fb367875f8fd3a076cd206299344a4ac5f37911874469861f733e90ac3d0a56498187cd095be0bb26f0d0dc4873432d7d016380c695ea6994cdaa42bed6d44123e1f01398cc77915dd273f64d8e99497db321452601c1d5497910ca859249d85265979b7852be8a9769400f2aa7b74e13624037c58d0c7a65779becfc2f18ca23be87df32d8b8e71a8ede68d46fa898259030e033870bce902817ff948b147426f11fb07e041a5cde12125f12b37dae0f974a4066882f68bbf61c70fcff4962c96ebdaa0aa01df1872c03eb34d2f609cb7e9fd2d1d66bb19014a0d35cb31a9b43ff555ab991ad3a2fde1f1c1349365b52faf22f49d3d647f045d5d689c7db1ff43215cabfd603f5e66e681a50c055666940d869f0e352dd2756c84bb3e90d9e9fe23b2c66095d4c1200e6480050ac0e0b62e4978626ec4fa37fc65839d72f1b7e337cdd63c969c60e37a1985ded5257af43366d408b3c4826467483cd4d56a3890b02a7cfc7c9178f6779b4f6b2921d9ad3746abed870ab611b1d32c6208fd1841960ad00e3c4fcc6b1e0e3492f0bd4016016e329592f7d7d6ea313e4b66560346e41d261a879d9a5ae8326edc3102260169c83ddc13ef0cad31b2eff3054a3cc6dd6f376da017c284d20f768b9dd81a974ca06d46843cdbb72e6bc86f3fefad10f4947d1a133b07bb46ca8ba1ea0510fee35a42ea6017f029a5f29a9a4850adb407b93c613686b593582917b95759ff446b0466671c8908a72bfcceb9d20783c9a85fab113efb78ca270601167f2f9950253ae8933ddaa26c9786ed40818f1c28e40410a2dcc46154e10eddd0d017b043017764d1e2137a1f661aafed87ce9e678bd2a9a080f9f79cab04c55119c7ff2ca98065d4d2a8e3fd53ea960ec5f8d306c592674ca5d83a9ce1ff67814f5f6e6149609905dc771bfdb7ca7427ffda16edd024dc83c86e22e457cef8cae7dc5450026d4a87e5411105d57958cfc93997318857c75784a2cf8bf8b949545824a34bee198fedd0a1640e75536fa167a3ac6117c20a7a8b853ece2fe65ebe22d0ef36c7cfd896f0da0f412d1ccec74fe2fc6647654aba917522397b138ab3363f3b0f8b77eec379aaa63b91770018bfbee1190819df69bdda1f002bd86c4bd5b017bb45e9e05512308abc591d3a3d962190fd3bd7613763a224fe54c7bd610d899910dfb6618400260e68be3eaeade8e4f82a0d744ace88f97fc20e6aa555a698884560c919ac4b974df035771228491501c49192cee31942f95f38a528dd626440f3d491ad16e0239223f22d32bb20ca221a7450a9820447c64e0f249b2cc37adb2188504f6197adaf7b54d34ae36f5c987302b5fd38d8f35f9016d58e0987a73e5daf8e913767bad641d9037f7eb34bd9b200099ff2417b6697a365cede310cbea266863908c6d49d38984f4b0d00228bf426eb7e0629c61b5c8ee39b598088d67a9d526bf393f897312e09e1247bb876f2e6987670ab3979023cccfe28d653489e3665c37f4c44333c47f7a69b84e2cbd0b63b723ebd302f8447070245aad27dd3603cd3e8f0d92678b2ec1b7256adbc9617e36262303528e587041c686a06a033a40c95628909737001554b7994e41bae57228eb99b0d4c8074a2f3a81741d9cfceaceb2a91d079b7d4a2933245e4ba85dfc08f297af3d435f79bad31fa122f4d3ee5542a41236ca9575e4b14f70de3ec8531e9321c4765d70158fd464ee0d08f0fe34b7c11300fbc198fb26321f54eeb9a4e91b0cab52afc8adb0dd12c8740706e3a23683ab083c7c7c089f8ecd84c0a8105474972d39859e662925e72eee35b5258e9e78f634a93567b0edb4e50e391dc02a7adda9c3b891e27a859e9bb457e7add1c2fc50171130ae9034f0ad08aa9efd4b38649e517db45beeaa39930fa1f98bfe9d6117039df0df655afe842a55185c6e14ed0815264fb3afc3a4e827d9705e5b0f2e088bfb30b59ba0a86e7e028da391944e47fd2359f1ec17553a1396dbbdf01926c4ab278b538171ddaf59e9f0acf457ba443f9cb7c52353a2009ebf47a398183dce9a2b142feefed441997961cdd5fb2149457a5dcefd333263316e3d117689de305bb75da4cece17035bd09d72dff0cc98b9de2784fbad1e470cd2daa2ec268ed6e173733d71ce21798f913eb3eaf7ebe0aea152ecf58fe17a2d18aa84a9b693006e567658e0ded67c71f9cbc8ffa16dc105198d804b2177cff6d5c6b917c8bace56d2e4c472b0d79ee8fbf9929c6ac4ce6f3a5a5595ca04fc6c4dd87e64a4ef2e6d92525b8db3faf6b62db3ab2c1de442e35ea284ff92e5072ee269802a1a1aa561af57bbc31833be38b8a8e3dee3ec553460eb0f9e7988d4dbb9efe5a0de47d4692c7401a2d28233caf5272f6134c7d26b7163194f348cae82f25658445391e0551eb5d6787fc95b6b02673fb47e414c92be87293269860597b567da29346301a788d761aa4ead7d34b8ae059b9e106fb7fdadd5953439347c7f4fe72a8c2b39a4d63d9034ce3241f007d25475a8a89ad38a738ef67ad73df413d01d995421ee2a1e5c8af8dc5c8cdb3435a087f5665043e363a1b4eafa25db5086d5798c92c2e7fffd3ebf819bdd3d951be7a6c3ce0bad34f4358d477126052fe05c69b89b2d48c5f1059cb66e5dc92a8d4ac92afa6853b2c9fc6fb1baaa474ff9e2502a5f2845b3c6512a1bef6567bc58566986caf18518c9b72cffce330476712df6011cc8351e006962d678ed355e37ac923f14a63964586274625f63d652d5a9126eff0b2cab1830df8b28d556e355fe4fddae67ac69cda13fa50a6945e4361da5923e93a9eff1a5f3092ad39ac1d776ec9498fb9dfa2168a74bb40d849d20bf371e37aded29a29c35097d4a5c0d779fa6b7e1f6d392356141f44ebf010498148b6d61a779e8656dec688383aa4359ba4de65273d3d85dc677330c3ab791cdf9b798348006077aec89b2bea156596862e338ea5a48d0ddb6fc38865e6ef27f711630f42777837d9d56bdb356cdf5e963d71a3339ee2dae6f77f8e6af26a3a8cd3daa8a949a3fac208e44f4ba1f115ee2f1504e2e87f43dbfba62199733d835ce686f803d5a250859d3b29683354f6154e64b9697d4ab31ff26cf9e4de08959b9ab368458e7800d07bc60b68f0c3836d25cd93082b66564fc107b5bc34dd4c2ebe22405fa7e3d3293697bc643b59bb29f81fcd8788bbdd9de05b1acc03f56e8a85a5b2f8497ac8fae7e69f7fda1e65cbde5a8c05d21f8f06fc6cb35a7be5db8890c9ae048931ef3ab2ea41b2a81e5caa3e1a63db1a1540e186bc2dfa66ad6246e67fa688d613b41a72ea51938933aaea55221ae10853229491f95726d1b8b1bd7538992260a8da550fa1f5f893d235d7a95590d50889afaa38aa6087b6dd280f27c47361cf91a38825cc983b68f743a145748119dbe665c51924cf1e68fc321bdf03c80cf4be95c6b6af8358636ec4ee1c56f7a4181a8e42883f424424fd6f06cd9465af749a1f1571fb58e9033b36d05b7bdde2036e7dea2950cb86a05c47b82201f3dcde27b72194fd00d0bcf09809e75d584a11e846b067ddcd8b9d81dcb1322c7de8490633f070d6693b92aacd31714fbe6608b6aad394c4008570027abe14e23d9bd2ae0cd2e469e583e57e9def05fb68fc915bfbf17312cc38953184db5abbf280e3d7037043592d3867dd25dd91124e0fcfb9b9649a2287f73b1ca4222dda2beb8eabefad2b0ca620c29bd8c42c5a6a8627247a2ebf49b057ff96bcd4c2986ba7364e0a39bfc022833e21b05df4b9e0c1addff59baad295876ff8a3bac4d6f48ee82988fc734fa18769cbf9de047957d0a25d111d060629ccaf2de95d3c20cf051838b4c1a181cedb63c06c793ccbeeeb0f7ee7b3a9adc9c42b4a0d080a5bc5b5160afb1016997111e2658b673229d8b88f9723d9b48786ef5622288d746c85908c66154b5b4ae982a391b2d534961da5437da69277c283fb2b226b34e1ba061bd7fe2868c70b804c911cace411ac96bddf073ef895ca3d6f925fbea8abcf8912a092ca553215d77e16b6c2a691ab39ea21b4fdb5d4179ef94fdc04522090ea61a7c0baf9b2f3646fe36a56fff73fb0c4b3325a2e62806fc761873d0bbcd3eb6d781ddbdd88e7e4328f981f256858342c9b2b9cd514f52243a2ccca77c52553bf2515fa8a057252807a83b4dcedc2beb563350228a1b3d7cb1df98edabe1fe1f19acd3e1b564318929542ff254a5305401828673ff6015a0a4549683b1cfa137b4dabeb4b98796bfb29d1540c1d18eb9fd5d0572e3809941a23c9097417aea84faca3d74854cbb838351963b2df141dd8b565df8229c9c8a5a3b8e8ca1e2fa1c1a84c4a30d4c85dd86fe50b1eaac9c6393ab1d48535e73b8d4ff9cbaa5195e5c33cea1bcf7f673d796733a32f5ebc1736336d379e3e2da3cd3e389102ddb02a58b40ae578918b78ce467e5b03a28a6b8cd18cd7c836de03a6eb7e1c53ab0b7671c1a0a674b23bd9155a2f7e2108dbfab65d229d8393c7098f28f56ed170763170fe6b30108407a43edd62646ce70b4ccec9bd72d7978aa7509da73a83f80745b2e06cef1d43787ea8cbbc785e4f50e87835ef968a36b4694e240584b9f24808d9d5af6accfd3016057a6d505b2a80c1496454ecacf95e02a33b2fa77acc1a2030c3e101741cbcdb959e5c70b4a321dd9fccd03cb04d10c6e61732ff726ceb08e680b087f6c12d21f0da49b61ff85cf0c1614ea43783366070edfdb01e00e19296b76f3f152614d0d238f6e52ccfeb35b88114997662bec4e2845d2c10b9da8dd4110312b9fe8c3721bcbfc08bd2aeba4887f7f5ad0967dd4219650fa24eb55b95e70b11e7eb78fd3adef24ed0e542744df7e9c2d8cfd3834bee8f217c2447caff6d9f27d2ed56e54652057ccf143e5c676116d9bccd949f0c1354cf978b39eed26fd0b286365efc1606d5cf348a4578c842423373443da8b8accd84f5678ade9256715c87ff3b5116c5ddf4c92cc60bd4c49e994c5eb8091f8fb50a9d8c85f804eaf3196a4c8ec9401bf0df004ee171267940032899360c022044842e0d4acca7d6ca7ac29c6113030a5c6f4978fe6b803884848e68e1344b684d2be186c2f4aa4d16802fae4567e244452f43627c59dcac5a7624a0d011a4d9acd9877b7d2064609411a0e91e4084ba5b5a1496d36b3638239f7a261ae9012fd7af20948020ccedb3fe486cde2d6739f519854663f1e3d8b812a8a72e8fb8722ef5b2c9154b40c0497490503d21db0626ca8cd60ecf7cebde10860f13979457285f2958cf7bb2d9c59d3dad655fc15973b63a457f328892344b37a33d7d33900fc29b5dc98a8058b12172dcd758078a602b19ebe0f7bc35d031992ca7feb8b5505ffa3717b45a65d31e15d654352acb1a65b4686f3b5bbe4fd10826f86d90eb378fa55e20c8913fcb09e767bf53aaa91705989e00726f8da47a21763d92c7ae2970a253a5c2abfa5b1ceb943a6cdbdbf0791c8e801627a6c610aee44de41a628547","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
