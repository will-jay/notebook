<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89639493431b28af0c170c51de2021f8d76af0b850746929a1368f6fa52fba8fe7f2341a94b73209a041566c19cc1f8c9f1ac47998b7174af2180a274af34a2e68a45815393a5efe29b935fb18400deb193e5ebcd1479b82501a002fabcadaa52af766d5785a09c5ca58b4e32988cb57666fa1b153efaa15e73a505b6adac91a12753a7d28d6989213ced3b8733da076da21fa939d79d1db6bb6eb654f8fdc60af7830d4d9f22ec81b4ade50470a9c7c1b507257c7c91cc930a5b5b22c91fbc40c7a0896ac6d00df79f0e53b414ce72ec6031a826b2682dc7e592233f029543d0d55b01c891ae29d171a3807511b52e6f887a5ea1cd0ce9bb936f648ac97b8fe937d55f890ef49d3a420e2a04d6fe148728bc8ebf22283766a80302384ee3a6460d9cb7f8b6e3dc1f14c773e1349a83ce9c7ac55d432e23ad118f200f7c89a2673fa5682f5f997fe8336c0d3ba471166a16fd7130b2e54a86b8e6832d74bff606b17b215f8b0c6d01af2027cb23a995a5f3b792d18f865d51946fc515068c2e58316675d755fbb5f83eba7bc73da889a3f9be8397a103fcf7d88495543836600d70806ec3b7f4e21b62f1743df22b392b57d78532802593ac4ea6152f5c5e1ef2e57adc6f12859bf3d0509281e05c0287f63fddd70b9645a26f8ad0b5e80ff0b3a738eab8727e6f84826e2b836cc4893c672372762b4176ec8dd32fe5e6f347305787203714aadf5149b9a44698ae37c44088dee62311ac7b53f50fabcca4e8e324818302fbcc499168433e807615645b8fe52264d021cc75a7b8c6f3f929b772e9c7556f55086927a7ae6f264dc69d4433380cdb80389b0a5d325197f6754f8570f2c28811338e2aaf3bfc805c0569c88ccc25ca7fb1e1d2ca3d4f8f181b1b86be0a7b20b844e484858eb3c39e8abcfd688f195b8bb9335b95b76f3129b66ec7ff6fa745b016abc8d5bf18ec5d7386bd000319235eeaafdba6339eae3f37d499432a693eaca5f901c88590958732bbe0d583a1c3005b8bb8f6e5dadbff887ab2334d87764195eb34c94607509dd2078518957d265f1ef76bde18c6ed7790283bb809f9748b3d1db17118a659757a32ac5293d7d0ed9492428f36e4cc47335067ed5a195f827d61be27bedde4443b22157bcb0e6f2a52f118b472f66349a74b1bb223913804d92d4a15124e672cc3a999cd306f895a19d6aae72614db4060cb4e2035e7329613d5a88c766d53772f05d346007d23861896c77c7a8dd2e68bb9dd0708d5db98ac10ed04ce6937cbdba253e73f1ce78bafb16b98a00e06687f03eb0b453d3b9fb0f1eed8644f2882e48cb4362d2b65a49db23d596e784a97f0bcef93fe68171090a5b573f655c9d10e11e7385316150e7e404afc1d60e940c574ca7f7243fb8a780aba28d0dd5e27597de97a4333f7afebf81b0c0be0af2d7b57e366e60cda611540eae5c9f2177fd94291aef2d37b22daac7c052bad92ac98f163311ddc1c32ca770a88506a272b7cf85a4e97af43cc4499e3118f49910cbd97494666eb968ed58a432453b185a26b64c42b1afd30b03ade1fce01c4b562452ad625554aaaee086074a0fecfc59af1186146caa5d75c75dbebbec29a41eb7f14dca8175b36925d83146c96f057d5a6c426d78765c18a036f5fac9932c903bd04d23266b778177cf35a9175fb8bb024b7270df4f4063078d9fedce1bb4e4b00af3c7a7b392eafa3cf050c9a7e473944418314fb186a46fec39c1d163073f8c6e049489f046c3483416e5afe97befb5c222a357fd17914828e1571f2fdf47e7a970c6e4b6c6ab42977777356ecedd89ed625f654daa5230d4025ee6bb99b0d16ffbbdbe59b605d1286301442b3f6d52a211520d59035cffa0dc23e0e6853d238b5efa2ddbbc783bcb055bcbec3ab9b3ce0c7fec493f9a2b3e00fb900d8ad575915bc4ded35b13f20397ef00fe02e00b9a915991ce37a1f0aaca48e696eceb9f633c579a2b4bda16e376a37ae3be6c48a4be6f7be3023bf462c5e56917ba2416ff4442a494984cdd7e7d2198b54b28de164b8ea9d558806c8b5586956d4ab23857ee6f9abc67404b38a1dce6abbc51e53f67fb8a49dd91ab67adfa45fae1cfb3dcaaad33f2cea6e075737cff70bac99ce4e7742d14074a459f8a4f9e45ec0d635393a8166684f0688f6ae875d985940d5826fd2fd6b320fcc2326477e8551ed50ecc3974ae4083980523fa2eea5faaa35d044b120b3946b0bb63903b9586ff1397f8674906b36b0907c281ee529eabf5d17230a3011ab617408dc6f321b50d3c62ce66447023e2a1a2556d76bb5f990d63054c5dc69e6956f25f329683d567443563b87d8d834abe7e8c5e6eb7c7cebe9ac25acf3cb6a825165a67cdb02e25a86f703806bc76b2a577fcb2c119f9c2875fd63c6bda7d95b5fc33142c07624e088d175ebb01c5c5bca4e37a9a8d6877490096afbdcf85e8a26bdaf8c45ad84ae995b6d995d9509b9f0c52db733b6b3f368f52dd14f1306775df3d3dde9a53f037598ca7228d489d990376021201d21f6e6c237d49d58af7e6da28d569060521fa66be816404270cebbcd3e6ea91ea430ffb53affcdf9f44bc8473cf7b4b31064b24de6d23d20c698d8c42b1ed88695ed95c378fb699c5c453b95dfe47fe63f517206ff36c95c1fa30afc3d30a3eba9cbf66b22f58898f399adb9361ce933977c61912ac7a0c973dc8cb4a8bfc8adc9365bedd0c15f4bcf0aafb47e3f7c604c3712d0df0cd742f1fd95e6f8e8c2a98041e9da5c61f9da130b79165e9afd06d0cb7edcd4cd61b784c2c3a10d3221626eb0a99a1a488c551f81d6dd56f33e3807bf247d90400b757247daa04ad0c52d77fd83b265e54ad58ad0c578b582fa97b1436859bc0b296a1a151daf8bf3305e3d72e565ec6d83fa210374a87d13cf7ff0ad70b723765e8c30edfa2781239d03c68ca16874fcf8f91f95101493a93c14c3dceff6c4b6ed7cc20ba6f2a29f306f08569b2cf73ca0bbc0f6a867fc885645c97aa0b7831562699780102765915feb4f82beef7612c2e27b94989a1b9698ee208de301c68038104d59c79d0a533d45ba7f4fb6794900473e7436a1b16e5810bac8df246c0eefd3b57682e53babba93d0bb2dfd06410b362abb2065c7eee51c3bc2a3eb3b2207489e4b1d25a964c551730e410e138472ef18dd31d3d81fe0b58020e0ac2b608d1d68f3175309575817d26c7e8b5f2ec78966c44bddbb7a54f32b0cc7f04f78f323916dc93dd3005f36152f77d7b4863f6d9effed10cb5cfae22f3f92a4613eb20d521d09786baf6652422add3c0acbfc27a6124b4b1c02e14f75831140ffae7de992fec5a5d7af5252e89bfce4df03e0761e42157c39c4778a736bc3a1b8ae372235b1af67776351c20ca96b00f863c65af1d2f95ce12e225b2ee85ec61dc1b231f530f01e8f1b4efa847f1d6bcd50e1e8087c0096e20b40f1720b1bf728c89ab568ecf25a53ad57ea82166dee409a2e526248f32f986f4cd396efce81a5f315f34371edf24310601e26d5613c3596127cdd63fceb381f087539ca6397e823824e6d4ef7c352bcd1a09bdbff981eaacb6cd4f606b04d0000a6a80b65c93678fd2dd7a464624a1897d3913ea632e724bac7d9452fe171ac9fbe427867cf1c0d351edf0e7527d7a3075d2f109d5334cea402771d3fbe4d28b4e3a5060af9df9e7c9c5ad533cc85fdefdf45c76b695f8e07eb91a2d2b8211875dc0e94653d97c04041e8d33e846486ff920dc330c5f7b3514d1d560bb524c22ca79fece5af3a58b11744236849d4bceec9bb3d55b6647f253a191e771f3d0d716888aa55b4bbc9a5187f8a667ef537f24ea4aa9039fd1c6f5013cdd0fe210f42bae2843f7e483a5964a3515a7a0b849df8edcaecdb5196ff4a3f39a92c830691785670f07c73cf4b76a72ba41355713bf10f477a78058a5c57078a073b6ad3f049540927a24132a95dcc21c7dc53b0c080c5792c8588641f7fcc4ace80a5cdc4c0661081e4dc468fe57b3a932d6321b07971aea2ea72e8eaeb80cd477fc57936f726fae48df1a129e77dc7ddf21a434cbc173f85f38fb3dd8db8148fe31f35d559799f3855af6dee247718ec918125cdcde7a8b9924899395fc1e59fe7138ddcefdb8ada4ca51dc0b9cef2ecc8f7db0942fa3059639164e4510ce1824e7c06e4b2cee6646ac0e7aefbe4c258e1efb94f00d28d6d8e031dc8c12b6646d6641aaf4df4d14e06d12aa0a534d4abf8d305d4280eef42570b4cf1d8a69d71a73e8cc8d1d19ebe5e7e41d3e0aec9f71c89582842948f1a7ea8819ea6a820ac7118e5a69d414b9540435a14fabf1c73fc8383af7671849565cb4e19cd743dafbf6c4f0b29bbab5bdc7249e76f984b6dc4ee80b9478f8a91f31526068bb42cedc84385346c1a3fdb7542f14bb5d3b1d317e315eba4faa94a957fc82a5972f56b1f008c7e8536da98170a9f0701aae457084c4bdc78ef9be10a152cb72cefd5bb5dd163ab2a6a00dfa37c17e2fbba965423aea81af6fcbe682501d863b99cf85b5fda26a90b0e4a045fb4508282f2c1805b911851db8d4c9cd86334200957481d45af9fc31e8b1dba7ffaef379f9c2eac4d0725c17b8440bf748ccf5e937d4fec68203153b6f5cb87eaac60b1309eda2f029e6b1d2872e0a324f8b2424a6cdc1bc56a1e429c11712eb4e5a2fac3696b088db1e401d3fb799fc1491603579423cb4fca4a840f2d2b2fca9007baa34a947d8b493c452553ecc9a2a02a6111a6b1bae87e131d0cb62c35a28125953223b88905eb3c385174493d8a45690289c171c421c75758d34a7464070f86f792cffab39ed1fe5b66a9ea2690cc35d9d79aa446c4b086bd0732a5187a8cb57c997135d6fa378b3ffb1c7382ee17eb79a97ed41220709bd62456e9aad732435269f68dfd594a3cf2f789fd7aa2f70f15818e19f3d5a8c43a3fa00589f4ba9da1303c8f243966857ab12722c7615b318bae225b72b47ec4ae60ea3959e40ee4fe3f2f204f7ebd0b901156eeb56129c76b3a7af7956fd1dc49ee2a13aacfdeb7e08b55772110d43ff59e0741a625fa20e29a05594bb37e642fee975c51b2c67dd71c2bd4acc1b736b84f99af503fd572740e15b7f3701a0ea0b4ec629ab84fddf38aebfe5ec78410116b9c803378448254f607564b21fb6cefd9f8be1edbbfad40b80bb8e8d1dc38d033ecbe4c72cc592efe34da8a308ebbd52c384a2548c52ea0a47f2094120221335acedbb14047eb98b489502082dfc67174c8db0ec5a477fe2820be1849073a614e7c1f4c37381400b996748b76f73b7b2ea587edae86b087199252ccc5b658dcf002d4b59fbd134b93b4d17c4d7875ff70611e13b0e477d53def73cfde1a3732cd2a09552f7947405982b6dd9ede0f75c7343cff9e60d3a4926a84363a30e3d9c434c7bb877df20e123dcd2fbbe6c6e6b7b99f5054c00ca89d342e1ebc397a9a1a292309151fa57abd1462ccc8d32a26eb785e5bfbd85b5e87edd6abcdddb4c6afd2125ecdaff4c595d56c6e464d27afde6bd21df6bbcfaeb0c3372f7e5b0b37353f1d5c25d2fad3517d919329ccbde4dae95913d45b5a709bf7431e1cd67da5e161dc66b0f98e92731995f02380de72914f07da041f10a345f9d708801fffe0fb5b7281793f6c8cf1f8085af90ccc8b15012e60c7698aa70787f4655d4b16418a7e6dfe5575f7a8b49a17bf34a734fd313b0b3cb9b91a1f1a6c783efbf6fb75414da297aeb3f13b429ae9cbd47be175a7a74ef14ec39a590fa22e9b10ed6ef4be7d50e46d6390a81577bce6f2fb239b43ce4e5ea80172aee4f1f2210b2c7dfb121392b0980498231071adfd15b8cb8d5818ce1fca1ae1a4b32e76b30c6420e6a3f45dda0ff1a7d69d0fb2d9a9d194ca778a0cb6a057b7c1a3ce4cef61a5112235f3da3963c09da467884d7926cb54a49222ab51528c87f2f847d706dde7588faae1e09e148c17d91d28040c8a00e36dc59895bc64d0ba706d5945a618196601da62d15b1556478d8a5678049d90475b71ef7c8edbd111fd7049aa750485f45600eeb973bb171227121aa38ca14896c4fa08e6814d5537fc7887f2ea135f227ba9bee14b30c43829ecd236bab543ce381b7b096a7766946684917158e9ac5dabd5317d7e35fdd605710c365cc56210c1276b07c7fb80d06443cf87d4823db8ef4f0d4cb9a8464844692c6393e1116a34a026a82d8b48b985dee9c78beecbecaf4f3a70d8d7927dc65c16bc844af9a81700eefeab2103009e91ccd57724b6c8dda4b2e92a81b4783fbefde992900ba02dcd437cd7e6fcff6d96f22012c989955d6f36b8b3bf78a63272b47fb2f1e7754a5e0a9e912f673a8f6afef01a2580022e849eb2ccaf5654515e8f4508aa94364324acf3db1be72ca6ec6fb1b46a3706660adebf87c186f782127e0aa2d9babfe7fb0c9af7b927dc0a1fb88c59d29bf39b03eb5d17daa660c64148b83d15e5585fbe47cd085dfc2f0b5fe52a44a5062a7778117a629ee83f1ed7fda44bdbd7766b91cf35715864b7d9fcc3ae8b301e261d249c71b4e7838e7f96278d03e45cab2db17018e12a1a5891677813ecc3345ada007858c46f8efb5e797fdd98c406b7e6bcea46ff89d5ef32e21c8935a20c7859597ffdca807f62f0110d9c29fc188f9200ea363f7072eec817fe167b8493283b89dd1e98fafafbf2e1632d62ac94f281289ef98163b7933a0dae6bbbf87a02507806cc81107fabeeb71b8f19fa1fd0c7d0c0dc06f1fce100341c141af61aa55c2345c39360b1977a9e1cb5b7a796cb58ed940e3811af5c0a8de8f35a25d20d255f9d10c9d841393ac6490424b4f2b039f4cd0948f5bf708a24876d82bf56da6b6f520c44a92df1df9ba57a79cfef5f0cbf2beb505a03664b2e6e95a58de20114e2f1284093cb8c8753dd65199432aa9307112595f8b9eef2c2d20cebf2d466b7617acfd114eb4a88f0339ef3dae05cc3ab050b238735833cc2b486f471b5ac36d75d13b83dd1da9b5b86df4a8a71398239b6dc0667c7839bbbd7ed409d040495c4ce9d2bbcc34445d37b881f8f463836e5adc5304ad2b10dfffeaf39d15bb503e5ac375ae4a65032c73302f9f031b6b452ae31443ce81cbf68c5dd1b3359fdf4cb07725b96c8f25c2d635db40ed34ca836d64ef4dfc9c2fc85ac634078744e26a71f22a075ab9280c9abab05842259d4543007bc77545f4c1d9c21e9473a40a54a101609a43b6d4f0e2bfc5d288e7d59e2c8d40bf8d66e3421a196fadb3bd74769607b595d0916ea87aeca73e2c39e21c4b384a304ce07d8cb4b3acfdfff9538677f814a98f46dc4f63539f85f685fa665cef44c2a870022744b957b1b6074d8f39b581705b40e6066f63803069d9ac4f0d04b1ff95d7f50e00950bcd5704a4cae80481c3736bb2fac4e860699f6d3d9a357111f401c56caa7a9b3abe700ae456b5bc6fe779165e98664829d31fe9979a672121d9a3f71366a942867daf1e843b5c89540dfe7020f25ca23a0e84d7fa6cc76922b8a82e032575c4987e0414b04f43481ecfc1d192f1ec90aa2724c6b8f6da52a71e5b65cfdba72f1be32d17ff16b6e2fac0efb49733f9cbd0966bd7daceb6ce189b566fe3004776c7dd38923bf5ea5d08d85279ca71686ce09ea6db8f6e68b2f31bd75a96c7599a68e127f57b592a11f9485a20c407c47fbdf7598502a49f60673e8242e8ebd34c4979f3d40b78760dbb8b054800626bd2c571dd6f8d9d86ff31e4c5aff982433b3564fd53b05c3c24b6968380a93c1165abe12ad3523d192de0882f15d1138731b00adf84b670a4642994e41c1d7bc248a8ee33dc62c7d3ca1efa9f17f62d5549daa13a66760c2418c950df5bba0f54eb17988c1245f46a0ef47ec0c3b66363641070d7ebaff4936436e47fd378c63f4c78a04436d500cf064487d4416404e9c71e3360ea7bfe0b8fd26282098ac424b8c7e6d03afad2f953c39f5973bb0c439f7253258303dfabebcab7eafaef3cec6159805752057ce8b21b19ec6fac8fea03fb56a2f9cba086cc77bc2bf474694cd5ebccf6574357b264359a00ed742bcd9c02f66557945c7727ff4188916c298174bbce4431edf925062424a0da271ee0010bf985807fb0a6deb71e866a29946a4ff8a10dc7a96190d484105fcb7a0c0670886ebac84570de0fb21927c33d41f2f19886cf0c7962d4397df03a2da4dad05b43f753b611bd4ed9e451a01ccc5d81b7731d2fc0253d074232ff22b5358536c3d8fddc9abe18aca1e121948aa87fc9ee0b5c56354dc0afd88e02b19a1e2124c45c1abcb86b0b028f2eca5df7664f98d128ab8df0e872dbc5b3ee076fe5af1220ec1e0319f27c8229b1f42e3635884ec3c10ab19ef4e32335e12d7a5f5804febcf9f90c79bbaac819e6c6e4844b35ac64f1e024519fedbeba0bc082e56eb368bdc9cba3b36efd4590dee6919a4e51c536cebbe5d13bc2a4f557b3aa1dc6d00359cda02a810db5a371f73d5d5116b225b1c7973b3a16bdd4cad112e90a5a679c34937e93dbb1bb2217eef27c4a7a58df93f0078123acdf91a7deb0ad7b78f6e6dfa48f7ae3a0ad9b6690b16242f6fe78cc61c4d6d799342e062adce36c04635ac98e49750ab1c78b2f30a2d8ee8553ec333e3b38dbc797356464aff3013cb0160217b2b83f6e15d1004c0504c345be006aac0500b558bbdf81fd69388da22cc185cdd80ead12f2674fdc483895a9e821d5a35da48d4220a22cd41890de85c220aab6b589ebddd85f1d34cc02a467516a5a3a4fe5d89339483a7115377cec65c0101eb76782a6c4e49618ad9927df27a3a0596242542a9c3d9492ec1998cf7b0f931311b1081f37d91cfe3e706d9452658490a09471a55d39e1316c148b97c9d64bf8b794569f8ad2f4247be7389c51b60d913710de840b4a2a81c70b1ec01764269a48558855dfecd93f12151b8e947933f5fe6c052c0335d196f24267e5bd0bd6a8d668bcbe677e4a6793d3cc05c1793b674fca950f133b37e0205b7c066abf9084e3995414496cb114f5e12017a25cc3f60de91a0a573c4a785896c6f1c3a7e5298d2a3e5082d839c5694c420c2d62b27db7a4d7ceb79254a78aba320f0f76036411d807268816123618768808465a074898414e4dd5ca88216f9e221dcf28c06114fa8a8b48d37831950b15e9677a0e5f1bf6646b1f2139a7ec37809bb238b679de7ecc09e489b9103ff70d55bfc5fa48cc8884331a6fdec2a2ae79b959b7d1ae03139ea25bd985db1d92a824021ed035b619e63c2c4010c6353153fbf3ab4afb9d991330470c5b95e86bf642ca79f733bc2c796b5f4ff5fedf0d6ee87be8e09b19fed76931da91acd8bf160d3d8cdfa29fae3a453361abe8624a3ca786cc78693079fb1ee041548ba20eb43baa0506b0b39d6b7d76912a86f24e26c4e0f1509bdecd51c4a7a20f8e5e7c61e962fc938361f3570eeea67c26c15ed7cecf5f6e19c58048bc12398da37813106e7f35a5c0679a5d210356ce974abf3a8045de52f44f0acdb2e149d6a82c2504e79c5dce107c874fe6db113766ab30b77c06a29575d51db9d897a18982cda3ba7de172b18f1eb9404ab81985679aebd997f5aaf0d06eb8dc69a9998ddf6aabf1a9e4e4f766fbffefa8fbc0e77c4458a134bb277008d5e1b8005b0ca90972e1b617541256c31e10da38c72874cc16cbb8f628dd9c4d31248397c98bde2e5d5fb95f90e0b662211864c4800a0bad2b094b81316f80409968fbddf389538f692aeb0dd3ad1c1dfc5eefe937f501ec5c625709c5b1d91e31a84d7b0bcf45232b15388c8211dc9d74215b28348984b01dff59d4a6c56c1d48c6d430543c824c288568f59cf3031619bff3df3bcb00159b7e6b97ad7a93d0da843dc21840044e62e8ba443789720c1d90c9d27dfa2dc4f83c8d69541cb6bae41b2a260ab04cfdd0e5e118c2177f739fb586ce07c7e8927845ab2df0f822f998974ef65a6b26cb39060f5d10ee4f0547c9698291e7f7eac7b91d6a4acb34b9fc93e172217967e8dbfff1a2aa438686efda57b9442ccbdf59e8bd1040bce7a2135da74ee2c38d4b66cfd28d6524f8506efd267924de9eaf204a08debff27cd31546b6156af8010bef80d402e0542dd69c49567c055591b56ae9f67d3e30b2c0dde69860ddc628e3cfc2dc3e8a84c449e874ddeb8b4dbb2ec89b3e443dd33980e2cd6ce9ee1a54d2bccb2688174abd6a43e2711f35aa7513f05942d576b2fe46ff2180fd77f8e87af13c8fceb4c6e068d53cc81049c210eadd4466887322b76ff9afa23d09bfa7390e6adb3afc3e9f071082ce71d7ac8ae5fac55079086898ac740e4d2aa1e99035da51418a79782de4647ff4e7a0f9bf34040f1288682ab1e908170979204ed5ac06fe02bbfc161c40499c38687b0edb13ef7d63adbea6b997a3356ac6cd5e2b53590aee63e380cd326b62907bf37b9bda94119c495bc6cf1a28de543c5be0ba7a1201f64bd97d14d5b4c61b2f65683660ae23266bcc9be209614e5413d83dd7c319ee86caa215f16af7c0ec2bca38b4a9fad4c6e6decb6634350745a524a7e41fe82318fabbd00d652fd70858a4284d6a2e38db6d0a9fc5ba3291e5139bd4626d68ef575fbe5fcff71d6e1a1a81d4af632640059f9b28b0f91b2d922dec96ff8cd00d4bd38ef8cdfb4e210daafeb360ee2b9d5a7678cd012c2ff36822322a93aa72b44cc61ffa6b9a4e7c1163320c8a2d8c8817e2bb56f11c50142a3cece6297f0ff35baa1397b233b295d6acd11a7476a3f3a1a58ae67426af09f03b5176ddabdab7e2ae2ebb7fdbdf52d79019e1ef55f94510b1d6a16f7bcdb1e537c4ee312925c68a2a4b4b3278bc6fc19f25af9a51bd509d5e58c8a86543b5c1a6335dcad76ba18129685fac63c059a9d828c6a11d665f57597c4bc3580b4a5a18495bea6ead797c4f8cd4af343154362e0bda3c1aea295e10d6212c00b8876f145700b71c1e888c24b67afff17dc41a0b2ec2f732a2234b2b10b09cfac76a879d261af73cc16c5b512b2a13236b36fcabefe4c91dca317a0751ee7169abbfbbe3ab915576d13b0f9e8248a5607dda532fcc6617903bc731176160f19ee156c8f3d9dda4f1d985299c2ac86741fb8d2fef8a403d7e45c812ab86622aeed422238ef071c817d639","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
