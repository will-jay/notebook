<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6f6899a9d42f84306ea0cfd5db72913a8802e5107f7de109900835d6651c3c393b2a0edbf3dc115339f133c13ea2be71c150550405250cf4e6f7650e1b5ff14a473e822f4df22c3acd143acf1054046abe065ef9e3db9348a1fe64ba6a409ac3e4d47bdc3d86cc0a1a94333e983705f243bbe94a4dd9dfe23590078658b3cf60d5bac890fff75bfc0037f5b0fcd2f092915d9f32f15da3060e57fa72f05e0d35af2175a17e70c825aeef4fb577e06cda14e50bec47015a6ba6e5a89d0c746aa718735ccca02067092bf8cb01488973a02b5055da5035852aaed61252f5bff55cf644482d9e282985edbd6641dca9dd8d250f7ecd864317ce6ac2bfdeaf4e9d662beb72e5e0c87b8f924da98b6975c709a19f7ca8226442fb9657ae8934f7f74e35eb3f876085979de0e7bef4adf919aaffb7243d27e7ea97be06fee8228d709973b57eb0e367769d2c7c1005c343db662fe9cb9ba0c13d184b33f20920c34238cd1eb99e9cb0ef33b9f9a6b76b8a90604ba819921bc30026e621eb4eb68883cfd5a974a865d97934801af242433f086b4a66460ac56706cab639e1ef685f90366ae9d297ad587dae61278d73027a06ed16e7083d5b126edb887937ad8ff2d21d3d6ce45ba2780d3c3a2278deaf04579be06f295c7023a443cd53a2590b47c2e2e838a18d76909d26e7e880c33f0bea0342e219bed47bed323bf9762f6b5d2fcaa25800bed56905f504d7188b368d1428d5832d1d2e70bf4ace36e38ca63a2ca5381e9ae604fd31959ce1cd1f704b361583d2793669ea78e2c5e93ebd5517e0e0934fceda6cac83a6d65b56bf198499b01c57fc7d0328d3a3423587438852ba27e3f41e66bd8a2f19a0f2db829e8803596e2449fc09a450a146b7c2d9df942deebb75dfb6ef00d3fa0ad89e430574bd5493de188a72b989ad70d11e6a8b9c58f467e58b1ca6b05a255f8be8bc56f9d592eaa34deafbd19c4e0ad48e4da1f0a8c7860724d75780ee2b5f7abc99d0a71d1818a8144abd08a55f0bb87a3f836abcf8654e27105cb3e046e42bd293d6fa74f3cf6a45360959663be25e7aa5b8c22137dd8f54aabb0e313c702d013dcd6b359e56da19ea5b6b34d3f1ee1919e92e1d5a98e56c65f7af33cb5452ad7806a5d083c567c337c1ac6f862e3cd596260aa2fc3f539e959b121654e5292ba15e02ec47b1ee409b420630b16fde314b72a32d923201846fe9dda4888a506147dc9b02b5dc19edb3f32fae88088e35a7423f243f2656b0d0d26b7d5bc156019e4f2c9a3b54504f86aad1086fb3b34ff0a56731c26e1f5c92146a5a71b9a14ebe9142469c7522a1c00cfba1ee854aef59c4d125035e4aade2aa9c7b0ac405df02a2e2abb25c0356192dd6ff540e3a5ca9a5716e3e3dd068796fe40dd85767247c272668a673090ed7770e57cf59c77551ff1e1683a3f8bbd17fba033afbc76f121cbfa7f82e417702c241f1a95a1b460f64c190bb230f75198fd18ce09b0b0cfeaee758f39cdc9f2e3afe1de8701b779d99b476ea4c8b2fcd707967d347f5ad76af125815d3208000c88ec72c2c9a5f948a10be77dd3095076c8eb4cf77ec8bea86c615a0aef3c4260b5ef0b6f011c7e7f01fb4e6492835a25cf42357d6de2735efdfe2fb92885ab50e891668e9b54fef9b50f4e98a8198b32345ba01cbd988b22330118bf39c6657a7a0548d6be73e31fab5de8b645b12fc67d43a3c4974d5ca309ca1469f9e5a0e383f46f91513b68f0e7ce616fb0845fe9f9094c24b59c2e7e9ec2bd0c76f0f5456734587370b7b77af3b8108ce2c91b25f3dff95e86d4297b02678cf9b0d66b569b2f9f2abc73909239aab7e25d1aaffbdc93231e8bc12ef296e6087948433b4c9b2f934b8bb976986c38e078395120a19033505fc4b01676d72a3684a74aa7b1b762e7467695741963f6f94962c36821755472c0ff1923e6ce73d102e62d1b23ede8b6fff519a11f4c81ca4ac225b440afc5176192376c912bb18eac30f78cc58545eb52209823a8cf41ea6528530168f296c308b2387257a6d7a8f9d73aea47907a5c8662e5756d48d4d1d4f7d6c3349a9be07a9db0d22d45b776b2c0721446576e138d3f7a108c75b39c6db11f1bbd6a26b4b9e38a847b5d98d6b35be6c1d88486713f6ac0533398e9d6a1c140a7f47140ec8699db4563dfbe8d7ab1a435656a14a5745866355b6de46b6a243b2ec858ebb635728717df91b041e89c1090ca2f1f3b0a6dd38ab79e3dab4f9c4bc0c1c1c992c8ba280b0647290855903132d62914b887c69bfa6768e1652be80ef89cc9c984948ed71ae19c3573ffaecc7e4d09795c0bfd4246d612a9bbb0aeff5ff133b6d73cdb48e11cac7f7f481c7002693b00164da4997894bb988947df2f361a7a7c79e57c6be84acf8f7c7798d59d4b24df39e5606ba23619ae659b652b2d59cc63dc09f7e31c7ef3c9ec64e0cee4196a2036c1520e0716e3eca6fd7898d41731eafb776f2d8d4e609ddbe504c3f5bb32e9ed48be27c6a4880aa980d6ff21f41aec161840af10c7567e0dfb9eae1731342e01452532260df74ef008698fb3ff7f46c2cee4d09385246875d3efa12d8c138bfda140cc1086a6a3914af14b0a7ea61a162d51f7c9be29926686dc094b746054c3e6b2abb93ed7d002216d8f7f57b611006d71b4d4abbe1aff07f603216cd9c9b749e8cee47820e55435802eda637d2864c834ee6bff8b8ac47f157e8ce6b75fe23da5f2383563cb9a0eb683626656e349f698e4d9de9f59f1de02205200f34b8655b2ed29f6f29e272d124297b5568637bd04195a7cd3ea89e7ed8d8696e7db797fd3aa8f45a16d879dfd0da34793d9707f69116b6bbd03f4043a11ddc28954c9fa61e75e1205bfafbc25b5ed7be75ae445b15de2d724f27f906a713a378a7bef9b61620e7bf989c95548c2c2dceb1aac4d9e27df515aa861b63cd5631effddccbcd416e005675cf1584fb5ce0e9cb74e8ef0faffaf8e8e46f55e711687ec174eb06fd76c3313190a44764b67b31aa7708a3c0c879dc14e284a14d733b4e1b1787fbaeccdf4e50b1a89f89c5c42d031fb45688cba3a01414e0e982e97f516fc7c24db5bf7f5cf72e5ed72c9384846df5288a50db763594bd9d54d8d22012879d01c3fae782e8d1e2aa7ec0dd5b9c772c5daee035a08103cbb6acda47151756af0b57bbcaa8209b31127a7414797dc9498da571180a3056da45849d1f9df1ba721654095c32340ac57a7eaea41debe6d0a2ed8efe087bcf563fa12cdeb6a2e19ca7898a75b584e468e7eaf52fe7d66572ff5f025ecfc8ae3ac86dbdd3a655576212c716aef783367235a4f414cdb73142ababcbfa40e09f1598b75229c0d2d471cf1e8f7f9868648db2df53d8b9c7e22ae07f384993ffff6eb4d9d572abd2405b71dbb5ba5b52d26d2a3c55ee257bcf3fcbfb5a791f27fff30e366b40f9cf60ebcc3a4fd5c47897d8f2a686f5fdc0240f51110e9fc059bd8bfec899052a54c2fdfdd1aeddde46afc0000ea7842f9633c34d4bafba6e9d1f2a1ad408db3cdaba492043ba1575708fddee59b8db55f1627f83e31a26ae691be4185f3d77fa71e4fe86008bc9a56f68815b64065d6c4199c2e7416ff8a25be76e0697726f6cf1ee5ba36a37abd72153f4d1421b664100d1f1ceef6c3bbef16f92ea67fc87fcf72f19874eb0e4e28a727ee31327ca9796a481b6d62858f40def37561cb57cc8e8ac85c35005114504054f61dea67f9f2f5c2ab60d62b0848d4e79ae1e7197b7cce3380ba8806f9d33ffef170fa5e457ece90f48dd64eec2f9a3de32d8c845a6ebf7d2424c6b9119d1dc4dd4018d3a6395bee85c947d79c711b9cd8bcd697dd6c95157a1d26267d1460ba1539d042271b96c35a7ce9e2da8e2b6a64f97495dd42caa720c2bd97778f261585e131446ca342d226f82b17c190e481d0b4177461d6b069ede5705113023447a5d043ca1a0f060f5b84782645180acc02e58aedc35b065c99e6cec25af58417f5afa938fe7685164a92d37f82662f1e59303abee975880c8de568d3e7e872f065137304210005925a71cc5adade12997f0492320ea30b281dfe93b409b278036f9c11390be5c6eed06b2e4aac99f8294bfc0edf1f585fee339cb0ddf8cd36c8dc4c3ef6ac790aa26e7aabdb88982477b1ddfe9840057e95ac1106cc71c01c6a9482e519340453ee44f88f8f965ad36ec5b69826e0800817b89b441d404eb1a363e3d885085ac6a7a2b02716d3d299cd6c546383efd7d0af26a2597077e6014bfcd936a3ae28d4075d1492a2f7d4e657d42b4c4a60cac208dc0657584bd17205b1551836bf472f81b2009f5eededd8dadc80663502167e77107f7023e757a25f8095597f966a7734a5746afde2ebac887c3b9a5c73a3b5a00072c4c8601b4c4ab4dcd30427409d865d76c2865b40e752e4aa7283cf56ca94334fba97307da0fa6503b91fd9579c1701c180f22f7ba8256992dcec81f4e4adb67435c5b18b9785ad3a682ea29593dc9bc7df8b35f8f6557e2537a84f53d11e18dd800f7306bd54b993c4b9e5d5ae26cb005110b7fd429e63488f00a9eafa2d2d34585e6d769b60728e7bdd7567e8c982d1b0a90020da76bd0035c249e9f6dce535ea063cf9b7f2bb553d46e703f349161fa991257e1d8ededc8e297d82e3865428c606bd1db7320c0727bad81e05d69c4dc5895a3600b4de6e84be95d2606bda81d4ebfc7995402e0fd6ceb46ca2f20bf7cd1c68228534cf28adfbf205bcf930f59ecfb4424146e95ff999c6560378db36ab4279f610673c919daf0261e403a6dff39626d61d947df39af2ffecf8413079796f06c8554da5e1154f41969d779a22ef7dba909b558ab8e95c723d930fb585550e83921080012a0b2bb7833d1109b306a35ce30801530218c7403b95d0ecf2162f4b75243a142e54209504a863062d5eff335074a628cf2af0a53e223d041e8702d320488900c67ffdfbfbea132d87ce45214a16860ba6432855e27c7735feac5202e7170eb962211e083ccbec2964cf0dba007c21edfb9ef7213458d80d62dcee814f9a54dc856dc1177fc8f2fcbd7a6c3380ef55eec77d23be31c814ab2e54898d833ff0f8f57840a1f65ae1134d79f30893f990f5d18fed66d14f8cf0c1d4f6a71f7254286cabbcce10e73b3a4b1f4bbf2e3c803406f4dce67a73e0dd8f1191ae515ebe9f035e81d77b202d349372914c65f3ab0e57f28e30b04d0a326fe95b66a3a234395e02989e4d87860cbc86283c41b7872592ec28b2950c97a6e6abc7e88a3e7eda98d8fa6719f6066fd221525d16a13c3984ea34872e5904a23ec957e1f98c1f89a7db2b62fed21002cc6e2564cb01d17395b7919e10732f5c9a1912f62ad24c3c745876fcb925d47387bb855ea2d4225c6838733a2831a6aabde9c4ea441a69b2c57ca8ef20e3dc190fbdb4e55d21c4d472db1b1ae3f0840ce1d0998f3bc9ed1ab2b13e5f63eaa2d044a67ad11375704db59b419b7716ccada0d73113ccece7691cf028c2c67a4f4485ee3429260226b1c2b88e4f6ea201f151eac3d23d48c52362eb4ce6b5274faec22b9920a99236f6ccd5d1104d9efcbf3f4b85c0b66794bafff18e40fac9345f7f3113c9d0b45a332bab317de384ef7dc5ae9ac716eaea1b90dd364b1c111718cde06f40d16b795364cf701010472f77fde04fc603f352ad013402d103c6c2a13277796bbd154e42f6b7f4636019102417ecd38dde23e4768773116b3c5015f30cc1d30e958f4c718780d4cb06fa9c6326a17c25bb1af2e2ca37c2b05d069a8ef9157ab647a48b6890ccf3cdbe6c38644de8b1b0386e0b6029318a83a8f09fa17799d10faae7837565a198d33e022ee61e0feccea90f25357a0681d01869f00f15946e91d812e6af9e4fe99c979692a7ca5f363959d388e1fcd81dc543e504ea8e499d823180587361f597423a371c9f1b5f0db2d1e4a89418d2c2b6b1bf11f34eb79603683efdf00ece44dc9abff624a3adcf6c410e280da848148c3ea8efd0046c865b409416b3057ea06c5f98484b8e5628b2967e4ad746495742787edef0a2410cd310bfeabf4523d91df8eb3302cbcd213bcc6344a21193783b4ecaf70a73dbc0594c050477a429fb1c3d4e1003b942b98bee7938c8333c2d169322585804ad33ab99549cab59b1e05238d3253010f5a0e32adae5793edc2382161823fe062d48440f31776dedcea472378b2ebeec7e56cf40583c4d8a1e697b3cfb194cac05151725e622972aa13c9a347a17e70e737c91a4172446817fc4bf5a2ed4d0949923266dcd408de4804b944fdd33a0a1a7153110cd30f669baf814ddd558f50b30adcbe0e38d7b15d81d6f7fd5112083e461939532d73bc39d6ba073e952e5f8d553b1d249ac103a1c4fa896a180321047dfb8d341ef7260352d2eedba5a484837614b4753ac2dfbb3d4d0431d47c67eafc8f5465b87accbac1c74fe46cc1a9678e87a320baad9cd470d55ba82a8c12cfcb9693836989c04c70224ba33faaf9620167239764c1237f63fafc596c965c7e7128ab757a0a7913239d74b5d477076428feedc696e65dd684524f54310ef46c3b30d79cfa36807d6905c5076f0dc5d47ff5d9769976a0d3d65e460019d6c98caf9b5f6091cec1614549929d298aee547fe2053d00e504a343a732b0324197069cd37c215fa4f452ea4671c638f2b45cd113a99dc6c90ee93509caeab84be0809e6d0bc1c2b1f3e538fc2ae8808eefefdb01aae565cc226daf92b3456600cd0b8e957b77cc6d7747c1f7a0fb0150c8906e6691278a15d79090bb897aefd400812da00f2462b55df7ea6e17be45609a388dbae41a40fb1ccfd055a0273cf5ac827af512ef89a47d7afdca9d91c04e96713f96270e0cf41aadc43149b6ea585dfbbbff860576c39e05678b19c0a8e25e58e2fa189a3b509cc69ac561bbe42a41b560060cb5adcae31d9e5726c71fe7ac533b3dd83a596a18381222ff6adc35b6b35c85113e4e5ad6eea93157e651eb2249233c2893e0b0d273eee78516a3fbf55f42372eef0234efa0f5bc5662e1b8e91cb808e9aa19e3ea3264c790eefce4e48617a6a1e911092eec089fb78ef00e4b5c0d87bd118c8f761dea5074e9374e1f8c1caf0af684b85e629bf957652abad0b65b004f2c789fb87dce74c3633a8dd774dc75f4d8a8869579b05004faca3a67325aba0e48f97fd34bd951b1a5eb48b23bc76fe62b10ec861a17bf906441bffb8ac043a61d3acbe10518cd451a9a5bf384cdf6f63115affdc9525b0a3eb85f0edab28bf15f60b2a71e22c3400c73f52dca541a005d8e17b0793221ea65679b8cea6d56acfa8e4ee7b7e6c3d28df78cacc4f3c0ceaf66a17e0815736607475fe75711cbf7c27a817d3c3199b10b2ee6d853d8fa74503fac3e5df5d9852a6998d9ae4d2936ebe5cfc91f74fa5d05b34e2ffe13388a468414056fc06db10bf1d1c24134e6bd0f69d679399ff5f7a7be362add52203a7f9c900e0d6575c02c5885af9737ed05dd738841f729b33a40e88b49de08b11e8ea84f66efca068408f80c2afa6dd2f9c150fab0e27446c71b9ed68862ce9ad6dbe90cdd75d80a862270fbd855978a44255742675c85ebcc7406e91bd6969da4f4315525595a329990c6979527debe4082a41d5e0bc720fab2a4c1bd99a7c73ae37520ebbd4ff19c2c3fa247b95aafd78ea1828de147e2d21871e6d46df96e7f3830c487bb74df987ed77da973a15acd5436fe4929a6859bae2e4b53d9f21f819bc889bd07c264b299e7bd0087d0a249947b3395fdaf76caecb94b7a7daf2c08f36fc55d8b068d72673ee437540e1af08f2a85733b378a33464dd6e27eba70f1b80e338f74caa856b0b624a00f0a12b273bfdceba4f25ce5f14fd8002aac62be64523cd8ef489c67594c1c3f9379704d7a293b63328b5efdcadcb9fd0054f2f6ddae27433eb58b554f70eafd8a8c35f070d87276c585cbb99a3958f37ff2004c71b645fc1fabf1fa3a2ca8aa4fa1730ce117ed122448f1e5441571c8f87e7d8612784065c1c04a446bddaf8db51ca871656f73ea4f83efb7778363354ff1a7cb2f46cf5bf162245763ee98d259b1d6cf41464f22de110f381bcef551527d8f8014d165a7178e1b5d2090889ea017117b367946350e90e11de52f4ea063b1aae85ef99b849f9d67a5e5dfdb0b59cb5441c9e35ac6ea9ca8b796cd5d612f565054e1d6c5e8dc924af08453d822bc3df42392a804d197bb22084a6cb246edb52a1d0ccc1168b345d86f30b71aaf761e09df08be1036614c3c76e94d0851678c9bb394923175cce8e2a48394c5fc7bc04cf805b4baae00870c874b1068885cb090660eaa104237734d4713cc41f396f4d7f1adaf5d33c38f1191c38a647b3b5a527e67eb46db5be6ba455f0fd54c90f20e8862e3d7460f77b4cd1d7823cfba9bb78da70a24e08d375c4b0253c791c07c43f823ffc6c8036234bd7e41699bde558517ed7741c0b8fadb962fc57b8daa13cc4bedbd5bedbe33bb4f88a6151d36f55bc697cae993a6e08c29f19fbaf8aa23b60d303d56e2eaff9a27b242a03d5f0f40b0342a74ffdb2e5b929079bd4f5cd4f74247ce48f26eb07c503e06666f998aded947bcd86057205ede5ba9d9562e29dca232196a0cddb397f778d7284aac62e7adb8d6c70dd3cafcd3e3f691f8e74e4e3ef5990c9f46f978a2e9525050a4e926300930d0e1cbadf98a6d2f9ac0767ccc75df89abd12abbb89079755dabda8b87b36eeb7116284f9a580a058640073e2e8bc0b35c983de0665879d39c81d89943bae59f85dc8793c82ab1206f9b6b2a054d83e080e192dbb1af7218a6f4b0c36b2584a99f58f74a04b5a673f7b1bb8e6f280044ac18f2dffe1dabb62162a4578ab6717c2fe09a85c33201137335c70dc7937e238426ca05d3de1a4d47f8e0492a1b17e8f33e3f8360eddb40ab88a7407cc7a78c3c4df74af0173af8aeab347968ae3712c853451389e17edd5f1fec39cf5074d2422fff97fdd57b8f643efa025f360d9673f59aad9d554e5ccd4f65fab68763bb36769280490cef38adeb81d6f34b70c21233f9145fcecc4fa41c7183edc06d8bce7de428403456ca363394fa3136fbbd5e9aab936421a377b0bbf82e203be78e40d817f6463221705018b867bc03d08142e5a19c859cc345f0c8f937d1601612121f263eda1e665cbdd8b72d6a77a17f59e1cf8931822cd199e3904d176219a4fc23307cb954c319adb8a4e243728eb08caa309efbf4a23313e425e99d8891cdbde6864feaffdd8e8b597eb5396be2a62685e65d8ffec2ac82fce8c9f6bb7a94ed0069f4ebff6a1380acfb9a284591555126e43624fec8499d5a2f1209dd465f2c263479915d5d10b86bcf34109163f82473d11b4b030c210c2a22ee91028b5b1b65d92afe4cd8098980db4c919320d387a880ae4e297ead2d13f33f46cff24a2c0f7c861187e501d4915532706487f6f0d7c52b022638764b6505184c443b7103b9f7114c52a19e511c6a9b87cb0666400a71d00a7ecb1e3e75ea298d60f4af981e58bcba5e8860220cf0552c8533817d8b8cb8f246489e9bc773ed008154f158b5894ffdb7dea6ee892aa6c62ed8f634a7abcf4d5c427d7859b4ba4e1f8374fd68c5871b8c308f5a769d47ac7fe83f565f879b58ad8e3385b214396c492af25a4642c8ffb42922e381ccbd4dfd7c13d55a1bce736a090a60604c9be92745d2100343d0f0e30d8255f338c30064eb0f333fee5b7eab77cd6dfcc59bd73eef0083afe08737dc5dddd217b3a46f861e8152839216b59a49902b6d9e985310d4970f0e7a375e51fe7e98d6e674123d35f3408d234ba7d9dc7626a6a091530183be6be12bd5f57f5e7b0ce390405e460207b371255f94c693ee39cae9328a16167705e744a47bf8e175d399fbb4555e8b783f8f65048100089991850f91606a594fe70e9792201e5c548bab0652766c178eb16067037c3adcdf0299b2753d271c3e51b58c49b4f5c9b6f64436f037e84f90ce8c7295496817b5d8f5759de0cff4d07d26898f36872a806b5aec6c1290fe708604252994613fbd724a7d0a073b01661d17c580b859966b2137cd560a90b1bda9428ec19e109d417c0d00e00765fa0ad213577c2236f897f15e5d1d4c0d3fe3595c8b823d44962b8f62219e363859b6b8a110dae0a7c8e53f20078689c9d4a15ef315e69b0615290539b5e00bfdbc81fe13c6b35ccc9179c47e5121dc309b7483a21c1459fba25b68cb0314341d538d0f6e5bbd14e18f6e7024088fd427a73375f802fbca59595c7ddaba7c3fa3dd67c06fefd3096885ca574a7d399b358886ebd0a557f097fbea8c8b676d45afc6a9451b94621064ae23983f0ec10c48e36ccd3c18888cabbf5b08283bdc8a3f8da648f476dee32f950fbc0680751d8e7198d5c63fb81ecd8ce19f3e8211bba640e7a6c1e304c6d47ad0b06fdb81bd00687e548bbdedc885922a3e714ca0bd386a02d73cc9ba7821ecc18fe82b0dc401d9d52ca866d8283ab60a23260305913e29af568e00bc4da7641186ac9b73fea57b49ae12be3ac62f881896e87c4aa9c183476572e63b8daa70645ef778cda4b893f924b4ff321e427e1f77aca6c174a2f6f83d9fd27154ea01dab3f3c3a7270f7ef1b6ee5eb562c33ea73a7c6e2ad1ee429c56249576c440e8d89b78d3922fde93b07932587f70d47ac55edaf93465fb3eaab0e6c7c4836ca50805e9052ef7a7bba4c602132a68c458d4a44144dd41511643ef2081a03f888e5684b40d5c4a68a1b9efe4cf5f4fac2b45b427b6e5bf5d79da459a2d0b68365c9795ddaaeccfcbb1f2f8bb8be93149fe1b350f5b54ea4c2b34bc7b89fb0c39ef17eba2a9039585709a2bac8ebd2e7989e4a0dcf699d3acdc38fc0a60e022102f13c376501179282f4131b3678d0f042dc138fd03529df865d650cae1446a50f2ffce4e2323b1ddcd2761de9745425b9050afcc36967d0308af2e0026be822e33a38194266d85110aa366d80e4052915d626ee32da14056a2dafdbce7ca48bf830e953e23af7f64427e97513f23df2340339747b62624de112196c40ad1277923eee7e3d2c179f53db972a47f201fc82c8a6437ce815f9890ad82ff5c89aecf8e77288c3231e0494a1e0ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
