<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed570a525293e54dc71347f419698a04754fa741bbda8f40103a03d233554141fb2e5cd538fa789c4836498554c499df429843a02a75efb92305384aeee6c2f1315e93fc90a77b2053696241eaef96706901d872c72d92541bc751720feb65bddd64db222b19c0c9e107b651cefb6303bde266ca4524953823cbb01048bda04e9bf29a18f235e268cb47d0cbd8d52a451b91ecdcb58e49d83297c437663ae8e19a17f32c7fb30f1bc495b88a26e718e7aa718ca9e90aadc92cdd373c1568117b59a4cc4743a1a2483044c4aee377221b9bf11460378ff6b156f7359f432c8dafd866fbf66eff55210d0a8626cfe5b88b60f8588351fd3fdc34bd6ef2b29501444a883ad815d2381395d0c141768bc9f123c1609f79d16d9f583b64286b6128d7efba518b0359f674a5a1d2bcdd4d0a0b569f72593917cf98ca51070e5fb7a96c8c3454a554e74a59f6dd07b26653a1f0a8b9e21bb0d89279817b2636f246f9ffc769ea40dd6480f5fe30b9202f99c3020130e1196cb54e2dd2a508245772644100ee0238f8de9e5a2dc94d3eeffaff496c54c1c96df5b4ee9697f6187bed1714289c135f34ae1443a60b9b3ad06685dc8659436ce5e482cc89223719522208ba496f6db294866e9f35068325637ab3bf1d24fae60dd2965f92be1129b5555f0da74130b1cee8db0291d51f379d48d195778651f1fef68a3b71ac4d8c0518af3e53461239f8978bd44106a9ac75b2d7a3db755af20b4e13b482df275cb209892d9b6f3ee080c4a638cafdfab881b5d9777813d4eea2a380c15a6c9dc8cf62ad53e613fc15f24d3fb9c457545d0eca5a73b0954f890516ffdeb84dec58b218c1058eb4822877b919bc733dd221dc43a321669e9796bc6c7723dc41d60298542d3d8513c14a26e02f440e85c7f59823eb4e8aefd951e413cc83b18448444dd2ca4779664998f0536cca6b64e491795edd77f6427289046d805431497df43c8f7a16a795d00e4ce79bf3a655637c651ff21ee9c35b7d0782510be4cbab9ec5b2993ab2727ae19e96c40075f4f4500bf52886567a56516600b9671048522f41cef3945d6887af0f58d8abf7418ad3f7af07a7bb45c243afac51aec6eb02a8fdf661dd2f772be2292c776887a2eafd05012e339b4c01cb442e3ffc0388452f7abe2f06bff9549563f196120b4262154f6f47d4c6a50fb0d931507d4b305a8efd1a8d8983e2233ef284be57db0b268dff55dba926b243430d51817c43bd901c8bb75ac0f9c0de935507665421a2effecd2f4058cd7171506719ce5baa2c84f5c68328504815b1df93060de8583119f33dbdde5deb6db059b698a9722c3bb73fc2378a7a3805a34f88ada07f550bba71b24760cd905bce91a3d10697d29bb2410a23a9c9f8bb3851895078df8ffdd2b9289d2db08f57d9bb631e4d9d73c7b1da43352fa2bce6ae1254cc4ad1bec915fe8bfbf238f0dae9a35452e25bdaf241d1019d8fe6d969de9e57e0fb9c3242e464ccbab49e1fb9103022abefa9b23bb125215129726f6c0eaf3a09ffa8372fd5a19e5dc7365e77779f85e000615f9c612c13b7b6a1d2fcf8491b6735c8dce03cb91ec1068194b3575a29fd7560975e61a8d3f258dcabc8a3bbf85ef5f8c1b7b35063637afb9de4a1f10c6d4762d63beb2061942ffbd55cff2fdacd0963d127fd1a56273f046552aab83c4faf3c0fa617f57312d7389ea4228b258023e186fb9b88bc26625613ea85f27a2b3ebe0355a21bf64aea8ac672f0c91426eb1f2edd6c75b2c105106457c011bc82298d6cc719e97ac6fb546be827fc45ad1b47c9c640d71178b67c19b25950711b50e9b6b943463add691087f40fefd608c3ee869866fb477cdffd6d0ae0ef5a3a135cb4af46debf9a179991f76cec4a61678f07a486570e69978e086298a86c922b251f0ee00adb9ab2bfb35ea8c70f5aa7253bc946add1813b47e8aaafa543fc386f737fade81ac33a4bf0b4b961f434a2aa14b98e98c9431f28c66f51aa94130d85ced8abcdbdc6895e1b6c766948265f20d0a366f9c22480c1f58bca04c609065c76e3cfb7d0c07b5f499767091bdad1037e7748e6dc520d6d0bfaa321700a8b0f1fe9ccc487007465d00b224ff127bae6ec669afbd5c5d14f186c2132db63aaa3d309168db25d7a4d860f292b9ef92253ed0cd0beb8f0ab01e54794f9c34921a60e66bd89890711fa8891a3a30a0a8d62c48e4d8f35cd0bd66dc8f6753262da2ee636492c7cb0732c2c35b6d456d3b8bebc85b6317f40e077e8e64ea7bae3615fb89632ed397c44f7f31e22c53406d0a63ce75932a611d53bc1d4eb4ac488e8de9cbc02110dd3f19d4475423cb10322d5c7c1da05aa41b66ab151fb3cfa23ba517e26b8915ffad4df9fb0b68df62bed82db64a5e295d591347510947fe475f03aaf114d5723ecd3c5c396ea8ad0efbe689b1fbb4d871a6fb390a1518295a3bb38d09f375e73f3a8b369c514a70d0e6c3104694cd6404137ed17c7aaa6226579f0942d33b3661c96013ad9747d331d0a23cc9880cae2e832e5aad69558244e2548446d732a8ff4cb6021b612784fe695d25f772b3fb26eaf32b96a74090ed806a5b8bed739956e527c318a6e5e0814666dc01429ef93cfcf3824510bbef88d253114e17098d1c596a7050efe13f2b6f6bd4d8021a601e7b146952e72a2f881f91803f57becab670710ba20ea20ed228308e0e5bb9cf625ed4df6380f2277301b8d5e5e77ea7b84d2fd1b12236c0c9c2a77cf3570af23fe4e6a91765ebed1c4b37912497ead0edfedca71c5eb117c576f9222549ee8628a5dc449b6bdb5b037c196cb7a85ef95881c141a002d4e67ce855ed09a073448c5f0ee955952ab0c4482bb4e41c34381de03d5cc8f57be425f3bb72cd7a5d8c7035dc70e8c506fa7009c716479a3da55019e460d30250a3b1d6f7d14cae136f906295799554459d5272174f307a973d2d634c229b64dc0c3ff9e68362a70612e425e81cad9ab3d9ac9d20b89c1bd9a9d9d9c98d29f974e8c2b88bf60c6b119552d10b1b5251eb28cf5afcc9a5b2711a747c63ec90034d3be78567af71b48ca91ba08a877e21df4336086e44169b3d89a27df428c547997a9742e7f63bf7ab1ccec489379a8953eb078b9f0ae60efe0c011b5924b3ad178c2e9217994f44fc3a4651cd30567abdcf8e4b608e595a3994906fd2adab722279392c93dee16c991fc608fd0ebfef1ba0feeda233d29fac1f42ef384450c21fd70962d969fbef07402d6ad247e12474cd154d35544f144c2f176461b9ca8b512ee91bf69f985c416692682ce93ecf7faeaa4197d213d0ed719ed6b434328ade058267ed7ecc18f58f974f01385fc1e77bcbd6c47f54b45a7448c41b688af4710c0707af9a973868ab01652cafcab39f25a1d6b46f7b09af54139fb8a9683494847a7cb600ff59e06c86ba3babca60da59215f55a00152baaedabbee24d54f49b79d8987301e8d961fdbebb48f7e83f753cd51e0a8ea081ee66099f439b196e61f20c2dbae6db47eb1f85e028dd55517f0989d9025cd7f185807a5477d7d45dfe36555585362bee4f0b2a24e6d69e976cc701c9f96d41aa6ebf474c23b6862963777abc90995215e117df2c01589b432c00658bb59a3d8c1dd4479d96db60dcc8d8657d9a9eaebd911824cf8a8e3fb42824c8fefed3cdafaaf2c1bde50634cab0ad36039b2ade85967e0efa8e1d8680ab26960b32030c261ae8709af24902bd1273d891fd4f8b5109597f03e19b1f982e4c8cc0d5732ff63fe35e1624c34d979e09cb00e0113fe16d98a6bda44bf02d763a51db94dd9d36715eec160fffd49dd816eb11123adc162f0fce3b9e7b895def5b9b52ec16878c3057d06228c7453f83f8bc4c0c6f0c7a2fb6ae303bcec70f4fdb95bbc44c23975625f5f3cf1472d359e4d54da85031f8257b2b2525a8a0abef0c19e7763e10d01c326ecb436edbf8919c2fc0c98aed29bd5ff3c097e94c5b59031cddbb96df5b9032f9b3da5a52a399d4f405341e31a9949ca7640132ec970cec02176662bc0599d9c443256cdedab2823f3d6779832fa3d40d8a7eaed16d38bbcfeff479b998a19a5dd909ab8cab3915daabee9335ed4f20a8b9b9dfdb54319a6b5654c1043760f317f9c55f6f66eede7ad417106746fa3d37f78c355474b4cdfb46368600d3ad8ccf876b83d6440d239b4c3d36f52eeff3ca60404ce0558ec9a5e128a613311dab9d5ae4fc7a7128ab7e2469276e9c839eb092184c2cf5a0b8d6b795e5d159e5ad8067a3fa52d08653f77e8cbbc6a532270be73677b8b4df5a7a64f16557b4f5b0aabc4b43e0d921af0c57c2108bd814cee79b13a98f8384fd049672b0680162609c40a228ac9dddc7428e9922e0f5e306c575aca2fc6320d655a533323fa86297181d938c23062b2b012b1364f9d1b0224d5de5034d5ad274548bf5f3d3350ccf115795f968fef9c8c3381a22e4962d6f7b3caa2d7d2cc2f68b6c13b86cbdf40434102e96e331b437bd80f553f54b3c8a1909f34f608e9fc9b8c2f591c3fbc90ab570076d13b17c480b531a5afc793ff176c7cd3fd6bbbb292305ed143c315ffe4608995f012f24c55233e8083cd84250f7c12516f472f3f5175e166c7f47520153df68fe256373e698ed4e064b1dfb839da7d04e775d286ca15ca77fe06209a0f63bbd3b03949fef83e37c72d811be8e613f5266d51c07833669c5afee6f3d733e9700bd83b6e28818475130bf3d002034001f12f587ca60bf21973eb07fd3660df61b7b3eda0c3c5b78692e74c3be1a6364d1a1e5f8bb372e6d7f52f5eef4a0f02ae8a4c834cddf6a1dc70f9ea4c42c556caa53d31db26f5ee25f3699ce111a36a80206f7fa802435d72e36390ff27b0832a79bd62bbb93cc82b0c272e4611b4dfcc88d4056461d797e42e23b6d195e2bf1ad250b858b361aa23f3ce64fbef3c5bbcb4b41d0cce2a695a3205efc31ea779a49b61033636ac57158bae09118424a299459ec720e8ac018451bd039e6cb94c266bff82463464ef37e4e489fb33d58bf6ba3573339b267f1c66cb1e33665b208e2ae517bae6765b9d52706f7fcaf2eaf68414b3c850656903a820df7c70839bb1b8ceeaf1ad2b574e433e662ddcf52254a16f8f61aabd0d2f0c4109bdcd6b28324d205ff6b979d95559c446081a181e52f97525da16eb77c13532c66b7904c791808a49952029497209d40f732e3623802b0e5fea86d709149f8c56c80b206320b6cfe9f5a59dcfd4b4644c9c0819468eeb0570d1bb040b3e602a3969ea36c0afbe68f5274ce016869fc3d32415a1f03a1559a4b5516fc281a1b531a16675df53899081072683de16f8e41176cdba38460fb869d426f4d9abfc64bf2c6b43ab0c85dd1c25dcf17b24f7e44947295caecaa61e2732babbeca66c6b6a2433423fe7937f260f5545fd9bf8b26439403fb4e64f56ee0b22c36c12dde2c0ffc9d310514e3933149bb046237878fc316a97bc0013f574e589c29f458534c94660b9432a9db5af0d61c118787dcd35a7763d9c3f3e827dd0930c3751d77e294c9f0920c696f18bbf1963a3dd1c30e02a109dc617782d420f3b5c03bba4950b2bcc37a1b540b13269ded85016bd61b643a817f9feadecee99e49c6bca96575a3380b25daa2209c4ce15427bf96360ca5746951e1819fce2a08b42c640188bc749c59a2409ec07a857583ff4b1943ba4d472a55be831c13c9a52315be5587ffb02b1dbfe81ccf5621837247993139c2b6d1366b6700856fc521b25eaa688539d88d56d2a1cab63bf1825bc3448ddfea11e92ce827d7011a08c1dc8ca9cd350d9435902acb737145a5eaa8644a97ea3703b44cb97961115d9cdb9db5924b31f9cd68f72616090995f730023f91a01ffe32941f70c08a05a241ec0efcdc19152ee72d24b08279e014737ac77f70698c6af0f1b096abc3a619cc20fb341f6b5790c99cbea6cb0961ff42da408d911c0f6160e9fac4c5496c0612c9cc7e8ea8a4f88481ee25cb99af8d4a823109551ecf59287d87d0ce5d6e528dd07c61eb7d6ab71f0fbb885c4e1db06cb46b336ccca071fa4f0cda5014c79e46eeb05a4a1093cdfb76e1c031183e917192e9e8deb2945a9abc7eae73660779d0c5846d91d2b474e1b071976d80793b7bc3a43eb09165237a03fb244da9b43d65c0283ca923c26bf8296ec7fb3884a6ca2395b2181ff32b23aaa3c67cbe9654197dd4bd7642288cfeddbd26e14256c1f3200be4adfd85874be80a56903bb20b4c15a8817cb0663bbaa0d8fe693d9f314636021b8b419118c60129e1d7e541a52ecf8603071feb412c4fc2d00fd10ecebcc88662702f8f59a18dc5a96a79b713ba2f1ede3e5ad2802cae9ed9ac6967cf990abc20d92ffed638902aaf7f091edafa66ff8c8ce8e8c881793fcd4dcd28b94a780ae5b17c0674cbd2d9bcac0747613490fa4c9ad4689fde3fe6f65274f657b148517463ef29adb750660979d505ee6852adb16a33d730f0b491d3a771dffeccc1611318600144664712228bd0b73c285c378f6f47e1ea3623efdc69b2274d7813d4b4c65f36a3d270304ac3d13df4111f0677b0d72e3eb3ca2f229529ae60131505c32f5c5d5e2b2a21ccdff9de98b36a9f8f913ef29be8a31db9763d0d5405c7e1f74fb6d8a344bbba41d812d1d89216d4df0f424cda1b3fcfa7e0d8b2491cdee3eb74026ad58fdfbe23a582e8b4c3f02b134f88954a7fcfdd025fac638f1bba305125fa6d5941447ce39cb7859ad9d249f987c4b1bde581c642cabdc63d89fa1d50ca996e96a0f9f680c706f82b94f71ddb8fba390f665f78fb8d4b83d283eb574b216f7ffc5101005a87023ae435beb11cbfc68cf67bf1928c301632e495978e5facd21bcf95402102e1574c3dd592b2c7b4f6b4eef33d961a842097ef70fb4ef3c674bca67a1366e6e8535b523a2300c5034543203cca81275c264720753e7acf7336687e769604d685401e87beaba45ba88011de62a94651dc16dd1c56ecb05a5c5f83cfebe9638dd8fd17b5ab679f226aad4372de3aa5b980b9abe28c9e9daf0d75fdee4b4fb6f8c01953d2c9dce81b4eb31e09c5316d53733c7c8989f955f2b52fbadb38b19ad73d9c2858dcda729f9b0537317f836e0e616baac3e29d45248dbcd16ad218ee574465b376c1a92e4e1a5491cfc78f7d0704589a860778381530ff504a2d0e1d669e221178b77dc82b6fc413f32a93d51ab806b0fd713ab425772d06cd33e7c8f5443431a7e21b306228c9e61ef74427d865fcaf47483f996c340ae1e263f2e69de3851b7c87b046f57189102f94c9b6cbf1c74bca01418ddaa08494c0ecd9620271422c974ff8d3f129774cdfd9687d4afbcc24c9d4035bba0eff381eb4ba7537ebfc960e8d56fdfddf3ed2fe90280130b42389b76ec35e939f0c3273c13877e7a97373ea5ab3a8222b1f46609ca97d00dbc8b48222d79bcbfa947d7ffa2616904fec86d4b83785ade647e2f1cd1859796aed0567aac82bda63c46bde5a171b65e9816561a97ac281def78c79195e1d289a3ed9804c5c0d331d8205986411d1e8fc7134a63452642cb6932444464030e256fee17a7bf36ecd735a7b3b7aba213fe04024027bea415fa3d356a3c9543d5ed6b03ed5d54bf14d2754c9f978151d273c8fbdbc9ac28820227a1f94241b03b3dccf2cce1d15251b182a6cfebf0734134bed0405fdd2ef9d45bdcf5ddad63ff788f6d3248b959966b17338ac1c857ef1fd471520f2addcf649a95860e4f2f026b3de9ff50651a1dd75cbe63a4f6a4a3914bc8eefa3681608f511cc7297339c0f82616bb62ba2bc6a0f0e2243d51112952d557914a60dfaa7cc7d7a9fff73239cefb095a7f833382e0f0690e74db875703f4e7fecb68fd75b2030a63ca328688503d4e1f23a99d00b430e352f80ffa30cb9dd141f219477f5ebd42300ca3a34644deb021ffecf820d5bb548b5a9addd8222e9b970ea8c7fcb47587c1d10947e93163c83b9b881345d76fd20169cfcf42f93f85d422d129ac89fbe8daafba46bd5f4976992c55d8a26d09ae331ff85da42ae352ca2e2ffba23cda6b7f7fbd98a0f88f1425ba80f5f60e7178a72608dee99ea2045a7ace250e8ee1e1546b7bc818bc78e519f53d842137e102dcb87efc785af5fc113b7b39a593a8a49489f7ff621e116c0f103dc343df3d564aed30ac6015c5795efa19d29aebb3464ce20c61d49ae63ff5c70aebd608b4bc513d6971ed33c91bc9d2d90e0b29894f2d031972df0a447b96c4cc851cb99ba6aebe8d1b794a9b8e2991d91c2f7f28e7abf1998c967e865d12271764d64b813c9d8c6333263fac0a784602ca012423b93eca9b2bcad3b4de33d7670825465a1804f67eb0d778f7196c754831a62bb414213ab55cfd0c2942e2800c40c4e7f0b6389c6b7d73b36e06b2df3b04b3d380fbd5f1cdca77dc7dc6695847870fc5a91f882c2b9199a10036221751bec755e1b0e0da3deac8073f6fa3bfcf72885e2230c8b25122d621daf404986f21a52b69c02c99d5f80aaf32e49a08207d3ad03793ad7e6c32ae839401a91a1678d0a27bbe57fc3e7d212489edb40b1b78e04e9a651084d9c290619b178687d15048d461ba0e1ea28c5f2a373969a32629656d437c937c12e74da050dba13230dccf1aaedcdbfea7e665d67a8274099861d388cf155977f4306e2c34b7e3095eb9d8a840d6c0906e488ec2741356550b7db2b3c25a916d06a1d94f7a205b5274d2c20c81039c48914b4196dea4f03447a752a776b5287883aac7a9e1fd8b963cffa81290dd2dcd88d68ac565a7eb5bd221c8e8c4f01a6fa75e95e1064ee183daffd62bfd22f9c2ea1cda849ca9f24b3b33b1b145e063e2ca731e1819f437571942ea21ed91990fb1c65f9b4d94d99eb30347962aeac3135fb9697c97f7c1b5361a973342d03572da00fc5e2487ca9c2f8e50132d16efd92129632adf3942f756208805acc730ea28a45b0a957567e9f166c09992eea1b6ca3fc3d905eb748279e112d8eb31e7ab228fff449c9c129d204259b792f9f21381eaf0136cec30012cbe7dc1d03e1af294e8751e439d3f62a15119049d62409b4b20f4328e8a5add800c68eb7ad6ab5237a8dde6a2563a3e988d2c0429d8cc79af09252ffc8dd60a0b8b6c7444e4cd4e51b2f6ea79f5d4a72bc573f33633cff91cb477b7010d5a6b04e2fd2eb353940d7096e59262ff194fcde7e1da58d25ed012a4478469dcbae17170743f7b192822b126a8ce028a9567b346c6c2cde787ec2a8ba6c2c9fc5ea5f410652f23f26984776246822c25f5bb6a29970f522c3b961931c38319cd0e3221a3b32a7b7205cb832dbacc565d45f6a4363a6baa5bfcd159f9bd0e9a0332a575a3b58e90785836203cb2972a6d2d0b6539907ddf8f0ed8d7d95c469b9be2c0c04aca30f2cd0c187f3de8b3d394dfc05b9a83f4a1054d7e2ffa537ff832734765e096d90721f7e55b839ec6babc75e2dd65f33f23e54552ae80841a8ce53cf3bf9eba34353090275efe5ba86fd1ab5e371e9061ed950c1d8229d6648f38b8968818ddd16c007c614524d83b96f94551dd44c88c35735ed634d32c04e50bb49dd7245b273eaa06e34c36af8d9e76fc74d41900d7f524b1d5d80bfbe9b07fd9270e5ed2ae03217fcff28a3c60afa7f9ab4061aa86422bc6c7d3a62c8e59ea8ea278f68f5ef42ecbf567ea8ce607936c924de8c6d802750866d606c1458dbeef61dd5689189f3de925a239c0494567e2c692811f90ee40eceb4fc65d27453eda0bde540effee1333fad9ac695a14354ebecf039e6b4acefd2a7bbe4dfa509da586439718be28540126b994d9d3f90ce71ecbb858566b1965aa54a8316bf27a766f62c332d3672c1561771051cd1089c18404f6359e57d301da8317b22e442e946b55eade5026839de58b646e81ebe653c0f6c32e3045abdf3d9a30653aca794749c84c16dc021be1defbd060e1a3b3bc925c6625aec7e47b5f30bdcd1636784867cee4b392834856ed50c5caab739530de848211faa2df0f26b4758e8df45ba4294f2073a1a751269b087f2eefbeb33d170cfa7ebaa9b1762710122503dcf986e83d9fee3cd04dfd9c52b6047cb186889e24d9fc69db46b0fb43829f0babcf4f0dba2bff7ec6831c04626a91ed47c2d5fa49555e8f49b13ea495d2ed046c45a0218d12a3df24eea3de510178348170b18375134c69039c00643c8f6c16f8e35e2ae6669e1f7a8afa60d58e9b6f9e94de751146cc836ba05a3b2d4e1f1fce9f9ccddd619e49d0fa5435a88787a026d00e00d5411e1a40f16a14e012b1a089321fcef8bf15a9c3c6d8cf6a275476c83ace101c1c02b632f93d6be9f756f6bc107334d1723a62712b8c7bd956af4a592d3d38705e7ebc4a1edbff55a5d86b1cf44fab7d06b678a7d9611b5230ae683df24b33208b25b8ff95efb4dd3d4893dedeb244badc497436312d7204f30da39d7b50d06f4611aedfcbc5f12ced69123c32c6cdb97b2cf7c2bf4d0a7431955c447044e3e812bc4b810c63a94bd6d4a80b7c6a7fe093a7c0e37d74be682fdc12b2012aba2136df0e057b876d5c995407e0ced3185a94fb80b08e6d7a6da6a32793e4419aea5f63350598c357046b8b076469b6549256394076fad57e233276fd1f799542888520999edf36702522b393af5377322aae445001fd0e4b690c90c4860d59978b4bc17354a4f3807ffeb9666d1c38c27be1d991aa28c8ef1f06b718683e525d0ab936b1c36c13e2433e8f2479cac888f9505547fd8488ee3e6032a521f83aa98a1314862cf60ba00a411dded6e65a840cc8360ccf06af2fa33644d4153382019fabbb7d2153df191bdf4923041269d5b10acc8081db1ef55aeeb03a38b536e0e2d006c833d0c79959c8aa43efd0f1d3e25c9edc22746074817d4c59eda4dc294fe1d4aba381bc21ec97e35fb25de9189acba1ab662fcf9df2233d7c345626ad3fe5f00cd2614ff80f6cab477db68a166281482bac42effdfb27cee3b76b81d01d5de81116f45ec88dcc38535cbdf0effa72be975e269776819aa2dbdc175548a737ef82c4fd5d16af9f6076481defb6b33049e11ca25edf4261c2b39916cfc3259f38215fc233978665bada5d7775c17f3e47db5fa0ab156fb68f5088e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
