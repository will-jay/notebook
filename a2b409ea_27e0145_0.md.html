<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db5ae467a83c6a16d7c900f913f710f67872d43f836cef0680ad3cf89901e1f05eec9948d009f4aeaf87c4402e69ea85dd4fd28ca3bf0771546105173d1d463d7c543bcc1b35650ad3350508841f1a8af0c1d40af36ebac0d06207c4d0bdf4f41c314f47147e992bdae0d1c556bdc1724d62abd10680093a92a84864c1155fd2471e04489e1d484821478b57ebf6cd2c0c3da30e2bc2613424ed556bb030f2991492d9202091eb9dbc0bcfc312ce41ef6c872da44708e9b05537dfacab70c95bce30ced3291955fd19adf4a3bfc840d8eeac85076f7e8e2bc29d70859a1643376fc955e6b44b119aead76fbc46e2e6ed338cfb0fbaeb157179296d04e1064f4211a82ea8a0dedb5864954ec6c5a54a27f77131ec526a027c5e93ed15e703292b01aa25bd0f446f37d3f4483b5b17052b5244b4f3cec4ba273ff5007a802ab6bd3bc6875031e446af70c96c63ea37e42c7fb4bad9c98fa10814594a1b3d037dc57dede79890010a9a2175e94dd715623de785f7ba8151ca25e7bc1c178f0d73b0c616a3a9a311639f6f17b3fc9b97958ccb373237c4db97300265ba6f4185c8e8fd0584b3223f5fc7f96dc2da25064e9f8190906cf800aeb7f250c02d9ecd00a46d73c2f9cc0b5e333ecc6bf5487d25a5bc4b0f7272fab7abc28ab1be8c110e3dc7edf360041fd696496e24e6653d3d2dfddcbba720297f9cacb099d547978463d75d69a5c76634443e41c11e1dfb2a32a93e2c5047a462b13df5d78c2d943fd2ae7bdbb8ca41849718b449f84e699b5ec358ef9530bda3c94e1aa9da3ca21c7774818fc85a0743f29b1a9d13d73487b772e5c0beb85ad715d4e7f0519d7bf83c25660911cc63d6dc44dec0356499375febc29062339ff25a5020d04fdce8d6b43b443332e91db8bb1e046d986b4e92fcf5368b9077a9b34fbff006544cb0e44b02a4100420a94c940192ab7ed241c9425db83e4f4c6d5fa27b54524323bd499ffa426707d6e18922657d0e94de5d2f4b8084fc30b19e9cd4f1d52c9a99d90440fc0ecd12aa7472870530fc4f4eecd45983cf63d6957b78074d00e2bacd1cb9b436c0180269e09f25ff28b2fdcf9cbaa50e41d6ede71d0a2dcb4e10a9f383d13af00057fcb13a7a56a2a9a1a276826b4a9a4e61701afa21184dc1915d6c0db02b5d1c9d11032e2fc0c07a56068579b67416ae76fe9f6b4378483fbeed16e6d5c4b6e40d3897cdbb6e02ea962bc35b1117b981d1069bf386c63e52e0eb27bebbdce65fe49e978369c7567c0bcfcfef53886f6336e3dc90f1056cad648eccbc6099af51f58204b8cce96630327331e7724c0d5860fb2d679f2e2acec7ea3c7bf043a18b47a7a65867e0baf4e9055bcd05d34703663059f1a29e901f2caa7455ed173854bd1037a29490c5925fc59329a25837c1b9a9c8c5cf688788b139332a08a558882e9aa18c360e6137175701cfb69720426d8e2f0d705960391f717f9adb69e57013dd17f1889c2aaa082e9b17020020794728931ed50b4bba9b51f0aeb3877c92d615efc3dc354437c5ffac6f45d8855a06685d7e0f7e7b5f789ec73e6fb71cd63bea643aa98a59d9a1541e890d6aab12ab03aa64f567d137537be176607e53518869ddb63bbdbea490472a2ec8f5cd5492143c1344ff0bfc550cd513ef966e664b84fd3f6a1a0d31260ddaf44df20c529be98f7274f6166f354effd27f12ae6b7e042d34ddf68958938da2d472dff3de6ff90a952cbae233ed5871e037d615aea53b462613cc2287e837fcf6de700edd780b56fc50816cc124e166c31e0136f0ceab564c775382f32631a940aca6f389afb1faa0841d5878be33cf95d62b7405f186f4c898a73e764bc4f1bda57911dbf72de9eaa88a979f74cc5609ed9b03b250276013725ffc202555df488ba213758c0a14058bd2c6277aabf164ea293c1251918d1fba4ec56465a06543d156e123e68315313673ffb2fcabb5c27c4ad5545df888938a409edb21f78324294c455d8fb49cf84d054638ba5b61da966607a7d9031908d2ab2ba6c4eb8668be9bd21dda1da1aa6c6c76d41a122d7d5a252cd9500dbde0c7f27b723afc307292732024fdb892b310bbf8cdb23f247b066a5c9a91dbde4514cbfd69a2525973179ccc4820d7f5aabd5e02699733a7d3ddc4c81e6cbc33ad30e664bcd3185921a1869d4f3649b355a1cae70ce51548e31c1305a7193c76bba7d159e2bdcd796aefb8398ee76fe6214381bacdf79d77f40d29e994eb2e7dfc0e3a82c89d30e4181568ebe1588f6662be611862acc2fe3abfa3840c58b6b3735d662aecef830efd7d69859c383489e32bcd8480e564499d4db6e900730d70e62d2aff472bfa56a77eadf94e34a554a4b4dd7ca33617007c70dee5f95667876e4d70bed966aec5b17e1614815fe5b614346dcec5cc265137d40c8fc0e7729f744abf65f1e5cb532bcc64f1754342f17fe0adf5f0625f7e454021ed8d402fb6c68f109661ab0695aa2c053786dc3dce566d55ca2ed74365f6c26b6b01941dfc6419f34461d05dae5d69d730f57ad32af1cd5521de4a70249166cd7feaa6fa7ef4deac86e041146993feb72d4548fa183f6bfc45ea8dbcb08dee505168e62b80e95389562465a3b6b6856b3b548bc8ee460f31d4cc2bbbbf4e1effbfbbab31db3fef5654e10e7861c9a09824b269e93961298ba82c363cec8faa9f12d4678841d1bd8f81c9320698b14c3a7039521355ac4c85642d4d094917a8b12c335a3bf78d8636c0b1381c715972638667afce5e245da6ae4276cdc1e5704afda60cc7d706a83c8dee8fef56896785853d4ad24ce083418912135979d1f3546274811e5d55f55eb25145b1791a06352de4622e068a78fcb031d8931063efa96271e3292a95c473335aded94295ddd7068fa7dd2f8a844474f26ed4d193c2003456a25f7cdafdeafd90aea4af639abff935d75d3f2834eb0a1041c43bcac6aa9b5f21bf758d1ddf66cc3308e496b067e9dbf2930002b4ace4d445e5def726d019fdb3afdc3ec29fb75a8f100f07de93fafa330c529a5cc84bd312257c644ee7bc04d72e8a3d99cd51ae62849aab6ca2900f0010d50a636179e185fb75e44d52203ccf45b78ca3f7aa35f9670e20ada6655d62a583bef1a7bd690ba94aec8b666bb44d3424b4b9532c71709c72925ee9c7296286e070da765d3cc27787d98d7d5e6e27aea724fcc0fcb14e1741e3a2b3516d2b432c61bdc0b0b31b1f6c93da7580f220c8087798e53c518b47fda63fa544ff0c44c8d58af54a3b58343f52f93e07cb19c30f951d39b571a1c60ba80d3fd97bda3ac8bee84da991166b92039d46c95d7c4ce6c732c00108062c257cd6de42db9008dde58dbcab8e2315ebfd67e7b87169aa63c9fcf676f42a12b1ce206d8653ca911c525a0e36623f96f45001d11710e98cf30e060d55984dcf63efc16047edea583cfdb657b499095c21bd92a71bb97eba72cff7216ed9b2a3f774b0f2f55cecdf0e407db277e0a9b153638bf3ad37c4b29a680c699ee7016f0bd20ea40e271777f4809d8726e1fcef46d6aa9859f0b84284b9abebe9f162716bde2d7dc79bd734a388ff7585ab756100a058a2daa96ad36bc8e194c2624fd788f22cc9ffd78a23688d0b230fde7c85eb7e3fc4800c82f0e98e7703335652747c2df251b353943a47da474b92938726a722b922d479c3c75804de6ba30ff8db89b118b84bed0a82c53d3307045c6ce024825c43cb58549a1acc54a613d7b9ca00e4ffd9f6ba295eee630724aee8cfa12fafb31b54d4e9ae1c4710ebd2830404fac63bc57c144fa7a8ba46f4bf0b94760217385158e7c92bfe7fbec855a5a4c548f152b2661bf3007819839b010b097e3d19a3806237ebb8a11aa09263a605aec1341459888d3e375f60970f7c892d069802b490a87948367870242b208baaa66e4ce53a79ace5dce7ade35397c2aa93b6eb8aa185d692e6a5077e52d6ae9ed93130029c65e5ad746c675e200d9bac7e1e73d6994745fa18ea1e0db8e314e59b26acfe27157182bef87a42a9f9db88a1f73787c0349b380660109ef7a1b06ca3abcbd61de96b3d3f86cbff7fed3e67d7566d255d070337d9b58b1590954b62fa277c529e69d03e1317d23a1fdd5f549ffa976c628e0edcd5eb93df1581db852904ef6e2561232109503c083d03ea8391b8c0bbae8ad7cee01f8103b245e722f57477842ac6dd56859d7c807be33535b8a3c5d780a509e21cb3042f91ccbcf169bab97ad097d325997f3fe928ba29b3ec56b9c0c65c276f487558b5863c3d726864f2038aa871d745f643fe7c74150b2e2aafa5029bd2cc00b707802b578d83178ada8fc22bfba3657851b20a6c37daf405071657c3801bda499c4d3ea84b19e793bcd7bb6ac81c41e32f8cd373c0c7dfaac2b464fe4a5fd4c1d93342e43294f035ece0aeb580358840ce8bb154274cd9a5808e910e1579034206b9f5a2c5a25a31841eb82e9bbf5d8dc4f4852dd43fe135a69c55029c02f416947ec4e8f1dd282163dfde5fbbc239720714a1153590ba9e4c89bbb6466c894bfba36f7de283f630232b894b3758bba8e4ebce1613078f9d50abbdb942bbcc6df72a5c826be9aa5c31652764e4349fb86dc6b0f1300902c55bb6560214edc09fa680c017965b843c6ace5fdce21f325b9688989eac1b8428fe20d4cf0bed3c499355b0dbefedbad9e9413e2fff7c501a730fa004610555c804c067b0943ac7e4149ca7a0cb39cbf520084f00cbdc78c3d04fc8b2198445bb4857b6cf74de712cd6664d27cb917d82f70da0abfaea42edc0ba013bb821c6cbfcc6c581b89a26aab6d12e9a1890b7d29251da5a210bd7ee2af1ec049e94d258a0c8acb7d8574134e9386eac579d493451c12f2966e6bd0546bab1c4b4882c4f51272976a2e4b411743a329771cda25436820cd6e2eb9a62c66ba8f97e601f6e1083f36867f4518bea99627e1725ba5acf6c2cdfc040742c2d78e8f4f9548d59e1fb0090d3a30a9f68f795f628c46d80e570b5ac7cf04a9fd604ea24993019139ecb936a0827b6d99ef91f67590c7de848b98e6c04d13dad9d4759db3b777e968c3bc72d75f70e630c4e864e6dc73d90d6905c380ddba825eaea753371e2059a7e0b62e762fe011079e78f38beb972fe809f6b5c5d9a38e7ded130ce181fc854929336b527b3e0798e4f3c076feae417e326b5a16731494b8cc9a66915689ee0722b087372e747e158905d46f63be1481129d6fea6e3556b2a21a117df55cfe06fb62e2fecde22c1b966c784c774b08c0c3e6ec0e3294adb01cab28d66f4e5374e4a6f76bf1d977e189378bddbd6ffbf0fe962c5fc00529bdfc39e95f568b1d014f13a8fd691cac03fa9959c2e6b81551608cb6dbf3275bb0f41259aeae86d6885d265105aa6ae3bb28e3df8309aa12a81ecadad69220bf5f0c3e5613b0c83b089c3325eaa866a0955a88f4f63a0c0051670f099742c175a8c4c930f04fb7dd0690d0f32757ebe43bf6b0b0e68cb80b8ac6dacf01a4466a57df6232a056e00c9cf9342a9fc2e9c11997f0d48b6184399d9d1865060ca3293e28c89b05005be62788cb17421cb1c77b43d71fade40c72ea38c828ce92746143881d8e0b34652ea9a75ef4e5f92c5bbaa057b89977c8a7e9e53e3cfbc2ecf8ff1b840de1cd21181123e545ec664f73ad9ed087ac9d03bd73a34cce8c6675ce20e1b68ee19b034ba29699f8e94030842b12a0fc158074543bec9ad28aa80fedee90f290d190532941206334bd3079586de615799e4c8ea9f4ea0e93e721279b78275d5af95f11e779ca824f512daab48ec4cc359c7e12bdf540310215bd36d4742c0a3b0b08f293e9687f65cbfadb323e422cba6778e1ea49e67717155066b2a09869305714683d9e886558d8239a5a425d502752db281f8ed2d37ab17122067f080c2bba7069365030ed7c3412cbff426b6c276ac6db58197d5e99ad2fcef070305bbaace8377ab445146d9f5271d3a5221f13d54b6be8fd348391fef65416a83ca9f3348506830fa5254d6c4364efa43a0998f3258e7a680da59389bb31040ae5066422745f8c2fa3d52415676257455b9ff6da51bdaebc6511d13908cfa4ab5f37a066d9d06f8e195ace240d084409e3f30b773b00ab0a07729b66a00d41d7d36538f1e32db51c2ffccec25e3a35fc6cb15ffdb5544f650d854e5dc5ff947a15d86f25b4570ac83916fba4c26a4760b68b605c78b68e985115fe3579fe5f123e47aff9477f4972293871ad94ed6ab73d26cf08865f42c0d5781cfe2d5249da293b4d3cd55d7f24dc642673b2a2ffad18e85f39a63f206546c59cd77260e084d09e1a0b8de7784c9d7bb50448f627f4548530c33f128e3c20fad7c04a437faf0bb2d8e6a29683a6107d06ff27cab9c74c26dfb8cf731aafe24ae6f580df496cb94755c0e7a82ac4c24ae498e52bc62e90928e6cc353d6bca07553a05ca4f45183edf39aa402e144f294d6ee61b7072474dcf1e032be1f2bb75ff911c35442d6e2f08b720fb64d31506f7b5b2d4e06021e247d8ca11e786fcb5f945b51ec1ada9fd02ef99e1b56583369ce5fe83b42fc89db0eae587b843ec8ab2f07983814d4bc8b00d7d579da5bdc5f85041f6293ba31b35e82c2c0a5d2e9e11372b457571c647aaeb9bc6729212617db3cbeeb331cb714bfd395edd25bd139bbc964626547b22fa38f84a4e4df7154d0d85d4cb852618b4270c1508e43a168a01fb6fd8bba16ef68472d24e68fe4a3f026fa31bb8b5c6051946364a2994e109ceda73677f00ceadf9fac5ff4e2879ed8fca86b4217765ac2b31998c10b9b0154c913b096e3cafec6561a3bcd70c009e08ac9e9eb18c8b00016f767a4f66575e8e21054993033f7161e0f53ba50c9e5b882bbfdc9178c3fb2c3f9a3148018dd6d94b6c507a41439c915a84cb41f36477b0b8587952d4e98a1e4b554e7e1a0144221ccb22d1e7dfe41f43f3c0b74fdb9cc97e03bb79891e915cd2c756d4bb5e173fc55346ecc94cb1fbcc6951376e09d8aed1e7b6de7f13a7a495bbe3bd73c1af8a6a30ad2e02f36f02d5db897fb2d407ef2225a66b0fa67ebd474a205d229df4ba1eac8b8a1d73accf113f90fd59248d6f40e876bb7c09225a7f20b047d0cd29a777fc3f6cf976b7a6ab577e0397fc33724b2c19ddaa5608df23f9b28689d1301689d43f2caf436352eaa177b14e21dcc78d80de91e902c26041ecd05b58d17a2ea6c4bc2cdd2a2a77ce2fd641fe654007d85499a1e6d7df0357973a0605846dc891c2c4030796906a091df1bc9e9529e655bb1b417bc521b9d2effba0319778a694d6d8fed693e4921d970fa3859ac5fb2131945023abe342793cc6a9aed3ac27c1e2c88a01b016851b80ac92bc46ae68bd8b0baadc724055a64965783d5be2c08eaba6a6e4b53899aa994200dbfe82ff6007443ad0065b00c8145fc21e4ea4ed017a85f6555d05fb640945a55f21617dcb2b5d402af80072e20feee16b91acda5fb6ef32b7948ff9c8e391c9faf348cf28eed902329b779ca606c14526e6b1d5e1444f0361ac638abc11cd9e1ab30fb484995c3016ca6bb4a6e1ebd0a165058dcfc04a4d2013327d46d9a5287e7f0d8034b4f246d9243906992a7716db6f02fd3bf849fec6b884db0e0cd7de4a3affc104f387895943b4481c5c83c3067f4f2ce1988a26939c564a31f3de6ff66715ac0daa631bcb6b918ce6be54116d03c6502f6d6d4b22de28afdc2d78d7e2a9ee497ee55582de3fb58946361cdd7f574bba4720fb81320476c9b715cc01a3a46c99af14592dcb8bd863d300a429c52990e932bb2021d8da27ec267a2fec326dea267bb6382a163eb8ee861533d3459df6b79736571f6e315b3852006e06011b25a135f1e2126cef52e6132b3d517fd2101dba5f4a7f5a3ea5fff402ca897f57eaab551c78d6df3ab47adc45de2175cdc7bc04462587802c6838dd2780bd500ceda5c4704981dc4356e85c10f8345e18418e9b0a48e37346b743ff89ee746200f623c73f2af58f91ac785f9c895f61e2b2f7ba8f1eee778a091ca37e7fa8e245a883c2d05edede5e4ea4ac751ed697e1e7ff45b097c30a28d63586ce896602f6bae3fbd4805ee8f02fbbd87ae65160f285a9d9f04d4edbff5018f2045700b95cb90d4b74d9a21aa27c173bfdd802ac7903c675b08de126047ee6450d28bbe72a63d0c18fd428a407552e1626485fdd66977d4e7f94896ac183d4af65cd42905482c311519937acc87c1f3470fbdd72dbb508c2e151ecfb19d860610387959d2cd540a51e91ed9b0d51197f9ab17e522d0df9cf91a32810bf063f95641226c6c79f94a5a0b45bb1a7a3de9cea61f9d4bcb59035342ec8ece565ea7459a6437310a4dd1943743d319bd34d930593132491e277f88065f4c3b1f577f0ad72b8e729fc23a98d9a27089633b97fb917cba2442d44362abb9a49f603e6e2f97210c43b71ce56e9f6e40e79987975d91fc288f16ad473fae8d57b926ef6d1dd6264d5f2bcec47f35f473546a0ba605828c79b16b9b5f14e53b89d3b05f6033140f6f1facd802748faf253a481d369b24f56549f4c31385aa717b5f614ad4ca13f38e84dcddefb9c9493f3aab00077a97912a51b0d58de1ca328c62ba389b9bb8c4cf30f89ba2cb62de8f32b98a62fbfe539e9eedc9c291dcb889828b77d29124ad2c5e1fa2ca27ac76384a03b46240ecf740df7ee4f105be62d19fdbab85940127e9a213774a135f0ba6d70db580d5ef09f5dab1f06fdbed120962a5715bd00bea3ed351860464e2417d00a908de72004e288ccfd56faa2272493d17b5f3f1b42819df5cc7729882d2582ae7058e7fc4fe03a7a625841b38d06a20b7ef7bc7175393c78e10eed20a382f338167085d977e018b105dee9238914bad03fc57c3a087f723a8a8d0f769371b9129662bb4a81616fb89099ca233c70dc8a76ecb8b23aa3013f9406ec66d65b13d0ff251da8e407c269088cdb47b3db323ff8173b9ed50b942101d306cbef549b694b91adc9ec180d6ce4177062259ca7002f3ae449b49acd105d9bd8ea7ecc7a1638f3a9776c7ce0ddaa9af82e06dc949ffae46812ed72ceae5709c645560e533e007031e6f304619e5ea49bb82c6f201b82f0e8bc6fe36fcf02d8c7560be1713fc562c0cdde310576a2e7427111b4a9aabfb7d42e7150786593e3098213119e1d3f9334d735c48c8d554f98c857086de0fef4e527c90d444382ae124b7dcf55442dfaa4d30635ded4d94d7223c47557e37143c7afe37f9afbc8d1f71ca12d3fe1679bc0851b6f59059236909dec81c637e3d5635ab895ae49a83bda216bae5880f2bc5600d3eab749aeb16b3d8d46816e422ce83ba60a59288f03d219f87da95e286813740bb83aa8a5f66cb536ad69ed4e75c843bd0bd4a4f654f2ff588a68f39bffec4ec5e3ff4474bc3cfccd1a3794441c029222da42add073e5629170031ebea635a0e6060d426c8127712a55d3d6517d20cb5c0a67f09d1c7bbad1777d385793fda47c56f2d68758a62269ff6be4a4ef404aee1a5abf6c1fccf70024d97582160fdbb93b9627307db86ab4e7e28e32747d4b139457685289d17469e7379629d62db280705827d112643221e4cc665bf29d83f9021326784dd9e447fd15854754e095bc74570fe64b2d327887a83a072d15eb3f3c98aa80db9f13cc3019c7d3653270e2f6486ae550550e93b61ff9ef872bc2713e63af8abcdbc6e4ed2662f691dd37aef87abfb4d34a7f8225e650a5fa3f3ebc2969d23bfdaa38635d5ef1ec0ed4c6a18fc65a6ce980be3faadb3d8e0cd192f507a5b36528b4b7c2e7a7775253f08e2182707eb0be13a550ceb18d1fe77f8dfb64bf9667822dddb70c9a8469c34dee249adee3b8e3c0514039cfdd43ff93ba1a5953e3ee585f7439b885af401d9107a47b71617b48b8b7ae26c80d6bce384b50e846088eab06a3fcb18ba109dcc7beee91ebe8256516ad8a4f6b093f98588380abc409f4fa9078fe0f149b254b39d74474e35cce6bab4450c81867cd0aca1c830da11c5aa51fd215c1714988f112c4a4922de50ff12b038e1307f4ef83616374333fa353aaf632637e51c58589eae7943f7992cd98b4a4056bbb2bbb278b15be1dd2098497574e9139ac257bd2485be19dddd821eb3ee78bfe85d8f2210e0d6ce39eb612a113a062c637b953f6ca640359a65b4816677f128ce4b78d25d2faa015e343bcf30e298b719cf1642f1b54e4799ebb35a57e8912f20eab27fe4ab79634ce250c6d38cb48bddf0f05b543e0b96b6120d4e018e1645e3822370fb1bd74fa1737ebe94ed4f8bb18584aa60fc5e388f56d24294d994b3660838feaf3eddff3342f193fb3794cfbb86b572dafc0aa34ec7cdd8321a0ad390e376fb7cf3d2a0b4818831ba7d8129717f4912a3721be53683986706b634271286c0f5d9323fa63d75fecc2f621aa8699cf3bd6f9a8ebbbca8ef786a7217d83222c46cb4df8b58e5a262283d102f52d607051a7e738845d2ac9d061829f7f35d6088adbf4e9b1ecced5c2478550c928e01d0fe65deadd7918eaffc81dc1b38583797a1ef99b36120c50a64b9421c9792da96ea6c090cd7c627f2c00908f2265757c83fdcc0a6dba3dfcd2ad212c346f104584dc023c44ebdf6cae9304bedc2ad021c687014048d2900a6def1c28c03bccc33996f66389ea315d59afd21298e0dbc59589b523d861b2cf834426675f02a23d72138de77f716e6f81d4e14f3b99f0a958de7cbfb3f8da45e78cacfe84287feafd415abf5266b184645de4c77c7fb6b3c78633163a031bd3eded94ca23c94ec6deb681308cf5f6e7caa9e917d6a8e31d3b326f80ceb046b296095bf039984da2ffb5aeff1dfad95cb602b536e87be87db432001c8e57748d655a36c1c22d4ebbf08ea275bbaeeeabf89d44bc0bdcd43fb163a397cf94f581822644400905b48d2b11ced56d94aff53689c00d28e635c71cb7e1dcd39bab92b703b815d88bcdc3a1d3a8712e800f151c333e3fc47f50c56ef95d296a2a50eeea5434a7f18216178713fd274290bf02cd405d1838a2a37702f46cee7cc56a095864a1a08754474b68adbfe9b9bdd65fe21762390db9ca35ed9dc6a205f68418f2c4f03b6cd18fdb2aea381070893c938b50b534bf6e811fdeea68fe5676ab85187c1053d7ae0fdc78ee70beaac65dc0bf1a915016ea0f8df48dc285374a626c82ce156939c7ee99f8ec1c714e07ab97803065b4c425231da61d843a04e9e10d6a30391aa5737fa89ee02e8db753510ddbddad83472f95ac87bb4ca7618c5cf14632c668cfb30a6ff6905e0229dbfc08d9e5eca26904d76b58c7b097859a983e1e7052f7848cfcf520921c5d0ef72eda6323f2d4d2a50e0f9bca9b02669b3c6fcf22b36a2a1c66390145f5460a10dca67c0926e76a7d23c0e2119bcbefc3af61b990ab8940b99902adfb388d292d1e2d14047d8d2500a857c5b94a697e3278a8d3c731872e8097ba5b733325f3aa002d641da724a78c95a5c4cfdfb2dfe9ff1ec47a70a9f48da8df40ae931953da97080a0ad6c6e394bd7b40d9782b7e3ec9a4fbf800096a5b7322bf2118be729c85c8d0106b453f550f1aedea1e7cbbf35eb527ae1646324a80fd8319deea795ec4aa8abffadcbcd94adc2c8cd0b4673c272b30e79df2a6afb86a77e0c3a0d77d971e634791220bfee2b768b71fc4166166f126ebb96c36fca00c25ef229a21a211265d24009f68d33c77f1e22bb52c6d4908f1253a21310dbd91bc97011f0793542a0702f1a2318a5c0b3563c91111aee1b1c24544309b9e32be0d1dc6bda372152a1904622377c20617d08ac0ad7db3dd864850091907e30cd5af13730151965b7de5d97d23a7dad8dffc8ee75d724ea0c84e69279e2a1447088b37e6b8a7c211e2c2fa1df2bf9cd5e45ac8b65b9c3ac35856e1d7e3f17afcc77a47ff4dc38e15843fc5a123298ca66b1a69a54763b06171f2bcc018c756aeea0947d4055651cf983be50b5525c40fc743b0c3560e47b18396593714b4b1c2018a33cdd5ec92aae69500ddf55b47b43239f30dfc9b9082745fb08d79537ffb9e994f54116c070c7efcb69c417a33f2f5b44d79f93500062b685bc2722be10756f5ca23f089f1523a1c20362fee9dfd7fa9de268c406c7ed8b382b9e86cb11af6e21b9f9fdc275477de7803364185a0f3210d8adbd5c58b142a466b5cdf6ae67f8fbcae9f976adf469588ce0baf8520ac9bca7c1c281dacd8a517d47efe88d6d193398f65415d9c0bf0782fb78c645ef74e07ced8fd95c2ce10d7c44030751b0e2be3ee0c6444f5f4ef3ccca5f7a58e0fb38de54db4b426ac11c07f2e2700b265e701e12202711e26ad813b90bcde4c71dbc5629b1a5cd39ede9b552c064768ab8892b45e2fb7ad8445b7d0a4bb48afc2c6ea6058866243b3673d068add92e252954508a3b92d91fe3840e3e02dd899be93e09feba85a6aa110e39785576ffa5c3e4e6f6cd6cfef400a727a392d2a5ad2deda36d2dd1d23f8bc9851fa886cd80ce812407905af00e46d394ab6aa2f4f32588cc3850ea7581443bc54b187dd998c6ce0e1c5b2b1a94cb78fd47d4eecdebbe1b39f06380bd4bd1422b013ab25dc76ae4e99882443988e854096ad0d2e306c115073f45c09026debce781b8b7984a10980c1e53b5308fb7dfcf1d09aefd2f5438baa7728450bb62b960e107cb1fdd6b62c2a9b27d0cbcf558b383a156cab2724d3867a7dfc0bd35f634b9d391c1898ca241505e3f7028e38436649f713b794516856a3eb59cd439f5b081f1f7366b0ff21d5e5d6243267a5be5a8a89f86bea93e77263e6a07e7a5dcaaa489a0e63e8c83750cc5ca0649066c0d9db234041c88f72e1cc9a5553ce6eed2acc5e785766ae00ac70c9f0d3bfbc1b0730be2e9594654c494c8ef048ae58328fe73ce2b4f79665b1ba39e134c934e29ab5d1322adfce9c654ed9ba7b34e159204baa0603a23610c236d797831ec82f2a30d3640cba5a717f100d473c45c84a28c7e9dd291b71e8eb68fd7033ca8bf7b3bd4ef18b4d0f72fcdb070a6e82e6b79c25fd53187228555a628a3a0c9fa56e077131baf988a79859d76dd7d60f6f41384cd28ea96541ad15573070c3846c2935cc1f59aa0a36014e27fdaa951d8985d87261c8864d80c959d699c6ed07577d0a4c0990774794261004346be2a85725a826b4fe55b19a33973e2d020253719d85b4b59df00cdf7ce1b117e95e67dd1c45f68d25f9cc2f5fd4c2dcf03edce911a40143bd2b932f6c09731d13a6c4184d8e8e1aaaf3b7d1bfb3878d8030d4a31c0b4d69563d33c338fa9e8587e146e1f94b50aa81af299184e118816c479f64e431632133ad6b786a6e29effbe561200b3f33c02b8cac642aa8b4b3f157662e2a8c40b777133a5418ee3e4d140006b150e14a7ad056411dbf7b0a0dcaf2fa324046fc20e6ca8fdcec5386a01779c87fca53624158fca0ff02216ec4ce838b14d086ebf6d61df4f811e02ae44969c297b2b6078c90a9dbc94e6f194fdcb0ad0eb901d896a658b75e95a7dfce7b4f50d79a9a84dd7805e75199c538f6d912ed2fbda7be3cf0bba3d7c29a4f879cf50f964ff0837aaee9b743baebdcf62db2c8a3dd307136c480404b2c9069f28d47e5f67679e945cb1aca260f9fe2b34b3aba41ef8abf77eb3fe4f7ad61d94325c4ee6586da1fdc96e8e698427fb43d42ab5dc5389e6befe47aee363b03608b970d4001d1b697fcaad4eb94b1a777022c6439be107c64a7d45255dc7bd9b5ae9770aa8be4f8c35ab9e5bf82e3b76b04b12f1fc58a248b47f83f3a075f7b55e9daa67be456f4f4415cff3dd9192b6e5bcde37674f5ec2cd5e16448af93c7dc3dc68367911bd162cc1f7974c2b1525ce9a8ebe2b93f3eedf21fdcdbc8fe0c754520b6e572cf45dd98eab36e4026f71a974db92f4a0c97570f06f0a9d058e35faf01f94041c51e8bc589373470a19bbb3dbcfdfb08144046b5f46f9c8f73d934475a70793ebacfe02a1221dcd0a428ec28f2185e6bd7b9350dd3fd8ecd08c775a581a3c874b9b75543190b8467fa87be164ac3a14617e6e97ef452ee3e49e93856d5b792d92af50120c97bf78ae24878e8957c1c231dd4d320c28bcaff4a9cb7e30ddee6e1f9365eb5636310b722d0e571cdd191fa4239192717775a8897e0c086789b7d8adac5d4b5f0387ee0c9ba0d73a80d8012efc66f84bb3c6e8fb74ad666d340d97dcd3ad2f54c280d4abeed5ebb6e1c022828d061a3865e767619abf5eb9101dac8c9465f001d858cd0f69197b783a4082053a60f4073b5a2e604e239441b14ae31f3aa21271c5faf66fd745c9c6b533f466034261cd5c4196bd5c042313fb73bf7790f80e570b81b76f72aa426efdc39a881103e482e57cb18d78e261a4771f6a81d2981815840f7284b14384d9b9211014444fd15c3a0d9607bd20d7d75d7e2bb94e3f46d47c4e00fa0aca50855899a3f00b06b539f536df32c617ebc978dc83e3fe398bc6c01217c8c0c894bd260ebd753fecb0923b60cbafd07feb8e7811554178330f3e480e9647be7a2b977e9d22e28b775eea5496d0d87d3be3cf284a395bd50a1c82bb4f24b3a3f3b14ed403a3a4b7b003f4fd1e6ec0a80bbbaf37be002a8c8cd4dbaa5a2601cecae33c33cd6a6f2136d0bb508fc4127a088e881909b83cb006bed5e07acc1d4ef8d7352df2caedfa65eac921413995d0eefb5141ee32c2ad6f7c9656e0aa60e1d3e7157639a72c78eecaca76f2ee08e0732fe52da8f0cd5d1d7d277e3f08bd9723011f1d51adf122e58950b2ef73f419f7fe0bcbdbaced424ddb0de88113730d8fa00230e8d8ce2b43e33e36481590075bd8c68361911b8090e09375410519f4dfef48c60ab0d845c612f0a1181ebb81cf49b746875cd8c4de94b71b91d8dc5f3f01177b3bcec73d81e95f0f05f21eb559f0fab87bbc42f9106610d049161d9c8555a42a0e9bed29fa92c58c47f69d2eb4e7c3695deda1ce0962b0a48977c0c5acedd7a44ad7ddc8760cea3ebec45850b1cef5270310a1d56ec55c65cd5b58a0079b955581fbefa8b31de7bbb9dd549024a206ac1cf60e5a595e9e782ca23340e01250a238ae631747b24794bc05c3c795d90634cfa57829fe0cc828018ce2027bd441840d03868d00d3286b49decece7ca72823cf2f80824702c4e819defd689b89c8cd59cc53c6c54c30d822aa17fbe777b044ed557ce1fb28dbc0dc61237a0f796cc077db2540b03528de8862b1d66c3603c6d06203da186fbcb403b39016e0023008607097ff086659386ffe1bd9f2dc9d2c3012eb482d1662279ee0327632bbf61db0480f5545ffa9363855488c1c84afe824f54302c89859beeec7521c045b9c96378e66f2084b5d9ea2737fa7e7f01b13f6a1589c1eb5cf4f62ecd7ac9dabf30d0da1c311a0040918bfdac6ea3b2fd901e823bc08996eed8621637717a3dafbdb0ce566083a997950db531a1b08265ed6ece39649dabc4d710a0519ff10912fc2b44d16e559d6b4e1f59f78245bb1c1a5c526473f7734deeda0cbdd1b99ecdcf7bb73b0b0ce604f279d61b4e86350584fc9948da23ce56a730ca488cd584f1f8c09744c5bd95791105aa3616f24a75863cd464f79cb764018afe57d0f4f81e6c92c9f9931c7252fe08918c494241b8a3ea2e48e923474ea7fe4cf5a00907220b7964420555efb96f70f8142f91654b416620e15b150d71ca8d82d6f7cc247836e98225969b32f48335ddda5f86fcade1e388d480b59773a6c7f89e08d42b19ad3e05b2f01b2f9ee1f7767dd51c04115cbc71dc3f4ca3fe370bfc0c7fc2a6feeecb0313354687087eb52cbc6e4621366956f2b7d806296a596e3745259baea1a613e4a766a2dfc98f78f98708c0cf8d9c7a7e24fcce0ab8d1ab59cdb81e0213ac4d40f304c891d64ef7994bca4ecd81dd35e2a8f3f31a8c6e4f74bec17c69d4d1db3a0937edb1a2c77c71eabad0eb4b61a2e27e1b90292b9cc8964b9249a77a76f191cff973bba56a206e070a1496df3b5ce2072edaf96d8ece174c7da98a175529167c42cdb30ff2164bc9513ec485a02fd4bd57663851ba6dd56b6dff4d2d8c5650a3e0c391e36ecdaf9f76e72737c2bc46da82491f9007d65b08d0f42aeb4fa8b7eb9ad26baa8b17b9d995c57cad30be4e1882a7057ddd7345da891f6e191f461e4654a89af9e1271cac32e266c51aa13b51405d61a4ddff90cff3961f3b47a75391eda567299541266273aa91b4d020be5abfbf31f35eee9e425c21f494ad715c2e4016c08f6c9928dc84559658b72e16574375364c00449ad40e1a0c609692c3b10d08ca2353aee27a0c718cf1b59c4521c73fd9ee62fc2f419bf21664d072d54565fd4a24c2b023c7798a7343d98b025a810d32706ef7303c7d326055da28155d523a353050826806e315a7615a8b8f079b005f313753ce37db3e7166283bbe61c87109802f73419a64305fcda0a5dabed89fd2d2cab8f28d480a99dd6874ab2fe3797d1268b5ff65ee142e164cc44aeebba86615e777dad483ee0dcfe34f10b1e63743d3022d905a8dc28bbe477202bd0a90d5cef2e88b2a8ab704b305cbc77f31814111643f43668c845e5335732ffaad13c47c784d6eff48d8d470d8c13e445f48f34937849c8e2324f87cc5fd35f6f77d05d94363e379d297736b404a3a174b4ea20f8835f916566961ce90cd828402f0796df10c8987f3be2c2deed2ba0e88a20424c2a820d0a4979f34cf7739c7734206d2e04523b44cf2fe2cfc09533da7cf4e239b5d9a6270807a99688f0b1e2319e481b2ac48168e6c580738a97ffc1143de6c6663b75512047bf46b194c84d0b6bbe2d26a5b3d706267ed0d70a378f097b971ca6bff3cea92b61ed42c8511b17595fe1e78a932c6be24275bebc08fca39b55cce25bfb704a94268dfb2df09820c0a02d39c39104c3aac5bff5025a9aa7193a735cb88d4ad6ebfcace45721797f07a626f54ee3b2c8dd2fcdf2c06a642d9b185bc35bab7e9d605e6ba1f0f6637c2e044d0d0e8b97593b52784f53dad24032146813f6fbb59373456600271fc59ed68de3b9e18598bb6455440553d90c10ae3bd4111b034df40e3b32ef8b1a5ef54a068b31221029cf66a3215c095d5746ecc8f10fc50ab7de26be1c8cef45f8f163cb4fdef7e648cc81cb81a876985b620423be750589d4da9ce326e8e1d87a6782dfa1a5ca7b4e5e1d0e863a766c2be496692d2f07b414d07c96ea7d15e101af7b11421be944b6c27d817c8086870fdd88fd7643cde77770479cb3750c78662db9990c0c5c321c90b2616e2d68f5f48f2232d05b40ce8b508b9eb72b7bd8cf555c18b0bcbbbec81fe17c0b5eae87fb5d49f97d2682f75b907347ef36b2a76494660253db61395b21a9d09ead7e0c7f2018f702176c43eb9b45d6edcb1d95dee7fda388912eec51afc17016b0a1b44fb0da59fba0c6d626c6c2820b87225b0a37863d631ccb0b7c62a61757adb1a1ab7f055464f46d645bd1ecc1ea6d373eae869c48fc462c34b589f91e639925486d2815db6161d4ea09c055a8f31ea234a68a0d689c9abd3b04d688420bf599e578e6869930ca73a8dc4b574f17fbee39f86048d945396bdd5061a62a321c739cde71b507df587e6d68ee18d4340f6ff3e1cf37234accefd76882d3481971d0d3c488637d3ef89a6d4cd7f4ef1273038ec3b8cae7b7c8df9b4be33f661c652827ecbfd1ecde7bc2a1aaa79840e03246d79dbe55d0a8f4329f752ad39ca21859d0d681c2dcc91b3b4c5707f1e070a755092fece426a3fbb08cb7bb623588e3e9ffd1a3b5156cff0c1cec5b4ac7cc431303046dba19a52eb44013d4335eb0bd58720786944dbe6aecab7d9e3d392256f1a9dad2bab79353cdd52b529443bc29efd944d9085169bb486739566f5a3cf5db56361c23a218612dbfb7d0fc11cd1f82a5c53366a35367dbf6bd48cc092a863590074e507ebec724d2c59cc6184f86d6c6e769619f4a68bab3dda1e74974809a5b6c7736e62fe4e4f792853b0cc4c0e59c25dcf3c5a2ea6cd8647e36d9255add61d084a910c00bdf4356741907891ef33196355ce11bb70be6fd043c8823681394fb87b2846258624cd4df194667e9207cbb1664c0d401b34ae3efa2cec60332b0320674554b350731a891c4ca7fafcc42a31619ed36f18ad088408fb4725d4d4da68e06755e6c6507b4aa7c86e0888e8b00bc44e63a09bed75bd8aaf5f7d1b75f752dd6fb52d400232c22f906c45cea5f2f5752368648b461c0a2252261bbebb861756cf530eb869cf71d2d96ab01a35da0ef3106f7c8554f3fa88c64c98dd62b8a4bcaa319c6aa6f029a7667f30421c055d785561750c91581d241b1435bb8eb6c78f22c06a0fc39cbce5d578d1c4dbe492421ce408db59ebe151daa5a85910533cf064fbd0999d6330dc0e638a3c42b42b8d22f77118cb45e3a213fabea16c6e5d3dde3463526d8104627b3883fc2393e143a1f5a1970b2e780b5f49ab01b453c96473eccd0529d2d3684c023c28578e700747ebe606c33e91e6bef5d1a536b925741106631322753b4feef7989585c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
