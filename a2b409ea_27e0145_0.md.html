<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9063e501ccc7d74d019efad5eb47250cab70d68901291dc7b41a6b6878f9bc96ba9d83fbd55e54ff3d41a7b0393d78752c266075dd8d6b31da71e59e7512b03336387dfcb262615e4a99db9932dc0b1e9495c3dad4db353070695f4a367fe04a22f911ff64be7586eeb4aa0da2e4158cad750f8dec550f7e8c06eb80a1ee3bbd652d0fbb8b04a486e9d1b6fdac4645157eade13130bb60c91228f53ce5cd07c3c72fa8f1acbd1b2f9615e5ee3ed431e45e0fc8d786d79e2a0ac7aaa55681248ceed4a673016fe50fdbaa8cd8bccdd23a3bf0c289b65afd68c62d992d0c230e86d25bbaeb69a577a05aaabcbcf146f7e8a45134abc8b2a2537073d5b2096f5e0395170762b94ad4657df0490fc7ba04564c6cd4755d56e538dd81faf6125d944e055bfe1c9f03ad5b55df803c18112f541c0c0925512fff78159864faa28866cc9295d382e2281d0dfce50bf939e25d57675263cb75baff8f5078889847b2e9992ea6bfe3a2824ba0cf354ecacedac95ce05f35a4b3f5b03432d914c646574b8877ccd09372530a1af1da38060e332ce27ce4e28a9dd4bb3f6726240dc9db2f85215be93a0cd4bbf9bb9d42a3cdd77ed5e513585f59055716fc535c5fe782674bb6929dc0d65f7805a8623959678f66f787ebcb9b652ca683bd5eb5c714c81143f15346964b45056154550c045bb8fba7e69306f1118dc73c62ebe3d2105e307b5b25d736489b556b3a6bba1600b7edfcaa2375f09692227fac3f69aaf7a9bd8c8972d8b15b4da30bb5d317f74f2297964dff949737f949320d29cc55a39ca41b44d7ce938083fd571eda0c81578a65671d9a4e841c748a76c7802ad17265370fa06773811532436c3802cc57db83a936d32e22ac1d21a1a18aed74af0a304a3112162f5503c0cf251b31161c12517e37cdb781f4aca97436edb20a612309405671e4c639974198952e7a4bc13089ca923bdcaa67d1c0221a3b9cb3b66c6be93a0a56357dbef4382076826c2dfc5eb58ceffc02eaf53dbd977c77b54413aa549d614d64945b60473be2467ecfa0c8d3efc8da299580f99c7079754d36d9371e530bf5c9b9eb860240706f254145032cb3fd019bb11f29e9721461fbda8dbf47ffcb4d5c774c76634184aada8ed77046b12465bac7e3bfb50a35f7c8eec114f5a4135d39201121610d977fabba537b1f8a22115977cd6625b7c181bb0fb560929fcac42afffaad181be6869aa76df2c936f049d7ce1ea15580c1a3c6d8bd6128b97f447802c4a77ead993ecc0f99401bf4fef8751ddb9cd447581c6e65f2e3e7c5574c0cfa3a0d176cbf2a91eedb529c75dd7a1ce31d960932b580ff22c339273151360c813138d8308a13fece5d1690a83100211f0a5801c9d90892df388b7f56f5aa788c014d5ea26a2843d230fc2224a60b5738333ad29a95e17205d04233fb48886ad87fea093f2c68a38138633501603c68689710e8da47ab2f20018b618100c5d9400942c45748c15e74f18d2ce6bccdd1e9bf74bc840547b5a8b5b74ba566b35852453771b7ab5b3eb9083025d4d80b4501aac9f3b8832a29b1af895da8917a217f774bc588f60c611962730d5fcee4a4e5f92296faef6507867265ffa503dd24408040d014512bf21c6443d92be84ce013b42d0a59e3617a5e0690209e9c0195a95b6c5fbe4dbdddf7d6ef33bba7c7960113898a141ef670489cb6db1cdede97f10c72bc51ed1594580b1c6e89ea8e6a58381b7c60c797a89eb938076e4dea1cfc5debd4a2ba648adfd09e5ec6c2334eba2525812c23755c859d6235688907a96a05545d9e5c50b35bfbd7bc102accb421b058237db95c1287f3d383cb1dd4f8a6f3e9f3436b8d703985c9d00ec2ef3b27dc3af44ad05ad0565de6cf85877a5ec421cd5865b058bfe53673957b8230cb62902aae5bcfb4c8e3f8fa5c180a84a1606c92d362b4130f3bf1b3ed904e3c06fb42035732a9342d33649537e67dea10c2cd0414ade553013663172e89549d1be990d89b326890dc577ec4b2f495a2e45c57a5a6258144a0f62139b6751dd36613138c5e3608312c9d200694c098a102962f0cb6f09f559a4f8849a3e733f41ca8ee819dcb53871dfd05faf9a18191553d2e0617af8bbc40e555374a3ab3a197968c55aae53ce9cc031fe87a02b1171c3580d42e45043f2df017ac764f93d05e8c17131d2a8c616a6ce019128e3bc47dcf52258d66c06d6ef0446865e1420ac7c10ba5b38e0aa5cfe8e9c55541453b178eb2a4807aaf640788817d4635914ff4ef9765f003c0701b21d905d026ddd6cc53e4d3aea882ec36a846b52af3ef92c2760b46e9048039bee8816a19de14d897a5a3d06e5d3762f6888de64637d6e887ab8e073c7f1fcc2b9e568ebf2520ac5f274176fd62047e0a8b12c429b2c9fdcda0315aea138c2309a12fba2b82fe54220ca1aa63afe210309e07e462d4b4dde69c35eaf24a907c64a73af547299133dfe2b53a622c7410a7b8e55449ffb73ffe99f61a5e2320c2615648568865e3694b762f5f05d52108a547cbd1f8addabeb8561d57760954c0a1e6b2a9da57f6310a9b407d0c0a03a8c830e7650839a75e9c2d11ba03f02e3fbc4455e691f25b85e020a831e0a8795aa381312b458f4e3e3559ca917ddfb71ef47e1c8c53f25598441274c178e556f2de4ad103ffbfc4a88e77f8ec2f7abd42a4e0631eb0f06712078670eab5e63ec9783104b0497b3d3c1928d6b4aa14cff94633f5ec5117531f8963d482ba9fc9756983cc66bc19ad87afebbc7e8f210d2a00c7988dafc9102de78316cda04c81f9c461d95f4ca9b4e8af082b796298c9eece1855e74c9ed0daec1d9582fbb8c8f6293c0f1861ddb8901f7d1834ee10b9b5c721e0d6aa98bdbdcd8b7b9a926eb6ddbbf251e83c9feeabd519c755b00746251d42a82d059ea59e2e89b79b9a5378c82f85044c89e7daa4c6a384b6225b2d15707b0b5083bbd982160fe7a53fb751fc0b7d7de9dd72e63f12ef0c05bc455b723c1411d5ced43256b860a65e7176c978761707374621082840c38225c434af8614b01bc956e2bee93ea4114e2966263e82910ab95c00c07b59347a53b89c9289a5a88208f58313293ed765ecb198bc1d59e77928020da183ee1fc828038b0a3afae55d06fc96ecca94e29857a6888593aa4759c38de7200c82381f98f93c49faffe6141abf9e45daa983e64cfc63192d5f6adeedd6ffe585b95b8636ce29419d72c3e30f5d5647fff8bd7a76752512135f1405b6493363a9d8fecc03c01e58768a9ce8606502f4ac751e57cdacfacbb93761907742cb65488fca9834864a2487b3e68fd290e1a4efa815e8dc503bb7fc4dcc9d610949b1154138f4ffea851e93aad0e5f740a1450c71e6341e6727b1e8f00241e6a849f90d4b5eb880f27c251852b20730d8eb39ce2ced86cb6f0668221bc6524bd47e5da85a1fdd7a3ddae087f9d3dd335345f0e12a8eeb1689fdd2cf7697b4eabf8fff7ba1a593c85262fe7a72ea7f941d1c319d248e8eeb64cf07e4f02b245bd1cda4ab090ace5f7896a701c4455974a7c7d17e2717f3ae1e59dec6e661d2ecb9d445c670c35264965415f1576151268bff4e5e25009c1f3d8211c554165e96e6464181916b9d0f1d313634ab17b27e529cc70960e6e74c6238a7c803ac3bc611046a3756801eef76bd89c53eff4b67bfa4e5bf48d823e79b43d1c4a1d11034a1a3f1b49d5376a8b91f95b20ccee19fbdf808d2b5ce08267051dde5c6f0c8a669234b639a7ca2fec5265d860706fd4da4bf64c8a93c33071fd746af790cb1b2087fcf2b898a83531ef6e51d3302acfa4aea1ca55267c40c65e7db2be3581db5cae8c4c9b704f7c08af6bf1144fc72dbd63845fd36351ce4d3d2440662986d71dadcf2dd65e9719c2408c4bb8896ed777622757a49531d6d27422a51126aee5fa60f36a3877a2c189a0d09755c76aea00b33b6566c48e1860c2e382717ea334eb406dad422b6470d212006eb2fcedf197efd2a394f07541ec347a5d3771b1578b144e6578ab96800c022e1c4caf5c4105035f997a4ad002f7c34458678fa455fae596628ea66e946be0327f86b12261b1c04359866b74c978ac165985a7c1c238b4418373d50599a1b0ab9e4871e97df4108dc585cc0b6b3adb36c7c861f49a067af64f41ea21d397e212e9c24fa3621b79bba69a3b9fb7ac3ea2b4e0569f0bc902e8c043477804387de035330a3e1ac3fcb1ebe152ddb52b3ad4c6895ad03c626c26de8b5cfe33625b2f04eef5ec5f08d2a12468e2f97fdecf63473f99623e8efd2fa92bebff3dd376c617d2766676304aaa56c7459c74fafb3eb02157029e7b9973a334a5c93c46780a8e537701487e451a85fa28b5d7158df5ea22e94ad0ba2dd7bc95a293c8de6177de5ae8e606caaa69d50d8e140edef45edae613a7913ac7a27a61da136d2b4ac46fd2cee557dbafec921017ccc4f52ae19bb1f8bdc2033cd25e68abf39b0839c6d8a2eb883495105a81a073e43d2e615b54f3bddc1171c71b38f28ceafa16582296f935d767d7088adc8948dd34dec7a2b0b7bddd37a62d35d108e91aa029d8b4075ae7319d695a5d4f28f4e1acee7bdf743273e1d8bc9840d11712d4a8486664854a58b8d4c7ccc36ab134e402c87cf315e57cd408840536b6b97350a30fabe5a1c5d605d0909b33f0d96cebb033d5caeae6837155abb5dd0664154342e05d542322d07068538576c6b7c4c6b8d5ce8c001d85bd985177ce47182e110a8e82fb98df3e58648b295cd9cf60523dc0cdb7754ac51069373a64f71a33bdc808b0c9dc93e2a3a9d47127d2ed018f28e202a0ac4436cce7616c589bb4886438dd5b84730983feb1ac8344fb4c74b6a0483ac410c4ecc905af902d5a09edcc07595b172308e1b0f32568f3e193ea2a5acfe6619d5cfe945ad6ec417af73eed9ef79ff442dddcf5901a72e0a1db5aa79943da4b5c35648fd9c03dba459560b116ade69789358d713fd6d5eacceae3b3f7667b6c4889431c70d3bd9ac1223f5c8647aa4f8d85066acfacf401f9dddaf4f0f7054111df45a46a33127c03579e5a09eb15c8a7f5d5f0e09034991cc68f29b03e489d2d2bfb7c485ad49e8cd6480bd029eeeadf7c286cd62c96720a1206109308304c4ab2912d671650508a3c50428496a1d29a916312499a2ed98a280c1a07adbd5cec47ab760336af18fef8e3d847fd2da697503488a300b1198c6da001dcd32741690d6fd8faa7a22913a320da4758a615619c3b24d65a7d408258bab1bc1d0d2b3272a249858f712968cff28b1c172414e8f418c7fbcf741b49e9acd8a0a3ca7c80fe929295a7bacffbf87f4df908d51f72be004cda5ad1c3ecb2e72362d94eabc1b8aad0e72f17b6ba8001e2b01b0eabfddb3bafa64469615f4837f7feb872982d70babac312be07be8e4455e8be7df6a59de2cf5dbcce31c1dd75b7f70f032b29466886ad4ebba0b42c914ac0c11aa9288f34d8048390e908a8264bf99bdd30117c8fe05edebce6120e226ba0c2516ae421ddfd2e7be9338791b34f87b529ba37abbf1b2e0e5dcee99139143ca0285bd74a0a5379e2703f3e3986e45fbd4c547981f77a3656024fc1958a84d5236772aed18bd8cbd8b7723df9d29d2f9b267c2ef162a3c7715fcea12f8135fd6d5b0f69345abb474597b2e297ef06a0074a4d2e21f54c88035b8d3c117f5aa102315e74bd588f1403efd0381851cc962c898adbc0cf4e2a9a53a61bfd19d515e940a1022bc85cd44b887160fc30d0f0b77fa3a12a7dc9824b3fccb9a5abb7457b639f2ecc74328460729b2d399c6f4a64d04bcd10648e3509dd519d6ecfb8d8938203821f846020d6dcd9d644073bc2ff49be1607bee3cca3416d889a22d6bfbf4a8cbff37aed24ac0a26260fa5f6e3e66a07f7862d7bd081e771947dfb433dc15b301981e7e5860eba4a5db3da8ef809efc7aad95d848c6a52a761151466b309a7a4c97d27b7d2da03ae7e788e03f8e2d1d0d8cfbc074100211dd8e032eb55df4166b41f5f43de94b8f8a35e495936dd73e00ea812ea5531d372df1307007690ebfb31e78c7dce53cde499bea13fcdf4e8848d3a0d29056bfcc66ab77a2a3692dbbe6e07242c140014848f1e40628766fcea934cda238acc0837ea767c5e0bff0533883447b17511d895e5f3084972b01c2f5c71378de0f772e20f2fa896de86d987c8ccfe8c29737cf449656f7f925d4221a24d612344650412d461e59cd0bae9161c48581b8cef08f7f09beed60a2f6c518010d1cbddb3fcc173abcc71f8d6ee636952ba5d143744a48e9501c5cec6aa4544e32be3af33fdc74d0ce96a7651b1e65bce08ecd916f3859f79ebdeec1656133db02c9faf9e6a26dde9330f2e6e14efd6cde02e256a7d1c2be41cd1eeafc091943022e33bc41fbfe7e8e693363c0679cf20e934adbf29eb99c530d8c18bdd6f0fce4f9653d09de273469c0fcd49021df7966becce4de7e3500d4d21ad309a56d8988c595814f952f07492b9152604d99eac76d92d0c437ba25b9e4edec9b0f5f20e1d9935ae1fb4f31eb9e8ea9625cd95466c9fc5c29af016315a094925af4e9c7254f06b431db1b0ca6e76458f9f4e1a1968089fe94f0da0e2f18e967c159a02af562fdd767389d5d733f3d22ce5637a8d4ad2928fc64ada4f7354635ebf6f04ca8797e798285701409e354767f8c6bacbae93c56406bd0c671a412778fa8278ed71338fb75230f0a8c7ad5681e3a39d8368f17400984f01d78710e58b209fe0842c6c8854e65036333ae6471cfc0e81a488fde5496cb77a317a001f23e91e8cb44e14d3beb612cb388db3b6a360ad546f5f4014a3da9e5b528a5ed5142c31a9c361a299a2c7bb3fd957d2938a760a8f53df915ba367db288bb16b51bf0b3bbce0f253d00ca514bce89f2d4f9c5a796043ce9b1ecbe27d29f9691d96baee74f2a2346bdc38d4899c827a18a97829ba2cdc9af4e59336230bf117e0cf5b844928a579cb78d7ea6dda82bdd83094943cc3ab801d6bbc4a2f7b4373e9f50c5ca7d257c96a9f4abb9712dc7762776e5610a1679e0eee2df8dad440e9491e1d3e002f70bab889a257ad6a31f2ce60468050e80d11cf4109b6bbebed2a8fa370e38371b6958e623ae501e5eebf3dcfdef72fa1520d6e8f7e53d240151afa36a191c2b89a8c3bcecd8854576250fe56b567b5fe6799a57502526f949397e259c8e0b51b4f532b43c8cbddcde175c3e7423ad53f5c52877b6916f8c028e88246ad8b8a6874a9f771cfd507cd77f93dad7e15fb0e23f2c46cc9a00a164b6f8dcf9ce15783a6b6ae725f8cc3a3ee4bd6b9eef4674d2fdbd316bc97518851433f6c194acae35c8ccc25200f071598b2f04d44914a7d2b97f84a383d730a55d6028929f01958dc8a127ff7731339f0f3a5c5951fe54a4bca9697014c2809cd71ebaf0f43916acb2a36f8f9ad5cbe2bcbefc04cd2aef4d780631ed41c240f06668fda0f4379d1560c508baad693b67ae2b221354480140414b6bcbb1d40bea2856ce32e116eb6e53aeffd5a95b740403ee5b3d4d64db792956a6f2347d44b2a5ad4e6e6e1edcf8093108a6efac782570bd4cce7d145dd9c8a641713cf856528343c97db60dc37b09a7df0e07570a56d48deab54ae495229a26a9e995b99e7fefbda12287cd4a1deb0c7325a519219c23269e08de664168ffc150d61029cce826516e44f8a4d11e75a69ce98e81ee9498e85cbd9a8a805a6eaefe0afdd6e423716290beebb3a514512eb65c80b92f67ea1f92b2af58fbbe39156141c52932ca2c44130555b0b79811ad0758a193c8dfc9d4b46bf911f05714b3045e3c4feef0453989e20776a1abb4f3b5e6b6445ce166bd8694072116debfb7e0f669128cf5f5a67878ec61c2e9e89331a48c9c3f1554fff4160f5a391b148652bfe1a4cb77f2c3954ddbe3cea7183e7c501297b1531bd1538ee7fcd80beddae6d1d6648cd13b7bae4e356d11281be2e71e2163c8490770cdd9b00d14c95a5cf05d2d41b3b64c0a42ce2a708f0a2ed95a4ef70e5c9a6677215f217403bb5a029e25f98ca80fd669b20219c11df61c633724a650a2236010965178e4c4f25e3c97a3f630820c4c2982184ea4e6a4d1299ed472e4863370595bf9c97d2bb7c65244fb2fe3f0fe2051183c5843d5c4d0fcb5db1fea186c8b4d25ec3b59d7ade1796f4c5aef8f1f5e172e2e1b90f3f8ca7d2968477aca96b1379d0d9ab75a86e14280faddce941822bc11b7c08ee8047da10e5d462211379a8e23313d3972d87c1426e8a0bbdc558f3a31c17ca685055aab46aed7f101fa48d932a6bfc369c6d61722aca65985160b119e04fe36a0bd64bdf7a1ef4f65ec0ac550cc52ea3518754b22c1d565ece3aa75456d2aa6021fc5c8d6f80f9e81f784db7d1d316570d835c81c72eb3c62cbe0690625d380fc67110a1456efd19368c9edbbed471141b8b89af71ba7f47cea82f3cfdc97ec62b50b9cc39aa3ab833824e7c7a1dcc31b5740ff07eead7c2551b97f3e977edac86a933c82583e0b0dd781359d8f8775992bb2322450edd5a9153f861486904212e472207df466947be7ab56732f361421736e34e8cd50252f2123c020bf7d2d8ce3f99810b1455e800f08c770ef0f6b771d31bd0362181eaa8a91737a9efa44a4aef77593f279c30e21fbe6e5e1fb979a253d56546edcd550e6545075cb4d574ea812ed6e792a094156a9f2635c29dd8a866e403f7809d82ab0375e4c2fefdd6149ad6dcbaa78653e68a90a130f15e63ef6e27a21ea50c6cf62d1f5fbea9ff6982b10d7f6ad49a564bd83f63963706017af26659de28011bf13aac3d5c367802e612d6349c119ac30e796452fe61949edf905e7187ee18885239b68f443fa9444e00d28c1c427e3b62349d65443db65ce9d088d839e33e19554ad1e0be1b49a873df54e4dc9996cc8e2e2c81c8d3fd7819ed8c7849980d27499ca8ef516d97275b3cd077981900642880438735af215e965c84a9a6a3635bf1290556e23749da036493d252d9ee36bbd01bc774498519431cbe151e43b3b646c4576db8e658048bc1476a6266da5a4a71514560fcbc119006e1c15cfcd115e5b601b568388f74d43802b5b535287837b955f1f4a160d0716812bbba03ad657940659e320305425a937d8e1ff3f7f53b098c2c00dcd0da38c9d8faae75ef2bbd278e9492d21bc1dc66d26dabb78116730a64325d2100ca2d16135de09dd50686ea310de3e3ed97465b96bb2c0692eb9522d1ae93f5ef60923516b0f37d25421d3e5922599976d9d39c6da992f6e65953796b736fde4ddc06cb975787bc0f760d1e8b953d1b309e81bb19527bd54ebeb473a9608489f04d8fbcab2106f6d6037ee0340d775ca090275c620e4c765ee09978ac5ff76051cd13c818534a962307b04940de796dd2478863905b358fc02b92b17e0201c466807d99d73f63883dd3bfa2a59982f706a9ef3909aad0ad2b55cdf51a99a539c7c04d1ee87454d25acf022892ae81be484e4b550811ec3d219f205b18581f5ec1d8fdf8f524fde209697337eea210e102a3645c3eaef2e6eabe7353cde05f1309c2a5e197ea650f672ffa013de90b3dbdf9894fdf31da7b62d4ed1038216c629fc33792165ef0686c5a2740cff07d020d60fddfd22dc54e7f68c0996e809b95e0e1b657c04c4d9f2cf4729d3e0b9f1214f23604911d29a9b467570d9e7a21a00b1bd87460ceff291d360c7797af06804e18418e75fb3db52e78682dbfcf3cb30f5ffd6ee8c90bcd2f08c249edaedb654fe061b7dff21c1f823a6bfdf5c9b93f0a7c9a83165ed0c958560e93b3c31ebf58e7398e2e67b0889cb53ee2d36b5df1d02933ca3dfe5e7cdf6693805ccacc093c1637eeebad297118399856667c6005fb186cf4c80f11585fc284ecf3dd71029893fe0e36edef549b363fd32f774a3d84d6162d56cfd740f2689b87954aab45076bd5528186cab367b96d3d785487069145bb5887589df350e5ea39cc2f6baf309e3bcf609cb2ea469355d82ce075487e7e34f60986343a55f4c21d7fef0fff55cb11db6453c2d4f8f0a6614f71d53fad0502fee10e4137f088866627db83dc88d3ea666831ad1f46154f11fac667ff4654ee057e4ccf5944a9f71e96ed50eae89669c08a3696d7018c7b0c201908204b84db5563dc80cc85689c6344cc5157c304774734e91f9e51d6b354ddd28ff9f45b87370e51e06c137c5e87001a1b7d09e5706ba537eedfcd807a0ef35e5c2235d12caa30079933aa4493215c33cb097c0ac515c3f77d234ef01941008724b6d93474d0134c74089130527edc7c7664bb7f2035486bb19702ee460f49c198f41cf4f7426d5380a35b3278514e6a6a41adfc2dea13d495a7edf696e37d58701104ca2b621eafc838627f0b4888333f27e920a0db4b75b2b3b8898b55433323940335a3908683c78abf22492a274f825c193d11cc6cb3cf0a1e2dc72c89fb22ab4ee820c37e0e72fd02427e751c832ad8e88b7b1f912fdeac6d2fe79fd59d39376b68e49f7d1888fbb66ca4c2d75b9177247c669aa3932269575de4ed7af428aba6b8ceb60ab1df5cc2ff704d5f6a85c7dfc50ca33d64d8f2797fdf8e630f508c333fb1d1e964657c63afb952aef56e8c5304e68eb19ae945868cd06bd411d1c7e09bd6fc93f3580073a9ef18715d9b7eeccd5130026bd4280b6b0fa69ebce1b5772ab9ef437b96d1db7105bf79bc988106212a93dc27b30e383548f7fab02f4e33858b573869d87e1211507cf90b59ad86c0afba11681263e6490678c570d9610d0d724bb29eb76d9abfd2656bf79f176dfe4659852e18e7249b32002b03a82f163518d66c721261124d4a3ac4a578cabaf442eb2ac29e9278e29dc2732ec0602cf5850fa942de725b107adc774fcb75cc45c5e7b37bfbb612731da34cd3049a315d4692e6c404b6bf9417d739fd352faf29d4ff4728965b831582a6a84de93caac178d6526937e0b375740e7d85f1e12b960285df39dcf31f85a2d84081e3a03d206a9a7b47731451892c991c469a55e22118f2b357571d5fc3bc8507a55893d23421e9b79f9a71b3a11ffa6ecb9328bd66dc68dbf8c50559cf4fff7064a1456fa7e39ba979630cf5e866d5b5c95974e083d75be68b79ba755238b4a95a98a2965a28c42d5c00f12949e5e622ddc5abb8e5fe06dbc0d04f449bd72255988f655b8f75e2f10165492b5f39e6da36b21f982b0547bf2dd172c31e0623006494ac3c17050bdb9fc32cd19f6b43e67afe69544485dc153a75886331957cd8687a1b564367f0a3d909d605c28923793f1f5004d6b3ce43ce5d4f430eff691f371dd6d22621fbbe713b0fbd3eca0645c387b567823575f597749a90552b45c0f70c9b978a1021bfc88a52803bb74c76a684371a5bcc50ae90a444457e81402dcb335d16d5a8d2cf3a5390fe2bb0dcba93bb678f278e6262380ab1c80b1728442075874cd4a0dc1f2a0f45023545819ac92dfae7b92858b75be4e5f13ecbe269ffb9876204eaa77072ce4d0e11becc8b8b749599c56b8a9e4509b86463aa149c32edde835315b20f3658fe2758ab263ee28b95b546803d2efff42407fbc308bcd8c789b40ca16fcdb345775bba8dc93d7f981361963f439ea5d2a1c852b4d6b2624978c55f8a72f2d593bc64cc38d03fbdad6c7d48ff1412dba3095d9130a068348b533b2646640476b38b5e8688f34cc527251259b043b94674c7571e763cc21724e1a90a2e605d734f1891d3c67e2868f7232c79b38b0a71c80d5dc38bf099c9ebb25eddc566a0c98290964d7a7464fffb078649ce7e0f295d20ef0f06f066485cd0095d2d70fef87e3a70fdb6d2e488e9516f8e736889adfac9babb6e20684b226f7fba8c1c81735502a4b0b5f305059851dd9adaaf9d910864fd4f4f3f4d645777269f102ba84c28bc72465efb061cff5886769246562e537bef77c44c7f9b095b25625d4213823eb3bf95fef1fe23368a49a414660c9d0f3f2bfe417793452307760c0f7e213d6d721255db6bf0a2b5e4f4de9f3420f3d4fb68f82aeeb74b40fc6f63bb40a78378feeca3be5fbf9a9aab643ee1e3e055fad8c4ea414121963768f5d20743505a0ba287c89d67690c04f7c9d0229290a3523011d2f360f91412075ffee3adea819251bcaccf6199faaed4ac0f66ebb7e6518cf5cc039acad45ec9722489c2109983e5a8e76094bf46ce106a46ac16bdc5b59579f7d4657cce7a4d0fed77dfefb5c3c82ee5fa26f3b36ed6c397df54567072350c8dc5870ca7a72ea092c52d4f65342ccc8c116ad7e8b9df5cf4a7396c461ca9472c9b14646b9d2c845084e0ee4552ac2c3eb2eebc5ef959f37c8ee06b9229bbcff57ff4a46126af43074a436ba9860110bb36d4acf6b486bbea5a0592f44073a27a2c61c59f37db507b3df42637b7b8472f54ca0574e89ba61d10579676c457d5c3c6cc345b5b21b8c06c9c96dbf6b75df2fd9c54250a2babc6529a215afcbe9a4be1df014fedad2f62317c3bfcf4d4cad6d92ebd6141e28cefa500891dba20eede9c898fa6fe9b58b27de099e6dddd7d328a6f45aae00f1759e6ee53dd2e4ac8d98a3404f0a4087beadd8584028d24cf0fa83a96ff3dc5ecb1f8030dc84a881b249a8116b7bac79e2c2e4fb40740d1bb1ef9c9973e397d02ddb51367644e1e1798a200e5f467fe9fc254314009a541ef90b6bb3bdf5b9672072b304324358271858b0aab28baf6ca22ef2108665703943609aaf83ce98b6b0b1fdfe82df8814c1fbed6f4b60a60c7d7fb90a90b7f6abe20954731db70a025c4d48492f6ee0ca021949dfb430e058e1207ff92b4d09a64222c7962e61c7cdc1ccaaa952a00c624a1212114441d2d54c481353b074ad7f4a97a664032f73c00df9341659a05edcb40a57f679405f21728d6c252d70efc4b8832f5b8f766ed6deaac4633a64d5ae8c32b920d77b8970c65d6f173375f304702f5191d78cb49425dffc739557c1bc1d5832185710ae658af3af777e3bdbf3ea03313464d4b2a927b7a8552b0b858beeadb2f0c5376ecd4cb3cded0a1490d11a69f64a387bb4c017360fca54b1d28ef25bc397acfb2f981faec1c94dc0423200561fbc7f75fc63785770f499ab66885e21f5935e36c2885a60bd77335b1e87216ea618bc909861bd8507dd302f9aedd3544eb233060d471154824c0f345e7c714bc74a911a740d1bca591aa927d37e0c2ec02721d1c05becd6631b153521f554f66646268140f4a0cf8285c089db998e5524e8f8b7e3cd05e1b1a191680adda2b0b9015efe0d3635188be03f1905b0e73d50ba00e55d8d903e4d79b3afe555ef0e6613559780f69c703edc233b3e90693c1cd33556af417ba862d435d7946faeab39833d0fd049a62b3808c7e67e61e767ffd091a1e7be6f1dcb148ff8816fe267694a080997208f3a61049f381d8285d9e8307d2c188954b6f2924d6463d539218b580bdfa8d11b60307d5bfdb6945f553300cc8aac75ed2e834f29493084ff628038a3d1b771bb0e1776358914ec69db222420f92c87c9579496042ca6cad0e197d7e0d9e0f0f0982cc8084715e4359267d3a0e81a301e09ec8a538073fc55bd015a232f98843344d85bb4c805b3322762f2b362efa7cd7c68b8f566d2c2dcdfa3460542b5717b4d8771118e3c37e720df85535e7c08608e415dae7fbf3e36ea56a412d11aaadca5d5924f24ca69a84d9dfe10d7c70dc93253d75ebee05a0196eefa6b9479a98387c53f15ee6758d798643adadf8354bb8d3733d4568a9d9e14ccb174780c5a6da58ed83e41734b4c6563546266a97093bd3e849c8be231f32234681acf85828309f2ab486e7f29a70131d52e3b84506b4b39a2068e309e52827a88a841187094d05cb2423046e62809bebdc6227b4360b3e1f359de4b8837af0d551c934740e01314d8e9d5b62fef2368e30ec0c85addc796fa3d25ec0bbe4c061b159e27edad28158af3b1a2cd12181530ea47eaf66dc036ed40048374a7acf068d99aab8b1e608b7445b63e865e6e8ce4a484767caf6358deebd68856eca4e45a79961295ea048561aea6e4f249165e7b99f2d4978d27f866167912818e1a883db41f82438d054e6abc7dbabf7fd3e88028b3e225b6b2b9bfa5a1bff87429d2cc6c91d1ceceb066dce40c53ad8e98452064815d711ca7c879b1e8bc94bd07a9ad77297ca0e30347e2939e63a70cb76d9a928e22adb480eac5e45d5a8eb1a738bfa84844c212772ce277596b01779a81211951049bb1bef3b8bb79c476a890a8661f46045c87848d67592c053dbb21499cee29b55742655ccc4a0e927884d7535ddb3a8e1688a4cdc5a68569a449085887b6cfec2ea190ff71149a184625fd350ef74d14055d775f70bf545658550d28e6854eba353dccf119c244719ea04fc3fa4d4fa52e0669436f52d17c5c77ead207a754719316aad857fddf52662c93399329a5c32192f4a03e8c3de96f499425fd99aea3f37c0a8ae3437d4672f907e68a02cc67e60631cd1d9444ca7e0bf5801e0f0c17efa7a18e7e8dd516c374764656d8149e0f8fdada86ef4a192cf262ec76d83c17550652dc6d8c2ac4cb24bac011f15d560221c25851afb60e57c52f9b849c6b71b0e9e0a44d83e5db52960adea5d7efd7075887da6c320fad93a473efe29b785a6ec2760585a01db156967435b54a551ba150060f9fd5be3049081a74f10c15f1d06ac5e2e76cdca1912254a214c7abfc12ef3905fc8dcc5205d4264a6e7c7e3015ddbcddeb51e2d8fc0d5ab05a4d05e1d825dbbde06e621b1ff74343fa1acd3f04a2bc06e6332857e7d8d3d3801ba83627650bbe2747c850726400dadc0cf30626135b2ae05d0819f37798c1ae4b46158c1fb04a3d8e1bdfc9d4079c969af1ceb20f38bf04821edb7008842533905ea243911e1f958ea7c854c228cc2950085f1703a3d39f8c126062a6709a76190e34b501d3eeed03518195834093a4bfcf86db99281013396b7708cffce649e9681a2e4d7c299f07500d99d22740fcb79b7db97f8f2534a9533396df2ed37bf2779498316229671a5f49b690da46219ff8fa582430ee88dead105813cbe46e5092be34f76b45fdfa50b327008fded822afba17de6d29904ad240c314d9cc604dbba768e195761c8be4c71b0e4e6f70a8e88d36bb475899aa3e17efcb18a1c69c42be21645ea40dbf692dbafe5b363a3b02c53adc20c000e5e3437a00b07af3b4f0c5b09d95ad02ea0f93dec3ee75812035f2e8c798ff23842f5a596f6edcef0568e5e0a2d734074a18adc8f0a61a4d29476cea2a40656bc848b25ac1dfc4c50529699f2ded203c2358c3ab256eb8a738761848ef6f9933a050cca4b192a9e3e0713bbc14534e61c66c84c3987a9b31aa46bb96347f8c4852504dbf273331e1a779cfa542265150d893bcd6cbfb3bd18579a1883856e0b49974297d92722182b44a99b7d894bfb23d1c671b33a36042b823104cfcf8448e19f1fa22d250840b4d4c66efa375cf5b13312040471f891928471d18417274937c9ad2be34a48534d1a7bd6f31cef7353588515a68c8352aaccd8df1c951ed26d6cd0d032a987d5473dc93f9948a5662f62de5a9a9913687567d7f27282e92b5627ad62d3e80c5f86220515153bc07f7b3a0d56f223b7847f1c04d48f6553e87746e0983522a9c78212ea5d57486aacf2b3b732a84fdc4104c0a499c3f2ce6b18abfa6d2c8cdd858cb18b685c21d3e83f0188bae4770ba0a3448acce7882ea2e8cc8d294a5b6d50035aaff24ac97e80318554f966c8b8d15de8b5235b407b8fbe5931ba63992d944492d25843fecf9481da1ea26e67c4a479c338015ef72b2ce96aba945d1a8ef727ec494e761a98970945ac224f7772da6d6eb4e0a98923c8aecd7f6c49c1a20a23579aba8bd579db2ba292057b2365fb5114577a9b815cd3a8c1cfb669d9a4c7af5058291c81923fcfe1f678d21805e649513826f3516001b59dc84671b8d71126ae3d85aa481e5f1140727ee964500e72ed4bf174dadb0cda29cc67356d6ecc0839a386ffae5f39d9994336f2eaa6cd9cc03599f78565583f0bded136afe7ce21d8154f56a3a1c3a19d2124da5962d290b376d5ef413be66a635149f33775091d022e4726f705d22731f3d4fd4721807ad6ec1f3a79b20db9d6c04a2f2e93232230ba9cdcdac277ba3375f4082728b10f8a628ab4161994a745a6ceaefbda1a760f97019627ebcd738c4818d6302c861e224024e728b07a61aac41ff445469e9613b6f24df6d12d59e60c60d79cd5913c7dad862d9c06fc42a3ab3171d8c0392ec904889fe742208492b0248aa93e7aed28d7676cb1ad9369b5b490087b038a7a91a97d434d08ac24f8c4355035c9ef0ee6acf3bbb7a59565ecdc71ece3ba75be4687b7532e7d1338999dd4bbe4386f7764c080b0fd744ddc84c5b46ac456d2f94829a252e282fdb423ad384ca7f52c3dd7413731e53802f538a34e70dfda4f55d92b54623c797f0b3928b90618ffebe8c57870dbfff1623bacc9dc083b4bafa1d677e4dcc8bd18dbc98f8b80a6a7e67f313f5b59d3bb55b16e578806a8b567ad805751e4df56bbe6addcc10fd3f739c916d7ed4b277af3603ee1c41586a0c6f594666f211dc59b2e57caed8b7419ac6386550d457890176f820548749886701edd0b56ef84b3d01a4252aa0c3398e2fa24a7e2c97dd339fd9df94164dfbe01fd71da2401311aaa99fe2dc7d88998ce3216b9001a29a2755736a2361bc5619a1cba9bf832d5027ceed7d0368b77107c7abe84402a5eb5b53ac54555eaf1fff88fd68e6842feabdde59e2239fa29450bacebe16c8d949b82fbc18d2d4bc36ad93a008b3399f8d742fe7510a9ada263c36ee9dec747b1296d7b15bf3342ad09c75b001202312fc752cefdd61e895849d800939890911e5df78a127c84347d14b577e83924c41ea6cda2ddb8633ac23ad4e971759c3dc9b691884d38172372a110669ca0e842b26efe0d0f64bea22500745af445338dad901890ba96faa0f29e311df6fdb44dcd11ee6189ab05061097e58b3141baea445fb7e8da4f1b351b3f8ed53f9161386cafcfe18e564fc38d32bc0f5b0cf6834bc56b3a5b1b871c53945a86833c25771acec979da6c20bebf6e771775258a432af3f9c70eb92eb86ddd756e5e63da45d7266ed356b957dbd73098d2847bb2ce380d5ab4abaa530a27caaf2f4180d4dd5a8a9995043a772df5fa44df00237f22f02b9fb5d12e8cbad62e27b40cac2a8f56c0893d726b2d3e6fb25552a1378db57af8c45da168fc120da6cb61984dc424c29e8fcc2125f76bc92cda6b797731aab7e08772e4b36ec702c2d49a5018ad6ce74aef67d95d8b6debe981b75a2e7b49525f9e09f876e09288f71142b8ce1282c8810a64476617e135b4e4a775f2a1397527c93e43350dd64de2e00ec5088e262b3ee424c6ed1e92d9d5d486a701ad6b9bf7083813838dd601e6484c40ca62813608e5a212016aa98a56ce23e36d221d1a5d03fd28e0f4f84e27c2e847c1ca7b742fb5561a5c23daf19af02b60950767166277b15dd70c4456ff7c27816f997615c64fe63bcdd5ccdc3c2289d35af05ce166db8fa1f78da5d504d1a63aecd886207093e629d15c53be720d886a000cbfa1b44bdd21ccccf2de2e83e4c250de26b8dcffcac1be4286936eb83dea85b90734a2d2964daff3abbe3db081355c3a5f27dcc6f6130f8b180767eef09f7abb741e6922d3c14f7bfdd3e56996f354fa12b3180b952b6ae1eb5ebaec1247efc51f6445eb42814a6af99c4d5793ff56fc65d93b6c7f322d91e137da59a13705a9bac50d813fbbaddcfc75850a11c7ad41484f1b1d5e1a7a39bc47b2f2170555be2227755afa9aad1359998bc68b608f4ad457906eb1721908f9a0b23ba89f87655f409a80c49a850cec99b5619c346396f8679b4543721aebb9fab30290ca119f0140699679043ffb53989cdc4864a06067b782d34c4dc16a884fcd02774b0d0db598fca0cebd44d9779d93326cbfb0436c9db7553f6a74a03c8fa2e089223f3b0685681a54c0eda8981b3421c0ab496084f4d9932f01270897bf452f02d547db60599f531690090cda7874fab6f649029285c161a91ee4fcfee38e19ca9add8a7b33d31a030f4330ff4297d6afe0c60e3fbfd6306a75763fd2991d87065e6370c3e66833e59b3adbb1b85d504f1dc200db57500c125049281dcb5f2bdff26718c96d39d5df02efb3f5e221f7a2c3a4d25303e7824b8afc97a80296f0d0731458a668cc8d29c60cc910598c12aa9f8fc5d3e8ff1f4548efc9fb44cbebaf5f98057a26ee60b5bca55611c7fd49c660004dfbb180a55553d47499df75a6a4a964962d80aee2ef0f63dd39f0c12da597910117cef02e56f1785415bc0b5b99b9dcf239d364fd7250b68b8d11bdb281a18f2cabb1f93a013f82ca0eda6b814a7cf5a55ddd493d403763f0149bbaed9f548ca92124fb172519f19bac08c4c80d1d5e2e91d71d35939ce2429c86138f49fff20b00dbcc66cea1657071141d65ae8905a8abb32c7543ac1926f09c85ebd8c3002d493c4f9281317c662e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
