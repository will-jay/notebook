<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c06b3961010ab47b1968c94d02521453a92a1dd8ce4874d25e754b5a421c9ef18d4514269f87350b4155359c49a75ce94806b62cf5348f782326e6a62f45f237e07953678ab37bc672f8f5375f46f293483fa464a84c2fb999870f3cf783e8641c506aa4ec19658d610076cf28d7c7623b17639f3a3cc820184f2fa0f401002db2605956a90b885471ef9c06955cd543707cc09dca35a30942f2269658798a4c9c6080ecf4004933a0d218419564e2ae183e716903c412e3fbdfc09c86c478a95b146824ce1bd786e12ee3db72499e69d3347a68836d44943ad2377848a75340397aa73264be236d03da7f4b2ef746be82838c29307b7f1e45b6b614398935a78394192f8c49410c60e37bfe9f2677561187a972dda2afe85cd9bde69810a619f18e0c8973a7987a7fea2c2e4ff31e6030aec24b06e1f0605782baccf1c82a5c5ee6d1414e7fd995a9a13d93eb7ac75ea3c0a96fd7e1ea0afc51549f9d18ec83e3c7a981b54c468cfdc68125a86aae378bca869e6bbc004eb19e753d3e90878c84252601b7ea57dfcc6975ffac297aa1684b647a5abad6bd0cd39411af6953085ac3b898396eddb86648c78677129826d5af159d5dce6055fb0827b38ecd4def255eb20fe40b3c03e608954c762f6d9c03bf438f062f6a0be3c288b8dbb1deb932331d3fa40833a4fcb76eca4667fdd7ba747cb333fedc209dac363ba9752057d75ca3c3cf49f8fd5c00007c901126c8403467e8d52a53242bcb9f5d402f2fe5926029067f6ced1c5e1a006044dde30f2d3a5c9e663e7b77bf4d2cc41f916021550d303afdaebbfd0fc561b545cbb7758ec2dac2a9cbd127f6277bff1d18ecbbc648fe64a791337385f1a35de80bf60d23214a75952bfeb093482ecab2a245c93c4ef0266375edf0416b515e6a66270f6cfa394fced11c50ccb96da4f5f78f5e2585c6e99e2b9b21890ca271651f45ea2825ed9a183285d276fc5a938c27155ac68e3afaff64b781b38726d5df77cccdbc157888450bd011745660f42e7fc76860e93b56e8e183730e89b7263b35ed0b2a4c3cc860b9717aa8f641a88b7d665fc5ce84899173e4b63bd912a3a40e8098f6748156da00043e7b4998196def45fa86fd9f2f9143f865a5103b8c0d8ae023e7bcd0537f550f70c4bb2eef4ce128d190fd1b5d7252baacc21a81078cb71e3b9e5720f245ea13ca6d6ec811779be62e86183d816b4b5e2dcc6b91a83b3be6dd9da511ddccd6baab5246213c1c8115a6d40cd33948a0bf5f98a3cfd98e86712ccd6381d30c6888f1ffd8427debf9f31da454138bbf02a49d9b09347695d9b53be96db65e23a94d8467340c7d947c72a36d900a464a25489e7ccc880071bc4173b362053bb165852b9ff192febf8cb174cb3f3fe3b97b3f8a7987290dca1c91158f04c99e1ec8f73435cbc45eccca3d588e668e4cb3786c4743c8648b52c2fc2ea04d0a0ee117e53f6e6de0bcd36adf80d50a069e93dfe1287548136d72129576cf47e629040c28a936644b964fdacd81226039399c230a8a50a7d58a2c7fb17a7d766202247be9af7d547f4f54bce744ccc4bae85b6f2d7bf6eaad61093b6ff71a51ac48320b749e05df175e213034875361948b5095b8192e0982e7f74edbdda8b1c9c51695a3b98b39f213792a32866120cb6305e12145b6f80f3b43a0bf676aec7694881dcd88cb996f314479183e66e98e1fba03f9effd1dacc3f4ba81c6b696351f83ffb210b5456e8bc330d1f5edbc22dd76db4701fc954bc076879c149a1c63f631007bc69ee51f3371fa273565c3e5ddf56d4e179a455317c56c9cf1bb41301501992e1b8fee3ba5f070b4f2c2671d5846dc8d8e964d6c408dc5ca7e279a98fcc249612601df27cad8334a51db1354ec2574c1cf7b97fce0fe5f337e11dc572ccb483b25ca6aae921529c4403df25d2291482aeaec08a0e461fc901159aae6c4819c6b9a4b39eaccc9bb015a43aebab94a445a0bb915c99268aba0519b462d4e6fe0f8febe7e43ec76a247d5b43e84631be0656c426a4b9f9b2068cbcba5ea2ef11a08d356523cfa0791c6b4bb25a1001547549f53937744e8ad9172c1cefb3b78aacf8ab19ebdbdcf7f2b33666e64e0b3d7ef8abb9a4d4c2aa9c03b3f00627ade6b27ebba453aa2e0c03836a2748def2ffa6932cefca49f14074afcab7013d48a1ff1e0676aaf5388d8789fff34a4d788268f7d0f4e2da422197885284dd5b3d952245d89ad1c323a0d2c9b2c8339b873e91f5a3c4dc69d0e64188596c8423f43ce04d40c02efe7e34a736005f83b79cb0387a25fb1753177a6d44cf2940bc9525e4575ffd746ee3cd80ea23dc31c9a35433b1a1cc33a3586414f7bcbf338d7de146578ea122f9388a930a7b88c079c854ed710c4cba8f21d9ac876eb9c2cf36f4b7bdd8d93a84d37938f68d49febaf303d863c609a03100934b2af3a8062635c8cd5899cd6cd63b145b41b8c963a5da70618069a12a27621ba6895e0470edf192f7ea98431a66bf14bd257a31a96f536cafa209c19ae7aedafc58d7a62e9d9ba8c0a37443fc07e28aceb817b41e256195de0e8e54a0cacfa24f715df85e61cae2284fc171d42e847f39c82e4d9032743101cb35d22f87a3976706d63a712d93221253d0e2e1ea104758eb4aefac258383f1e3490bc51c108db4372c644ca1301ed6e849d40a66e85b4f28de0413415e520cb24ac444c688313cc51b72dd6fcacf3bea848249565233cba311f449c56be303c622dc9dbc650fa73331f09470787416b3217fa190d28a521e5578f695d08c44dfdc6c8b47f800a02fc6da99196213e85b6b4fd6709915171e2c94a857d39633e4ca568e2227d44f459aee90584b854027feec1b308019f0ce7e5d4dfa56c59afc9316eda698a9a8fae7d883246c5f4e219da86bb131670bb0ec004414a250525653201533dd0546ebb2adc834761fbdd20403fc809c772087c0eb396165bbac135a1292329823886498b20ef93a47857c2bc6d8280ab0373aa58ac66758a2f2dd2e289bafdc0ce9b13635d54271cd4ab5ecb0385d0f0acbe40fcc14f737849ca179b31561f0a8dfcfcc4b10a87e4cfb6cc1f630dd5e86cd6e90d266f063c847d8446176319daeea68e9cda19768ccb6157f4f39d63c95076825046707200d74ee7815894583c612e0653b5aa04f183fff96ed645c2ad9bdf32022b271db9dac2791171877a476f210c09aafd705ac980898f9499f3bc2aea844ecea458930784d7147b987738187d8baaca2728a1b37375135066c147e6d9fe9ddf14fa281900b5f3b64cda1f6f37c8b479e33ab51af7af27175c00cf75cf94a9bab429e47e697ea7cfa4a54435b5ea6c7b9b96921b530f27c64466f8416c13813a1d208176e3c2d62f622226334d0343aa7445bb548ade1ba34d5497e674177ce42f7a59d358d6ae342bde5110f49839d9f0ac503d2a60e816572a2b420adf93c0f064b0840d6ab1a463321e4d32d48856a13cbfb3ba637bb01f88beed4a0911c216e7529bd6603760506f94099e4b104502ce8b1ed57b6feba994c23ad504d760ed823e45064e17f1b9638364bad6826391c4af5888fbb0710a75c3c8bc0a10c531d3b599a11fbd6e2e0a43c52829a83f0d8ce0d9cdc4133b88109ba5e42ccf5fbd7918b63996ff74448c87c7ad0555850338c4d79e71d982673861e3df28735fa094b029628f812caf44a6c91ecf9d9404cdcd88b50b161373e6d92ca3d22b74e447ae46cf1684a45f648e56ac442b20a641a9c995633e6c63228fae589bc1e1b63ee116f6431394da0e7d18c0589046f245af6a18094666a7022250a9e11c73974ac52568f3330e439318fbb9b56501e89c2f8b01cab70daa92494b2292a198bc3da65095326a0c1ef9302b6e49380822737b767d20611ac41ee03f7f3fabc45aa96c2866cf7d0a6931884b502bb7a822be077fdffa406ebef8867aa5c0260d390c5af3ace05bccf295c51f939ff8697f690b2ef5a5738094991d5a08b9ccee1190d126f7a152d71c72621200e29d61363cf6516301c2d60aef90216b2cebe5f10f2ff9daf2cb49161321be2d8ac0523f50138d197cf137bc84b871e62281f13c1ea30b2f2320b53f93bdcec4a7c477199d351b326b0b07f46ea1d04aa4ea43a62d782a5326af9156da4a4640f8960ad486df71b26803d67a735507d5834a3de925f158aee98a0951feabf6781c90debe70c2b98f54a0800373192040f8a7ba2af371556e9f0645d89f400af61317bc16f7cee5a186a7b7998fdfc35f5d5c47975b66f5adff597257c3ce5d3679d4674927045c7e0cd5518fa8082f80d7df3e04c038e492720694e9451d0e60477b9e5e961fc5d56287983a70c2bee090640315bac297eabe55572408b9fa8b1f7d92b16f76f39a3ab9117de24f2190f190b51b367cadccdf471804358d4304ede4aee5a447b2578365304f2ad83a0844e647809984f57d4f638b7d68454f8a6b5633032f5e797d4cd5f3247e651b0a8f30e0e3c0dce885aca0374c73aca6d0873e7fdb686aecda28fc915bf6adb5691d9d9dd7f41cd074f09a8a0d3a4cbf164d0b1f49722fc15f9dc2cd4bf7c8db4c0a3797bcda09d4a40a88c9cb84cc1c7c07fef044317a3f9ef67edcb4b173ffa24410046de12a89b6750eb0b133fc4bdf5b1549a6f04d9d8a6a0d4903233e488ec33f0cbcdb6560df6f93194ceab7a2b5bed098deca163673b566ccfe433f4a54d6d0490a2dcb30e679933194a60fc5982e8b0d9877c36c48163235487c501875f17c483cb16d0fa9e5dde5a098c74ba74d5fb5f6c00e0a7a2fdad9f3fda3958208bf7daf5dee398019089464444ed3253053b11461d3078a5581269a7df34fa0f4532df5e118afb633a6b5b0feae6149f95b232d02dd2ddbd96ded190e4c82736d79dcd6fb6518e8598c6b16bab70dbca84f359b865175c02990a33edf9bd1674a0db2f77cb7f9ede79db987c5262af91c797725f259643f444eacca8a8196f9918a73cf935f0b2c1563efe2af66674bce883178b60d5ce35853ee297458ee37c277f38956c49c932b63fc4922cfdca6ba3a01ca769d266030665b44e6e75178c5b85a6fd8344f031ca45062dd7033964e55cdd03e4422fcea89b5154b59105d2f4acfa5b1efa250a3e785488c7940d7de7013b0c89822674e39ee8e941b130dd7e12bd97953522ff6cd54306657081df826669f1f7309572d5888ea110e84c1486cab40e7aa80fc4bfd904dac7d18a9121f59a1e5a7c6d286e266cdfa1cf67a1afd2ffdd3eeca2586074af189ef3b8ac5ced709c432c6de372a65cc9b7e4d3dd39658988bd6151ea3db70a2cb23a3fd8a280d87db9c1ada37fd8067cce60229963e76d915d5dc7da086a5b8c3fa79cae65e45f9c5b027d7aebc9fa7f85c0f62a9951529a3e3815f4880bd30d7c35afc20cea92495de167163d336ce75760d6f857a6a7cc3593918122959853c177c08623cc1be62152f6b96e6ffb2b2dae92bd48b5c91cc260dd65cb592bb78d79e5e687b5423921870468ad34457a3a3c48e33b5941cc63f6f84124fb8f00ad2c468d29377514a334c56dbe6c2e73431c3df072c98a01d6a2ab7d4da5495e24de87be4db4079993c514b6a83c68752fa7752b601ce362c2b27a5a2afc24fe992526c4bbaf589df6caa3f33c9a86105de21cb58edbd053c923603f44500fba82468c19d36a1964642acc66d00eb7f263856e7e04bbe3ab25d4b5cea134472623f493cd9926bd8cca02730a86dc346d0f652816cd4b7b7b30dd7faf45b8a23af528bb728acbaaf1ab94cefb26930facd85c023f250a51eef5d13b933b45d6feccfd9cbb0d673a86f4b5655a2e090fbb63ed8738292ccbde3f7cd2dcf19e48c6eafc8db195f9ebb4325f9338bbdc4183a5c577b68793a4b85b509c5de2ff398b7c2c51aac25137a050d7a84cf16e8361df849baf2008a21fce93342203cb798a8cc5518be4ea74ec6bca52d1503cb078f45a20c3f0ec591659b61971b8b7508bf5e909a51c13193b80560fc1497d54517a137995d5c773c8498c275da127997ded32fe6b139447fe80e6d1094b7939a06eb12593ee01ec98f3f31008935d03dd9adbb5abbbdf95f6820fda9f3026b7a2db10463d4f9ea8de7e7165abb740e0c166b0270c5b737dfba502f16cd04b5c19d9b551d6dfd274c349e02220d3e81416f947d39156989da047c2c85749981042d438d3a2d827c4b48d68f54b3daccd828d9ecf1ddebaefd357a6a7bfcde11fe9abeb921dea78e3dca3bbf6322855e5df1aef7446773750e7b6ce4321343d363dea78df9c0821d3465a8eb10f79934ee19b1ba589bec9d4201aceaffa25b78058ca28ba468360e7a7258d624b70fe711147a285b866ab0c33b126759e1b5cec108b39069553d2a4bd32851c126b056e7e1e1933fbeaa1e3d719fe094645d225824c0454b73f063537544f8b10658fc5c1545950c3486b16c56212247233cffbdf78e4351735bffd96775da79f463285f086a2eed72d9791f07306259fb06f233b1b4cd7317e1ec884a58a7dca4064b343777456df80e0e44ca3f1d6996b2c56a14c59bf6a4402e9eecf378ef45a6b6ce3ce7fecd1afbfe461c9522fbf000d2b4196a162951780b8ce240de591d149f37e55c7fb280bcc6ba7d9604bbcd9e249acba2b639ec855ece56f41b3b55d3094d990401928a67360e8026215ae6ba83b7ce292cd6f12e78a7a5e279af1c51cc1ead9afa86fe7b6b9f64d8ca5629dc2809fafa38bbf9378cfcf648b4f18450670265336ed3a32637d07faba8a870a7c8cfd06633e0274bc170053bdc37e5b5c04101ab8cbeafc2bb630f8f775a9fad7b4c216d8224365248bd920e78ea3415adcd7bbacd65e89ac2e150200143875eb14e651e5380ff05c778b2b6238a864a9c0dd8d5fb26a13cf99456a9090c4fd6637b51943145fb607583febb6f8149ada25c6605677753aaa4b25adbc7ee6d949ba7b8e549b118df3dc5080e91a35016be8e56ff1277f304908e0e6d13296d2230e1af58d7e2bc895686c8f4c5fdff2898b680435320325b211b9365a36b6b6ca931ffb7e9f38bcf2ad31e0c7b77390835830636e75a39aeb35ee0c7ec297940dac3fca500aa0861460a322ee236b2f1c3b936daf46859e7e29b436d6591f06632c6954379e4fcff0c922df060f6c724dcb8fd07397da67b0721ce4227efa6326555219f8be165fc9064a1b29ef190c25b168aad9f5add4873dca41e121ae4c10624b37bfb2ee8dc406827fb2193fdb5ca75766f8015f5b5e1cb361f74e6a995d00f536ec17554550b381330175fd15208a8986184e3b4b73510edadc5a0cbc217baf23b9f2403ad8c9430d7eb44a5bdfd3a94a8bad0ca4b084d6a564e0f6b71fa977f37241fd718b20a1d8465988815c6e6dc71f5592d4884c8b017a941b8d5b079680374aefd88f6d55a063467aaf5490e09bac859cd442096d53b1ece3d981127321fa6a1749d5383388cf35e8f77e439c0f836e29ccbde384629fedd7441fa345f7f6efd3c1a15853556d2bf35750e44769fefc5b6de0d91ed603f341c8588683dcea04c052c306a3c0dc00f9f3e485eb60e9dcaacb35f3211d7456add9e5101e22b5244b9703c5b3d7fc37d29a10db0a9bb8a9986e82ee58eed04a87cb0381530ee3601dfc2f6088a4aca40a032a0aad9aa0cc75959dcdea02ae0eb6daf6e159ec26281d8b1413fdc734ba485f20fd6ae66c4b258f48b35e2d477ff8a27ed571a580d97311e988674eae45ab64ee9bee1cc190028434d079c39c0603571e136234da95d46e1fc0ff8933e026980765bb7f5239d53a324e53d2ac6ad83bf30538f6fdb4d7cb355ea2151eafbab356027478c1f489156cfeea77b18d27b181c2da425932e12346e91cf29a05f732e2ad2f99c910dde5fdd69b29b797718a4a17998cb21238ab18032c3aaa7ec6303d96ed60fe68b73801e553fa0c17af12451b85089b586139d4a921ead3cbcaa3fbaa4dea99a0afed520b9976dc0bcaef802c482debd1fa27a87ed931b7055ffce95ae2bd7fa92293349c38cf9295a119b7e3f387fa29db1fb8fe015e76da4306b67b9d75eb6803d1bf357b3f5b54c996ca4de0ffbeeb07e148bb1ec038846d3f75a24b30426b7f41c844fdeaa81f108f16c8db1bc4448a39ea7b71c3be28c7afd5f126a6f0bbabc085e9a3542bbfe62d81c0b5c2189b9da4a33612a0d8977f03e8e9bd9826e32ea6f945c77da8633100536429d4e32d19186864b1a88f002000eb3970524a14bbe39d55ca20f5eea8cf957745c3b76cd0d82a2cd730a1c463c89a70bd782495296f48ed1c25997b9a3f86c5f6361ce6b88a255d404fa1310003546ef10ad805ba1da264bd9d7dc462ab3b050b8aebf2c29fbb154a448497bb391d971f3660f70b969d1670c72bfb7547eca3d42eb9f8819f1d352387ab3b3acefe48ed202017a5040be1e69e1b0a9b61d9018fbfee50122664dc5b58e8ea42f1209b70088b58fa96d0b13fa9384927874108d4a16388e92e1655c227e10c1da998a34a56dd8bac15bd600ed127e63cb3709d960c6abcc86fa49949bf8d46ce8c7d6f69122e9afef3d7e8ecb65bd4016ffe624da42efc510c71485672dc4823e569c9cfe03d97c1786ed58d08e86b2526439b9d409225750649fc9894c5e84479e906c67cabea7f02e8a7ef06ce4787276e2fe47278adbe6531b38fe6b7bbaff4a13203f14cada80d8b2d92b49e796d40cdb04e18ef02eecd4cae2ee260fd109a4fb34876a647daca48c75060de713c01f319250139f2e091ee3041923add5ac7c4ec9f81f208c53a2b997f05ed476e312dcfc0f631ce7feaf33f577a5cc1ef225ddcc3618f193e94ec43fc657f880181721304241f3eefdc02d34cddea066e9ebde48a67424cffce5e211bfb0eabe3d7a1fb05fc177e69fdcbed2cf26b1d939115640334f0d949acefd5c72e59d30f35d4370bdef3c7ea9b7601548e69e5eb10dd902bca0854c635fb5cb65e3eefd85d749dbb448acce87a4cac7046a79f8d5497ec826e51cd1126330983aa560f74efa7312d8876c6da678fcec1b916c1a7239ee0d960f21164891a4da425a3cb37565c6441267a63d52391259442731a381e4b5af10405930521e3fd0620719ea48fe0c1fdb0b4220e77e05a5665766ad055261460f32f0bf26099a2a2ab9b2afe44357422f31ee639940eef19e7c3600e07da36efc74c94894c2f4367a6273a06268510a2d4ef0d3a61bd5a489e2ad6cd0d585227d679f43f1e90f78529621f93ea98d0f1e557061811424657b0e04112265de3e74be0ee292b6ef23521cfe6b926f9cb48d372c7ae6a22c61b7066802446f7c40d221f3f6eba66674cbf80f0e6245c288eb459446a6b320f93b618d92ccf6303d3fefc26e8de93f31f895e233f6f40b766aa5b168a449e3cf90413e1cf0217a9b08ee0a55385cb224d412a977c388a2220de07e27e457807c45bd88e10658a7e3db4531c69a139bfbc0a174ff44d763151fa01116346dcf495e81f8aac7a7eac916cf180a8477deaa3c232600c5a57bf8a529479dc06824f1b96ce7f063e1ce11c6a1973b6488d35dda5007abbf0d88b4def35026c8356f62c8227015649c05ea57c19a9d62bbdbb08cd42c4a2b479b2a4114f199ca44ff673a7d714bf147e9e77a39bfacbaf0b3b099630aa7106bc24b53654c9b60831b3e63cabe636e2400918197e24b83f2af26c12a74b66c28cc9ded0204236b68103d5d92eb43169c287d43cf34cfc7354fe2afe8b8a8cd1b4233988ca82ca79fdfeed119476c9972d09ce0b92d9ccc786221d7cb3d8463f4f98587a11d14024fb71eb06a731a916dc9ab891423b13246bc9b23ed8feb5409aa32f904ac446152aebe15811f2f65323c8fb95edaed5596f08221d3e0f29285cf442184fcccac81c906e67677872397cbbad5623d26f25b9eefde765d632c98aa91675fb1b869f815a3b3619c06ded7fa48e72d54a8f88ea11d88a7bf9d62f7dd8678e872e251acf39a0908cc0e45609daba721211c49eca41a6aebf9cd712f0a54f94ced6dd423a3cbbc0c8a1ce7892e4521fd185f6310da5ac7a9376c685561b10ef380894f4c3d121834a9c6c052eef61ddd565f8bc551733e576fa3990ff4d2e94e6284940b2e8449605dfedc3205dbf5e8b460f00b32fb1bd5ce23d173f35cb7c45919907e40121963e8941597c35147fac97abcd87395ce66572c1ce5b4bbb0b8dfe6fbac12e9b578346dbd71b023441d2dcb9e1739fa7223b75fe91fbfdfabe44ed73b47fa5c773934920e8cff57dd99946236b9e3a1c2cc75682bb8d11686bafd86fb8186b328a730457a1b3352e7f99e3035b026dfa735cf94480fb78cfe2a2dbe7e7205d755c3e839bc20f5ec52d811b13111686d28c609da6e5126417bdcf196a1076a1d02bc4d91aea15a65d723ccc7915ac4bfca45cf0388cd3df0beca948eccf8e203457c129c55074b87293803ad623c5e614da961d7787ec18ab16d099669add61766cb4faf34688055202f2080bc4377988e41d0eb887c9d19a42f220eac46ba618e5a6ec6b7605b21693018ac52d6eb6e2e1b4cba679259fe57ccc559c2543f637950995d4958300c18478b60f702098733b34cf537b38ea8cda7b26cf1545435eee798c3dc60e0f23863830e0ffe63c8fd1d53e65df62b2ac376e9b48a6495fa60556d3b8c0dfe562ddb17628a60539b17cdc32e838b4a36ab6ad78618737ea75e27c32fc5888dc8b5c34007de53d0c1d181087f3cccaa98c36ba1c5d72389e7357d76b3afe41d43df584bb7e376520863baa2071fa43156fa642d3d1dcfa631a9b6eb40b99c4ae56a5996d9261a9229398eed6df63f3737d8c7974c254083316a9987cf7589dc70fb2c12a35ed3689e8509edf7ad9968c076afea8f623a2263811f86dbff80313ee522484d6a2906384bcd9c2616c27c678c6af03df7142a2b8ec7336ad27deb7a19537cfc71f8df8e8f47d9da62a8817ecd13b1123c9f2ce6ac21c8fd2af41aa590d75046be8d1717ce47418b4ac251e34617ac5971bdcba96b0ab2b222182bb0767e44aad0f7721ab0a9f9ab4b5e80b8234cbee8132e2903473d44ba93b0a5e807a460455cc45dedf00444b95370a604f639d4ebfb649e74eb856bf340bbe13c6e49c24ad21bf2f007e4f51af8e9ee48ba07f971d6d4bae2918d3531f9175b3d295d17ed7afb792b96c082a0be17cab10caf19682fee3ecbbfa803fc1f403c6540ffb40faa73a2ade99fd5a8a2cac992e557c4ee6641043f9e82565aa711f0be0421d7d017577a8999b967fe5400fc27327673a4b2fbf6b3d57b74e27b6d55021de4b2020e4e4efad737eee03cb4842eb99494141644d24eb116d7c6e4c3bd6fe100a82bdcceb1c337f3adeefe468f617ab34df723577b952b2ed43f789788501a4e5cade9329c017b00e3fc77fca9f42555542a3a7d7cb448209097acfb9e28776d4b6a9b091e31100fe6e82bcc0e526b2fe05bbb4036b715e73eea9ecca35f1611100b6e416e84cc97c6986ded72c63a6375063ec079243909d3f4d19c30663186a244db9228f9068ea4031b7911c64401cce68fd6b0033f443c57f23f3a3fb9cfddf53f82be6d5ccb70e2ba7ab7fa32bfd5e70476c2120370c360c17266ab787346a9d39d11f95d0586c384a1e17d48fa78f729b8ab4f436e4b1100c6a6026fd5766a8718691b15922bde2ad0f5d6bfb79293dab32746b18f691728a163215b674ffcf7823a533ce7b49b95b8ab9a90c2beb4da19be3db1b48c2d91d697a16597be5bff6f6164d1948074423a9039c5ef5ee25aad0364fbb7cd46db63a27f6fa9cb40e4d42483ad815f2b24f86c825625679b7fc25131fb3525812bc79b9e6b65adf76b19d301967a8ce83d6393267a753b673a1a63402d953b9dcadcd9b76797fc67a09603c7786a2296fa95459492c4c710b89ef18558d78be389ef4318b52244864592239f2140caafef03a6559154b2c283693f6e0b2930d2458cca1e7ef56e346e0cf6d3c41edc332cb08e6d0a72667c28625041d0ddb610eea9523ca32dfb061beab00ac7523778e80c76d6fde9ece4e08839069a4343d15e4a01588102a5e6d6e5b3f289564c6802cf6400507e71e1dc6829ed2e793de1b464b9149992641fe0b9e78ea3e0cff5d48f6c352d2b755239e05b27eefd150ca63014625915034760a78776839c4a5d45786d8aaa4c9d48852af6201b848ffd0e8ad5cad92bb8440eb9d8d95c2c007fe4e99f40488aca2e6edd221d7d953fc64f99c66de5fa2e598cded768112541438740af96655073796b79bbfd7190a1250c322add5a7666ae385bd6e2be3ce5634bdf0855f4c0549b1ab230ce060897c0cc2c776e69fee78e26db661d739d40299646e77fbc7f34119702e9a80bad1868ed18f557ba69052178d39c130b117fb6388f3d4e62c2aa01c1b6bb999c17b5c6aec9cde8bc5d17a0185f0d2c8210d452df5ae5b520593b4e06a61ba51b79e52ecdb7a1053ffa91fe02dc3fab603a324de4acbcdee0fe237ed14494aa743e3c2c49198003028bfbe555e77002bea4ad65fbfb3cb962c777d4a6c304224aaed20a7aacbcf643ec4095b4348e064af696e4eccd37d81f44639929e903ade95ebd7cf9f8f684b35538637fa79866f2b749d475841231537d8b62bfd23a5feff9b374624869a0d4670f05d9e38168082fae4ab24f8abe171ff2ac2228eb63cd3032bf68e8441100eeb9843332d2209e204e240635aa04a93003a5722ea116be770c5ade2d68e95bb9c369836659571aa290333edde5fc1fa574545c6fd88374021c39c44696711a268830ac65745193aee682e876d454618944f404af88545b13086bd40f19f751774f07ece5fd4acec593a1242b794458bbfba3ec9d2f256da1a8f08c959a93d75e507b4109f880d646e8440e5cdab16267864a328fc117104db7a036a9809a274872d18f439ea3a3d05953100ea1ea4aabb3a52a1000df35d0ff8d70a1a7d53d70500561bd833026a3d6c7f5cb8bda606b709f7524d38deb2594f0abc6dfd9a5b6a078029415957e6a7aa6c8ee520ba3576d41a3b0a6f566e7840c4e1fcb92438c5bb2ee1d82e8923fe006bed31553258f59b7d3cb54ca53090c4e2f303be1678ad827e052f8726296d7b0c74fa70e301d0eab6f221c7381cc4159405eb8617987c40b56c845365fa39106adc22fbf32869dbbaefc21b894e62eea8ed2f92d5380fa104fc9da5abbaccfbcb0cc4b3b3cf28182a8844cadc4a02469d372654895f2de5c47c978b8bfd042a8f67e1cc4112ca7c8927f28e0fe56486b8875613a30c5587f7df427dce4778b6188beac3698691a394ba068a9a6f26d49743e00154d2db7827f77b6b3285f02bd3135d6bb6d213589e4f70a572cf50d8d03f2eda1d7ce6e16ba2f21ce56fe6148de5a80d651f94217a60e78e6a0611fd91e2e4b9e3a1a3864edcea3783bd4941febb6d399948fafde74c15426f43250e9d7348be5912f9ca6002bbfbc1b16570245e64ace31b91b0036fdd93745242f559f3c2e104008bb98dfc2eebbdaec6fb5a41412fd3fe0978dcf70b60faf13b08221073fd4a3f337e21e04a62ea9d781a9fd43158840a369806d1d495b9da0c2693e0b642677b722fffd4ae51f58f0a2cfe28c648ebc93fa016b7791c8fe06265d96e38f723f7cfceef1c58c9710397705a54f843f061b64a79be24e084bf990825ea2178d08f9bd4a93b3bfea1cb22126c8a71b92a3b0e3dba51304859714d659dccfc37bcab5af040a9241e42af472d9be6099320a1f0687013db7c929d44f615e1820099c0145b7c3667dd34c386af862e46539192807b432f53d0086654733a70784e13ad4a87c47f7b5b88e167eb8d24ce50b66cf1d138ed76c82d69c2244070a7ec011720691e8d4374603d506d742685748d53971c8262e66d4d389055d381a44472df0294ccb9fce2bf06737fd3ada67c2030c77dfdb614c2fa3454c9b9be89afa448e33e99c6262f5bc666575cfffe822de75ff874807ab62515367a7da4408f82f86f84dbbac4273531b7548a49d6937e83d643a50231a6ccd414eed2d980130a29d9a939b27952801fca55ab7a18c0e829d10e4afb429cb6e1037fa50bc0de7a6f4886e08bcf1c27dc03daa382c626809d2fd2eb573049717d41e01632dec844d45df453af4532e9c9e2ba2d7e19066ae253b9c4dee0bf64a4fc11823daec7f5f17f9d496fab639108465473169de612b6055af921f4e0579463a08030de15dee36fb0b557b8b985e63b2a7c7cc0cd37113a78dc7c476200f4500bdff2fe7fe52080953d012df3c4649c6340d9e74bfa80edcd55122af75b3bde768084aa357cc92c3f3d3dff05966275fff6e5129a6d08a55663e9696e6d7380d34af01bf37be6364718e4e918bded0b377ed5b58f49da980ec776b9eda4a45b4ac146af4345f1e898cb63d03ca066aeda255fa5126c3478ae648919eb7c29fb0617d6443f043a12cde287c39c2f22261a840ba815f5df7c36ad98e38eb559b6fed62e3514470994874cc96d92142150e2a7058fb67a2ff44b57283f88c8ecfc16779f3c62b9a01e2a11ed6360fb8651c0881b80c3cc950b2c08fb1d979e3ef0e204cd110c92ee3629ce3a60213342e7ffac3d23e11e2f5594afa296ba9f9a8d0e23cf7ddc297191d7cca4c5529fa8edf07e9f3c92bb9a5e9507f9c7679567eeaaf52dfcc976b3ea392d2547b63d8f3303cccf538fe0d02d329330b5a7c4fc3f0fb03a45fc6654262d2142dec5cb7cdb10276568df443a78e5ddbe71c9a51de11e551cee1f739856cf6654a06a55a6b160df6e41b3f55a41c23ad7994c9b6b5cde255c04031013f06d92861340e878e9df5b04ea541767028d4653ae0d85d63fd6ff0b514788e923c11e0bb92926ca9dcf7d2c16c7200621851ace45227768f1afe5b75e1e0316cf2132d30fe1df811f3e6d52777514fe42f732b535b8362c4178471ce62a12f5b9713148496c6d63d0a816485369abd35c6229a243c8565fe27025f4573798319d28bfb3be4e1d3d3bb7dc3bbe03959388e9785c34dc3dc666e1085dd30e2d6802abe6abb97942e73a23e21fe4cf737a23778f0f9b4c1112721c180307f5fb670870e68fab8aa5cedbf3463b13bfc7faa9861a319a3bd52984e9ea6647403d0192a372ab142ff0a0b2a74b1318999d133f8494ca2a9a8dd22d1800095801ebd516a0b8a672c1e922145bc2fe42446d6d86ffa1de16fbb1a14a3b755bcb6ad8486d1fe7700a001a2b9903843db6b54459aafdddf59914046775fa0620695908ac764db9035954c03078e904ac338b865920566e3a4098390458741bd64f44c615db5c9953d9d12183f8d652ef1216b2c7dde7887b20d2abb4f9054e1627a112dcd228d8487ca9e22dfd3c196f49079ff489b86f5de5dd65dafcbd7d2024a60198b492a7bf94546e9216e57af194568026d383cc1094166e58bc496b02e2e1bab59d0fa4ce849f19f2144082e9e1b6d51546a601eb28b3ec7631314b48a2fa1b17871ecbe115cd15ee52b13c6eaad1e9a14a0cfd0ad6ba9e38646ada79cfe67e2a3137f0dbcbd8410a627a72de3b3098029dd0f8f296eeed1487ed73ef8a06b6b43a5e30f3d7ef6658b36b665981f3f320e52a9c3aa38f080ba7bdff1d8887139e1aaf4050ca3785ad4dc470ada5eb2772ea638698af92bfe7e7edbce160a4c55a98d55708f9d5e38dbe9631d2894a25f00a02fdef549451cae0f004bdfc39538dde5265bc5db4947138e5f48c976f580ca1255a2b91c4337df53ee927537d5718036d5c7a3efb2f9ad6689d89771c4870d53387824e0ff43be7304459983e2d88490d9e1cb8b7cd89ce422c3fab267d5a9fde23089863ab6295a27a7c7d7e5a2da22a1cea81e9787d64c7ca3fc2a94204b173dd72287655a28f729a13672de7cf36b0132ad365fbd3981bf50b7cb7607857018601de9f02a71329cef6ac2bee015f903915db66de670c0fee26379ffd07b5bb24f752650b2ca7a853a8471a11c72f539581748767a7794acef93341e1bbdd6be7175b2dd0a9a9e6a9c5700a634820bb054c5c8e61b8998709cbc1be9c245d2020fb3d69fff63acf71d423e5ce566cdf069e8a4774a31809ed4a60003563deac74a8c193e0d549f1dd3d3460d2db04c0d8300b10c4414517aa89917e27672991a73094103f862420ee547f02af7e876e200eacd3d90be04722fbde8a41d89c3d2c1825696bc27c0eb0a4f5ce75fbe0fd016fb70b054070aedeb387639b6bb97f2705bdea6397b3ee9e1f50c476932e9993c340c73108bc5cf71f2aa42f43953e3f0fdf1b31e3afbfef9ffa4c2a732d2a473b32d10634c3b9d02e19e05e956c8143408fdcca740e820dbabc0333068849018c4fffea29a3aebd1045af553d8526fdc58a4028e26bef97dc06824dfe6e80753ae2ed40a1737fdf4c13c430c1dfe2bde903f2bc906a566365ebac490c4f9013dacdf6be0b74494640745a8d860b8e890e0cda47e79970f5b8a692550a7eb4b69e7677144cedc891d133ff1c6649b1f50dacb65cc8556c558b1d6ad9718420bc4ffb255f72bee4bc2ec1b5b9eac22091e30cdef7d9c30d5a09eb242dcfa410d0b8776ae432030c6cecb9d30f9db77d0767bd723c08bd5176cb601b5a3f5f8e6a8fcb84580b7759d05c71df71feb60583285f5c89ae6e9af47d19806eca1716657c86879165dbce6bd89ad6888a7f0f769c232919e406d44dd0022c54dbad43558913bbb62e0b0f05770bd638cefa968f5c3fe540ddd11b3fa3690403498e743bf0b79754915bae2a3347e6e4248e436c6d927525874474765b45bd5cf8277bae02b8d893d477204ea13e0cff0cb688d3cc292ba3e5a60ca0162fb0a010646757de039930317b405db92bde80d99cb13f5c53ed33e9815e8bf711c3cc13ca527f53e9e4d0199298c3ff5f4eb5da8c596254be7dd0f3e19b7923d8a23b04c98e97e152446fa8234dfbc783a0bd1bbc900251f2d0e2195a7744a76cd9baf90fb55c7264f423378c5258f45af9455f7356ca2a6fdf98137e7de5011f09027d5d110a9c0427282c265737fb069439ae3812634b30b53630a0acdb4bc294b484385a99043e323201027ec8dfd133d7efeeabfa41140d5f495f35ac9ad5b498d7a6d4789ec7c53ddef47a1b7c77da61abd11a11f03ae46bfde5d30aedce0fac76a034f9852d1e17e9b2613a93ea8a79039411cf6da09af87ce898b0fcc9f9b1bd7e127988c9875158ac4e8f9ba78a0be4a10bd92537d461783f6ffb3812afc863adc68ff403c88a4933eec893004fbdda0c925916f53c9536c949356e2ad70730fb2e8941bf6707e6731bc7187c8f4d23fc0649843d07111fec02158d9800703912315adf2b517a214fb819246da28a375b37d13e890128f7006ededa27843bce3e8a1b9c9cb254e39f0aa3b5413ea50116cfc932cd52cdd6c5e8e5bc8b929ccd96efe813d6590acaa85fc2c3008ba936228ee05f123579ede9786c0cc621b2871f88eb06c1c7415b4de441e803ec2fe122d99f149c5792e835187e60890034aec65ee2b582f03fa75564d4b7f24ce303d91259f3d28bbd76508702c847b0083281ad45a7e8693534b81b1d8c0fbe5e930734e37b6baa068264fd1d67830dbfd03708959db16e91189341e7d77d4d9eaf2e150febf97da0b647c619ec9d2a5c0a3bfab2e684764acacabd747d69ee4745dfa48aa8876b01358349bb35fcba2d07044603fb04fd18445219d845c9d237c258d94bca9334b7d88b6024f52072a4f47c067c7ad19e00579814fb2525b65207777b1ff2f6ce42c5413b908dcd79066c509b2b165a6a8bdf252a14116a0687ea62aac7fad316be3be456385c7076f2220e9d00435adcdfceea0cc7f4fd68ca860c75c4360731b932a95896f9dc35715052c44cedbdedb6106cc47f73fc85e14e9d7f758df974096924a9dbf2746cb0eee201a34e0209cd3b9384a720f3fa77356b861720efa967814f919dc04ecc8adc8dc74f53aa55e0e3c3f5566cf9aca85af40fd6ceae79325ce1663c9996cb7ee8216e5392923733cae77922f74b5e2de5ca61e561fff1a5f7f8a5c693dbf5e2011845fafb942cae858d630e9e3d12c395ffa2d8931f3c5e62754e14fd65b81f8ca16b30fcbadc76742477433c80c704849ac7075714adf36174556428c9dc850459551fba8e2a5abc275df5f7b3ed64af3aa5ef1b278283fb268a5a7399d4c0a21ad72b89b0c8b644352db0f3521553122ca7d0dfee6a61b3c11f6ee5b7fb4e93fe5f9e3bc8781b104f4d569e4462340e5400b31d53abc01eadd7c05473b41c0ed60ae19538ab13121a86770c50cf8cdac8a6845d92beb8165d871d3981da90e3704589ba04c6ca6a616e1627d79a5fb474ab9db7076deae222eed71d43adaea0e6df7885465cc27073a190b4bca75d4012b7547238bc68bfba1f4d03c7f74b33239136a5515369dccea73bc04c24c79e06abc466dce4f2e9dfc8f19cd53b3eadd8072b755d1334761e165ad886d39dab7ff34dfaac3e7c564dafef9822bc317c63e453041b10f469c868824536fc293f5f662d523e1ad9dac79a4349353cdf31a4faff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
