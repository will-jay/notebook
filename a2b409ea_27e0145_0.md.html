<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"614ef0e5bbe05b92d1f9b2688d1bda7ea8f50c915eba3aad32bfb2086cf56efbdd61ca7ebf07990f66e8935f47eddcce7a40fa6d7d10e362de0f9e64cf42abf3d294b3d56c97f98b1b464f07358716fb9fa23384284ec47f01373e4a3aa80c9e20ac996e4f2029601efaf9919e30fb8060d77436972dbfddd1a84b77a45ac9d293403893e9e083033d3b342d7922a747198fee684f33774183315ae5aaf9704b17158fc0f2d5fe1c8af9a77fc7dccda1f7444d3ea7842a622c0cf8b430889f2a0f985c5bfb46ee71e53a4c4d67d0657146a747580964f9f3abf9a0e382f1485dc60fe575370141398f36262d1c665b588da612514bd622d5dec29886d1976fbf66e04829a2ede2cd1728eb8afab7b0d96a246242307688168c9013d37586b5386915fc35ef7442e86973f79983228804b719910d8780c5760823d0e528f3a42e748a0b4914be476fdd96748ee9cec5334a35df362c2c0ced22f9bf868edf20b403ab08bc5077bd45ad89cdfe432cc375d4a22784ba19a9ce2639f86a9732a69240011a7943fc64150c7b2df9fa438647e3e9f582389d7b1dd069214272e4c28305fe6bb7f235c3df6b59cf282a6fc503153586e0c1a64ffff60a93a192e154c79ffabce6dbe32c48a04df4e61849574806864e0e850a97e6d4ae5b298689eb7939c7687c3eda065c7f2f6c0dbbba78377c834419cc3f5f0cd0df090e7e3a2a48cb12304300abf280609287a821214aa93f35ec5e16f50da0c59ecbe5ddea91ad817d4d5923669c06b88944be07cf3775a3a3ac7557cc329817b0a9e851aa3bc4832a2fe48d2207b1e5c67043723a91f8860ee476db39c6bb6846f44670a866d03e0c54da6db53d9cdd88c3230edb3e97c4b50dc9d299a8cf671cc01e78cec1cf185585832533f140870d02195376fb578ada13af1ac01b4ffd11e023fde73b30c9f11c4728be9dc3a3a98484c794dc1883639a93dbef29a2e0322d317e4ee0197cc8e2560daabd112d5f314b447e45d8855d06cd150d2e06ac54d61006f0c9da7b919a1c0fe806abe7e31c41fbe3f6fc186064f46b97ad0d9d1a10d1324568eedc704132dee01c5451bfcdf8b245e5e6e1f8ff7a44a2199a212917a48aad7c94cbb8a82c553ea10a0abc13cc0e6abdc4525fc9ca46f12b4ee55495e6a52d488a579cd8e8b93183afc47db2958988c9051a7a9bdc08daa3c1a9f48ae41da782ea3660ab408d5b60182b98080146ce77c6d9e44aa963d3c25a234ca8a3624e49c96d164ba8e9db63e7279d2f24235ff5ebc287009660b29dbb80ab6428d2aa4ff83a1f12842d14d9deb44b01388ff2cb2ab292be9451b78adf674722021e6ad4bbac62d4e79046ecd91c99d9022dcb6f10a3f9d7f907e9ea8730531fd7bb519d17764ea9367d647583bfbca71b3059d0bc635840d22933bf9d4a74a41c424506e981b7eac42bd9212ff9bd5d80a8a85a5db96ab8574952becccc5450e284186d10a3bbfb37fceadffcdd7d1f370b6f86b9c34f2a95b760e59253cefd10cd8851042fd462e5b8d9dae8fe2fc7d1a26a478de881661fb933a1401a9dc882b6a870af3022571bb01a9716b3b4103a6675b8a671bd9d6a6dc5b05b0728286c784d06d712faefe3c0c8a1c1e7c7304cb2b6df388be6e61a07e2808189b94e2da8ab8bd25f248fe0aba5ad540de0d1d97e5262afcd84fd78d47ae923dcaed98f1518efede1259decfb0374ffc7fda4bb3e080062cbf352f2c65b4b05d1943bbeb1f9c7fefe9a79dd4176086b95614e06f7ba0e2db43b2078babd0f9c0faf7ea6446c74c9075e3ed6476f2be8343bbfe5e28babd4f1edefea46a9101701e4f3f381064cfa65e9427ccb40699a9d7191b6dc0ed36a239b3dcaf827a96c4572829337328a2d4056dfb8300e2e7ca44377b7d0c548cb6615d1f2bdf64eb475e90b70149e16c4476370efc50721c5bdaaca978b1dd3f3b5aaf4a8da24a81d2f936c24e7f9f62351d0b4c7119b8d13c20b6cc3433d752ebda4d71bc23256dd9f2ee1e24714d0591db1ed7d665368b549430fc2be8f687846a1e224800225285f75edec8b46e7a51127de407428b8553aef5d2dbcdf05fd036e564c2d6e195505f41951de2b529a5126313a322b3951373486148e8172830ef7b7cf816d3b948798a22ca9eb37b684e954d3d1d2ee65df4a40d9168abd7d2c9e68c2598852c019908d104969d883562916fa12fe4ea1e7c8dc586b5ac266c1775d909e3a2e6450d264bf45d50f7e6568d3c9fe007957012c14b37aaf2b90ebdd6503fa74833eba63d4bfe2499fafe5bdc8df515af11e365e396a18a4b1996eb7408fa7c152b28bba286db748d7627eb29c9d1df55cbea2c4443bcffbe6035c999aa1efcb95086838756a02fd19a12add4211ba5cf38aeaba654a4a9a726e797d8fa1eb82fc49197e5fe47868f2ee588e0a8d4389a35dd6e680e42ff8a6f49af3ecbb740b62c6b48eff6b7b3beae8e98da6c577118fb74a62826c5b5d215d444f5a9ed528d841149f9525ece71089133fc2863fa344fbd958e39b414b2a0198b71f03793b9cf5fb4e725126e582002eb91230553252b52b9117dd73fa99e8d7c365e4fd979d7dacb3b07715492f8a005359f02774e3104e711abf8d1a39d763df44a2bf449dce6be749ae9598c56851f5f5b1e86a9eedd64f651b2a2da26e84b89220a430243c7f0415ec7c355ff7cefc1a544d60c2de81c6e6ef5651480d3d572542d88bfe31dc36a4b25d566a85c7e00bde4ac419f7d804a82e45dc5b3c65f915511a68fa0390647eb63a5569eee944c37a65cb0f1e56c9893396ac3c40fe378b6601d966752cee841955759ba3d9b8d109093867008f674dc933fa72012ce236431522013917684645fb9a21668ea4f6a40e4f8b88bfb7c68dc0d9250171d5f22949e59a9cff23b4b4543ded04365f706cc0c75b419ad6a38eafa9e1f5b85bd10674af78b18882babf4d97e7c09ddd4fffc7f586b849bfda897526af68b9aa4eb17487275acb0ed7bb91c866113c0cf74ce65aec290bbf3a5ea9aa6105d701917bc400e7f7f98007b645944a355c932078a3feb577f1117a143e649e368e0e83ce9cc0b97549fe61b3ce700009e94559d963e2838571b20adcd5ba6d43a19e687e4c69ee8564b2f75a9db9a6d840774e19a307bf2b7c7d36c5c0e4f523ccf7495f3e76b220e44fbf9e4ff1ea9dacc1a6f88f667cb331fb3274dbc26c38255dc219e728c358f6ff978c11d1a46a0ec8753fe13fe762a2a31020344fe746a8f5d4733d5ab6cb7b55c3dee6903302bbefdbc7eaf350d1eb14f3d1d34e691679bb074e37d0c1aa44f6fb7808a5a67f3c228e4ce0a943e7af640e0caf4dfd18407e06f7fd7f20782c29be631af9bbcfb6abfad68bb0400e94f3779e75aa18fbdf26b60983628a1b39de21c7d8269f27dab21b6d4df14513e4e36e413be78cbdbc6270817bda60276d015f4179c1299ebc901cab4d5071ce6b1a217d6e371171c70286b3bb4e3a40e40f4099742d2c1922ebfc4afdebcd57cdddbf812d843595968717e8c25ccc6cb259b11357446f431c0667d33cd41eabcbae509be81d72474ee94c3258d11a5cf0e7e5cd2eeaa69f4fa3d04f4577944bd0aeccbb49471c37d205160deb85b8c9f4a550ef5b42cf121aa7aaa7610b1f6d44da765dfb4f11d1eb816bc3ef2933954ab104507b6452b890e16620b408c42039e0413e7b1a8f2849c02dc89870d39cd9bf2cc7b4781ef1b0bc8f8357e8e0e74009bd319c0f0f70a37844c3c7440d2f4c24c237ea81d6676ace11a44255a24baf87fd8e032b52a2567e36db76792bd850717665ae48a652443debad24aa606d35147ab5e5d9ad14bfdfd2bd69bc62810e404a0db97f0f823292261a3d15f93a4afdaf86e1e7e7d34e929e6f66e3aa166b79dfa3699bf8d72aa9e88d3e937a8c5da25d29e2ebbdd6ebd495202fe65eb0563d5e9e6d4e2bc43889d9198d7db4270c74986bacd6b39db5b4274a5064a309dfed188d76a52f855bc737c0b515bcd9a169810ae999a0b62f13b0867fdf7d71127a07e1771d3499bce8a6baba268d9b9f80659ee85560af92a92509f7f8ef88abbe654aaf29a32f41ab4a008e3c518083434940fb9b24af8cead898b4a91b4443a8dfe6904347b0f88750b6ec58ed0dd357bbd6d0e2b175c7c9e0a95b2bb2df494d6ceed40b9b8ccba05b7d4488148c8b5bccb8db0645f6a8f31142df16e674b3e0e5ac08821fb687edd29810ac6f622a0077cd9d42cabc38bbc1b21a21b58bd0d1f8f2b227f3c36f481cf923fec2c346a360bfd9389fd60283562e801edafc50421bacabd56aabd9f38aa3dc9864d51b511443c9501dd9f8ae3fd1751ec6d35c092494167be4eb7c965d277988edee3e3e37aca904ee0ccff7176fb986a2137940f214cd0e1234d1a7cfadded498e001956364581f4f789e7ceb375b2009cf627e6de71d87a8322f89111bb20de8d3460717d7e8d829487fa2c3996c25e6e6966bcfe4fa9184fe3b86699471513013f060e19d046106302f418f09a210e68a754909994800ca16b0555e416b9c107ad3d1e422df77d04a19ee3c93ed2b0ca4a58cac4dd2217d527140f26606e78e4216d95c1ff177455d69008ada4ff2019e5696f95e622403e80fdf6bdd7dbc1e9185131666cd0441c5d293b649ab4c2d334f1edcf834109dde128fe780d0095ac01be6d55f50ca6d31471d61747b947783a801b862b4749db5e199d2c3f0548385162df40a758e77857de78bac834783c3920138fb3588e1e21b4321de1eacb6d07d582f0b53d524dbe4fe526a9c8943a0e628d6656f2768e6f6d80af130c3ec032bf75fe2232b562967f89168d152b0df869cc71d19a94254b9b0db8962ece85952f459693cb9596d744e5f8a13d1e9bfbdd2ebf74a41f95cc9d0d7aebfd69765bbdf519a64c84eb855f9577f1ceb27c34aa65b37b4dc06bda9eafb40eef40b4977b841bcfe08b87878f87ae287a47029a7a94e1e572e8f4e4b357ea6e12b7ee0d000d94bf7e428381383b4ccdeb54ad0825f60a6968381d8413b3a0b81211667dce9583037e12fedda8cc24b2226872cc9de76a7aafc1836bfe9f26f1b4ee6a432c9606c301641400c9fb9625d96bd92cecb14cd4393e53f599391e58280c3f2cebb832a4a98b7660b8f5dfb9d1623add1dfea4792b18e84ff9cb164d32730d86c810110bf7bc5a8b0a77e977975d4b19dc4f73791313da8d2d97bd994e3d3daf0167f97604641abccdc09eb1686e5673d7585d50a7c1bb308871712d150c9c95f857b958b9e442ebcf39cb13e151580341ec1d7cb2c7a7d1c22df733bf6b1b8656f4e1477c70ae2cc48d9abf3ebe9437cbd7f481c406c52e208e3dcab5faf6de802f1ae2355b58198f8bd6786cfb974572951bd66b0059cd1026dfe0388de90aa3da15eea6e502c326fff3c0524c590a1edc87c871f4fe274566bcafa226bdc787696feed3ef40c517a427b2d634ebcc75624d0ffe8973e2426420c370cd35c65958e371cb6907b3b12b83e6bc8457e3121ea3d178df5994c0d2b7c2ae744eccfa97df0334fe885f670b2c6a4d50d2109411f30be9eb3062b37a4aec1ad88bd4f2c56d6df993d479fa4044a75f39f62f5a14f16c6bd787872a3ee4bef280bce8e22bbaa93ebd90892d64b960dcc819df1cb458c70817e72813700ffaddbff3804550519e8d98aec446866fefbb2384bfdc5d8a4012e591208414f4cb98afef99f5599a54cf1cea2a295bc9ac3488a92e85b6fc298ed8c95be772805e4e0fe145297891e8c38436f8f1c90c50a703363f024ec02f2d39893d4c0385345c25bb70c1d10b3e87fec342f7406f30e68fe66be4c2d9026c08e979f22ece356714e8a9425a93bf2ebc520866807dfc61a1700278c57c62b6c52c6b5f2c681bce35a7e6da09e0343cc08b71d66aa4318c0b80c3c71584ec0f7190552de4d09fc9edd15d3fc5f6a0dc170e24fe9223c88c8f75bd97f925b05ccd280bbe17444fd9a7ca188ff64fe66f9e664d6202150d655099c4753c3078ed153a226181646ec840480c6e372fee2b7536ff295aeb08b6e18148d0e3dfd42c73548ed607c69cd097b5578532b00adb36c949bf732cc76fbc2f0188fcef447b002c963e72f5d717fcd80fcf00600fbc06eea2d5abcf342133cbc2e5ba0060f6e70561c09e887b74d3d057cd3c9def8a985fa7ecb26bb0b068b9a41a398a79818e471e0c2aaed47b7388775f95061320fa0f82e3b9f93109ecfeb564a9da3cce9ee1152dc81fe3377c072650306f328d002bf8a459d7f0985aa3284700758ba899eb5b02f897aa4ee43edbeca53d6bb002d9be8405d53aa9ee47083f9e2119647917f1edfc9c29b03db552554666f6abdcb52439da3a7ec53889955085b8bfbf2a6dbed0892c944c34616e76a28589bdfb1d50bd39a9599c2d82bcecd30f49c6a31d78c8fe575ae4f9005ae988d6c02082d738dce3dffde85673caacc0e68a1f871a24a572811c47b3cae00cdcc1f4eab335c0f37d2e2e3e15320a42482aff42c8e0ef475bb1f48cb47756650b740867bc047f610118ffa2184a1174c6e40557a5ea3bb3a90e7820b5fc099e8073d205ce07b8802a86210736aa6e3bc0e60a3480bf99f28786bb35dc81eb227f74317117e911d8df3986443bf8a6fb894176cbf05d315fd4165492069af8c20d46052b9614a14bdb0724fee769225008786984af230a50b49187072b496c7435723f8826ee1dac3adeb9166715126624f5c497d2821212ddbb66d3aca02f756515e1500b972635bcb7943474a5f3d475e02786105bc4cec63ba1f512335327d7e219755a5d9474a3314e2e9ee0fe1d7bce14604aff7bb18c0f0b2f36cb35c41c383f16585f5050e51032db0921035005bf437acaed9830614b970164c313862df68b08989b87250c119e4e81caa7f9700133a24e046456a4007dccbe338f0fef8ef5051d09edecb051a8b7e831f838e6b3e9f11d98be531b081d965963c78611c22623736f12733665c1e4eb7639d926e8ee5dee25a7532adf055d8829703d83f5586e1bc47d4aa38a5624a5caf85bd0a8d29c6f01dc1d8f7ea25b10ec30f9b126abb4c3e4433b33addc1b74c65e3466912106c851e8a285fb558da43c9b08f276b538a7f59cb52b6564a0976ce131db5129cf58b80106c2a8f9fbcd29b172115714ff2939534dd7107482f1aca7650c3a20fa846e2dcfa6f0adc51809842a2b7d8915dc9575a06f9df4a457f9b1c746ddba02080c312d74dbbf2392f3ad1cd90a04316de5f56bfcd4cc319dd8e0cc0d79ea514ebd0c1113eb8a31c19a7e3d5f70ebd8536792ed13298cf3d1b8b8cb1a0109211e3af6e005ebf3ca19cfc0fd57690769d3604977ba9a07de391a0b7dc1ca1eff1c5eabd4419c577b1f2155ed66d3d67dd07c16b84cc2ddeee28517aecc05e1c6c9a473c5a36890e553ab4af09b1c1bd130e3d95ffcf8eacfa61945818280128b582623fe8fbb62e0fbca8dbefff5c6c977abc82f464466509da6659a493458549d0ada52c3c588c3d1c2245a531788a2dcb6a79d725103b7965bfc66d4248ad55e25d639eaea08e28aed44a506dfa5426fab0bec26a8ca5a1e9c72ffda213ba00fbd59f41778a939355f563d98ab847f601a385826e37967fd85c771ed829c878e8c56097547c8eafe36a964533eb1c8fbc935c2f3d14c1d8069c0ec974d629b4a8ae6da8b809888ab5ac44d584be64dba4c18d915e1107ac0b986a2062e0a8c1304980088a93871f413f15cd4aa1e32a57e36e626c2e6e062a2ff67b04b638d3b4243e1cee1c817e7d1caf1901f3333810c937ae7e436081733723a74daa85eb6f99d058c78d89ea77504c1aaeaaef0100ecd427dac879ecade4993a17d443058a714be24ac82e8dd7319bdb11d8a5f19a7ded36de8933e0b17360b5d6f5631ce0676b7f13327eb3490c04e7babedac8b883141c9ab03cd02dcde8fe58464012d3d71019f3b957152076c184e3b802585f28de155e62ca6cde34eb58c6d7b577f9f536366a1dcf3f0331209d90cfc6df126faa37dfff1361dda8a34ab58e32580a9aaa081d0f9feb3fbe8068f401d4d6451f3af9f41566f9114eda59a71e8624ac10bece4b98a8c6318bedadc2df7ba14a3733006bd36253b6529b494cf322e86cd6e1ba6a6f8bd91643f21cfe0f4088402329f5d572d1fa960f9511df8e2ea3250cd693d06c834edd826d1b41e04b6d13eec9a9228f5a06613c3c76f29bbced8b948971f930c98c19abf1835611818a133148cd0265cc8ef435f5cd47b51a3980f8f247011934718558b61963265cded63a0a593cec0a3d209e8f9ac2f4532b563ff05d929cf3b1df7dae87773f0d94938141b5a03a098c4c998cd215571d1e3b9e48c378d2af9d0f260c8ab42e8525f73dc06607c8583dd15bc3bcbe7c922e8bc969b7a5afd80592ef07f0da4946423417f3c8b14acf557f330e114d665419b3640c709e618b0ab4aae5f800ff0a0ffdab40d6782a70a7f247bd15ff2c079665f7e4bb8257edde336d1b0e7de4fd05919f202226130b01c6d16fbfb630df84f0efab93ea4c2688d69658055a3be02c8f2782747cd76f79cc1af8096e402e7551c280ac28a2b91c2507cd5b4801658cab28a1db78a3b2ea5ae54fb75c9f49635a842d69ec66b040d0dfa4fa589606db4974620faa98d4ca97a970a852c4fff605ec673f6b8fc68f45aa3d3c939eb276d6d63fd218838c6610da27264b3a7b23eb712696d189502af402cb1a7e09608ea86c08fbf033f45ba0d867d7fad226b371c5cef8d714b721e631f39f686d28ade7aa4b40184ab5fbd58953eb074ada8d64d630e02470ed932be2aff1ea122aa94961bc7b68961893acf910888be598c74e5d343dbd0855f3dd181416a83faac3cd16f6caef7461739be6a7f8bc3b9db6b868b9bf31bfc0ff34ba34eb0c84257ea555e5bf43c8a30a03b45b901862dc5e9d42ac36d1315bc2d1fd10f086a355929ca3fb5ea1bea29e62fc3632071295cfc7507ec0bd946bca762b1e04495b4deec3091bcba821d467982a02fbf11df2bd9b7a9d54600537b2bd7cd54b6a4d98f503a5580d9f117dcfb43efa4b1293e93c86589efc68f69180dd1387fa32bae5936ce280cd11962bc6549d7dce493dba2de2b5f9df225fbb0f799ce71ce84c7ceb46a7df029e3df32b3c552123db3c7176478672f27d9eeaf20746d4b651a359aed20c9448a3ff2b07f447165286713acaa6f97f3c6347602bc5fff193dce46fca93c54185df4d163c0add703bb951c88e98b8899bfcb8fbc593e565d441449728d764d1185aadead7ae091ebe56c0a9b31c243039fcac0f384f70151ae274d253ba1dc90e41b4102405f392df4c3ca1db0c80b7ae17a6e9960467cb5e6e6b8d287f5820dd230bfd75c50c894c1bef0dcfb9e05d5727bf7f271c07cd97a0b49cc2ec94a435c3a111d96f1ffeae9c234c3067731998c45242760d8f3159713c5fdcad7060c1d9c474b4b6be64f00a2aea62045331d6236246fa293bf0b555db493f89853f573bd1bbc5f07fc4395f19e446d47ae3a0baccc880c45254ab4f14b7ba0d34f1d7e524b5754a8d57993e809af274f5681e313b423d00b30fb0876091c8cef884ffd6cca6a004e83048da2dba9fad5bc82fadee30e63346893e21ddd9aab990e6984c2061a51a6e5ba5c5533600cf6a57519cfacfd0c59fb47844fcc6cde613c5f2667daf8ad129ffa855be5951caa92f22a5b176af8f398ecb3c58ad1b9a0e27e9361da8c082cf218bf086900f3215147993b2d7ba62d5ad7196627edd5c70b092d226326fe11c27c4fe89985dcd3c8054fd49991b7d39fe95870d5c16bd0159b444b5c273bc510ef0e54b086aedcc6d5982dd80278f4c8c6fa7b4ce8e9d21e906714a2cfd696140caebd693bb928f5da289f27c7912ce2958c47cd77058acb29cc404364db22eab787ed0e85172a3fcafbe61912ae5944da0990cf8a4d45018efdd53b0ebe24825abd1eb12e4db31d39e7946be8f0f9124b46cb6ee36427bd38b264d18ee2869b5b599da13adceb816d8b71d0d46f4ceb4477015b0f128ebe962bd5c223988f31938b987d83360b91fc4919d0be5ad949787faf836d72bda43f0175de80c2193b452f5e9562953c3b492c571622651fafce95c175fefd47515163794ed605daf744dbfa05bc176ddc3751a4d74ad1d8558dc22d6fbac190d6a13b273bfe844f649a858e5c626f4958f337f5fb00ce851ad3242b46a2d03a0383a381350088ddac2d395bacbb2ee2babcc339213a2196280b5fc9509ced033a0ab27528faf688b51a32c7c0f8c6c89f10774c17fd5278e0a551b95c3e0ba8716757260e4cc0a3b29dd432239720d7d952f9fe788b2cb588428370632af5ad81fbc9dbe8f401a59ad62d3ec367f70533532972ed82aa6fd1aba2dab5f29c418ceebd90c8daae71c8049f687db85117e2a4f30868e8c5bc8327b3ed0a86dca6aad27f906c8cf2f83531719f25c87996e4062ba78a961911f5d77ee873a464587508e0e674c941d8d20fa76532c98197f6be01025baab78dc4d8daa8467ff6f889da9cbfb9c30b20f40465fc5bbe4c24c41bd20b65d5bea6291fd728b4ef23bd1bcd6823d3c63b93e9a08c7b3e3c8eb5ec5a09ac140e0a921a08aa129b6910d4ceeb61a3fdc453bd8fc61230ea2bec1233271b473a963f9203a6f6c3025786e13e75f81cb16f2a1cda881976e2b8b87dd8f879b8c913847880df45f83455d3b7e2e008ee107527a65a46564715bab5e115ea00c7276ed6126f5a8078577f72fed04dc152a079d5079bd1ba16f08ee7631f9e60beacde9352f252f6dc418f35fe5fa6c2e1856ff1e4dd86ec606a8b9b6507ce34d7f153831635d79315572d191bb3a2ccb87814e06cec2b7d7e1a296be0ccc15ce8e3573b834ce24760250c50d41edbee40ec2d0b05f184454e9670bcdf7c1dca026a2c7400a7b0b6d60a6bcc621ee79c76944ef0b058055583e73251e7445c8db7b03a857833edeb8365ffa72d0bd93c379256e14360250dd456cb222eb46550deb5a647d8072cb34b0be012ccaf1620db23f779f44059ca9520db452bb61a49171d29acbf117eb7552358ba0479b5dcb9437ae856e43b039c8b7ae731b7d8557e48d186ca3b68eeb9ee6d4615fb7a609e8ae6543aee8c76fc0bedb34952d2e14b281f960e22e5fc2b6c095ddf6039e195e9a39db283c4f0777ecfa2a01b78ccac030d046762ff88e3729ea93dfd9817c2c2fab4e80f859547a8a626bd87dd5a2a964d8e539e7de4034ccfb45d5e55042d596a95744ecaf3b553ef096b5a78ec365d0f2d0fa53abfe3f50eff29c9b19b13b20339819fb5c6299913a5442e791e4a4b34312aa923b7735d5f44b2c282fa09413d520ebd1f97446fbdcde615c86fe63ee5407a2863aad2a7bf2af275f1c5ee8bf3347533e7a315ca73870539345de82b6de9c6acf5d85d58848281e632cd3c1a008e4e769d8ece0cdc6420bba937a56eeeb810e732c18f9b8951bf1b3f6572812059415f5ff4b6664fcf504cfe69ecace6bbc573ba0ecd4f75e899f3213726e9dfb703242a5df97e1a009e3bdc5b1c9fcaec5a77572eb49beb9bc9ceabc80403fca8322bd74f32e132487a6cd237be539eadac847e8001b3879bdc3d03c3bc8909a174ae06a94bd589fedefae7d7cf67a11c91262eb5bcbfb3013595cdcdb9a5b9e040147da67a4821433bd78bd9cf112e6f3ebbff04ac654a5b2f409d36883385b2500c94298df2b03dc26cca5bc1de303f506af8037a5357877b847a50943de1af1b090c86cffb615f7c34e541d3dc7602bdd962190ba952d0a39044b4da9d25dbcdfb0ec9d91d41a32e1c86448aec41bb564a56329a2fd743e196ec13985dec81763425b4751f3e56d8f676c64e35379d35f2cdcdf16b5bfb0c68608058ba90757cee321c91b2b8752050f86141ffb327a7b89a88e7b9c90bfd95b1820e5ed99c22d64f17e4f17728a906ab865d896b732036e0f1abf72728e35873f453c4d9dadcff17170ec912a407f9141e1df5c8be52d156c65444fa1b693c1be757d4f7484aa8c79f85c6faa1f30ba7e845682c7f11546097f806d7adb3d1da620d4b93afd2ba1290c1bdf7c70b2429311f892d593806eb68cea681f1a40ea6028e826fef703d1611794883ba1a1d5776c4c6efcee1272140498768a983609f861158326274948e38394d7f1d3ae5c94215b6cf36051e689c20c8d0d00789aba9065a8f960e6f7042a3980dbfd401d010e998d6dc5606972561da4f5943ba55907f02e3b15d2f7eac994f0a7bafc5aa914acf2fe07b6860d8633e4a9c1cb9c28cb325528d1040e31f4fe7671260f41e4d6fe064e6ea165c4f7893a4359924096b63687f41c99520f41bda94af8366c5f18071e8dba52d29cb56cfe5aa9749ab98a5b7868e682be7a0495cc156233f60a57328bf831812d3c71e5c682bcc13f8c2d45f353164366fee2fcb77eb740a1d51c45cfcebae560c6f2b6ab02e1730e77a07272570e69367a3acdc1ae061253e415fc7ec1bb287b6d8029b7f4608abca66ea0f5aaf99e0976b785c942793a8fa234c1ce25c94c8b7f1d59f266e8fb2c779b847b57357a296a250675202d441a6a27c1e4ff194d3f39645852414f60962bd3a87843f4da71b87ab572c90d17d94b72ac798afaf94bae017abb1eafe348e94d249a1b95240884880176b0ced6fcb8834f75f881c2b20cb23321d0cda34d8abd27fdec166edf336032f80ee4dbd90f4f849c3929a2e401c9988893dcf6b6cb5a976cc5ef2e81e187aedd838021e202daa6e74e26c0c130f7ab8bad8bc26d84a66d6b4f8c02ea3b9850859470ab95d16672838be936d013b20a2769b409a03740c0d19d957b00102f001697f9dbe6c6f2b89381b7ee208163cf66e325bbf5c512336878a908eac3f183ff37fef62fcf04d420bd2577fe53a10b3170e389c234079964a5b47e542f590b9abc28fa040477a90446548c0ae26bff96ee725ff122d2279be793231e413ae72fc1058058d8a7ca3daadad95084662f4df3fe0ce1a88bfe664f2a691f09054ce2fb88af8f5b82fa8642a4cd974fa7be732d6c1cb2f00526cb328316043be4b617647073b3ddd94fa0dd6c3fb7d9896c212c42c2817577ee8c681605c9d17cf527185fda54fd2519a03490f4f852be75225fbdef7d7dd75c41603c27ac795d89fb60affad257daa5867e7d1125889af89440571fe87a7622ad8346bef1941075e32a265241bde69dc66f466a6a8ce0e3717b1f52c6c81d49f0703c307eb2fa68446d1e526cc8cd01b2a6ab77c81b200adaf3c1c55f24adeb67068606229d9a4fbdd1c4a0ec8fada67c4a7b50e3b957b34677b8203807aa36e991de06e387f1d2041430c51319b93dfa6ae13d9e2b2013903f1a4b2b8250b564b8b92c2cde4a2354a710a30494a68f5907272cfaa0ebc937213a6876ea3099374c8b2b19b167fb0a6a3e89fdcf27079a1d01c9796dd16cd0f7565f20c2f0f401b2e3cabb3c8067742503dcf87e35c31bbd1cc2a26772d75c89ce4d96a6f0820a26f7254f3d956a153f49e9f9f82cebde081462c10df0063b27cde3c3d8e4d2448aaffac918036443e2190a114110b2e19b633b4f333d483813851f2c1040e90b9323e290b33e0f7adeeb7aaeca8f35c3feb8c56dfbc0ec92b0d9a57b0e022d2800e3eccf5b5b0724b8910313936c3374f58894de862c91f684b15652d5c931697f98152b7daf907dfbff6478234018268d484a4693474cb0bb13d90e0fe33aa9d41adb9e16a2c06c15f759b99fdf66c37b72221549a586561aa3a7033369944a0a84c71c098cf62643edf0143cd09a11717de5b31caad221996d6138d62b2570c319c0914ddb16308ca70e27e7add2a244fc0e04c6f703b09f818a65ffeb1cba9810a67eb6225c2fdfae8fed0ce0a4124bdf6cab366c0190486f55d2b1d3c1c30a8cd54b2171aded4f3444673415b8ff24f171f1449a00c73b4ccef493f8a9cbcaefe067f0bb78daab823a77f1e42033860387076775ebe4d81d6b68a374f872913f8a242e6032006c80ddb3add351f2f47930a75ffbfd670ffde301d397221611d4556c18c651eb1ff05ebc14b216583beb201e42bc714441680484b8b903b7fd80680c0aa0179369e805b42dbba942df159c63bce844926ebebb2394febf26f907934ffe8165606e7227eea4ad6322f616a6d8b5a980e55e45bde9cadf82e19084716861bedc6c5a8779df4dd4c4f8d6cca50d52217b99e620248726e75a75f8c259728c92f7f1a4fc62d6f26e15a86c7d1a52eda3b27db8599cdfffaa59a987b23cbc8842ab4872dd75f2bcd4367d2a9d1ffaa9419ef84ac74ae5cd3d0e6bb80bab6810077689da6e586d1ba6ffc10b22531edc81b6265aa6e49a4223696f8edcc98db191239a9b87319ce1bcb7ac900346d69b91435e7c6c5f833a0357364112afea4e03004b4f1ab42de10a19777705b475304709c62ed8cff4dea75b5b663b42baa3ddf1fef68095a371b50de89f8cc8cbd8844da8c37e664f368843fdefb1fabbc815be0c11e964c1d727d467517971da0875063cc7f9329329b79b663baecbf3c663e4f91ed9690862f34a7603bfca52c21dd4b62346a5523fea99202e6b947691d3aef8b4b01ecc80d067a7eba040fa5135baec9da7bc91829d1e069d386e35cc3a6f7bff63f38756c1962b3d3949ed87674ba672f26de289c08592147d9272863b778973e5c7252ebfe5209327287e99eeb79d31f9aa206419e6fa0c4c4fedb859dbed2d5893ea318dd46ef436d850fc3670c5fa05e9eb761bad2d9bd367f3cbe2bac52d62225fbbbf0878a61412ec3b6d7c2df71d6fb6468ea7327d86352f6bea6d811f45cce3739e02dccf475db4cadcd46ba86e85a09359ca16e229b60cfbfc24a60ed26735a329b2bab6318f2d8044508287ec136a6cf00de3403a14f36835eeb7ca5f440512251bfc2026115fdc8b86fa31308d89f25c88dddf34ebe02c4a3d1a0c4bbea4b84eb7678b0a936708373cd9453654434c6ff4d78ece29c66467526edd1bf2838029935d38f4ac9d47ed4914ee4f92cd23cbc032ba182199915c3fe458b615bc9cff9b9fc6896286247edaeab97b2c8906213b98ba1264f7897c8f80a8db6620451d570932b576fd5944ccd4d1594abfde2b1283fed2074efe8dbaa9413a67c3072b1c6f59dc4c0aa25ca470a858332a89be032d593725461715dbaf469a4569d94b446264be3e540ae387f7a7f8fcfd87736906398b1c384fc4dc770706150620ec856ff64150f94224e1637017dc19e6e09c78a76fef326c1c06716962818111bd6d2c266eafa58103c2d12ee1ef05bf9d633ee6f236c8f11014a43f6ff0a4cc370b22493cc1c646a61509c7084820314624ccdbc7e431b1f148131ddaeaafc4cf2ba93352edd3f16646243631051510269ae4a541b9ccc41efa530b7b40b0d488a47f8a5153a90cfa54f2f1cb361f9424780d620944f2a683bd08ac082d8d0052d5b5980ffa302585ccb34d0607b5e472f4235ab9087b83ac97f5efb9d6cca7cd08da92904e699abae615818d1a4c232385410d14ad45193d85c314d7d7c8ee8ef0c05e49314074530a9084610d751a4ceaf37be96a9d0c5027bf461cce616cea6c56d279da8550fe03561f8ffc1f32f18f09385598a26527adf705d836bbd789dda1b99e0fe2b8bf327518dbf9487dd467b4a6c896fe3ad40fc4cfd8b7c9bc808a33858602d75c9eef9f643a7d2eefd672aac0851b8369617e38a8d116fc7acf8a8c290199f67d8a8bebba1b234c6cfcc8ae15caa61a6d7c25f1bd21ffba01bf0267314f0adece12fd7b6273ffd88b1192eecf26b87ea0c3d135d2acee4a45d760a8e102eff0e2cb6ffdf713e6e0c47c93d2c6bb3412aed77e63c53cc602ba896f143118fb30b83ddec2c1d06966c0ea38a41a5d1038ee5835c2a780009d072493e856b0fd00ba9e288de920a7f4e54f8e0e3a32694574f8e16fc269ee974547ae5ba298787bddbe16eeecffebc13873978b672cc88c976a05f513135418cd6af67ed18e48446776d1091c427f0babcff15967ab0a6534b0e8c6309554c639ea55d316193ca47057669291529fc9551a8f990c2cec12c54f9431b0d9fdaea528ae6a5051cc6e234f07c6ec0ac4700b7ebb5da1e561605b1ba9414e9020997ff30db790a7615392e5aeb69528b0080a5707d9cccc3971f678e2f64665280eb92aaf8ac5391c8f01af5254535c8534906c634d33d48ebae889d612cf8f27a45c1f99def412d6e67716e0a06f9f5b5ad53a313413e7cfb8f2835e14276c3167b799d9e83922d2381842f5dbe69b96a0d935d036f0f3e3ca4a3b9ab36228ddbc12449c6d5a0f963019e7b6e1839730049ff41a5436eb72938c692465fc2f1a9a488277ff0a9652bb1e676aef4cae06dee6819c98766a49c1e5f28e4cdbe368bf4b13a7f2795c034010fc112b295a9d96c8a3a45164645e64ab1c351a83cb27380e572f051cd2ec566b6cfb6601e5bc7a27a252635a4383e2ca15181f149c0e4e583c13bbcaec6b9f380e5d7e865d73d2d756f02982d8824ea7fd7031a68572491b9fe037b8fb3b7da2b883bbd415226a36e0c2f858e7d656027cf102ed8ed3f00c188a33b1cc0e4aa72d61c3644412b34c2d88f91654e1e86de911c32e622b38d7043f86fc9cc980fea285031510472487826b68f239439c5b5b6076cf591c2a97dc80453183c98b7cee5a32b3c85ee9b8579086da14c1a68ccf499874e772723a7495e8d7c25dcfe57804330fc5ef98c3d17467b5491a5e315724f6ba20e909434a0e59bc8b89f11be87142ebaeee0bc9b9688a9206ea837b3e38a0748b86a862246f3ef9549001625a356828accdf03a1107e0fba76690cec68721edc233949f0dadffa50c89b81229e4b0e39edd3301f41cdcf3c7bf70b8272b581d0a567299de3df4284f8013262bcbba63618e936d692218561ce65a08b39d453b3fe72780ae539dc6204618ccfeac746aca61eb6a3c96569a19a179fead992e78a55d4d80d869f9a74842fa784d6c188bb555002330cf27aa997ce64550389357b340632acb584c55b48257499db91ffcf17092f8f22e1c26717198761b604a50332e064627b3f8106f192ad5b9c27b24573a9bfab4d33e8bf3a636a7eaeca386fa86ace2f6d649f335062eca5190986bb5e3c63154a9e5bed0cf966150d6f4b04c608962dae69860b51be8736805d02fe24e564a0ec2e8b8371b4eb16a5f9be2ff4f17ec8272527aef16b919111503af913f6103f7ff6cbd7477a1c95e7886b55cda51f01425bd6c907c2023c94b1f85a663c80a0246ff3d5a7d2faf5b9ee2834ded6a6fa2895398079a94038490c6486dde0e633f263d5dd81503f9757655c23793e121dfd67e808f45ba99f6eab8eb223e5bc91787d92c60d591cd023ccef86dc705b2c708262f8e61517b601e7211d39f1d6684a9b26580e4531356d6afd117b9e6c1eeeeaf37829bb78459ee6904a83077cfe685759dbceaaeb2c67258425d4c73ac6a3c52658952b2253b132bd19d710ee4b0f966b0f016a5767bde5e3c3f42e6a4719b80ee5e1e7cbb9dc603e027fc9354860dd61ad6ca3db2e78a6f76dbb374894a564ad685dcde3676396e514552c5e5e27fccf1d29ccc4de701656a22a7a1da2e5fa504fab15625e9df95d94186d47f0735bf90b944453969467c80a3b7957785a243c05d63f3dfa41ff5e7119b2df68315451c7b8787071b02eba08377c18e2a8513e8cf85312e43a5199de3b2d6dcc27ecf9050bc7ceeaa3a6bdae35757370bfcd189c29f5a48173382fa6f824514cc0f3a1a403f288762f1e248b7b893cc43f5539756b67cf8db9882ad279d812d2c50cd853c1bd67bd0f3c916df44cc31789a288a2013974f73538431b45bde7340f3b575e205af5546bc8919285f0d5513d2bdf1a98b0f751846dd9a0624d5515f18a5a502e343951648f831d488ef61a8e72505b53892db6b711460076a4b2a555defdc2715a176fc370ea4ebfbfb4ecce29721520ca126ded9933da3f2864acb63d338a9346704959b69c52db8ee434b4e10da1b218c1d1f29c9e4ddc35fd878ce994aefdd1efb3c9d99b7b14132208de6eaddd86b7d3658f215faea7e38bb30f4a976556dd1f5c2226a436d9ad78485e62229fd0028767208d287c2072703a8d70b4c5e261b72558c4976979fd7ae6f32a5759f37102c62b7c167235e6b3e2e4d6e805e4a238c634b82419ba309673971906defacae9ce981f91bee3bf59fafacbe148fb600b02ca4baaee7f60159f11d3cd58545c0c59fea91fdfa78edb138fe9c054b3e5104066ec772768788d8dbea81a3b842983b1c3b2120325ed546d6c135da6f77802b4dcfd17861cffc12be97bbc6cbc4ab921e0de03e4bbb06fb34884e57c09546aa14b1b83001774ba71043ea009c20b53e4b96d88be057c2700e6159a8327b1487403d03d596ed3e5d00f0f19ef263de81b6f24c76e54f8d044b41119b3128e8889a2b5a0d71f20d705f9d652ab164b1bc3f1580c1b743e77d6963f2238d1e0ec7e494a9f378f1f778123c314df4821210d88b7c22de66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
