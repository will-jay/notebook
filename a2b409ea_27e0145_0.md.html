<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"142b1e8e2dcb3efacf595a78e9dde8040798109d2e89d88a073d6dfa0bb75cab5d723a284c402b823c6eb6923d946c3a0c318d50e954202daeb3d6678989da83f1e8a67df7ac1f1c58f0b033d7259fb60137b4c3019e695bee91576f23388edaa588297b96d2b45d8760f12a6b9841f2f50225f3f69c41846e4611847e9891ab69349f8640a6b37cb6a154325eaec96c0a0d6fd142a84fde49ab9012dde7ae18f69f0a861f54d081867c0b5b928c32805ee1db905cb13b7482793d70c7072bbde9f79c533fd73595c2f50786d042b8e930bb0c8f965609ab2d9d5c61d793dce2637759f2bf14b336a4943e8e628ba0fc9ff5d814d85a97f21e12763a009683fb26e2304dacbede1400ce9d6ac9fd455aa9cebc1774f4aae6e8a70345ba3982bf11915bf2f8196611842e587031f0fef8c43615861ab282330552056b6e76d2290d64c23ceee1bf558751bc8aed03256332c9526be0d4a4b003b5fd589da1a23c204a0d7d4fb0186bf58fb5d1875afca6e2fccf48ac5521458539675fc8e16c647d1708f87f1cfdafbeb4d5a43bbe9b63e34808dbbf84f14be68e01f5890347e75e114e41751a2a96d26cb690c3c29d95043dd6bd471b7263210635037206ecaec3172a6268b903c39d93b530e78ddd2932b8ed9207ab8ce55be54021f148125f720cc4f1e486cf8c274ddff2c3f34aa8bba127ca3f90ce1b1b89e8120b0c7144503d6b30e92015b36422e4b9d1227ea3a9db15336c72c503829294831104d5c6565c241ec32ab5f7b6f8684ad5072ab1b0e61c86c90576e1167b1a1b3c0d78c96a9ebac5f86dac2eaa6d2743b416566385fd05eb6e1641df550c8a19a327d4e880e463ee8a0bad4f58cbd60c8374cbbea4d7a01fff87be88ce09022b8cf60fabe77bf8c575170041daaf29b397319ce656c8dfda3e46d33309086fc3d3fdef4a8235b73c7b5c7bec7ca470d600237307a8e22ada0c155d1bf51dd6c2371013472be0658c264970732843f1715d75642b7672df9190c136fb11a27e8f50a558dd99305ccef1da06f4c040d2ae349a0dbccd62e235b7bc766c77fd801e771d620b0f3946c8a9381587c4eecb0c73cb2cfaf211344e4d3d26715a6b7d7114eaf38ef6ab1def5846bee69c86a6092c825bf19e0ab97e73e6fde5725a6cdd89a4edce9399be58fce0b50b89779a32e6406c9fe4645b9c94463e838b1803cb21b79c45c3e3700f30c6c09cb664b8ad72d473cea5bfbfef8c32298613fba8f27ad33031642fea423c031497b32d414ac3f974e05a13c578589a8215a5640dacfa826bcfe9a6135be4760a20f67b4409ce35a93797f6a60a4715cdbb065803d02ce9e7e4ac917796019b5626f609ddf0aff58f85f2788def8b8bd63745905c4a4d1de4a5b720bacee000215dd97f54c4a8408427db9b66bb5b320378f6722050028c70fb41ecbb3ae2420d8c4a3f883b69aa45ce9ecdda10df0df8b30acbe2c72b213c58ca14cba7cf6ec17d42c361d910d003972315285430e92d75f0226bbc819788736907e69c65b006d8f9dc46c349ebeb21e6f70f01aa264c0521de88e14b1cc80e6728bd5ca9b5204254806c6568ed4318f7c93d230a655e5c2a74ca657980c4977b29f1fa53f7edf9652876b6fecd609c93a6bd9f6f7ec3fea978974b98cbe63a0250a32123fa3b60e63637381cfb91c85e93e1dde7780ed11ac733df7cfe48ae7f97943fb59b4902cd80497c5f935cd3e7258a9a0fb2a65151d9480ac842e1f50a2d59971b138c593d880fca6a388bf11124933892eb93aeffb85eef966eb221014bc5090e58354d925aca4c65836a95c9f4de64bc929239194e1d80c35fcf79bb9fdce44ec60789a37a2269ff735ed4d8871da9fad9f0f994cf57dc502f512940bb44b9622c8d4b366fedd1cb922e170da1302c0df582663c9195c837805ed960b6c92a683073da7beff7503fd88196fca0e2a0ac147b4bbd6b01e53de2b49a8e8de91e0a87e4bc906cab2a11c32e348e8d122b8a6d8b1b7981bb67e577ef47611692713156247fa2985144259fecd9dcbef13b1e2ec955400b4db4fce24555dbf01e0a440df87a87645b75855cbd7d3263fd1a6634784010112e8f6a92e67ce29ed6f6d35785861c552553881be47a92341ce49513325075468f6b0eb3ab34a219f2168d59d8ccc806d4dea8c72c3822acf83d10676bf4a621b01f86adf69e9ca01fddf1ad2e6e88c6cdd2b6d6c715c5b26f2160803cecdefa39eaf08049751dc03ddf12e9ebed7a353009f5429b65196a1c2a40f36fa6f08318e8a288c0478e3acc3ddc0008930410038fdc97a0dad3e7d62d3fd4b02e90ea0be4135ba71ed005dbee2f33897b18a7b3705a28c1be52c6cd72e32f7d8802365ff4997105d109d09d612fe8604698bea3dbdb8e2af497b2bdc735f27d153ef7dfb4707ef31db722530835a96da0ad108df1e44717760f0c92145be2925391d63d6041f2e3c3c9c538c05f11f2c6a4cdbe9b15e2fce374298e8bd12cf6cfefbdf0f13f32a4c59d868e3a69e912bcd21a57d4b74daa308a499d12bc204edad78c43ff084043816e191ca838a4ffa013da657f3fecae4f7a05b500c5b2ba6530fe4da98034653eb6a1bb223f056550e7e58c11a7c0513ca768fce62ed0ff4349a14fc392a261395ca1acd4ba3c5a95599a6babb182c7f44b5eba1598b9821f47304926aa6f5b177c337105dea0b9117ce067d6d6d34a553e92ba8c1b3b1ee9829c321cef294127484546527c38544ba3adbc407b0d546e8c6bec3511b465bf00c1583dde08fb2d8632c5e02c1baabfb42ef01aa5f6cbdc9a8f7ef6de3612eab8141d642f3a9ceb6ef26faff5227fc2c99dba4f0d56580dde97bcf67e768f0dd615cad04981d35738443af4547f24193d9bb971065c17151806008de3a06b73dd81a880164f4813c922d2e38dd7f56df5d77eba2036c1d24b832a4f4e4b64ac1aafcd1f8e9afa31ef89cd63fdebafa21d19b35e3421c3ad0c3d4bae6ba2118cb6284c07a3ea1230b695a0d7bf90b16735451fb1076bf8c0437405308f827cc0d43d52d523297dfbacefea04d282102a365742efed3327eac66d61d0b5567b4363b6e112d2ef8ca23b2a6211acaf2bb74a08a129d2ccbd7b45de547b84744139c5fc092e4e790b41dc9bc2d22de40524f7c048e320cf8f5986ac5e06479e6a57d3d207e13ce907faaab8ec0d8ab8c0bc4245f2065063bb46330be22b38f33d67eb6d8a84c106ab611f9ec68e599ce45d9d32fc3cdca7ba1e8e2eb9d1d2831831b3488091144eae04b5a9fd9ad9f16eac43b9cd209917f6300aca8abdca69c7e8ced9b6e4583f9e1de45d8fd457d49aa0361e4e698cdc0dc7d903725ccba31c37ce418e641cca6c9177050d17e8a87301df2bb65c304adb3035eeb26a1c5d7c1c6d5401d9a710766487beb2a24d34533c4cda028f8c3b1798c838cef34ff4311bd04107e4a963078239d3ec8e8cd077c323cf8b296920f6b189cd9be71492c2bcf9b84e4643070270cb7e87f88bb1fbd1982f57b34741551ec474e54ebef5078fa038e855f92ec9f6408c1069ed8d30e93f8fa53ca62b4417d4c1ea5ca173a425e25dc20642124aac2b5feb1894455ef1b886eb81bb9ff0964a9375ed036bf7a49583afc43c35eb660e1f094806a3cdea33f531d3680dbd5a2ec8143045b6d4964c1eccd2341a1e3f9ca9da409e765f075c449ed833340a6e46dbfc884fc8679ba8aa3a799d0512181a4e6ab1596da7173042f297aba7ff5812893a55418994b4a33b2c8401bf8da7921a44ee5c05ad8049c02a04b9fc8773c4a601a3016b1b06b50c53d3adba781e5f7cb110ee33872269f6db664c6c7301ceac8004d342a80ba3ef0f094fb8b3241099689020611e84841cc1e2b1cd25e7cd6baa04b50fe102288fe7e093673fefd392654a7d1fde0ee6f76ae5f59789d2b1eccf1f530413afb0792a9f87980cc067f6512d28928b9a2380b68168f5632bd31cff3e8329a90cf5de7a90e8ff0013742179ed95b77a7382eb7eef0a6dbc7c6c9ee69cd9abda0e4a0dc1c55aea2f6592021f93bccf097031a384c9dad230eb4932ef8cba2ab21bcfe7aea68f822b799e1cdfe63d2188ddbe009c0132679c000e94423e0b4ac5e260cf966e39fe539a66abb858bbc0bcfcc4110dbc97c67fdcacc13e2d3f0f6815f92c104c245035ee33343b2a576aee7ff12b3c80f24c40a30b70b9fab11a8b252410806ed235b8e049c60ffe6e6eeadfe0617570df8f8d592493aee34741999fd6454fc398b1131ee0c8d1c83ed4446760c284a43fcee7dd3986410b585b99cdc39b4d1bf4169f1481b1f40953f7d75f8fd36b1fd8815e2082410441e466a2fef6ba6617b14e1cb21501e5c0e46ee03021103583318406c89228743db008e2906e66e8e6037413a62b9175d514e83c2c84b212a15df180358b1a7fc01d9df014c2f0864b4230b481ab5c2dd60903830373bcf286ce1dd675ac23d25bf0c50bd64e231b4077da8a2e3b5757ff7d47dab7941dca9a88881ad743a7591110aaef4e10513917626212c3678bf22c6c1af1187848a9ad4bce695c73973b195477780309faf4d7c8fc22754f1aba95efcd70cf388c534937177e452519b02b8d6385bfe9d3cb9a71f3d92e7898c26958bdda931d291a4692ddbd597e6c52f532dbb4d8f06607b520838df461695b2b924e4955b8f9eeff896c7063fcfcb63009119da874e32086a931246a374179fb05be0bb5a7c5442da9e793bac6c30d36d643a50438fcd2bc1438340ff0b781ef9cac6cf373b0ad4adc1ae1aac81ca0f5abcceb7a9d9bfafa8a60f484381d0192906822e5a25c14496b9cefa9e3e5994e97035a8bfd354370bbc633216084156c96ab17cf2144077f44566e59f7ac6a5a2994e913e2ed0961e2460750e3ec0660445faeb11ec888b182d7338150bb9486503625885a738eabf40d37992905c8891927bbfd886dd2d7d4be893e60128a998700e502322fffe6f7056c7f6e80b4e8e36c280c22ec103a40221a4cc70293b7b8a9aec48db3cbc59e4d5c03917acf3104dc211251e6737e00a1dd5eaab0bac333bca91edd2ed98f7800ef912bd568354418d2b85aae907ab384561d067120999e55a13de3df4bf298e4f5d1cb36076e104775f8fc1c7f4f221f8ca065e8924c5a801424ae103107912372dcb60d73ab99fd27157ecdfd22acf50fe6dc07faf44e430f947c420003189d38531665ef89ebf2dfa7e057f8b38a8b8351bd9306638f1ae8482713af9e3e90d952ffa35dc5f20221e4c6ff0af0ad6a5a21a5273a215052fcc9c2ac1a320c61ee5ec2e6798b243240d8138a3402e9da0e55676c5a6d4b4096dde216c1b7224e1742bafbafe505762667bfbd18ed25260c1964aeaad71733b9680d304948233592a0be2cfa2d6b7d27d5b2f9a48f83e8c935ef593de543e820783ff1a3431707d6b8719289c167faef976ac6437b10abe3f123f3471fedbc33d9e84e39a1cb17da5c5a7f8c74d1502ed07760b23b332fd1d292108bf1c14d9a239923a57c58040a39a97df2f7ce8e39f4ee0de86b4b30cf79308e8dc5bb866b7328d856f328e0403b8aa6ca4db04f16630123dedc1bb11d59f0e02e803b558db4ba437a8ac4cd0efa93106fcb2507d6ef270b071bc2784e159725ce7427c54b6fa030fd14df2f6fbe963b53bd1007e2f434af7407af527f74f525b6bf40ae7b322eb2aa57fcd5be9c9f806655c3dcedf2b3f97a902d146a17d3ee0f17833d9b47b84f841ed24695dfdef8c950908a80b1a9783d011c6409b0e7071d69f7b88b0abe2983602c1596b2813246a7d77907ca1cc2f4e5f900def1f3d1f2fbf91a655df4d5ece7610596bac1d00421350305934daf57f0f465de6fd8230c3af2248ebd4ac5d8e8e1b75234eed9c50c6dcf6ac51373929ab7e40017892d043388bcd42796a7f8acc26c4fbf8e012a79ea769c6acbe13271028acd22866e37dc4543e5709066aebeb9b4130e3b8035993a48175b0789524268efd532ad9f3fd7fec5375860bdbf461f7c3bbaed397f30eb4e6f2c9a0743d24a6226b1c771acd3cb5a77ce7908172bf4d6959a2d962cb1608069d0df79d2a1dada22456e52757192cc92b77332cdd15ce153820cae66bb6129c5600ee312f6da3914e434d54d519899a0698084fe1536568347093860d9eccace69439557706aa2cf24272a27bc92e77e2eeb38b67ffa85fb8fc7b672820b188f84da9657fbe092a63b30688b61c59330407e3cac47d198fc1f9a32d82510334f5c611dc5d10226f502eb047abc87384b448f53e1da568c72fe511b8959d5fe6690a75114bda8f314049690d8bbaab99d64660461a1596ad72e0c2bb06e9e2a87e4f497b3e0dd7be6368875345167b146e6ffa11994ae5c4a94dfc9bd03014ac05f7d60bacc3ec0e338ffd18607a9ff0e19dbb620158ac5ef66644ef2b5351af2a2175cfd3c9f737e39ba06e295148b0893539eedaf4b427f114c951598834c65b2a3097835b237c07b6a1745f69c367346875d49f92dc9219e61dd75d7b0b8b6084ddd2a30f29c4b746439b09a515b220dc8ca3697aa552864b9a0e9129b73ec512c4b682b340ccafdea1ab4e6fb89d503a3055205a74e61549a59f72af7a1e796add36cd8c30a90b0626246ba9ca93cec2b7971e152155197b48ee068062cd3db79c25a865acfc368b5cb0fa458b09ef17ff4c5ad5a2662d82149650398edbf4be76ea430b963c2e41d331767cefa3eb664c4d281ecb5942e144b3cf9727ccd81b725e456d4e7ac0636087222b831c15d559493b6cd0c3c39d7503117d1dc0e9ff5844f4ec826f53beca3367c4d422f8ec65ebc7077521113359214090f0633bb24af2482a68c8394ecc1c4d8edac95b911f552723d079d0b961b9c53d0c9ad60edb6022e94c5a6cf98fd4f525bc5c6eee34f11ccd34cfe33328494f1cdaa95772df80e392a6017abd6b2618da387abf33c9de2a09d01683000c06fbbc58b28c240e05ca8849eca0faee166fa346846e637d1b4658aca42e0ad515d95ff89af87c14848caa3cf0e37bacc641e4f6c7636445641040dc8954d5b26f866d7b7f3d1afcba47bc31d713c34adb7d1517c5ea6acd5dfcb008ef3122fa499690018936097f31c0dac3c47f740b94ed963331abd1889be037fb3d7b2fee32d44e72f075f6a0f29699a1992f588efa83d48d10efb3df43c2d6f677246e4829150b272ec922c344a68cfb253891f6915cb1fa2d6fadd9edadd5943f1e1042a44dc83bec13b861a204f88a1c2e16d7b2dee00535592fe403172ea5b0cd478cea63ef11132b53202b3d8ed527dfecb4eeeb5ac651bf18ae2997e2cb36b0c1bacec38de17b6975191fe6a8d6cb4f46d764a2aafb5db9e3c9c59ad21fe91e0f5003bba50951ea63fc09beea03d84ba1b886709194dbf80aa861861ca869ed8db8c62d92b65b10afec55b6f6aabc55cd73df5fc3a853d6cecb1490aa3af1f1d907ce6750f4db315cf39063e5cde9a7aa10ca14c8cc62c7a55fa76be2e2d895e16596ce967138d3b21ef4380b0371b0e0dcc743838c8b0b984d9c5d6194e8c039771f6a2fb9990f4897dc4c180d49a1ff8b4b91ad4613c1c6dd7ac12be35a57c9ea92b87b7b3b004c8147aaddaa79b02e0e087c3268bc2385c897ea037d8b089991b391de520b779aab3406a07422adb574eab6b3fdccda349f195a434cad71c996281369cf5839ba4a404dcb2ab0352de61750b7d9ba2641bf39a5230bf96be1fe2430fe0348c5396b6936f3ace56e655e0951724b937c61456c321f1291217fbecd7a8cada79f1cd8eda721ddfa9d10dd7238349966579be2c1a1c8f0b2a9e56f7675c5b638b8be469c91f0ef2997ed272a681f079093946c7c1efaa04723cd9c3e727f2e365bfa07c236341312dbcd157e9971d345f0e76a1c44edf75f2a526413560c79aae1d331f99e58d71554c62207aff68af28ff3835dc6b66f5402f3d6de56054579d91891890b21b4110a146a1f35d1ce6e3f764b1e8fa37e5b0fa008eabfc2477ee4b249ba490ec69607f727f7ddcbdc87f59a59fca5badc01df37af3b0eda9c02092c6ebff6087eda955bfed4d74b0f1a9c777c8f485c02022fb554578142050a98c5f969277444d7859bee17c0a17f1fa5b62fcd5c1e72d8c78f117ebb107fe74e16e5908c0aeeb1d25a7791a91e5d8b55e5a5696b5b2781ab633132d8f5739a03a2203044261f6be849017666263585b7c96cb2563f0d6ec71b86ab6379da3937b472139b7f262c5544c9d81c51305314484f1edb61023fea85c8becd58823393aed43efc63329de1e7bf6eac38a00301ff74d06abfa1140349882839cdd53013a97d5460928a905c60671adb325408f4f1728c546cfd145d66c8078173c4406ace79d3d14b308d408ec6552fd6076cc38229e2b46e39aad6ad1b83ad57b000e703ef0d350ee74e79dcb6820e5671c70d25706e6b6c7d4f2c34d3366cb3e24ca9f814278f889c966c2c0f53bee5b61904d382ad6ef1a049b6a08c5884770e03b2f5026b7249cb778716e8b295e602f35e559d066a7747d9429566417eb0450df9237ce03eb8a7470f3a0693f9d1ea66ae9597b53786e9e53182cef15b270b887a83610b4a8bfb73ab5f2848156175962ff6d2969dc99657c3da35d94f569a14969abe375435b6993bce221d1c563aa278703bc6622bf4fe430699b1090ba71329c39609a322a9000e032fa738db3173b34578dca88128096f8934eabeef976f8370b414e469ef6f866eb6476c925abd97176626946345585b332796a2664084e59a1f797546d57692497e315247982aea4ad59c6a6c69ec04da8f3937b60828c38d2fba647eb78a37c104d7ad7bc46f129c76a78b93b68b70452360306e412023aa381a8f81620862e3a89a281549b76f2fc4479dce9438a6a2cbd37fbdef4062919e04b2c7d2390d9d66eee478981459f3c5e1676ce0ec37e9288e1419d2599ce0c00e8bc8c814ff112c9e9fa141a15b9df3798137845130afba5cec0b9dba33d5ef1b31d0798bcf2804dc3668220888b9f63668b80ff703bbdb3c9fecc3c4c3c08dda75c01d1bd1a0f73a8e6b7a1882e4a5e35cf06b5d975ece05e8b2ceb0df5301df613049e493624507c0cf0ee3a8b1c16575f9babc986a21a43982e6ff6568c8c1169dd899f7c9a8d65ec21d6163354230496807ace8c055ad9e71a9405004262764ff9de9ad4d388b167554689ff3dc1642f7a40c1bc376e358255fc8dc845a354545a380b481592a9fbc59b8743256fb8f73c7acd3f976458a8d5967ad97d3bcdfe71cde28ea5eca70fca86beea11f07cfec405831ac4b87e80bbc33e950f538c56f200ac5d3632732d7adae475c9a4970b8dc82078a2c07611b74007858dd0e82746cec1b235fe7199aacdf7e5e1d6bf8e14cbcc9c0ccee0f8c5c975c093360b4b8c7715c88f87c6d61a0f1e1636d97e77e0392f38e1a2b2169c1c36f3a9abf740efee0730271fabe9f2b903bb592b7c78f5480ac7e648c69e1fd914241554ceba09db7bdb203bc5098f1175fea5071a1e0bacc45b98469687b84ab8cc7ad7211800e5a145cf7e831dbc13aae2380768dfafed66fd0ef6d443ddd341ca018c5af868ed9f1a89ade03254f1eb32ac818a189dfa7b9534bc411ca82614f1d2559cba7fbe80fe1b36023d9d0a2131811e8c16824d61d07ebdcbd76be75853f7db12797e0262dc6df12988db9b965fc3d88bd9eb419a1040edd5b98c90a7711cb2d27874d26824bebd25e50264ce0f140ae146d76dab5744628cc01a13c98f6e8c89e4f2a62fc90cd23c353b827b910c17f4e8be10c7abb771b5f6ca7f2ead981eb23ae372164a6ac53c7645876abd7c09ef5a2a3aa9a080ee505587bd7f16781470020a2f35c7b4f0858f4268b401413347d7936c1bdc9904dfeb0dcecc23bcee7d162cc2168989c2362e0c3925a9caa7217b927caf5a41a8a3d35bc4467b48c0fe601f83f3d6c53fda734c8a82b1904f79399b3a40738bba6a1299791597d0e1872af78455c130847bc4b535aa2168d4d762b5ee3a64f3337343eeef2a48ae2cef69c8d03694600b7c32ebbe538bc2fe3c9827457a828a3b01e72e52868245a15214114cc6bd937fce88d6c1301482b974d8bb3e00a34cfab84a8178a669d46d7e8bc3727a40f8247a9e8c1b213f0997038857c157e7187dd4cf41d63ccbb772659a9bcceed8a8449d890a0b2c049f786382888c1a4edcac9a1df2b78ec57230e2e0046a6e75d48910fa69773cdb697ce4a3cccf90713ba41eeaed0c4205474e9cc1884c7b46f1fe245b97a8b761175e7664398518bfca69e4cd0c4d4c176c8e0c143176eac5d35cdbe128a78b31d4cf735a05ef623a3cd6added9cb5c45f0083934f809450ab17c53e2f49a1365eeee4028ac354c2683f72cadd0971325a5581102933d7e0e855960fa4dec1e9e5b164fc975d90129ac86898ae0c5c5aec73a7325b24a1fa33e0c23ad5923695fd7b7095222de0ab64ab0504eacecfad721c5676f9fd54f10c47d2fa76a6b4401ec1ca583d7b4d4a88c03b030a95129d7052e5259db1fa692128d064528a50bf597b96cd6d4d5357beda0a8a369e74e48c7ed862e4f33eec26e4b1afa86e9dab27124c3e48188def5cb1e21eec0cf075018db2e6c44790c0ccdc9fcd6f1d2a1c460a025c68b23c2c9962c23e103b63592bf26814f524ef3d06bf97a271154978e5f9f2b25d62d6c14f30f51c47b60e3c0678f2337d594fd1529911b2dba8938fcc13ff613917473cb1435493f5f0afacbdb7b90190f25c8f96894d87fd0721a9ee98e1413e445ad10b6085f4e31b615f91dd6b30476c901793d68b47842dbbf5cddc869ce82c448b6f96d8cb8f35f22369c1a550f092d3441a06e1be7d6aeb7a434757b4195838555d381c115327ab494f42183e694bb77a2cc34672e437e65977a1f1b4c1127d95a9fd9025048f2586f0f620401275248da0c91c603eadc4d6d5e9b799529796d1da8e97e18cb186469bca8512416aa0a67a0e2ef7871859f5c928bb58c177a55629e3857f3d48bb885eb2940f9a717257b9c384f176308ffcd7f4ccd8ef9c46aa992b1756125b70f1bf5c0108445bfb4b3a81dda201b259627b280d5780e163fdcc6b93843410cb8b432e7613c421e7c058ee76b282c3631d597f886fd5e0e8990b6d4d15d99556dca05ab9659bce1d30de900f2264a28d5a0d1b8f20dc391559ab2f98d681f7822a1613c8de7e53563457ae616235f31013da7a9dfe530ac873e47c2715a5041f15e46e560d09918b798105b918f79fef1362f266f0c455d38cbd8d6d72d97fbcaad560e180c8863f863fd5703f4eb1bb19a0a2162ad12cada55f7f961550793ab9e1c71b44177266b7ad25995809a5ca9fa1ba78d6f4131d81d4a3398992b3b2cf9f293b25213d38415eb0ae2591908a6f4f87f17a18cae5b7f128b9f516e08a76b2ee3bd41dce42804aeab4d435387cbf5e36a00ea22e59612f4c07b95d342fd8e54b87f637d1ab66b73aac7b51c61e053d1a77e17a02b59486913c561dfddf674877681085235ba8b940446b7b6b91ea717be11aad219cd29ee838a658be2b04254007d3d3317a1a94709f4a484c7f1fa0ddea4b3e87b66ed4ced1982a654f5c7393db1f17c9201b2bb25ae6670e527293664c29d6211789ca10e6a5df2be0bd455cae7ce33b0c7c4f8ec9b1118921ba430e5a134e906188148896dd74331fb32bca6c49cfbfa2d5e95c90e256d729d7c309fba8bfc4abc5750fc577ab9fc902f10b37da7085a8db7360dd884460aea43bf9bc1c62cf58ade5483b943d8aa895ed6231280954186db64270524fb88a6e11a7173645d4499a7145ba370fe288ca7bec1150a9ff5605c87b48261a7f5ac9f5b74543786c1e8606b6a5d4a0450a32cc24d7a61aa787f7a014c86a56ca56335737ec9dd5fcb41a504b71980abb30c0d97e477162b63567c047da1293cb24ff5f7c76cce081c4e48adf450709f73257be48757d534e7281cd094786b2edf56049834428a2d66b631ede80dc74d6ec06c8ae9d79146a30c79920ebd38cf9524f5e02f1554a0918f8a2a49c2aadc9b9c21fd56756613f1ef5ea4bef803c0d211bcee9e85bfc562425cbde1ecd20122bc8d3406cc0f3c0f12206ab254b65314421d442d5dc9a1ce3bc9247e0ce10ae8a0eea472dabf0c9590fad8f8f57bf87f469e3632c78e726e7e1a3786c1d3755a79cd98af8946b48b0988b36c37bc57b7876ed11ee28f921e91bd11ca8cade7717fd1e429da754ed163bf24bb7d60ca1e016a76004b05f6a3bfe2081816887452a3a70ce1b63c00dbea85953fecaf2ef639a171cab2f358c34329a70633d1fb7e4c3da8da93ecf416f2a3a688fd36f070c3f6d4192739daab32b75c57961866fa654a8095eb534df86ec5255a72f0f66d3df834b18c0f77ea5a147c4bec16b2bd334ae3fbc797168b2f8ace32f873e1862e99d744946fca23f6828227ce1314c1f108b4927450fe49daea59dbbe64f5de8897bf718afcf78497ebf68fa66a4eeaa934d5d213c93cfecbccf340db947e6baef600da431e68ff810519619311891f309e43f13a2d85e568d499a01d98e23a54fea15814715d5e51dd71d8da472577f7293287baadf2f2ae9ba3d9f81f121eaf3643493420b692a16b987b9950ed91c870b2438bd936f42716a92aa61734c71844d90ea19c51410ccdb03871cedd4102c37d281754171080740f8fca4431c1056ec279a786a0a9ee72a77cd22fdf7c7d8a4b5e8d91ed26ff9b68b04c9d27c1c8207fab1b6af4154d4354c9a6208144464821b53240f56ed821e8426dd2b8c69c710891232a9776e5d2b8f4e653a3e194f92f296c5fe2c606554baed40c5b8e3160a28870eb76996cb4dcd34fe34c1888af983ce25abdad2ff4f1f353e49ecf975f0162f739b3d513ea5bab44583375b60889814c38e3d8098fddf41a6084624a829b31a1a6e717cc9499803ba711f2fabcef8d079bf293022ce837b884ad7c0923abe40da3fc5224d4b780810ba23eae23b18090a47a135eb64bc0931422a3f8f9d2dd8af8b66b5333f0a8614c86ccf0a9f4563660cb20365318d5d10b1d9a27157c8c423ee3a41bfbdcf7a1e7886cc3e25135fe5d5e43a307ece937a0dda4512c533e934a7c38889249b7d1831a9478798b0998567654d1fbcaa018fbc039f2ffa680e800dc8a3db1332cfe8e81cdabe6d7dbcff4767820e67238132706b656e712225338fbd93dddca36bfc3099469f17e3c9ab7d918d535b3fffa700b79462dcdd9a663aa1596a04e5c06165d421e3b9a9e033c56556cc25a76c636f733307ea1221f364dc18d4093e8840f93c3eb08a0a98341a7b597fcac0e11a26c2788f8aefd5226f7d06add656013839d3765843745aa0ca258fc54e3b6759b8fb18f4b4040691511779b594065c8fe9ba64c14db63808ef0510fc6cf8fac12f173e4fb32d804552c6d91b70df50db690ff41b63a3cd230a0c9fe4880fc43215d11ef3e5a8afc16bce41abeadb648f66fdcd5b3f27d2d16bf1998dc952aa75e277735d82140e1bec79ef42939cc9164c707b22020b51fda464d71512db304d88bbde6d8f59e5d2fe1abf8b802c2c930cd5f7def8f2b6b6ee9adbbe04b6fd3d727b6a44f35c7b6ea4712dbc75870d55013b0362e982579bf0cff7a45a49ff80ad21117eca4e7df6e69fa39f9ec5e185d4de7957def89200cae9c3194898920d5993ade679dff0c9ad2412f2c2b97aa0965fb23f62ca1332bc8f17a36822c66485b4b4aea0cf99c0e01a459c620cdc510ef380ddcc23a2c9b1636721873b11685ea7720e30a5d85fb4e33fabc7d9b51fe1c2ab3d3ef68dddf21f8d40419744d37c9cccfebb61b101076d6172b1c1e91a6f8023dc9d57be99ae9887cce1c6d9a4492d3adbeffd5491a129089f4b2b45bc66f1d5c280c5f0c5774106a4fb773c1492b6afdc6a93327671b7f62b3ffde3f61e1b0498cfb78dea3378660a39df0bcf2e8b7bc5b0b5b54cd684a1d76804a2f1d32b853188410b82c88a2f1c49706aa725548d512e26179e4eba402a24cb06f7cd414795a60856dfad2678e544da8bf26df68ece13fae826b856e48d38104e60feac2c20a73ac3208765748ba2046aee2e871f78a753b7e00cf0d1d2f419141a2c72ceee97ecf8f2ac103af0b73256488580ea7188e50619db2087a1cfd3953454a0f19154bb143137afe4317b82c256973414efc41bbd1263bd08679d111d0a244104212e1691aa652cb6652fc15e9336f2a598d9a7f0382ac739109087b86f8d12e6cb1e4debb6ffa225117996882dce62fe34cd07b7c8bead73ede905de875cdb9d878d6a1ea963250b72352a6a861efad4526d2fb18718b0d2c0abcbaefad2b18d415ce763d277146c9a4fc07d854c2af355ce13498e223742f41ac1420b2d1487237cd6f4303b39b8ef0e757702b1fe1469e7b69dd236ca8cae0b229abb53f3303de214acfe14eaed71e5cf93a819b49fb7f4842c715ad159bfd3fa0c8529e99b9f257b595901894ff94b6328e3c0e7a7710b40af9302b2cbd7203f5b841f1a103fefa77fc8b418ef041fe669c1f144d25b49a2a9e1a5308c563567caee883d16cbaa346466b95f55047b494109ee35a583ee3106994251d59e9f48a7d4523e51ef545e1b2e1df0fba697d411ce746dab9e09e8c57986f30744a94d2d6d2fcd90ed363c4957cdd6bb0a13da7538a67d70650037a8cf476446f9383abe1efb8d3105acb8ff7a0a5e783f6bf1f2434116a958c152795a4b1b27ca28b99a09b42acb84e254d6dbce45d86d0c1d38c8de7d43e67e623540c331434f64352804c9f74e7c59c8e48215c5373c82a80ae78faa9c2ac251fb8d3ca403b5fc15b978bb7f049bc683d85de6f16a59aeaee8359fc4e4e0dc7737bbb218c8fb805f57ab25bc273ef001cbb96666d5d0d0d8943e2afb5efa49811c5757785bb8ff83a9d8e7c5664ceb0a82b12df6bdef69597b3eabaa46d4fff32da621be2a305c593864e06f573355c678550a99cf3d3ab5aecde986142919ace0fea1ee1d7cfd33713bee4b5a8233b0c425c5f25f8d0a6b5e77250159c9619be66901b462ee234516a1a03fa528f71f9770eba0b57eb4348fa7b2d7096b3a530a3b2af48b0b834a3aa4d97a708dd8d2a8820d07d8ed95f89be3841877db991b9bf4b317d3b8da581c0d90483de60fcd12f1f1b77d1c61383f394f8a76ed6ff1c410d417461f9366f9ee2dc6d9788abab67756112ce0e10e407b58e0b26dd537bd0c6267c09e2685cf1a20337e0a682b3ffa8220986bd34d48bb18adc3a03fdbd95831d7a6d5989f099c4ca10f0eb99fcc20ce4ccca8c454349573a09ba963aebffd423884b40c86e687c86ff1956a1537187d8ea3fb7ace724585f459714a3d75ef55bedcaca77029a3de74920a0c63df2634d9b6b83dd3f0b6949a2d4fc1905a451a4ebd90a0056c6f963d6bfc9a1a7cacdb5847c9f883d68c787d53906b10c5c9b55871635d2e8d2c90ff826d028b515419e93a75054ae12bf1389fedd3231000e6a4e18e68747eb811e4d9a498a3742475b3f7efec44bb32d32a4e708bb2bf4108b986c3541f9637aec8ea96f56b2a22c98984eb54ba18eaed1ed99454dd424fb2045a004ce65c3008707e973ab62dd2723c6eb2ee0142d2e7e5629b6337d9299934327a1bc07e07f9b94dbc93299773926b6e941bbd079cdad0a571369f3482d71d231387cfdf3790276dfe4c2a50e76c0b111fc952ea9be1530af65ec5941bad7169d9f52c5cc8e2c47e778ec7e5f8642136c57e6dceed5f1388c5947f8e1d1f5afa37b92ede8c080103baca4d1c7dd82305070e7da279c07e70552fb3c73fe8913d752859ec4d84c0888ea7b02b0e13a77698eaca4933f0ea32cf40f3cc9a42a212bcc686871e46dc4912f94e3825605f347146dd1ed29fb1c2e7c38087d5e7ef254b62c9a3a3776880df5312480eeebc182a5331c19685d066ebb9ccbfa416ee6a339d5ecb4120c5e111c5fe1c301c3adae7161c2db7cab56be4128885b80ffcc19b0536d8a675bc14776f34419c19a1d2d8b95bed9e7175cb93e0a8a2d09e430fd14d8ded0ee5ab44978f69cf9def98f7f6d898456303f4ec03d5db4005e7f2dc736e577392d162d733f1044383a2beabda48638103cbd76f194856257deb8315cad8da61a04f2c79cf13ba50155a9c97f75efc43bc09e46ef6b8110f029f7556e680b6cdb17e57689d6255eae78cc27764fe59622e0fc0627b9705371186121efee509c8dddf8ba43764c69dfbfc650f03eecd84e80b4abd28175a1e0fb3e33f182fd9821513d914b9ff04a960593c326149e0c9c9321db72c2a205a9cfd2b9b526a5c205fa21e8a85c9e31e67aa7d6e045d2fb0f42c36eb65eafe790ebaba10935a8042b644fb62362ed5a79599e339875f9b664eacdbad1afecbfba8c22dddce788180d86363037fb14518d0cfc748b631e8de0d99550fc53d16f91e70a26794db73c2f7c085226d924fbc6403e6e250ad049483d002e3d7c24c9289a3ee69b3fb00a2315b198f0cf01094f7dcc5e27e9fe8e270a589bafdc35456b57bce37920729390c3842e9800cf72faced10bacdde79278562775915d3854557ccc53d54276ebc82c7d3799ede7c39c5eaf86fcd007d2c4bb9a22f75eebe16b38ea0d4cd74cce973bce5907f7b8b9371d958a5b2602348c86a60b5ebe9aaa98e3e680d85bd087d19ffdbb739fe475566e42e35d903404f00c224b5ff23782ebdb81bb18b841605e0c6888c60b827272858be3f6736f08c0dd6153aae03d6c4dfcf96a66dd156af02b72183591c7426794ee34b2254450f1c5acfbcc5b1ce2501b5c73419477d3888515325bcf1c77d9354149c86fa0a7c44b0a7a36d6ef934f74eeede0ebdcf81a308ae7f56af68740fd1303c4ed737b4edddbb3f7f22d1984a9c23715426e89d03ac68035a6609072c6e334a39821d7c0876bb7f5af68e38eb6348324dec41345a44eb96741345d0999bdb645a4a1f85ca6f70a373949cb7008234ebc6e1591b6bc9ed4a1b0ecd3f579746264c06f1ab47eb655c6d5d71a6a47ea7fb3a76963bb8fbe061455e6efd9fb24b975ff5d90f9b234eef40d851ec382755e01324f7a21865b93bede99b9c030a00a64d49d20ba112fa35237663df67aa9111ae9244970a524aae04e3b363064901daa39697107f7a0fc30bf5db24409de4948dbdeaa099d96a2fe980dbcd149d8f24dd55161e4b3d1817f0e71e07a8f29bd690cc86ab2ce6386be264dd409f46dbc99675810772bb6c14cbc3505f0fac2a2ec073c26bd3e1932228f24c7c73b1e2bfc240e9e130507838ced8a8e1fd0f975434a8407cf7edc441e67e870404b92701d1aba73a5f271fc1e48b560862aba83b5781fdd069919cff9307d2c03cc1e06b7dca3384d834fb82fc4e6429d3650a09a2a5a824e4ea57aecc7c3fb528e03b3df4395e06b91949c42fac01d74000bf78193a365773307341f0cfa8ccc9dfdc2e868f0d6f88fc7e247783dac32681276e68fca12746e86e685e847fbb7bc492a11365c4121e2a11c812583c1b5a203ba74de11043175b3b59f12dcd2e59b58e7f50bbd3dcde8c62bfe6ee84d183940bc246048b097fdaa7667a019c0a564743c9c1da372557b34b297aebd9dcb64a97cee4a3d915e72e4df80f123804746e0481cbda29c467825b301b681ad34df893beb8f21c4f97f22a566c477ae430250f73d2c4d2f1cbbee59ff9e59c9a381d94900394735caeefd876c78fd9a429807b9eb08e749edac63c668c8cb7def6681b6803fa1ca251cee1685dccd53ca7bebf87c2e2623894b079d77d79560f259dfd3a32221418df5459b6a059de5f9e4c134a91c3bb2cb27e3176e6c2540519d8510c6e7d6a56e9ec334092bad174a05c1b047db114cf95af2ed48e8a13b406d15bd51787598fa7ff70f7f5fc77dfaeeecd81e8ff621598168fb9702fa102a9682b7097ad5a180c32ec5b38c844175c6de3ecd7dee6683dbf6f2999e265173774fd6491ea536e34c2d5c9a13a98d964d4ed5f3b97fb16339be96ca000a76cbf1f4a2fdb2c4628e7c2d8e8e4ea9c325e598127fc221773b9d964b82894b611b463bd2b6f0c27cca13d86c67dff4a35fa97928edde9411c063f47198765e73e4d5e499256d07a386387505dabfb16bada5a17b68016c76ab145d286c086a3637f3e78565c0151754ba3a2c758dc5ace39853a2935db0138c830cf19ccc15bfea70fb810a1c9412f4f4eb0cef67f87f93e1483a9cdc5872abbd0caad08ecbfdd0e927223b4e22c387d93b96a460d07abb02fef84b9bd481f4f776b0f652820bfdb9f2705cdb1a5884c257645f5eee96391f7c296a6ea7a0af20d6975b1128d23a0ffadd003c897fd214d5053246fe6a92f281cb171a4f41b32a8db349520ee7955ea242e1899d52754b0d5e4a6ad396f414d57a3d45ddeedc7ffe0305d1c49644776eea40137087d3230f3fbfcd63e8d391718c916de5bfc80c1eb74331378899ceb436334fcb10621b61c1d1d7aa078220961cb7e4401be76834d76d2e1c29e4ea59b97972d4657158a95d5a9f0783ad45688dbf5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
