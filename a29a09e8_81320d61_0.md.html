<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa3a4477502d0edc73ea98f50171dbab97f7f856d922cb4812b54d4a38a6d99b3c1f117b162d1631956076480809ca9c5b743b145c4d021a693d73d7f7ad079b2d09b46f28765ba096480f278dfe63710acac32a80b6843699fda4a84ada7bd04280ebf50cb9f6b9625d6b9a2702813d5418f5c3de77e7fcb763b20ee25c3409f6803a7f29d5aeb7770d02bdad485574c0ea1e118c4a63f4c4447d129c8a7bc4e39a05149d1755fc28880fa5472b16654dab333dab250fede5d144fbb32bd6077576a690179da0a57bcbdb92fd06c51fb917da4e88096d58c32b3e4824c166dce5cacdeaec3380daacf8fcb6031a6c4eedf18c1c47c00dd9a27839019cd8d1a57ba07a43be197b1859c21a5cdf56380da70c75a15e7739ea964fe72202f01f4ac8fcf2695e5af67f737c03315a709e12b3183bb29a98a26c87fc8091804bc0fafb37e89b9ca0e90e421d5d1e4c363a30782049aa6c1221db6ae10242044aa13d90ab6f8074ad75cc4b550d43066d0087f19958f92513b87a192f02ddb0837ecb725b127bab701f63a661b7f2d21b4174c75f92759ac27babc75f9f344fa6d1c7dab875e8afd2aca1621a10bfc65a456139ffe9501794d33d1c08f74086d4e7c795beaaa6b09eb65c49498fb1f0f1b7e9149b932b3dfded5e45aa73f5e4ea76a411fb1cc9182841a4f7e13b83f1f35402a722e7912c981350b347ae7811ebf64592110b213b31524fd5cebfcde1517c980aff7c38aaac156ce640746838a432d138b046fcd911a9bfe36676f62fd14a9310e897ffbfcf29176364cd5fc6d640caee256309473a97f7adce1e9f6d9c10587530d94debf739bfbeb46a3538ec544ab1061a49fc6ff540ab83f565603a175e2d04b886f81b9361e1544044bcd2012670f42962dd4ea2c701904206c1f71e4be19a4af2e6639937034daf6250d7871e1db4bdfa04e9e92fbafef6e6e8ddc6b7e9e3b403336083072b8bb913fe8894b15084568c7901d0835138e21b00917bf43d293b48e6f2f41f82ce7a7c50076c99324ac2b77f8ccd4467d24cf3367d16006c389a653c410e0b42d05c0410d4dc8424ff6c3d2630886e514f325954cc73cc6636ac4e0fd9169625664b2c6529a045faa248702f66e91ab00c780b1c5a217126b04ba8a61ea41cc60512bd4888ca2cc77a0a807222bca656c89c96e9eb9839108250d053a337f3bc8092365347919ed7e8f147ce5fe800702535a66dfaf08e855118b9d3360739a4822616d5bc4a24afd8f3fb803c4d679a4cbf46213e73e29dc308aa7b0487f7723f81b75693820e8d252648e0a8279fa9562a31d580c6d427b7aa21c5fce814587774c50581f2f74ddc5246791b0f006a78f9033ecd8feac5a2c7163368ef70f820091b2340663240f8edc6c538e65da887263c5ef564a7bcb1cda97b61bede90c23a0ab4d5a484eaa040d44eb1b88aa35aeec7f5888a0960b078b270a4f25e9778c673649c296888e9afd5f87b030f4a2e89e79ba2e7a6b163b88ce66fdcde1b16ec6d50e16f5fea4837f2d3a18164713c9d243971f3351f60b873dcbe0c5fe7740139dff425e7b5b28d5725a73d55ccc89d026cee4529dbe7254db52c239b0d26e5bf0098df34e47689b41308ab36926a090c0ece4b5baf7c98dc03747c546c616c1ed5bb5ff9135f609e9944ddc279dbadc36eb38e767f68c008c0fe093849411a4c4bdea43c5b0710305f540b528da7b3b634aa4145598df6319b1e78765e92a32f65ba4981b16a92595be42cdbf5abba698e9c8137e1f8a509d69da4a1077312e69cd418a99067466dd616825df6467b56705f8ffcdc3de9d9f18f5b9354d515ba86daedabc134a84d9a0dd5d331f6d237817dc4d70eeecbdad5777fd7a26f8bbc1831e67bf4ad51a3b69d8753fd505d522228173869a4045b62e23ad3af603c10ce56be87ecbbdd04000961839bdf15a084f2553af8f021f71bb0c1c562fb18ece3166f6e076c3f796cfb76e3ed74c4f4acd7bf2fa1f26b362a49c54364fccf5038c10b668393ccb2cc086c856f80d00f552eecde39063c76d1b94b14b74d7ba0574b09bfdca7f95cd89c186aeae8a559a93ac7948dbe282472edf34c320f2b8f733fb204cca23f21aea6a98cf7a7be12cc203a8fd9a7835265d896608147005a793a1bfb0fcc0cc777a037cc6ab9f582495591b8e1d0e6beddd49a808d85d8c78451dac4124f983cb076f38d8e701bfcdb9c9047be2a26714e42acaa3398e7e89480bdb769856f19438ac099c495d2c61b5b25b46d0c0da300baa033ecfcec9ebb0da52b9aacb001b22bfa7fa232ad885fce553fde16ccae732035fb7172e846dc142152d4fe0512c8622090adf03a5d735c6f4443a75b1a79f65909b1fed1bfb10f4be0bef369604e83392b2b26595a3fa3e1394e0f91c2a2add5d490e106ac03243a648977058a29af638868390ee779004fafea08d491867ca37184cdeb17ca794a8b4c9b5aff20eff75ad9e1fc734b81b9455cf6d7ad0ed8747125bbea07347846bf759265d8d03369fcb5015fc8876e98f610f827c0aebd23c357cdd53838c75eac58d05097b4a9fdf5a19d9153967acfd77df84d1f55bd354507e6f1fb4611ea15324a1a4b337679daddf97972e4014866b2fd7514e559f6917a209df3e1286298ac291587d05d8ff13d04e45ac26b97351720e3846b8c6793978a01d8519714af9792dd97c1554faaf9ae136b0614dbed7e7486bb5cdd281161d865fcb83ac136e849b5c3d8d0fd77e00d7749f3f811b760c1b96bd5782acea19684ed46fbd0563c2ba028d4d8da1716dc98ac791c49f0732ef98e8e1fd044b3b19fbe466912ad024ded39395ce5064cd7e41750bd606a15969292357aa3dba39fd3a46f54bb07c328457506b2133da2392c10a54479a387e6385b6087314e82fa408836cab2136c252d79b53ebb241c6316d3146704d5f3d3e91c6554ba54545e0f286ad841c7bc77956ad9c9d37b74aed9ff69976db2ffe62af4c17718825ad837dbfa5813b28166500c1451833731e512e4dbb0482b684d9358e3f171a5ba64134d8b476a6e8432b5091793dc974ba849f6a8954291048ac901eb5a725d3d81f8509cde94bf8afad03c59150f11c984bfc59daf43a51711396cc99d302074beb3384d3ac8ba2a076061ead6b721f31079ea8f20efe28889ee759efefe4e17ec4be517a03877534bffe24654169c07562788c18fc880a8fc42556bd6a01b53d13e73ac61e7e7b25fe2d34431a53487b401b24617a11ea3a9b35b304bbb9c7ec5d1c8fe31eea08f5835220f94eb047faf23b7c94df6c00eb42766b89b34ead44c87e3370db7bb3a4a0fa512f238acbd09afe04b800e68682b983d9bb33c18b1283c4e8d280f7ae94e3c19869ade06dd73b8393464235a02986c6dea397e7527e91f0592c1801261dd5a501e7a24d76f8b37e557068f4f25b9e6dae2d1ddb9b489577427e21cc4185488149e5e672a1753a5c5c2453db5eb28e019a004aaa0515ff64fa322c6e1895ad44cbc3721141666ddba10024685276e511a670730952e4a1f89f81f4301c0dd02b83e01fb51004de64abcd9cfa910c9bfb49e73a84ef6b7d0aa44ee1d1d2702b8037d8d3b94f0b1d95677496155f1a64e943c39ccb5b416099486e1a236ff33a445077c58eedf2597954d1c8abf81f9083ea6079f52681f1f9d598db32f04472a752de26062e0565b605837b89beb847588add8bf5c5a73f00b4ec43eba88c5fd857e4c8f1b8e09aec8be5711ca846a768f4abaef16a249c7cd14540cffe352fa474c5bd6fa825510b215c7baa78e21dfea8a03fb57c10f655478aac11550790e4d492858544fcb3dc25a29e3052bd330a5680ab0b8697bc958a12228e03d059eb79d393756b1111541489dcb2ee1738dc37a382c2b0607b4d08fbc5d3f6048406405c3e3c6afdce5d5184a7d1bf9b471703cf5a8f1a2fa186e6fc74ef9d23308eb89931a9a9613e97a3bc85f007a3cdc64e3399984ad45900d1f8f714b7210892b36260136df3a6177728f83abba164eaeb08630535a7c2878c83c333302fe7a5d8a5f3be38f4bd7ecd70ad139542aa5a9b163aa634cdc553bbb14008700f340e29af150361efdb76fe026d0da25527b2d1064b9a5f1aed1b2cf1453757851b10cbf9e6e6e53f2345959b348a65ecc66f80058406d6611dd46fb4ae185f66821a86f33d182676e1141ae9debfd149f6c0d88944a2f65b28230b47f47e307b9f12602b18830b3c02cb17e0746dac743f664bf78939840bc7cf82ee88897d0c1c64d20aced2c6b5c89079877b1379689a30a904f747e5359e7d8c401de2bd1afce0573f5a659271021d33d11ff1d106d8e6038906b9a9b8bc7c21b360921581bd5efe7da15f928425a980a6a6d42d15c1522e0eb723a9d7190e9697bb7d0bd8f66b19f64757a8f433c4fe49d0de185315eb8a3cebce591f67d6079ef7deac47b10f528c0bc11df2b33845d46d6fc3503b766b090714958e86498456efa4865bbadd89c30cc5ac1c82f0caa2044d6fc7cb3c6c903d4b1846b4f7c10dae83a780b7ff75b4ff3bf37066c6b13511506a5e7688667515cae6b490f98949f432f1ef9e22fb0f4713e5328ff6b5ac99fa7dc09f78e5382f8d0a6a91ace0a29cca3050320fb3c5462128813c86c163e6d21e36dc6fbf6bb3eb9d0c14f0a995367b8a424db0f582f19733eab9630fca864418cd7b7c8634e79492df63155a74c1aef7ff83df5f95672271f5d4d0beefd412761a43f5b45da683d8c6503cd2b3658c66547511b228f7a34175dc5e71c2c985308d9759f39e82d7e40803b9209ca676754491298d8a08b5861d95f091d27ac9ce1cc217d1420bb8ca67d0dbfa7973bf638d184e00b64d5d81c81a56852c765072206d8b72c14a173e4fea4668f1f44fe233fe965df33a63122c21fcdbad805d55ee50fcc6c64c0b99e19a426c18f740ff824438d34a991c25ab8735fd9d32b159fb104f2efbe74133e047fd97bcfbb320c40e3af9bd9f0ecc68b0eb4a0e7b46e5c497a554fc8af94542034de58150e1a22c4686d07429d04f999e0c4d2701f2bef1cea083a41e1fa78c5a74cf0c0d474a5d166daed2ce65b72b689ddd2b930743c8882a108af58a43c75a79b641c4375450aaf0c46da259626eb25655a7dab6261a25cb159045f85127a1b2c584569200608361f519bf29703ebb9fef07e182290317051e8a438d99dae11e6bad3c90ae0f0fe7e5b3801b6f41ecfce05c1754e5c1c2916d8b4e00be51b0236ca4f9d4a29a768bdc939623f1341bfc50cc30cbb00add0a482115190302dcc8b249b74d059842e3fb21bf096c9599f29633680f38da585144194ffe33d85e8922c11528a7b177b47ec2cb83e2c7b360adbfc7ed692f892ae03b50fa092eaf41a9b422b89e950f5f61d5033c8f9a1dff16ada990ca3276b4fc79bedb6630278dcddd453be892dabd4c443816b51ea1fe115bb73ba3bcfd51c81755a3a3eeca7c5d8153451e8cf9019a49d797393712da4e687c7be4a6d3b5c1702349103642c121fe302009743029844e3b35fe4121883484bc84d062d53bd6677bc6f71b8f12496cfb5af2ab0288ce61103da45923b81f1808118a0c6aa47ce65daad40c095f4169bc17d72d60002c94dfe3efc43907b46aa02a1b59876f13b25cba49e088af2755fa0a2196ab33f2b2668472d769bb842fec3f64902b3828a27c196cff33f13c27161e62209c7c7d6f1870de2790782460e24136c1fb39c3fe54cdd6bb628d8b399dc47eae2266f016d5f84bded73e52741e46212c85a383078cae998dc34e56de5fb134093bc313a8716dc52a65218db3621736ebadc001c80547bb41ed7bebb5eb2fce4eff2609997f34838696fd5853fc15725894e847301a0cd8a174a00c755ef65e68fecafc7098ffef2adc4df0182d129ab739cbf5b6d5112b8e851713ec67228c503f77abf862a91fe18fac47a8bf85c78b9fe7abe08d237b22dfca68380532d760673a4f2012257fc77c7a5ef89d85367c9bb78a3d9b17e58f76dd0e78d1db0116eb0ca9bad502ce340b8c6e0b7482f3afef34d2215726c7806ffcb1cb896fd2be8c75adde1c4311e3db7dd56014c54854219f2191ecc6ca2430ab88cc09430c001fc6b51e199d09067eb6b984096549e30554751f97f99256cce558230b2d6748b0a1fc02022bdcac8ed47d3a2a69a150672a5925d8dfe00a2a75ab1f0841b88d59fb50bbcb826c5662a25779e45721e4ecc65d0c606db87643d5d0720d5f51c0afcd70eb76f8503c2832543b9ce92532ae8bc918d281f19014f27220d854c3e0b205a672fcde271a2c5859163fddaf008292f472c8944f3ec1f3db0717514c4277ef47c37f8a71d84980c483a4281c2e12b0bef03e788acf9d4ff828db63134ec75cb3b2b2d3b9d2c2b069fedb9b1220c2f7d68007c4684c50df5d91772dd785999da64db6a9571b1d99b60fe8eaadd82a8b7caf2a5f3a2da335e339315ab451d66140e4a514ccead0b1a96310151f1199f557397f71845aa04e1aad8cfde1602f8a5e89d3642a5335faea31754c0b3ca09dc930610b7273434c3b0957fd8243a6c13ee47264a1f1b78c67d617e143e8cfd018158bd0f2c20eed0f66c65ac50041fcc8a8c87d8619c5875774281e490f3338db4afeb4b53f9373fb295b91a5b128ffa9d70483f6eb97c0f6e0537a973a11ec8e57c3fc551df26c6270a04ee1767466a756d98883cc7c7dc11dfff1b30c78138d62d27196c45fef6dc0394c9a3ed8a9ef5c7cfcc5b422fa74e71cb2b11e6948143d6d1a50febe2d3120ea3940f3eea48736a14e01191a86cf0a010180868c91e03ac6fb5bcb9811e41c404941a531a0328e54463564fd81c983945f70674f2e9c91099f598df76c66c1bdb0941adcfb4a00219ef5db7dd5e14474868ccd79d71fbde03dac7ccc4c430367cdbb4a661035bcb3df44f59653367e8f071207a7bbeb692994d5e4b103868a5c4b5eefb0cc7b61f85dcebd8887961d7768166c788f0b4f5d778291d15fd8f52ebcaf13412458fdd18e2e14fc320310803dfcd77e7850439e46a1409a509d270f23632f7f42dda4a9e1dd83da08e30629d7cfe6ad90a5fcbff3839659b33dee4aaa15d6f30938a3b7b0b23ae17f27a47df954a674f897237e3246ca54e143451c6deb6386c2caf1c55d3dd12d4046402ff17ef34cb743c8d449dfcea0bddd0d69a5e1535a0438cb1732d8234b22c28777043849ea9a18bc63f8f53319f358ae09d02fac5bdc1bc0bae0d7deb21c26bdf8630cded5f3263de84b5ce362de87289cb080f7bb29886151af18b9ee324e1b1726b345c38a12727110daf9cc8f4de8ed50ebe708c2a3fcaf2d8f06a556a6db05058482c484abe01a8b33ff65a5722ba4e29e284412016c590b8ba3abec44d586dea03507501dfcba7b7bd680299d2fad783ed2371586fcda9f7d56603e4f142ceb2b72e6fa57c84214d523eddbe3183348262177ebdce97c6016e9ed9d2ba83edf9d6c8c92a8b4ddcf99833fb6bd78d52271a812c22e9b011425176e6fdd9d55bdbab5419c21d46cc224233183be6694d2f7256d972572c391429830b52206334bb54cb75b68167d00f357deba605289a7a5c8f8ac9a694c1c1a37bbb713b2a5f8b4b452d71e32a538054f59466151a932c69626871b3e89137f120b20c50934f3fb390420d9877d51d3af61af3ed2a523b573803fd9c03a7139b80ef9096e919ebc8031ed90ed1518be43314cb7020e6a3afb32f06161c5f66621f6d915ee600e0e9df6f77e59b9b92922c89525c19fd398a191a52cc2bce990b9abdcc8ec7526f58b029aa8dbcf5f5ca460b04494255d13e1ba356dd493b94458d9b7732c385c37fd183d4bc12706a52ae022781d6e5f5c07780879fc8991916a0b56149c22ad1edb61bf7f89048ad015df2b1e8d58315248eac452d5bfefd3f046f17f98d30f8f63b332d2aede13e6949fa4a922798e7f2812a6182239012316d17536047f6cc2bae7319a39e1c2c99092148aa4471ce32dd22382f7608c04f83a17e19bdea8186ddd7a3d6ab17135325722c244c971234ed3ecb950dcda975717126e625302180a5db72e8ee4e84398b6fdc1e6096bd26366eee9a855732bda7256cf6f8106a6e904ea4218572a8a28448de14e93d4d27b33cd44fabbf20714d94f845fc4f31241a8d88af7335f4050ab1af52dfc09b3a7356e7ea53b31ab534a1fcbaef34f27db3b1babcfcba4c2d6de30b51c2b7365b1c016dcef51398c20b07cc7a03ab0fcd9aeea7aa12911e2c1bf91465824d59f594d73e0b91313de86ee1df1f041e5e113e127117070ff65c355ae823faa86f3c77b185885da23733b801a837ba9c225ebb4058f9ecb2d6753d68ebc662679d56002ba20ff50016e0aad2d03f6b0a25465e50a21c8dbdfad4c596265bf40a414e3cdf0a3df2ba443fdbc19d5fd2d8ea4fd92a55b1a07600feb500df8bc576717c1b81928891517abcc003eaa00c6f057dbf7752e3eb3d780fca93b665a47a771ba8167ed193f17a045ab62a2ff0dd196c64bd5e70dccce2974a3f6f3ec7997eceb0d8969b6177b0f65e03b28e04cad9acf16f64e629d4af48e0f386298924497d541734e61729aaa72d85b1b9432d9ef1c49c1f5ea61d4703b316209f46f751c0bfe5dbd0ba850912a529f40684553c1543fdea1905fa626b56b9d40eb30ae7b2b0fea917964b2895e3ff80a38b0c59d6d3013cec8ccb7187286941bf3cef3a778f14b41e380cb98ab6dce9b1a4366a87b68e93a6fed6edfe052e4c886988d6b81232bda339c6bb96baf658dd04184e4633b8458f2004a8c52691be06134b50d7fa0b1c4abb83dafbd9221347da6b5cbe3a9c0951822dd0743d5e4f9b1e5a49b12a4887e2ba120c392c73097a8918f08099fbb34e91c39a9e2ee43db361ba1e8f2b5bbc84e9b6c412dd4566f41b88d92a8d292e67ef184b034d4dcf7998b4832c4355d5cbd0b61f80f87723055e0400358122c537156db57a29a2f54d9c847f3f3ed8da28353311a45af15a288fe11c55acbb1b341ac9ad2edac3a2d115899dc80d7b11b7060731c4c28dbe8a0b52f1afa0acb31f8b223894668e5fc06923a091328902799e85ddcfb9cd186ac2cda57cc9b91113c756b82440d0e0309d92ffbe12a73aa0bcf395636635c97c039d395655938b646a9bf297ed1a746258e3063b1264f506b0be0b2518d4f71cce2f381bcdb9b83316e63977e24802dab4a8c48acfc94995b37d9cf3ada69b47b112cc037b56b2cb86e91183c9f08c323d8288497873f226e1ba6c4f0a37a20b8f6a7ab9b6c98bb3e6932a017c88e16b0f52c6d9021baaeb0f656b56ddf06087955770bf8ec2b085df2f0bc1daafd32b3ac63fe78e33dea796297df39ee2779f9e323e291156751fa26dd4bd2f4bbdaae78d4b7a412d29f2406f29e87fe7e84782022a7923f39c78386d0a268451206236f4265e178995269d075d5af2edac6911848b86864f9f6a58e8afc601ab1acb73c57bf621d29ac99885ece76199ba478f453ad182d982a66cca4f5fad287eacc738a52cba707ff12aba2c95b4ae68fd217d3567d7c41aa58adbb1251ef019546974503899015310ef60bc6f4105f6a44e2777ba8b7e7a0c40dd78b207d2b1df1f634182c97a73baec602aaaf078264aefae1ea92236ee1f11a03958fc43e894c352174954c0fec20b532c302d0c7c4cb747f71d4fe23d5658cf3339fa661b0bfd05686c3db73b57cd628381e0ea2ae44afc7dcf976d61b3cb7844e4fcfdbb9664c6efa065d157c2481d105297927ee6bd43bbd5347d5e3f972a4c34190bb5b5e976cb8bfe44644fbe2e8652956df823e4f5222a4739967139d028a3128229c7a51bfe692c97694c1c66ff6a5a796e5a255ea4fc7d69704306641403497c30b661ce20dc2d6c243437f95cbb5f0fabf9f71673251d9ad0fd05c48d4c9aebba48a034ecc9c08bcf123a7410cce31397f5a68fca894a28e6ad5ae7c963e84eab94b0222c5089ae4ac98ad2019d2169460fe84f2b8782b5dd85431325ee55f05a22b791e28d39f2ad2cfb50edd53d89e28412a206640ca2f6540ef31cdbc977298a5e4f7874c5dde0cf510bd2940ef194fb019036fa7f22ea96961211170583cfa13e73e50552c102aed9f7c3a315cf77e75cbf388e6ffb503cde062b183219042e8aae96c37ec8a3a34491b09293820a5e519fd9217c725a73f61e083d84bbf5b6a7d7aa345263352b7dd7495d44a949bde62b171f6204ccfc0c88e5bcf7c5e53a29cc317e8a98f93691a1840e52cbb8aad8d3958c6048629ee4852d24af1409b0dcf39840579e9368b00936d3371455272398410aaf99392c5c8ce0f3e733065281351663583b0c9421fc7193688b50427695f8fbbc2d9e45f88395233ceb0e09fc49885b0a04c7cb693db200369916b2cfe70814b8dec8b8733c187b2e6491b3d66de03f5634c2433e74476e605799d9623496bb25ec7975595acbb30ba5edef8c67cae2cc8069541ac1c8a79ede112c4480e10cbcc20b6c08016e142163646c52ab1b31375c9b6aca17af9505da66c8d226354916ffc5ca8b2fd06f555919df08e17f4c53c00898c51d1e87d8851c6b2d307b8c483895c61f9245ca8af554c50c6bf64bb57fb2afd1f56fd00bc011278a742b3121b12deb289c7a7913070ed14ffd0f675f7288c7aa4b425bc7cd184ed1b0ea0a1c536f50f37deec46795cc3d0c30b6464015587181d18b4af8f486eb47e26afa3e13c0d158f174039bfa9115f834463ddda96643f0d95ec7286da0632923376c5cff3e1dcab6cc7235a973c6df8ea0fdd8be6102649cacbe3ba1af2b1720a936ddcf83769f27a5fd2dcfe20a5fcba35a99f9be96868db9f247eba522a3f4d716f183d3a750217f80f5af50466c994a9060fa4c93f24a856b05900a9cfb2036a2bd2485abf9f0932b8b18ef9a7307012f7a7f9f0cd35c6f4257945c1da0ad419ff28de26ecdd7ff9a311bb1cbcbe9ccb0c138412e8cf86e4fc85025b365a92613867b991b389b4f0b7dac3d1cad7fcd73d363e3bf527008738510e7bd79738ffb11b826b97be25ff2edd4dbe577f66395fd645b2b4e3f575c6746e07b423828ece70ab68a257867eaa7586699136097d91314716cfa3ee46e232741b6ff90e952586f2653197934c21f295638aa4abfb511fc911fb5efb41416483bc886f27574114624de86d3d2682293f358a556499ff30a6deb1275924bb3479f844f4420a759c4b0dc2513b919221a4ae41ae06c7d9595f8c96a1da3c2ea1c3c96f2fbed1374436e8de0830e791908d22f1d57ad90a1f999e3aa212c905d4f9a29b69149b45c6201c9343a12a013cad796f0a8794bd3f6541f2f826d079e6cab1b36ce30311b5e713f6a7d47f0bc7ac66e8c3f6e3cb1cc5a05fe713a792517acacbabf8e2ce23550d13b1a757db541294737883f7a8da49781c6725f81f2feacfebcf4c39fd990506f37823008289f5db320a446f385f439791f60f966ab6f9fde996c29dac38362e30e7cedd9d96c5f8f50b53414cfb7c915958df2bf5f56d51ed9dab86dd204115e9da8d392e5c8d5935aa1b064794b3393196f03d81a1ab5547f3f30e632708810c10e977901845548e77af9f039a8fe4ef15542371ee246fc240810735d9d91309e8b8f512efb90067e2ec9294230d5002a013926c9c166a6f37f97ca75ba3538f3463365a033b147884529afd47b9ed39456098ef20155a4cd80583a626b02da9d2543c46dfdd8289863b94fe1f64721a73bf5c6f92574c10fa1e30b655c5d591c8d7bf76838d48babdb2a071902bc3ea388acc3786013bd412662041540b43051c51d17bba4c1bfb18a373be7ac89b92d50af0cee1d943140bd095d88c794ae1adc53b970fea1320c475438994936a287fde26cb28da0bceffc4d843ca19f23ec7f06e7cde42ead523292a7616d1461f815173e70506d3b62fbdc246726a3b03be737123ebb397c677c2504059a2cc478d59fc7879ff3f8fd446282cc874150f0ede786626efd57d9b35552f6edb736687efc9fdd10b79fed7c0318034b58ca37faad4349fcaa1c17aa54030085158b843fbae90d1d65faf912c9e1e8205b71c7e8853bb7c63c8119dcaedd26e2f0641c66e3198853d6e124d381f82050658fe79d2fb63784f07aa123a76f2926bc01513c349dd4119224fe9ab477c6faca7f708439f5a7f7d5f0d896bd7ccfe27d70dd71e22a7b3ebbf2aeeccc685545336f5aa40a683e864bbf41d6c806811b188455fbe19e488c436943ebb4e313cc3129efbc63b247c152045e3dc8f2ffc65ad18ad64ffa8b9c12a787c270f21ea99e4761425227f03344f82da166fcd1ee4168b7f71149be48a723e4a68d8327ec33ca5193a198532b0c8e874009759d7217be9641bd1260935dd969663fc4a8ca2f8946f1281f4079fd1937af39d7b5bbac3c6200528c8203302dea4d54f34e5b4db5e9e6da311c222163d918d5cfec7e6b9cc941c4ac8ddf94d4ae2382","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
