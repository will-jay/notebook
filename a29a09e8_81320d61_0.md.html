<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1a2135c27f5307247b788cf8671d65f03fccc0d957edbfa3ab1887d3450cb3d4727fee1c49a22c435cd21efae1cdd36e53a7127f2d6c30ef6166c578f7414ac94bed004c71099a2b73e0284380b73b76c16d22e63fe2bbbf3230ffa7974d3bf914753ceed05607ea6fb282e73ac6862eb8e25077328b24366247c389a8b89a10248017495846b73c515f37dca4bfed40f303694b7f28d05bf48c85219f67717a728fec7200db23f1cbedb3b9211c252398cbe7d4b4418d55704966c525999e99c9cdd15fe9f831a3690ec9f99c602ae296d85e1aa1bc2c056b2990b2337e4dff9892b6474990dffff04e290ca324bd4519dce29d79721234e400dfcc994f5a543a0195ab59460c2c352fc922e0aa6ad210bd142d88876b0ab964c0c84adaf116b02e39c20d5a21b576efc691098e5cfc350776d4a351d94d63c40842f6a34cc68d0a965efb3b59f37888bba396cfb9dfac84cb85bc71129521834ce8be41602c0784d6021610a2fe3a7702fef6cd492cc74feb6c30a9a71853c6f1f6fb3bac6e646889613f25f003d729cbf4fdf04ac8350756327eb9bc0fdbf83e8a85125be09032874b79f0573482785446b1e617f10d03ae659fc5c68c4bf3c87558033a174fdd1ce7be2d15cbf873848cd3eb65e63defd9a2ff7901b196fde083460a44b83165ce1e150466f84378cc9188daa060c469b1078ec046f454fc8297fa84cbe3f2633fcf621807550af12a12eb0e4b34c39ec09701d0332d3dc4a587d754dec5b76d2fcfd62952bafebdba1e10ea9898e86d4f6c8286662e3cce243ca01a4ca9f51ba06718ca76810a8a6443e0c24d10d087e0854a8c0038d787cb736904818691af3460fc8fb858943f5a289214f6e217b6e096395ddc1fe5d6d5f791adcf194ce558a828a7beda520645e90b64adb22aba5dd56a33d63aa8adcaf998402612c768ae8b66edbdc87a4540126b909950bfcd3d5b410480754ade33a505d25e74629cdf764c96f27f78ead39ef7214a4a2dfa7c7e7fc9e847037a4d7b1b8af6b5070c5e92a3fdfc6d93aebc4f42e3bf9c919d51646fa5b0adae87e54bee125b6bafb62a9994ccb085c02e42ca7213a2a7116c878d35259b5cbeb43b51476fcdd9e18b879dcbd45359ba13c4d5170ae0ee0fc26f214b191ec4d69ac0241260d20190799a0d9323a13d2271abb721c30ca766d87f9bf72e61c71719a675f4de4ea88ac45b882a3df7246373d3ff793ca1ebc58128805ff24b56485b0c9467397420a80891025be594c9710a2283410db29ecba698d459b60241cd0266de9a4582c5f963e63038ac7098853155ebbf7706d8f7b1c37b578e754e1f774b628d3dc83ef035ed5c1f8d3af2c2c67909e19e3ce858f318782e6c785d1b05e80669b3b393ebbcbe387f65d47f89b797d3649253a1d1db6bbfe85007254c50ce88e796a07858f4304014124c21f9632129a17ac530627131092c5c8393e6bce2c96f82b57fe94611f5137c16f5dc55de13a4b4f4b69bca44e996e090fc00481dfea7b701d7aa6c87718fd82f4a6e71e057cfe18c7b6eff44d509f934642171f6d34e5b4d635564cc9ece64f0df1c54e5e0b7c9b34589e20b21bef51f7e65f542b8fd4df45a673a885c7379a51e9140aa40056420c3f2339d70f3be82c4ca3bae4f53f0a6dce0c77d478fc33f67fd834bae713463329001876c1656b9aa2acaeba2e20373555a17facec559ec0e4dd3ee88eed6894a089351b25f822e43c09075fa17216f7aa0606c5189b3e727d85a26cd1c23f7a0be4a946178da092802dda406cf96d5a0650d1fcadc97143861b096951e5dd5341622d2ba6126a514d64125dd7a6208a6f38cd326f0e14f79e624a7792fa081235ccd31bd1f90f36066f80a8b5cd6850f5d824afde45062bedaf25c525a106a5726d4a2f44083ceefcf4c67e2481f0b897ef48d07bf733f21e36326b0d31266170edc428da622fb2601cc73817f0433dcc569301148868c0ea69540f422cd1167033ad764706539f5fbb4eaf92147ca565aebb67652325761917ad311b1d4be3066b8bb1b8c31e357a259ebd0b37a386d46fd19fc666418959468935552e3f8c90d697979ce95fbef6bd1f5cc2cd8b50ba66ea45719798794e63af30ffc45f1073ef2f5462741cfaef8d2029f8c9dbb151248480234d19496e0c77d70625892bac2913e9665b111b2b5c688f622d1d4c4116806edc64944a71877eada6627bdc645c235bb21fd084d88e2f021cf5fe827bb253f99d8daf5e097be77856ca719458af95f78c89f103538bfa8bcaca882d3e80684d82bb8016cb6c91c5bef8815aa3a4ff214f69b3da6ffe92cfe5bb8bf04eaa0a1d7beb312ba34fb1c93c89b60d81996d7f432e127695563bd70c7934699c8b777054040513b30424c7753de50cdc231546a7912e4bd182866e7270614765ef9d5fea4dc586028005da671924115a783689c1942f7b29fc2eed3c9e17eac0e03d075851506954eb486f518ef24f5bff407c72f43bdeb268d9b474931191f87db0fa516bc5084fea71215bc6a40cadfe897d46163a4a97f5216f1684c15df2f323e4ce5359375f253b73be8270f19cf8ce53484ab8c65a4792102e46884c8e04fa283b90dbcb1d0746b58ce8498ff6f1c246c2b48d622e3f8bdc52ebb29ba455b13bff71cf3b50d76120722bfe258386992c5e347113758904b446eaaf3b625b5f67f5ecbe3397e631da13bdaf6abab291e2443e9c3dc5ffad751cea253ec1fcfe25743d174bc8bdfd3299e6a82b22426cdbbcb4431008170394395feac24fd1fcaec75ab870a55e0f781c06b8e5b3050b4a1cd6e6c04ec57d1f9a38cdcf799b08b19291422c6b0584b1ffaafb8841e7b06e2f121210db1bf8d1738a8c25301afef95307fd2bed89629c79eeace526f6b04bbe5ccc02f7150864964ba808ba670bc9b61c8f4e6f164ea4215920bab35bcb8bcaae5000b9ebefc76966588900bd7c458c757cc1a9cb41ce660fbe7ca9d30000a63804c39afb695badcecdec2d2ac2566607349f573f771f7468846b44e473d0821fb470ab363bbae7e5e472f3b4cbf51880a35cc06a87f3c90423d7d5b61309461ba9f338011afe232c0e32b017a54d7329392e417e767d6af1baf9c31f3c184147c7fceeae7bb7d02c572a259d66a8d46615faa1f130395fb5a036b80d645b67c17bb579879ef49727898f001c7cfdfe1b4f200fa6e3f3d5e87cae74dae7c8f6092c7fc671d90e02b3558ee159c084a5833ddbd934ae98eb15ce59402786ea0decc838a3b643c2bc6a27b49580de9e0b2e83aad5aa77250c41e9c26ac601d13071246eaa58cb2022dc084972b2ab331cf607a6479c7274a11b922dd2134e6479ab4d35a18e00e5bcf6e87461c95fcff7c4d71b72778b99b0d6f0b2354b41231ad3248bf0d263b2453b61f47004b62f136ba081ae1aed6586cecf004b24e3e9c5945eb1a6f20af7a5470b4034a5f048b44dff75ee79a3a8caf438f5e7318c69abf22f9b170b17baddcce2264c2abfe3f80f18954167733fe08bdefbe908489c5c8512da257bca38e8ae160d0fb78cbdccefec0585e678f9dd19d37180d6655e5305eb547cf71e94f4d5afa980d002080d85a6b02220c0070c85945857c966ea6096f7ca9c2438692fd3aeff11552276f67905fc093689ea91028705883e046fc713a0a8c0544b3c21a294a1cc23b2b1b490c17ecb2a2126d652162c200e6fa9a8467e6fb35e5116356919da391750e0ab9e41fce2dd82db1d0f8dfcf4f27aee9b1aebcc31e523c1a2e6d1defa68f5cc9fd516d99e8c6be52fed80dc01fbf6de107f5885ac2019ba6c3baefb3e87512a6086a9008c5180008acf82b4b47b5af644a950f16bd235009d9cf78d2ac031de562f5200a69ce65df299a7e96305072cdbc0d39ea7bd70738df7e29eb7c45cc30a8785be5c56b11fb1172b30ba9befc16ad9b4eb352dfc6c32039fc94be82e9188652d99277d7fb96aac5e71d4b8f72e6c8802c639e37f474e6adf24befa7d6d20041d599bf3e3cb857385b1f2909160ba6e424f8bd5b8bcb226232f7ee1930ac6a1a2200afd387f41fa893fa040201bba79d1bf0b64f350235a9f35696de9cf29561ed64f48a0ad1a985307cd11c711c3951ca56d07928418956e4193c9017b60ffbba89c90a8c74925f743ab3b8cef9b0dfbd7a6e99290f1e5c38339e28fd797912122cc69ce30cf1acd69731726cd64f1aefac684620732f648082050dca3ca5f3416f75772380017ac93f9bd006449763a108897587479239ad74fb66dd6f4360d90e01b959e49097a7727fd8e9b757a5b62fa16644c447646512e1f59022fa70e15027861c3b70b0e2f25e61a59600455aee9efde3cbda9b903110eab81aae415e86e3a51e6aca5d3728a043d4666e82b4c154736383d2956433fb664dc5e3597354172d2e0180b84a13c90fbb558b503e05f205a938ae77308dd257220215d75c03c4d6307912734d86dfbf5a9e952b33d7cfbc8ec870cc630d985a174a0fc910bbcee9934f4a8a97a22844623a676833b13389f995bacafd34c636d74dc0b1321959e57b96cbda18515c19c5ff5649b4155d40680befbd1699a4727df7ae7a98a4ad5df685fc96ac30655e3a119c7bdbe07265c8b9fdc852c73797be5020c3d585df19f2bf1d4ed061055a0ccd269d6bb6d0de82f35d9187694e3f8458017b30b01195007ad29460241d3208718228ea4c52fdb66f69c339db869b77c2c0f4a0242cd5818fd13e9ec6d13d81351e250c80032ab87767af8dccc3a5cd90bcfd4340bbcbd3706cc55831d2c153c6c1fd3e1b3146d8c37dbc80594e38a6e32a49195202ade959ef5ccbf086172d2dc90d40aaee20ccc94f549473affd5fafb5442eed9395ceee6d2cdae417cae1c925087aa86c5fad4186fd392ae22650c72c4f28d2210c608ee5dd73e6e592803b406647362516e3d7bcde8bf4c9d459e6a17932abd66e52b64e7ab83146230f98fa49e5ce9d758b2d566b4f0989b7a0082ba957dcff0fbe1203cd5ba160b976322e4402d0c1cf6cc66bf7284ca559a41c95c56d6390e059e95e808310af0d0bd57e98499d6b26cca6fb309669dad09f750b25ed8e31c0329a5adbc28b98dde45f7222605dc7d37ea6ae3e03ccd6411212ffce198aee7e7dbf6692451b5f57a216e51a305673c7830fe817bf69d5a2c4759b914998fa9fd65351213f846fa37428c741924b9d3cd61d189d9c7d0dd76db0e39500681c08cf00222933d4402acce5aca89adbf1856e9dec93945fb820604e2ce3b963f69817e838dbf4116e4cdb27737eecf8ac66db9406821db78ca0f340c08e805ba9dd70c97a64efd1c59e3b56d9d08ce59ba9d7c3f15c90007b0d26f61fe4eef29cfae36ce935493a60c0c8012680f3bf21e4db57de374e69d4d83810852a1aa7c5f42e40c26e4655ac1626e7b15686597ef03ba6ba7f8a4808422290c30f0a8baa7a848aa86e0b3404461980e5c7fe78e6698dc045816199bc06584f03f58d87b077155115a6bbcd22bc17a2a5043d40a0abe106ef97ebba1923f7380eb350330af0e3293e7920d42ec93db9739b85664b9a6c91d82676e94a231643299f63bc509e7fb5fa5f2a70b764df1cfbcd789a7d19cf8efdb7b81db935f0e0499bc732bdf44d4540c8c1968e55e4fa3bc14060c36e6bbd8b200602c180b9948e369261cadf27dc2cf63aaaa46252964c81fa7c8b816dfa198e637086ce1e94272143ec0e4f0b1da10c84f41369387a09625b2c51adeb982a944d24d3f93394b09110016746de8e8afb1b70a11fcf8318f238ebb7fb1be4070d3cde8b8bddc49085a98b6f7f96201463660f8505c9cde0f756090dcf0536e7251f3280b545ab0bf43a8f8c1aaa645ef118124d2fb26895e8dd2e19483792851e315ec2d123bea04df99a79f31c813e41d5c844bc3a3c0b1a665332500358bc0a0d999c12c7868ba4aefc0182759b2f5c0b136f6f985329310059322a51271ea535afbd05fb5356f364e122dd7581f38096e51ac257b02955bb6b29ccb0618512ca8f5a217a223e217ac2b71adefade6bad86028ae35abb10841c23755143284a24223f35ef88854db59914e82838dcf8f8a2cfac7d310df6fa52d0de69762ef6e6c71ee79e11532c7f69b1716c092a1edd89d9c7bff64d335bf8abf08b1cc6808cc42b11a926d8746b3c0a4859ebfa6e42e2b8d6da471c9126197ba65a2acd98d000e8f5349759788f8f118e7cd17b98cf39e36e86648e14f5200adcc4a6848d2f57aef0bf92b7e756cd67ea871cf766acaa1b2009bd58305562be796af5fe18f9bf5c6ed761d262a2262b34cb06559022616e062002ff41eadc22d62a3614064b8b1189c8ca8ade3821173496e87221ca88933f0ada84f6907cbfe7bcf3724359baca867ab144a1bb86814d656a5ad4a18f36ae627a1d6b2ead5e835a68c3eee1790992d70e91ad635d136752cb25866be098ab22c289abea8ad7fe9a83a773b3eb2259c514fa9e0a7b528b7ea68a3f15662451a7643aecbd070fcf63ec566d61c7874ffa04006ed366bb1980d88014bba08c6ffb5b73888dcd20c60add59a3ca37a1c2e3c691b085e0e106f01b856d5de5207c4182be5880b290be93ac70aa78a330260b5773c77857548956969368f3f088c3739fafaf991358c0b715ceca21659ba0a9fe1120bdd5a1c9ac7c1dd4f37696b8f46bff45851518c343c350e2bf22f855dc5bc0b5a70a4a912fc9e3bcdd7a4d24a21411b561dce709bc610ac7ac96a23e4757c1653e2fe8511f37090fd57da2aab2ab6cd6a66b07a889ff1e3f1df3600ab675ef654146ce933264ab158b15478680321b164c8b57d1216e3d612c66bbf540c4b48424a87ab3bfe29f177417ad68df15067fc6d71dc1eedcd6848f52919704f8d5f0f303ff3e2077d68cf523802815951524548ee56bf2c4235dfcfa9eee5f696f91289aead7143b45059a054645de4cbc2e15a961821195acc276a73edc64b121d46c9e5717118a3b172a660c48158a1f731d7e284f0a5cffad39902161a425786e772a7dc83ec62f6b0df2e99af33de692355d87b4ad4c63a1b0f98e364f3cf3c6d9f4c7daabefdb5b06f2e62d17284cccddbbb4abba89e45183592e6a8e807ee0bcece9606d264db4a1f0075776534a10c415e49c3c5268c97cd836b5baf62686173aab542053ba7a2e530d2bbd51c57aec7ac8d5bda0552f6bcb9b196539c8ed9833a120c349f7268f2f8210bd39ac94cb3cc8ba7ebf8649162d8080b3de0967622f8bc122558323525cfac9c56fd4a71dcd3fa463789effa93c0975eb044cf1849c281e3a79f8e06951d6c27c286069289ff0d435d0fe3d4d56c9c86e2933f2ca2ace901fece4d0ff0df90a0a613891497f93c68ba3382a7a4799662b44818bc05b381d06ee2938b1bcbeb76ff9d258c1d855185097cfa8cd29433679123d14e9e5f46a72d1272d5a44fb3c8d6d436621f931a39603ece8f54291a7b214ec8535cb3d35578954e74129b25de2fb0f5b8f055c8e7c112b97d77719a9a039ad4dbc82c6f853a997ebee1350e6bb11f94ee76c82abaaeb20aecb7ae1401de11e40a69e4a6177b8cf543f710eb630e4f54cd1052e2619e2d6c0be0823dbd1614e111d732b1008f05dcb1206c2b209d7577359a4e85012c7d2d74110a6eae3b924f2ef1c29ef1f0b7c43721b34148e19b194c570b91104d55517bb97c72b22a8116b9fca5f36ae2ac87b9389b7f251a31a7ed36f76b76d7aac11dfee943f8a9b6178566e4383b1da4ec460fa4ce05ecf8e2ab0ad6de644160418576b9ef701d36e852333e6dfa099a310faa63b9cbc13755c493a45ba87c991c8f86f96d502b7203bb2d9ebdab271ab0768bf264e65fafbcc17683f8861d750b94d2dc6d1d3c27a591cf23f4a393f8969c74ff2645fbc6d38ae71068676fc9dc11cffc4a3cc2597d7de25569f97ff1097005a1f88af674e56a70ffa7bd54b4ff806e7d31957d9a354676770850956759ccb20efbc0eac7154872d24d5e9ce1e3499d985632f382759fe7bd6171cb9d0c8b058aff5a82c52811f7a3c6fc91ff8ddc7657d3e8f45019e0784a4264395951bead3d53117d856085ec470445743b77e0d8631a20b6566e481f444a118fa45614c71bc9030c982d4fdad29ac30570fa852b658be6ea0b25441b30775363640b15e884e6f5dc828d8dac8116221ee5a759954993659271a1e9d63c8e9ea95bb2da4a6ef42a31bd2610e684679df331bc9518487ca877d427ed7718a6019cc1788d8368fe07f14f09a6741a4854b180ddbf9f2b34fb22906cb6859f3fb2db3130bb72e80a1c0a59e0247b06f851d3455a0628208ce0cbd7879253a11433bfda96e2d0806e6b8630a3ce010784eb5a705d7369b1f1499a4ec59ec73ba558896fb3682cf50b98b817cec4913c508a35b2c14af9b40c2a665ba432621013e9fa3e6b290d8292ae85b6e54a2feb40386a9cc6f0eddb35769b3d03f03f449c6db5f5605965831348491c012c3dddbe6f131c232db5d407a6ab41a6e71555e6006940cd6e7d1a054300fea0850288187504c29ff31af73807bfd53d0d020c9fd2dab8264f2d58d7db219a59e1cb18c9666097e099337b5c5746619207bc9290159c4d948c58ac1190f1b4123c9066b7e15f5057a064cbcb779a8fdfc6abe79847efbb25763ba9f6bd135f00444adea269b8771185a2b179d0f2094c31ed17402ec26f90119a972d56d85f9bb52a67531e9093dd9a750f54499ca138dc8a9a3935117e1c512f0704dc63d77fac1837b7129b40e2e91f33dbb97fce3dbda691786e58d232897af0c0a218ab94e77efe02e7762068c73e6b41b2ed1eb969223f57c2691997752c14e6470362837301a2d8e78b0f499816b22971ed63b06e4215f5a50952d362d4815d4eb2e28251361c8755372936c16f3d74c9c7d39ed00aa271baddf9cbd81cebbc499d8a9bdb819a7987c0fbc4764f5d713c2c464fb090073e6787964621a0302e77404fbfae143eb4e484f852f84865d48c830c0e586c4e97678e2b5040c143fa81ce628a6d66c7bf3645bccf44276eed89db9ee21300ef98a0958a5ae17d56f696620329450a34eda05dc8700c118af56fd8489c1adb94169753c60aff66017d0eff1fe812cb9edf7dca43b7445761ba3cee9aa3b13a2af3bdd1a983772156d04749735c1bc681bc4d2feaf3b43cd67def2b60e497b412816d27d7930af3cbc9ef0ab51c2e94e03aa26f1e837249d39f9fbd1a4dc13fb3eae9de545752af8b07d65bd14bd743a3001d236420a24982c912a61eee66ed7ed202440e22b25eeeb491a2cc8badd099768bdb22a153887dc9833c35fa15622148e231eab44341a84774990562279270617a8bf6cda39e13cd866dcab4750e2be71ef7ecb74ed72c7223d9901aa2dda11e99e353dbab9ee2ae8832e5d8b171436c43ad4e01d0498438be26f0e93671476e5b750a1015fafa52d468afb966714c9b2b412bc5bd875405e0d509cba3a6404ac385cbc854abe5ea4dbfde6fe8492e884c9c53217c079f2edefff41e3b65e18a70063779b5d7053ea05954a1cf8fc6b5f53b62465c85908fd84a680a73c4f7b6eb2fc5eabba75d267e8a69501260928a04fec66d7cf4f6a1123e673cf4ba890af9bacda3f72342da7833f114940013217dd1d4458d5032092a16a63365f61bd00568dc9a3ca1abf6927bf1e1c0773c4dc2651465f2ef11e84e372c0ea99b7b159006a486e634da930a028fd9b1a8d7a950e397a717b42f90f78cb42bbcd98c365015bf3ae4052028c5a793cb6ce344b94f356b6bb558883d6e5f190a112bdc870343766eb274c559167fa2b59ed6aedb54a83af2163dba6d3ef9b49ef4d71522dce2bcee24d80a47c199917389333fb3fe17c3bb0f2e4e2646bf5296aad43827497831409c9434516852678c2da7a6ad7e8551a6db9b18fab6fbb83ce41f8c02d586b6cb1d160991802b2c75850e1f7e10255276ed6d3dd56df45fb2aefc96826cf2f19abb320bbb5fbe9f9d0d7bce5848dea508914de856b7b3153a5df70196dd4d588dd46567fa62381618abbaaac8087ac4d9ae93262286a4e38a6705468b141338b3d0fec19c25b210f4f0b521249ffaf42817c90d79e7eff7bb528ea499516ea91799c70cedffcf32fbea19c55c1ffba4919ae6530c6dc7dbc5547e34187e461264e9fec74898b6c496b4c168d71f2ba4af8e8bc2968d03da2b3388fb801b2f111f878773aed40619b3163a76b55f44a5589c229406c8a6014d05cc40724fd454a995ce512877b3d96e9b3d032176fee24417c493a062ffe91473c77b435d83288800cbd2336e09c6f3e4ea6ec66a6e60fea03299ba98827de725d452d5c3ae25a6cd59ecd21d44c1804f0702b7431a2ec8798bf27511414ad435ba153abd63e0641466b80bcc5d827fc744f4497e6428bc1eb48e530d9e0667b55bb9a7582f21e2395b59c5658b72bc1d68aef219c35f7ab7ed8508b272c5cd4de419ca6dba871e99a9bf01347cd60f5e4d725f854b35673ea8606915592966dc70a0ac1768567de9189d0053da706e00a100e51f1f2529bbdcbc23539712ffc96be49d18a5ea920c4a5684dfe97f21363d5b335a0923e5c6ba56e8cc053934dd744609dcd93ac6bfdb95a2934ab038987d07c521c3e7f6d251488823be22987fa403646d120ec134086c43ea89bfc02b1342300aacd760655d46a19d0af409818f4f058f20b5a698e2799d27f885219bb56f9340cad60c560b808cfd6f5c0cb0fab591a5348e679559040c4b5c216b8c4c5fe6266564d2de4232f3097b38d3779decbe1c71dfc40c3cdf11f356b7ec3ef65d78044a3e44edce4a1c1a9764d2bf35f9a277fa210088d0f64aaf65c09474dca71f7f641547f6da774bf81e6cc28f49921c7a220eb4343c8be990a568398cf35b3da22fa83ef9349fe90ca4b199d4f1ff3713666cded6bd7fd0d9a6277f662b39490f7b1dd78384dbeec7813f9e359f57e448fcbdfff34163a5b0393b1e99112d99fcdc0c07fdf30c526d0560e320e22ed77c9550a1d3fb4bb39709a863783604ecc9f48ce5926b9eff304ef745fb541e5718c4ab5bff28f14a7a4f4ab835b4dd1eb1e0736c453c6bcfdd4f05448bccd384b4601784a6cf7bd3b3120644857044c9f8105bfc4df29c32c94ac107a600ff9734640b0616baa58277b34dbb61e94fcab7e890f036e0f67e969d8f641b19434abaa3dcfd6716d50ca40b75e589ec1877296652d9174f5dc8ca69c1033d276616367c9996749f897b8c36c351b4594aa3e5d2f7f700f663068db4843b089415ef9a5b61ebcab47e870bea0aad93f160c09dceff0a2401bbd4b57abfe43310286a98f2fce14cf44551cf2113ee8407ab6a22107bf2545c689e1caca575dfeb6d5f3289b750a3ebf7c2effaab55f9d2163a88fbcb2c188c6e4ba12d2e583001b8c6af7da11e7f5369063bf96fb339640277a4c1bdac945ad3f6af429a5e60ed3a90fbc95b9fe14e5548dca44fffc71eaf2aa18853656799fb2d4756c9c5dfe60eb9b415ab00f1e77b95011bb411b19f08bccaff6b1e845731c483738a301132795ecb1845db8a9744d136bf32db271c6224800c271bbc90aa98b98cdf33632a8e5f831c51242cbde44a00518ca6866721ac99bff5f416c12794456970cf342a9ea2e829c7c44d6f3ed741547c4b37d8c68233841245eadec3ea91c54fff700ab5edf338c897c0fc07b521b8a2b4056541c2e2d3e880f9445dfeba5a5df44a60b67a7cc43a6bc48c5a1888d741d3f550a58c087ef25c6f053300076195bcbec21157484e104bd184253d06c4b412a4459b2fbb34354b0d9fa17ffa082b5d92e2c982a44982d31eccbbc68d8bf5cb55912bf670330ba4f02b800b0729554c81646fcfe66a2e4569f478fefd8b68a632ffaeed2e660e9f7152b40b2ac9ffe0e3b3dac61c1cb46843502f918af3dee0025cabdc35a9fd433c988038308ecae902b35deb968a3b3679be664a20212e6224068a7504772505eef45b93f48a0eb8610d98b95ee8c10d51a04940b9b7b494b00f3e584390711b2b11b15cd6061346c9575a14da2bb277977a541330f9ae3f37e0083b1b5ef5673dfe9920f966e00319e9589c916d6b6f4f6579f8e0f0b0bfd9a4ab211c491f785dc16f819695b6d0d68a7c469ee7c9ae5e2abfff98592908433ff22577b5e10862cf2267ac6d300886b97be347b831948347bc442a6bfd74a10a15f4099660d6a5b4251e38eb99bca840d4150f99c459117b4b334425419289822370b52db8de71b3983bc2b6c66c035665f13d6833833727db4b65c20efcdd927d93f29f9d6029e04e3511227d40eaef0c390f34fb062d90d30dbc27e542febdcfba50a6019b1a62f5e965b3678dc070d1505ce8263ad7cd43ca6652695fcb45f0b1038623f8ee56ce16626424bc3b79120d1c1ebc80729e1c508b678a799c5bbc3abd8ab97f61fa4d08c542f9e144da52d6572a9145aa04ce544dd05f2b5eca3054d534e3f5b592","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
