<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a25b472f9a7dbce8b0ac6416ff78332f85004630e6ed25c908fe998934810ae23b106d7bbaa7e35d41ff40cb88ed6283de3da38dd0b5508327f19b8e072bf5a60ff065285ab81e412a5bd1d60360399f24f56f14a9d02e99394a9a5775baa3ab8d56ca3792a8e65ca025f530ab0e6dd949bf4f86109d0aa54bef19ae1c5c3bdcb9466b6d335f13080818abde89dc948cff65b36068a7fa4cf2cbf90f7a9c744c5fa28b23f49ab37cdd04cfec9fc202dad79645fbf6902122ec5a5166a4b323697051cc2773cda427113937df2864ba1b2deb964557015e4dd1bc921a7e4a82e9f4374b6ef1a4c77f40dd31ad260bd9016104c094d46cf104a2933c3529b6cf88a16f15e818f7206a112b9405c322a4709c19f91431deb3708b61b90da318daf8203da0f66ac6389b698bc765337428db3d99786e056a64a9e15ded22e3404eb17921e99955c2e9b5da1ced62039c9bdf3de191be189a8dc8dd2029eb1b2bd5cfab11e1cd29e2ac50b98fbc3a64e5f0e17856cbb610a078ba3d5f0721b9cf66aeff0ad3ed9e6adcba920dc7a29760a001f8d0c4e008322d9757118b2e9a581a3e2ff2417afa0f407055efc3657456c05ce242be34f7dfae2288824a41991ef709ca2f30a72e93a500e8d6a15ded2f004533f73dcf20c7fb2383b8049baf94df90ddfba2e0cda7085f9721f76482ab954ee261e5a0dad074d4738f144de5fc7aae2002ef9a0396514ba57f20317de57d448f15856bb96d2b664edfeb30c1e0e4ddb5c855d57d942d13a9063118bc6f700de6c8f7d5f979f325b9fedc298f07fe0c35a5cfd3f269f19f5575f08896c479d4951116be523e5bfb061774f9c16d4bd08a41bf75b1cc3a7ce76c8311ce6bdf80172a690c87a0a256e1868fa691e5984ee8c1788ec6d0c1f35288b3b92f00ec3abb02b66399d6df6186ef4ddbd893d49e328e527704bf7193ee58cef9f073fd8a0d2e711348ce3f1d7023a6d0ab35a13d706153f988c93133d6119e3c7c265ad6c9746bd9e2b5d7aaecd5757202979ecfba168fd36f952ff805671b56e2d0c113d10f3572cc06fb01bb8b16ea99102af046cce13514411ad60325a0360557746c9b2a5b0cde30b32279f88ff7ddbca7b28289632cb2926f5b1de3e3ac62255b41cf552b7ed17c21c9ee44e441cab280c31b5a50be076a117c8917c146e00a6367380188a5ec0c11c1e813eab465756f82a8d2d31349e249d814745b6a7611aa43b3af24e3142d81666b4f78e3b1cf22e5eb6e78b826e0dd93a4aabdf094b73499bf4b054cc99763c286458d3e835edbdfd19095ac3c58a4ed8310aaa92cfa6a1efa8c950091ecb0cb4055e7de4796b2ecbb15c86b40de63e28d589eb6c73590515a97d10e6642a9a82f3060ba31ae5de16131fcc58d009c07911b1e32a9c5acc535d4edc96857a8ebbcae55e567e5bb803895aac5f4868117dcae8bde02de8aa1d5f886cff533a2fb84c228a464b9baf618cd20f833cfac9b9612ddf5f42535896609aadc6bff32201ef346785444b9f4ea4c7f6ad310e48ab6661769f3a20100c5be1252fba56182ff4eccbb3b2683e2682801bd684f2cd359ca952a2d7f16569141cb08333e0f872552cbcacc2c71e3fe995c88552f2c9bf25e0b695888a63b3b81cc3c22777af56be98af31ec9d3820d43f1b375700adddbfb077330eaff4f11b0be93364effbf4e70cc405695f89cbdc8320ce59ccea5c2384faab05902591c951e511f1a3531c5acf00edb0cd1e600612c2ab5fe0a40276fe4599469b33f9ef21ced8333d0a1ad6698392a8b0c253a778e214ea47011c3624d8ad1eec3fb42f54bf494b6eafb76d41446a496009a6aad9225019009284ed58e0b80ea79b6315787c2bfc483d5753ccc5ef1f3d4f04b1e608ef6e4cb6c5f50de7e0d5a188959cb8d31ea54c8ddbea253384e51631fda37963d53eedae4b511f82e7e449085a49a7642dab950bf0582c5910fb580ff816c756bcf06cbc5459bc718b904669b4e8302d9f244756fbd81eaf9287f57a51f091a16a082ac7fd440526b0e03ba9faf35786a5066d1959f8fc7d436aa214b3e2c9a0ff245131c765b98a761cbb3e4810f8027128eae139fb507dfaba2233ba25204968317340e15520b8096694df934c7d2149ba622bca6328f088f3d29a1dce5b2cdca07e1dd44275f3050273356ebf818d853f74a0f6000ed12d05dc122bc075ed49f58d23401e8c35d64775f33d85fec199442dcd4646cf1f86090350c14174b724ba5c8a6ed7877a1d64cb63deedf6da4abfb9c1df125e44eb4d075cb544bb8dc394afb318ba0e653e997dbe573ef436c310a17f91db0a4d5fae5fa6e06192a0e5faf1f07848e6edcc2519f837f506acfbe60dc061d5284d4d86088d4cd7387c210ac87250f911825797f860af950b7117504a2125d9f79c0964bc68a236dfea3aaac7b092579d9a5b0ec0ecaba2f2dadb8db3af47b80b8f90619281164844585cfce5158a1c7061f8d6c4175d1a7617f5255ae4d7415656cca429043e652cd63dbe6b618ddb573df5003b2d83936ec4201ccd8fa88d87a19ef08ac8feedf5c036c20d28a5858a0446f61b3127ea74f308b24783e282c722a86c33a3b33eb82912fff176e6b9e631ed618a8886df63e1918a53e849cceb9ea1305b6a0a294ddfbb216b8e04404ab0d6d957361b0276aa0a2a193338f13b5db7f1e239f1c2f0b2c0d42a15968a02bd18a33b8c3bb9138eb4aa776c99eab7e2d5f2bab1a1d10306656c3f47cc7d25a42a7a84457952dd1c8ff124dc778fd5c0aad410e65d367efd9ed0969e2c889eaae053ffeb44d700404c8e39b9eb6920b314bad68bde6242b1059a86d795e7140ad665fad7da637407ad2be2513a5542993f1e37d36ff4cb40cdece486434a5f538596435192ded579a2617f98724b0201d7aca185bc6ce7a93c0b46c0094662b26475254af141fc194b759e446fdf5ddd4d6bd61794dd71dc0d69c48f45c467074d80045e789ead9062e6d9e3b66c00f3abcba2baebec560d0eab022ed35214fd6d2790575ff3b95532a1337792f27ea64de7a53021eca7cd4c20cd1ee570c2912cf94223dcc6d500c9564cff055df051e7a34399aac5862e5945d0db0d73d3305931d5550c7a87629edd9c1dd0e81f1ef658bdda9a718886b25fe0394e2acaa704f84ff67e2ef18d7d39fe0221b6b306b170a45b956c07bf36580d33a4bb1d0e4052fd97fd35180a50aefb83931aea5e5b9dd8af50f03e926421015c32dfc3671b05eac20443235148ecc1d6cd3fc8e83ef0c453b464c302c5651cbf3ea775a2b925bf0067ff4696ff281fd08ef09a3c000750697173ae39e0c0f82df75823bb5d1982533c8b8dda40157ef1fcb14550f09d4aed6b3fcb3a6c537985f1a4e548b3c2de1790b0c8e2e527c6508e22cd15f0f055ffb430be826264e6ace718fb5abcf8bd345d3d52277b20304c7bd518a895a30f6877bb0b8041242ba9e0562f27640c92aebf9f4c1a9da8a04a9d7102e59ca866fb36b2597f918019b40a641d609c09080d720226a80b3f806516284b7243e0c92773a8c3e6f4eabc6b4868a76d7e034e50a39f5300c40f116226136ee83f91b532037c88b4c910089b027875b836d90b2a86c2905acfef6d41420964e3e99f75a89121da2079e0200ae31befc5ed26f2dc24094a41584ac786e27cc9f414b759aa004e9e82903ebad43cf066d8a40c1aa6ff4b5839accf03554c8f5125576f03d74364b1a4be5a8bdaf0ec4debfab5b115ac4251c6dc6ac5d45bd5b9fde2b5aa84e421b56197c51f3b254c99e60aa7d256996adabfa0f7d883019b1679ce743bc7fe4fd2caa9ed14e2946d43d82ef84beb6158b384446faad7d83ac81fc3a888ed281e455a738c662638848947dad32c285ce6d16495da91bf3a4e94428edc180f526e70a009df644d19d361189019724b063f136a08d5195b7d3ead05a2583f877fea2672c9151ad53d4163354a05dbc6b06db685b2989440dba04cfd3155780cb1d916a1b623625e760bb00d6b0e8b8670ecc9575d830a04b68bd732d783c6133135681d27de93be22eee611e3f3a035146d9039cabffe253b566631b7ac598c39b6b0004ec9a613193e0c644444e9f522f16ac69213618d500c124f9b6f1c2a908037073e047a6748ce19b466b34ac0e3fcbee1dc95d7380cd983603735f0e8131ab1814576588f4dad9a68ed835f4152ad3f6f3270562126d4f81cee91ef5efc235b7656c4b548ad515327abf56378ca5e7a8614d204c3c6bd6cecedf3d51da6378da292439507e3efe22cf737561069dead67c2b1480a2995722f6431959bfd5c58619c56d5c12155c7f790a05d8f2327f59f5f4e18dd07234d0edf115592c568d14c236e3706fb0fb799c9ceae219e3e759254f333f44ad3a95a543fe95e45c0b82c163b966382c06f95da9c210bf9451869dcd4ff5a1c8d1de0e36815ac89dd0404e80b5d773ee1841c59aafa56a18d775c0050af037adfe6a4c89bec9c23c63327da08b824fa406085219be9a89c6ac3c595aaaae8563b31e6dc4e2ea60cd84e69254d2429d001107f79b823033b13ea1716eaa009fa0828a1942ba558d3c027cb903a16bb8f300cd9868a1b94e9e91a9e5352f62b6915978e99acb60b365046958ae7ec96ee83d2de175833efa39187671b7121a4e50667b2169fc2cdde40f2019460aa8a635d4e45fc2b1033365d46be4d78b9c5a31bf8c07eb592103819d2f5ae5e3e79d105b2790c1d64ea62fa1d31e5b05af7e7623ac64e316431a68eeab05bfea696851ca6645508dd7e1d16e05a94d472004107ed21c77845885d742b7fa66703e654136ffb81ac59d39946f0bdb30b5f5ab1db6e3216c7aeb77034d699925d2a548f4311e053d4bc3aa1558e235473c30a9a8bc26f62295452bb963fc283251c969c84a0a76ec4e43b1f16791bee21fc25ddfa630f8cce728a907267d300886c27a7a6bd8ec2174b5a0d4ee641cf02d8bd195630086e517bb86ff1a8afd5fa0d0d19bd85a469b8478e6409bebfc1a440b3ed32113bda78821d37ecfc84668312d14fb78ccc0b9ad3987d5c259395edb604adaac52cdfa798b3141f2cc01486ddc4ab4cb4ed50e046eabce4d206b2e14430252ba984bbb2ca76facb118a2710c716158238cb1dc51fd4558caeb9d967ce71f4454a19216762cd55d4ed9838e44292b98cd88af5aef9adca4edb7cd0eda4b95deb4dc1378e64ea77534adad7b3b3e8beaa5107a4de9e5d5ff66c200de17a64d4dba6f1d8635886d67e37ffa2625ad13c4ea8cb6a428d01667a13d9bb55f7e242f5d77af8221fca88e0cc3300b9a0eed3153755bcc8c96afa7c04651ca4f24912ee8208953f71b45fc670bd5e98a498ae8bf748565d667a06baa1d88c0734e10a170bf49682d2d9ee5f39e89cbce3831ffd41a8166802f2072a54196c180f8ec094d2ab698b1287673e8bfc34c5f1ae98a88cdf8190968384209885ae068723317903055de60ce4c1d4837fc48ac390fac11fbc5b876304c2eda8e3984e0ba62672aea203e16323e3fa7f4ec63c7c7f572654c90051a2a952b8836ec924001e3a053cf2b5f9d2100d962c52324484d0a57d4a7d977f7547ee8a370318fd36ac194d56972a0c21925e48229de36670b7c68cf3bee8e461ff2a041d2104dbd4f4ebb5a05c2310f5a9c1206dd1a88aebd0d6cd9aa653e435fa0ceeb07d8e7ec155c1c977d1204e7d97d1ed86e42658fe5f8f1e0204792364bc38022e074894810dcc88b033acef3542fe1e457ac48122b072f2aa28bc102120c919157c9b7f7bc51f18812afdf44dfa024f45ae4933297bb8380ba898138872251f52045e94548391d5afd58bb337a2cbdf2d83858092b0f4a2342fd97fdbe183fdfa93f2ef3b77db5c2d61bdfa225dcbd9ac607e676cf6148ff9a5042afebbf77bdee3a10b3b8a15f0606e17b5a591b223f162eb96efe8d8060e14d5eddbd9b4e02bc3ce4744e41bad853e37d53fc473a9e3692307899d5cdb556ca421b202528d2635bba4589501be33e441f2b73456553dc5ef794656db8ef471b1d8b31fa38f337a061fa1bf953007542e011ff75129e003f99cca642d5a6fed93c5571ea2ff5c046135af778ea3576f991b521d1d26fe5597e4162189aba0a0980ad4e9f2cb084761bfdd2e52b4126f9180e1f0a6872a8595b0c614ef3aeee700b60ca0bae5d26d4afd68e75fc529d68f0fbca78c9c0f9822ed5178ccf55801ed04115bf94902737a52634785a6fbe24cdc43d86a9dd85a1cbaf6a1922492c77516504759d132f4fad76abb363fbc6ee6b59ea685f3a04d95bf7b39a10b57f2fad8a5a056421a5eeae7fb7984511bb312643ec5372e13725618156159bd0cdba755fa9f3eb953469d2686b6412a537fd8c79d66c29f33ae1f0a05cb6c1121e7beb378dbbac4a9a6a5b46d8574a4d7dff4dd4336f6254bf13b21ad1cc04349043edb2d16f1b131f640951ab5acc016479020ca5d2f690937d7903926fb261200d8dd1332130b1bf78517ccaf956bf3729131d3209fcea850cdf4765d4271437675526eaeac183326df1305bdac7fc269f215ba09e244d86fa1064c770ceb4e4e4ef9120f9440fc8233883b8c727bdccbce809ed5871c324f282649f778f78e2f1fdeb35337c21e7960a8f869528a0c7133b8490153662b6d0afb87aa87a708826e74dcf210066775d29d8b9af134c648483862c49c0432f8da3c91bdf5aa22d373e267a2af25023efd8c85742777fc6068a09384521336114dbdf272d6a6b96601c368786c9e36bd6518e9a9dc551919e4ecb03eef140769ed0cfb9b91c356075892bf08f8029f79569f575263266058b8e815eb05b1e89c898f49ac9090c706ee28100d7c7e9916bc768b07fe54e99f9e8ab5fb65625a2e0b015c10e43595c20c5345ac09af1958d6c72e689f4ac7ed5fbb1bc23755cf4c71c8ec27b7ff5e60ed796804df7b7d682e5e59e5d0525249c3dd0153cc7580f1e483236f8f63add5d5c723189055f4562f5a5786d28084f85f6a44c6f6f014d29dddeb59568749eff15e2e358caa039f636ace06e2ab2755a3c2e16d3ef5417fc812024aa8dabb1aa219f484c4d0343e6e1bd25b29472ffa4545bc9bf607898941d0b8b197fb5f84cdec5559914ce0d06456a34214cce9674e55f9b7d404e9e82cf023513a7726efa487710665433cd63640c368c13cbc7c83e33a19ce21013e37e336cf8990cf849c27348858fa29fd1148095d8f5742fccde18d7cccece44444f6386f6314e0c56cc3e076a6ecd23f6d0af72ce5f34ec68f6a4f66405abf181cb508f32e54253af4700453d570d585dffaf98233017a77e88c43d801610d830030d09f98a51944976cd952f687f95073abdb2836102ebc65b3a258dc5d9756e1a7b4b1290ae341f6c650bf461dd87056f5d0e3fa96d990f346b8d4f83bc045fad7a40a3b9863a63988df9386a008438328a5152fa19e2bc71ed70067b0dc7394406c071693832f0410a83fa7353d8f766e9d00da4296a60940c600682f40e669a5f071bfee2f4b32f1d984fb14e3daeeaf7c11087d9d9c7ffc3387f816703e7fe557b38cee6267e10e04ac8ecc2075e3c8e53d63cbc447afa5a98a87f63664078070555c5978488f0423e745bf7a90450363a9556df46d479e6d0e86e39d263f6d7d6ce3aed68355eb7a12bd217fdebfce327e90753ef80394825cc4bce9043098572e75abc0cb4e135a0d5a264a635a6219150dfec7b1e1447f07a44458d7bb0bf94f71ab3ea1eec388eb117a45e691111f9617bacdc13e7cfda837003b0a455dd90110a5702f0076a8e5273a9c0e08732fcaf951c15e0e521a6dfc7c3e275466f14aa581762eb36658f452972e45633e0342f9cabc9eb1fe70cd829f75bade8ba849c96eff6e99a7e8dea73aeae8294864f35ed28a8112a63bdb5a697f5c881ffbc4e024160919be408c36e1420695b89ee5fd20a7df36eb406589ca6f034ee771201e0e79b694685c4c15755c1d68a345bf7848ed6a88ea105875a6446e3249b99c37577d968181ec5c5ad81a5477f3fcbd31ed23ff2a0eb622d9765e884431804de0a1cbde3f6a1190cc242ca6282482c34dd43e0aff0e3fa8cab8c91e00482b600ea991497ca2aacfea41d85f7b0ea201c6cec5f9f211745305a9ab98335bbd60b77fd13e7c15494ef4bb48326e3d5e2fb19624636e546043b67d5b672af460f4765accd2a1c23619156a6fa4af88abcd867410459b5ab30b7e5acb1d3bfdd1b301adb1f53587a3e2ffe083f1e90d794751e7bb920e9c38c32d7eb854f5547a01e9743e70f1d9386fa3a20fe8e690325c2808f4c6930deffbfac3eb1f81358816137e7cfde1dcb770a83d92d999df29e6a61d3aad3a5bf5f2edf789ff608ab77c5f78e8bd614a862b296a65092f90dd29d29b980952bb60e335d3bf87369cb1ceae75fa77d795b0a2580e50cd830feccb945e7a424b07f991d71d5d7038586b688dae197c14cd161f8e632f2247ea04a6d0d371f9b5f491578074434c7d7234d613f504a8963d70145d4aa5f5912df6afa83440d075820a5b3e694936bf79a6653c95992f752e274a1da6e5ae625d1aa9fb6cfd43da520047da400b2a1ec55e9daf48d175efbfa67ac8bf31e714698bc5cb1feacdbf93733b1145b5dd0fa81f6bb2c3aed589dcffe31fc2fd5c3fbaafe0a9d40fdc097d406b7dc923b9088a07fefa5d48d01d8e35b1a14d8a4a931d1dc5cd71f0ffe8304b2d89294f93ad5e9f87acba679b093b7320cadd4dad23ce26af4f7f32f4bec2d4ef53ada6aaf81abbf8adc12ee54ba19e1ba18e8701b938fe0b11aca1146f125c6dfc5aa2745a875f4b761fb35364ab53bc77ba4f4a907a5bebfc215625f13961facf86a76d72b70ece499c20bcc4548d4c9e4feaa72d7acefd5a49e71261340b8b822196f4b97ac3e8298a7e2a2ad58ffb94b1b15f91a1d3c01df60f877ffaeb19b0bdf5b743f544745fe72d6fb56e8d48e8e005a8ccf137dae57e7a08e970c8ce87a339ec1f4470b12abd9494f316d72692c256f1984647ade53d187dca601f415b6e7f3f40d3b78e4ec71fbf236db836a208c3ff20221d3a0f6c85c8eeb29d761e14ba8df6106e27a13aeae091f37ef20595d380c38f04c5aa17655fe7534c30b1a91dfffd567cdb3b2edc362247164df5a5bd53ed5258836900a611d75f0d8fbc19d0269e2b478cd93187aded7ee182c02043ecc754d1c8856381ca0b5a557d5314c906ea98725bf307a9b3228a907f3fb0dab8b81a9fe927cb47250134dae9aa1efc28cc433024c8db4cf02880cd3b3245802eba520c582931971e5cd116913398b5e418447681977f58c32d906fd379cdae8e70fb401cd1a330338bf24df5ef1e9c7192b2723e2aceafa23cd2aeab291b15c9879532905803a1acb38446545a4505d69131e04c9ce0c290f3c3c51ba3488d727970dd54e0728949725ba170bdb919e4a15c1b7a0c411899a4413d4085251ca742da698743e3d9977f08c831ea595866a77b2276d21b0b1f44774abb658de90fe1fd8712e209ccb4c04ad38b9d706f98d5cbf49bcefbfc2a51ac8cc9322110642fbc8306bd4c7991f886de3a1870b5492085f0924bc331e6fec86dec22a3636f1faff3c5fd9bfc791bce08b3f1ee7f75d193412c9a9229514c814e4eaa3905695a36abc8f2fd6ee05190c48d260219febaf62edfe4e01c854503cdd600404171afd79aaa14904e831c01c2467aa0fb1c90b1d172e67dbda89166c3d24720646e836b87c0693fae1a6baccc07b4658c44df6b1b6aa1d808909e9804a71a4b19ce5c543e641ea774000a97d3cefdeff35ddd83d1890220b17573908e5c7b3620d696001be9f4e6e60216ae1eab90dc2a47cc8461b63db14dd94758624a06d9503ea2c0c12f73c63841fe0377dfcf92587ed68b53ef6ce9c34ae7cc01063dc43a128397374c0b853dd32ef6989f6b04c9fbb2105ceb1bcb900dd7002ce5b9d4a8bcdac65f9904c78c5d0bb453364178546c55436a4ed2b2e67e11ff717a0faf5c1c345bbdc0e993d613e7fd400d55617d2850f101e2b1d161d055886e02bd3252afeb291a47f4211b9fb9450235df332a97b1fa6e39dc9bbe6d8950fadccda3e09308f8fc98d20904ae214b6abaaf3ed2c08eae2558183e62f6880caa3c273d9728045e00bd94f334d8c621d3f3aa4a5c434eedd13167930e52abdd2b282e63207c7b08ff1e1317cdc93c008d2a261d14653105426cf813f9d70761b706b000c9269d2e5bc429970e4330ed819cb27b47c4a1df09a0e3a506e447d4d11741abc735506b313ae26ed649a70226c505ebfe531583e4ee8697ec1b6d94ca1941ae09dfb8081d0841db8644a100b9e35db79324202d4d61166d76bce4478e8bb6089de6d7f7abfc36caa4b686dc5768220edfaae0b69b0260020c4162c379436dc0b1f44a051b894f21faf280daed41aeb12a475409319658b7fbeaa8a8a2e6b00987d082978309854183aff0753e64dbb0193f7579a52eb9c4c44c4d40ade824e1dd5e27a7ef25c7b055291eae0b22840351e12c71750fc9f5b7275a95d100bfa57b7c9f648c4f3d6f688e276312891edb1ae18566e127d0fd2cf4dde3a2a48a8f9d386cd71b3b95e6efa8a3792c4ade680176629f2c664a88fc46a9bc997585179e9aa4debd4b4715ee94bed7495e6b4ea21397250de9208878c792b48f6fe72ad47e0c95139acb17457c1aa5d9415574c6500798f20304fe742eb5b4b94dc02abb33ba80ca03ac255dbe742ac8d4469a137e89aa8faec7c6721623dfbd4b834b558687fe39bd7ad25628e11146924d5761228d0c63f5941674a27f43dc840158aa8a3db0882bbb8b816a83717a920ecdd866a09a437aeceb60c8e7faea3fd0bf3ff83258f79ac6319999571fb0f1a48db8afe24293f5e2f66921d905d162ca17a790f3e56a5ca5cdb59759e97d232ae0c500744eb6f38cc864cbb51aac437cb5332da72d4dfb73e7e395854ab2dc4402e39e8e669169ef1bd37ae96f506d9531fdb52a6f94528a9bc03815f109a0d975c616bbb35680c17fb7c2f5edffe36f8c6d13cf45814857812ba0d1b19480232c8b156c39ce6992354129ebab3eb0ade3e727da3f85e49f747e4f03ec568f0ac93d1f5917e911e2d0af93ed9f0f38a3d387142ad70cdad79e04b13ce96dc4bffb1f240e14bd284cd0cb6e61b96e239ba49d402b57ac7ad4e482b593467ab6ab6eb11a1ad8241798ac6691420e44350e0796c05c2c7034569373828e315ea72f391d5fc8a771fcb1fe316f71012ab34a8210cd52feb76a16aeac96e5f7a358ac29e56cf90a1b052bb61ca71bc331730465135355b02cdd1742e27dcdedc41cb470b00b14f338b91e77cb1252f55f24d06cf55fb07e04082f158747551fe2ef4018edff3656c549dc308c1f8367ec9a0e1553fa16f7c137689017304dd11cc165ca7d35d46a8b854df0d7dd97acdef5e8fd31dacb6e789ddee770ba7b68fac2d5426f80ee5b7e0868d3611ffa58a49b788352236ab7281881ea6b18f2c1c1878d61a9c4712bd3861a04bef04fbde2090b0bebfcbc38381a4ce45f8a48ea1c91a999d90a29be53db312f396ec6e6cca6e78468b0cdb09126db63e4b6ca6b8fed4281d3a3dea47a99907202480cc193c0827ee5c361651f4a4afb91f42b16ee08615a132f1485366f188611048f3450294faa00f7339c8c3283ccd34f73b0a97911afd17a713dd719f119981e2b365b10aa12b4daf780e6969d30738dde6156a0afd33f029a6d2fa4f2c7e6878ff5522af6281869ca2b123ea49c0de848359717143eb21303ee6bab3e8031e1da184d6d67a5f4e61c8251d8892760045359d376a45c9c03d3739cb67321c4b9062ecc84dd3d80ae9852141744d207bf70e79bd0e2ecc5e11dfb44ed8ceea304ae34ba8e1997e5d4ab4b44e4959226a69cbb24b7bea96a1f579ec43d6255b5aca74fd94a5837ef91785a7cfbb2c2fa1f35cca95a9981d896b19d6b79397cc61d08bb8f0222f3ad991f86efc94daac9e512b2c97ce3766eab579cbcc70262f6a1335c1e9ff33c6bf17cfdc897cd8f8dddeea20af62d3a0ab2219e2e4a103720baea252abcc9b136dd63224b3c7a8d8d2fe9c555b905ae84eac8c64301aa784a1c2da54daebb5f6e42c5888511a0a6bd977e96f63932d22a25232fee275edb5dc42fdb72e6af91af9f9c944a48190e090460c913eecf0457f97fc13a0e770a81e599854e67cc02bd53fcddcb089d1d3d36dec2c5f3f880ff45b2c6a61aaaf99e258f78e37a6b416c37714f1ae303d10797bb14a0c131b5096728d6a2dae6e7dee6b949c29806907ce4fb3fd6f9851819c59ae907c81133d8030ef2a94ef45d11bb27315923bda04755648e562c9e318af65b386338e4cfa67eaf8a9d185474cc53023a95a1815528c3ca580276df3bea0d7e42021e0d60c1222989a1cfcee529ffed6d50b3ca515c5561f9161a90026e17816bcaf0ca12309d027213d6092e1ab3fa54eea19","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
