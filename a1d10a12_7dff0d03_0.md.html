<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1693070efaebce1ffa5a1f83fafb965b009a34bdc8f0d527b5faec196105ff08378cf3c8887707c0b6bdae29af22b88305fa717c4799b56dbdfdcadcca4d3716f97ccceed1890f21bf57b7aa03cb62dca5515906b9bb40920798b694f5000f134fd90f0648e4923633910d2b8095ca52ec82f0035cd6a03510edbcf05f4999165d2e9ce565b89e773ae55c6ef61d9d4046940cee5703eb0f882a8b3c915d234827a582d042f0c311c99a095b55a993ccf23bc8bcb8d09d5c34a5117cdce61bb5408fe2cfc96ce8b69f70538c69a2a972798c1f375d98f94806f224e485865c2c2cb936a26085b75958bd65e62af9563d494572409728fd9df01d634468de3971b7d094c3798073aaf46944ce2df8445f199f3d4ff740a3751de3a8a548ead68ca90d555e2a659ed02c67741f2788aff277e659a65c1c6e41c936c5c7afd080eb65c925cb9bd4379cabed28b7df393095b5e0817a75ab55bedcbaa618ae32d2c25028c7ead76dbcd90f144742f617d012527096a3384fcac1de183a3abb576be9be5db1177ec6be543ca97f7c30fd1136de521e1a8ca1e9c19dca81183c2361cdb452b5a98963a94b35df97aadaf9d17284c85198b2ce58099800c8418000497941b0ee3c8de356170530be9211bc315de735c36a1f3b5c4195b38bb7fed6784c4f4c30117863833bb8bb1e803e331305482243c276f20be244c0ce18e5692c7299e87044b12c931e8e341421c3e7497cb23e9ef9866e90d4e027bb8a911f21b16c120cb986447758f7fd666c51e77de86e6ed72e33775f2316d509e0e69762f3d65e17118e24a83dd7a1480840cc869f80edcde61354a4ade0a2d9b20cc08f7cb9ebe21cfc03c66b0892b34e51330be94303a79b5f3b6319de8761a2c192361de5cf02f1a9575b7cb57bcd56f619edc141a4bb3a0ba7e096177c9cac060e0ec220452fc018f46f5d7967d4cdb8aad58fc21d0d3098a750d8debaa2c14c825a9c0f856e7be84f5b452bd5fb6dcc7737a6a5bda50100ca6ccc7ccbcdde8878eba3f1607dd035a4fddc313b4bb0efdb103b08a991f0afbd665890ddbb43ebcba47cbb7a059e36c501e6d4fb810bb55d789386e3d3fc1495123f92142410c6bd4a8e073a9f3a48ed9b1b8d5e5d70517f29fbf0c6d9099ac830ef630df489b9ef5c847b67bb962cf662c1932c01e3c3252907ee8b48c092a92a5ba3c99f53bbe9bc5138e12f3cc6b625acb532bd452aad35566da07cd6f1d8b4248b5f9e78d4129c33c219b38f4891cdcd5a634ddb41761f78e56dfa1e2b0323024a06fb5ec8bd7d49adcd575b23a57151d01672f7353ceb16747ce2feb3f2f88d41f24973daa453327ff17efed09f49827d2b6f3714f99daabc209f0659e5cb48adcf8d97786e289b090fea0b3f33cced84de84c56511c6d9bfb28cedd97bb0561ed5161e8764b6cff5b315780fe283e02dbbe7d1641983895d349dff0ca4123dfdea91e31e9e316f5e009f0b85aeec42bcb041a3a59520ff6340e4340fdf8cca41634faf1264fbc552dca713ca1d64fbb0547a7bf51dd1acf73ee5c3768076c86281131317bb5d7a645e1e9bbc472531c8235718780705a84be7f4be4e0fe465776d60718b46421f75587676b418b3f0625263aad2e0940930aeb100705fc902839f69a263ddfb5517610b8a399cc96313e1b5120c818edfd89a75c0a580b69db63296c6179472122572414f05e8d4b7e513a07047f5d45b7519ad09472b15c2fcefe82da7acaed0827cca7e4a35d303a971064a8bc8999c6243e1d11de1b100739081c4a1a001a902a425b4269b2ee482ead46db0198b359873f8f234c593a792d75d8a3abe35c7127d926a3ca93adda36113a6c80f7c325ef4da9c805297d25ba673da8ca8f3974c07aacebfdbbbb4d56a75ab5b4b14c2e1684116500fd1e4552c08e40c4a0712b593830aca515019367db80c129e18d616f178265a01feeac4c1ca169581294314fc9eaf9ffa1f6146ff11ce63fcf574fb6bdff75883146bc5ca47e3fee695ca14cfe78f67d18e9dc8fbe2a6d7dd99e48c41789c8c4fa40b1574dc973b710accc5f50830ee5e3e32cdda5bb1974642f65379cce9f4fac0b7ebde05c9967a4b043820b700c2e4b6cadac77239102ffa8457c9d6605e844b69309ee4b9bbb5b706aa5c7983e337cabf35baf0da542ad7818375827dd3e0d7913580be1d52f100c2726109f08b216491d16d55f84ff4835d643f62843605b245c8e8e1198565b49b2b123400f1a9310efdbce2411c25d174dcbb6b80174bd738dcd5bb9da70cd13806e451aa7d60930a30ebaf43226822ed5fcaeb7e48d590b583b3debc4a9bef01750f26118d127fdc4fcddf1981569af418d55d1259ed3ba5bd889080aa8c3c0b5d44985a272f533e0846ea42ce5042a46edefdac2b3cea003231b15538ebf851f90d57807e407c28749108a18292de12f789c2f2b6ce00697d899e9e113e167d5d6018c34df1cedc4293352fc0e8dddbedbf9da8e62d196df9dd1ac5ce11c6616be204d2cf75b7205247a30ef5b1640d524d9f800af93c5a49d9803f69f80e41037daf548f1b870145b4bfb237d98cd484a2243741b3f779344707624e6dbcba73669dff0391b67ba84478713e2f92e52fa1e92faccdc51618984ae77c7bff5806f4ddefb29440093250582de2038ce549933027e5de3be56dc6e8fe315fa651087f5e46826942c97e30cd1b5f5efdc4deeff2d11c26a3407133e8bf5e7a9292ff25e3ed4b47e0a81d5d396b4b3a9eeea5363bbc62d1f008f6059ceba09b413568787fc53f630bf9b7780078685e4e4c13c43b6599bc48380752a48867b63fad3512c1d16b98f7aca5e2cbe1cb86e699502dd567ef9ebf0d461c8910aa200b23a72e17501fd3db9837faa14351a7478a83036cd1c873e7b39879ec9eab1d86e4bac9867fe3b97da123d932c967f8d5fc5864f7da306e24233c78ac9c43bca33059c9e3eb151891f31d16bb932d27bc40b77c7f2f9bf4a805c0f16a04286e31ef75708b1a6fe5f9d86e86d7bd782da11e7c8e446bdd3334cc06f7e38bf38cd646ee10f8da998d454aba029bad4b57fce5d3bab281a8498a501e320bbee1b739bacca76728ab71a039582a59d2e6bf1f6476291626ba36dc8f647ae4e21b211737887024246c26cf2e320f4f9dcc914a16050f05d6a4e1f00f6ac702b90341da049e627ed397281cc22dbf9f6697f0c06d8ff9caf843957f53dba272d4ca42307532c46b9ada9dca930df54d24a82b41c199b9e8e0b164bd0c9aebfc9bab45ef8b8d4ac1fe479872d3ee68e336cd53713599fdb3afb80962dd1c285e3d72735c52bc354164db135f05a23b54648ccfc8e163acb8104d3c18b72600bd9eff2662fe90decf7d669c66c94fd958d3368342a4b9898f6f8dc8e888d7d02190891ca675e41d3956458172ad7c481b57dcb5fb6d9bfe23f5bbf6488f56a0a3a5fd190c8db37a9669b3845322c376624c14ff672e36042beaa9975e3e94065426c7432465cb18ca64e881a247f189e05dd7ff5c9ba41fea556b90cbaedeb0e3a6d4930d1c5312ea7f8a2cd46fd93836267bc815841bff64717520f55eec8d7bed475db9b79eaf67497c69299294b30a7c70b141bef90de464f45bdb5b5b2c16e84376aafe6a69b21fce1fbc5892eee0710643dec4b6f55b122d25a108499e498d65c3584afe8ea87acd7d269c12726c967b99cc306ce0ff78b718ddc0324390e51f821219d386b80a079a92debc17ce8391953d38dcaf13ec023966b7b6b7e5da34d8fa0e702b75483e9d6f943f9a9ff9de918475c316f27eca900b1e7772fa256e92e19cb1b6af0c633e91893fada2b12881a5cfb38ee530896783d521e656dcd10775314754802722aad5ea197dd4019680210acd22a8291138a5d92dda67a86e7c58961e41384fdc8c444b1c6a1f49b836f51d5c02812e443ce6ba8b207220eb4abf164077d78438c525ae47b3ffee63db1fc055493bffe24b089ab4d790baf5e85e8d1c1919263c66f0fa88c9ff6e31857a76198f9b07f6a44498bcf2222535d61b2314c286065bb24cbceddc3849f3ee136015caddb05342acde33ff9f3516c6ccc26535309e78eff702130df006ce36df0c39a3ef197f191b6d32069c0ce280b9e86f2860bea169392c60bf81e5d3be5839d0958136fbe9ae33eeb954955f29bb8e6c202d4500661541362981680d52222fab21dea56ba4e0d59899ad501395dd1c0ae9713c711b4f70ccfcdfd5e1c880cc73c7d000a7fcfe2c8cb50f5114a860439fa46b7b11e7c0ef31cf50d96f7ef21696ff8217993b0731deb7ebc2a7b20f5286790c3300d38c69ab413153873b1070aeb05b0f895c517a81e2bf152bd387b4ccabcdc750cc5138e5c49640e481c156e22aba8f1dd61b0744df12db3c511b146785761e4548b98ea03f8237147987a8e64d689b35b9d0e98664545bf79042f075efd3245837b30a90bd350a06fe8f57ed3dcac9b66633e41c35b6d7d97e2ab450c2907249c4fc17a2bac1f6fa5360f0d215c82075280c2dcdf3147940b3ff12bb39ac32d25872ede67dcf2edc5d26fb8bfd2514ac0c0f989ecd411191438974adb37efd054c51959bd15d8a24334bf296085915c10bcb0cf4802c38181940ab00eecc466c8e7c737db616148de508b0345a504d765af183482ac69ab221d3fac0ced344a5921b8a67eb394d9624b7d9f1e653263a3a4f828d5e4a9345b0bfd6a7875d2cfb690263a567292da2c38858e21a709f6d43ad1aeefa6c6b4b548b5666c4b1ecfc070138c2a2cf5e25fe2a054f43a6006faa999c0c6699aa25dce72500620f155ff3cee278466cdabc30ffa9b20a9b99b6cc1b3fce2dc718c7db5d8157c1788ed1c5182bf075f29a6ee7af2a850f70625f68258417833765e82fc681c33a7936b37cae7744b96d4efcb1690bcb01e2718181fd11a63136f95f62c9262cf04ac3b28ab83ea3b337ab6786d3bff035e466c0052440b3a21f21afca28cf0944e1ac59cda6ec356a1217f204df8a267130be455bb7fb865bc82460e8a9bcf856c65ae29b78f210dd2735378ab1bddac5e8045fae322fbdaf88e21d730497917e8ff68d9fbaf154f055bbd352628545f241225ad5a14cc74450e65d5d2e784844aab2d587996134f3d6574dedf88d16b6c7b905924a0f119cf3e78808c7e24c2cb3496552fda9677d198beda37dd1f672f92eebdaa6c5c38bc5a13fb5715d77d762d10a7bb5aa08adca2181952df8b55a5a6b1c2f26c5e4c4796102a21ef3f348088622ff391b80be6e072fe9e6737d1164d2338582460fa4f0c6d2f69c19983f1d4136134d7655b2f5ccaa58af37a893f4e3615d6d822043ec3d52e59061e4a9b0846b5a7b604e62b8eb3ca962aa30379f7ab97d911f6fc9f40e830a15a1724c480cbce6656dc29ee5dabe68382055077d306609a286db1081aa7827ce7883744954563537cd91dad3526ae06b48f54947df21fe58148d53848825a46bdcf8c120504cdb032b4715a61f530c163b23d04a7c524054d48728d8d852fb8d13e5dca4f5493180006215d1fd97e174f5cace31da4c324dc1a4fa67c7e51481a32d0e0d6909f38f4ebfcc47eba8ca27932ba82b8f6ef0a8eafa5119263eab1ba2e3b6a564343781b483c8d8357c5fb94cf88dc04e8a0c036f60d61604098eb9490ad07802a3bcea61a6353aa3e0c6c151815b2f8861c5194be82e1231c1157523c6921610466606321164e605e573079ce602702a59e618aef26169f146fad71ae7f68c35dd0b0e500af4c358c39292e7df38a56f388c65b9d61da6e407f3cfc26fab9044712d84f1eafbf8178212c50cec4f852c6597a521ef8b22c2ba8037c2921aba860417a85da86c0232dc4586807d85b8d604607fe87063b8ff93d6fec39cf73a02f45d7456de6af7a87fd994f3991ba7afa9d5208b2e10967e84ccdbe9a0d485de30ce9cc82c1f474bbec15a35e58c81adc9c65dff4ef146098d9b7c6bfcf32a7d0a29b138316fb4e32cd7ff94a114ca3ab9f885246e48762ee0988f05c628db24b2e70e4faf6b4272e84c405b47a22e799aacbd2ec388515137bea803dadafdc35adbae6f61d8a69c73a9e842921d855fefa8b63f23d0f42801dd54e02cb439c2ec173b0c6de65947891fde75fad287ca6423f8473b181a328709e1d14ba0ccf1f232e1f5970275ad73e22e97829abeb4ecc4115940ec4b4e5f8e85bd355012fd7c0f6f969996442fcb21faf06614cb98ca3ff9a64a5d1d1e5168eefd141d1774936f6e0b07a47995aed830ad2e4ee2ef4ed6a08e2405dc16fd115fefe4a795eed1985baefbd2962d12f8ef2487ac452aba621aecf0e0c5b8d8d79047146310b51c9ba037c6b51cb64a9d215ecbe26d85044542173775a3b11b132066856496b899d4e33bf441642c71f6602537d94d2fcd86e2828b74d3a58c7f214110ebde9b403af8c2d61a1ca291d6494df2248d153ca5488f6cb924ac480a1c52930a87a76d8e982f94319e755d6f3fe6178b2b051827debf383131ed0808b5a5009f17280b85cea7584506207288557a02beeb253356f9d3b880c4b293a3d072b9ebd69d6decf6c58b7cdd9e25c4b1eb8788f33e192febf8bada9393be2c3b76bf448dcbf6ef91a22d9c129434d635c44771daf56f7f7aeebe528038a6be18e2eb83847eb55c83a0f0d484ec8b63515fba650f7a0c36cea38eaa303dd6f49bdee5a772abac2a81685a7082957d3108534a0948cbca5adcd730aa4d82f9753e7b0869ac602aa3bfa8e7ce2054ef43973f85b8c29b33db9fc6b156f7611fb1f4ec9b9d8590f02045463fffecfccb62a892b1a7c7e69e26a6aa34d2ecbb9fbb8b5e8e97889c15fa75b1126e037b4afc7f602a7f0e737a82c4bcd044008caabe7b19ea29e8c1af399fcc8b16fca0a36fc7dd9220e4ed2ead1623073a2602d90f83b267d49dc4bc9b7deb7dd8a65483ade5c50135925eb8a24b1d655bd3835032b0a934f7670016e04575492e2f3c841915c87b59ba9393714b47ee11054c079ff4fd9bc9ce4008a419b9f3cb577b223331fa25c1d1d34001474c8da5a70c120618ed1629db3dea105a190d1053360aaf94ccb2351a28cda6d686bf785e6311a9c027fee050719551096cbfd0359da7c48fdad8d25ff5bee5c601f18241b94d9c137980ed455145b6e776b76713ac3aa0c19dd01a6cb526ba637a2068d46eb95047cbe44e4c0be620c68dbcc3c6f7a63a482d2d6e085947d719f1f5290f993d4741eb054d1ed80f9039c69c7146629298ea5cf01d45e3fbfc6b1f3b73f18d83563fb5eb818b15a16bdfd6b5742f4efa86198ebc20344b034947b52441d92019d108aff4f9e5bbca8e33e41b7204ceb661d2bbba0675401eab5c96cc0ccfe2e782644c01ef017dbf929641aa22a8f9269fb20e4a842507b6ff590d4374afb237448065a6846a13ac56dd2f650b97eb78c4ab2378588fdd3b2364c48e76415f0aa1aa129ad905b95778763aebb9a7a711a3e3825b23137457ed20174065c26065cb688ee3d7448b2f312fa86deef77852d24480cfdcab160774b225e809e3cb55c135d1874cf4f90d69524e6ca14980a8c6a147be7b530883c76a9a990dad6f3fe0d1fd5e780a2db09df7c1cddae79063fafdd6e9d9b4ed9bc6a5479796fccfc45127a6f7728b30c256643ca435154f01bad1024775871913ba632c1ecd61d53fa67dbab857dd6cde38138ff6722b0e43e7d4cf034928a2e8f5817294a8211c3bcef89609d8433ff96b28e45bc8b8298e5d95b08cf8e11571fae9ff413d78d692771d1e1233a0d8eb2e1029e0bd1d0d9afd56b67400acc3771b490a93b1fb7448e82062167c3220819ee138978019e1975e45a864bb2fab52ae18f42bc1a12de6259c0cb403fd0cce01b3bcdd8a25704589ab4b712d5a599a2f3476990eaab928647e5d7ae2162dec74676cb797d61cdde7e2fe108a622f7516a915ff528b5f47e43588763f0b6616bd1fc2647dd6738b533da181be4db00469c99313315ed7d3de3aa49394e9bd4a131a3cbedaa876a3ff93b8d2623f78132f73903b5275a8e162f9718d9cb7336296c4e9f411af99c9bf15503fe79ac64106e959f1b25b92a06a31ec47755e396136370179d50209a0cb152175b32008b576b685840378b22b16b249c346ff00c5991152d5f39955241276c6b9e7d3407e794ce71b7cf8e7030a7085924c29f40b6d0857041fb8237ed1de1368f944fa57be242e36af08e61a352566d1b4426c96e3c4b26f0e55402efa084bef2ceb0fc7b03793bc3aa1754b70abd2083816cad97a0541a346dab460b580401e5aa87423e92e1ecbedecd89b8d9b6b655595d7995d2c66aee32150a9a2f4a5e02b2b475dc1d4ca50a0acf3693f73f18348e41d6a3a381db94e362e375724acadf8f7cd231158da2400b31b6daaf1297bb002f5efb937424d5686669b029b873ba3f0b934c547256af75a472b869705e1487d164665f1657a2d574d85eb5bd8e53d2d824b0050925638f3727445b151a553baaff991b1c050e479d647725b479e41b3d8815fa720388544bb0be56115365797e4489d809055fabd7758706884ec5526bee13a69e8eb64a0c8c9105bbe119b73ab9ff9bf768ba73aef5a5bcfa5b7f27f4186616fea7c9b6e1c1226316d811995ecb83828e83a973f56d91071b48f0730c09d0e1d3d6eec2bb1dd9d95d12950dcfee758a51af19a14a3a13ca6da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
