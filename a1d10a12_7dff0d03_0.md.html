<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55648092d8f175bcfa1b3943f43047e8e96607f7e56771d0a97e1067b4af81cb7ddc4ec03ede8679c349e8ffe49b4e8724c376e7c61446019b9e42177bcaa78a50b1f30aacebad95ace537b8894f6fd4291114cf665f71f2aadd4f777d9ca6a5757128c2ca9fcd3db0a3ba154d336e770e4a109a59239b6b0d3741c53c71d84a65593bfba4e01148201045bdd77b2f2538349ca41d5d31fdc793c68d22c6cce4b1e1eb8e9f34ae385f1ae5ac6abfae16ce4882e8839c4487d5cbfe89d0be1b42bd684613c5a599247374c99e563af50a39f9ffb1da3dabadca83705504aa2be0a3f09f0e2faa295140b5b919a4d42cc9a61bc450a89004e72c1bdd9f956257139a678af6c826c8711c05b107a1cf691b47eda199aa696ea3bcd5c509309dfd135edad11fd63385b4a6f7875a0c57df1bd99b38c15eb17a560960d7b36d746c9b79d0a72665cc304f6196860d4f679a5e94cb0750926228f0106dee183dd11a928e4c969014d64115240d081be82fb62e3c0ed9aede1ec744d621bf74a355669059e8b52f533e73ad545b7b5da13bbadbe53d895aed9a53554fd35eb5bc41cb72c276d82675ac82bf15774941789976b7da182c1a96f3c7761c76ed71b8b02b5e819f10a66c047ca842aaf459828bbd88a815436559005baaadaa415d75b2b321a674d427e9ac4c5a909496f160139cb62b79c822887b423d2c0a8838c6f99ad74cae154e13efd23d58034f3783ab6e6c9038c14692654dcbcd795131f47e5e632abc5e011779279166124bae76c4125c6e002f45c8db8aad1cf11e2a6a1027f1213a8111d3aca7c5a755f7f8277a62836e87c3b38776296ce053460322fda4f9fd5b4b16b0badab88aa3d1271e98d37190fe530c5fa3fc44970b976931b98bac1c1467eb9e1335e2778e3f92c750d6e2dd779383c98ca0910bea8fb1c24da0eb39b9f99b855631f931722ff0fc7b153197cae0921b5f25e1b1659c7dbc731f3cd101f82c8ccb7a15e469453e8158b6da110591680b16ad21d9e016a287cffe6d8e07bc16242a9a71be9e7f83c8f44cd2b60413539cee2a0ecbb50514ad46f7cb69c52372efbceaf508344c0014a7eec3d280c4ba7e80dba716ef90563a64e6a556734a6398840860d7d2de1a5b9177e8e42b438ee134259ba2b8920d7b4a8ccba4ae77726b5a836f7e97b713b4c8bbb7763ef0013e66543aeb618f6a83a96161dbe29ed3a2bea8c0033b9dc2c51c854b3d32443f4626bea4ff39eefc38b33e8875d4d461fc151f865b2a1b65108c976214889b8b81aa5b0df87ba1645cbf013b024ade6841b0a1821c8226d9d38e76236dcc0d8d752185eed72712d74f488c1e705b529945ba5c3bf87eda8cfdf44542f548f6bd77f1c363a5a90f2503672d73038ea583f6998008f6c0c72537fdd84850a7aa87b96ab05f66613346d2b388f3a31a126d3a99f86c538b834550b8170bb44870c309961635eeb37d34c37d743bb01719862e43a39527086a8175cb9df830bfbd51740555881958b2a461a08fed22f5dcec49d0bd86323a28e430002dbf96f39e9198e475b1804859f07dec82a2c7bea4237ee19dd2851b8cdc2fb16c08e82111b8fe643bc9dc5b9bf5196a989d63148998fe70caa7cdb99d319491e967119c20b122b39ead9fc5bcce59048b4a6322d83e6827cb0d566a708aa178f1e6d132cb7139f220c77d2a9a1cea18ec454881d94dc74aa52708d0f0749ef074a192dd0431f71e37dfd791743006dabe4955422eed2e9575e06f9cdb6681f8c5f47b8ed4c3ce3069257beaf7003b37697102920762c001252b80b30c335eba9bcc533bcc0f5f51c8c543e9c915f3445b7dbabf19112ff408e6c022745440c8345a03637346073b8d2a2b6df9dcbd446767afc29c8e1ebe990934aed6d51e76976e058ee1870d895385c43bda9b4fd11d2e280ee1afd28282563216555677c0c7a09e935a59adfbe4caec5a3f96f8f3a796dc4719e9b61dc381209645c1eb546b92820425db0d6a79c8d694ea0c10e7f4ae177afb1dee918fab3a56564f9c55c1f97c368191bff4059956b536b4b1e8d93d6cf2bf2ce369e44e677a1c726e93c94a4984c05e79ff3289f03861cc6dd1d67f7121d3674c905612f41d039a8a672623d2163856ffec662a6143dee81e5d442ae04673902c8f453fe10e882bd78531743d0cb549e71091783a04e1329a363247b8e477fe0ff947f3706dc791fb1f206189916ef48cc94cdbc90f6072b87b6fc48bdc5029760295722bec86c47efab6c0c0979e18b871af50aaf922ab60f92c800be54287b1746820db4917c4c74d14ade629b3177f88ae848c0c9051a030bcbd4c69697d2d0a41382e969b934c37b6b3448c7f6af05053679925ecc4921b9f36d87e9bc3dd95a57f9b3e8f6105b4dce63717d0aedef8aa35f84ac9f269692b50d36dd7a12a160658b6fbe5e2f39b70e49a48fee46acde3ee4c2fe9e714fe4e35cc0c7687e70b09d108f3e6a36243cd1038d241a51eba23c53629a8234560f48b73eb1f6e9e076925e756993ecbc7058f997d8fbc9c1d1f4bd20752f29bb63e1cc2e2ccb5e2804a851abd878b174abb0a035ce8c3d7f8a52b57efd77bc11e3c0dce69ca3254f98a32940139a1ac570bc212b3826ee08c8310ce1635c76557477a07090aaa9e92d5e026903ccb3e5d448ab751330285f7309564cbc132b3ba1648f5364084f977995bdf71e6df1268d4cde53334d7dbea12de3b69d1b4d1e3ae6507c03f5129a5917e1ec0580c229b9560ad05dfe982b1c47790ae6b08d6c99aef9de00f5e0bda90594fbd84ccad9497f9e794b8e6627247de9a8fe272c49d68227ebfd9f9fa8b983a8aa15a148dd4b95f2472a9da472b18401b3ed0c2f1a25ffd96417aef1e7c0f57e0d5ef9a0a38a1c4734ebafc97797e769e1f4b1c1ac1db9549e8a8b1787707f08e2f629debf219533fc0857cc500044bf5923ca65877cbc976660a67af2dabb95356c47e9ee3b56cc793cb3edc16bb359b23c0d9668d89bd36814c9d8fc7b1e9f5d49b1fefcd606dcb19ba2b0b628782392089239b5fad7f513c9a38cf630f1de9d5ad3241b0eedf1ce595e5ba9192c12ef07b4d8c3727a5dd036b938b2fccec94d1bac6eb894ceee3bb7309bdb56231792025f94c22b7631fa465026d97a8119b157717a5ad6223659655d3404e37e0f22ebb3fd497ea14517c1f7f811a4ae0633bf2b4d0dbc84cdd33266c9cff2afa568c5ed4a9d2be11f46c3adb130abc9c171f8b905644c175c9c199464d2a8af38a1809d21e6ee70c8b6cca18019ffffc2f26ed37cb3f192bba321c3c47a769ea00640dc62a69cda1dafca435d25f3455f74d23a3bb4c55bc3c773bf7e0d5655dfde08dffc934fc7efc6417382c6e74f8536c40ee316c92c9fbb2f75a0de934f75ed8b409bc7659994cacb1e1775c173ed55109d5c9a1206ccc172c0b827715724cf7e6fbe615044fc513a4783981aa7e9faeef3c58e34dff3d89ffc2a06afad22eab6c340498e87ff402a7dee4beefc1d009d41ef949af6cae5b3ae1545cf3c14c9cf007d14a43243a8487e247f1efe180ee41c619895e3c34ab487177e0d3193061d2c535a7dd6ff9bd3783c8f6a0c13f8202a29047a17271078c6d9efd486f999dfbe46f44e8249d77bf78cbbc365f229a881156857e38896304e0aa0c5155cfb2f0e98cd4b232f0988208eb9e44419bc35339181e333b644bcbf7e8522640206b1a59274741a59c9ce291f98fbf732299a5d06b106f345a9fcad3e953857430cfadf131e266bbc48cf44804a72ecd798f32144437c698263f0bfd457267a037bb957b8683c8887c813138e68d745398badb861a5110434d01646e7b7bebffebd39da8cc62893e3b221f952ea6ee8425e72dc94cb87bc1dbc51c95cf659cf0ec2ec8c8585ea44b4be93f01561e57f3cc3a1eeb9af535ea46b974c067de2eae3f7956ba535ca8d8a163decc1a4df7fc3ec351c9833967a8e0ee1462413cfa4592916f637e26ea7e1b1ba32b17cea4e82384bc8bceda20262bf588fe716370cc18bdda10f8007f4253e5111fd18ffc0dce77a197f74869ebcef6af6849fa230318baa87a702c66777a92c9599254b4c6912c053ccc2188b89d6ece594a69067a8ce349633b4bd70774a9fb0424ddfb232c6d8011d79552c3150bf21885e602d63bf011dcf41a217fdd1b2be82cd9f0b57201705cebe550f8b1962a3181b790b0c644da2a3d33b267ae2805db397f2d48527be971f03931d672369eff8aa16029d5feff5a9f47fd7f5613df25cd17a3e4c6e54cde170e84d8bbee5fae6d4d3f1ed03a47672935d455bd6c31c8e7539f3218f077fb5e9bae86a6f30116b26685af50c3540f168d57e08e5994720bd6df1ebaf773f8187a413db8d9f94842e99022da94fe2b8a83b17d6b99c21a02988cbdd15d10e6f0d71d897bd1a359c62933500024129c46551fa72a1af627b2c6418aae2d3e452f100cd77846ee29ac93ad04916646fc7a25af27ae78b9c21a762e610a998117d7410510e383aa50595b2ad50d1b20a9bea5e584893b3aee734db7bc1afbe1872194b19b1815a469792046b63f036dbef09d091c6b82a592902e52573212e2b67439f4c96dc02e8cc0e466b0fc6b1ee8fb36efa434950360a459d29bb0b88c0db915d58303b46ae2a9d99c846eca0f3eea33d4ed6769e12e1c9f91bec606a07850a4fc80a3adaff5192e08ff055906050b9b8a018f99a03970688aebc5ba7cd60ae60cb31bdb7a81a52d04f06a80caa230a872c3ca16444c36f6260209e65ec4525c255bb0b2d91269deea6504cbc99b79618840ef180fd3faa6c8c42e67a039b4e9f6cec2eb4118c6664fe2a558cc00be4bb7aa2ba3a23fdf7a0029a1c54fa3b800fb90458fb4ae0aa870b4abee634b28c251009faad91ff624389ff5d3d9112c2985a6afc43a758932b5cbabf5277d25f4c6daf175ce3599d7fdee6a185fd50a2320c3cef98683d9b332ad8c5b2f11edb720fa6b61e94dfec40b0860f22f62546c581f9edaed6e4a91df56acdee0048ffe1e43d8af689c98df04cb5b8494093c7f167a628c24c42e0bff99c4a95d738aa81acf2c730cfdfba739ecebe22ec0e9d94d92d1047ab4a624d497867f5b05459706d9ed8e2efe8dea5854b8ed09841377c33ea43cf0f9631624edcd097f1597db4d29e8f1334c0144d136d92526774587efe48a15e2aa0348dc31b30f16dd1783d50feb72c9ca609eb0c76c1292aadd3ce356e8b576f03eb65c810f6d30d4e48e1baecae99cd5329420a46e9281af980b15ead96d8a2c000360787e0eb7c41e0f7929aebbe87462270f1d739f1618cd1461fa8452118bf55c4ec8eb20b46da0825901d484f19f06953d1171cfaf3d8b6c876c521b2c425f1a84c2f6ef7d0c1a7492621af86cb23543c12668ad95500b1eeddf6285e4ca9fa25d323126aa22cb7b7b2476e9bd36e955a8045d6bbf0d4ecb4027266b1de5d3d0c8f6425b3570d2a66b3e5dd0c5a90a3aa083fe2a8a7012c1f8cf126f42f1d95a01502ed1e146d0449c1b527351703e90e7ce532e167d9b62beedfb339a8b53205f1764e27a07077421affa04612d3f79a00f9eb53855ebce1dac1318e8c3d2d725cfa1402d5dd3fa91da358324404f29c47c6dc420c0d5eb57fe47833a8d9598d2eeaed942020e8a5e7ea921d27052c9215faadb2e70356f23f1a04e6c237ec7d2a36e92f9ecbb1d0b439c1462b97c61e941c93727ac384e352d12dbda0693326e5b8c988996fbcfb951a0f030d93251319c713203d5d4f66803e304c66f7375106d18c72c7110e1d4d3965227bd0dff718560dbcc32b497dab2fab0e24d541e608e26a7d109de5a11c5ef964eb1eac538af0b4c493544f2a128ad387fa0d5381ff278b8f6723bb94cdc3483bfa7651d2c065c9774ad4657b5e7eaac9a376d82a94e60849e5fbb66e5ec6fb38b223839ed9e10ec4228b72d3d68b060ff954e32ab815e169f4f54a1e87264c89000eb1cff7e1de34d89609513b7f93dec1512614824a41875d7e5720c05b0af2812aced1693aa6a57e61673b947d6b5239c57f9fc5854d15d27353b88a2aadc9ab018cc0fac56bec0e57bd5c90816f24bb09b339210a270eac09566da12c0d82e4d03200b71f845af0fc4db65c456aef943cb15f6c084f2fb9bd43da1b4b986df92d794201365dfc785b82857b5d640dfc46b4d104315c9c39df03f98b77460a83dcb39655619f40056513686d1a1eca3475046ad894973fdd2fe990ce1997b685d718cd36dfb2de798fc64fc99c207312c2e2eb1108c3f937d98365d4ff55aa7812b0f42278f3e7cef73d55243f74d171d32321de01615b0300d9f92ebc6d56ae6d45201ac568d38b39cfa3b529a2b1abbf811a82296e82f875f1f359e66430cf899f736d5c2e840ae4cb9d0d94930ef2904b9d079b3edb395fb6a51f4a5c575c5de73a2748059d33d7094e2beb4fa3e8e0f43cefd456834e711e90368eb78d0e957090146f83dd7a2603aeed29e1a58cfade4e7e4cc19996f5ecc5df4ae164c115041b2ff8fd8cc6395db8978286be534b4f70cda8cab2a0cf734a42312985c7b825e82ffe89586ebee2b8572a622a85948af42afefadecd5513591fbebdda2daf5392c2c062523a8a8708f32f44b2aea4da1cc9cd503bb2824cbca49d13a11d8d5e66edb5ab9b9627bcb9e4fe92230f57c39229a1938cf81ba33e139f5710fb43994ec5c148415937da7a5227b4614f75a348519dd63a34d73507676cf91c094b46ca0f08b0bc62be672ae7898f20517ceeec9c6beebe767ea851b25dc1e0631069610d91709bb9dbbf1726ad786434820a66c2e8ae8e8cd9ef899f2aa421492e5e44038aea2076106859e9e0fa33cc4f8e20b9b950a635f6e75eb51c5699f616cb667234d3cb3f6a2d06f60949cfe0e50e214031f40b2590c270ff7a663b2f3fd6527b627e580f8f6e5682ff5801c6e268b505c972ed7c67536e2485324150bab4b3d44ae540d09f010c9b4cdf9bb8c9f758872d7475f6e77ee77d0982825dd86cf6e22114b88c58e8ade07ccf620c9363b83aec48a4195603534d1d3f829e57dcc68621827464eea423e635ddc5a5ef30c7cd3d6b68a1d60177964983ab0a422eadc1940a275760bd2ab1e8e2dc64213d5ca63a7f711c5d6fbe3f80f5f9cebcaa3994dfb19faa19054efaf6d43bd4a6576bc93a1326354bb9da8354378b7d90d56c291ccbcd42b0c2d872801a1d957f720d9296d1625f3b1034f95cb14c6d483a3f5467454c71dc3ee2c5365d3ae6273885db08bc233ca2ec9adbe13fb8aa4a498911af18901ec3bddf0b8cb741424c3bfc6d911f11f9773e0a768f9a45a717a8b14b64157848cf90691dbf6bdd448ddf184f6e516b019278c42bba00b344612d4f6176b51c9e39a18fc850f113c8679554a77e90e47b838c4253ea9c0599c4f826c230f13a859d20d241e41b1700dec3b7ed700e613270d94a8a8352e8b2de5e8957a27116780731ebeac484038fd344e120cf07dbedbd0b2cb940d0d4499704ddcc4c6a15c5b0449cc3bbd009c6abe50fd31b7c25e1d94c3d6ca0525d522606adc1992ad6729456d3bb4d0b9a660292cb31ec79a95cbfe4e4ebde1033cb2bc442f2c94f06637cbaa6e41dbcf5670d9e8864af82580f0e9f4620673ed85f9900fd89a9b7a3aaba895244e2cdb0f6da97d913bad17375a9fcfe5d190c222334202a90f9b4a9c34ce723ae4bc180da101659385c5dc28757620fd7ac90947671831352e3774238a26451cc14779a119caa2abe94b941b10bb970a029cf629697c6197ed98979c87cbec0acd2add0c21f345fa21d6edd7748a2f6c4efa93a9f75e449894249a95fef81500fa3cd3836e58c2ffa3fe2412cc7272e0ca2e3d5d1cfb14a6eb522639dd18dee4f839e101c76c5909c550499fe8c0729224450dede24da9ae88ad125f2069b3cf30886482cbb5f079ba8eb9d6c2812a07010296d4f07c5a92426f1ab11b49efa1138d60d96ffe47d98b4f01fd1dd602f1f503adc46db43324dcc4b8b4dadfb1308581358c0eea16637a2fd280a0ca1bb8b50c73eb33c49baad654d5ffb0fe58200143017af467cbdc0aea243fb4c86adae8801b3847116fd9a363be0be70c193e4535344b6c3a357ee02f04509e191e2f29fcdfe08e86c0ae0f2261a2de41bb7e47980ef293a2b6970c92e0313220aca207d455d35e638029f195088bbed01900b4456060032451a7a827b3ef6f15f84f42373d0f8148f756d91ad1d660a0efac65c4c688f4c2155615b3153d62780b023bf21940cf191980ab44360c0c27f7fc9d8a3a30ed98a644dd007fa6be48638a04ba73fac84f65e5a8eb7aeeef92752593455f89ab51c846b9548ef1c79967c7789c4bd20d1e0aeb68e06517c2b85bb103dde741adc0c2ba276088bcc18265cb5eaafaf2189cd3234618a07c0a555801d2c34f8fe13d672d32ce07abaedbfd330c55d81cf39c4f013a9b2c8c088beee7c725b5acb6c96e5bf70b25f18776c23cf8bc34a95bef297178f931de69dbadcba63b8b34470bea73940c832ca3d806665dc50248dd35a376df20b4959084b7046467576ae60acea74247c2848d7242889de8bc1c58c31211eefd5c48a972a42b74156ef60ef35156bc09699aede061b7d91e8c3871681875fe1257850debe56c0ec1b58062f7779b5e8554f303d8b14cb229b388d91c424a32f2ffe35c18dc5e97","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
