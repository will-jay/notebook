<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf594edc0efef530236d8808db1342dfc6fdfda30eec9932b05cd9fad3d48d422ef5a112c5297a3637cbe5f32e46059c26c368206dcbcbfebc47f5732adc8d6cc686d7dae0948c3ad3070659f9e991404f2fae3ef2a1b46229598a202e06c730e6952b73ef210c06c41d8c3e688d95e264df60df12ab7c8ab38f33f8cd5c4e73bc7c6ceeb7cc3f96aaf5f8548237b3c96886c541747eefb9747ef1b44c482446d2505ab5cb773abd45863c440e7ed4273b79c6a81bb309656bbc4f6fcf94611136c7de2b47c55457eecd7d52cd3f4f18462b9a5b9b4f35ef8048122cbb5c99d192b493042c78ed56aa5dfb6056121d6bee104e5f71195153303fc7ba6326983a04b7e66989968238de4cebbf544e67d6e83a909d52eafa2801ef9ba814d37cd8192ec79027c11dcaac34b8de16e173487eeb9f10fc01a970b0244d6282a2a3ccd6d2d6157cb820ad41c87bd56019e9e4d83d0e5c5b5d9eaf4224d7fc029f6573df553f04c28dc092846005d1e6f43c092479b2ec2ea566c01d488597cd46f109a95d326d8bfa00ff01b469ede68c7056511b413c4ea54ef82a5298bff51e6b68ff24e578c798d82a0a71fa086ae7a72b489a67cb3d50938855a8ac2d03a6c38b06939bb62df89f7e827753afbba7794d4f188aa0375f94919e43f58224270eac44b24843fcc0e6848d4bd5f3af9658cf1b16d43a167b7ea80d0e0c5af8048de26aa7c7a62ad90b9dcd72414584123bae6e381f5a048937e8bfd6a0adce8d4adb81f4b2662a782ca1fe8a9b2202e0f3ba804e1ad93e3c8377f639b7d80fc3aaf6fc110b93e33c823852f68b92a03b9c33c45ce183d9ee641d7bd760b7912368d10b8263815f98280599f9263218139bd208fdae3b3421e96e09d0fe390d6ed94761a02ce0b1650d7be974f276afd923f3c38a98fac4ff5406721c0c3a5951735d745128103dac3674124555dacc19e81bab89c0645ae766e717c0586c53ce78e4c94cbd19d1e99ab15f924566892163cb39b227c1f83f94209844f1376119a17314cb3c138ff02bb5daea169f60e3d69c568fa7b6389a95d90284337520feef68ac76a27ea256810162c215414d5d65dbbdb6900c79afe0ce84c65686098096edc26f2c7e73892d2852c66b051f3400c6459194798f49223f3d35dfa0c76609abef9443642e09364750c04601bee6c991171246967f5a0cdbadf9343a1b38bfdb46ecc80fa28c63bc48cbedd75b7190eb9e5466408b55f47cda95dad179f0f04adaef55a05014341ce029310d1e8edd97e0c17fc2e925b049416e24d79acbad94008b2688339d7d682a64cb1eae325c9ba8e546f92d54c49912ea0ad6e9eed6856b3d3c96557812b61c6167ea90cc499b386d1109b9a8a18915746cef9ac89aaccd7a105cf87dd3cf62f2804d7a61209250d6b3d3fdd1b90eb8c7cdfd7941491ea8e6299bef288e9e4ae70d0b69ca81286ecee057a576a6567d4469aaacd169d92036d0098d2b0c9f3696df2663a9eb5789e8005a74ed04e2cfcf334450f5f7ff56723d8a203745f7211dc16625c909871a20b9b687f4e94053238a5eafa70e007d9afa1df5438e6491724fc467aa548dfa2b78a67f8b047179009582f19e23cf373d19d2e86779e5de6e8f1c1d08691f66a360a3da9aef7e908c033b15db2cd9a978274e1625cb9701ade4aed7c5261b8bf0a114fac4a8f50eebd9e80e3cb72ad0d6ab881556bacf2cda3caa8083463b2410a008a52c4ec58a0d6050018ef9d8c7eae940b21f596e1c99e4fa083062e2ba23c485e5f4548a64679b141f5ecef1296d3320742abddaa75733932739d8ec46a2e63cb492c7d38cb4a6cc8a736b1692a058800b3b0646b71543d1974b875c715392adc71f5ab09c8d538b129f6d234d00516a28cdb8e52bfbae7288eb4561b6ef311be4bdf50d302131206f76bee2df84e20de0893f095f58eedfaf06fb921255b7a0a44a753c68a9175c1e6b77689a752693cb759f7990b36d474876c4400b230a4dcd94a1c9f2b8161db4d59ebedd5bfa04899370fc7862d8330ce0b394cff96cacf8bf5f0b5f5b7c5ef46c0f64271c1cb6bdd07b8b58732693d6c4b1dca8be6a950bb158da7d940358c0e153c6a3390b272ef577f991cf2b808fdd0feba35d785453a4677fc0ea065867814d203203910e0721b047b18af614b96adab196af5818cae1836cc2d4584afb422b609009d2f0d5a627fe7f3337eb4d1693a400f2481047b1cce2c320710773c3fb1560db932812592c3a046b7ac83e070a74ea86b79a4f21817d5e650644cbe95b054a192045f8230db0781a5091f58fcc55d72dc29b9b93216064134e1a581905fad8bc5294c7d3957459290a932e2b014c7b9d7dda57d5a489390916c7526727bb23e0fbbdc891bce5d5f2a278e78995154018bfb2b7ad7f68fadbcc0560203a9db158e1e40ad938e9a271c00c3d96cece7c3b5cbabdf8ad95f302922fa4c6b28a5b61390abe0cfaa77ebf1c66b4e0a85b31d18af90e2be9b5bcad8af8a0451606a7af8e71619a34b153b156664834d7d3fa4c1c57ac30811ec934e3aa457770bd0c9c1fa664ec65b3d7967efb92060454b07c567d6cf16f1568596d9d652304cc4ec77952b492555abd14a8d936751d7792b074e585b712abae09ad06fc63260d4ca1e803ff7f7cda78bdba2a636e2b6379e13100dd79597567f5d25ce08f816bdb85fe634fbc890b1b7bc747a3e5050eaacbcb45cb8c3fe94c48c91b6fded5d7e4b127912569a31d415c18c397271f6ad716d5d131d9ecb548a90149e5b8048dd046c095878dc0f40e798afb2cef928ad6b3fb07ccc19c7b820651317314a91e629cbf7203f7def2d28d64bc79e720d3b402ef5b6fc42c3c41deb69d51a9b32c0ea804624e1eb42c3abfd4cf0b7b1b5d28fd3643cd45d687d2ef8ffd37e4c910c51f08a236d8a6515534d2db6f4958bc093dd680bffb567daf8e8ac2c05fc90bd9ae119369b8047a725367a0f24e983de271d62e82d9350e83c8c850fba88d1156fa63ec2db33e9b169bc9d05b1d157540e2cfdcd91edb4e1e8d2099651d1912db1f50841996f246f3945c23ce54fe6584ae97108a9154b3fcd908a06e343d1274e68837b7a098d63746dc71fcf134c45d3d8c0d68d82a245c9c70267d66a1d45708c75a7495a3b45bdcac9c50216a65f5f0e284c72a790786e898b23cbdaccdd54aa60218f6af3adeea4ad27f1d155d54311f1683bdb126ec4d1e64eab6ee9cf5858bad91147f297b441f98b5366128d0a9a201d96be84f215d8107977ef8fb778d1e62fe4f264442c339d32fc9022d18a6fd661e7c986cf4ee50ec75a6fb54dd3a771a7f716c23713024ad17d099dd65a2081b073798054c258178fe8ad3cae1b35ccd52071d575b9054006d2ed6476166634cc107c0e147963ba235a00d81352f3046ea03357d0e52cfbccbe9451d2cad04f5ac656e12a08294ad2dc4937dfb3f2127a4dfac687ff233e104c53809ea4ed3973a641a8f2d187f5dcb5e5f36cc978c4712e49a9895469b57b3b29012b139ec35fa208a2184b4b546a0de1dfc523c18c5d2bd289ed9ac6a8f1eb495ad9c732603d89522f532fa18a62f43c78a90285937b2767984b83b9ac0c5ff5592787b1871c916bd262cd720c3d9b14cb9aede70bce74f6d7803bf1c305441eb72147dd61848bb89f28d3271babe814054eb247349d3fb9e203465a43917a1ed06799920dbbea64aa8280294eccfbb06edb1dea55465675fb06bfc9d24c02408c19f839532b54ba8d82ff7484e5a3d06f39daec0e5200acb3eba2740ebdbd31dc6b0fdd5ddf3bdc46af1018f1e1206dc8906dfe1736d25b8160ac6114aa78c0a1e4adcf897f1e4622ab1959bae9c4a57f9c7b3c5cde43bb62208c09149d2e744b4c95640418603f507df536fdd9924ddc816220c4fb956032469646c06b3037120b0b8cef5877f5c0e0ae80ffb42051037ddc6282b09950dfe1e6a2d2d412e74ea0041f3178e7ac56153b14b7a809290f97658474d50074f71f759997948f500c0099e2ecb23811849dea1b80889de2802c78bc5197cbce1b2b9a01ead78ff88d6f8ea712ac9eac201285858efdac1932d3661b17b71f4fb08d74c1d0131e6fdb83882f1b2e17ec6736653487a40452e0449348fa6d7ea981e09b491aea695df8d4aa7e44b413e9b38b0d52d20ec3641c92620c2d13be2f758f14145a8315092ec462593eed607c84aa9359b27d8a4344b8757f912ac13ee917c8b94e658c288c4a033c828406646bcc2339692b7f7c616dc02c7ad3b4954eb9672b5eb79b127f8fc65472b066443c31616443158435163077f11f5d1e1d6a658aa44120613f04265f220b07b1017e9ec57363746a16d3ae0a7749fa0b7208523100a87fa0c5c092c08442c7788235d3fc574edb10268d1b67f77484cb5d7ebe4e824213aad55c232d31970727589fdf0136441263d2a56498f8ea03ded1e3f6ee327089efef5673e4a9281456f0013414bbb6fca650fe3a53ae9e20dd7c156734bfcc8707d5566b78a6eaad7bf15385c67c6d0146b85932a2357a004a042977ee733200eae8d3e7d5167aa9b5248d3ca96ed0dcb59b4759391b104a587c7144b9cc677ca90990708d56e0df7832208852d34b6803148161478f9bef67d50218fb4bcb8d04792bdbab08d210ef8879badb2e3798f334320f56bd487428a10e6ed02e772fa51f69424683fb771e553a5d7e41a900f9683453431effe49bf72be4636c35a014cca137cc1b5b2c415e828ccf057f8780dd96697804ff3aaa950197ecdf63ab711e8611f04676db554f4c51fc19c3ee82de82f19ed1aba1671b86e31bf523c6b9251f3356a0ea7a32aab0a85ba4e197dc9d147a43326e705ba6ae94ab63bd0f036b0234078105a0b7fc42909e2dc61291bb558bd47193f1d276cbba465fda37034238a111d7f4a5ee9fbdcd2901a0601fd9dd485fd2826bf575b1941dc2c0ccb7a69b648e3c347fa06c82512af7dea2182a99592ba0be71291517f5d1dd787e025d4485b4c2b1f7dbc8e190521c34dba2a2915c01276eb751690be185364a28f0a215ac9cd67cbf9c8d54320bab9940ea40150e060083fb163dd2eedd986a20144a14c8379e03a5b9ef4636b3c886a61e6eaaa3926a6260030ace58ea5e0e8f0d8f7c618c0314cc8c455ca577387ebbb7960d22eacb9df9acdd56d86c913acc92da94bcf6d46ecbd0e122c1768c75a89eb7a4dbfb09e9bb3f6334613d63fe01b18ff3eb550ba09128b794859031a09f772e6babac6cf1aba86f0a652903f95839205da52a3b3a1c86d253b7066a10a3e4b0c6d72c95e58b9fe24fea3bc1f1d0954821be33cf795376fa1c599585e70fca50008259c3ab08affeab7b02f42596f75efae793d602dcf609be07b79d97b4b56ba6edb0834b13afe817cd0cecff10589203d0d7027fd505226020e528d1c499fd9007b7373cc1534d48042d02016324893c495fc4c171ec6233a61826f376e89373222810bb5c42c43764868a16e933701c5d51026c063ea0d3cb40d8164d7e7d3fe73332b9ad470a71ac39d77c79c7a2eae1f79fd8848f63999a16945554966b09dcf394e8e725d43125da0145d66555a29fdf05b5e8fbb5e9d0a335cf28c001889dfab6b1ea78d5d75d979b76fa1761effffa8317837cf8cfe798dd2f34d2842e44c5d260ffd6c1b639ec826ab2ec3b2ddf30fc27ce34e6175077261c06631ebc2b998770767fadc7da4db9a4900f50545dd589672e409e1edecff95ab57aca9f80131a3bc2f65fdf01d76292766f94f354759c8618f385693fa85fbb0ed2e87163198ef87c03c1e844388a92d5c1d85250aeea6b0d0d1c3e32c1a0a50b83f23b063340be1a147250a33a99abd4424e1c977e678792c40e9d99247bf7021b6fd5e8bd69f4c988811d559b1780d41b9fb04b64f1a7ac2c16e9adc08170a84486915b5a3ec89decd1d93cd77f46ded99571031e9b6613fb0430b09598df6b6204e7273115da7b4dc716f68c2cd43f9d602d64f0f49abdcad4be68e4a0a7b5a890e71ce3aae6aeec504a21c7af4d6b529588e64e31a8a9062ee9a7a74073d46340d45391a5d4ec9bf7960cae53007fa2e335a99d72c4fd8abb3f5df3bed6c1c609e823b81a2dd7b4dbc923a74d6f74c8ba84645f54f514aa97826612d9836eaeec2d5eeca4e749dbbdeb6bb83b3dd130414f15740d917eacb9c0e0da32ccf8796a1647cfc6dba4b99f6d46aa72854e47b6d74085f61d279c185e7e872fb78fccd609590758da4e3812abfffd8e7249a3130704468671f8ca4af31d0ecc6a9519768f931802c0d2510404bffdc49dd3b0c2ad444b1d06eb16e74066bc9b80334820b075794f8fe9b0ce2a2702b1bd6c36f3e74d9e5a793f093ef68bb2c319c856abff269bf02eb89ea98ba21b46659ac8bca004d5124704cf7dcebffa59e19933a44dd9ce90a90d9db683b252112bec74d6c74201c303159466733418307fb617d6cd43714e6f7c4f1f727e17f1955542c8386985ceba0f1f0d17ac833cab88ff4566b3415c85cf1c5d8789ca65f8c8466b0e5c37acca9273b75040aa51ebe5eff1258b5fff4ae2afcc88ccd5943a61fd76c86f883b37e171f8caff213997365b33b51e4140861bbc2670882fb2abd9614b9f589e6a7311964c75af28dd9f2482687922b08586ee6ee03cc4033041dc3ebcf229167a6a24497afa1dca62675fa6bb082d3286dbfacd352276b0fbe607dd79c55c89a60e3057d8fb002ff95d9b6057365381dfd011a04906b153475ba075b967f79fa29da545794852156274a30cfe3b10a989dbd67788de65d8e32851bb4d02732d6eab1c077db967b5a507c6729e83cff6a60d3d779c4aa4c93e7b52e62d96e42cdaa80de913ef21487a656bd6f8be7c675b12df7247b93d5464b6e57dc486f93ce64f109d87d5e0c9db57ebf078ebc40fad797c88d17d81745435750e1ccf29b6e803fa9a88212e1de8ff302ef16cc5df33afa9f5e168a91755e5284fa88363f56b1e7cb13649d203367a7775ed972fcbb234ef02030ad80d848479f81fe79952b8761fc45254bb15bbc50c5dfda7a924d7f7cde8740d1c1a17b0b781b033ebe3d314ec028b181083840800f4ce0698195e3b182c0ac18e58caf33119727ecd9e8b59b3ac9072128b776fe71f128a73ed576e44695d78501473261550717f9e1be56d655a00072ec6d9e43f6a2faffa55718cf2776febd9097aeac59e6358ad7539a3b620178d00e017a8bae73a6c198f692ea4e38053eb1f7da84017a0a281dc52078c5a6f8a765a488acb72f683333f20290d8dac2dc5ec6e150c3ef8f77e3c7e55567d8556e2371cad1fb4c840babc63a34645d5d8529f6657f203ac40e623c10334e39b618dd9e4978a762394bf9a96a2ae8b02b8efd417603617948d67bd684de082e1f511b2a9347b4851237d59258128b2dea2f7b9ed429b35437df9102fd6629904e15f41df9c0566014cc87fbed029711c5a560cb44665807b106e537700e388609667153b47528ee47c12f7c63f16a3578cf93e6c97bdf1583e7679e8761914d82a5dc04e4a64722c1971c898f9a8da197d914d9da227bde932dd83b537c9e171d47c35cc9c6b5f6225c2ad44a6a79bd2cebd86535187992910f1582d24997abb69f321da7fa9d19cfc1547c45dbd2872e0b88cc1d7d54a20a836839fefd35ebe76461bd4e3657d6cadc279935f2a300923bb948f59427e420ce15c9fea07f115e3acc0102b620d9ab9542ead06f5a4347e6a5c907477f30f49867856a911a0eefaee505ef815d24bbbf44d4b07719db77b88a788fc5840d8c2e1e07e043457721c164e05bb99ccb83c3be93dbb03c3d1256e7283e3bf00ca5a3e9c68c4e4e7352aa4d8680acf28289160fb48daff99cbf60a7cf4099e39b5b76e73019c9d5365e787c50c97dffe4850b377ac7be4282f5b50bc759d5757c68ae102b3ff9834b4e778829b87b0013c288743f2227974ee85cbd5a92e48463609b9b604e916140464e54b3384b62f673adbd24e1ba2c80005ae2bf7a1c25b6c2d7b83d40e6755c686e50c86e9ec786e94fb1031ff091dcaf2aa4cd20f60113cda4fc48ce8cf680aa43f518913d29b35a39633b89a9f6d4e4305095f88439033a8146757bc602e9697cd4dbd5b1b593b45b163697e96cccf4fdfef699eb89ca964a56a2d65e64988d24f502b5adb9504b71909daea76128ca101fcc7ee5a5bbd67b530b495ccdaafc5502c440577dcd268b63cf21d9ef21e29a753f1632a6e44a5f641ea649583858a43f3a3f008c1658a19ce360ec9b767afb71fb3756dbd083de2c82c82b1135ea9a9039b2dbf4d0241c80306cd2451f8da9635e406ad042e15b75a22ad2aa6d6aec548cd10149976c09faa52362469b5044c8c5c719f18f2c2111fde3dc244e16a2fbc016d4f6661b360680672e0391383eca3ce8f770bbfe274e3d874237f3f2a9c8e9df5743e6e5ebf7146ed4cb8d5b576bc9180cca389ec56ca7238da45375884ed27dc58daf3e488aef5790d71192aa7a818056829fe3ded0c5212df064517ec8033f802d8c565a8a0dc1435a097568d7e65387c59359ce30803316228aaf5ce68be32bc0b3ab7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
