<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c15996b309511bf00f44242a6529914b8f265a8b3f2f26365bd263a97d7b40e7ba73428a21243cc65085f0af037e2dbe6c1f8d7657821dd6de55c49aa860bb65dcc57280002905e4d90b588d9d984e35413cb70ed5ee623ff538fadeed3e7d62ade6e49dc6edac572249a7feba4f00b26e976656cbfa7db64f69e6dad7b9f196a03205d8837d9a8899b185495b27f1352725db77e6cd56fcbd2101851028b9aa30584bf426e0ec91f47e7d2b02ca956bbc801b4c4b65793cb6145f819a4d07c83eeeced8625200e997fcd8321ae3857f3e583a81ccbf2c42dfabbdbd919a7cccf954c1ebcdac49d56e6df036409bffca7cd81060734767bbe7a80ac9885cd17749cd1d4a73b0ea8162c833ffbdaab13569576a3207e230b1f0eea81d0b06bb3d8258c43e3e2de0b2c9d41b0ffc06a1fa17cf9dd620f1c52450256b8388e0e870efb8967b6f923fa37d882e8df7d8bc4bcf288233829018ee2e15eb6b6010d3b9f7a30e832011d63a07b6764a5cf475a60b1c3bba2a8f523e0de79b4eb8a4a53200c846c9b0a852912d11f98b46e4a580d2a0a84831cbaaf1f08fb686c99e97daa7f7fffe609a4496ac271d26a69d332d2b8c58b4c0caaf2d135134b0217b3b9c696f282d200f94f4b06a6f2e0849810c98718eb8880c3efe696497f86dc9ef26156706f0632664a93e64ceeea1ba962fc31e33188d397d6cc115529b6f4ca16b6d53d5af53fe81ba3a68584fbead9279d977392dd9907821a1457953e34c3bf614c1660bec6773da16d04bbd1f30f861e0a07e54ccbfc47ead5a1e9405e77a312b185ec560ef6f605c72f379f861eaeccc8e5ccef9c2b47b1b340a0344d4fc542db26adef44cd324224fd0cd33454d4b0a9c6142ceec59e1eed4cdddfe1083835cf0439f1bdfa8bb496f4250e9b0129459a311a2719d0617ef62a4b961d4ce8c77f184e2636b9650200546cc2d858595b61fc78f9229386a2b1a5752512d28721c3995c556b9278d36c8760a536282ee4ff4b5236c489c8da37206855664ac3a9d548025e52392c30bda902f79c52967076629736effc766b057a1a99cf5960d608c11dd93ed3b6b9cb7041c15a540e7f3163bbe834e828bd97439ae5efb5ed090ef58a95553543b5d0d33f826326bf39bd622f1936b5c7acdddb155dc447d3ce74dc7b1e3838b147bc59737d6e35e34957b465f570f9fa392c0aa5db43668cb9016c6afb551b76f870a67bb14915521a9dfa2735e23913e4e97d55dc71683758799a2861d95a21962433e4b06f4e1ccf610143a14b6fca01c12a2ff3a65ed8140b936305c13129ba24477e73374a830cc9588c000f1aa5ec16ff6151d119676c4b19343015a345a6c3911c986df16a9ca6a1888851ac2ccde3c71afca3b8b5009b2e15cbfe544e4c045a3d561da52aace7503f919c1c4596493872f81248e3d04035b07345da3b7586333278873180eadbe3908cf3d191448cdfee27db4dbb888c55057ddc30c5a32f75fa5a98748fbce3dc85f21c0dd910c438d952b2523da7521636c3d8076e6fece601f2e4acd00b819828dfccb9e989e322323fde2cf2208acb1bac3c069ec3d178a6dc58b94ad82a9a45eea85fc237ce14dff06352bedc32f4b765e6cf37447530edd013e8175631182904cb05a2c062b489d0cb5c4347f3edefe5fd57b34b33302f1024f2b00715f754748e0cdddd8bed269bd975757aae4652667ffde770b4e9d39cf103ae74fa5f242af98b5b991bf8b0a1c7415abc64af6bc4d69d14934899eaa3fb9f447496cd96c60e041748179490837388515a8134bb1b52aa9514b1c5be8e6adcc5963ee4a5e0d31dace5903e78eba66e6dfb0a0d12cee9346b0ba1ba84b5f498c31434d5e686e2b89af12674baca3fbc2405a42ae1ab7b53c1036906f919f4b65b5012a563d4c551e963936ab258d5cb38c35081857b328e1a8fec0f48b5c2a12e4fd27c90aea6f63b15255fa80ad1ac92722990b810e86afe6fa456f79c82a63cbdb1f12a20a36727c51ae2bce13228946abee6fe04144c8e4754ccbcc416f3b952704db207ae4df2ac4eeedd1767b9ce73b2212b7635fc34a035c59b94bd0397fe2ec46626c1681a3f6c21dbc40e53c0fb38f1f87e7232315f8efe7be6e550312771f7f0f0949743245f9abfeb3848affae8ffcd0d101b5ec199cbf251c9575bd4c99e5a656a4a17306b16351debe964c2e33c0f7a0be94bd63abc888bc276dbb6631ebd802882b648c84e8f58011fea8212e4f71cc8afea8b6c61535e491fbd3635269de7799cb41aa2301208efc953c62b39da99aafff9d823410904af2f710a3ef19a51d6271f547446d693af6ce81c71cd2c5211e6518523308b4cbbd6d15085750ffd4d0b6dc049fd856cbbdf734580479fd810c7f2cd74f4e9b72d8d10d53122c7c40350c18077ea86af058367ab0c482e38ac4deb1dd5a47c1a8d67ce22bbb7879ff9325e9ef2ee6b78fc32b568384b5ec7b6185794e18fac646d73cae0bc1cb2be9486904aeccfd2ea5157ec9c9250830d9cf56c3c2d5ea5ad9d698ce229dfe587c53dcd152f8a126bf3c250d0822c3006a36c433d5ec17dd223ea6c9be0660f6454224cd220160ac6a8568ce0d01a50baa37d71a57310b11e816a6f0ffaf1f2bd26f85ce9addab6b9bc5c373eef799d029cfac2d1eb5d17cbcecd13ce47a04a0a00974b3b3fa9de165ded697a6c919a997c936d28e3197231ffbca75df2e98dce0324aee82295141fa07ae290e49efdd0463cb0b753f7ef2e742443f7092e3032c7d04e03d125656dc3bde2a6cd2c4ded77257ae21069ceca2461c9bbd9529a6273aaebc64b59c3d019456f74d79a478f8bfb4a47140b9550703456febde8c0c8b44fcfc66964b48b08305aa06f0f53eb27a9b44cbc87b2f39bab0c8f78306cc1e52e658e106062131eb3aad0ecabbf28ae6909fa2b37eb104842b77e53550e02c848033d85126fada205888285da4755c610afb5bd6d8486d25af49f482ab7f6b7bf071ff38bf43dd64fe16e2e83ca120a58423ecfe6414c88db987d0efe1f02b22c178a41fc7b62af64296a8dd829c650d44a1f1f88028303c0feca1d556352b9509140abded06ab418eafd30518335fec384f214f8e1ff74a6409094ebdbd81ea13c21790de8aecd51484d7a389e2618ff8728dc2f3a358ab4eed07b1ed8302bce7f01bb5e9e855d08c9815e4f887b993b08f6710a629d464923a1b8eb9fa953072b932757aa55f9ebded3ce35ae84075121e730db4f5ecb6fea9c10b45b7165c93da1097ce6f8c489857bd632aac4fd9985681800570597c564af483cfbfaa3962baf3100cc3212393593b0496ef3f0879556a1fbaff2a140318be1ca6baad379376dd1646582c98b929b5a8c40891fa915998bd8a61b4de8bab7a61c8ebbf21b84ee5dedf4f127874e2605537d2e135a004baa6011122682a43895750efc46e9297af3ad410149f4e1c3492953e39231502caa46151f01919b07f600fd06692ffe565a2f187968417fc0d9ebe5caba5ea19ad4604a0ece47a9313988f2652731571eaec1a51c479d8e461ce36e7b693b7407c0b370efa159ce08deff96e280804fa0f1cdeedd04bbc6d769e6ff0b3d195b6be5415c93aa5ece6f421f3f6a6ad1d982c06a708cb7b72d296535b21502a7cde9a2578c9270bdd394d8d8e1a56143f0e97568f1b46497ddeee4e3c8a4e5b005a1e1a5757ca0277104fc311bceef49e5ed840c318e1bb3be14a16599bfe44126520d530a9dc9e0be02668444a3864649b36c0958600db52d8efcf48601b0e73babe118bbf4ea38f3e2c35b5f349b9416baec1dca0cc1a194ea77e8933088dc31a341b9f8ef269db30c99cf402c0855805a80d2aa47672cc1163cb80823577e415a33d06314e105019ba2b53eef19e4be891a7d38e3c5412ade59fa24f3b491ffd9227270e025bda10b68b8a2851934d109900fc962ca1f25c9aa39b8e6e66d7bb23d3780414bc1253b1f4434b6e78d42bc5dd5084c2ecd89bf7b09dcf14e6471ccfc94f2ba506a03b373d10439fc4283b6dfa77fd595aa22cca36991f5a358890219d8257743daab8865f156ddd82c8a63e478a05839962dfab12a45a1a9a3ca103d34eee61594b1acf3633debc0c1f1cd9eb5bffbbff4d6d7267a860cc961f352b0d940d9f12c353d43691062a9988d99861764a3089a0a191f470001166aab58ab609a48a3fe31138732611222ed735f451f9eb62636f5835463317d01e00ee5ff8ff1cc142647d73c41b2bc4e5d76df1ae240125ad9fb05162c2b874a8d8590fd0ce7721584e41fd97e25b14e7283148095c67e8d30b4bd7a7f548448e12a773573e0cbd878535a63bc1643c0ab9b2ab4e51a98cfaaf1dd47770a80de065eb114860d1233e9c7e8d5085ede71055a244cab3c0ec2accc334be647744d0d5efb85232a39f68efa32663f93f504c0f86b8e65a2cb46fea79f560502d9818c7b620e7167c15d64f86cfe331f61c47fd4e923f6009b68156106cd222e6ca9c15d9caa098d0e94c0706633225d2e69010c3379ff70c030b07efcb85feeb860e5de94758328a3b6c89d618935de288c9b1c6b75aeec4823644d4013d2f3e5aaed67492ccb58540b300ea09f73dc7c2465a0f4ec74150299f77f36319f9c487c0cdfb8f45dddb1609111582014bc8d9987aeafb0996947b279ad6c4175a9e30bfb7123fd44c237c9c53ac68690073102040fb2057fc10bf7049980ce551bdb0c2846a3483108654a067fa3a89efa72514a4912379baad7c9bc0b213c7dcfd42a593209bf32b8704770997bcd6a1cb19acfdd7bec00b56b411e1bac7e4ff89cca0716947706900d1735f42718209c0a68dfb1d63c22d3ac0d2ad8c248b17af56ff26916bcfc2b7803faccba669146b785a722c9040199c4618be14425e38f8813b8872dd19392272a847289a687a4ed8b159655d248c11372f939790280786eeb11d9dbdf0e3414c0c4e1634af7956da05c531b959e024a5b8cea4a293fd1c4a5ae4e8fe428d2a12fa9f6c9a769118cf219539ddc225bb6c6a1c596c877b900bba46038eb35aad5d9b16885edc36492cbf53dfc35ce4c78e5f65252681584b37272bb1361c23c707520c6c7874dde96b4a9b2b9852e0b3fe3fcce7827bff35d4bb6e221f4f3af83162e510f3f328c7d9e96e76fdf5cce36bec86f2ca6ee4f879ad6e2b34552e33d16e9e6305bc62216cbf426f46ce466589124922023418b4014955f2e3243f62038d394db4934b5aa51f0f730cd56c60bb817d6da4b11fd9bba549e0f26f628a54c3e3e411eede4ac5fbc22679eaa4d0ca548aad722c2b59352d3d563151afe51d79df3f8c3e798bd916862654f924b52f827de8920c9f6b2496c282817a233df324849ac2125045f7e83f1d0c771fe9aa168ebb42c8c7085c09c42b3a72e700ecf13b149643ed8ca3e1c96ae28cbc813102fb4317c74130ac30b9a4fdb163bebbf93061357c48724c7bb6ee8a53f0eac47dce34a76afe3259189ef86f0d21a5b69706b435ad7d465589d265d2e5307ca6daa371e523b75efbe93d3f03392c25c1fb91c6b789d0f02b38415a01496a205ba87923604c1558827d6e338b7e66877c3abd925a2d4db6a27fc131e646948dd49da78b23959920e9d576a0b58ef31d29f8a605d1b2b0d495b355079b25650b4f5ea2349b4ac17b0de7c2150f2d23e03549005f0c323676e319cc30319d2028775154d4009af68f08555b8a7664bd23a1f6c7c4d3db8612d019941d754ac3757ae45b537bcb3fe16b30364c6c690b0cb438a94a8e427423002489065348c8057a58e83ea634df258633675c3183bd64ec39ef59e8b369576118014c0cedc49d34c231c6450cf54d7fa24120d9a3278ccd7d0fb0ae0cb4f8e2cbf96515b1d5b2e7797938b534df806ff9e360ed78de225735e56a97e12821b7f89e5c37a267ffc8c3a44ff0a4c79d76d63cf52fef5e31cab9f7c65d0d867ba289c90b30662bb7e5b47318c0170a110ac42d460a32b7a5644811feefe8eee4f9718400d67641be14a44559479ffad47ad74e30e063164782886eb1a8de09f28d0c05100132e02efd5c767215089df39b9485451bfa478e34d30dd0adc3ec0d857630dadd0be72517547f71e6c74d97107ab27021b3d4d0ea30c5b78a5178b3a96a087a4914ba818d979b3632f13e49c49ab50333cfaa185cc3e29bb4cc0c4fe56518a4e64f0148e53a89e7cc7e1ec7d91c081acecc03e66fb10d99fb940594e23d7c659974e289ff1f13a8306cdcaa61134d6a2ddfa3114359349ecc59d0269aa1c3af2ecaa8819ae81f8068d19843a8188fc6987e5e98f1430f80d306f731c8ad8e176e1369359e7d2b9bf39b69339d6bf02b2151e33c8a86cabd19db06c7b79b76210fa39c5fbb6f8a84246df6ae3079fa3e9cdb619fb0213a0a64b517aa8cf02406163b8d21d7981aaca1b98e4bc8421c4846a2e2f4d391fa4371e4b8f50992604cf8f11196c0103e3d10ebc9b86435c62ea0c933212ff15c0f943a1a22bef74c17854335425f907752781ccc959154251f5e7f257cccb9743d8eae1a8ee10edca4444a64c766f225744359d1e8af344a68b927c9a8d57f97af60ff4d13beb968f07c450faca1dc371282d9e947b84693d074f7e794819a8b849317bb232401983b8b8c0c0df2363e5e0b62d1782a418aa822973bb9e4e7f48f8974e3d0c5953e9ce47806c21adcd9138d1c2ea0b84dad0b8805f04064e16d3d6761c593d8e62314b2857480a8dca8aed0fd05470d8ed585fa1d17ed609819d4384f5bdc7d95d677cda9af9467aa53e7bbc3a436f22ec83c59b1ddf52fdf0e54869343733d6851c123014a571fedc604f65a948f6f771ce3e3f1a6b0801bb848433d8c1c5aaf5d1013ea0360c67ff2325e65624571fc362e49354360dac8eabcb3ed0d94ae29cd9afcc0fb635d849e758c6fc2b20d44a4c6a9687d12025743caeb6ae1be99352a8ea89734dc6440e9ab946649465d2908cae8294a5a86ea12ff691bf86b6817ac2d5323ab915413192aa797c8512afc9a44a929c447179783fe803cd2b35018e897e62f01d40d9526852faf5eeec9dfbbcc92c53c7537cd82f875bda8e0240592f88f44cc08eba998b2e72e7d12a8ed04f35a6c12a1233864e987162cefbca276ce43773530c9d2d1dc89964ed3f48027845994008966f71d7fcabcc463f77ac05bbff7fe0b05d053e5d509b913222eb1ebf486a724c7d3c784c3deced3e926199d4cd9e03f5f6ef0e8df6d260f55f1b49e99287ab79d58bcfadd7e659e8ec0e7349303898407a5aa35feb785f52b53d133d4a0afc03f97336c27d9fa60aef392ee51c80bc24c23e886a1955ba8a6a8f7497654618566771ed6ea06e97c653743aa837912256a7846d49d8c6e750b6e0d80b6696061d32f9d11621afd6f3e966191274898a98759b88b410ef0b3f6aed16f23709277747ffbb9272cc3b66e531dc1864112402302476a8153fefbe1b3ed2ce2d678be4d9ce3d8b369719577e9e72df5a8194c4680a6060e942e71d29bec50002a82e775c479f94eb74c62341a138497d5fb3c2fe08947346ca60729b0a3e65abc28f60dc5dbc95d03e0359c797148a53e47de7297a7106184dc2cbaa65c4cab233544ada0673ccb5c793f503f52a4e64cdf5a25f2357e3472dc56b4a6675602a92506d700c625943a787954d3f1f169287845136598a5fa2ba8e5282d45391112495a32ffd8c5e2d3324a879055a277084a810c9505f5b311c41673bf47bcf3d0cd65d5d87d5bab900122863f384c92a5aaf96ab3a3b627f39a43886687b33f42e8a99b9de13913dd8f9d3a743682825d2901ad96ba01e6aef4f635861d7d34ac298ae10e414001a69d85df2e5355562415cd56b584632543b66d32d63cac31c633507e2c6b56f947bc78c5d88c490df0375190b20704ee85844c4e675e5d5b3fd6f0e871f3bb03c7d105fce2d0df6a3f9fce12d3cded2cd943468876ebd6167cc1ec3d0a8b256314ecae5236d5675673aa41c9ff771949be05e8a1b6d5d7fc1604b7e5181e9b76fa65aace48f7534ecb23ef66940d61ed8f5d4e9b61c1596cd56022d1cf7c06b232de3e32e297ed36be7edcdf8e5565197ee63744cd4a308072a424812f02259860a84a8bf8b556586825532618d1c7a0712652bb4244842d458d3358d85f87280d7f0027d47690b539cc81e9bd6e0df949c2bcf0c3715da22b03afe6900e8c2c78c40745e33c118065a487f3483721cb5e81c8b2415c13bfab9044ea9b85b4982274a4efa0d754e5284995b75b3ffd6eac97aa6b497f637bbb8b4b2865c63030040865ff30358c865278071f7a20843a9ea306bed35e30c826f8f7c255207b23796d2b79e04d449b9a28f7b43187ff1cf0abf3728e95c78c5656d4755cc17606eeba95168d1c65fe6ea4bec886c85af93f370d1bb0ddfd8b238c630521e5ee3191704d1a7d874445ea2c000c6204995dd8479d81fd0ab943e5443f23a2cef27605ebd4c9b416303d15040665a408e055d9dd1e6cf402f7d07060163a59df3e581984b2ed49a8780213a6b629471d0c016f6e5f16bf5f61ffbbb82f441380956d117b6add4f10ab33883ed8597430c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
