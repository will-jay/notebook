<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a6dd269ad4f4744b901c2fed4849417a7ebda57368677aed31e35ebaa35b73a1e24ac0e40473c40c69cc58a7adcab43fdffe296b47048f0686351ee1418cb29561dbdc32df970f8234ca81df600edabd28f527667d14ac6e0f236bfec5696c09d69330f4f1a8ba27308ddc72dde75b31e941876d70474607a31cffa110bb8063c2eed5a95e246540f57932415e8f6ef0fe8bc91746a77d3e2949fe9fbddae98c20ec39cca0e26b0737a13db021eaf391fac8450b516bbff5f7253f2d2067d5edea4a752b35aa791c41dff13417889e3353c8cb9241c3badbb5716b39021b2a6ea48299cf60caa35943246caa34f5e9380689a8d41bf629cbff048b8fccef6ef41c263ce4d35fbbc5cba1929e7aa2b8a9c092c80b056684055ba537fe406f983a7fa79f804fe6273cb813b4c61dddfe9d9d519c32cc7a5b7e9831d9e8fd216502580e94d8cb7b4547b30de1b9fcbdeed11582ecf8a0cf68ee407347cc3f80f57a70c9b3fedc45c376cdf5c33a1517c3ca46aa671822ab5c1ecf1b0c265e9fc0a19ad0ed57083a3191a0ce2fc9f138ad3e62cf6c7998cb40af5440c36bbf0b06f061226f52975dff8342f06206a9f96ebc5c585ebbf48317985e0d14728a5406465ef3eae06f41f3794cb7bee621e68f141613076cf4768c41e5c5273b653aa2e2dc9169aa1ac61241b31e483bca9f733bcda131b05cbd58b108066355027da02fb5c3ea9655df5acc62ba32496d759ff9d6f2d23f94403e325f2630097f9abe5c9cdb33ea1046ec2764dddbfa9285937021534616049d6ba2aae468f72a157db58ea3a8d569753f1ba958da755648cce1c8e940a900a2d094c542ad8ef110b9f56b9fa6bbb6d73f928ec25707b2de97adc263a1c148d914a27dd424d531a51b06d082c230f02fe951056378193deb8a282d55de80d3c2d9d8d06ac345af2590d4887a07e9f508432e8a8b26cddf119f3c05583f3ffc341cf5c3d8e2de859116c8005fef0e3f299174fdf789317b65a19dec375f815db11d56e0b43b58ffd95b94f80b49fb7f340a3a33ac05a79b499229dbcf5b9000582baa2adc5ce27ed448ccfdd94aa7f69a7f26d1a702f11133d58debd84035376e8c11d7a76c02e7f42b70686e64074413a8c99c2502e2103196855a29d9ff985f80372a41e0343cfca578b4553188e5ed3046151b33ce514da9a3b7c5432648e27d382c42009c32a0e6ff9c285dda3519c278a985b98efb475f5ece3a538e6cee92a9980a54457556093296ab61dc8716a5f47bb84d6fd9c360b68017106fbd72a3cef5beb2a5c3ea3c5ac465892f18c7f62e7f027b5da4ef82300a082e072f9c2130f3ae08190cc07a3936a7e1ac0bd10c3d1d3bdecd36a6dfef009c451b8a4792f6f7a2bffb59eb27ae3987ff4a14372ff532655893df6e2ce6d6e1ff04d427365ae04d6c8000710ffbbf2dc291b42f63e40284d779267f68f002a68ac8e8fd26315a5fba0098f0c0ed3368215b1b6530597e1435d4a92407e9c2a604e5e7ce43f4cccbcbb6065519a84fe51fdc7f74cb920b8a4712dff58df0a10ea6b6e0466c9b151dc9535a52dca1030ac9e1556ba7b980f56b218ed3d85799ab4c7ef5719791ec8b0447b9b16de82f9fe01cb5fbd27111dee7dbb2afa810df2d4f137fd1b100c5658081fb17ef395cc724b35beeea62c8d2d18e4029b1fdf29a53f9f306b82480db5a00250f0fd0b0425eb344d57d40aa684b7e34946ee669f69a300bc12d342067d00ce1ae46d3e0e5abeff00d73febd0e95f873a6ff36b77b9c0ea39d290b9391912d6a8c4cd38afbcd020e88a3f62834feabe866a3f2c2884cdbb3884e22ff8af92a43b5ad6d102b5e881911f8b9fdf42ac80c7c285ed4c8f48ac6dad25716735e9befd07f788907d675b6c577b900ff604546a3709ede8f5892e7723057c0b486ea12fc464504622e16de3c7d86b262502c62e4dd7fddab7f7f23a399d17fada6d118d82eb8475c44d46071bfc4b507cfe7692f8464184372d7ff8e98982111b28cfea6cadc1b6b5b802884f378b82e2c130ff9d26edd7ca82c4e6121471899b2f0dc1d2a041f53c2b594000c42071d3d0ebc97a7ef26ce8a071bcb8c21e2e6fe495195bc8e22db9cb9673f2a932f36def4d598a25aa98f8195c55189014c8e81223eb2a6682a0e3f324a91e613a34540d43dc9ad92bf2a48f8079dbafd07c9c0a76374a461919a9b454b3221a509d20621d7adf09f2079b82e48cbd88d7164b59ae1b2ab9e9c55e48c4398aff7609bd21c7704deb4dcb53e8042169b7533d48dbd6008aa4f22c43237df92aa146570494f3d97a94846597c2f56ad63ea722c9c155dcaa59755c4aa718c8942f5fa2785778f1fd8768af330b6c90314856632f416dd56ce92eca74fa703f2470c8823b546b00e4ee6025c18a02f70209ff2761db48cb6bdc430a717bdf48ce03e724b0eabee2b54d706ddc68cec92808bbf719a84cfc655a6393634f9ef88662be7b1629fec33d913a3aeae8e2069137d6670191ca8322b6ec4218a6527b6d55cf4679f3ef01a3f7e2df21cc84ce2fe500b5ce98e306f44050d4424bfc4032cf22a87dd9c3858b4da3c0111b216fe17c01d7ca3bf69bb0611887e3007a7c96e86cdf1830295fe1044b3ce5d85a4556d76c3e4ab3b2e80721454c926d330be1aad8fd0c22ecf86b8dc994f2795d723782470f9d8e21ce04ab92df9e3849c05d3b2d544141689bbed67def70ba020a187a63396b747d827fc276117f8a948b07325b69dee71f78483f657adb20bd1923130dddfa095bd43fc2090da4308b827e81b1891cc42df2ebfa9cf1292eb575bdaa19f0d0ea6e1a46095adbd2a77145aa7a9fe4e1a599710e932126e72a3ed0d6958a62a9235373e8b94fbf72948cb9f2efc9c023ba488048f8f63c36d4af378eb20c49f6e83dc2b6265bf3ca62254c65d19855369c73e830bd15d47bae2ba8960926e54d36ab384f6f9b4fa4f631dfc429e8a97fa28dfd506009deb4f9430a7610eba4b3d99d8ddaebbbba4cc40a3f6d28a3e444b5d3b795a4eec95bfef6b54b12dd3e3b9e47fd61361eed87e4a38b2dde92312a905a8fc4756db622eb922908a449138332f685c0a8c1013142f36de9559b8c81b8466df256eba5341777cdc6f54f23a78edf208bbe932b52b093b3b213420dbdae0c33e44c0be6880b1b00c744f1f169945340cb593689e835ce884c627d3683a426d37a697333c645c7b597ca611b15cffec13c7e2d814073a9de07a77dfa98041c5fcd8991fee0321529980bfdfc443eadc22642ce018737273af30d519b7263292762fb3f787ac8d907714bd6ac59f3ef728c9d2443934c3c7d93d43d36df45b40e4aecd6b7c853f3c9fb0c3f646ee76dc8a3103731d85c1d26dd07c1ec7ae64e7dc571edf252a6a0059ebf1adf6b5373128d71b6916c21d5b06105fef0668c7651b4622d2b13a31e0f2fe6681dbfa17af955adb6a64ea0fa4a29d56e734ff9e39b52a499e624d4f8e18623d65a3b244581dee19528efdae350d6461a02a3a11aae160a285fe71c57b1ba7e26d4d1204e9a1bb87fe23f7b3ec3ac1bb8e44311897c8dbd33e92849a933e8345a5d388b87a219657b0aa36e03c656a60493c4e4ebd26b228b0b6e86881b5a2ce8f49a007bcae529773495a702757a1323e06d430a594e0598f2c43a1b00742f1680b9e769b067f5be848c8f398fee5ca36343c99e2c09cbe8a1b99a49dfe192aa03d4001fbc3afc5e9fcf06e0d200d62a47e1f6b1faa691567a2ac66a4e12334293b42df6355915d39d3ec63c077d349825c00ba569b2c345be72ca019b5aafe9e0a5e08cf4f80e1557d286ce046635a0d66a14bc843d8ccb984f7e904d8f09b939f7938665c703d832eba7b9a7885f1c5383690d845f9f689694011c6dca627e60060bbf4d2c5d42beef5a46e3d05820ed30a531728e596781b294442656f40298d1a5a47d37128f75e7ec118f6cbea4d09b43d2b947ba0bb96b6affd2e7f57456d554352526fd370944afe159ef1cbedaa163e983988551e948f3c70c8d9ef8426272405ce1d1dcfa2b2971aae6019be66f07287fcd4201974813ce1cbfc85d0dec449bfd8ab2e3aca53a39a31a0197c1f2e7876f24a36687fed2c4dae41e1593eeead91dca3d0ffea62325a91ed0f9a6e8e15fa086576112720d77ee3c5b1d91ddf71690ff2426675dd6bd8e3c3ab8209406fee9c21c7b6176092ecec344e8921ecc7fbd977f2a67714612156f77dc68d475b85fc379083469e0e0cd7eba3ec067c6632340f66a4f95bf8f4d6a1ba9b6a3df08db3f35c3dc4fb6537e67e7c825710b8240e25efe6f2b76667e12fa7c2b29a6019526c4b8bbcfcdbad029e6d8013fdd8c3a4629f459f76c04c00dadd253a7ef8c35db8218f2f0f7e47c09833f7d1c306bc217d5f97120a86121bc1074f69631162fd3adf1d812727a236da5ce99f1f1b60b82b2ae79368c544564dd594e291559bd348385dee24161f23d0946315ecce4e2b083a9769ffec47ed5b0cc7a3cb409f996cf9bdf7bc166ff953a9c66ba3a7c3afa7457d23c3f613d42d1d798f53bd806d3fb2fb202a04c0c06d318fdadc63b553b3ad96c32bf46ed130dbea86e6f7976c6505a510d23e7903dfa2ba3d568ca10a1384e9de0df13411d7deea4f3ba1d5e432c475c16f7a1bb4863a5dd00b9055ea22acc71b0f2a89365463195efead9a79254acae324acfab9b8e7c7e2506bf87e070b1614557c14e507cbd3829ef6b500d5c382d5343d3c44544e776a3c1218a8d952afc2f148a3ab7e680a01956df849659f8a2e8ec65bd6f5691ebac2b6ecdd15fedeb2aab0f5e96c3b4e978c0d908f397712e1446e24c6a322bc68e7a916e5365d07ef8ea5791d06ed433f5db5373c1756d94c5938632b57b077a87ae602407f8c2eda4dc90d190eab57950d522275fc06db9066dc5d04c4b76ecc871e80c47963d8ea2f68187743e9861d3d6f6d9cb6c8f45e25ea3bd31cd13017b97a2187bcd0eb9adfa4d78d8fed6c72987ba5d841ca7852d5aff35ee1f0ae2559d962c31e1a2d8820d56f719f6de2b24f10b5fc57202de98f82efd08f122b1f2f9961014318bada7e089fe33758f81f1128c3025b1615b239553687447da4546a4f4a1bfb5807bb74ac9352ed824a8e3f747aeae830f44c1d1ca5797cf3d1e464fee03fbe207810952478053041af470edc264ced8ca4088ceb1ec0390611bb026edebc8cab65f9e690859692f4e10661ac557552e98ef82251316babf785ef2715e931a57349939e6515d5bf022e150c47da865f8d14e888b7a5459b3b933b89db4e011ecae3e18a8aff98c47292d1dd74e07b0a6b7ce5520f5492a580e86511b7f32942197aaf46bb72e078ccce1d97877727fdc213ef34de0814534dd52b610ba5ca9c148dd5530a6fc5d564a86cf1b24c14d1a48c7c965ffca5a6c4bee14b9030fd73bfc1ef40b2d40404ae8c2ffeaac83a5a528af4a485439509d85c1415076c1c2e6994e641035e6a3e888cc9ae83f0415255469bacb93cf54b6c34dd0336eaa2ffa4b3f7f4fa0c9d6f3ee6dc5fc51359d865ad064a8194dba6a89891dc431803ae818709bfc5c93c81daab2d183c8bb4e2ed6def4d8a702f68da705fd3c5dd7df83409ef15a26c639e08a1e96dd48123af9415b2dee9cc03b58fdf74488cafb38291304e58e4fbe3f590c84f894957acdb4a913f7e079fdfc2c807a84fbb8822a3b8ec435b87fe8cd0ca58f8f5d47533c7e0600a28380a4b95725cfa97eb74e277591cc9b9291fd21cd18397b48732707d223a92c3d09e261c7d92ef4b3cef382ea92225eb0cc785eca0ec931d8e6a734a2ceb352a55eab5361ab670a8784e66d4ad1980278dc79abbbc2a7c4ceef0ee36c8377e669ec08b685eb8fdfd6c75616dec25917ac38ebe226e4e397f24955b4056aeabe0ddf43d7145f7a6c4c497c126ac20d539e92c517f2fcb5ad95c66236fd4c26eb0e78383948622f01752047af57f601868b70a681313d83a511880a5408dd98a05981e2f98ce687a2a1fc906465ebfea731b473bd60ab248be49e92d10b4d5e76ca0a1ff06359dcc0d72f45f7945a4b60d686ca4d7589b99c2013c0b9a984a34b54f5ddbf9a59912beab07c163382f0736d7fadcdf5b2c2cd3eb7fbb18fde4f561993a651564089777352328f46d63259a0ca555d26e6dafab8881993a51bca1bb03c2a219e5ef4aa36f0facf1abba6b584db7305a92a233762d2c8ccd8adc68698d4e14d4a89f0aac9c3d5704579a43bef7593f813ec1a1020c8976d203e454834d915f812bb4fa06226760e3ac1dedca533b0a162989052776034c0ade1fc3623636c7e3d5571a9674aecfba3cc9117c55b0b4e07d1318bc19d711b5de0370632a1421d167c27c2c3f01f7b920736c2ef6e8dd0d230bb39d1eddec97e2411ca4afd6ce7a1da2d3d3a74fd2a66cdc1ef0bd8d0848ea9692e9cf9ce45df57a17c9f130f9dddb4ccd966cbf7dd86513da65fbdd04e974bdf3603ea372d0b51cd80114737c752d4873c336a9e8545758f57f661c69eaaf906977d5b8064dfa86e7f5b103606a893a60df8ec49677c8bb91deee5ef9bf294aa705ef286e07bb97f09b4c00a212a83bdeeef40e0df6b1c2540ab5faac16f0a254c2edcfb066fb80ca264e57dcf4c29a6beb28f12aa90ffd5b6aba309e74e087f6300b6357f741186703a1b3f676cf3216648b6ce1c80d134850a3cbb472b7cb85e8484312f41843f3e342bb78a15276a09b4de058bb381834b0f245666cda6824716176381d61d68435ff23ffefc4ff80b4f83bc2e5095ff1a00bbfb5928e841cb41828083dac8aea3b9e1ff1f974be33ae075c958962794989604303b19a25aff72c62e3e5ba3affd3565e3147a33995ac195ac929a199c2301dd7d047ead4e5cfc9596fd656e75c7b58916aab2d7d3bb2d0f03f6c6822f77df08c94f0b4d665768e6453c8574adb7af3061f19e289de7039d755840b0ea6676b346db3d0e0d21498a687abbc719444ad881d43116782dc8636e19b9a5c5280e50b78d5b41f3708c3ada4789a6007ec31ff47eef84fb3803ecec221cd39ae91068e6b02eaf9f7e220882f1e4f2eda59c0e60580b2b25e5552f5de59b6ff8b2449418975b5f78a6da8cfaee1968c30e613a0f244b75317f74e740cb886a2bac0d345dde5dbee01d34fef858ce21ae968bd50966ae9300d093ab781c36d019d1654888c0c5c35d366d09619654936118af30f55f6bc2c66fb91083f08ca54358357ec8e1d16e88c235acc09a0dc831747bf0521040be86ce7acabb18c1af0693aacc89d3e012f8766b73d158e4b7938dec5ceefd9092b0ae31e245dc0533b27a26900630aa3c681fd914e92d15885b09eb2999acb7da36dcff723ed63fe17dc828da1509eac8ef44691fd46c18d7170260a5bbe58a794810abd8b42f25e9076c4a23e803e904361db2fec0adcf9817c9104771580b6195acd789d98a63da7137a55cf6a3c2f8645eb2c1031be49bb163f30653e5472efe5315391b7b474122a1d09b3446c1f30286e411314ee1fc3ac9258fc51ce3328fe4c09fd9983f0bf95c740aae6854855ceaed9a197262729b475a976ce271f30fd53741b6f42eecbff75bb079893d6f08675488a8894c0d451b84efaf154204d4be50939fffec4d6d80626f6c75b96d27e2b0bf305f9f3bef07154066e8eddf69b39d295be6edd0827f416193c4d26848f825be4af5151c4de3545c382bdd7ebad342e88c0716168438973368d922b6afe69295e21e7ec0bfd95d1b78e3a043ab4fa379c604999a7350a63a8fd53d240aca7e333c845040b5f7b0d58546194cf49ef54c0d87c738c1c92afe2c0ac18349670881b7a1ac138686ca2c0b734a4e98473106f758a6ac93efe19d6c43e82d294de9f3cf01a339ed4ece13e6ad1b478934aefb9515bbaadf905d5669ba8a0da98f90b6f747d34db9ba803f4f3ef37ed0221a30547b545a1179d05e597a57c8e02d6afd5fe254f114ed4fe150d1dd35deedb0643406e8e19e918153e4dcf97d0c4ca0d2220f0350d8ca09426762419dbc22bc8ac5f0404668232047854fcd6f30e8d1f71c0a86e27c8312162aef4541fbc5eef6cd2e6145c8711d48cbdf1b13ef8f1128bf27bc194a4401f89a95f8eaa945032ad130e57c073a1db71ab4467fce93152b1afe3a0db775baeeaf03041868a520231df62e9ab2b41ee16a7376b8d4ffbe5e8beb044d766e8f7ee4bb4c3c5a982d24efb8a7f8d94e3e3682ba990ba36c1d37f10d643b0b4a53b05c13e35186f9970a339bf975b6e23aff000bd43edf55fe208ad542e7771151f1529e08e76c487976801fe40fc74cc89e4b26ba1f64c10c75a5b7276553042d84cec7c1bf599696b719d8472bd34b6441703da631e0568016446a6fb023dddb22fc1212124df08d3ac52901871b07c1b789cdb83541a04edd57436478a66bc58aa79293d8f5b1b1855b5da6fcde3bf87b1e58a20855fc0e8e7ab5f81959feacccba87c2da251ac630fbb1f654efe8a5d942ea9ed0e96a47cab59d09c5fe4be9e26f5538968d1bcf8e4ea5411893ce84e739128f61204c90cd73ae7ff9f9823c0bfa5139d45984e968e36093","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
