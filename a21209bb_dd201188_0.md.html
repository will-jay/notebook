<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22e3cefa7816355482c6c712b6ef805256080ea86d86403726c0a643292a14db2a24a0714fe79309c53380734d121412f41f44bd99dcd3607becf932882e5c1ed6274913f5698b44dcd65022657eb1b1bb43a99dba8d11e041e1d0bc3c9003e0167f1c15c427ad9b40c1c477cb8b51c58e8b2ec205c81b1720c3b9fe47a450f4f4376b532d5786dbb3d88fbf9027c102625af32a0c09b8cd7d5bc362e906e3d7da9ccd3ce564119851cd006c3efedebdf2ed45102b8acf33d83595bd9545d2919c7864654ebfab18ce01063217e15214afbe59556c0d73f5d234a61b81e8b3bc2897c13fe431fd9a1c7ea3f905983674df86ddf714e507a3916cfb2091ce0cad4b456a5503706f44eb489ccb415a519bb02d55e8ae2801bf0fb6f5d78525ececd55fdc48fb7bdccc1546c3dd1e99bae112d5ae8e734e525c0b840a96c467827b9562d9e979ee165589ac9aec443d09071d5d8d39ad3e335c2edc6451cb38926cc540de9bfe04a20b7a927c7ea06d918a527f682cd25d2c2c2360b4634e2d8848f17de66a4dcee37036115031478a4db81583317ded1137b71938056ec9da9eb9278e12ce3d6b87eab7aa4a14e6b5ef33dbec9d4398dd11360955859c846e3f9f598107e30520f32a3486905e242bdf64ad8d45103b6273a6fd4928a22a7479b20e4b3612a6df238d699b99fab5109c909f95ce1ef4ea095986a8b472b5fc44aeeaf5409a0576ae2d1debcf5728c1c3ebef61c26304b7761946fe0082618ca92127d95801ffc7919bb768c838602e116995608acef65a614bab13546381a04246d27315379df6f6ce639b553f1c7d48c61ab8fd5489bbb077cfea5d4cd0b16ba93e4298641d71f0bed6ef79bce7ce8eded3b9a0766573ff584e6867044956da7bb6334a047b68af789cd69042611ae1c98ec8af9bb6e2cfee9803718acf80f0d05a09cfd01701d7e43a8091779567adf1bf831a6c3e9445663ab18a42e746d0a3452d6477783b0b2d65214ea9c782388bb32be26d64c9e325ea61390ba947632c99bbf93d2d10ea854fec44d15888e77344023b986a0788d52291df64448de44d40406b3580c65391bd9416500b9ce6d4f093a85bb630884c7ef8ade1107522112f42242a11b9e93ac31b78b8618cdbe3e8df2fb72aec243fbcfc9f3e5684b99880379e0b227da0b9d07b153d01b10ab7cd31c34b4e1b5ac874b97a395c3b23e4a29f13c039113f7e20faf81694679942bb72583206513e00f64647105daeaed41ab5588c6b984a6a60ceeb3d3ec2762a57e28e1a7081bed5069ea248d6b0dbeae643cbbe5c5da4ca1c55791744b5558a5b201c6db75055966fef93ce136014ebd225f01d3da6822c6ea3a5b60b3cbc80212aa6335f37fd618fb88ed7df5b4dd31c6719061d7f2d625c69ef63a5b37d91359f5f606967651bded9fb6523997ef6bba94b69dab078eefe89cfd5f8d2b944f8ee46c31ea668175d2078405d1a55180043ab14fde7ceb54c3e8f9cd2612e27806912e733e25d0351b4d8228f0117e72696e4fcaaeafb3d9f117514504cd059fc1609af555235eb438015f8a493d1fd68fc556642f0aab4d20f850dce8d123a68bf8adfede010f9641c1eda8ed274b73909999c820f28bc55992d7850e619cb5495caae213d935ffd0a5ecec0fc387102df7a6e4cd6438bdf1a0760b44a401ee21aa4f4126993631f6cf7c5e7cad3642f03766f3972952fb028fb23197357c3553d2ffaaaa936f671eaf057b994ca99e167a30a363837da9e655f40868537c3c1124884ccbd2ce1e5bd1e1728058d594b6641ad6dc3a75afc7d490f03451c1fd8bd3239291288f13f1c3fc69c46d0828e56a34a043fa1a180cefe5a85b6be0f91988afd42bf8395430571d136468f19caa1a1bd4e74d96efdf1497776f4935c33fd8f14d2ce8ff6a775cbfd8a76d2bf5b892dcc1718c7070ed6debffb0d72caca495cd8fd5f2db4aa929487515434895638cf78c14d4ff7991d8fd59f3934654e8c2f8ac1b907c9044b44e4e103e55f590c44b6f163edba91cf02a92edc5a884da11d9b9d15e96413f2ab11219c38363503492137fc6d8a41a1a9a403c8a0a9ca4f9e6d2717d9ced10f526f5503329c0c189e7a4a8c791af1c668f89c91ae1dc1d5a5d96eff79810274e9aba75037e964068bbd9bc9a58dd9c360a176571cedc75b3ab2655180fd20506692482620720df6e17bce833bd0e3e41847c4e1894e905c0150f522de67e74a419a183d79f9fab66cb63393d38e948bf88c0125afd66f49dff47122dce05eaea6220c647e50bba371af54fbd099eb53c6ed9c7f92c4e4b269330a3447bc8555179107f58b076bee11a019d402d81145db2ed9c57e5ab1c88f867fd3fd3ebcd458a5710a8dc33365586b4e9c27e0b965344804e8e71e5d22dc8f8771193bc51dfe1ae4774c6f808b0a87a461105c1bb7939f881e8df3c10fcd009940220c4595282a3a13ab850425ee8a872f65123c94e8904605f00d173579aa57f00458310d75afc15f5f055c06ba192994c1541df8aacb2fa665f2c2ae1e7799759efb06f04d096e8bdc4fbdda653ab25bbfc764a7c92039c86210a41b2f3e2d23c062833285d81f42587dd387545893bce4ee5073e5148c5fb718a9701c4635921bab236d8b6c55d97b5651756373afba435660b2762342488d9080c4ebb41b09eee8fb5454cefc62eea815779022db19b5f5847a0c7c99ea977c5a14e084a4322033a2a9f591a74ef5b524c4287850f2d17afc4cd470d8a0d7b97c978929a9db2331d5ce4cb92a4a8578b54c371a01b19f2c8c005d609ac6ab4f4477a87460d6b6a4ec5d5f70b7f0cbff2b1623c5377ad1319951917d7ddc523d4acf9dd74e980aa9bd5fc6016bfb55241d49fdecd6bc08fcab7da9bf47d75b2fe27220c118d824a561177c8b5a0c93a421806765dcdc739c7a4ffe167656b363cb29cb679441d5c316566b0b01fb084fa7d490d658c64cca3bd6adb43a958be0a05d3f7740bcfc0c05f2df00ad87a080c6ca7639d3f9206d95d797005c9a4a2525cf0f5df3f811408a7386aa0cfcb05d4d2b982a312b7a8e35de3e070beb0d443dcdbb1614ac533461f1def2e4eef59b3c4bba2251e05da300740b4399e34c4b0cd34d3c02edb825b1df5dfb903ed87d18ef97fe3e3d68279ddb7bd8b6f732d4ed4edb685a584179408e420b0b1fecea600e59a7be218b5a33cedbdf0e2d98007d9f3479c9b7b1a5e5eb1c02f79e654ff2e043dfea2af59cfb0326db47d208ca0e107752024c34b6c66bf9930c4fba29e9950a64bf9c208852f2dc38f60fcae09e81dee9236ebd52b25a8cb6841f8709083c701fb4bd9494d59df7dba4a6283f88ad0db20769bf466070f1e3c1eebaff78383d9ee6949437f963169e0d9b130bb11d5b86a2920dace73b8b29d6071f9e5d2e63f7fb4f4d45dcf1196b21841eaf04ed7f6263f4ff919b0b1e01641d6ecbad407580f6077bb3ed8a990b66de4efe6fc38b510622200672625282fd00f5df42bde70d4ec16c5adc938c8e0447dc41787f064b9c27538c1576f37abc2987405f5c71cc060ff85e6395d4fe0354abe25c3e0b413e0a15364eb6817a359eadae7fdc70318ce8c7ef86800576530c6c9089bee5c1600e981d4e6b281f811fdad14c3c79ec29529857d8a1f680e9700c798d40ec9a110713f437965627b2cb6d5296e5ff1e2e6bcce416c778d1bd16d02afba4c2033f23e6bcab2cf120657a7efe0b867a2c405b23969341e445e6a860290353e2c43033eb56a88f4526828e8bc1f2a080d930a680c2b7df99129b138348522134b5dfc552f29cbc3b0b2968157c32bc2b73730c47474b97490a0e243ae19d59cc0071ccf9550dd8239c31b2d6544d13b1814e1292aa94ccd1a2ed0cd43e5598a71facf5a85b7b594cfcf0c37fc22cf54daa296f98d16c2f5e8858e83ec0a66945081649498f11beff607294fc05a62962009c994af7cea607b5613ee847e8c6b973cb4ee30ffc93bb380d4eb6faf3baf338861a3127a9ec208811c1b0c46e611c6562061420e18e82b05b732d5186335c7f6673db18c7363e14c3a92e6e0fa5bf3a6d9dd9338edfb7731bf92a31e3e98ccac959a78747d473247d102d0c32d46e9d0ee82e53e2ecde7d5978ee09172836cd4c7e07fb5f266e6759c9a60983d5055f492f66ff7ef6692bb157b7668b5f09f5b7d815931bd495c76b27723122248e1b8dbafa0ce59c1a9ae5ce290b4f534c4ff4e5853867681b032ad01057f9451c4095e8c38d83d8f5bb42d0af7fddbea9c4c8f39fecd41d6a2fce8ba8f0af7848ee1a4591b6e1de270b3082c54f94a5807969478c6970afe810603fa3604032c0f834807b4e49a345da00974e5e899440b038af24efc6ad66722b69399400f09e2429875685ff5291a467228b8ac888772b116317a80bd4278435ea2fefb15a1f2877ae1d43024195b2efca49a494a56a975b7d28f769ec3beafe39686072ac3368d75cd4d3d2fef4345c6877c7436e4cae636afab991b8ef76c803a00d410c0510b3c38ebe9af9c7626421665d907cdd4e61022906362c7c3ca5c22d28304b1b15fa182142ee39209115717ebb52a5fee9ee63fc2b987a32f3f7e4b68e5bf06259284bdf40895952ba188c0b46db8672ff036afe59587d37dd0d18011eaebc9c48b7ea714c70091b6495801260382f615dcbeae8eb0260fb32f870c8b6de3369ca759108fe75ad48f9a6fc50138839778faf20c10e95ee3b09437cc9dcbfe124a534fcff5e3538d46150cd3b156003a3fe7465c1e6c53aba80894a12f3965cdf4c21460d1678c300555524778baa08160066342415ec57c3cc41a702011775b604556089b44bf3e865c91de2be63d114e67d99a33e04ddcd50ab46e96bf97985591bcc0f1fe55155b23404fa4febd4a9f06daf740aa19a3b0c502aef728bddefceef786924be3f524946800c7406cb1b7507ffae59e789c6bb7420ac935196f83629404f651c88bf3300e50dfc310dd113da650080008c8fb2f21ec3381e94417a014e41f8d33f06730e55d20bb8548909f46e5b8370657f2fa051c8bc7ee65a0549fadc77eb5973f03a23dbe6b41aad0e3d76e5e23bdd88f18d6da47511608f8cbd0cccdad2bf723f0d9e4e12f7f294ad5a199cd024247e7ad3b70f2369f61532b08e55b1e4dcb1ebb69d5fec616afa4790e1e2307ec12b04bdedb2afdf751e4bd4c286ea2878e39618af11c536863e283482e5ded3c8becaf9eec41b1d8afbbdb13f4e927dce7c8aaa83047ccc35566f7516d2f0f1823441555e17c9c503d5f53205b5956bb9d21e8d92d89fe5f904224444a01b649e4521ffb77cc22fa3204d6be93c05579142f2aaa1042892bf28a0f77d4f969c8595caa18c5cf977b869bacef93bb07b48321f4a82916bc7d438f19d599e937f85c074dd7b27e55bfbaf792adf478d91eeebd6715bc71599688cf698ba89e84267df54a69317dfa80f13d89cb547f3e4e9f07ca350d8d4706838a14bbc4c1725f5541b073b0a153d1e65dcf1b544272092c432f4a24f1590efacbd2ef85f55d03d14eddb2eb6d1de6130c7dd3598f2f534ce21ea283190a70f1f3e58edcbd26568d8a3a3fbc693e75850e807d787e4f4d4ba718e1d63be38139a959ea8d00530c779dca22e183b6e20a67bf108dcf9ad2b288e1cd7daad8f49943bc0b650f0eab2e528af3ff6c4d3c14ef5719dfc7730cf6619ea686d074f594e71c36082f8d8db70855ac68568259215aff9f948e83bdfd278fde715dcc74b53b2d51ff40676852257d3784aed7b4fc75ae7b687a4bf260897cfd3964d98eafb730343ad19dc9de00b422a4c2b4fa9694a9252b439dbd053359295a75e4e44842521e6bdbea69e631055e6da2bcd61a6db57eaf687039e99770a046eca955e206ff9ca386cdb2d3e653b6b2e2bb90f9f45a2e2e1f02bbbeb8bd5810ae78ef6a6f46be9817aa4350f7ca87d5ddde1987f944e1aa545a8cba99d8dc2550ad3f419b630cdb962c120720d5b020b27a2d904a582dfbb2d04dba562ca773bf739c08dc3fa73b8f98a38233688380d2ab15b68b7588544f9404daf1e15b92c67492102395e500380bc1d093ee09c131fc32add4b0f8902f415778639232a7e007582bbbbaf593fb67db91130476221197cdb7aa10c05bd584d4455d92c3ad221bb733493659584a1e4f0648e002b3bdccfac5d8bb920065c870e5f42b4a74b53ade0a9585ca67889529b33c83f16b71e1d43632eb7cdb162756efdd2b75703ab03f08927ad8f3c9dd83d073ff9e2397bfb4772096628e88744c0897fd8ebf1312e63b7b7e70836de02168bd0fdd59a0224b2c7cbde932a13817d5c99660a943957e877dfe2f7a897868fb268cf3c6d2cccd8011bc9fe96c072ba0cfa14f2e8973e8f5157f809070906e1396b60c44e1eaa6185c044490faa6e55c8ad2f3cba1d431b966b8e054fdd383e5b0225d4673a843969256702d54124585f8d8957b8beeeb4785fa856c7402da8318efcda2cda39bd3ad22457c4cdc86bb556d764e008d7c819eced9bf700ef9b9d9430caf895ce984ff0dd8f74a35298ad423e7070bb5ae3d4ae54d0325b6230a9011b510a272125ac60a3fe6fcf20b13ea6b83d8df677b0b79bdaf8218e597a2cc5ea96253178ae78818f7de124c78dfdc1eeecdab0a24955e63298c204ab5c3d80898b27c8f02d85131c30bab18095f8c4984a9297d95dd99d3e14b3d4d49e11be17467f450194be49555c152926a0465df051b5571fb25fdcaa1d824debc29bd5aa3c62d5bf41eb5d331d9ff14ab946c3d2967b36b50473f337e27727673d7dfe709fc1890e5632c9afae87e0ecda1d6af7cbd92193d76e8b2730dc9ec06e2ecaeb698c0017e3690f0dce3c9be3b6b643782c97dfe74f871d984ec5e04d3fbc7e92bfdcb5f7a796dfc4acc8e812487061352116a72350711acc0c38a6b175dbe45737360f17dce37fd4c01ab4bb3e34da6e0adf21442a6f35b259f3db300b07c03821ca24d7d2e8d1fe3ab3fff5c7123524bcc861351be43868ae4f97ee3a7915d487592fd1d46de3957f681587bb05ed287d2c67aceb0888648cdbe6eeed90dede1df09d8c09dbb3e5442d2b2597a03d13ecc8102f1b8863c1bea68c059de07b46b10cd1fc57be66c9ec8e0e990868caecd91fe54ccfe4894e5452c82b52e5d43bd70575f865738ab499cbcdc52d00cb90028a1549b5091ac2d4a254e45f75cbdf776dd8c5343dbced67f0c705e2fd141cffa8c0354ac9ddcc623f1ba1ad4ce6a7d89886d26dcf3ac588b7dfeb9f35b369dae6bbb07a9d5fb2e68118f8a75113d7e383ce853cb384ba8987ecfc2f2b8f93ccb7c3b5f829a903e0dc9e8e538b201185a1f78d091cc9dde8d89019a8c4ca7ad999217a049039eb8fff55ac31b887242136d3c202334a2edf77d72a4b42e0dfdfe8aab80caf6aa4c29ef58ee8482e4e344fdfde99f57d2f026ffb9fbddb492725e1af936cbf67929773a2e10677b27b719c71ca34b12942ad9aadb2ce7fa4ff4116c92070f7285c3609691c5454732183aba0d19f1183ac2bb96b99430ebb251f682c1e8f289438615174bdc04d89fa2d416fcb216c1033d9520ff4619964842eebc5638bd3af67f17f3470bbab0783a033a439dc74dfd865dabe7cb81405d4be7cb83ec7d3fa5edbfb10d53a5d7e951867725d9591782357742db79ac7e1bd73b0c9d2a61153d54dbc4d872cc5f4331531272adc4155c1e01960040e385ae476a8480119298efcaebc15a21b6521e4d176ad1d2acc7bff410a8f88e8f53fa815e24c039e9f0b4355932c466a48f34ee34097ec47ef07b6f2ea7df6967152d73f70e3aa40d54cab1c3ab55476e4493511b8147ff356c404d81e20e866b85a6ce12065f6e1ff33259ee46d0549d0a4297476ad478a57ae96151e6f40fb59367f147d64ff52f719d29d9958fb1be3bcff6029d42d00481dd1648acb4fca9033a0af48db3cd8592243d87d605029a7b2b10e8b141cfeabda848a2134a59da9b070cca57fbedffe7ecb7eee051421392a7bd4cbf022d3fc0d3eed0acaa6ae79540911926df6a8ac0dbe496662c95b650d0c0b0a2714e852a74f37f0582c93abd0570db4f2223e58a5ebaab0823f764d699983e2e114cc0cdce6995de292320045382a2905244271d8d44abf80d17d0340593dd2ae340b40b42b8d1d05e9e6464aa7f0ead8402e1387f43c2c7da40b535370b9b08a90fcaa88b673ba5ee485d0c0a7311784a54c0e7044f5de10c5acb8bea38560019c2664eb0abd3f44b639523d23afeff658338c26eb97bbadd06e89170cb9b1c108bd33979c84df0366cdbc71b77c060b86a282823d9c8b322fec2504c4fc5a910abd011edee5af3382d5694172ccff37872dc6ff567ea0797d11719d1072d4290b456080f1962f514da63228f4363fe5cb61d2a3a2bf26b165ccf5d96cbafc6ed551baf3dd9f3c5571c410a4d26c32d07bba7b07c85443635a98e90ac36297af52158d5074cad1b4e31fbc8e39f9bf2a7ceb229085f27737eef581ce66696eb61e6e303fb631c57ae8adf62cab5ad69345ab8f63746ff47ccb874858870fb250251d3c9f45412f97334c2baf4b9536f82878b1b26ad7833fe1b63c426baabf49376daa8bda21db1934420e712068c6f0334a6c310e3a86d238743db6bf76dc6646c4288ab26a3bbbe12f9980a61920541d59f5032b1888f4abbde1b5c3bc956714d0c22b693af54691e2e2369ba3c3d7e0d4a0b64bc89d3c5a9b482d286a3cc59b1c206b0758b4572174cb2da216ce7a822b1fdd082d404bd3cc2e9c6439f5646009193a897fdddd2117f0a7a4388828807bc0d26a081b3a2bc2b7cfe67b531a39f369f21edb9015260fd30d93bb4f4047d52118a370f3d0ff07845494040bad3cbc02a2ffe09c37fdd457237c44fb50d9c5201dc270d7743d9dce278fd45f850eb01282de61bf545f0febb6324207cdb9386ff329e1671915d33bc9cab7a10bed5ed4dd83bf008b2fbaf303172b4a1288bdaac6514a769c2d1a2f49dbf5d3f75b7b14a083928a70ff2f967c7d1b0f4e3ebfc745d3999301e36d5129c23744608ea6c72d84075f202b64e18da5329c94a43c41c371c1792377935fdfdddb3da047dad38a5d256464f94ce451068d17ea4f3981f4d41730ee1003c03a9fcb2a9e235b9201b82a1c963e323f381e271ae3a14888fa90038180b86603e4845bf98dbc85c1c5093977f45385d2922cd1f52c564c3b7124c731f8deed3d834e6236b0ed19934d823050925ebe4b40e0b4a7fc1d81c1a4de83bee065782e3c5a1e2eaafecbac9420ce6a09f047aa2c882882a6e7a34b7f6bbc5f13db2f2d84451f9759410268dd49f1ff793c2e71679c335e57e7a2e9bbbb8d7b06fa4bd616e19b8c525db85ec895024e57e701f75b007ff9f8ce56ca29ee350858e921f9b161266a5e9e1356727a89517f9c71aa2325558fe24fe89df8486b9e81707ac35216a347c1e334238b28c86f7e4137228f539f0edb14d145a00deb1895f2959877a5dcfd78a1afa686a9afe74d9d72ad20ccc55030befc4fbe0b35bc7c3043d21a60f8139471d9618761014850ca89f48b6e126230a7d6f1c58573dfc4a7a511f602bcca63814b43d5e393b2a932e6a7c32ef7f21fc80dc49523279c5a92039309f8bd3d9f34edddf0a61e808062545b17bdce585227aaa0f2c904b5b8fafd29cda161f182959b42e9a4c0ab1108ea92d087b2445c65dafdf0088310088b16e40e298b691dabaf5605240f4a1f8d3340b2d351f8676f98b6982dd1a8465e7fbea25fedd80051de27785c1456b70ca6e4bd81fcd7119b467ed67788687b096365d79ed52fe5e5c8b172c68805464919eb36b3d6ca19eefe59cafd6fbdc59bef3af13f63bb85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
