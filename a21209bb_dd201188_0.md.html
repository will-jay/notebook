<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47bc39e97897f760c542a6b821cbc62b0048a4c31e7ec1bc9a23520e50e8e6a013739696e2bcdd6eca451aa6ee66bafa6f8415bc2c859237059be60c9ce8e415b119f1fcf10548ac3ad26674ffdcf05890655c53e4ae8981434c89cd560f877f702548f2b4ffcf9266bc9acd045f40e96c6954789bb3efdaec7bb8594793898bb7a23356688e6af4ed7f9c5621c760e8ddf4a943be4ea59ec12537065a74081f79cbad40abefa13308c92fe14ab3b077d3622c51aa37120cd7e8a1be9e2ced3ac6c8e05170c5e2dc35ef5bace5bbe367dd083f206a37edc02430d6f4c319bea3bc4c214c09d97d3d3553f339a46389e07966339e10a9d35331bc3a19f2c1d80bdae49d46fbfa4ab5fbf3b5668c508cee33b94f651133885b367f1d67eef6e7ecf7db81ee5527dead0fa91fd96d69ff521b51fa57c29372531e65f0c704e54fb813300bd49486892f2fa9bba002833f0308e080178f85fcf72409380ce5b996fdd4b2a4f9ee0f8645dee2530245ed73da7e0afb005e2cebf1ffc20b90e2542d7d588abeec3fbd8abffcba4c4f6a1bad83b66b1ff6cdc2d4a2950c7a39c5a6c5b15a5cb79badc4519e9d5ec2b2d5b53310a0c1cb23e0c4835a4a6c4347f0cbc3d47a2e3eb56be013af30b2c7988cd2bb7afeab471a264c9aecbc378cb6c637a894a5eb50b1a8d35d4bdd19022375a992a665320ebc723278918c765e99b01be30f3f25d2afdb9f050d9ac363f6a5b1a6ddfad5e444b63434e89c48bdcaef915791d06ca1f633ffe08a19fc318aeed7eb66ee31d6fcc8203119e39c08d14e3dda05be8337db44bd8a7c402b13f52a37407c391089ba6f15229fb2c850292fcc11605c264de99e947ba7c7a9817a1b9430b38ee59432d3576ee25d08b7691ba766948ea08235708a2407dfd7a6c398bf881d5c0d363cb76d5bcecded3008175ec044da56ddeb2bfd3e5adc3c0efd71754f0de44e3f28dcbe023befa919c7c3d749d3c8f1f044f1bd02f0045a6fb9e179b2bdcdad0260e2653c48af75202f124e17052bd80f0e6e93fbcc68dad822f5811382d7c4a18523c9977e5a05ec1223f717ed99d07a648167ad7285919a64618022f815c99390c09e776a552350495cae6b2bdb4021a694febc7737f3e098987929afecce3462ff0f8bf47d12ce25653077338c22062cb6bba30aa8a6df85964966348ca020710bf2fb3c08ec82116e71221f39a2752df54db46310b46679562f742a085420e9f5812d2e6ba64a424bf24053701a7ab232037e5b9aa84b9b69638ac3a590d24050abb40a90fcc5fbc1ede89828536b759d1f3d0a30c36173594291c2808a40c7dd0ae6391fc229f07c5a6472eb28f5158bc31979706fc3159947b18cf1d8ef12802f4eaec664fa251ff0b0e0ac385a035347b2bcedc518e0d4d3f405ececd39ec5469b58f87e949b2e02c277e605b111a74adb9a078e3b6b25f9826b22121229f87e71732c2a3218e65a3584a9d26019338e9cc89638e50ddc60ccf9486e94a494822fd43eed89ed1f9304e70f147054abb34af92140227d71c27417b269d65f0618d70e1f2942b61bbe6d9754afbc206ac3fa9cb34bee71e701696145a6bb8744aa9f1961fa022903367909835e8442b4c759b759697a5194e87f03e873c200cc1b7e4ad394c9072b662ff109d523990525a1d9d93e77a841b0d6bcda416b42ba757579f895e9072a0430dd600985ef3bde11b2daec7889eb0a8cafa965df88c942f0b9ac1e1217ec827333b3e2cf879e0751ff8dfcf59bb81dd3fa041c2a9d757e9bb3ecf38d5dd923f299a0acf7b6c2815dd6edfebac64874020799bed756b16f928e883ebf075f376a8096e289dfdca906882eee2a93e6289e40a47975eb2e5a83cc2c1f9a72c5b5a1aab5ebbac8d0b8b32f358c879dade79af3d6faab0fdb6c17df306a8a001ae05aa08956b0196cddd9a3d225e716020675c3df7fdf1e7f37a139cdeded1b4a022c3d9d6ff82a66641bf94d97469920fbbbed4f210a9b9e955ec6db2122ba9b5d2f72e59de9da9e3337a02aef622653555814eb1f6acf9100095152b7d8e87ba79f214f6c40d0582fe3b6c9adc63ebc9cd7b39adae58c0e0554db27faf7effa433ed6fadc8c32b0e5d15ba657a2b1b27e9509481961b0ce26b658d3b05afd47b05cb9e2bd3c242d1156c6cc28e3cc8a2459ff1d7011171a77d8c03e41242f4e839cb1b99e36a36ee577550e24924c5623a20e73c8d2d1443c4012b4fed213e05b4190e72d0bf60e61f7f88ff526447987f797299c9314d66fcfa4e22f2145221e02f8349da1086de54c3fc2dbd3add16d6b639dfb0b0651467efe149a87e1ad89307d180dee2171010e4cbf9befd3d2635b68f53d073d58e947471ae9d9b9684f0058121104f26681e1462a1246c0f65fb8776f0ace39f1a5d11fc8eac8bcc48a4c4eeebf3bcb4ba7e5ee163a4d6c982064d036d91367703560d0bbaa920a6438926b341339ef16b8d34c6eaf21cd7a42e5454e3e23e3d74a4cea3e5ada1016c74362740f36ee4b60df539125c521ff275a2e5e61a3374c171916fa78d145e9e6ba9929289b19d340b71a48891d65786b5c1e894ed03fdbc40e4ad8e5a9db30c38c24b8ba3d960aab483689483e6fd9ef4a8b41c4d1629f49f028a809e88f4120fd9c7b64523c133977f18fb0d2fc27b82a1c823e4daa9912695da517d14164879fa5ea8fad771e4a270f541e67728161b339762e1387b155d8f90dd9583ff5606c8fdaffeb5c4c624107251ff9295c1b3b15c2b10727685f8fbe204a9996e4c6de59180d6f5261afd406b6b486dae273b069af2b399253687d57d5565ded5617d59ca96180dae9053daf787994b32852d30528a5f5eac3fd02c961ec3bb4f973ed2ea3feab1d2be95c80d13db87f33d346d81d442a6a7bbc8388699a7d2104969075271cee254e0367c02c141020f3ed72663b610d970c7dbbab12215a5d0b1e487e664e5ee38e58533f72122b0967f9dae157b4bed605644b342e5c404b693ce7e4d2db956a4add67032451f16ba8f06df13db50dbfa16d6e87fad75140b3f220d0d5b649461bcd65af0f50b69f9b8ec0514e4bfef97d2af53a0aa97c990a00bdccf18247ef298dcce13ea4953cde05c6fe7dfd99a72410d31804c5c53e805ac3e5ae516b3d758c7c329caaf760309997eb83da8ff10b233650571e89811588f579f0e786a18a8784e0430cfc10685e8a0bd1e73a76da3019d57d483d7a2dde591fc7c09395a9a617656d6973da8c74c647da8062569542614abd47ec30d92b37528479d1bf38a05d4649914fac020736c2dc9fcb6fea09db5cbce3cd3ad33c642bec7c9a50ae7cf820c3ea61d2a6df13e3842ecbb2fad68c69f2c2933259fda0484405dbad06c31500581e267d9e2e7c4a45925e5c2a78883345a6ed8f9fc2d699bce44c9dd7de8c655b6c5d466b0d88c535dfb773817d505ce1acfd02c273b78d0013f255aa1f9a3f0d78ea72ea145c0dea3811930d02ed21ab0f20debb2fbe92edca81b1f44781b7d05db62e737bde62cca1c074c7c47a41d81a91894665217cbcc700c3c47b7e9aa395686e91f135536e6eac584a7875757b771d850e2bd102e035d9e93275ac6db0576c2d7fdd68ecbcd4bbb1ea2cca3f7687004d610c8ba4a7f98f8b7fc63e5d5904cfcf03014b081d2c44988ca72c6ee410750eb7740d9e1921684ecbf7f8222dea80f3a8b56b7f222f6287c875f189076ff90554b930d49d3892fc73c44318a31e4848ad54a8f2f53acfbcc9ab0a315eef4dc7544abd1e530ec5cb627a946c6c814e22d6c1b9a1c578cf4ecd6297b951e115ca6cc4af6ea4f083d2443c7c038ac5317eb5e36c205f7db8c8479d0084b8fed87275273e6540335c3169ee8301f184703781acc357879618eecc63cc7388d1e08386133b8e2a268c29fc723c35de1c0911557f0d751338464bfbe12d1e6d3a11f8054169622191eb79d1beef5ffd3999fc5331925291245eae37fcbcb4898a748c7f945d36f106e25a11489a2686685a564537a326bd4b3bfe7325683a902d164d0221a045d2ece6981de4e5d1c0d9bc77f12092996b0489fa87983f7096f4bc9f64fa3def6a2f635ec34ff5dd4ebad9574f03f314726cf4371218645400207d74e6cbcdb6d3599c0a5537445164ad325cc23d88e73d80f38659cb58eac46da97eff3d37b29b138e4ea8cff806f6adccb6459684ce6f89c6eb0f264240ef086348b58264c4c3cc26a6e17986edf19af13064f4d0102e122c2a65b8c7f58522dcc195c0fd7cff4a89dce79a8cfc4e0e978ab14aa5c8e3da8640ebb43130cae16809a47c16f9433babc6d4bd9b391e809c304ee81c01e3caa9ba343fbd65fd4079209543bc3e165f72f1508bf112e8f4bea6671bf552549c47c61a759e9f3af03dad5833506b5258edbfdc13d3b0959ae380efc645c8370985e295c23b54ba3f96554dcfbf34c9d0c695719c90ad6b39511e4d6ab1de290e83dbf49e056c6be086f61b153847ee145c312bf80298d94d6304e098e9287e07d6ee21d18f76e7ca3584473a47d916e3c01d47aa1d9cf69fa4674a5431a078358bb10f641bf288fbbe74db5f616bd5152cb54dc46203644dcf4813295c6711c7a2cef21d4020d6267c5ef3cd8b90f9da8ac10c15380d0564e2d4abcec5607a287c89ed7b4548076969be4258fff524fb365623268660b50d324a8726211c82e285bde65d80ac0da6335ed8d67067d4ff37f045aaa93009b4833053d7d2073fedea12ec26c4a2578625f61562afbbe4e03cd0520d9ef2ab02f6b7c90030edc1bc7913e6cfbdf9f9d0cbb6ee8b3ee50ac0c4fe72b58ebecca4e31cc8f5df32103cb3106e3c7be53950af3ff2d3147513c6bd4ba5ab185595dc5ddbd46e17bab20d632d2fb6aef5bac4ab519a1a63e266c2b017866d7a0bc6bfda8df1aa7a92eabde188a857b302a4c3c3a32df0e8425798db72f3b1f806b09bfee570ae51f527e1b4da2f3b0b6d1b8f9efd721a1f7e941c66637632cf6d039427a0afc091f622a71d35876ac73cf40aa7b726ad2adec0551fd943fe3dfb87a227f769dceb1cb156ab66bfdc26d9feca7b8056ab71fbf93c65d2f206298ece849aadb7611c1e3671257aac0a2d4f703fcecfcbb8dc3e4f39fdef094cd2c8fc222ba3a20130ee181a4b272db40b2aea66e71891225002a310500547b2913fbfa43ecd863210aebfce18917f127579eca8c0c8bfe51a1e50e8bff19b23a28e570bd35f12969e7b628b496df718d8da6178f3bee916941cf44f74a5ca4f7849aac61167c9ced5c4c4e81cddeb6cc328414af02ba68dfa3ed60f2fa43dc7d98cfa2c40bcd37d53e6f524946290d473d9745abb6b0e5a1bad70f3ebfb759341b11336daef19ba9f1314f42ac6b8b941f36f659f87f13636be4fbba7d47994938c03cd13dd22ca77efd0006753305cc0657bd450cb9adcbf202c682a4b1f833db026fbc614fdbf943ae6939c75142db0fb5c059ab527bcfb28b77bd7ba67e112a0ca4f1d943923c49e51af46c9b0c2fa42c1f9e8e29eff312d38e147635b9e093f5ea4d7811da2fdda8dcfd50e3bc7351250fabb5c81077d4c4b18e2b7d70fa43f011234d1c9f5b07c2ae501d05e5dc69c759d373ac50481df8b684fda5f6f53d081edac05081474d1dc95fa7b7715749a0e34e8602f1b6438a5c35131f0980aa69a24da0cf4bf2bd76a1aa3be8838f4537800121740f4bc1eeb6f3e5ac14f8126d569fd428318eb6b39f1ddc65e4bdf545b62743f598d68ac1c0c5bc679302edb3a1b85b22441e05604ea02c0a73a36999b28238c18c2d65a40da096b6eaa4972352cc6a0fa86fd5f287c0f804223a10e68a91a00dc6b0e223ff7b23f30b477291c4a037ca516afb9e543e174079740950125685af7855357a163221b26a23672920a81952e377f3db740d82bcdfcb13a24e93c074f76a9181216e6cab5933b43e14e98127d5c4b220537bb14545507ce1b08dc1f392397145abc0afc195321ff3b2f0f2f4c57d548ebb527964d338f8146e4055f0bf3d522da50e4677d9f0779fd0fddf8b98a0b5c922026ae5b911cf5875e06c7c68e5078d590b39ca50ce9a2d427f87d04ff24cb9eceec3152aa7f6da80cecfb372e34bce45a813709128e7bac190f4b3a2c2c23c89a8194c5ee6dd91df79f2922fe6d1f08f23b6e17c541e292c7e2f024163e8042cf5ee907c721fbd3daa6dd026339d43925cb8383a6a61cdc7cf20c5a344e24c77ba6d45dffe0c175a529b5cfb9042144a8d93c28acf793a9fa181a690bc786e1b07039c8e5aa4e1cc3043dd72df845e6c6857f4c5cf714958ecd06551d1f72285178f0daa74108f4a2f7e1d3f056c99798c8615555fdd1624739dbb1c5bb3d299adae645643cd9b4ad283579e8ef502e49b127c222dc3f9b9cee0407f2caa15a7dbdc184966d2176bf4d87b7db06bf481cd2e9ce57b961713ce308a0ec062915ff861fece824fa999d9bd4cb719af50c6a853f7c02bd3c53e16d0048fc9584bf2de7f287bc9bf22cc395d7641fff85c6997f2443dfdbe3ad0a947d2145bd5fa09200c048832034f7f9b278b8e17feabac77680a19948fd45a583c0f3f3752f61b787faee77777b3659269d7fd6c035135b73c427df6c90f507938c3237182815c9a8d683730677072fb1d6f023dde23075b536c4f31dea0374d3a37ea0577a75f811358490d4f1cca019c56cc2bd50c9fed96905adc34b4639a8ae075bfe1668c4f49ceaa2408f3638637d742ffc0fdadad0826168d68792a35ed967ed4a4cbc779e1f3d86471b2037e157eb22717092e5503a437271c534b486db704997bf93e9dcc9310c502b8ffaac1925a2b6b58fbfec1016bb4229fef40c937bd5d30a5f805bfe9303b4d11c86e7e00da874155cbdaea15bbc0eddde03743a5a81a5b5a108e4cef395a71118b5f33167273b9564a8e6977f6043e20bbabde12985267aa8191b696b8ee18cb97177cf1b7048cd27f26e85f0384ef57f9529df64aea1c21f0a9f3979ef7d3a4cff25348f86ab9691da20118faec6ed095f46e617fa6d4a77dea10a86a2891a1acdd9efa8079a229f38fe1f4673af786f4605a6ea237d9643b395d8bbfcf76fbdeaf1774744aecad331a61748b4b25ff1e1e6195766296098572f5c6fa12fbe82d2702664b15d3fcf27ffddea5b3a6bbb4dbc51143b31563ba0e8159e8ebdb253c72653ec6c2875b03036371d71109851c0f1d2990576f1fa7ad73f050c3a281cac5e97ffa43e7693f76775d15affc0d56931d533bac7b10b099c967d4d88121a195764db7b5884d3b5e89093264ed7dfb5bc0c2f5975557f2fc52faf5819735fe87c12bc2d78c0da3ecd5e00c9598e14716207c431443d355d6f06dce09a1b30c0f4cfbb92766e3ac7d618c34c559fddc29ac9163d9e5a1e48797f0e6ae7dd4e67f4fc82797affcbe48473e3e7d6de3e12a071b392ca1da1a7703680d08ea9b771f6146fcaec101c3e1548c97da5bc6f46f3802e210867094b113ae118e17259d75ecd9e8cec6164cf89ff7f175cfa353c766474eaef6aa25bead1223ea940e51b50a4d8d6740df159bf3a4a5ea98c22c879e89fc2a17e6766f0a9fb1c13c9e29e324fa180f231b70283d1e87509e92f72d60e53a743245db08525dad0ea609f0a37a15f813248d5e0581aa42cc8930b1204ce75a70b8d67c9d6f5944e39e234f450a8f740e00f9eda106184e28283ae6c275bc908d32a06a50bf7dbc1c59b7b61d53093c2b2e81638992efcee4b48acdbf118d13dd4e90c9b91c8268ec9c51572ac3e48248ee1611a1dabc436eda31bc1ef416e40e3cf2f756c5afbebc0092d1370dd86904db6184d21b19dfc77c42ce5256a26e49a9b617d31cb0afda6fafe762192c3cc3b9580b27ac593e16cfab9c3f6ea790d65fd257299521f87ed528f1527e768cad7848e57cdd32644468bca7ce53f9e0433fcd8e3038b177878b398d72bed29ac27e41cf26f4ccabf62f48051d00c171b7f5c4f789d64422ae152db1c8a62302daee6e2a7435e4d0c6179dff71fad25dc0ae6f82f95e171a237e7bd3ae09592367a815a4f9a99a599290e446030a2035fd0a3862125fdb795efa64817d562c10945028be25ef87c8398fb6d83e0e8e39673156375fe89e8303a41893894689703b4164677ecbd4fd81b438f9ac7ff27af051f2d34b9a9bfe28df475716221753817978d061709af013053c954123e542a667277011241d45698dcad70a47066a6f9f5bc6735536f3a96288ea83cb3c436de5ebd80d5820ae56571c1966f24002746764d36152385a5234bffe38e39fc927181dd3b2dd6acc6b6370ca812890f3195cee51d609f93cd28ef716d38a21603b65a10a09b375b5ee033d26b5bb2d938b6daa0a5dba0b46579d3de38496f90362354c66b9852d1c835263b8734a665a88d75d84d3e0612069942cb5035266ca0497ff7d0af3cadf5a33836acf73024aaef15727caabeb35e0ae8fa39e88efb267d03c334b406107810ac58dd4e4a28bb5b87ff552f971933f6772beebaf481b9ab9c637235f24b4074565a7f7a0b8b0c58fba1d6dfb153f9bc609013bcfcd6c0da69edbbbd90927b313369c29c49000c31b98e3afc159b595e5074e77ed589d2970e43a3c04778a3112ee7ed1d1cc8ced7bf3b21d3a91d37a5000363884dda4162c6c831e06241cf07f1bc5a2fcae188791662b770140b405fbee935aea1d2e1b55d2f91649f634e1d101b632ebc65f1ebe8fc5bbe12bfc0e67151ff18d34672ff1ecee1186da873adec019edfc5632d920f7c1093094fc28991b51ad6e8c7479c6e1622513287bfa6933c10dcf0f07d32ddbc6d29551ff281317c9866371bcb6a086ef2ffb611a50685a4b91ee0dd63f0464614fdbe6c91405983592ca14c487e5a74332cb3849a70760482e26d87fdc4d475d2fbdf5d8d85aa0ac6161e2b8a22b832c0addeefcf41d14bdbd4c7489031ef480cc1244ffa375eab99751489c432d78f03d29b92066685950b93e7cb61e36b6befd0495e2f6f029dd69b2e83dd350a844d8c4cb3f7a4fc7a6b0b8cd7e71c4e66e90d25d64debd7ea89a63c4dad630005c783a37c169ab921b234255da10767411be87f078796a113a6ab300d3fd893de0fff632e6b69f2fd2fc491002d14b7db64d3bdce08ddf030d0ba6d0f55244345c5f190c77d6bfc30ef14ea7d3495f87d7459d9a6d66db26eb9784fb105b5a3323c0baea263173c6da4752ea7c659604d3bfaa830b70768d2fadefb6313ac275211bef563389029c9694ec439bd53d6025c3b7192a83d7ae3626b39f9da6637666445a2752318854a72245c133af29bbbf0c85f191c169f9901bbc702f43f94b303d0ca327aa5aa7ae5400378cc63eefb7728ac6eb6d268693093581e84841a5ed8b7ad759f9f967811538d4ce9a7b98552764b51b04f1c9ee5878b78ae3f7cbd7828311e87eccd8a7c56ffc272361a22e3cd8e166e7abdf34758241debb69323f02e45029a24e2adca17b4cd10e05c34771809e874bb192621dfac8abaffda8633a8521a6f0e940ff12399f53cecfe7296688c67fc9d6860bc8362438b906ae2687db6b5fe6397cc6fe00499582da2e53fbfbd0ffb83e4fa6b57e912ebadd0a8b88b5d33b47e54bd31666284152cc533fd0250e947b6c481100ecbb864b7e9bc56b86e9e424827cab44b5ffa78ab756ee190f6c60168d048fc4ce1ce0236ad9d641174cd9edc0365705c038e382a1aa7a6fa03569ea21465cb325e2b13d3c9e93284a9ae69797d293ffe45db3b43974901cce3ec9dcaff0003dfc98c23d5e946d1432b7004836ecffc249d2508186441611394b24e64f19085b7e97c0978c9e2f54eeeb1f4de5e5416da143bfa1ea5e2cfadc532c2ebc09b4f32331590efa0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
