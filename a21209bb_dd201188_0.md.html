<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7bfbcc9e80453209bebc0975f5535088fac39e65454e9a7dd32acd2c0d68795617656e10b74d070fd5e69c46810f2559f0468c4e60236acb87eb14fa4c2240cced097105d2a1859e35479fe57a3a346e4050c7e57a80f75fb5620518c39c29a5b176119edd5f4334cc09e1cc308857ebcb3d429dc226be71b6e70811a0ce4ebc5bcb3924c35472de0a10d76e964062b97ede92dab6b62e39c447e68a1bd8ddc96db6762d209ab9761fca75928dd2d4f5c32f45dadce2daee922f7cfd2df8d759e2c8cbf93527af97b3db3b014e5d190fe6f09df6ce9b64afdb91868bf2e5aeb2826b6800b0aa930be219bee1278af326e5747f5e0d5f8d770f32039a5b26330195538cae8347de95a5781a115d321d26a1d1edb60cd950750402854116bc6bdfd56c10b852bdfb650e4574a4b8c0eb1bdfa9e79776c7b00baa10cbc9e15f48bb12ffa1c8d68321f612d980e129e4200b155cac08d67094f9380512466eec3167cfff18214491f059c39de171c0808167f849498f949f4e9c731cda3903fb85b8d63804a2115960df03bb0229b15aeac4747aa16c4ec33dd46053c8f567d80f66d8bb20c3c680254bf2ce30334396374eb8910be8ed9073040e99b0a44206f37e8a2d0da6ee39e88cd6c47a99d92b0f81b35032ed088236974cf1360ff24f565ce722a4ae5e0ee876328394875befafce2db6f68fe500c72a918163d6310f2c5a6d1a8829781a222ddc0eba45fb820ef982fc7074b275febe2bbaf6b73feeca50a890dc5713cf7789cf04841b786fa7946dc343afc3877d830e8109bc30ea7cf5528b07755a5bb840aa9f13b7f4a9a3e46035144bc3e4a8624065a5b76a08535b4553eca2dfaa10f37115934ec0c59dbbcf31a43509f41f7d6388cf62405595aec79e79c0e1b7d85f23981c9d306ae7b6d99dd1632ef69020be9a0bae926e69f31296a7bfaaedf77b0b17feca791e886b733ca7b2678f94d573c475a59cbaceabd77eac85a6864a3f5b43010a0813b99761183274544cbe4b87cb6211dd2d73fff061d69f7c58724e2d18c3d9294b61710f0a90a415ec056406f48f6fe41819e3a2e48ea9a4369d2e854a09b254ca846d83eb0601921d55742b5f910f3ec1c239796b8617c41f5ee0f711680cae1a8e632249757e019cc1f3e41753ac641e0778af6f6b68aee3507bf4cdca33f99ada74f291859d676bb59dd3c43625d60ffb74faa470931186857bf4f988b8500e84381c7fcaec7df751660991e2572bbeb43b5f479dcee232d8a05297182b038f1b581043c43bd1143943d067b74eb63961a276d1d7e240eb65ac5009fb020896166cecb3d721c3512cae8d4deaa1c9d113351ffb6e8d47cd8921b94f1b7e7a16457d52480e59a7d1aac028ea9b94e1aa2115df462acffe1a0955161e192cf44d2f2768c691f5b4c40e546d191bc21008d12023eb75220e4154fcfc6939de952550859198484332df960b2ab86ff01d65489eb5a9e94810145a7b110fd1703355ce048014a295fe6d9b5e3b77ed2d45827809a5f5896910a72f456af5bc08b0db820f86e8d23cbb045068198475b0fe7d90bb58aa74726e672386de7d4e75412e546cae45ad22eac1abe466fa7b12d344fde269c03d83f6cd9cbda8e2243cc96f909ab982e755f25374cd95bca72ead6588bb652b3de62b1eb22cf9259bbe1e21168afa9449b30e51829e348442f56894e5e0e6109991b2e0a3e7fcde0d540b395a2ff3830d2e713eed62d603eecde3e55da21050d1b1f44907ac9bf7419eff3fefef75a673ed2e2ac6ce81a64ecdf7581fb3ba5d51b2546da9fac1262e11aa76e20211c22eee667a71e4e946952b415482e42d71220b4788b43b7d6214232f144bbdb7a0f75555cb69e29484860ed8ab4ca55a2bad5196f4fb39c865a931df49cd6a9d5e9e771ced5c30cd7c3857d68e617b4d10951a1f8d753caf25ad8c960a826e9ea35070c095c0a7150e6b4fa9380617c3e4eabfde689507253ec56af96dae3c7ce695a17112492e5dd4704f8769d53118a12b02d34db42bcd856f047d357835c02710d6552961e98909c6e9516c44b9ac07c3369bbb94d0399cc81eeb4cc3a785465d10392019c0ee03009ace4559f5eb62d00431b2626e08f6afbb4ecda65476dbb5d1245e6620a31ace1cdfb73db2c875a84e33a0ace241f6631e0f504e9c9f008a6547954932c64984ee0e3ebc9821f3c42824f6b2bd76b0b6602fc515dec7f76dbd67a983269b9c317e17592bc3e4cf301c3a7d55e638e65c9079d21cb5e98bba14c45721a2db8edf3a3067ce603a075ecb4f6d456b32de14206ef2c9f2936362aa4278b4259884eb23eed9da282fbd10bc5c72597d37dbe3d1890415d6d587883fd709f41ad3ac15de6ecdf4a9666684f7d18877fe3c6443361bd5695f82dadfcaed0f58d923c62bcba7ee57f522847dd4e66a5820c36a53750c7355d6eb9b1360b772fa4d99021bb381e01f40abe65418cd3cd66b838388cc41a5f3388766f4c00a0c5b114b580bc7dd20a3e3c75be07b8a35b895730d7c3f0a1f7c456c9897b3c9155e16139e41becd96860c9dc90637040eba41760b6c8abc8536c9685ccceaa7f65fabc6e35cdf95b9350acfc08180f15920f6d5e1debc7c989413d499853a66a079535afd0b8c89feb2e0ba9cb4b48666071de415f9bd55d3b39827a2a288a5613971225fc4ff7309e7256cc773fccb03b8e6f0c477fbf4d233468e4dfb84bb137ac8be2859500149c36243164a2b35fe232da7f1a83d823aa65cf85b61976a07fc3e4c6e6fcd66dd74c46426b280ac1b51e818f1b949e30b4aac66c30849083cef3cad46d33cd9eff3fed427bbc365578c0569db45e2ab2b9670d7480f58dc8942d0b3171ad8922ca65b7183ecb03cc5c7f1ba23cc88a53a0650f1ea581287e68189ca6972bf3d8c02cc2261dd4714c7e707d57fa40b0c731fd43c0ac3d219965c889be464a01fa610cb9da5f741a3d3a3f33c214d55c2a25c8d537409e4e22ba7924d704d11bf82c1b136eaba5e3eb2fc0cf0ee408501b15f855baa5264da76e6f731ef76836d93284953f453d9478b07bfbdf40664ce768782993d74ceb318c88adc8aad3940f0c9168b52c224bb22c883b619e36f684253652c851b18ba7322639c6076b225394b97c79ce20f5678814cac68c7acaf138be880eff143621171a25674879b3a8033feef95ed48a40e6589ca7fb0b8e7793fa360a2dbf5eee7960c43939fcdbf2b0441214eaba700433beac5e30a7fb666eaa37076bbac94056aa869520edba3cef6c594ddd47004b981508d3c8b0768c6c9b2872ec6c79997bad1943fe747e2bd99e712b349af5961aab987d0e4b76b6dc799e1adefd3e40a528a1c7477051a9c5fce067c6df340f34d8e65e84d82ceb8cf91b60d2e1e5f20ee3d6958e775f8e50d6045de022554ca4607a98afbb83b23e20985c612e8b4a7e7530045fd7bf3c2e40fb91d872f58c2e45817914b946006d72280ba498962af003262c1ad1568ace3e60c32ca150c884a653f7040b7a9fc64cad41f2a62c8798d8550d704d172cdc18b3748a0e1c726fadad83156b974caab966c638f7ec1f0ba270d6b7cdfc0bd82559871f47b20e90885133b3fef460f173c95532b77233650a0a02a86df8dd141d0c391ac1dca4370a40de2287840d220bfdcbde0e458ebd636bea7479794e0f42a4f70af6a5e8155fefe1d0a83d0775039389bdda9305fb3a2738a9cb07d070fbe81a9687ac70b3a093fc0e8bdc7953ed34d8aaaf7fd7d0c42fd18073229a4ab7fad730bd74a61f40d825e6a36d6d17091859802bfad3aa5d80ac4e54ec17ef0d8001eee0a0cd9e1c8e8562c162956b75f5f9a5b07d18c14b88c81c509b092b8e3d5f0a6ac7c11fa7eded621cacbf1f3ff61636e18b23a222ee58faef2b6f461ee538401afb10f4406314f688915f8e25a1f20bc41a5eccd200cef2ccb1f4ce68afd386a643af760b1593ab952af4d0a0bada4a5796b7549a319eeebd71b452af6bba2c38c92cc93aaa9459d5496881981894f6b401a3fb1d61557cc74c663f64291e403eb75289a4aa7422673c961b4aadfd900d86be670c22e287f793d7b1dc675eb6c30d312f81c71e19865bb3f746ed4b72bfad93adba42085c243e257905f1ccc06e6d6687e4e30b957fff927cb1b95357ff28bc5a583078f11b17e51cae4093036510ad9b1aee3a8da50cdcbb3d2b980742cb17e0dcee3857da024db14fe24166791e31a18b6a336a4004c531527d4892318bfebc3399bc2909146b66853d6b3996273acec781821ccb94571e32608adea5747cff652cdcf99a167f14bd82901e44b33e6bb0d12763710a7eb63c1ca3007a77123350ab13449e21edfa7f3ae3456eb5b8c7809a5fe5c5e3e3382c6f71458b815ae5679d066deddb148a097ec0c0988854bf70bc13c5fedb8c23cfb0590b3c7712a395ef5df5fac380a58748e333982a46ffc0c54131ea191f53f2c1affb969f5827b0d5acbc2455ffdea8841a56c3cc97057e86423bb5b0e4998223b58326fdbb6f9050ed6b9812fbfbd25d929bc3948edf3864d6a923f4fdf2ceb70f077e82e77a1804abbc5792dac52f4670e4cc7b7823cd332fea5ffa2482900227a040ee81f75b9b7a9c677decab169bbd7ae5a62905ad4dea2c87014da6b1a291807762a94e32bc8bdead000b0c66f93f94da4405b956fd5529b618c9abf9044737db0643c38dec8b93b2127bf33744e8e075f90297db5bd92610da88c624b7e5fefde867412e5bd59c811c537e23e19ad380fe624138e8d6dc001afe16af28f5cef5c3225486307ff09ae078656d32357a026d8cce8b94fb20b3d0b269536e0b0d61ad0491832f5f87a4da13c72dd066b144b5ea78672516053282917e9d6b41f8fc9d7c86ae445df88e2a6f2a3bea2bdc6befb2a25079d8dc04b4d8f2c72776f25f484ca9f3a965166c2ad276eae2cafb044ddf7f92df8edd01e83aa6f160b29cc035e32ce95fe3e6cd3d4f6f35c9cf39f8d7ec9ca4dd41d5983272e38f9f49ebe3672c4c04f0cd01860258902f821beae7f76ad6c0f84a45af7b1df34bf72fe565268f3f9da9b98419d0f0148ed4988e7180965e8f6a433efba80afd8aa75fe924b52f96e5a518ee14e48d57f622f347f3d9d968ad6ef055b30d5b0eb8a50a1a429b7f8248de4009c76037b44782c3bbe5552a223c163ae448775b85f865f6c451534c6ebc6e221b52acffe80c6c16a19f05a67df627ef4b0a704b246cbdcce904b5372dbd7cf32c2bd1a3a6292f53eabbc8d888c3694b4b56fa045657fa35b3872950dbdf5bfda811613838d34b9144ec8579bb9fe44710bfdfcbcd46f4f6aab7982b2a58ab63dd04e88768175d9c975dd06bb4ba034bfe2da82cead62dfca5c167b7c4821a10d7a2145bb5bc5a93559abc3a78c562153b207babd3c66866711de43bb5341e40cab384c900cbe8f0ed455efd27b44ab1156413e2d8969e395c05fdc136393db0937fbedd660af66dd3dab31a0c65380bdf0f4201a799218cce6a637bcf8d578d44138ce72fa03f7560fba24ac6841f5379cab6b33016a718b030fb13eec669b5579ad1b738882550dfcc72feb2ef4292ed7c735dd04f0394bf136b9be008cab60ea5389dd8bf2a56f8c82c630584f092a729f8c635a67c3516433116251ba176a6412ce6aca289e2376ae986ed114db7e3dce891ffbcb719a95296012b7ab436414364b6dff632a46575c5b3e0e78b0dda2072b28f07fab522ca1203769c4b0b558e30c87757c03c5443a757f4734a8aa973611676724ccd96511836250c01cdd1fd407ca8ab87f9bc7c159a8d64a907bd5a5b6087715d680eaf2cfc42a92f2f292eb5bf81d93cbe4bdfd4ade3fd7226ba0caa9db73928b3b0f612c96ab1af0d8c58206faf4523d420425da33ec4088cbc5924bd324b71fe6c9c5f9260a7aa6281777f6bc1da97370e281c16bb30f4cd4b4b6180c8d66df255e79edaff45e35194e089f5a1d161c8dfc7ee967240b1b84a03e228b726e26888ff75f7bca153314a47596b47461a6aab989d418406bb59cddb86a0bf3383f0a42722252e11f912dc28a8203cb45b6edda01ae7421400dcb8a778916e2d772c37eb8c785b8d193403731bb1a9216f557b59d55f13528d87554c3b4f24ea0a87b0dd8dc13b7a175a140a76b56c7049d1086c479561457ef8f14e9d8b23b9e0c51ec23f914e5a1eac283d6c15bafcefe1324a0599920d53c26b5a569693d07bad16d7f88e4ea8bc121654b4f37d94d877a506db806f2ed4cbec1a7f7875c0fc8e4a5d01a39da623ba89d4d9766b3f3d8ad14a45755606439e38ac3473a1b6758f168ec515d6ee5493a265be8fcc55ce201528ffc83938180b29156df151c5aa1b71b5dc2fac7e867b73aedcf9ee61b165e7057145082d22096bde210b21c9697dcf84431c8b81643238a4795779ef7875d82392eae7d8b3b5505fb7cab322fd2dc37cc396800a867ce09931c06f2661efa7d37e88ab952e3ae8825f87d29637af5901c7081f85a1d85e532f3e07290da98840a1ba780db5bde4cd708b9130ab886b4a0c3634c682f5d37c6006ffc628c3a1fbd3c2783097286b270e994d38c3e991d0ef62efad61a1310b9bf102063c8d2d95eaaf57538cb9670f6fcf4d01a2e2afcea2b9ef843231d34f05bbe3a1f0bfdd46096feabf7fee5e12a81502fc3721bf99fbe1664153fe59a120741e17ccf81098eedc911fe3ab78081483f9686767ae04d224288b6d7c063125672f435e16ae474f37e080f88f03fc5b4536e38a48197f30628c29d8aec1a8e0f994ba9abfdb7483630d920fc31443ec2297a3e433e19872c6070c6323e60f51c8ab2c367b8747742130fbb8f35bc14a39698ca92c71bc8780788bce51ee6aa45a01b1235116f8ca96e47babecc61871194ece6f7f30f0f5ef0b7ca3c913f3f1cf872124e8ff3e7140a21662390e7f7c6299554477f91a3a9db6a91b7721e02f6fc22b3123d8a3bfaa82ebe3a6d7f767d7b3367932a5320caba5cde4ab665fd99f4be6686fa5d4a0b2ba6111c343906e3a4976611d05e0a9012b2370e3804467be05ba412c9b2ecdde784b8a6f9be77b92cb955a612c71063b330a9820fdc2d7184dd9c59991a2daab0a1b2674039ae05e137aee5fa6b7b8c619e18d748e845fda6940ea72bd806e51693e820200ba040e7cee6eb4071e84c7f098abb4cb2afec6e963a192efbdd9f3dbb1f58588ebb9867fa13ff804646f0da98149feb3a5e7f58cf0931cdbc367482355154eaddf5518a366bde515d79be37dba0fd9bf7b504d990e08c0b01f25d07fa4d0553331046a06114d632af209627ee06eda9ae8ef8d8c447a80b8171b86ca90a84896e0ca188a9055f4c67b19ad08596dba06f96476a22e474d4a93116fb93c2208896149b7bb6e5e805a3982b7a942d37d83ffa28e293d380e7ec8fb0ff5a09c0aae44d5a47a5edb784ebea0bf30c022e72149e59c61496677f6bf717a2f4a8ed3799aec8a2669273bef62a5b872a4dd088bdca46143016b190b1b9508d81ac95aad2ea0a88c3a6af52d8c9aa2651fbbd7a43f45aa969f98654614aa0eabcc128793cf5eb56213759f69a37b8c1b476474b4de67ea2fc6a73436893e9dde4fbfadaf9de98e89dfd13cee24893360a656167850d1b5851ff81b8c4997a0de6bfa8e4a5dc888d3ed2623239e8cfd215553fa23aec7c31ad32fdc04117b37949a4d21f56b4fddf9fd04398b8ca49b813c59e2cc8747c7867b611561d2f6bbe67453f374f6016fbe70431ba7e596c405150ecd920217d9e99e92faba76022e93cb42b2be888e04695ae2147e9cfa5e2e47d0c3566df62f1c25840733e913c27b6cb6607d4bdba1892cbf9e20e172088237b296cc44c870993ab2d53e03847834d3967bd6fabee013068583045cab72742cb2c77e1c23d846590e93613da654ea614a774f88203215fbac5222f0e431057e02e46dfd834c15462c4574134e30c8364b8d2789f22ee4b7c863b458a9bdfb0e1bca013d2298551ea1c3660a42057a2f5f0530008752fec056cb314bd7243e5d7090f9451c74d8daa6ddd52379080ee0a8f71b5a999a1dfb5961f1a178acab3cc5d4761fd6792dbbe12c684b9d1902a57ff5474b55d8c53b1337fde7be0aad65d971b792b3b7599e5c21ba3d0921d68c1ab5bfca28fda9ba65049ec27f1a4ea8d7dd81b7761c6171867a8bcfcd12173d200df44ed68c1281984a0701fd2dc153b050fd52d6142063e04deb1c7bf3388892a05006be78aea612a6ce3179c6f14834e62802504e01b2ff283083a201afdbe3c073622a71708d591833fa5c14bae36cff1f99d7421c30d1b317769de7401121031fe0c08efcd8566dbdb9d7d7295995023f90fda5b95533c6b1a7049a492540f44a20b2dbcedd1bf468f59413fb3d7b1ee8cd83a6e640b0b311663c510804cbf81ce0a22d9cd987eb1e3f15ad0de59d6037248139cab13b5ef67d1c856a15b8ebe1f3f87a2b6d3404f00081246b40ec6c78f8ef1922ec6d7658021cf0454f6d688c2186f1aafb453a398ddc67a1d5411df090101bcbaca404c81a082a17299da9b63b987951ef57a804717f77f18f270c889be20fc5c9c48d90db38e0b7ed9d398eb1f02ecfd9f821480a06421bcd59b37ef633fe0cfbf2f88c2ea5c83846c91cebc33a46e4470b138122a5382c94fcfaa6e2a5aa3c1e4ef4fbd035aedbbcd2c3a3ba5848168af0cf0dbdd2838210f4b2661f7af9f3103f6d492240b4157072eb70cb2d2ae151ee66d9f1f3a2aeca056252bbaa828e1038e72366fb392633d907f3089a2d25010e3efb37b4ec3542e29cdf0bd696922b84496b13437a2404732253e5c65602b4ae7cf44119c3abc7b0ba2e88a02f184142a7be27a819bc32d19796963fd4bf06c90b041c83556c1b907cb5db00bb676638ac18ead621e717e900d43facb9a4435f5e80d922769d282285fa64a25789103441ab678e33d14c280b4d7709872d3f3b0121a6f7ab9e54179ae2472cb956727f714014f4e3a691682f5541e281fc6e0f096f5568d9d6c49e2fb80d07a9afe5c5a8b5144a84e747108341809e4bd3fbaa57efd685202c7c03bdc633fa23156471031e286cba5a664aa8d1848a864fd6561193b0ec7e4999117fcd92dcaed0326bd7b3b1225c9c4650815bb82cadaff852439be22d6083e32fdedcb63e611394d08023568df7049ca54471a52c0e81f44720594de3d8f72554df0ec592737b99cc1f4cf7b1d5bd0dc0a9a2c8817fc1f47921997ee31e0be65d9dad16cecec2441513241c98499c108ed0d1c1c060b90f45f8e852896059230a778af494827492bc0bbdf48f1a68b9b8ae039c665358e029ce69390393fb2d56e585d970fdf8ef794bddffe038039a8994d6b0e20edf1bfa65df1e24cc665f282666256a3b66f2f1ed2a19822d1b8a2845c362dab1b3171a3cf42e54bfc20269f22aee678a80e49dd501768033d8e3c31a4990082e5bae18109f3975b3206e2883bb53f94b0c38d8a5af2b5c24fc9a06a591b9a2f447a38906abd48be376172ed4c2340dc6641c03bb1508becc575642a4898a5ccf211989f08a3720d006ec125581c4c3a4a4b457f74996ec740e6fcf8bddabb69bc1eb47e487ff964dd5e90fc7bf71aabe2b1317bdb6c3dee0cd54b16f19aa5e5c6e66a7e1f5793dfac60f5cd78f168df87f28da40643c7999e147fcbeed22a4ee1d67d07392da6f755ccd000b1a660b479c4b33f189d82a36a1d1e3a87c542ecf8a8528f124cb712e7d03a8539965aa5dbe337ca849728103c857144d1d57328a1aeb9709e246062c1d325caa45ac2c207f03f6e1bbc33e2f149b3f4f29255816ce8cb163d5e93b783ba1aa3a8a62187b306421eb4ac43adca5a66763c701e6b02eff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
