<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d9e7dca46a37da00ceb23c21dfee717e07782cbb02ae62bd1c93bcab574e9765599f8eb4ce91058f16b5b3e119d6067feaa14bf0b87ce7237be2c83428f766b3562338a5ee70dda94882eb9a407ac3862c058541809c7f69ff2651912e7fbe70fb3467837640379f04ab3b4a05ef6c66cc0acec1c78802ea22973bacdf29b3c238ca68b7324977efa7ea85899c397628c8ab50481978fbb3aa197e128290096ce2dc10615d627dc6fc1893dbb9f0e8219d546271c32dd5e262c7d556d02e0189c1a5dfcae1085edb829416ef2b2c6786eb2d57848a30bec1a96d99bece0d0c9ed401bd83ece0ddf553ae19adf8bbd605ed0b9eadfe48d9d66583fb97abd18e9fc9b3854f6059c165573e36a18a4e16cc949632d812cc351a21fd103320feef968fbfc0d3e8b9029dc28c50e656cd71267392e9584e15c88478120c6c69fde4729d2fc32f17964000ab94b197e92bc6afa42fe100ea9d42132850569bc692e9dbfe87ae2da11c81340bf04a9a71ef7c03d5a80ad643dea2d4d1776862827faf6c5f6e78ba92d20a21dd993cbf290b6bed09b1f8f26acbeb707293b404564d0030911556ac3acc6686db4797caec2a9b8b6c31f29fe607b83405297ed3438c4032d9ee598574e214cc215cd84c81a5ab7acfb9d58416e1d707d664a8e04cefb2f4c35634016dd5110b25de9885589f7c13c09c2f195d54b4408bee090d73ae0ba5ae455dafe996f933e4e0c492fbc78ffbde83a2607039f752ba71194e679065a30b60ba6ed2d64a8813931daf8f08ed2d455ec4c577ab6cbd89c61f5fa6e60661db8394c5796c49ee4ea3a052a757b1de2126d3b667999eb8f6efd12a75e9e809d2f469c5c460cf0340f145d80bb86367b3b6fac309d0f6e396d4b6862ab98f4033b76504ab95eff93e175b4031a53e25dcb890be7edbfb2ebb958d04d099064a935687e08121172e9cdbb690d29a8f45f799e80beb9fedd118cf513963793e13c77fe8680dd842824b27401cca3d1dce830d10457f38830c5fb3b6c2429e0c2e7ebc9766d925fa92c00c140fcb9bfac1ea41554843b5b75d1dda2164480b886f7ff47a85f377bd1d574856febb3997c359456f2eda01412a9804d6ee46d09195a065c6c47dd4e827f6609aaefb0cefe642f4d6ef4f5c270d7a88b3e5aff065930a1274decde3ca3aba3d326701590de3c91b716366a66c6e2ca8e95181ddd2388d688b85a8fc7dd1a2c973c83c85c4bcecf97a38e1b8ad805fa1a22c63a32023c32e97dfd848d4773a508b4282ee1d5ef62bc6421854ea0eaca8d0d439150e696e2ea8ad90b84007158ae35cc825aaa510a53af3715253078c60d2073ea80b95745d2409bf0d9ed44f612c75acf322ec118d7752fdd8de52dc9c72cb3e1a25e5ebbc6451c680e2ff2846ffc0aa449a76a47c82cf0cd08b0a9f9695f8e78f33a316572e301b4491884c1b30e8a77f287b489491c99b5aad79ec52e2e8c0738523deff8e191a7a40cbfe1f96736f1ca3098f71f82453a005147a51c312c445e701f36758f8cd6eac61812f969f2276974eda5a026a09828905234bb00c3d70e5a2ad0f1f0924e89cc702328243a12acd2a30ce580493eeb7b95ca26c00231524641e62691d06f67cf6ddbd0c239ce305ecd00677ee7d514a3f28e44beb32ce4081fddcc76d5db9c2b845994ded3ea50c0b669ec408f9adeec7658a6ebf9c3ab98472a73e5e724e7cd55e09be60a3b5814567397dfbd806957a7f69cf28bbd2250b1a96715c3a536f473a3432fac388581d2085e809293304d4dc82881842ae127ce0f06d84585e17ddb694e141355b965b2de3123259a7978b5ff31c3860fe67b99639cf6641a9e241d8647e040c4fbd54a4a1646a7aefcb415873f7bf9815809b41cea301bfa9e2fd66d61106e8cc83d3d2610c8b91d199caff591e984359caed732bf6d0c8838cbbe8f7bfea223fee0967af6ac679f7f89ab2ba1f5499fb455518899300973b819e0e3c494e93dc08fc72205b794decb2524adc8e3331727fa40bbb5d164cab62bc0ff04f860adc0157d929092428330d18bcdb649f5047ee35a5f86d76bc0fc36665a07c1cf03c7b61b0afa77b7ff9fcbb6d81c699298e4101a5caef07d0c4f5c13895796d224a3e57eab6b96ff96cddde3289dbe55536bc9d9e19d2d78f5600aae3566818b9a2f13e5e5bfdfea0c5392466231c0ecbc8c46a609cba05fff8bf2e64577a68439783a481faa29ed3832c75f131c7f77c4f6b9347cbdfd2df2b470893717eeb92eecc6df78fac0c813a317bfd053e345526930f43c2dab06d104e467ae397ead355f7740f69f7f7747d21b8626126c4961b4b99a4ad81ee63d4f1c4add23e0722edd2d2eec96bc1ebccfd7008b0d9bea96785d0232eacfbd9c01d431fa8a2ad77cc260ab7dce22ce488ab3cacc5cc04f63657038d94a8a5d464039dd5bd61722ee0dfd8f100c95702b88eedbf2118cb270d8200c8757d54af8ad8563a8f2bc82cfebfd2db1f9904bfb03b289b93ddd2500148a76f99565b69d5f4a0e3f12bf8b356043383b53c014df94d057575c79089bf24e9d352b3c4e1e0c13c3137f641aa83c908e9b829a46f5442d9d6dec438d43492f96fe3a578763fe647550df3c5cf296c036953160dc1749f60164064c8663851e98e9f436a68dfba0c63b61377b5674d0b9716997a91c7a9d9cdf7712c841f142b6abfe32f3294eb947e0250bbaff18773074948a787d248307cb6b0e18969e001ec785102226a2de3892f3afe2dc6429d2e466171d76264e6ed3f51d99371f7e8a6d558839cd8b5ffe11c4ad270f73501dcf6094c641d77a3bf106e4fffcf10bf0711d94f65f6ae7d7268dd978ab86a4bed471bedbb27e44bbb0b662e43c3b85076c942fc4f78688281f009dbc7ddba9422f3c5cf68ccdd2d752aba3660ab88ebbcfde3efc2719fdf3cceb712d98398f6f3093f2c2653b93fea2d9fa4022d8982673edb8f86aa878177d733c091ed215499ef861bb568cab6068682b02b7cbccf4c89e9ee047a3075d579ae2e354dbafbc3294fe78b1fc5f739dcfa109740c0917b7d02c770f726a344aa92bd57cf3f344fb94930980d2be4f855032aa16341505a30ade03d08e43613c722b798994f6a8fa053270c6590ee767ca5c6542edd267d499dc1b34d7e7e7d9a08ba2da9c8eb6ed509ad84fc063302a7a79f6029d809db65606b215e1e1668ecad6c222be548e56e9020f2b0323cec46f93a9624d39dae913ec0084fc651811f3577b1581e7b249b0f5a627dd37672ddc9d3e26d2ac99ff216772046fd85a0fcd95f5b7466d8dc0f0e392331744ca3740fdd9b86ec692a65e27fea85091e94b6786f28a5699cc70da454aae5933105bb7a714978e30a926f6e7e771693ada264ab45e85aacf43fe559847153555319dba2ddc1dc5697e70dd46a55d53daf900fec02186634324b921c5362c4b1c536166caabe267dee89cada648245f7d8fa21316890f74e453c2ad9f43caad04854d787b3fd9357433afa3f4f454b8f0f10b8773268e85220eb9fdca8c9a2c01342f0a1603ef7db04c6c424a6451264624424706a1ef9d8800e7d293fba2327fe6ceb349b10ccd8af8c67079d086f94d8ceba9a8fabe38f38575dbb93d795a6f84f4cbcc07a3eeee7f9ff1645225ca5f2b07a12b468df5d96eca78f3f86c33f655b5b9aff9142b600080e16e13c585fd9ed83a1e7f418bc054dac0a46a0cd8d1a56dcd2d675d5b2daa37d309f5712de4dd938576bbaec3c4ed94a01d0def692bf457da994a56888051a3e41a40c0b50a02532559bf64a88d4d1600176f6e4ac8ec4f5e40f1f4437f47efad080c05ad5125b9806ef53e5b6fe6a3923d829a759db0165705fc0885cf279b0f252d65312d5c3ecb7027f9e6e2ba8045fc9b2a5abc003975bef7cb883d6064ad2fb71a153d301468dc2ba6a1138c926ca5157ce31903fc08f9d53bc12f84f30c343d79601c8fb3dc21703e01fb5291e191ef7969b71448fed465b86e25468079fd9ca5f0aea4f218f37115dd174c181dc03ecd82da7ac58d4792b301764c093faf3fd75873e7e2a3a4f993a763dc90e5b9aa0ac9e4d2e9472b288e8fb1af7d506be582c7cb6c131142e8852a6c39a41cb61f950aa65a0b40c67e8724f8ac363a941568513d02928277ddffc0c82ad8086e7f8718fb35de4379219171f2122b87b00546bf77cc5cad465ec8a34eefa7478e3631cbc672fd05255edf7a2de0a25637bb66889bb75810b53f95aae6baceb80af0bd841f2bc79638752e59f35d6367d8c683beb5d5a31cee9c2736ffc183e9f5509e82dea31dc900221bfd470b08cfd47f800275d9b9719ecefa1bc0ebaf64c4ef08cf8df5efb47d12e11e9390cb787387956dc94d8bc759e881abd27ebcbb5698219acee8f9cc7acab11bf1f69a6bcc5ac027751af55f199a71e4fd1efe7e3f84c7220b73fc8c6b92b67f4cd54cfdce2d48fa16aade63f08c6e31707b5a76464e12f2ff9aa558eb04e8b6cb87c2dbc1de82d9c65e58cab009050e2f23261f0b05250f8552efdd0e5d940114755d3355a3f0d40bf2f95636bf09e0beb36d747b9bcb5dff36ec703a2b15cd1875c2f5073ea989685fce57733e35cf998bdef82bb83631ffdf65d14e571c7931436fcb1aa7cb8f8c3756a591c1daa6cd26b606788f58fbadb03c6bf135f1aa9271c78730d108fab2fcd6b65ac3274abc028ff6871e7c5115d9f3090238718c41299879017d6ea52480cefdc29c114be27ab2ff9c37bb84b8e935129638debc332ff1f8943dc0d8684af6df6e2174e6a7308c2c69b2e2c23805567dd8fb56266dbb0aef1a3023b0c04a94820e8977f442fb6718cf6ca155a20425e584a0c0f52304d69ab6802044abd3ea3e4984525b9faa6fcce2b3286e83e5ff7f0382a04b7d1a0347b6bc6d33f39d3afc64e2a4107356625783a1e4c86e6fa9fd556360d902e30201f79fbaf57250ae8f688dc5dc1b67b2212d94d1db5228e9e072739271f66a5e665cbe58aa4e66566f0e72245f492ecb262d2251f9c59ceb1b7721d3ead481443df002ebff17f12410e24fcdff7fbd7ad93feedeae8b68d38c2d42cdf6731e55faaa1761a95bc0f8835c29e32847bb46980eaff24ca06786faf242a1b48b009df1848b9db1e15e1985514e7409959f7a5143192e9cc8bf9344d40d639f1e7674619da312b459ba24b355b771862efdb6e84b6c6a410944e5bf39cd90805b24b6ca07d98eecdd729928cd9011b236518b443504c9239911bf89ff85a6d3e287b74a0be0a571d500fdc64f817a760ea118b01e50dae34489f4e8bf42d50ee030634914de3abc7cbc9472585a2c0a1040fb51f2e15d96510bea31719caf74c30fd0dafb0cd0d4ce68fb82aff5771e267b1f0b42828b85a0033b4500712196cc026e652f7dfd93bd6e46302e6130f2c7eb28c1d2d5e7776171533734e74a5acc3f2ad3fc9e4eefb005d992336f3cad47990717fb93a5c9e67b915432404eec09d932def32360a8ed453a11d93287c6de241ea7e30c5ffc35fffb54283f0d2f51513056f0fb9bcb3b1db1db802c2b15dacc995dc71c06a8a6a33c54d8574ac4ef86745ea92f8817d21afd9079c98d0a3c357b5385e872f91285db87ea5004445f242878915fea63071cdad891248f5ca7d89ed61bed33ff06405928aca6e31d20e44c8687b57cb48c28d584ecece0a62a72763a4b97e28534d775862d9ba600b48c626ef7362101c3444b968a4506387226030e1da14e24a64b00a224fd2ab8ab1438b91c96cc213735040f8dc5c38cb6da36f4e628a44f9886911185dd46b349bb97a1618778cbb3459b5fc017359c799c56bbf31f8cff5c9f38dba023e057d332ece48cab062223caecef18e0e4e52beee2cdcbdc848237aa80a146c8302631adfce45c02e5a86d37b538968d3f8e57e2d7ee8cc160f64b0be5a0c9598a098b29567da3d9387e60f6bd39762540966d1dbfa86eb43923a1e48238c0d31a906df0b9ada9ce7e3c6c067bbcdbbd5b9008fb0c16fb555f9fdb4c1f4a8f7d5d539a49bc3ff3481ee6aae02cbf8d05d5e303312b5b12afdce7449e090c78049ed2e78cc8785e5c19a1ccf358c3f4ef9e1c381d72a763e8f3a98ed553080d104e5031a7964742328b1fcdb606f4fe94b7990083b635ded1e45654656d06ef8804d04620058a9a11b4c3a56bd4095f184f14059f5fe17331337e9d894f9867fa33ef13070dff13b4f195c6ec140f5240932a57a556574757144b4147c618278cad7a70fac4df0248b9cd557b94d4841abfacc2d55c87f38bce17feacb635add84bba51bb8dce028b9a5aafb85f90add894eb398c958f7b59c4850fcf4ed8bc2937df3ee1c04b4d1d67ad25bf66c8e29244f80b1a2fb38e3a367f24049105104099dbea2f176be2de0fb5062b3da39eb50c45de15015ce6709674de2bc6033895b78474179a0a99ba04772b2a20fed354219adaaed05d04f385a374c110052e5ef04c000f05785fca632eff412e4fffd6951b30cdf842880c2a1cf15a2b73f98a793d02f31804aa7a3a3e44e66cb3651db011b24c562f274692dff9ef9e3bf72bc0b7a34c4395a58298dcbb63a6ec0b731c6b741b9940e3ffcccd7fddf5038a0b2f1b659d4d7783939c09ae66c384d48b58f2a05ba688899fbeaf6dffbaeff06dcc46d995d83350413185f7b7e2407a784ae72be246b9e2c1f62202b298be8e21761d20d605906aacc0dc4b88dd1c007a460e3850a7786e60005182b34a65eb06984313d01276c0a4be965ba7f2e3eb4bb91ce5564489005a7990f04ec9b3597f59ef92f8d421712dea8755e1fb1281ec81a4b0850aae85db9f4dbbea827a4596417398c5609dee1ed4b2d3fddaf30ffea4a10250dc79c53eed34687bf5a46d80a5f7b3e2e14d4112a358e620ca31be1c318573418061ea169424fb55ac34db4b0b52efa08fcdec1a045cd28b4516a612670f38d3ae35d257fb46a123459b5011d905b13edcc6794fcb322af684c6e3f5d0d922796cb90ae51daa781b2969e1a65775529e59f4ee8c616be7be095f30feb0336159d2c315fab55d67ae9b04f9aa766093063ff5d21796e7895ba89f0efaede639f6b1f9389906a3101cb22846cd2dfbd95c88d062cb7d1f1039587d8160a8725c193f7c9eb3ed97f63df8ff1ea831bba4eea384a8ea273c9a6a107e36ecac38fa2e4df04bc4cef57ebcf2487afe9f540050cb6a118b967e95c2b189ca5327e96a88ec002fbc1ee3a2de4b36921936b5338a9a2ca594cf7d24936cb015b294bc34dec1513acdbe5120d96f390e31881c05ba27a8af5dd89a26553fb0466226cb29e6124f32d1be0ae3757e02993b7d2241f45bcae2d3aa46d57ee2e37c58efb6d3203ab18882e4334e92d32ac7df86e09f0672360d2e2ae9e247afbb525eeb6289c50b090a7edfd36de44ec6067ef328439622dcfd3403d13699fc94d02526bc1ab135f677329f1406393cefd9225ce107d3a2a34e3b8a95df7847a0a300cd916bb42edb6b6cfa638b55fb9fe19ba0d77ca63eb12aaa3f4f78954ec81c4f0f67b960f29403786a7392afc792ace9527dcace76bc2b39ed7275a5bc5ffe0ba6b77df1777bfaad569e10ad0dafd9211a667f4227fb3a30d24c5545f21ae4c55dc19305cd012530959a80a10e7b95101798817b2f13cb2a02bb3b8beede69baa94eac89eff1848a40abcbc8e104d2ea846b38f1088a83fcf1747b468e6a2271ed3e4731d796a56e900bbcfa0edf1899c40ef32f977503b960ec43d5a7cf8ec16b588dbba42516ca02edd69816a504e3333f213283b284e7f8b31733f8329f34cb4c64b180d147466d75a329e69f9137dcf75b2d2dcf85da6e413b5b099858c4637968baec619cf63a0542a8e9db6157676786e3942385620599bbfe93b9b94dd670936080480a47be0d219086bf5303c04aab832519c86a7f9631bbfd70105160598dcf863a40a0e00588ffc27a5462dfb949346c2cc0fa179ef87cbda9c080f40672059d9635b4677286d7c5dc36502a48af409607825300b0088bdaa166b7b419f59e9be056ff69732d618663419b52aad0acfe75f642db7175b24c35ad3433ffd7f71b3733b1f3fbaa3088a49b0ee4ace41baa4e09d21ca97cfc657a45df546fe6e575f0e2358f510f65e77a416c3f4364c42b5f37d09293750f739739b0adaeadeb3dca15b8e1b7a3687c6fad564e26d0d745e58c924339910f8f80ab914206052f1e7edcaa55e20a2cfb2c26f57bb08ce5d17a122471ad42f6a6a448d631bcb660994fa6f77430da33dcd2cb5c5d21c815f6d52380fe30a963eda6d107bca9f87ba27c5f9831e468fd321b46a293e2b80a1d4072eb5cf120ac9aef5068192bf8f4638343f0f179e4b9bdd6c94bbd0bcf6b672265a3b9cd8beec8e3b2a38393ebc8ee972b390e749d7115101f41f6b3c4effbbc7b36bacd25804a6f59a2adb3c953a3ce061a94c76d5673d58357d5c40e2a1b176653a0fa6b4b975245ece3ef4775c9a2fe1aa3068db04fdbbab0ec3f7b017795906b5e55902534c0e97ac4a895f48d6f9e75d65763a2de3f4c10a4d3018bb99def584db9fad4c62fa2adff95883847fdde38d79c86a56d9e8a2cc19166dd7fbb885012033cec81278b7276f3b2cfbe42694182b1bd1be6fdce000ff17664d8d3a412aeee6377acbae82a77f9fae06ab393ab12770f35578a78cab76af8fabbfd0782c36b11a189a683db654fa0c2e317285769d23dcdff52efee83a91360ffcd66e58d04a3a866e22d89c6b040ab4877bab9159bcf1323b6a85b1fa45ed5c9147262810dc973e2daeb714cb7fc58b34bd8e2d206f62e29fe4e272897a29d3e0826474795936bfe8aa8b8a926c0ed3ae0576473565c5e89334d9e7473356063c0ec99d730bd6d595535ef55e67e139b58878f7fe3d54fde3982b8608a54cde970bd5592c1c8d1b7167b95b40b4ce281b89a4fad7026aa973a756c816934e51cb3b13889f53e1cc1d1101e690d3ecac9fcf085bd1b39ca13dec934dc9f4fbd6141da437221c2adb8303d7ea47fe6deb5cb1db240d7d47d630da27dc08dd892d98ad760cdaa8c27c8e8f8ae658df96b36b376ded95cdeea6e61423d60325cfa1ddc865f9997b27998ed8f30492effa70a49baae70a94fa3d94c4efdabc5747839260d1291193d5d39dea2a557d921b482464fb809442ff7f47f6e9522468d6a1c7f4df964b0f7542ce7551bec4ab7bbc1130d518b83d9f2db9a3c5a0ace426290880978b56da072111c575aa207e341e865df996e369319ef7062a70b0bc46ddbdf8c0d041327e52feb97a18689ee9db6d4dd034047bc6c737cad70c456960cf889d7d2453736a1aeb373453faadfcf756c2e2be937637ffb88b436724a08d3fb32bc47256d3c4574d254313143a136d8a5a54bc497fcb0741d9b36648ced104f374b4bfae8b6e5f3898f4c7202e5ab629d45292843a2f470e9be76aaaae61e3fb98d727e06e6e803f7554c5e940ce38ef0dc4df15fcaf46764e4ed4ff75f17f543dbf75c8070b7e79dca650b13ec822c656a21d470b14e5ca171e0af682ecaa0199aac35c008f0af46d4c7e5522358119f869098f0e4e5256cb1f8aa4070f12b4d67687d6b9591dcc6a32c60154fc1a6fea5646028f61330110d4b6ade52bd45bef40d3db0d00e603bc40fd882db4e83be744980e2e4dfb317e10eb0783b45d56e816a9005c8b8fbd3fc3e38cdd68ca42416a38e9d7dd1cd9586aef047db6097c82f5a974853a0467f91eb1108a2bf94a0fffd58fd0fd9ab422a8b2b042ae7a93453e112c0248411a197f115e614b67a369621fdf5ace25bc90b91f9792d6514843f85d881c7ddadb2fb0cf4af86a2d24ef1f4917d29658cf46a960b0fdcaccb11dadec8158f21445d3f66b19f73","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
