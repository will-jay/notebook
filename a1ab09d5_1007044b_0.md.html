<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bc93c5ec25a5636ad86ace42a46e2f09d3f542453749bb7092b4ff51303cf71b29a018724ddb1ff3659e126fffc4068ab10d3110be06c22ae09589ccbb1d82e0a9c676c0fb10eeb78ecddd1395c8f7b4626558fa9ffe1bba722e3a99eca1b2c92a62f72cb07fd314a59fbdd4ebaca8bb6a3d0b20530624a6334c18fa3aa63c62c0e2c803678be97e06b833608a2543fe9a806a31156f9d8e059af075cdb8b81290dcf2dcf9156d98f5b17e6794984439d95452be00d1714b3acc3c608d780d3eea973bd2796c11688aa1d4dce6485d2d9469f03649085b999e9afe761be51486d8e1da3a8c7bf8171ef9cd6e6fd7153b0993f2d55f67d1ef537afad5593b0bbf1493b42a14d1a27991a20adaaced0b21d9d5f3a94bbb47088a2976a457cc9323206d802f3d4672273e768275facfff4a595a61d86b59070736580e3eab6444176352251829909e8ad791a75b8465eb754c91bcee8b761f41bfcbfea35ac79f774ae4fa43efb197408b8372ee419553c113a559fbbe56ba050517338215b0e342458bf8b11e6746e239b94df43701d16b95a27c8cf86b92af7bf67b3efbd4df04f651ff4c7a6efbc94745013f0ecabd04a811526bab6b9cdf7751563f09b3f1b225a4822938c310c253cfa49fc5114bea360507674c1003a609760c8e76a65f1124c7e8cac2bcd4a37d665e84595b112d353d18914a4b3a4ee312b9ea496f5671d66fe4feb615f200d1c66911854257eea4c18c622bec1100021c91e7eef683a028e1f6fbc313225ceb35887e55305974c139ba0c02e9ee042e5d7ea5ee0d3cf1dce5047a3d37e5967f2d04c86121c1eb4e357fbd752f450377d12f5fa2104037bb3a0a7dfbb29632dab2d847d53cc445c18259b32050c6290b32e54c6ef058208101b668107b2358b543ab28c902bff46db1e636374b3a4bf63a7511c0abc010e3a424b0482633d7076556a74a7d742d4f8a05ea88c2e224c7f2ccee36e53522303d57f5d4b49a72347f7dabd2fc983d5ff03d454e13e5e8bd35479502834ad8035f05578164ba4883440d13bd07144f1251cdf21238fe50e7e1c1a81c0e6c182f6d7c1fd8a4147cd6137511a6e469072e3dadc0a5ae577752623b5f72a5c8bc6d99c3a0b97cb2a9e5b5b341be23bbf8652aa799f8d87380d13d9918b85a247800029fb32817d3d6cbaa0e2f8295de43fcb8e852f5c71f7ceed77ffb9a30f5444b84f261c6a38359324ae9b03eebc645c036cfdc856946a4efe78d98fda117aebace0123bca403de7e9fedb5865b057dccc12288366ce9bbc6a7f8a480adbe95a01f6217f1847ca1bd2fef26e795558e75413a62cb96c3f13acf023790839215040eb83d654a73616beaad587f9df14931242893b0dd64b6ff793eedbbcd10ac427944c656f355bae80abd1509da33a1737b58b27be036e5a83f8b1b0a78b50adf46c309b9a664fd5476802289334bd233b4670b3edcd413cca9491532ffeac4041c2d9eb7ac4af1f7fcf6e19efe3bda03fb0277381c1c1c2bbca8630bf0b084fb28c9fcf16dab7aa51e9d06f056b6aa384546cc3a07856960471a4e3d49a13d445d26e5f0f6305b59d3c1b30e96c38e31939d8b3524ad9ca5127848e05aededac5d07a9720ef344e6be342709e5c5ef470220afa5ed8342389f1f74c7d97b5cdf1958745682d15f9fdaa66c98481da4d6c5af327e6d9f60eb770bf57179d4e18718c2dee57b2842981c81be801a508ff7eae543abdc311eb875882cad24a648098014f3299ca653ef5986f7bbd3aafd70adb0a81733d62ecd19d66665bbe5a5589adafcef7cccbf6632f1e60afbc4cf9783ee906ee7da7fe2d7319e03ce58a0182cc6adcf9ec7bb540e3fed7ac863c6c2f422a78999d60650171c44139c62545aecc362bfc4568b4c3936957583dfe8a67f6f6837372050b9e26fc3c49518787b0dbee17ce55297b9b85edaf6314ffdf618338b81a57df169bf1485851308157a3a1d5b170c35ce04bb6d413207d60141e1511814d684fc1cead07e59e4b405b15a43468d221d75f1ff37242538c3f8d6ecce7d358b8cafe53495ca93aa51901e75777e929d171f2614290a6701193080f0f0dd26178449320eaf34f7eb60dec67ba4adfeb8aaaf3ed24eef7cfd4b8dbb72dd793788a26926e5d57fee252f1ec9ffec8840a2582a6c4c0e550904b8d3d1de6d94cbd61244b7bec9c8dcaf8c51bc24a3eeeda9ce12657e3951e684ec75a9b30d4133e85ff1e1992f1528a61372e84927f110fe9e5b0755019849a44ad444ee7776e43305f24737ad6ed6c4addab90b7cdfdd503a8e397a66a415a9d1722a312daec66f4053a6626338bf27fff644ca20567de909c3b6eba84e70ea25a5e3946a3888b3ff70c9d59e4ed3512fde1a81545892c627b7215bae8389b28ac7e60f90aec788ea7f0699c1cc0c0f9db1c2d37e3335941ecdab04ab72ba706b96cb09fb077f6f4c9642720a172e3c3915584a46f30343b7d984dcc201564d543bcb144c3a90bd2c8ace4c850e032064fcd3bd841b3a10bc95c250807318bfde87429bf20b00ac29df6b787578b59483a1110c8d8cae52a185e30e60ae2ec16a43954a98a55c87ad4c53a150b03fdfeca0f8272dbf483eecdf82fcf224c0047b080aa2b181ae495cb2731f71d93f627a174801d55120f68fa68e604357bda2243957026f554b14912359ef337683b466789efe98b4a94389e82830f4a378534768b69bd5932f9b2c4ed7d51312c1c5c8c4b74f6fcb22af23c5df0f87191faa918cf633768643a7c531c341fe7bbe1817edc93fd40684df3ad4627f718661b2e038ee0e679138cb0bb99bdaba45ae462dcf7aae1bde51020117c536c55dd30a944633bf64187df6e71db6c41bc026f8e10b75008179cd535aefeb4fee6ce7b212b53252b5fdc6b7931a148573fc308373665fde8ce89647de1c48471ce7e6288fdfc7026a29520ed8e8f7f6069670c28cab5c5f48f4a99c211e7eed0b8cbc35a5de04e6530d4a3ed257c0d9c76891265b22cc80f1559bbc0de9217556e61bb17830a65e7bb08af6325e23b0ce6964d63303daf63bd5ec47f69158df11c89376769aec03a430223122df1f55997132ce0c1e76811a4f986aa9907d5cc474dcc3b09f415d186912d5b2fba986a3a9d2c2c5aa26c28d7bd4b0a3c009f058d1ef6f34e4c113ab7a8329924771bf6bf36c40190e985eb61f09be5861f31972ffc0a76ff8439e05f21de14ef86feb9e9a11e4f4722414e8a7abc24f8d20f2085f28ec68a344215094218987cd0741335917150876dbd6e9c58c5bc36fa6a2f75e2a7eb1836aac43f54c2cfccd20b48bf305b33be0901a08b7e97c23919cc6042571ec9c33a0a9d44b2ed5734cee0f99d0cd422644c0b10b519ae5fa1264203aca0a190182e97f1ca63e12ba7355378bc7ec41c161bde96fba1a9bce89cb8981ba43444aa5a4168ad7071a024b24fe26d0ea05939e29b24a394abc3c0ef10ad6747981706bb9a5d8252d760075253d00e576737a7f1016fcb7b300358ae081259e5f08f463f2b3fb6ae7180cc520a3561ad1438ef8aca07f8deba5901a8107fd3fb1a98decf13764944db3c1395e4a896338cbc40a3935e156331e5d2baf7eccceac88e1119368c41afc8ac4c9cffbfa20b5912ebe6fa9c44f68e7a672307eaf3faf37aea3cc3a7871beb2f037dcae207ed2d3f5c713557247aa6dbdfa87907a7c9ebb5c94babd9c529df5b0cfc28048484c22f9b5375db17c3d7eb0be3edafdef09f37bde2f4ea6d060c3b68312399e7cb4e4f5bf7a32d85e2edc79cb555f878f16980c6d96230edf0a3ac9ff04a5de8a430b3eb2bbb1fade8e12c7028c386d2aaa4a9155a9772c1f0d72ec912c830cbb7c15141e05c051f870760b9103928d77993a8418990f4a4931013e5ed9381933d1c79fe5d97f997b99f7007c6958a5c80d5e90d9e80269b62afb7a0443d26224001dc92ad2cbcf40b7f2b0ee537d5ea08112b5b2a85baaad35c9cb6024af8712a6338b965b97ae5f4103d3a3c74a46fa1060149cc255afa91754e3282e9d1996a475571be1f09b2f660a0cd5183e53164ca4964cac904e25d7b3bdaeac73ba2160c95cf6b815b9593b14f9332ab8eab533b1d0b96bf2cd71e8fd2c44e27ebeae63b2d7ebc9ffd019a652dfc9c005e143594c1483fc9e1b8d5fa1867a6cd80de92a761e1b3bebfdcebb97bc01d206140d4d3aef25f04e98c3115d6c71a18e21abb45d0cf45fc9d78162d6a59253daa29e1e2b9fc9307ab1b58f3ce283253333ea19cfc9410dd9f18310e04693bf6cfa8746d7eb6a5d6c922fb8f0a0311880a36704f55bde5fb1bc8fd292bb8c2d23f54a5c9ae48473bae00df78e086a5ee2e0dc16b71c3bd7e5aa7bde13f87725fbddb793a8542dfc4a5429ff6c5470781dc3b3d9d236c1e33ecf4bcc5693f60da9bdd67db535900669daef22ded6f465cd2332e8f78212f4e54d8fab979a4a30a1d7146ff0d3100b882a74546c56139ed302ed32647c029d634c4993355b4b11f8a460b91803ce6903164f78a01714ab718ae8e444302f63fb133f0c5a60a0eb6ce2e7fc85a93237e465f98190bb5e1d34819a090253c985637246f6c26e95aced4b4155efaaac0fadd4d24e1d7ca6198960508117dcc40937b7810fa41c2d2134893d9e88c9fbd64ed773c50b20f672b50d5e0907750680570d54d8a3b057bad4039d0e8546ee4d40ee63a026bd8776b239dadddec8e50f02515f509ea70da3f40a16106d410d1c469fe14b7d0ac86e67d337343520d02a599e39ef61227086e0f91b59331c595d7b741d3c0ab9819f3a2c17fc13cc4d8ebed753a0cb8b3936f443f1548487a30f63fc6f9da73640d028103ce80e592d17cec5a461403b6aad1fde7acac54f51cf116a5694161e1a1c60dba431b24432af37a4209415e944f041498e1034756b3dfed8b7e719927850f8c7f853a98132b58c4eb872bce6ea92e51e66330459cbc1a9acfe8e6308e57fcb9a9cf42a7482effc1f31ff221f4a49781550507804274ebaa976cf637b6e6e7ed8b2932e36c2aa596ccd58b0c5f46f0a64ba2b80c440efb3cce7c4bf0da63a5fb4d6f65ce8c4f146d6c1e11eba51d3277f832ed1054d3f4ae7f9cdfb040ab5bbbe7ad33971366099205dc553d76027122e9c9dda0f57a8f15c8f262982b57b88d3dbf54d0e66d5ba7785baa5f492c9fe1d83b2c308584e8852fcd06a671c6cb7e539e31782ca460c4d07ef91c39a60de3dbc0be3bcaf291bc09da94490f741b7835669d210dcbfea6ede079c4d0d12fac7c94b475b70bda2e74bb657a32ee6ba86a0d172add3fe70542e005be876457269df67e12ef00181ef9e0cd9ae399ee1788d9da4e2f6b0a040d5b7c7a6a187da65647843f33a8ef03544c3f7a71f2a21a77c087e9f3525bd42751b31e81ff52538cd7eaa3990e50f2c5144ac2e7c3a42802933bf53007ce03e0f6112f15cfe578184b7ad6e250ccf73fcad2c10a688fb5c68ef02f52d74d9097c44642e242f738fd066a19133ea8a4e784a9d88e81132ccabff9ce12ecefc4b45fcf3f5ce8af0e75eb018207179b1570b2a8a6f4209e766b21e07ab508fbaa7dd7dcb69b89522a54363ad13f2b835052004a723e4f7296950609ac23434b90924697ab59ab0d3bbcb8be80cd536cda35ba5f333ca986268587a0decf9abd89f88744e36b761293a85c3493bfe9d73486c0378705d271aafea910b9288bb115d177e670b015d6516d251c55c4227be2f7f882ada5434f91e135b8cf4440895eb8066fdd5dca17495332f0a6501028d4abf10c8a2145ad610222b6469f7690cc015e6529edc23059d750f1980a5ee2c934af10762c0a5cd9b4668f090d29b3cf888bef509477b04104282e8fbc61ee0469d81f0a843e58c6cc744bc5b0600635217c9331d682b272ac4297d08b73b27681ad138c4bb8fd286d8aa960abb73e03c107744decfa2277ebb2ecfb642a2f8b51e039ccac0a924dba862ed59b0f384411aeb9922dbb2ea00f2ac6e96ec991a5d881cc2579fad532ab85eba84f3ff346137ed58fb71f2d9aa33519bbfca87cddac847d13924f6dbcce08a90edd51c73a00080f4148d278c0d8df929c806c3c437310b5f9ae7b7a3578e1255a00ffa21e6d838b02f470687f470287a108f54e0aad39403743e2e6fe9c9777b65238a588500b6a16ec890459ef686f374bb4b8e4c56ccb1e99ad9419f881f61874005121ede2bcc3ef26f6751667360cf7c2dec6be4347a0d1e845f5f07fcd7909d6af988a71a2e067ae46154a26dad0557dabe83ab363adf793df3c79ac2b09f36af30ef79597ab8f906d5f7a1490e5239270c422980bad6c88ea0f09a34db9be8f5f0806082c20f9d507917e87b9fdbd93599ed7b32187b9cf3c512997375ef4d6dbfde11d8273c627b53af5097a0c592462e6f49b107a366f73c37065e6bc1fe3633c2153335d88dface5168dbb8a870a0b729dfe356eece5259d30593cf9f25dc11dea78f42dc74bf9c4497d38ef4630582f9e999b60eeac3ece188c12a7a22fcea925a8e5029e758ec1fb78224f8416e1b934e2e952751b65b4b2471081c677855c4b76226fdb91a9c33e912cc8f2305ba158ff764195ea97a65bf3169fc0ae993171ea85744e0b00fcd6b2395ca4e804880c8c8c2419e271790d7655336b977310e6d777517e02e8dc041138fa27538fe6a0624a09abe6c14a194eebde2762314bed5ed9684305e8f0e33627a17a8af2ae141a0687014e40f0bc598d12c6fb8c41c58f57344ed32aa8c09c71fc00419118c4c95ea2acbf30f96976995fd91c975a45ab3cfbce16209df1ec2fdf27f09b98daa8671ea055e8ff712d57f57c7bf5c601bd592d1bda2d49fc3258aa6aab6ba350747e041d84af59863e9de04acec21304511d42dc4fab07f63803468878c54675abfb6f0146d313f963316351f605ffc70761ff6aff42d9ea8e44c04465845a2404bd905b5e47f9fd812093a8536b28aa5ab191a95b7bcdfe26c0a17a7565c9bd58ee2ce4178e13a24eb6da0565dfa1c0eb7473441874cae22c214bb3df67e0bdc9074fb27e6266d4b4779f2c4763eb473d2e7e6ad7b0e458beb6ad1cf6966e8f7c46151289f0a4f1cbf2964de104f0956131ded3d37baa136818baae27a0c0fa39439f82c1bccd1490ac27e84b17e134eea87f790707e10805c839b4f338c43a305663c68a9fbad482f1a956ebe9cd215627e9b4d496de14fe28f2b9719a46132bb479c8078572d94ad97887ebcd3ad4b56a148df47c254ed66431d3058c1d3154a9afc95b908404fb2360a283d58c9f1d71c13175892c853b8b613d5521a281583592d1fdbb4ffac5c50cb6ae877ab9fa718a7b59ccf9b3f7081f4e8ae3b967aeb05745c9bef889c55b767d8920c72191285fa76df7a1fa0b82c7c414d2acdd2871ce3a4faaa009bc3a7e7aaa750cf4610f178970bd637504e51bd272f8df490f85d0c52ee8efaf43b39abc53052864d0cad5ffc2e71697ec3a62cd61132a85b6505c00d478057eb52d5c298b849a5c80056512132cec6684f38ecbb90848bc7bc875544739bcac3692455849ac7eb736d713de4393e76d73fc6b336d9604df817ec8f2c7673ed8213c3355e8b33b00e88776c1f70866a625ae7a2b1aae1d1985f33d95fbed8922a81655b127d9295a0e83b58b279b0a8809bfcdecd89cfef3ca514767867cdda31f191bfe8719e8b60ef0c6e77957e79229223a35bc0c60c452fe85a84275b245f70acd4de2ec65a79a5dfbaa3cb24626c495a2a9698a38df53de54486b0a26e8792f4a320d68a7d038feda65a8afac76da61ad441393b479bc2d7c005612829a680b028e71e99445565f6733d36601df9818dcc5c31cbba46b1047cdaa74f26233a77879f90a369d7015e03dafe9d4f412beaf29e46127260fece60489d0f6162552e2072dca16f908e862958ec871fd05d33b1b843154e3e82b522d43870831f81adad8049a4bd50a5f578d36e55f538dcb9be1eebc7a654668316ecab546ed200dec8203d09dda92a4a981b571ddcf05cedeedccfe487fc62e0fe8e609d02b7f3f5a427a90d2d5024815fb56706fc6c9712a8fc9bbca5520efabd90957415ba27451f846a33fa9c8b99dfc97ebc01bc6edbeceba0be2409c4a2c16ccc91e6038c2bc57a89cbc3b2de4bc7d3b9addcf7a0020eebc2808cc99b2cf09e396c810c175bc80e31ae41672ec01e1077725796e7f456720f3f1f3053b142a7a9be3cecb53a5bfbdbc8889a8459c61cdecd6d6726985cfd2b3244c2bc997305e316e160adb7f226f5daeb3928f44d979c7698b7ded17d5ed1e1df2b6ec6b96cb31c0ed6b68374d6a5bee167c18ee214a2dbfeff819fcadc1bcef4144eb6c96140ea9190c267912d37f75620a461ea6b8d4bfad3df641b4efca8cdd3e2062e2a124c28f172cdf3810e84fa65be4d4fd6dced2b1a1b5026997e6dbf6adaef7b30da7971485975beb2b1083c3f32092ceee952d8d86baaae27bc5d0f1e99d1232d22e37b176196043d32483af6c2e6b695081c5b570e20354838025fb1c4735ad4a6d16ccb9bdef437ef64c395abf03501cca98f9c665ee27723ae565db163e69d088e533f5d35248d197fe1baa1ab1c4a6b689c326b1f5419fbb7e35af1cc0592e2cb636555a1a71bc2f865b164efd64d1d073865379b600d778f2f2d3cfa72d60cfdec0596dab5a3d3282988f01297c3d2b35b50d426621c259b07d2cef45f8d51d33add20dd1d8b76d424a5467ac018a9919e7d24af96344231469a4a8511da339c6e16977383150ee1dffbd380de4b88e6d6e11c2dff3e40984897fd570ad216daab1069f6b2c2bd677375452d028103a874855d4a61b97b8e34697abdc703bf22d5257b6dc8b819920276a117c225101d4c41419c550cf335f2fb17e145abc0a726ff91268ee0374b30e954bf122e0e298652b5b25f54a045e6d1ad16272ba1a2b2678113aaa15e254101bc42213358d49c82de6936ef2c6b7abc30bd8e842ad59dd087fd3ca36125c9512ffc09dac9ae61cf77c1199d8ea82e8408a9947c79d3fb713063a933562f1bddc815306e5ac2506d68cd96e8f104b4d4932cb3cbeb653ae9f3ff3463d03d7e4a3af559d91d73892e5d4ec3ee5ebadabb1f3f14d2819da5f6a488235872e6a0a2ed39fa1f19f8625f50223cb9a3c336ac5f65d19a5d77cc9aeb0c3e68fb385bb09f785176826215fdc7592270c8e7145c27163552402e26a246258c8b91f40cfd967e256315867346710f6461f533a142fe7741b7d3e00cbb0505b3311c97e42e58bf0cfe47bf45ca69325fbc24b560f827cda2aff34be2c3354b9761102d94c7e0852e733ba6dda321b5dd12db97bfe629f187b927a00512dd9dda8640b9dc10d8d6729ecbc2c1f8995c387","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
