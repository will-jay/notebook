<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"239d6af5ba2699e537ab979ad6af38fbd32b6a892025f1e5c107c863187fa375d9c53101d7f86921b21f7c57de414e86a053a751ddccb629d5c7bd3b4ec9098c5ddced15c5fb0e1922c0b4384d85e7ad1444c1d76565ab6bfeb16bf90075acdb67f41ed17c781c4dca017dab0e3a8560327adf43ad1864ca5291a955edf4b3228aa7c37f58dcfc39775582d44e2f57db56211c4aa700d28c76d43b9fa58387935aeb37e7d7308a6de8a3adb154cb899b2d7d38a3b10925022e982ed272c4baeb0d9868338f95a66104aff0fde1eea6fea462306c6b191761fb4bc6dcf07ffb4a3654f8a2018d5acaee2b9b1fe3009fa3abe87b663c84389836731625a64e557fc4d5b81cabb12618bfd5c9c4ae51c63e2392a5ce8f04843a01d6f04286df41a5926f26364363d4eba6247daee0d1b7e1e92c970ae471312ff705cb4d7c336b31a4683e4299b5cdc0e194b66e53e129d89224fae7647a0feea0d516ccfd608af2039891008c804fb191f8bad40959d5b491311d3a2e1447826d470a78727e5ecfbb9e3b104d21c944983ca86a68b8287006d3afc92b6d78ca3055ae6e9bf11166845d0b2c0ae8df718716c7b13b4d7bb5634a585f665ec00a6847f7b38825769413242a768088d85c34f3aa9157e7622fdc53c78fddd6fee20c9dda406998f2b02d0b8c813c995ec940b8eb19f7e9e27171806622c82bf0e6b0ecd842014f80c83005428f8c30539f311e7552112143ec3b00d6bffa7ab57d0fa1cb0173dd891dbf40e6a3013b940c1bf0408d6d81f8391ff78bee387a13339fd539322880ab4ba5a89b5b061684a0e48a40838eeb9050f52239fa54712d11ee5c824963e51c6707074dee751bfb9982e0e00f6023fec8a4954a22e3e402d840c2a2ad8b6e4c693103484069c8af59a57e918da5f16517cd758fa4b217c9361808e57796df5981570ec18135500b8feffcb82d523ddc1b9b06bc2ccb71cbce509a41c6d6cb543724aff356bab929c63d24a91bc48e14bae144e54b2d98b2e1084513e7d934c8f0660bdfd1412426358a5f966f0b8f3dab938c3707b583d4dfcd7884a6631ee16b12b6639251df5d1671fc678d7e5e01904878c9c7346f952f4b486b1126319297851c9e881b10d68f9e21c16cd9f9f959fec31bd5eb91b1e8b24c0b1981d3460f955f79224c520080d7effc86b8a7e385df227965177fbb4bf697844314b7b137a7d7dcc6ba06c58829eb03972ab8955fef034ac177ee0c07e15e03b200c82e4ff285264802a1d21b5cb6e5e2cfc08913afc770dcab1d332e8a2df9603156863c7fb3c343a312ff797a919ff5c13de5fc162f66ccee2fb386d836676bcea01f7d31d932e1d56c5be70a17976443840b59be559084630230ea5f9a3f32cc6b8f6edcf0d4a63d074320a921576b59e98968bd575ad37da8d37a59f4ee8f8989a9455f068a562c84de9a8c0d227b53638fce7ba0f751d14eaa1a164403d47ba8735e5c4982a562f7d6811126607c981e04c9080e3fe46b2bd6158fd07d6ee3e15283888ca1cc6402301eab7d25c640b5b0cbebd39000b12da0d8b2190e7df9fe7f5750ff5e5b4734be65ee80100dd91b8f888b5cc776abedce29f604b4e86fb7008922e30e0baebc8570c3068671a02852145495adb95455b9f993a9fe99132450481dc9be84a758ab0e7b125b736cfa21ec54497468f57b3e55c4305d439050a54ccf4f6d635856e2b201d7275eddf583e5eb2cf9a729db1bf03269279ec26c3d47b96f299734e1541c168f4763a20b4f02ba4ce92ecfe777083cb937b12bedbfe49b9d86b798cbab52fd0fdf4020d94e3282b55f9dd3de920c72d805f3852ba303fd6b94423193da45679746dbbddac1aa62178148c2511bc41e83a12fc5ce10f05d1168d356fd8c6f15bf77a6b0ec02f9b5b7a58abbf74caacac37cf3032d2d5134ac6034652fb8df8e43e47f80d14486d09be5a48e7e23b91da67e8989c92c265ec2d8460c610937907dea35f3872bfda604278eab17cac5ab9460d0c13549c83b270e46e9ddfa49018da70ddfe43d040f7426bb6190a643f5052aaf5afb3a75f16c6bc989c02f9c704569ef6e0a229788859a8ac620d658651597d8b29c360ff2856b2ed4967e3f9ca406b35542bb27bbf252d688f8f32c1a6e30eec465f90674ba4c2b5cf89b1e628e9af1068a5f23c0f7ebf44ce13dae591eceeca65d02ec0f153f77f9426d41aa574fa40dabae63aa7af35a61edfe695fafb73482c8f5aeca60e0f89350bd17d8d70fed7654763cca836e0aac455c55cee6def33ecc560067fcb4d39016ef2d85674786614919089803af9872f9f6268763e995db7852b6ba5f4059e9e1591edf4eeecfe57c99725af313c713aaa11be075c1e22379c246b6b35ba5e98845e51f4e14e308ef0c5cc5be1db4b60829c36ff64fdb5d14bb5c337ad19a8c487fbc37b59045c3ea365a3f49b91b617d7a0b7d24ccb2f99092008576f03e4c1037dff7ad7e4240a6edea5b940873cb5c239f1e598ec2d0fc878fb6337618261d8378becbd145d032b0079836aaeef9dc10f1a0505a243293fe81aefccd334bbad59ba142980a5761c3373f76ec5b4d014fe7dee7b49904ebf70e38f4b6c8cb358d61788b8703fe5ede22d7746a0d4aa73cc9b2a7240e1b7876b0799763839db4074b589dc26dcab8defc07d5aea72d8ffa4ccde5668886cb91e2f814deaab5a49b81a7a4fffae7416572b44b5b501b850cc1e418024540285b9ecd8923b8b755bd429806178d2f31d1a5f4a31a1affd8bacd96a8134b8cca4b30835070a197bcda4ff58c96537a30664006dee6cc129bf4f9299559d33d0e040ce9a39e9bcb7ecae5ab716e4a45b213630890750c7a85526df3fe2d19420265b630b4ef0defca29c3eb9fabda1cacbbbedbbcbf850d306fd738ab654b2117a898406b3c511133c767abfb8866a0ce7454db543e2441eebbcc3f5ec400d621453796ca318f836ba6b01a450b64311f70af7a454fc89c2e033272e2f3491cfbad8a0cf456981b0220027c5f37be79ed979dd892b1821bb109980acd81e98ee946ceee7d0ec1c685b72e606fe9f607084937ab6b805232ca9f669d2e09ae4802b2982ed360079f9ef441b53fb7378d567ead375a52f883865bf5813bb0d549faa549efe4a3945f25cbc0577ed545b31fd0ae18ea624594887c57ee664395c08c1939051fcc95f16b03cc861dfe596e0bc88cf1a5d9115ec384b62fb87d11a86eef492f978f77ea39cdc98a6de08d594d114c55935e830a2fc6806b36ea9576450c1b3ab6305b35f41ec98f04b5223e752e383c8da39d70837c84d526f8e28b32117efc6369af0de5b5cf3aa154bd85b3a880b803844aac80f8c08c49a8ea0cc53d7a6bb476c78c243878953000118a3714828cec352f75615c8f4b1324dba82680e4b0b1fc290f4e6e22705ee83634d91173d5b7707a5ca09286dcd32746824b972bdb1fc0545a58144f7fa83991153a8fbd368088cb7b7a11b670c758ebc90a83b8228346387bf9558e69ace8ab379a0b60051ce93fe79d8420975930053ab9228813d513c458634e559967613e6915172dfa180c994e2f8201694e529ed7218170dfbedb51fd5eaf83a4fd24dce1189a06000da598a25abbd3ccbfa274e2547cfe46fc845e8b6b06df3934894ad96c2a250836a34793a60c624836f5a3dc0aaedcba8eef96504b665c30399892af79fa6736a528473e3802ac04b51439099a16975f31e353bb1df806a27328f0f1384c82f829a4fa8b5620b08a89a5426ebc93e4efdb13caa44515435ab5456460ad992662aacb2e61ac8de79d7962def381c647f56730fe0359feb50b20842a76d7b02987fe863af2f9ffc432f3b3dc6445e41966079ae6495cd2eb93e41b1fff2375c8f9d2635782ab1917cb1b9a2e1e68d7cd6e75e3c03b0fa7be6eeac24aa9b7650f1e9b9702d3d3b1a99a961d618a05f3923478c63c4fa6a1b518d7acb96aae512e697f7a840a0bdbc61fe3c12b3b4604aa2fa8e3c9532b5894a9ebf39ced5694517f5e882e527e96dae5e523f1cd635f38742fd8db924ffe0298d34d978f4eaf2c690c83bbab2aa7b759cfc57bd2319e8e0fdb663c974aead42d6ea72365a66412a60c45df13caf09967ca847ec99aa0bc6be26dccccba74ecd71f7c43ba3f2e107f835f495debdd12526fb094cc8981e9a5b7cf3aa3d9145a455a1eabe1964f991303ac19ba1931731937d5e8170dc43e042cd5a8cd3e22985267f9826e553f60eb468e313a21feca046ccc0b3256572cdc155e0b5223da8aa480b64361f4c19a046b3ab54cc41cdb80e6af607dd0bf9d481db6a4b088bc30377370c71c290de1b7ed465f3b14d01af5520b6e93b11fbed25a4ec997d004fa7d254e8a55c0fda5f59829c7b8be8b7ee398ca9bee2cbd703584659d07953e0b0217e4aa100c216c3ecab9f83da276807dbc277bedcbe74f707d4f57a2044b6b191441d08053905f4e18cfb3cf6318b7478212e812d14c005357ca14d66e7b0e18ae3230bf6a6126cd51be90b4698868458a8d6d75998012ccefa3ab0d1f4e9e8d6238cde81e4e516bfd5d49747b56102cd9c5add63e17b6a8b76f8c263c2beecf279184e8408b1e14008bbe0adf7cb54ceee1430f5c66a1ea259544974988613b164fc22f2db91021e02fcf97f305dac37103283ae3968883f8f9ba3facfa68d69d32900831782cde131dea08c2b569914699341f7b6c1253926a3ac16246a650f6d32b089524d62c488f1b1d44c8f862b42d3e4274c4a694d2abab47252c3c4c89691b391947a242a6b90aeadb7048e9e0d5598544867d40bbc019b5d36ab33fe2e9b1779064d04e18f79665b33ded3960fbb35ad25739c291efef7bdd7500acd30587d5cf36b6c20fa8f48648019f89d575cf9b3865400dbf2db008ef14e0ce9a5e58718ff19741c6a3485f43b63489fbf1c68a10cd756c5fd37f9cb96ff94b156768b9788952cd9b4c1e0dc08d3a6638b77bbfea00275eba6ae2e3cb460f977327bbf228a102d104ebe629eae3730afd51f9d036a3011767f70701e8226530ef31738f745d3b8f7117eae7a0ca504d341dfa6507e16b0d31f0ec6e7e3d7c1fe4d1611487166d8c0296e55ef9298c07225064c7d40c0b3d9246b2a6f6cc68dd08930c1022f819da7836825158ed0e32778434eff874e2f0385271d9a0d23afbc4c4c825ca9113543d0c6b8599d80f3a3d0e2d59d9eafe7e50c570be779eca6211473aec9e973115cfb27850f08bb60ef8d1c67ccefefa27a8789d43c03232d6fc5cd4ef6ccd66cdcb5ef126c8eb7291990ea3fd4a95b2919fab67e8b3a46803270db4daed075548c1847f3a249975163f95be5021fb644526c5a0fb2cbdc86745057835441bb6e78f7f843daf821784724f033a46b3aebd5fbefb86cf41f6333c17f0493bf50eb7501f3418d2eed93601febed2a23811d713ba361a2f33cbb46facf0eb91cd508fcb82d90fbc292cb5762d09bc681cc88d0e0ff6cfc31a4dbf5f72a56b961ad66851264217f88d83617d917b9bc0defb93e8d115cf629a8142b6115a87b1df0ad12fb350e2a0b401f75da7c552a828ef04b984e5da7ecf9152eb1c6cf64a04969eae4ec91e6a30a55ce9c38223c615ca644a746b36da9efb248ae99bccb16a9d6f05e69d5ee0a8065d4485b95622f63c432010452d900c0da9f01884b682e2aae8228cad7641bcc2a4f340180251948f792a8874eca7f37a0f2eee5cec939990d708ad718b6ecbf74dd8e912c85138c07305ac9bc12753874a0136ca0654f8d5a27a011d687e733d237d1727a30725086a4b2c35f564f00152bf15953fc313039cb55789401a2e5bea93d29bc38e0750967d36018f022eed5a75917a52b9e33b3de9b05eba873c62f45bac5191c794942bbbcb3aaf4ba25bd1499c5348e168f9e2e58e3db34df00e38f3a92e849463aeb2d6dc2fdad243b9b4a3f964e9063c2520885b967ef18569da4b333d1d1e1abb5594fc0344b67f137609bb40fb21c444ca960d697be56c0a1b55f875bf7bc96b82795bab2c11c3205e1903c4191bafc21afa4f92a35efde2160e3de9ad9972010ac7872f7ab9c1936139280f7dc81d684f3bd4e9b844e96480747316b278849d09b5ff6031de1a5535766cf61818066929866574ab39eeac2f397b478f0bf4ac0be1a789047e519ec180818725f17b32cd5043055f0a43d3f4f264926d05291bcaa0ee68104b5000bb6fbfd3da08f8f034fdb42a10a4c97cfbe066b35cba6ba9785358cf5eae05541fbac17adc8cf00bfe29c159c1cb9a42e261c7c569eb791111a919e6ef29dcb5a21520f94ac8b8d72607cdf2d2eb9efd1d77edf6f3019e745af347624b124afc40eae54ad3c2e164f4dc2b503a5228bb3eb039a327a5193cd9f1f085f8186683789707a61531f4f75d1fc84e2b7282ce6eb4263a58e0d9c6c38500688d7e6bcd901ac6b88b2db18fd953c9501d8020588cb97f58c051410e001afbd7bdf9f653e15b271c135a69984f21aaa64a8d70172005b0e5fbcf51d6cc167a9fa63d3c533643ff3093df42953c6815b55be19d261db3479e91dc185a59e59cbc2c3c7ef073064d9e424524595dff56f6438fefd0f5173b47b33d0b01332845026c0fbea5da2bde9ceef95aab8f5d8a830ce42d5e64a9f526480dfdc694d03a13f726a30375c21bb093e4b83a0c351784a666c3b4b1f5fdfbbde825b3ef34f165b859acbe46d6cbed7b40df19a4e1070d15ac143f58637950783a63f66d6284344c785c1a6fa7328cb67e779ad689740a7362d4ccc2c7815f14b6b2d66b57a27b1d59eb623c8bea1bfde7477285a3fcaba329c7cf1c32f80325461d7ec6223d09d228684dcd469ddb485250c51819b442602104ce7f3ba6d81342ac2f19fbcb3b003090933b42a949233953c63c26c72ce28122312766b94f5595e50053e448de991cabc71fec470314684df049d81df14d70d6f463814603844409061959fa6d3e127b297ff3f89e89e4277c81bd67f8cfa74063a65290f9511073576c46be57b0d927f0ce8a92ab4f54ba7ca92bfbce604ac3e20c5735834b336434288a6b5d167ffd4b8b15eff4ac724b9d114251b4bae09fe0b6f4e88685b8184df586dc1f0bd1ba278ab081eb6ded3d809bd76ee5ab0e8f812ab03b7f0c59b5616fea1031ad4aaec03b5aec69fcfc851f5887120e4c6a2168f379e30d39c711207a9f0358887d22dcdd5abd8e3d0e246d95509f302721f1c2942830201b59b703e11bbd5f5cc89958eecc31f72b3858b239e0bad02931ea09022d9afc25476ab400b1657ea535ea8ebd463c8fd80500f67a40953511c527a9c53556efb277af3259b052f729e71697a08f6f3946618de6fdcf87b4b7952854e92de147566668099f7ab7bfe85b489cb52c5279e96a1ed6cff59555321397dddaa08c696b593d239687dc71670caa0608fcb5f40d0689847103dfef32d6ffea319d31d2b2f7afd58c224614aedfee959e1233029c56e28d98962c8b9c1353d2d3bafa68df71b7181a4c0ecf9e554557950a69aaa34810dd6aecbe2ccf8edcd872f750b6358e9c4e09c96eff6745939c838b4d7e16dc2629d987613e12d4fbf5cae0679abb8dc289039342f8664df3f916a1a26e4a5af13fc61fda5448ad34861d025d56253a1d609078f9b1443dcda7616c75b1cafa8a6c5d10e8ea04ea5ae3cf90a072bde9f82154f97e54047d9387bfff540aae02a19ac4dc89afe853bee72d31578b06159e4a7f37d71162bc54f70d72bf24fdbb957a369438c4781c28fe1a4e64b50a2be46d4152a9127f3cb9e597fa8bb5074272edb34665ec1a85c5fbbb2071200462037477d2d8b707ec1f26c829b867279158de57f34b8865ece123cd485a8f0b07327644263cef76d626dd57f9479f0d97a893d33090524f7a11ed2ea5e73296cee1c085813c02b12c7aadcd2aeaa5a47f6a08055d7fe06b98926d467ca1651ac7b1ca81f89e29d214491e0bedb531a5c879d89633523451f19e9e87aaece894b6981efc9b3a3f4d2c1c57f8a29b614ca23cdab31cbe43ca458eaf9e596285d7c963e6a77c2db8031c38e152593cdb4fcac483200438e0f55badd9f9a31089d411734283e86d496d346d5b61051435565cc00d3c80235daf3adb98d75059d3455a14b7d6940154229a2632161b425b9f93f38ecc9ee06d691dfce56a6d98f366ff07dcd782ca6a4a674d9c6ef29c9ed769ddcbea682fc28d31afd8c5bc9576df97ccfefa9c2155a1fc1cefb6c07f50d9b399e9cc3df163ba605bb4ba9fa8a8f643102618234cabb0d62b8324bad9602014fb27208096db6bd3f7e8c4d5824c0191d6c77a7edaea1ce11bee7708ae36419299704e73523c60bc2faa1e3f1fdde32ba1079ea9e6b470c028352aa8af51db1e70b694ed75fa8ba742484986d793272c7f591ae9cad4e18e7f67f4e6a69c12356ac04c9bf744af080cfad31d06dca02ffc87f1865d25785d8e12555f809479f082336bc00d8b90cffaa83cb1a7319b4345310129602d009f1d29c218482b34549f665a2a978575f373799663f2c142fb7429bcefcf16f042fa1ccdfaada8ba6fe92c2bb1765af80074e20d4f88b1fa1787465cea7efe15ea83aeef7b4478f8119e8c66669f35e17730c4e68a004a9926ef700ea783638e46ae292889732fbc45ff5cc3225e08796f897125be2922a2d868a92ca2000e0218fe3e191057c34dc5651a427e5fe662f11e60dc5349a3295d676cc987bb0d7ddde6a60536c35d8bf8f0afec9a431781b85e1a27662d72bbbda21c32829246187d7bc24b364c6382552c0bf36b90614672d440453b32f59c9db0f987b1d8d0084f4268a7fedc57b5b9d9fe260aee1dea035a4cde0e38bd3ba2523f785f1d1403247aeef770ab6516a56daaafcf81e9bec6193570b3895c6386bc44042d38ef84d45c51977bd8aa6c13f19242c1c4294a83e2d7b27b8ee82a0db0907cc046baa6498932a3ba8a63fd28c265dd3f4fc4594a2b5675abed8177fdc4f3ec5db6ffe4bfda72e887b7cb71b58c371cf5806798a1c0a8ebd1480ef81614a64542aaf65ca9732bfc257bc7f7241d0a85d4c7540c54df0523fdd4a6bc851d93f5a10ce0262b499f44ae8517394656ae9a8dc28f4c1c8500d430dacb9ce38a61662567146ae960cbb1193a636dfb06577918d2116f8413a97ae8615a00a83a1c0942da61e17c143dfea107ee6a65b8e8bee32307c47bf1d902e98b27e20649b24bf5e11201309fc209985a910550bfd9f6a6bc05099094d35d193fb6c2a8df0d585efa8243f64095a571a044cb116fb9019c5d2591ab13cf51ee769b6864bc30cfdbe613c3e15277c42363276e1fd39dfb9fe209ec097f804d8b58893a18bd5f0988ed27d28937999079b2177b776cb2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
