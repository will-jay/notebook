<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0d0d6cd9d9dc4c1e6a549b5d1416304950aa5bd53ee0ef2639b7c3e2a849a5f409886753af732b23a9fda911d1abf7c71794747882ae61266369f8e25d34613feebb548bfd066867763915aa387e86622a5a30f356c5efd2b1a131d690f1f7ad090a2fd836d5f94afb13d8b6f736a2f3ca5e04924e66176a528458ceb2d0a8def626390edf804f37462704a1dd134987e850e730158dda28a861cce059169b497882c918a5bd501758d2d0707a345afd3bb019c81a3bed28659b0eb5def631128c4c2d18eac2f17de7a05a0bf034e19c6d0ba6f0165dd08a402f121a9e23364171ce7079b29653db92c5c89eab0cb001fb26f4e5386385b791995499f05d2831ce4deb80b40c2e52bdb9027076c4585dd2dcff25c2492f494290ddab0e92b62cc0c217dbe5653ba26a67d631d87b4b68efe7a4db9ef68cec7af5b7847a0a3df0ba64065acad226f85b897a22465fc24ce3230ef080346f539d1b8e70d063a76de0a2ab10879a38ff14b16c962bd436ae2ff4f2ee61f13c2f54402e1c4e95912c922060529d85a2c69cf15867b82c96859cbbb1cde40641a5d55085799e6582dc13273c3e139d47e2d396f5591a95f5dbcdf651fe37b8caaa3f947fea2b65b8c0a8b14104d041c22cbcb610e3846f343d6ab5590913005adad72a06625228bb002fa82d0b5183c0476a4beced4a312f38f9a0b3ebdf5c231007ef6189b8cf51731d245086daabaf59d09248fcc36a2e9ea6c18097e0ca7f9db89599787139a1e8cdd065f902dd1dea191f209e6b7fce6583132437ad012f1a3646d2722465090d62f13af5fda5a81631d24f646f6e4b8175fd0ca2b2c4fddcde553f6e7d42802027c75b4a5eb9e10f017b6504dd43055fa1aeb0854950026bb75cbf358e28b614b450bbe5ef50987a34cd05dc487a6819653e3d0031ac3f1cb080e593b41983a1e14ba8cd1422366de86983225fa0a7aad4fdf11d57aede00128bebc399e49f09a6eefb4bbe0ba699e3b7aab781f10e36791db97f9cb0455cd00cb7c6a8ba0f20fc1250ec913d045cbd12e2fe4f512b495bab2b28df4e4d5d5498a4808d5dbe0ba0c800ae488947604485892ee30f80d159b1485f8f0cb28e1702bc6e3f83486852267075f87b9d508e714ee29b9d0874ac2d2a44a4f0ce4d2097c7d5a2d63256edf584f5eca758740493fd12e8be3b4ab1196df668e2ffa173bb0dee756336a54137e3bce9dd8db8ab332a87c1276c063f4c96de1d23c33039803afa2ee2fd84b03970401476d409c940e545d854aa343a0e67f41df369875fb2224ee53548be579c0bbb6b6d44e8b80de50b7ee4dcb30400d6b8cd8d8793cf7a02647db2c07019a71ef692e626bb390413907791ddb73c7debfb170704a4fde4d6ee34a69a47d4880bdeb4e0b0b51dd15b01f1fa4f1ceccb9c76f3fb2b05a0d8f64d8a4371c07fe7bf0b3c4ff296facf38b705ffdf8ac1e6d0cc8039be4eabd9877d547504205136219f0a1e0f77d6da025e4853ec5049a2feeca778d0352066908dcd3de997324a726e8a5d1c08962a54b672a17cd9ddb17fbe0595cce2c69151ce8ead948329e655c09373168715bc2f6ef7cba02a8cc941007ea43d14240875c2903de73ae9edb000a84664c197699e4259a69f6622e9d531d1ca994957cce7ca381eab6acadd803f7ef7bb03dc1a1c718b8d484162904f868b453d5a74c0a6299baa9dfc89c4856d616f5d8526621ebf23105647e34fee1ac7ae5a0300e0f26ff7ef9ff12fdfab37cc1dc8dacf0dfd02d75b66a1f0705ebfba85530544c84d7dd65609599a24b0056630729bad767d5f18dd948e0841c5030c246d4bbab28d6cb9742e4ba4e5117b0368f6b7c5f742fabb0eca1fca0760b755974aa3997b2c9428879acd413829c5be105a0af7e8ff94141fd6dd5614032aeee115f685ebaf859ec168ef075d3c6e7eb25aca8e6c154ddb30ea2b7b6e2d228ed89797cde8aa5226d062e9dbdaa9d9f89c10e99aa835fe2db94bbfa02aafa475a0eef5b4696885c309bfc1ba1bbb7dea077427bcc1edd740f19f221b9cd60d1382b4fc04982f0addba3bb496e265d9ed4891d71bb41e1a328cc31451c1047f7f8a0043b76be12b81f3ac5f4947470aca2229ab794c76659b7a8ff3901df5f24d331bd3478b2b0e557fe7370df7cee4d2978892158d1385504c188150d27bd6ef2751734399fbe87e8f2607a7540427e681bf29e4dee2a95919383cf1160e7e1bf1071037b7a2bd671e62195018f97d14740a4d61e731531d5250cb981c5a136c0add5bcddfc8a3ea5fd70271f1188e815a5f032f2d90808fad7708de0d5d6652445be98694cde7a2d1f8c649b19fcfd233dd137444d7639f95186399fd52f3e5bf534758a260afdf8b63feb7a71c74f08d14c13c795f183f1cc89a9d6768a9902f404a00efa69880cecccf7b35b406c06af454928472e93276cac2b04b72a0264c445ce87ce0255f0613bfb4df8099872acfc62c39609888e9c7bb3164746f56177bd139edb23142cb6ef8e2ed20026fa3f972d035c8a37cfb728780dba67a3e1bda0e712712fb0fe9dda9a653a948acdd81df39d0840a4703a868575c8f7b0d6b0e2bf06e07471cd4764572f0d2dd8f1a290de7c13c2e20a517fbb047e3d3c9fb00dc0833add9db36c5e61623440e1033e124c49915aa8bc97b5fb988b20e8fb12cbec01b4d2bb6e8bff26e6d64c7899b7e9d74f1c5dfdb95615eedfd0967263824d00f7bf1698093be660bf8acde4ad392e72a3e459a6e288f2d1c5105e9fced4a1aae9cc56132d3ada16bb728627694ae07e087a58f4b62461edd4dcc1c2e3cd319aa939d8dc7b9706919a8916fdef756cfb4529fdbb4bab9b9734cba7a1f69677240fad688dc3da8f3de72ba08f11c79cea06c401f2471d27fe63e7384d06d012ff64bcda1f942a05ff1062da09edd94ddd85eb034938c6fcde5e92bc3e945429c6bda06d906b6a5ecc60b04403b11162625bf099bcc82092850348ac8a4b021c6be79430236a3cec2f82acbba0d5b9033fd9b197d8efadec8bc038ff89efeb4c44217ba42702c510237f8c5d35abaf475c0f693819b1b4e6e56e1eb69e87604d3bb7bd49c63581eedd6fbc00a01e4dc5b4774ef195b93c9a41481a0c3d485a59f7357ae234ce1e51343df85bd64953f2357eabaa35066db6f44e561063f458bd121fe23675340a26678f3f7301f08a23bb527819f9feb680203b695c38279cd92760568ec2f014f9072cd4aa2fddd331813a79ef33a29962f8f92211f87fe1c5710879357eee7d8cd51bed36d9c3287efe76bc6324aa8ef70af6a60f082ecad9e4e929200bdda4a97eab55b967cc3492301bf0a0f5a2732121d933fedf38509948b8c07ee3c9466c369aa671757d5de4e1b3f0e19a30b003296c730698f67ad9cbd8e0795ed1f7293332aacc94f731ba41fca191d38d7cacf8886e5613d8e172b50bf38f9c6e8cbaff06c5b0974bca54ce4a97782010f008bfcae5701c4fb617fc98300b5e47d2753ebea126eb2f45f32dd2da55982472f26fbc13060804e31e1121f4029a1e62421b63dacb80d154110620d28091fbb3a08a8e03b1fc34c82999f85423577d4fd11376665c3e7429ab7766f42db565d237a877b58b3a29fef41113fc81b00c8e96e88bf46baf4bea3b67daa7f0757facfcf874745e60743241d3687074e6b308625e2058bdfe3ff91b9adefa9b72f5a262dc6afc9991f9a17993069294f060e25c502d335171deaae7bf6ceaf7b541d67d33789b445168091cb07e2b28e2339eb704d07bf779fc5029ce6373bc16a2c4d9d166479acb4d25488a677fd81ff32b24196a6e1a3f89eab8bc6860830c9ea0f28fc2e0742a61f4f40f5e6b46e8088b1362f3604ed29e0572c9edcb8700126b80d9fd378360949280753eaf37ffaec8f8fdb06e1ad159e8b6c61f599e7ccc031c9bf4e89a15d65f609a391ea2a5b75d8e63190b865cf012ee126fd7ea820255b5a8d979e80ec36c22fea654019a3691079c610dc2d68f673dcb4a54e5b724809df36110de61c082720f19da73d88f2754b926cae6b7d77145e624769c20eec87337e7a1f94bc1bd4ced2840b38953722ac86125a04948e378879391a84610447534bafb7e1c73adf3b06c2fef985825b4de42395ae17ea5933deff2f7f15e9f0cc8b4ed7de2445e34ac7918237f2c3279a47fe290e982587a7ef25adab3df0d595aa98f41ac507c5af6565a4204b832a085d02b5fab5400d3b6dd2b9dee43a5c19f0ed4989984ce2cb92668955f0daa01d71bd207716eae36e287166c8655f9cf5b5e14d7697a66b1039923df8cb66495ce1666dfd85b82149b9c80cbae71fd0c82200f3df3faa7ceaa22753b3743019493f6d566594674b823e09eea90865014a227c72abb3b7a15d0d7e748a7afbf66e0e64500c293aca739d2daf379a10b18a45542df652a7439a83c9b506d230d5df3d80a55b0208713da7763165d0ef90e89aeb7f9481980cadf7bb1c75e1fb9a3338d7b28a53b01e9d946943105f2ff51552074ee81e0a1adcdf561412c1c9a0083da44e5972a2753606fc0fcfe35db281b8b15ccc9e1436fa00696b57b0e8a5df0ca17f26bbe9975fe4c467c9892b8a14d636dba0cc7c48c689388ba75802e72dfe66f29eb9a0f804486a2788b1eae645fa35b4e6a59f7dd459875bda94e292dc3056b5cb58775facc757ac9f6ef170e35cd6d79596bd89dade73b89e60e55d7ead18c629a423ebabe7b3b271b02058d0234635b6b7447a66e73e8a38f6c8fabf54f4fc64aff83ff1d39873b3e03f3a4d0b275de1d7b99d186c50a85790f2e27d79faeae376ba111f9a3d9259fb22aa5bf7093fe63e60f815d2b20e9d86963a87aadea698cdd4da9f089903eecfffaf16f0207eb4bd77ef6e101bcfe11672c7d24285c43840d676e107ac7680d76835c5fdc800188afa9492e4d2b583850dcc75c0e80cf2ff8b9279cc7a07ec8ed5f8c9b78072026fa1e0c2bda210cfe5e13063816798290d073812f13bc1ce413ba39ed8588c14d443d9c02b0cf2f64c1dd7745193d9434b4f75d5234e0eeda5840b90e531602cacd04e0646f3e07bba59d0f91aed38b19c75ad0e23b5a30a3a8d42db5cbcf0adb73921f2fc21357898dfa501c8fe067bdebeb551be79796389ad87477264a92c8d706d1541e77583dbb556d2fc93bc53cec73bcf3f82cd5af68262bfacccb4ff3e59c381a7c3af65bbfb8767c5c40ed8abe19a9eb65acdcbf442c6c0d0f165b06f43530dc7015ac57e11720f47c1bc2b39c48a81d62c872414b3c18cdeecdde043b8c53288050c81354d5f5278d14f2c9a041210c135a4c5c3c3f001930009a603922481230c40d73e5f6829b057aee35fe7acf8f5c5c237813f791577017db273660726485797f3f92fd1579ede4cb873e135b54a49d28e51be33e56586e14f8b61f7fe33d0680e80ecf5e2578c5fed97cd177db7a2e3add29919c6eafae2f32903ce7c85fc411db3b51a3d0a6f649810c0a32b02f92b5944ae8fc3257ca4b198036bd3f52074cf8a1a06e851e5b781399765bcedc422c5ae3c382d9b450e5d15dc7a35b3eba5f7ddff1bbd1be6970a5daff3d745277873dcf9631776049bef6fbb2a8df63573bc4b78443e19cba145a91e91ecf75cdaa374609bff84bc21d4c6f312d1f40a711f799c1bce3d2ec0da67bd2074d91be1c22789ec3595f87b22e8d785ccfee9404a8c7e46d7a8dc515bc4c1ed7e59d725b89e89f71d7dc4163a63d9e824e54380de18c6849d8a1e42f6c3d301175d6d494cb2eeab2f809ea99c09a93a66158fe04af35599e641423e1968435ce40f315b7712b4137a03f24e14ef79932c6b93898f4c7deb4108aac590e0fb7756f9b812247f14a013361b409d23acb1c7b6427b8126625d3497efdfbbb9cc6f0075f6c9a9968933d54c97bd95829ecf65843656f7ca927c4cc0f864885152f1c414fff8b116c8144952fce28e4b8f79673c4b9958d888bab24b8ec9eb9f7a48b60912087707a3d4566b9a9e2bd59eada31bdc30c09a6e495049359e980701a1bd31dcc14b12ce99a1efe6225f0186717e698ba64c441b59d189ad6ee0e557323493f752bf6406312a96096ccd68f66f0808a0567a9a87d01ed305f3f3c9dbe36db6b4d580cab52e60e65725f4552424eee540b94bb810701e3b51b8963398f64868a72ecb925264a1cc99bd416ab36a722b4ad6330aff2e905f0429a9e0cb1f327d9514d45bd0fd6db6e736564a77be2978b717a383134eb19e4bd614879084a0cd2ca6f8f26473acb17be23a1a70959749c25dea470c31b1bf4fe49a3dc5ea1ff27d652bb4a221bf885db8d45c38639ec016064b020f15887ea109b43bd849410e035069d9fa0ef8dfbd83012c1c64c1ad23572f00734027326c89fcc8dbea8c4159848226616e6708a3b898bc0d827c9348f3e41286cbf12d552700555fffcaafdbb1357c54ad96eb891ce717c860117101e129502405e4352b22744308d611975813331cd13ba5864f90d957424941ad77baca40209ad5912eb087f92bf3c44f8f64396ada33d7d056839744f1b48dc488109a0b9a91c1343f11359607b0526a4983b4803713bdf028c087c84484d97e3c0ecccc002d1894f3f27ab4bd51509a2543cd767eff09b114b2a95e55b6c6dc8491449e125af0548de4a442de2c39979aa7f9a30d9b3ce2bdb8bd9e18a6fd2d05aa2d6c0f2b971f67dca3ef872397240686facff1de8d901d3da9a479a4fd28dfc64dda00e0c5ad9dd3f85da4d0757890897d7c1dd42af906659a5d76af9a7ee71dfe41846357a8efec75a9f1971c9cddd1036515e44fcd9a048917730370eb52d2cb72dd6aec12c0b852f93e7910c4e2daddbd85800b088aadb3c1ac4f2d4fc1081b365593b992e2526e83f4cb135501cac729f9f65172c3ebd66df3f02a452f5b8f0eeb3c03107c48f1c77387632b235942d509f9a45abd2b5fccd6bfc0c80ce5c2567c77cc3bac5e5e83bb97e41db4942abfb5037f99dc5ebd73890561e442ffb03a4d0ba86bf882ba571205217b0a2ad336104cd4e45716bf2ed7a9c2462e290c15f2461f7f705c9b6f8f596ec5a2ea62c80515641f416bd9ba2fc1afc28fff99147cd59fabe84ae3c3c4ceaf3b76ad9896ec9fdd82676468b78c1804d6de803f3ac548fcb22da31d182e074a91b974931197438bd15d95b52c81cef4b47b49535a7471c28f932655e3aee7f309699f7ecc5e4619e5b29e8f7a4536e66d6565ba81efdfe1399d8007d67042fb90e28b8250f6662ab774c82f4c8e37cbd24da92d9cf464cb9c6fc807ee3d502b22f317ccdaa83c2a72b1813b5c4df24bba4d72831377bef6eb05235f4d0bc8e1a08b08f9cf98ee155cbed797fcb9fcb7e67d84c45e3f9793be5f3fe9daa3e92145c3a1e229fbe7d7ef4aaa3fd7669a9edf3ed03f5fcc0a61f80172ccd1dee93c5c79c5897a757eb417976030418afcb58b2cf052d5d7b51d5a5bf125deb6d6e0bfa2eb5377d1f59bda3ebcd0a5b7e9029fb6b6856e8f6300bf61eb5e012a731df1bb5e5542f14de5ef6c4ad86b4b5c7101e84eccfaa0f84f661162247e7efbb3b98b2e1e36367700da64bb87ed6b80ab93ef55b7d91ab684612ba06a02698ada281a86fe79a3282c10abc7b046e4c1bedf49ae7691c716f8167a9a096aec9bfec266154919b5e8a0fa03b03cc2803a70bbd6364ba641985ef9fce38ead1c3a35aaf8e3f1ce0a4306e1d6131b91f1857956025dd17c9287140a4a0d62e77aa21bb561e0d66de639abbccc31f15db3c107400ae2941761f5afac82e5ba7e7afe854ac06f954c3a9af2de71293eab6d92624797f83ae9ab06ad9ba0fe26bcb03aa8f8730716674550c468352e15ab0cb12a2f5d609f9183dca41c30fe9034a15efcda42705c0aa88a0a55861fb7ba680d47f6586b867271d0c4144f8f113f255a0f1ba5f80a7875e591c92f412d2877b2db7927f851ec635770304da29fbd66e2f50b8035faf207b1279db753b9bc5109c9f18b56b30cfdc6a331d7d3db32ba0c134c86bd2a6356f790d434ca1693f630ad0bd8e2a5eef38b32826819ee37cbbce514355ca46964af97f79e11c0c9b12deccee323aa2aad0a2202055cc186779e23be465d97271ca7612f0e39d91bcde2df3ff40982890979429b97823c5bfd42af2711a62d2b574f8b1808f4f814b3657bf5a3e88b6e8c3663d61572ae86e10bd98ab4c0532c9c66cff560333e31dceefda14cde67a75430cd02f67d03e9a62bc2169e4aaf6f1e014818b081ff4cb992857f32da08400b5746a4ad458a6191e857c0041a2cd07546d502dbcd15fc62dde15c9d89d6fdf63c90a492e7f2b301963b00d2e9e5d14ce0568fdc8430222950598b9efb9522267f893a4b7f0ce8e42cc033e6c6ccdbbe37fedd5b601b337c9bdd4e58e73e6f040bf653ef18a8f7d6a4f3e3fce6f3ac3246b14cd15d3a2f14d719e644d2e04b56dc1074289da6114e8a13e80d342f84c8e3503b282574a34cbd4611be26ba3aebe773920dff91f2ecdae6131b97d41fd135874b0a0398e6416ef03a78cd82a59f0f7e8032c7826ff30a4e574366278ead1717c90c815eee11c3aa767513d88131f52c71c979df523c2cd90b683ec1b24374922aafd546a5475484d0c30e907d3e9a4a2fbc30ea295d263e362f35aa71051ed812b01187341e935cad08753fbd4ddab1860191f2b63ce6220ec4676c1f5f1cb73f22784a019a1295fa68c35b544a7b21dfe2ca111cf7e74aeec9ab7babbcce7f7c745a008ab9e94848139f528664295c6ea27c80960eddf4c5e817427fa65833b9a5ad91c962aa6c7675da5922d7116038892cc0137c7876d5c35862e7efa53fe3290310ad5700e738d29589aee12bde007252f9fec6750a3ed23c3315c2c6af326fcd490e7d1941cd0c79a961f0ce1ad074ba856851452cbabcc4e20228618499369eb33c0b0dc3efe0900501c517746fe6e991d5923db38b39c00f4787586eec7be42f5882bf6e6c28d2ac276c90b931385bd3a342a7fd03618de87d204f7829e1e69a04396dfd91f705a1d8eb001298bc0a37dcd22a349180b360cf8e8f422ac3ab5b1d2c431ee577cd7a8177b97e4cc78a264cc36717c70b25e92be9efdf1ecfeadecd1a87480c47b0df9d5d9c610f761d89b933b8c5d75aadf2e96746a865d208fe8caa73420252fba560c303ff1839426c0a74c447548b85ebe4a2979769f75671b23d0b0dfd6f160120444af14649846ecd5225db99be9cbf2f019b20d9eb51ca35a033d960c75ea9732246a3da12f01a5495d9b367dc2362d0e5170b447638db832f17d560286d7bed69f5a8c4f9ef0a5ce3e5a5e1770c1fe752637d39cf6daa22710c7a64188fdf01fdb1cab2befbdfee13699dac517963f19aff7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
