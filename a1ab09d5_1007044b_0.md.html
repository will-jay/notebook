<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6141c35a278a2ee99835a648acf7724c46050e3e6c6b37ac2813a80b7416fa6ddfdae934ab7f4939a1f1657c368a0536b93aa3f603a2fff12c721699765f7ae66ccabae3c74dfd61a06f2ef980ba02eb644bd5e161dc3724dfdfbe219e94bf4c28945f003299831fea6e3790cb4d83eaed28caa32cd83376c017187734d08d2eabe834da1c106a650de4ffb18e3e3f1c80fde24c8f8724c9194596956c4f708eaca126e23408dfe39a96cfe02fd9373a48d007d2fbc2e5495ae85bed3d802075d0ea3728df452fbaa92bbf0f524b36129614b78cf5bfe3b1e50b9fb198685f9bac9695b87555e3623cadb4747f4d96a33eb399450f9bb627d56b35beb8a7524a822e00bfb2e726da53bd78b47d51fa2e1372481d9e7bb8ef413f92c584b3224ca0b59b790dba1e3319d7ca99b7bcd4239b93ede26e4700da6bcda2d4f045a0d56332993625b0e9370e75b568999559d29cab851a0cdde8855213343433ec719bf834f8370babc602a3f8eae75e13f2dc1b770798c2285271cef9119126e896b0dc26d4656da223eb1d822e1bfaba2e7b7807510776dc6a355c78f730f9ca89301af3bd87aba68573cf9949c50cb63da7823f71c57382a05092dd72969f274707c8a9c4930ebe29312f94320d9a81c2421fca0a65ad002a7a09f28e11a4104054a082d4067674f2f7ec6ff0bf6f48c269858da81a233a048c40b5a49784f72e6b2ea8b17278b5c99507c157f208c84d4550da9a7d2572f65735a4cd3718339dcab76246ebc230e02b55d89c12d07df8ff88ddacb3811bec6664eaea606dff77a99e28ffa45481bc356dd962620d152854953bb8ed99a5d14f46d143ca0836362cdcbde58032e4a17579eb70b2c5647d5407ebb2b56baaa29494171f09a2db34276b1eb82e1c5e178f870a4f85841865ac461d1f94d2eed9bb3128b3fc167969ca1c1c24360e3315824507b63c83c78b11d4bce69179f8265e29eb29b3095ad47bf096069dd04fb499cf950b48e6382655fb44a24ee539ae2189d5631393db5f7a55c12bd0c308034f5323e11c29723aa29ccb707928969c0c21771ddcac226b206bf82e483b3e9eb0f47ee835d7e1c7d8102f61608c6839d1f13541c64093533fb7625d8175b877d46574431eec80e3af6f069841293b53e94a5837b98ee72cad870afba1224da5f15048352f8d7bc13330fde549ee0f9ff29244cd292d4c1d88124d441d0c7a29f18eb13f1fb6c2e007ad8b313e07d3ff9109135ffc24fddf25d1817f4a7f84eb5d44b51b8800ddaf5a1ebf88c1b482cc372b3bf5dfdb1e3a40ec9776bd905f7f2537a555c5cf15c1ced0928a141686a9fa372fc3c3e8eee202c9e5d0c37ba00fdabbd16139785788a099ca52305c4a76fffc2e081417e9ed8736ff2a9ce157844522bd87123e9e4765e4e67a1c6514c917ec121c9bbb344dfe05eac724c2a3d65bd59caf19b03257747b86db7ab727b24c1e7418ae2374f5147ce82517d2a6ebd5fd895fa3e6dfd728de628af6107736d1e041277646a499fd5bca2187349b3e2b1a484ce9559681999da0c971ba1adb3ea12d9b63b41a51b5e49015873be6244e39b36106c0f9430171d2fc27612b335fb371ecf5236c154645744bad452302413fcf03481f77b751fb20b5aef640f781240bc56b079b619cdde7db34d253a6c9bd5f396fab9c4472efab90e68c169d532876f3322980f7f3b63b2bbe26a1ea46ebdf1a3a8b9192423e00629533a7b60f0ed5f01ff792745d55a22a45d1dcc35377f64828a65a25648df889badbed58af866b2d101edeb6ba5f6ed7609b79bf8e750fd022ddbb97a8648f23eae28e23cb2f9d15b822200dab8a6e6e5b623f467b14b9de8ae5ba05485a3abc757385fb7e935a0881404ba93869182c2e4f210baf6afe29b42e53afd7c2eeb57bac652bc0e105e0f683bb9b8ad81f592591069e131ea457a2966571eff5750eaf03bebe3e216eb2a9c3564724be243c37c0f30e25cd06d4aaab2d118cc672610fe9c7013ac39cdfd08ae73c974b25a644b7f075eb9f698f94ff2e525331f73d23c99f34f8131af25d8951e06ee9988964a92ce4df77cb2e32d272a24f404c12cf6d85fd17d79f3668438072fd67fd0b2dda2f79e7413725097da4e49440390dc71e4555984ecf8e489ea4f9cc614c92c1a94bfec469d453383c7c6258eb94a3fe8d11f1183bc64d0ea6ac26ec2100aa1b8fd78d5c256266303659fd14969a57c0cb7ff4e3dd418971ac0c15813b1a90c590f691a4601c32f381cb8b487bbbf55869ab9ea567079aba50fea3ee7d454661e1ebc7c7d3a7e2301547e59ad78655844a3cb47c373ef895f9eb83858d43f7962a5c240f334742b21495b13224106b27570fb89bc88a926c345fc73d34b6e8de5980da4ec623dcb74472312e3ce87e2a1c2c5a793f370268bf3144dc58072216d3affbc62583e5355641c44c54877a77b18707bcc69e0647ab1dec0cad9607d9c9247c8ef32ee2aafd3be093a191982aae4c4524d63ad270917e1f1bf2774e19125d5560d903c401e222c7793fa502a4b2f844286b5098ae153b3864d230194ee73871fc63988f737f7c23723deb256f8e60008c5f7a0e7c94b6a7719cc39644122ed8d474e74d856659a6a55e43ca6f99f5df9668521d35435a73dcaee2c690f98284b77b42ec84068dd2115f56dfbecae549b3f1e0a4591cd56a015c4751b1d18d248389272f6b7ef04c531db047a31d016780b8b06d56ef847104d46f9d39720d150a7d812df676d71ad9f4528497f237a66d43f0f4241e533e77a5a210db8cb73331b4ea355005f27b9169fbdeb1adc0b6d1a1a12c5273141465570666a937486871cf402f15155481ac9c1bdbdb2b72bb3d7701e20c97cc14331199cefa9aded8db74bcda21652dae4972d715ab34072bea5fc72da3883c898c8e33f5f20957ba7e55f0368007e384e6238a0db425085f90cb4c75075a5fc10e90d7c7d3960139aa87e1ae5ea348d249553672e103e422e4fc7e73259c586de9179703b9931b78459bbfaa33715584005e71153c44310c3e2613121767e161800244872cfaa558d4ef93452c0ea54a28a7e07fe614bb1cb767b4f338525ef19992b170159c01e4c58a97ee8c774a6561640fed1ef1ea0e1c296f2267ba3cae74a53a54736061e43637f5edd7b375306244ee77825f41f76f8a3d878f62b7a607a38021699c51b75163b8ffb456ca95688f1f0a3444006df779c055e18ac6a085c3cab4f073d183446969a6869216cd34f8283f9db8c1efb406ced7b64644c769760f71a3d3e8e8e34be3584386a28e14f87992c5f38bd1aec18e7821cb645c47506f6820dcc29b1038457e69490012b52c8f174e58c924ee88fbf5abdfc88c1edf9a29c718a05ee60952e5f71576541b51a0c665c8d8195187698658ba623db642a8cb4114018bd2fde782f20362bc896ea6918aa706b94e6ab6b7ded8f5f0fc1b9af2b0b46eb7c476ea289328021f229052adfeb7212842e6ad64a3f4bac48df5a90180ee00763ac8d052da8771f9dc633c6e8706715d8e92bee657fa5a8c174e44fe13c20483cc936b57cbbef22d7ca2ed3865ee2d75a2c2b3ee621c88c476cd68d5913688e24fd1839c7f59ce8254c4eeb7e83add19d13e3900953fe8688ec7ef8fc36a47b1b00fc8d2d9d6ee7efe5e6dc13f92e8aad5b362849497a13113b69ccdab55dacaea4e5bcc3fbaf6090fe612bfb40001beeecfa35596cf9becabefc222917739750de886abc2264c4f18301de7669fef930dbce603a8183bdaa9c3cbbf5548a07312002dc0f0508a1e52761f101140f1ad75844e414764e9c8342d4420d61d6ca59e8909cd8f8acecbab61af28820c42fd67a72ba6dfaafa8187e3d25c490c57576c6e62b8569aff0fa2ce7d9dd6a800ed25bf2ca590e71f63492d04fbd46c31d2001b8bce5f767279fcdaa322a9ad9d1b8098b74a98bc9438ef41b5c2e247e4cb0ba948c7696298846a2e59f7b9f992ea5b0741632da6fa2fbb10dbd49922e9984ec79e6502f48cfb391de7cf870e1f2370b67a3240a37f72eb6e8dde0ccdbad0ce4be92232523eb33731832a4fd99dccbfb3119ec0fd8aa75a1e3a5f18dc0aecdd546ec270e0ee3b3c5653ec0a2006707d451beb41d4f4ecad248fcde87fa8b69b792365d65bac948282cccd2408ea9c02d37f577ae79cd48fd2868c2eea9091102bc0e8b1bc5be5048c1bea564d620dffb0a63def8845e5fb97dd52c772637a01eda7e8923ed76ea29b94f1df87a4a0019e137c5cb900d23b8827dca68c67762cf2866dd69e0b53ae6430f8c7b8e88b8555120b56ccd5008847bb2885c0d372198051d06fc8962827abcc8f3f1229990341c95821f8af6f748016fc9deb1016e15c7ed8f2e8eb8ebf6429183ed3ce2eb3b31044fe306cdf78095aaa7ec6afbf90b09ebdb1c3496f1ec24ab6c8f8c0688b79de588ad56f3ae103d862feadf58998a179bad05164cf6b869421982f4f734ea5efa772d9aec01b4873716a124ca9d068b70298300d6c51f20fa594435b362943af7196179ac62437f33756e2ad050eeda549c54fa42d08b4e0269c2a9149cafafbc96e36743caedfba08c93292d666e1553188b4c8149f867db20833fb8211d1e0932bf5c478e729e4c256b2b188a83eb8091bc0d2996bfd57233f630a67f574feb505177d3b667193c618128886b2f3dd87e2a4e3ab16524699e338d6ea05a2334f359ad6911df13df08693279a858834453df1dc64563aba10b576fcafbda7752e6ecfd164b1e00485e638e5c96011eb7246554fa1a7a89041b1f88de4c5ee8fd71e0bdf0a9a340b3d6b64637ad5c6b6a4cd98e083c7a72a017e15ad477689c8133f74fa682663a56c9947ed699180a5da1aaaeba62fed3710d7459bf0b3cc5e73b3dd344a0bb7ded98269b51cf582e47526124bfd13efa44c0f4feee16976f57b13df77a404517ba015f3f18ab096cb899b5b710c69fa378d38841c2dfa1b7f449baa7affdc05c8458e80fd13070cc7931ab11dd494867608b75d8d98d37748007bbe8dfc12aed7a612651a69272fcf617e6605f2a9eeb26ba1a050ffb9068c3a7f671f3a0cf8f6fe237770efe235920ea9a7e86b092f3fd27627b3a31f8576397b580e303abe27f80fb85a36a01626a74f9f04c7226fad87c8e55ad92281b55c92283373e18d926e80b74f85125fee0479589edbd1f4cfe6b6d8bb6e2743a04f9a4221f2929de5f5f0982172b549c79459abaec99a41adf68fd8a7b40973f943e43b7ea49c8629b41e445365cbfc72690b497b9b73a509ff90296b538b6c28acaf7b3a14252ea7119e3e58d4eba159f52517e5f94bd5c460b64b132e8d28a182ce556195f39f836a7611ae205c832d3494ae5fcd29d71e13ca497251c385d3131438db4191852741e3c43535fb381b9699c81138354a7d3bfdc0d45d3f99310d8897b95c2c54d30c80964838b35729ebbde89034a86d2c2b6f41c1193b58e43d87ff09b789bea4beb35c74d0da4920bee314ff5d4a9d2252a20a72b4275c8e31dcedb2c883717db42407f8ee727f29a966a6a98c06767a3b5f5eac5d2c01bb6e9ae3565debff0739b7a93911db06720c03f84c9368a52f36540ece1ea4d517b51eea8ec6cc45b50ace7ce2cf7016a2ba4b852b8ba750be8dcba511b97428fab39726c9a7320ce52b96d8f1a9f4b2955d7509f8a619bf1010779cde2470399e9bc96f834ab912f490c22e7cb8b04fc6044106393172d89a7fca00364677db791e8c58293ffe24e6007eea7aba8dd9f17bbe17985884fb260d3be37436d9c4d78d8b234195c74e92a2278077de509d45f4280338961d75a31a7f6f3a8dd1137024fd4bd865d9bf5d31f15f45f54c927149257cc7855bee6b87be7990080f95a2883cfdc1c3027cbe5ed6e77354bb2e05158fdecd02bd4d87c5cce679b7e08f460794d2f10805ad7401a8a837c8f99fe61816b818b44149ee8fb8b2d577a1d0a13d5ffbbbdfed33a6964c63df6aa1176ebd7243ab2cde915840fe49376f041d15d9ef46ddc38cbf559e92a4a273cf195697bcda0b27546accd7b4cbe2b211dbccd89d7a3a5f36b14ad71e46bd21e5a6e8056cf0d0bffbb719a205cfa891fc951dca8824aec8b28939932beec2e938d04985d24198ef27895d0464f510dd37c4875bd9ce3233c5f9fb8dbbd0abb319f771d416410bbb5ccf1ad4896aa3f201530f6cd58b4720f5ebcf1a7550a3b8440b8bf5b42826c6cbabbae6cf499561a47f727d5ed139b8454b4a246796fe98953848005c0fea5a1edfb2c42de722b7661e9567b5f8d882e40ff73d46ab695b81d350f97524f4b202133e77dda913a4cb9c9c0c038e9dde5f2bfd6a2261537ee6a28e47e23e6e179bb98bb28d5655a19f5b9338221f217be5f63e05e7a498a83435745cd8d23ceff6baeb558b04dc1121a2eca47f5914565cce3aa648e1f3da06e0ce0e1392b0ac791315d32bc1847a9a2a262b5d906c9af904ab0af7151aebe4da62e31776b8427b170c51efb3b830455f719a8c05c3528d6244db0311f3085453a9a927c6d8eb9f6abf7ce5810b652d3ffa7e66792efd699d496562ac7b4256a4a0fa14a912860a12a1123dd1da1d978040ffa8c8c346fe62b3d2ffdf3822823d0b078c3c5e26c4652dc38f20ffea9eb9acb23d2fa663c4473c60ac7c6d83d5268e1ef98c9edd12239b13971c56a49f4398203de6777825ebd9d7048992f23e8bb9733ec03a1d2246a33f9d47328cadc63029562c4c0c3864654d9bf4b46455b06d06507b1f63a9f718d71c86909ef2db8476516a7f5d586a76f61d90ed1f47af40c11876e5b40ad08e5fa2c9f82f64c3b9f5be399af8cc4acc1831b233aa7ad267ec31a0acf350ab2efae3ccef1abf61238da63dd54d289a9c7bd63b9713432887e525ee2c2121f87b15bc534c396f421ada245d88bb0bfdf321c3ada43fd82c4216ee79504df973d6c6b391e5c273e2c01db415a4c155258cd467bc488dcbd2780dc03f53120c08a6bfa7f1022c3fad57cf62dbc31e7b7736dd111a4d51007795a27053269f98cc112bd0cacf18d22cf797f1a91ed87de6d3d59d2de9c722cde82b0adc6dbe2fb6497a3edc5cf7fa39f35f961ccaba36cf8c35edf23dae4e36f0624ca1255abc48a2c0a41adacceded4b4788dd71dfcdb991599936edd839771539524429282d24f3ba07f7cd9a425181a38a06d8eac4621fdab055b4922d829a451b818ecc5cf1e058bbc020f55a97b76ba500807e544fb2d35aa157ea4bc8b5f27ca1a84556acb01bb13ae1c4720346d809f5146695427e7806bb6f2576135a22a2ecb542f5e21885c83f9648a20356d3aecd1b87daff2535757098d231dd77a8851109c094d627a9fadcede4263d3046cf2d33f8d54c6d8624e6a3e1df915eca72c13e372d29cb7547ff3c321d2b07a133df650bf2d14d88a392795fbb1e3e1c5f9cbb718ec280dd59361fc24c1ddd97b32708e74dc347b1bb417785ebe6665d11e61c89f39d85c22d1d50b8d787b349c88bae4167720f8e974c0aa11c3f2c94d902f7a70f62e778e58ece5722cefdd5a2dad89c39d2aaa0444db7d65b58c8d28563dc001146fde491e2196727a496da144e06217ea440b3d97bdf745a404b792794c756a6391e6c7f0e0e53131d1fb39f31199ba083de0d9d81ba0c42e51276af55df040d69b8c8325fe99df2c2c4664590fd9a5c4fbbbc40f84e541c71954939a0fc1edbcdad3363f7a85505cc1c38edb390e3640777945d739c007ad1fdb2e65a66274c6e3e8cece3cb80b8d30c96e14a7df339f27be662963c669f7a6d2a3a28cb0ec7709690ac216723676707e338b419db12cfa4207405c8ceb60aef8d5869f32b8a3fdd023975e90140187d8f9cd7ea63bada286f1eb554d193c22906a55d3aa6febfc8af75ff90d929f2044460e86b7fbdda53b16ad4665c7e61f77e7e4383ca5e32928e7a7f6e8f5b1a47fc1da69236d0e33ea21377d3fdbc71e1c05f37ba8f15d6775cd2adad03572247aad18375b41a9f5aee77ab994f9fcc2ee2864e191e51746f90d7e5190a98ead95e3714b9f1dfa384878844c742c800fc7cd93a6907aca5240bcbdff221c22252a71880d136d033c8006af9e6501cc7b78714b5e3b943e27fd282680596eb443617f878e7d239c37cbabf1c28923903cc25961bd6df8a876e5abbea5a655c3c16d75b04d3859382673d697ada4448f6ff8460576cc0a286f289499bea3838e12d971740fb91a4ee97456ee7c8fc9853e8c94a399a9facf306a0481d932c936469b5e138972a6f2af26b33602cb649b6c6561537087245a47cbe8651e715f062b216ac7cde1b22b1a0ab244009e7f9bcee0cd44041aa8ab38a0197d489da1d9fdbac7cb3e916f803ca13e07314065282bba0e5f6e1e1c2271d4b1cfb5b141900b7e9f7f8f06ce4fe7744b491e17370def4395e0b35c013f1b6cb3a938d411318f26afd4088286a5756fc1225d6eaab1f05b6ddf5f3dbb225a79ebdd840d1b47f1dd8f0ef69a1b3e4de7a4d97b31bbce363988865652c67b9477f0336d499673dfc8172d5f80b6f3606cd47e9a9534c4cbb6fe583cad0a1ea4a281f242d91def7139983658b2c4df35bb0da13526d8794d1528b3d5e68277dfe859389befc3ba36ce947e958df6047d88558800ad36e23f8fa3f22eb3cb2dc7f1af48b8349293ee0a2989a8ebacc55c6b2130209e7060e9a8d200f885d76dabccabe4791028f72d09f77510a88f873de4b9a645b0e97d813c5a8557afa556b88963d0b48e6b9966a83be0dd717eeea6e1b01ba4c818f36c9e8df0387f2af2abd451a98d6df3c5c8f246a606e46de201290d8485dcaa623d4192650ac33a5631a051731715bf6aceb2682e77aeb3d26829394e8937862a3aa2c168cc5e5456ccaade528245e1bf1128bfe20b4ba94bafd93a978b36bf8e1c325008d69461b318977b55f34ecf0db97929666ccbc79fc7347635bbce4a46f227b57321e8f52333e941fcef6c279e4f8dd9342ccb74d4bc0bd86ec3f90b62ae86e6673adf947dead7ebb5ebacfcb8676c71a7b5206d1e9e63662cb76181b52762c415e13b967a581d4fc435a0c62e5de3a62b78ecb591864f6f8efaee1e5c96fdf95ad38eba3b09f8d87e5e583d1e6684538be06f16de6f63e2bde29e60ae69cbbfcdb4c17b00bbca730c50e3a633516b02eab84761fc1727f116fda8b799ad356ddd74ca5bc0dee6a47d73b9235fb644b4099cec192f74ffd7654ae0267080d95715036fa6cfb8fb446dfa6455340d08a34f672bfb3ba699dd2253daad64e8fc2834edd1c72327eb1a881e5989b2f3cfcda78b0f6c5998e12fc1f2efa5727cbd5d9d873bcf5c60bd4ef12ec985820cdb6c6e91b33bea54c95b76d5fb07fb7a2f6b99c06a3b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
