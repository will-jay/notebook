<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54511a807a151c2b9dabbe31e4645c59592271bdd0b8584d2dcd3830a4df08e48eec23db5783777769824339a1ab8c97ea2d3ebfdd3e2a111c287e12879769faa21898738220debf7a8492980161d91a2c86af284c50d6ebff4e2e267a98c8b7691e29a3a6df764ff341f32490373c514843d52539fadf3091d980da6ba90ef9889b88fc636f8b08ec24d44e514285087de8325e903cce3b65ce0cff300edd81e0cf7cbb78868b0125b82dcac859f6971a7fab0404e46ffaf99c53d45e9bab664a424b81090bddf3cd840788684bca58148bdb2b5cb0879d5cd3a4ea1f79c487e50945f370b68d05daaab499904a9450c00686e11706505f6ef85ef0f58859ae0e77cac866f38bd534d99fdff5f860222ac32c5c13061fd8fa0e03ec3634de8553cdc1f435ba55e7b008b858558dbd22a5a5c589f834a9a0db0e812082906570f29c9e30cf07661cbfe6008fc62c9f2f4c215c6318cf051bcd1f7f217314e7162ecd99e9209f62a48f8d3c50563231a482750325a11aac53095e0165cfaaa1e3fb2b363b79120b1d109ed21c524782f0e21fe351ac9e30e368c0059009c54ed627f825ae40dee4eb852f354affe2da8e596b96ac887258f5a2ec23730f5e316351e20312dcdf62f5df3f9bb563eca69dae73ba3e292d2c5dd1dc968f4c0315e8ce4ddc9732cd180f894693b2e3f606f2f4d0bace05dc1e113d0122559966fbdf5797a8234d5bd8547f5e88e015cbc3ef0fb77dfa2dc54b59069160672f3d02a77512f77265363aa58804479a2a8e923a578408fe722a8200b61c24579f86a7e93cf09c66a1e2a31880eb7245143b3a31a53aa7af21884a3b64e72f06d9804b84b70b4ab29dbc194787d977aa6bdc7d55a1af91250bed4f25e2dac742a5945a157292fbf0ce56fd4f5e950e87e624e2ad45b4e4ed80d9ec4f30e895d89f9dd937add0d68331ccc2d7e61cd7e1f4d7c900cbe332a886f3e428cd7270da26920eac3cbbfe55928135ccddb4339e74cbb4cc5ce43bffb8b027ebe73739ad4a41321be02d174c017c49c4586acf1691847e45b65123ed965ed022c508e15d19d1af5b146e459f095a9cfb358df9c12c6727651bbecad2da52e45369f5ff55222f706d21d265c2e24bb0e419da4e0b07ea914149306b777c0ff438cd0e51f60bdde9dd143babd8f8e7b153311b7a38d2f9c2caa741bba0b492ec7d58babb460d68bb790fc626ac3fcf56f104f51fb46748386f50eef292e8f711130263daf8bcabfbf6037aa84b2d3cd9aa49f767d75b49431a27d6fe61da631f9b552cbfd0e0600224168965a6654801cc3e5238409beb3e24b72a23cd5edbe5b07aef052734894b44606d95c3d27505327feca482428fb40a11a25d7c1b7dded7d587594acf6fb385c6309b8f5cbd8b8e398a45360f979d0c48a556936ff00ba21523789f95a756df3739fe68a508ef8cd5c45099914ea5214c80ec93312cdc438de9b13e0535ee95d4c242a0c20f971794193278ebc7877f29ad39213d6898989e8f3af7cae5eeadb33c4ef0c7f4a05425f82e0e34cd128d426d4797f38436ae42da753afc879b851dfcf4caef31cba9a13fc82c8c24baccbc1263c064e47bf11a4ee8216fbf1bfc803973bf5b71c54975afffbabe0aa90d4461759aa83676a5088363a6b00fa44dad979f6c49f31a3a9b7ecabd141128d288a934eac747371c85be89fabd3f835616bee602a3f6e826c260c7419e2dc12655759e7d7840c27940caa75028e05dc9f2b1cd67afbb4f447ec5abfec42050a9c3edb326658d2a1fcb503f4c01fede28a6214ca0dc214a1aa0811f6b9b0bfd663b528afbf05652b9ce5285c68b4315da8ab5018d345b64f89f27651bf99d5fe0e77b292f84953908b969f3bdfe7e8d7ca3011dca04038db402a17b39f92b894803a1d7828d9d4d9ca3cc1db09ed2c064ecd26884aaa7da86ef1b0d10c40f6af157307aaf5f1ecf6baa7eb05b189173c9606e9523b3d5dace981a26c5855f506b7b03dc8d0f5de2d3fbdf4f767b0f1807ba4b99b3d4300cf0e74cc965fee44859ec4ab5782e2ca1c51eec03633538bb3b3ae3f91bb7abf651d21bab1a0d3061d0651bb8d069e0ae99e0039a3c604dcf50b45766d2b79297fccaaca4278dd2520882ac4a2fc221d587752fe8b8973a306e54027bd1ecc4539df19d30c5307391e1608f5b970a03ab2a233d301d0c72f64754e5ea0509f1fb696318c0f5e3a40e8ce79aad55e202d30b5f29a90712087f331c18f51abe2022ab2f490784c243ffe070aebe811713bd93190240fbe0e2497abd0e5a36f136ac61c740f0915b8415c6159235e782b19ecb9bc7a38a3caed59e08ddf1eb22af3812952ae58febd1041e10060e9bc306b285e0eff5698eae91c8086338131c33f02d8ca8d988cfdc11924464c5a0bbca6770823b31ce8de0dc62a29c7af10df36716cf237be06b054512a6e49d4b83ff07a0676549a1d787f500bef1b311fcf78120c567365591ef381e7a6e8ccdc961333df95190e52ce2cf67265950a75f90ea4c70fcfc921bec6cf7b4dfc4821e6ee30b46feb0f1c970583f58ac17a2edfba95269073ed6f789f166e1f34a5f8c245edb54305240bc7248c7544ec2cf402ecf13be6cb5697165cf689e38819f2a2b06752dcff3bead8bf338d5567218e6d443fe8ea59d31396ea8c034ee99fb8c2f4e725cf891ef0f5126a4554405a3d2bb4e7c714e3e45e94487820340989cd0db70917fa96895dd6af9131dd2fa414410dbd7bcaaf951fa8dc5455cef711fbed9a48c963dfc78b6fcb6a5402db4a3d7d2ff0daafadaf0db6f05c11118cc197dec16edfc574913ededad9e17d4652d322f6bff4d8ccf8b03a594717a684c24789f6a7691b2d36451cbea5b4fdfb667bede7be8b56b42e557e07cd0b8276813c9c0b276a706af41f1976fdbb9a38435c9844bf13780de4d67152068846665ce24a9039c670ce6f287d30ce212e8dd4c3a98cc6b90a4cdc8b82d9bd30485269fdb29a415aa8e61a66f385be70ce760757526fe3f48f2dfc8e206c17049336a5fa95f15e959aeed7d751242b7c7202a205b84c7ab4995932abae135b278d1b9218f587e37115c1485aed52a26115b1e87c101fdfa3f8cfdb154b2e07d83c9520be83900ff5ced2c08e3dde60d223e2a1d872e2ffa40025ab88e61bffe8a212add0f86a2d32291732f0f6bc768f3d64ea10c3414ae6d37f0311b535ccb563b4eaec94d35a85362a8f5f0cb962b170352cb5c2519c4d54b7c4706665062347909ffca07c9ab082f53c1e2539c7a8c1ba5f71588247ff1885f6673d5d8537d6b01c7f4a312fc636050e055e50247053174d124d11c3cc16108c58e203d611cd5a8b8357da5841721f16c3f2f0ba65b1bb2cc8ecc90c09cfe3dad51f139e620e6f828b0a97dd07ea192a0f8ca1f6c4c536eed561a23578a04ceb354a61999e1347388a08d6792d9a29cb58006cdffaf6bdf71d3327c877568fe2c2374d001b3131453eba2cce5f7006b02687b34c855a0b64e9c61a1706afce9dbd9c53e713f717142b16cb8c8626fc29b800379fe259c99c256bee529d50794767285c01881b72ea27d34c904d60fe0093e09ec8d2bf1c038fe382a2272ef31ea9aaf16ea12449cb3d5b6f5c2f7fbe64e4986e0d33828e40070fb76d2ff2221faf2bc644232dba46271be2a0dcea59f8fc044a48aaa70075942012686405e833141569f1845f3acc8e3e5bbefe6918b0671c1035e5082ad7e46682a33cec8dc71f6b77a73b8c1f8e704350d2e10fc54d910db0a2bf13bb5c92404c2fc68b3cd0626d77e4c7fee0f0ae4ebede3f0eac5b51aa576629955a1aeb54e8feda5dce679716978f48cea5057dcf6cf8598e57b1e947e448b02019052ad16f155d87d6afd953f230b45160f0f73886f5df2b13304b8386fcd549fd9037244cf0e76ad4801899b4fbeba63981e9dd9542033e7ed4b8437b978bdfc16e04e4f18fc4a3aafaa7e575e4e8f9c51ec754d6fe24a801a2304077eef72fafad5289fa4c49c055e475d6892cea6c1ac142c7917f8e2ebac159227cad77e7796e72af9904813a2c68239343cef6be1c5873121723dc1809f31bfb243300d14666a8986581622eecf9bbabf4342bda94118951e6beaeea9878b5feed06c3487f5183bf0620db2f22886cd8402742401825140f21940b0010ba2f2ea8c9d9857b51df32c06745c6d76136266d56dfcdad3f0651ca9a272b1ed3bb94c42b1872a0edbdb77bfc23908935e07934af9ea71ec59d2ccd8cc8f717d2f867b51041633af32078ec9e8c0359f45b727c414d78ccba3fa5caac119e44a6b72e1426208a521a4bc20f53f94d44ce20df911213b14b51a83eda3fdbd811e8cfad5704b0c8c27da247bf7a65467d9d3308c2edab397a2d6e8ad945cbdee2a94c871e6b1e3f5bdc984ae36f3c864d1f80215f2f4ec44b5e6ab31be30b1de953b51c15f0707a497aa135e0d5525f29eb9b5953d6b75b2acfcf644c2b1539cd624c686a4064a6d621d0e6599c14bf45e48b8dfa7825cd7ee69321be77a37cc3e91802c1c2a697495b4378ada47dd71a2f60042957590abdc38ab488e2e4cf47c36daa586b87534c005ad610caf30c6727fed0fcbfd1dea14e6b496b78746856a7b24b4b7c977385cd4b4b5033ca850342bd4f2888755ae9259638f80fac134353300722eeadf6d8b6fac83cf49bde7e062c72f59fa7b0f83615ac5e7c8047ef4f7dcc4f50ad38453b64186b2e0bf1221cdff429a9c491d28a8ddbf8356d69ebbbd802dca6d560dc8e8d23e88f2b55af3801dd7ceaefa43a53db9cf4a6517432846eab855c0cfa154919501d33516736681360d48fed2ea0501f136b781a8324a74404e94cdba877f3c22fc28ca365a7480bf07ffa1ff12084394b78f8df24b9dc5d09a7cd1cae4f1104a84f17625c402f35ff03a50e5c56cd1ca5feb0618033a6fec8fe50062523a22945f8be6a387a6382d3044c325860c1869d5093e4572b65338afb5246c3f26dfdefe8152709de2312d528ab0941e96cf5f8802ad3aed1d798b2d169ef00e0bf3cc261368eb5e4abbdf85c8000a93c2077ba3dee8e60ddc34174bb7da804a9c4db4fd28d42d7db5bef264f6982ef08e4c946c76454219b8c6a76b91e0ddbb7c0772e156d07345fc9cea954af72e589f75f3c6bf5e2fc8d703e2b5fb54e28bfb96c6970fc487e518746e38f6c2d24b6ae101de52435ebe0554d0547feb306d380d80655467427cfb3eb8c4894345e84a224d72fa08b9e1a30008a0b52d10197ef690edd8e975e66a8cc565496dafa1724fc49527681d49cee2986b0cdca398a9341e1562bb9f62f89998ebcd2b07a487501352760e15351d6772087037af9c69fa3b18192bab38824bb8ba0ca9044ee715fbb17b733f90300fc351c71de76cf2ff9ecc273e52effdae8979f3f8d951d61dc1016901b9583be3a435bb548d5ba5945d2ecf1ba646e66a636b4604cab74693b7bdc47ed585e5d9f72dd8a03a731f4c477261ce7dab764e4e07d7d82f89db5b50b518a05fdc836bdffd55fbc013e28b1da7bbe4d22d87c17c68c9c2c1911568f548d32c4922e725bfa3aba42f4721ac53d9bc8bd320c00fc9d5107bf72dd3f19f3300d24fa672f3283f665192033c96a456f64c538c37ac75c99b1ca954e75656d2afdbb2baaebe2b6bfe1714dde84e0837998c658f1cb9b6c2d890ab58d8ce7433959597fa923c171edcebb5636dd029329f8fac66808d7894b0cd3298707e507360b4955a8b10a3cce0060d6cb039b66a9ef444b136cd86df4e7f9d709d39653671c9eb28a099fc668f17a7ab63e6de257c757654e6155c8839f6ad62ae7089b46059b7456bfc577671e9145fff2bcd354b2b71c7620e30b18114a4eaab717488280f146790a627d14cdd7202bdafe4b1adba190810b3cf23b773a4e0c7ffd5cb5c80865102aa9f577bd9ea1bf7c22d1815b28fa7a2b1288e4696890082a1fcfe7876c297cb222331efa6ff5bc12fb74e9b73b7c0dc2cb751566696fd3f01e169387d1d959109c87ef8b2a2cd22c218c1ec01d02b75678ffadc809c750a6fa81e32795e04bde23dd922470b317a20ff61123c62ab570ddb153987e68e6ee322073f29056043dd8e95e4165d232f0e85f9a73059c6b39a29a99bb57fe2b241948a32264ac00a9560e68f1b899b7f6bea7f45d7032b4f1bf5c4db7cbc661d92b09b1f56465fb1fd4ed0d5b191990a0091ed0b33b18232db811281e860f4ec480e846b01010456091d7fb7e6bed566cabfe2fd108b16a01a004b96b3c13056f18ca5e9ecde5697d8b232d5f829e8ce531d5796826ef84144e4e7d6b08557661a44cd486a79e0851b91d1ff442ce176de7d7f5a3a4c9897a6f4ba83217bdec0f55447a26007649beb4a75890d3fd44a2f95ee9a812e4e69fdd9be43379cd25740ddd1e3937a19584e9b47375bbf29336d42bbd4712807412650ba30b581fd60e363ea2f863ed650c33bb53473c41350b6b1e78d0c474990813daf11325f13634057fe6bbf4437a9ec70541630f3e1072bdcbdddd1489eae947435eb2b467f0663824b2769ccbe1bc9f5ea2efefb8906c6c25de10bdea1bd5c72b01f4598a686deb3290e50209510a9d856618a76bc0086c7e5d36ea8ff7feb68ba677058ee70d1c701c4b19708068bdd9d10ee633557865b9ea1402192daba15a08a86fe10630a4bc9ccbe2a767b420154f5a1ec2fe0689a037ee74cd6dbe3c61eed41c29d4e8927aecbd9bc5da4d25c2ee090c000f77a2f62d65210a5beeadd2a45276624404ec637a8f04688a7cbc8b2a3286f493c6506c5da8081fd1aeb8853b98e9053efb929defc43aa543e4b17eae877175d0d7e4912cebd2a77cc550288652b4a799173a68edb7788199726e8d1f288ea753977f4f0346f90a3bb8ef8850e9eac317b8c66d2ec6961aa372596ae557903ed85cefdd306328d1b4b8795f7d57c9c66c6d8d4589dca3c6566d12f5061271da9a60da2851775e487f090d70e7581af2ed46e9145cd61eea0d7b1817dc14b4dab30ca9957645293550af78b6fe6a92c4ea3fed58ddc3b3a19b03a3a5337d849b589e81f97581830725c7ab9c39ea0a7b6a965e0cb7e96ec888b8617d2db326d462c85769ba01662788a26c7be496abf7afae9fb7555bd14222e17456c9431a5413706491c68778213661ee9f2aea00c5b28a7fe1484d92c9d560eb757b07a98dfeb17cbad4caaa2af576b8a03c87f77b62afbca4fa659e5656319e53f5cc34c5a92bc86cce1e37d11e330ef377a6ae6f35709b5e02177ee96bf4c5c2c85b55338740e623a02bba5f5e4db0cfb39e54fb72a3390f7d0654c79a32a19a2c7251795227e47d34fcfee2d0da26fa13b3b38c6a5a53d9addaac5681d59ef980caed3703e95760157020a0e37bca81bfbe2e7f33059ef1c00b152b25b247b5416c0dbaf4a5b556e75d7f49d427e4d049e709fdb14c870eba285cc42c99cbeb8246837c2b68064051a7f52ec65022f50931504bb4c0fb4ab32ad3ccf222c3dbe26af001127170259f3356bd25cb35f219e4b82dd70e95e48eaac87f915b70125cd4394c8124461948686ec106a510c83196a84cc41ad2c7b4101b0931015bc7fefc4dced44efadb4c297579e95ed1e9499da4396da2bcc95b82f4e2a3e9b07f6dfeb0dcdedb5b9ea3e619563b21135e4ccf3f7fdbf5ff47333a1adbf7ed554d98b372ee1e385307b3fd6f99b8bf0d0fa54bad30dd8e1ca9914a9ab1d3d6227b6e7335ad25afbece0e966b54516318255fedf1800db65f4448022118fdc4e341c6c9de4981ec31d9d7cb9cc9c70900349147a100be21d4ab9a71c2094d2a49da72e7971d650040a9c40f13344175f1ee4710e71575d5c7858f326d16ba906ee90718d5cc9da9ab462143bfeb6d34f5ab42abf0150d182021b86a1ef67dfe778b4f9c6c1de3b058c47956c25892e35a3046e0e8a9fcf08b6bed67e564bbc60f1a3ebc661171c85ad7385eb8a1fb31ed4179f517b018f9cec592670a7f0c731ed41bac81fe8babdf82aaf9836c5be3f0c931a48993df4a9967572b8217f8bb867e346cdd302d043e0e4e872e93abb03dfe09edae6e9e45eeb86ff18f6b3ea051a3eab4a597c735ab7a08544d3b2dac32ee758e3b360ded589cfe0314ef5b297cbdcff6889d3450a03e358e7fec2ce4b105f0e739963da38cc2af714ac0fa4a5b8014529e38a6363c305f7dac23fc1a69783d27caadbe13f1c0ecc884bf73d3afbd08219590e33940627ba4baa92cc0d24b7df95d9faf8270c9aac86b63a14d365b5e145c0bad33776d4af528b1f1e9074ffbbac6b95cf066e207cdbba55d25fbf4f264eba2991621d5f9c4e11047fcd9ac352584ccd2d42df3e505e5950bbfe489ae99fa4a0b4519305786a7d86d7dd5fcb0b768f4667a47075186c4cd1ebac40d3ddf70f686abccf7044adefb35f923d110a34e921bf87e8ab20163de35d5fb8be99c5c8544b151f039bfd9b67e7e326f17c4a20ec3390fee167dea76af0b6f7e7f67c2cdfe5f8fb556e851d7e34a7440eed48cac18bba934b62252241a6e2bb9fac063d0a77c951edcbb4348f7a75e58b87f83a686118ab617387cea8456fae34127df2ec4126aab87c561b1fb695f1a0db2f20c0d080dbf0bdd02e5db27a3796a6ab152f3becf9519bd9d1b33601c5f428551de901311822a62d0d8c60723691d7a446ef44a5372a311bc319a8fd5968d362a7dfc17b6aaa8c9840ff51b6fe1b28f0e8a8d1396185b680a76f6036bb5764a6449d5da3e094ec8026b21f1c37a446532e147320f692fee46b8dc0e122d7cea242e630c2af52aabad95b5bd7ea538c681c79177d2a0adb0a75d0efe05f90df9c1ecfa3e3b796d04c2815b93383feb74048b9ba75110ead455ada9f404f86681c51f92750052ed7826331928f916a59f666d8bc126e4116cab3b8e50beceded0f08585021bb0b4aea7f714d4dd3b63cc53f30de1c53de31686a1b40189970c1efeb8f77049b1e40d58e94bbbacabe13a8f2055b8e9c759dea9b2bbac9b4aba9741db4d4a70762665acf1ae8035e196da19a92a8db80ad0be7ef83df6ae99a1151c76e89e21ae748d259164cd204e595c8fac1ee27529aecbf6a416a4489ef739798c5fa689183532c42cdc012ad4cc188fa1757e84ea720d006b949b9220239a36a707906af75a2e450480a1adaba7ec19df54d256be2554b974ed3b354f9f4370821eb6783f5bab7252a71238b781d94fe88fd230e0648950fef7c1cc8cf88dc8df4c3e89d97f07c2d0267920b06d05887b27b3f1339a49a64d8961e834a0f1ef855dc5e16528875a68712de4a8b89b5c5fedd0ebf659396cb3d31b17d32206aaf12b89fb84af498756e014905103bf8ec21fbfbcfe02d23704fe0b03d407b4f63fd4742e1f42127b2a159fabd7ef6df4f6364a7b5b27947243193d46d00296d011342ba01ae1e746b901b9e71dc0b29d7ac0086f736d53b80c4dfdde3dd45eae14b6e962c895fff77e76c7315a621fc08c451770cc3a4d56110c912d7bd4bf648abe6851afe2e569ec2ce3cb4131926be4fcffa7ab4c0ab761fe7734ace8ae7dd6cb2f647bd318c81cb29260581a96f6d4c3afe6dee73c84acdc568f0c9530ab115697195c4518c5982ff19c126fa44675f3d171908d8d9a7ecc9fcf3f9f21c01a2095174ce4c8822d863c362c4687b5a0b99bf688653de2a59d952b6a1897076dc7c5d8141f4ec7a8253b323e846b920a6cfebec6a4db0586f9d3b688263756399a52137d6cf3c9d769291b2060256e5400b57f56f97193cff9b7c63f0448ee04e277e4a4f7d6254b41a03e796203ef85cdfa76da675844e56f7c004c126b4c7ffed6c1d39288c8f81571d9f59d545e90b35cfd9830c03dca2ab75510f002f16167bbb7980aad3af2b6a30cb81070b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
