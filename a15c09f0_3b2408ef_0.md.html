<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2440fc18099d5db67e8e6fce74089e40b6088ee1653ad06e5eea9c6d74b21497e948b39f88c85913562bf13a970c0841e87512b8f03d2c291885668387f32cc0af932c4016997734d8886f0b49506108de26af91492b2fd5f1a1715a1923c0b7fe33c896d217456ae10c6492e953c8e887e17c142febe2829dcd09a1f2de817c409006c143d61846767a20d862efa96f41e5c6c654a1b6a20a05f9543a475c24d923ccf3d4eb508ae323e989d309d59634ab0b53e632370a872c021ec5d23b571eb4bfc9b56de0059f95c727a38fb303f32e5541056eca29526b93c76435bfd98cf1e69549a30740704287468f5f73047bc53c27d31ab314dc96e979bc49d425c50bb42bbdd3d5d71eade2ae9d3b6b9ea0d88eba0f95499b78c1bb52e9d0fcf098425dd9425d78a97ba1b56f67f520a1b695e5968bdb08fa0935e99cd905d7e139eb7b2e33dbf5732080f664177d066c4f4428299a2c209ea7befe189da2baec9726b318788f5365752d1adefd49a762dc0db5ba54efceeab7ae1e6eda2adb66188b36f3b660e05e8c665e88288716bbd83d4138ef4818f717cb06b74763cbb9ca1e99f0a2a0a2d35bb03e9a8256692a8d8c4ead38f85095bd72bc1393d992cf3cb3eb83fc70061220d08252bd3fd3d018d591482228a6d44f0c8a5e376ea77234f952fd8053117fa931409ace83cfb151db96b915b160a245bce9563c79b183f50e2088fa808edead1eb93acf04c426dd82dd9e17f59c809a6ba55d3dd6618385fed23b75fdb7f2705b73e4bd979542f2b741e473d5ec494e3c6f2b006d5fc1a271b956210a4e4436b96b092125c121138a5e70eed3da52af6b544d485ebd9d0e84fb291aabf01406a3d7c8c6dd7f0276b5691a437758f0238021f399d8a58257eba3530b7f89810fffd7181bc1a2e248b3c0dbc1e53c1f560854b375a08353e46861f02f0ef83b08d1e6b6c36da6934041d5e0f661f01f188ac98888102551699a771a7e1c5a9e430bfc01949f6bc2aa5d053e9b8cb801a2308947928194a7bcd2743f43a38197857a46213ea2c872c147c5772b741fd0f06d5ce132daf1cd10e45277d9476a902e353aa2fe7af8edc4efbe8903578fbf5bf1ee45506d5a4a42777977be8107cf338d40d7562302dc5f7d723ec737c4e6d6907f345d4c9b90a926a656b0f08d7dcd6b2f0801124d05d26e0a36812cac2a563597ec6549242237d7f96ad0989ad3d9d60c5f8e06e0d0e596715c79c624a49744dde05906d29dd4116ef513a13ccf9bb55888accbfe223adad7209c0ce09d9f88100bd31e8b511467b3d15a65597bc8f826ff0ded6a18a15bb49b59f8c0a248cfeb961714c7fd2b177a6714158e4494d5b8e7a18b35ba99276ed7f8331d9b47f8028bbfcf0ce6742ab431df863bfa393e47a51b2e0998b24fbaefa7bc20e1699eb1937d35d021b2ca7958f2db7dd364c4c8a4d701a82a1e48135e029b4a89030607829968ff5fe5538872a17dc66d4f83cdd5fdddffc7ca2ba3d366e678b00c093d02610710cdf08af1489cf24c908c0bdf10d16a68239dceadbd133d60785fab6a67fa587f8682d6f25f487bdeaa53e79600e846134e2515a45d3641248506f81621973ff8a576ebcf681d1d731ec7660df297e3d4b670cda574bb5893ed953e2eb0a3f65a50c79a763e0cf91a4230b1b718e947f2fd9901efc30153822fe90b9633f168ca0252f1bd44f15b1ce21429e30e67435504e8c78c99e115a58b5d3db49b2307b2cabb0adc6de8f24360ac76195fad455e3d9e793694a26396edfe1e7a0e608cc9ed27565a043ebae90570a3c742814b4dc9129fb9d9ba649ae9956e4798e5ea7eb210fc9f223370344d9b2fed8282807bd6d7bfb74d5711dfb30b46c298d2955cfd4d0e40bfeaba56ca9097f20300dc08c696e2613983e9c33e9d48957fda96e4798fd9867246a1b95c948194c366e809fe261a7664a76a1763ce34798652fe3f952bdf0629a083e0cf29f26be7a3f0398cd9974215bc374fffc88afd9715e0733d364608294467e5882e1759902b4ae4f785fd05292d87b2d54042b2b26ed7553691699d7b9a1fba3cca1eeeeb50575425a37297bd08f65fbb25e11120e13f5b50cea08d76757efed91e5f01aecfb9943375b88ef5d1d27db4c8a6ebbf2364887305ce9db7d760119cc2a40867deb03b5e28508e2198fbf1430043cfeaa3b7ac297772a2ccfb365695b272d796ef6ef734ef6440d55fb0f37fc29693e555ca95d29a3c538e83ed3a364a3f6e5b118f18fc8552a6785b9c5541f2bc65cca2fb683548c8e7df5763bd6c5327d9d1e81555dc0c0ec9b444288d1cacec2e8488dc4a9bb6a4762ab40ab9db2435ae908d9c0ecbc22c94ffe6a7f84fa912b74a91362f084362a73089ee6f22c04ee3035e12792ca20c1307e581883c083b80387f7bcc3c7c0df93a6b3016870da0e6213286995d269eb724c7a19654f525f5a32dad5cbe8a07c206a73ae113fd0a95d55a1f4759b9e381e6413dac616060346c704e603d16dff48ffb058e5a7fbc0aa1e941f3eb68e319bfbf4be6570e6d610efa39163a43d713413928c745588a8fee8c6c41afbb7815f39797f65de31a5b76e1b6a0a912e4c669e2960333f126c59afc51cc4c0bf8733e0e028bebe2da5faebde99f47c16079e41a948a9d68cfcdd055bbc5b752f949ecee857c99bfc3b7bd1d08e9625645f8ffc5eb3b663323b84184fba2d9ac2fc65724335321073416fa4bc8a736ad580da393016b79bf728731caea16f0506fcd5b603045cbb01171f3d49b74dc79878003c9f22b11f6d1f21faa8e53f9645c161c20c45047f711c523857bdd597b883aca95d01570edb8fa8bebc8adad6855c2c25719d46dbf1daf290ea7ac435c18a6332c5dc20ebec7112a035a18fb44329995b36cb742d4a1ed8292f080d8f5eeb917cffe4209af31e41f5c0d10980f1231e8acb71d460a0742250b1a00fbcfba5875cc31b6bcf90facdf3dde468cd2bf3691a1e119687ca098ee2272141e463dbb9c648dd615e46ca005e4a28f7ed4276cde6a5d88bcaa7ac917c58f3bb536d1e7b53b6da18bf9f8406633248ceac5abb8ccd4c02686173b593da7e448bdab3181ae800e3f8d70999f59eeb53722186de8f1bdf3db01aadace425a2f6f53491c13e4092941962fe98aebd01daa1595685a266dcf0220fd3b9a5abbe328fcd31ff91f76f168c5830575dfddeba51053ee72bbd45f323e9782f7cda991dc505e1b19f4a85eede6e8c3c1827fad4a103156bd2c73d001375693257c93f8054cdec38f3a174806f7169233299649348522deaea95c99c6269c0cbe276061ad2f1357b4d2e343718b94c8f1c4515286f689eaabae4b01763fd738b81d4d346324e6f95b8eada7cf679afe9d8e3ed177517e0c2c6d7b8f12957ba21603416c04751b318d3209b7d4504b444ebaf3c91ec0ca7bc48cd7f62b23221e98adcdfacffdf2fe833dad557df00ae102b5879454c0c77227e9fe9ea17e7ee29c5e9f5e9a7a3118858f89922df1edaab84af041ec51bd4fa6f37328259d2dde052921f778683cfd61e146ae67ed7a42db2d547cd760bdd6fdfd328327d81c4fc2daeec5cfe667c9fe76ed072d101462dec63fdcc984d8b554fadb376c08a723b0b499981787e8b64660aa802daa8be71eebc4a06dfe1affa67340d4e308a559823517908e8c41d05ba928616f047aea314450ee7db9f7f22f138fce519ca5e8d518675294c0ad03a2e77a307e7bf9883225a84564b73f2940cedb3a317b3ac1a41d84fb00281c8720c0b371976bd69cc7425ad41bcde371b256dae7ceedd5d6c95305d2551c68ee288fe216d6b8d35413ed0ff956a2226563d5bdadb69cc7785504e63993fcb629347550f232a9618521f679e9bea48717f8dc9d5005f479567d353bd8fd9910c49ebb69414f513d71fc955429b2481c23aa367e5d1d11563e715232d7ff50b29dc80af39d8ddadeabe5db5dc187d1844074161377f4e9c4ea9c137527742f36fee4874d8d83c41d5876010c08a70fb7ed332c8225c2c7ef6a0818d7aad0247e4d132a29ea3e9fac74d43087937123a4b9a1813822adfa5c4b09d7df997106cafe528f18531054445ee8e3798fa66696f59ef23acd41c630f5f0b027a6de78effec10821bbb5f65c778b89e246507b28e0b90109bb7d645eaba558b6be05a00728a39d088814cc6849753e3a9f06885295b38cd3c67473b339d38a81481545ed7d1c7c17d2b12b6bc234d3e3a1afef7f311609a3760bce55eb5d42504c15558c0571b0a75ab4725be4ffca768aa3bca2748b3eafbb916fb8be80fef4d25de9498137f9b9f869f2e47d2bb61c30b6a11f8d2c057f293d2b111ad30e0896d01efc9d64ddab492a27cb4412c86101732318fc8a6a2aa40223932a0d8a9359658f7c1c687275f43767f6f5f815913c67cac9fee3ef35a2e3392ad2db6c7fea4a0ffa43f938f516279d2759272b194e792c29da97b062fba2fa28174fd4d748b60258019f9a935cace0d78b1e0cd4560ef5f1ef96267c485b38fde316e54f212741ff9989f3ad810257880d4739b1b103a319587fb3356d44f6cdfc0c6e5d53e17635f21e503755f92e7da270259445386ec92053dda818e08cdd9feff84730124aa0eae131096feeb44ce72253538c1b0e4fc51a2b1b82c1bb9a21379d4cf244a2332ff7ffdbe20a588f165e31c803be0e8659d21611e498b324efec7eb0123c3487fe0eddd9cab3483ac60bba202829c0a7167fd5e3e58e20a5eae707007d903d75a727f9b8fab29890d86405ffed1674f396146d4d285b7e4cce5dd5868baf0bdfa48b4e66f0d33c4cbf1dcb144e2f2aa6949071a9758a5ff36bb09917fd2d86290364264cf1d34052c7139146d95047acdb059f940c3a431d33784aa2d7312b0d2130fc803bd8a5e8c009adf1f2bf68e94b1a08f8832a08657baebd62cb8be970aa6c20cd954219fc3448cff71b81e69fa1a2ca79511f8bdfcf24eba60835ebd29f55608d707e1d661c1b5be4570edb7a179d264142cc395805cc76c4d921bc317acfe86f4ffe72e239de776a40fd26af33cbe1b6a55c874c83de8891141e27f736d23aab1216ad403094d1db084bd0fa9477cb2d381bd04c118c8c5cdd363ab267aa2b1db5c70d279a12dd88ba49b035540867593d761260f7ded0153330b2d1094e8ed38616488d40d998aedca538de0985a22bd99ce202dab7bc2b0e2f5855dc911a8b97256305a04ac9589808fd6adad0618dfeba4786f40a2d7fd4fb2cdfcec682ec618f7cb7ff7ce37cb8bf782ff2cbe3db67f8f59846915b6f0702386a89add26c7e14badd24adcb86ee130b89b2491de88d96529dc5d9e7193bd19c1282f9f1cb636b3d8f802f4022f71896038d6bddd4849ff8f8c2780ee4bcad6f449afd9021e86d45eb06c3d9c2a613ba426127e703fbf18be6401fc3abcbd8edf42cfd19ab3bc55306307b4a95a70e23af4e7a4c0cc784a00c9149ba505430e63d043ddd5bf5e3fd74b2b735bb10eb1d091131cd5d575f6b46e82ed05ad3504b36b71ed225aa0abf5951781c48bd6a0080baee27298d220028cd5e59f7f7eab2e3211be3fa210849aa3b12044c99c4448a4688f28d7fefd3f13b4b5717ebc7ea74d08dcc205425eb7e294c48cd30e37bba9942201d8c36196517e1b2ecbffcdda7331186b50267343fd302ee199c1a9b4dc87b2a194786cc7b9d485c5d79fead79b77fe754d6c5d4afaf66654aef25d7368705c081efbc5b74ed5ebd43a87c10c1d1be8700b89e8e0459905edd6120538d808ba6987ffbd8caf7d16f4a060236256de8463c59de7c21166d17b047b44bc42bbe0faf0a0c45c9d77be477af9614602396ce4522431345d9e717c936b98cf758c8a172cfefd51c4db88764212221925ab35cf1c8a003c56717f1f5afa52d27914cd0dd652bb0138e7dee15af32b1bc7bbc7d01a80c6fcc531bcf314035606c29f07c8b79ec40cf796bccac5b4cd386d26dd3ad4fb220babbe73bfe2bfa28d243f35cdf927a6acb42f61482d1082f4c28b7dbb4fa425a81e924f75d1a1f6f57dd7d5f0215690858e84b22da5a46572bbdc8f0c8363af7da79e83ddcdd44fcb80149f5c3de3842ac2edba4cbfc2fa79395e500965fb656954813af422882ac31c2893fb17a53b453c91ec96b813aec539a96126764c99fa82fc8d009a6818ce46f59b7be51725597a9f4309f4009ed42e42ec31779d314da70d4110a712a60f4c2e802ed484cd0d1a9b06f46e6f594308a105ed9f723c8e563076eaafd96fa394fec08a7f28372233dbd13ba1db2a9e8210f7f0211cec705de0b7c043586f93090e21a8728116b834fd8a31617c2a0c49063238576ca2d7fbcccd3a95c921e4a9476b39bda9c9796b617bc63459dbebf665b012183759e4a45f6931e32f83cd3e7f48178cb6a9e233b4bef6ff3ef52c8bdaae78c5869536990c145c908f5d4b039b737ea911bb203d5408b836d4b0b4fd99d84ce5690a6da29f210895e1d47cdcb014a0a41efaf830aeb328ca0cab2e1fdc094e911018c78d88c15614771676e991da44f8ae3b5fd75965793e74dd0c6737ee426300b47547d20667c143ffe75bf410a0778dfd7f1653b9ea5306c5dba2d6d076778c46aedd3386f9eab67c12a57aeec8e2a10bde014923a15528d0da691d0c5e4849f73ab1a2a22b725b5a12559236a5a03cd879100253a80c63300f6b42e356d5b0a25096ad3cff3f77add727bf5895158c6486856667ab91dae8d873a835de0d7fe122d61f4c86e319286237d2c6f21f932e328a90f45b9ace37cbc10e32fdffdaf4405a550ab4caa9d22dbee68e10925ad8229945bb5cd260eeea58a2d6c214595d86dd3bf30080312d77f5ab3afdd2c2817a16fa79f95de57bb094a93d20326c51bcc19b27f05a31b7ebf35fc191d6272974e45300e36ef1f0096d9d62171a57f13a09708c878c426e33f43063a1ec88af3f34086df038dbb28ff093fb0a5c3b03cfac65db1494e48ddc2d7588fa5dbe3476c7e43b5a06a0df749f22ffed87193d2df0edbbe8cf30c5f836e19baf6385eabc1be5b49b0407b30020bd772aef653e1b6151eefb8e60aecdf80892e9ace7a7cf6383d0ee7511d9c8626fb87890b0d533e5699523eb8b314511cd65cf61366f7cac3aa9fa34c2e180ff93dbbb1eb8507cd11838f8be0c15f87d5fafee005b750434eab5829fa7a70a95c2bb0b3f31d17e10c63eee250ee6359507a1e1da55d6168e4d9e9b74d0ad5e156fe3d28db4558dfb107c71f536306d03118b641b7e18230fbcbceb6a6dcfaa484c35bcdde6cd46d6ea292c7f3621701c3ae2543876bb60e977f7459bf1d324c80cb7a870cc4db8c709f7ef8bf13355ccb1d5878180d7853db2a3a1eba833aebd939716f6ebccd5b6d4fedfb71c7abca74217fed8a3cb1138f0ff3767f53fed8bee2fd593d27d8e45260ef9f59e84df40e5b14f4aaab98b189f9a584b2b72270f05585009f170c05252ccedf08d01ead08b62aaf67cfa2cdd4272f35737c419f8af3bdcecf7d5d76feaec8b2003e98192b8af99a1768715c41215376d7e953eb1cdb1f1c6375fcb8772ba534c45060f8dd0e85dffd4f8b8600418447985ebf066c22aa187f736286e98d927bddc06a730061ae9f6228b70bedaac4bb23ee9b84255a530dbaf660b86b79703f5eadfd2bd69dbcf60870ae83e1ed58fe68c1301b4027cdc66762e17627274334a0aa575a0990b1edb58a3911f785d8caa3ce6d5cbdf6116bf70ebd48ae304b67eb8434cee482cea9cbc8814112d51c67ea8a075f1636f906131d35f47a7e2051a96c5accd521d789d667b62281be434b796c04b8fe3a88232fa57d1079726e007dcce44ee6d401635b4d04fc1b9355eb24cce30ff2c5011d742b380fd9753f3d59ee14b9963ea7978ba01747655c4f80287d125f62b49b94568cb4df95a020acc5171094f08d05465b3c2faf8ac05ff0a1f1916e1dd41c7b8f3fc0d00a4e36e778ae054ce31a4d9a1a4f8ee202d0b96699b230e2287f6ff88056de1de05d3f6e81ca3d14f354a1f677b43a053c4e1fda62ba1f548f523780edae5dc7011a2b330e7f924d70ac2051a06e1a4750817bf3cb4b8421c7b7ec6590545abeff3a2880ae1e19335e1658f8ce9ceb96277cffdcaddafadaa5f8a8b0bd9a9730b2018f41a3f87dc7516b18a2ed76880140fb11195165970465c0abeb21469e126928d68bd1f5012c5877352102a5dad82035698753b5256faeda682ce2eb3b032dd840323af81d678866ad4245db560c12a82728d41e8cb5515c493106824859175db430568bdf3395b02ea4e3cb1c854bfe4c4f9cc531ebd666235f094fc126118aee46d3904f21a77f360f0adf664f12c9e77f7ea50529329aba55a7c27a4fd1e13dd1fde131b31e54e9e1d810f3a73a71e6f7fe02a0770434bfcf904c5f261c7da1e36665d1ac66cb045c73ce281e55274446589e230d48aa51aa6bc8b3e64b85612a79e8648afaf6709cf815f66364e04cfd300f0b96d988adc4c66d9de25fb00f856f13e4d640a434f147e9cf21b1ed684b32314d932acaae3a1b66e78a176f599e3d6d4c4cad83366d62518aeca6fea37bd18e1480244063ba0777aa5151cc98b107973804fbb47495f69b2f86ef3d71dc3df847bb629c856816db0a69bcebbf7e61dd1d0b6d70ab29bcd2d2f970b82eee0f0285aaa4684c59e4e22d70cdfc4d637a62e0557527e88cbdb3083c8500d3830a4bfa0b00833d292e07fe3b1ad29550ffd6a6c41a94037f8899a2c694944b9553667dd04bed89ec8f16b9f3cbd087398e9335a4141887ee13cdd1051bc3cfe1b1240b88d861edad782436704b22796d714eb34ba8b00fcf161859bf641951c6aca81361c53733971c98ebe3aa4330ce7a3c600626feaf37d66a5e49a26b1f3ff7dbf35b67e9fac0e382d129bb6244c73682fbb8ce45bd28c53296e94c200fbbe655c72702a549496758387a0780281793424f67c7652fa3a8f6b92106bf9115c90c8f3db62c4f0b9e3ab039b8b4ef865d4d91176a23f22c1defa167a4cff4414b4d55a933acb78815a86cd2f26322a81908a2d9db32231d393937bd8019a37c8e065c89c2f1b6fe1f406004fdef1e23927b638c8f2d67e007259857e5ce49d6af3fbe024a6ebda3b9a3f65b1b7bd2975080c92e934d562c417fbe5f8d7a6cb979bd1ef691dd82afd6c4707cc077c079fb52fd225a1e819f6f396ae67449e87741ed11f31982f3c4642854692ef6116c41002e0925d9bfd83e1250922e70f67c2f6f204c0415f1930e91601a5bafcf34c8fb6fd99da70a0ed627d5654e494f311bd3fc19e997da27bf2020a5452116687ca18c3bf234fec66aa8086e76309d3e3a9bba47e64ec84aac9bcfd99b8003c3a9c32eedd222b0926a37dd0493feab134c77ec48cddb0e5dccf24804bd099186ae065c7a5fdcfcfdd5171bbd897e1274eed541396eb9c8614cbc05463a59be26e0c832d25fe183b221f7e753639956ce0027054c78d82f8d904bd199b789c297c8965508515d590b7b569711364d4142e69a7671eb8c6d4865566d7472160fe8a64a34a08555ac305e8f0c62382c88efa2b0f9905fce895caf21fe435bebbbf9be0d2c7db268cfbf9c6a421cb1872420704d8320206a41da28d2097a52fe86acf953dde46ac8f719eb7c1f9a0e4523338224375540101e6aa31be95ddd6491c3c9bfaefd6cc02048dea722ed823b30abbcdb9ffd941931efee30a32ac4cf53614f34d47ef61ed7d5d059775287a2ff08d50848ca5abe00081003630045925f1d093a246002dc98900807aa79bf0e565213866f539eaf351d5e71f93e952fb742aa9841bb44cd6538cfca193281d0d38650047bfe1e6213b62c58605adea73b51ba8316fe878ed323fe6f7a7919b5781dbd8f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
