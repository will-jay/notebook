<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7be27c1505a2c1ec6c5ade27e135dd002f3e376dcecf577ea8bd3ff4d7673d4daaf028f538703aff9a5e58ba82a0f7b2bf94aa2609e4138d72291ad26348b70a8f38c0793d7aa5c55647520b2c98a900b665551501f2b5f62f2105e56c709fcfe490199e77c0c08cf232406d458dc58b1726889d45079f15f582dfb530a211c96492ba5534216bff7bc8bc8eb54e7d865324a062bd34718f2c4e92ba2a3cc6154a9948fec174de59f4630c3295e79e86c80eefd56cde53a5171daaf0bfc64610740eb8ec631fef8f8f301af8cd272b5572269833071386a22f7db56ffcfb387526ae2de047a98fed7ddc65f0329f2f480af54dfaa34f6f3f90740de92f2710818f4b4ebce1ba4af7f240926d4c4bc7745830b6824a0ca92276102c19afce8a5bd3a4accf51e940ea570e93fbd3c0fac808f7dd57a21e5a4533869015e4ecbc2e1e4be5f85774113f180f13950ef570cf63349697e962b22380936a2ec6572535fc1ad1ea8ddd033d338446a2dd283d6b3b3bd8cb783fcfed69af49ca9297e7de82f79f1ed3de363b954eab1712335c155c25e9ac1b8c204ddd07f6179cb9351fda4084de0b0e7ef014aba7e57ec50f0b2a4683b095fa1e479de7e62ac514f89c1ee59d1b61047916dcef16f18f071442f9352802be757a397265a75c8b97016ab4eb0c8fab7daef2ba866d7e9f45937c7678a64d2f42ef6e963bfecc2cb4fe6afde3f6358ed9df75c01008e31bbc6b6b98753bebdd582e0cbfa144ab3dec867784becc54341abbb9b3c70872d4df9092187485c020310cde04cf3f5de4ed7ea6f0a18ee8eab437df927ccfbafac4985eae4251a410d0033acd894f42c2a257a7c611dc0b86f4f97efb6d15441865da873400b6d93013ca774874977f43be0ed517067430ce4e3d1ae99424bfba18995ad2348ca6a372912dada55f76aabb7403bca384bb72b663e7b132bfd3029739f19e89c7deaa9856012cc987d8a7ddcd94e87d9f4b70b8b15a1a76fc71d3c98f8a4713827d2de8c010b623770e5971805c23fe4af3a5d2661803eb57c412b3d858ae5b73f1c51ddbdccbdcb5538baab92d8bcee68ee67bd0628dc3e18ccd92a878e120570c324c033cebc4940d3a5e81e6d6d1428bba14b37b1cc5aa1f4c9ecf73cc27561e958dd083bdb0a05341cd2b238369586e24e1e502959428b694dc3e8434efedc089401bc874405bc91adedc386e71e1e6f7dc5a9b2e4ba97f637457b938a42daf9f363a2fbd55d1d2c5db48aa60a438b738d4c4e8e990a575d63eec1f0ef2169b3a020ecd3e60cc10bb14192ebd51f18353bb30d8327cdb45962964e22a11437b7347b2c6662d081ff8f9c8a14b1ad99f25418d4fe08139964cacc420fcb206a0e2c5d9e72f4e9f5b15ca0ba164e7c7e6b4e9031de1475895ea4a6cf05635676b7e74acd38d8822fad9ddec49d9a4d3d80cc75e496c4eec250a173428a60efc0b3daa66177213b3f423447ac5758d07e34316a6884c2d5aa6667ab86db108a415e597cd98062f6a5b48e407efe835016fe46edc2fa819b73dfd34cdfe986c47c0875bef9665f31eefb6cc0f136d0a83c4310a5782ba79958e188c7bab9544d3afa9f22d6a654a1b48d723263d84b45f7ef362554940d3a951aa4dc6a25b40beef9328b3453388a950de2e53bf5d7458485d36ceea5edba425bbe3f368d0c28b3f799506be260a12fcf83f164814c76dec6bc4857f417405a9dcc04fc3243dee6025be51becc93f6b4904361e94a3f4965c193093d3733116d27cfa9193a78aff5f99e23a57729c3ed53529e49cfd1d1f2896ed802cb4965f7a68c5b84ac5dd3de45f2f47e3802bd7667dd5c55743696b2d304407a57e3d7ed61508f611be156c1f94c18a0cc5e89a6b329bef614d9e741d2a6d68075c98427abe72fbc7790585172036fe364ed3e786d886e5502bda30618b6c4776559d862c14542becbc9b0ce36f186227b11710a00906d963a30ab4bf45dd38a658e9abadf081e61235a64cac3fb3802754903213a82499fbc12f43bb28174ed7f6c04c62e8f423feccdc39c34977a0137218a47bccfc505469e89f485fc13b806f4f11f9c500fcb9a512e16230287c22f263b7a841558c579dc48ebdb8d974f14bbaeb3dfff19b40433ce3d6884aced090749a068e58741e8fde808549f7072890e5cce617c5888ba176e6de762ee11a973475002d1aaf5af322156cba566a0b5fc8f9146a65c18470521c4e8a0c6219de2c9215bedeb97fabff159a77e3994f9db7667faaec9d7b865b2d6a32a02e7e35e331b9d24e95d67b4e8896897f7efb08d0b070a03733993e6a565b93c81e102c16b154d81220c6aface42a3ed515b1fd6375c598ec8c65295080fa896e8a9131c08e041a67986d47c3461c24cc6318f4208439e9e2e4943b0b263de89b3263810475393dbc9be271d7c61443d451d89a0f206e4b9a3b8063da89646676ac6c28506de5e8b84dcdb94dddde7ffd4e624ecfd43d4d5608d563eb238cc303c27443a761feca95458459b8b8b5dbd2162ce3ad58951c58de7e422c9ff91652887e725fe205e2931066e254a7ac52280a504f3533fb2aa44da2bf1c89afc9e7099d563395bdf354294c3b98d7dbaa85a922e43367153e115892c570b386555ec90f41efdce0a9bd56b87c7795d6570b08e3678f3da2536ee6eff4091e48269fb912d5c8a94eebb159445a39a40dc8d55464be499b7977e026184f52a843eea17f3bbf5cc49d5f5e018418f42721e51c32b9e88cc8e15270bce2cd30fdc00b37ab96f80116acfc5f93bd03058855dadf50c741a7eb1f1097eaef4e00444c71b4548382010782bfb5633f0429a0f3a2760375dd2fdc367155d0484578169b2a62cbbc25087b120af3d15589217bdf4a97e16a5a0889541c3764265f65251f617078e462824ab59d5fd567fd808142398ec796fe2e8de609a9c13f51502368e8732d484fe32f9b86c693f5f72522550696650d02af27ef1bea54afd7745e65d6c0a903c3997a0769992ee4017a5ae20c4c7ca890669b88f06755ee48462fc87ab49694f85b0e334af26ec105f8297a44278e7f2be4509a7936ea192a1ce40ddd9473ab89f640fb508bf7fac34d3c430717798899bb21d05b69e05ebc2a43346c5b69feb5b4634d364824267bcbad7c70e450cafebe138b69d6013b277d43aac2021a12dd50ceb5e2aa58ea997ae5fd4b896bd0e6b6f35197ac5233ddb2fab2218136ae70a6118f91d56048fdfa7a7fb48164fb56a1c96ad81f80ff3b2e5ade4e377207c3316ef458945d751f8979a5f031fdfe637f3be1de9cee8d327494d171d45f6abae13a87ec8d5bf48bc2747ff77b66a935b26bde85ca42ac162af3da165b78fccc37c027cbf68c23a4959071635b06ffbf844f062756752da13985311779841dffcd21ef4d69fa9d86e18396dd74cb978b5000f2ee03c5bc1ea5ec4cfaac8908217750ff31198c2d2e87992cbc2eafbec6e55d454f5ef1a04e21ed20bdc89981230e099f5c78ed88b26445af05e89ff6f45ec07b138968efcc8015b344056d08b5cbaf97475a6a1bb124f7cc9069adddfbb28485307c64f8ffa06674f854b27526b03f6d19ec87b2bae8f9a8afdc559e5c3e0c3c68e540ee110e7f88fa016ce1c2bc468d3e27faeaae38874db46a57f01b71b3778bc8c7460f976db0722e5e80a53ee097566c7a4ee0689d6730460b361bf1c9d6b3a7ca79612a6502a71ba8f41680088510547403f7b0efb684c60c7418143b1c89f1c8b7d2771953629ac258866291daef3b6ccf1daa620474abc9e52c3b22e527c4edb441f1c1888d54b6fcdfc2c07eda98bff1ddd48bf452a4d5baa01cafca17944c9aa293a954826da3f6ff93dfb3afbdba57fc2c81f4fa2e6795099dab236770b209e306c334e9e767367df6ebd7a5c42d3864e0c84eb75b70234647bcd32cdf32038251c5387d85ee4dd953bb4f600aab9e5c89a7814aa685748a211cd38a356f95825c42f3b02cafd289f0462ba1cd8c736797ac30237542f15cafa4ab17a7ff25f8b080cd5dbcb51e1f2e01a394d7df7333e98703c9c7f4fe561d5ee89c37a7f512b71c247176421ad1b1a7c0d53254f6f8a31b0996cd6485b2beb5f701873fd3385a8b89630e989a4cc5317bf36dd76546b970c64f2e66522d1096e3cca67633a95c49e6ebe9a4d1928ac378340d34d2f83550a03c2ca6ce19df0f8b626f8e8e3e93b4a10db3af7f8ae32dd3df64e642d5b42a7a501a9f892808de8f116abfe1bea9d82724740a506468a5c317121b953d0a5a703d92d0bc9d97957700a268f8f970b0f251971e17d3dcdde95d7557e79b079a3ef2aa6550cf6f1fc92cda52903bf73eb8c5e6000f70cae7b38cc6b244da94ceac2ab1c1b25bb8ea2f854382458380a79c43cf839214d5927e2da1e467ea556f0e310308283978e8891bbf18532aba95d49b41541521a0481fdd34350b6401b806bd6d956ab6e942fbcbd794d785311055e13f41915b5c1c69be4bc8085ecf06cc67447729a6f370e2d059bc905fa55411549bf913384d8cbbd25cb63842e7a4af498359f61ba9cccdbe54acb54e4560dfb2943d0723fe68710ea78c6733ae8b5d42d6043c7015f6ecd27ecc3ccadcfe081d5d5f8a9d153411cad662e91937f3c2a7a20de527c7264ee8f37f129c0abd9036350548eab6527f29129e805df64dd384b7a20dd821004d9d2fb96aa22802d82a9c7a27efb73f3c8d63dcd92f895a2b90222345356b0eceb0caf13c24e0d817b78f46b7d99d6dd68d3507f0b00aca5f18a2ee8ac4cfc9ca518608391f9e78ac66da798a47ae02f64b55e43b8cc491a2deb0282231a71695120061fa9a155218c6cd411d68d82c4c6f514a13a8bda6411168cee5e63f40bdb89321759bcf41c5a35e0a90f263609e4b6c6c12334367b26fdb225fd816286ec139acfdddf6511ad0fa06c0d04d9ebb58c697460baf238fb415ddbcd6115094c4fb582a02765862d0c790d01c56e5563b2b9f5f70d1488d5ed51fbeba1425415ac0a99839e4c6faed4b841a103d865f60a695b9a76b60ff32d27e54616f151c5ce94f488513e6d62796720057bb4647b7048cf79aa1fea4b59b41493796bfa07d35c385d522f2c207bba26c36efbc266780bb5bd08127fc38218eae1859caeec06b6d8e9a7cdddfc2196d4fd072d6b4e40376ae5f705041b99206bf3c7c436fbf77b4c51441d0ffb10af45759d9fb617912e550c8268a48293cbf2568e5192581ac875e62a7eb6e17efe0bf7797aa8d395e86bcde1a4f560955b26729165dc7191ee1c598bbd019cb4721fe1a33791d8a0a8e04957e59173b8d63b28f78458dfe3b214bf2ac56f1af24ff497508f63befa1c293d5fc425fa75ce9974c9d4a857884c912aba8dd8f9cc2bd9dc0e782b4227114a909ed7e622e22e4e768aa32296584eaf5048c947c91189d902c33bd837cd076c2b5d9601ec41a1d0d48e5db45ee85a86e348cb60b3c1f6293e7cc060afc393cdc5c607b040b2aa72c8a2fc51ed8bb9897fe4b3c21340a9b842be2fe763755c42f28f3a23d7e3bdf084b628c59769fa2de0e20a2c5f74b3d6d8dcaec37123e404d739a81c151e43c00e960b9cf062c93eb6dfd17c5607e7d0b2456eeb0185e6dbffd80ec303c9c4cc4c3298a09dd0bcf63e0fc1997dd5cfce43fb31b94c0d5e5f107b0582ee14bd793ad57b1abc8d14fff3b51628295a8acfb6803aa89a11f35c37b3daa46f6bc44ad87d04ce02904000530a6b0f2848dd0e0781df4d2da104455e03d45b33c243a04e4ccb2adf0698aae4289f505861ebe2bb5cb2f9e265d9469e0ed11d2974bf210843f950b5e9f7e5fe6048e100e9092e09eedd5bf02d8fc8a76754bff8bcb1b94229dad474cf6032709c6e5257514ee16912dd9a7be8a6f17fca1ecb4d868f6505a6a3f493a18899c8f8767c4539a32101bc27672728a53a34504c48d43c91334a08ae17e25f484318a59b37267724fa97cf4bbd5df1110860c8836007d46d2d1c9374596f1483cf6d59d2183797e2cea4771890b77de030baef6463222ffb5e83b38a71f450d54dbf734e84822f54d923ae731a98583f0993b95e2453e3e2325a7cf271fa642b26229dbb26723921980a9f870c0fc32ae062762f0ebd9fc2f08ea4120e5e1ee29d511c6274ec08074eeb52a8772c2aa714d2864a254c09a8fbd3b4e6c93739bb8a47963942ae5516716b28d623196cd7db44846321b01c58984d938c7a590c735f62b7de12d4df0fd2a51baf11a63b0c736bd19d20aa3834c88457fb78a3395a34ffe70b6153560d088e8d974051c31fa506eb02ae275962ad89a6cf274aede209b0ad724e20fde2cb4fad4e1f69bc673e98a46d23f87d8b3528ddceaa0da459baa119a3f69008f1fa3d48ef58c3eb333024e4fcd9591957b08b3cf3998d5d310732c2dc88de7b22e68de34162e7a7bcc39a0945d2622e30b3b8311e07c34d5600a2c30505b0941e817947f9b2eac2d8e477c6d7eba152862bf97be3d6a5deba4511b08bde5f651e8b3ffcb8e84138b150b687a8ea43538a6d3a8525252166da8e287c785cb8203610c902b30ef24782fd0d17a214c3d46df7129a7910934941fbc0408acc7859b3299bcc5cb2c7947aa5be40fde9f9afdfde150e1eb42461f02c5647c6574747970a30495717149cf4f66d3d171813112be7d1efad05a58f0f449ac5ad0bdc0852e234dccc335664bc34d115470ab1e3c5dfdf050ba18197128cf1ce1cea6750b6bc40bff6d03e99c7751d870ba02afaa187d4460a632929bf3971220246aeb9f49ce2e48760b92fabf816fc648e5dc018d9e06bd060a1af80ef1d170b459c1883cb9a30ab0508db04071674f538179ee35c4d0a8a2692c788055f5060b3982754aea0c24ea3c7bf23e228824b261e0770a970ffbb496afe11152d785db1ff65d4e00a9a41218084eecfa3bfb33731e9ba74da63436e34f87552f51a85eb6094147d7292b54b9c3ee1632f257f6a43702896f81916653258dda7f520c4d2d73374e6b8a950d4e9f06cd478c5469fdd076d36fc2ff3b62f476f6e3aee5723e51c78d83c0758fc1df18112cfa390f8b5514794a24d14aa4c5c7620335d7086b9265499d1974e8df4e8f57d16a593d38ac2929aeb3b7e6a12bb35d63cc67903415962a093dd06bb66a60cc9e98c440a266e4861a4255a1b296079e5002b2f6dae5ca8b28147559c32d2bafdaf0ab3862d8f06be34748a0b53038dd75f179d54e89f18b0fa8309d739280a4e02bee18501dfb5b0c63884765cb668862dc597e120f821d9014de59af197cce52c9892f14123367f722ae71f94d34aa8f0477c6ab6328c6103722747565f87d7138004af737df1bd4831b11361f50913aa8074305ec8b29a5fa40435e9161b5274cedf6e1d39b247408144ca534b5640ab293d82fafb04e19f7ef92707d84ec3f6fc15fe0946875c3e693af6a0f078e7d5fcd640755ad5bae18bd18b484462ad22b7236a1a24be18c5f7d8d3f3f57954928fbe4d60d9110e4a71e9f01dd3260e0a46fad9a48c32c4818e0efb6243bb6c5c487350188523e582e61c4eece5ffd3eb0680194f531bd9d4e784f160126cdc9c0ecf60c4635c609d53ad4a7e686bc5697517b77e8212e1894e80dc232b78f3655af7308ea72beab88f22f19bbf218642a381b99efb7873645b345c972434471208f8b711d8031eb08fd7cc4495243c613d0561202bdf89c22bcb74cad3c31e22606163c60b01f4c431facd4738881373f041b6a8266f931c51f1eed6ccf37c86956008c7329e3c7c904ae074ed2f764b72c7bb9dfa25f081fe78cf5dede889bed205ce07d99c38aaac1f7c9eda22854db3b3423a4ad8f04be265ec90881705ec9f2d4ea496801330138275dc5a8a5761d37f92421c7749ab860bedd05fa19bca04c46af3b43404912ca2d1a0d8fc21cb01d8ed7d7b3c7c567931ab491927219d6d847961dc19c046de131ff2278498bc91d4bb5ed23c6f156aa1945d60e8a8cd1df5dc94fca40f378ad50ec726665c50068c0d7b69a1ab20cfefa8653ecd0a0967511342c6514dd1ebb0a85d0b186b115bdf51c313e9c3f8c9c32952d9e2cdfda142ba15c1ecf4405cb1385f261012344a0421752987d98eb9a66d31fa8d30085fc8e84b04f117ae0f86da20b293f672b50226dd0b2ce0e2539398065a1b3a4d52bc2b0ad2fab240fa99b0e2e54fd49aec12571029f5ae91ea989eb7820398bb2b6cb31303063d27cff13a23765994d92bd326df6a7b249512ad12c7eb784ca3fe0fb0812605d879fc1fb22a98987bb0c42e94b2ae431877db25140d35548d800b3afa015ec5944891b84b521389609f0a7ad53de54b485b94aab738562913ce110003314550c0ce7d98b35ce5b86b123fcb9147ba325a8e7bcce54c1af0066e75381fe37b709d7dbbcaf30b9ef91c669eccc5cb729c9731a4a214269b17551637c88d009ab96a12f1ef8d30a91c9f6485e93c2c1a2e94ead8f732953bc5b6035948fa4bb80eb6b1487f17bac271d2681c6c9bb757e28ef4633bb2957fe79c6bd54690ab3928ab2c009687e06c1d734f4fbdbffed9e149f3b46d089d2509c25a2e06259d420437edf6634c1edd4246bed6460c3b69d1a0b1d1a90ccebf4962dad3f3622c64d816fe0982ca481ac41b677e570207756bb849d222a482bed521b57f471b20c27e8ad5cc6c1320a00af8210131aafca83a0f6f71100c85f14083fa6a378f433386feebe8d127ababca0ff778e57cf707caeeea8a2ac521bf9fa8b3dcf934098c575439e16937ff4b0b2138f64a130856a65141a28dcb6a3813175f60f3e7cc419549de68a441bdbc45ccdc29571cddc93fc78f02cd08e09706d7a1aa8cb75e0999461354438427738ad7c278be783150d14bdde4e2480504b1dfcf675a8225bad528e4ca4198e8808b182a01e05a69fce66d05940be7b87674b2943bc9b5c451ea778b5b7e39ddb75cea0ad935da37e44bbf3b3ff1adb744eb9bcef9b3a8a8183690b8398c086263bae8b560cc7eaabdb8e5c678526fc2d6f750b8d1fd36c3c2ea8834d1d8b89ad1c2fdd3c9f243286edee8a06b89aaf184386549369858319e095cd1fd5012f8662e543e9128adb71ebd8c6795968b60fc81c82e440c8e7c0e78ad6fb43060005e0e0d3a2ceeb5512007ede3e20aa979adaacab47bacdcd00ce99b76cfe8c637b2096fcda28c39658535c5b99f6e8801b83ddaa8e8c29e72be5f1101b8a20c13b9c60354e715bf785d7e3b928d2c61d09387ba53e826d8a67f55ecdab2d80e5ed7213f54c22bbd9db707eb94dfc359a09a1f40c3a94011fb0ee08e7135151fb5b5096e955124dfc42e7632ef928f0c6d28510c8a99d2df4accbb461a0b9929d81499550f91065ca9fe76d09bec3252949fbfbe203cf3f91bb43cf9be58a2d89ef504cfaa9a8537f1dcc2236ebce13c6f7f3a328cfa6a341937218eb7d9dea7f1d4ed9152ba2673d440142898249511ca32b5377e0a6dbcdda5918d1ab24bd8bf3c258b3879d9fafaca8d6463d170a0adb145e1ca9864dfbc28fd6d7f8d868b7c24b332042680075e2de3f30612d684124cf40d6f0c88063e49349dc0bc3e8df0521c5311a8c7351b9e95f9dd2007711497b49ec721225419bea92ab09cea3dabab0ac1390635e3885927767c3763073714c486f7074adcc4c1e9403148be71d39f38fcdc8ece5e97eb7ef390c8a2934959a4b70b42fd68835f720f5fd1062f255d0e109aa2aef6d3ce545abc99f7ecc94ddbad3a2803cc703e13ccd0a4c86d5a9a9ad34df18d2eca72a2d135c2efe3fa067370e57907c10dc68fbaa3c5d1db102869b9d02708798250c6136ffa423057f13478ba6b8ec4c6d75b418646d3ffa20d2da7d5409683b9f6a08bd3921f75e44a0cec358fcc54c4f4601c90aebc69327ffb3d68aa9e771f4624b00b69cc1554852baac7e56a9e31a1e71452366509de2bf061e7607e4e9d47fe51200f585a9d1fec980ee9f3a93d10ade7e58e0f93be41642569e3776e1c70b3e939ad13564000ce41881ecb28bb89d457ff09a2cf4987c471714afa8d6b10d161beae0ad205deb2ed84119fd454b848479e0340bc728e4391bbaa2fba59359c28710c7a0349865839c921dc9b07d3a8c0c59dca4da4546311abacd01ac1965553f205333a8440bcef4a01d17b9b610953d4719fa98c7233193bde453fddf9f4dbccb8af47f41be6a3cbdc91d9046da37f93d9052d0feef00b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
