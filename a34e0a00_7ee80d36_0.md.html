<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2f839478ae5c841941d500b29918751bdfaf19d83f419920f5d535d57b82e78cadd2bcf6126805f3de1670eefaf755f35b675de08b4e6355299050be7f533258070cae6b2c25e4a4cae8bf687ce8da73b000301cfe11104f1c6bfd975a683fafca909a704482299562ff3bfa4ffae34fc13406c556ff1566037ef636eaffb0cfad5a3a49f65ea7cc921ab3f837d5c3c226194b9f2791df55632f224912cd55a055a54b26bb3cfc12842718c1869577f5661038557c72384252ed3cfbdca65620011e9375755317547dea5641d184666c2de24c3db0d0a85f02fde9e37b8a492117f50d73196a584b2f609e6d657a1d98216511ec96395700e1e9b9ad991487cfe3df70203df9af6048fbd85df861ecdc89d639d24723f6bc96e7515fcc1b1b55a32873e9599a2fe2fd2d594dd3e92f82bd498b47fc91bff9afebf25de47db831c53c52e6c9734a080cdbb11ad944ea9e9c39c32111ddff81425804c997dfbaec85d2664560f933308a8199305bc8126e4a99769a8028fd94506a7ad0c2291e8b70569edf6300ed7ed988aded471ac86703de7cce852f57acfbdb5f08942027cc5d81e5e3916eb2d3674f1069f0e4605c678b5e7a1658f56540e2bba559bac1c149326273a5ee2fa116a941d36716ae1e072bd04cfd41cb2cadc3d32140e73cdd4ca3840da1c880568774ffd2654bf1267e5ea47f5c9aff4741ec5e93d51e460491d22a09fbbd5087618236fe375bd902f15081ff7956d49c716cfff35db928a8ee41267af864f5a7f125b351ec7afdb3778edbeed9f05c1e2184f44770f93fb039b8031af75b9190ea2b4d4300933e69e19407f603f1ae1e419f9c88c4bc9b0211a2ba5dd4eba0d78f4c3d729dffc44fe7a089f4726b8c2c6a95866a0d2c5f0ef195423a2acf563c9efb340c9aa359a60d346770ab74ba3c03f29f24dfe82183ed2932a0322b374e9e0aa8b73174b6f03d61435adc0ea906169c0413b23398543d7daa841e453731e05cd4d8fc0a6ee90d4a1eced24274d142defff14970cafaa1364707935ae63b08bc872d6ff878b1b2ac20fec21713c806826b536fe86e3e31d310ce17045d7aef7d118d23107b3a286b739c518dd7a74dda01fe9c29b7e8e161d1d34cc6def7addb5edf7ff1bcef7a169ea20d53476fd43d38872d5c451fd695bf296d96c5d95a7b225b89a0d84ab038f4b088b3b6ccc0c6df3f222273880d9ec3cbce1f57208893bc641fe99525bf0049142d20c8d49a2ea69be57489be1fc9b912cecfdce564b9056a28bed610c78d2bc663c253409cca26303880213a28f5b3602d2606e3a12c4575ddedb6073263a8e1d1e3f9d81a755700a3ac23c00c28d09bc266a229651ed77f7858be292ac612cf099ea42ef54eda42b492dd17c09ed9a0bfa4380e949ce030ad3f6dced5e03e6a06e3e9f28a92e0e28713945e6158fad15d21768cba62575d34eaaf21969d8876b7200eef0adc801a649fc5ed2553c2de2a5f8a53e1b8c9ab7039652322b51ba58d7522d54306185d25d9151b01de61c54b5c345ebe0a5975d34b2dc32fa579007cf3de770423e3c81798480ef09f4547757ab6ef49e881cc3ff4b3081aee405be414cfc1cff9949b6a13ef533715ab7cf1a2bc11b85b9567c18ce19b57c1665edd6be023df675614f7df609028f796e773b9a71954293abf5cccb941f1f867d6e1893f707ab9e3cf2e3128db384d02c240227ea0cddb0ea9688685c65e72c19aa7fdb109a172fe5b327e77a130e815068fe146b7bbf6253e300a0589f981060765e95b630224a04781521c161252e6700bcb4b5256fbffa6d678ceeea83343d6c669c331c684b316ff91ff8c9a37cb46dff179827f2cd3ebd135199726ee5501276915bc62305baecebf45ae98dc76317f7c3a9ba4aa03f2e0fcb405ce4fa838b51fcca0a779378df387eac3bfd8ffb6cc6988476db284ca172924e14555f97b36c4ba56cdbf6eeec4f94066cf515858a074ea4d5eda9f554607884ad4d9ce30deebd52f1afab9163424997a3e17c75ca6ce1937ec24266772eb98d55024821516ae3869f88c0dcc05a0795aa91d148820902ecdab67caa077c34ed1c7dfd5235dea39de23b583e45ce4de6df9a43fcb7d2b7b2da368ac5473d1d0a5a02f2da18cb7a565ebbb2d0b262a176693d5245f418c2235761db428ee50f1d2f4e97ebcfd65f6ad9b88dfc3d7dd87dc9212fae9ca195af805cad3f70eb0bffe2f9a592181e59a6645c79e9f08fa641cd67e72ab05f20fa6fca3d54c89fbec4eb744bd71760869fc6accd9e6121b6f21b6b41ec2d3376deeeae7905e74ead0c58595b785f9cf26e69dec4a85dde239fa9b809ff091c2c5f62fa06aa9c5da19996981d94aca086130afa081a58b1010e821d0993fa43efa9fbfdbfec537658a52e53f0e3eaa76d570d5ab7757d23b4c01e976fec0984bc7f48ac02e93633b983d054bbaaf818e56b94e39f01a162511801299ca537c5842bf8e23cdfefb2891e9a52591903bc2be5cbd66ec9addd624709ad48463f10d768f000c878ea9ea7d76fd885b0de563b4ccd12a0b22452335d333aa1206ea4ab26c312a421c931845fea2da49ece38152a4d50e3d05c5324a07b67d8fb3afac58f03e1226438442967d99a913fa85390a081518a85630fdad3216bf2cbfc0a1da6288b8a1da0665857aca1cdce8b8aa7cfbe03366ec2c6723b1dcc3a29e103d0b4d2b2be9ac98992d5a1867c7a5c12fb802d0f8d78dde8df41b7702ec589735c1f8dd140bb7d4ddbf0f243e14367af3454eb8719bc4226e534a74215a3fa5eead603d13e44a61f79faf16cada19593f7fc6929d3bf1ccf44a0abee067673098514afedcc05b80af454e1dd2cb3f3e008df6d0456d94289ca8a02bc76eead6326a229829dabe6cc95573c11e8d61065f25e66939ce9f8058c6833aa35fb4325c5cd2aefd283c2f75655a4fb712fd64603f2df3b54dbf1289c56fc5ee8a4f879faade7da109492e5d88f1a9bddd8f8aaf1745e1f4e953edc1d4330eefe65dcfa16f8957097dd2e7878402e5ccc9a5752393e11123c3f7a7753288a7bce9b2dd33693fdbb2b3e1bbf3bbf08265fbca4e97b3966d7e1d310160f4df4654a3e13fda5c9dc3f4a68970ce220ec515cdc2cca526fd1a910d1bdb9e36325e24f159aa1ab16ff1fef648ee21f06fef01ef5020ff92ca20ace5b064643f72fda5fffc1ab77a08ea3a952860e79576248a450701f523a87163af2928aa350704bebdfb596c7af696032eecebd67754cf238e8ada170dea5d8258beb7e17163c4ef57862faee5f247c420ba448400ef34cbc524749d20dc6c85bf5a0c95ce12a564c11a3e7115a7e2a818c66918032f5931ae261947467b65f8c0b9dcae83b22f4104cb40e4cb7227834d286177e19bce335f11b367dea247479c566228e74c734298b265eaf338de66741d224bff5a864cfe30b74b15c6614d4f8988b4b4c16c217c9238fcf68bdd65d2376c4dd8eac4008dc92f0c144c5c7a2eba8f6b01263b09779c079501158211ec5a106a8ad175eef374011076e97024bfe49d7f0184cc4aa3cf90f35b0134ffe0cf2cdcc0976d1dc0afd9b17d584b32791b10723f35ef39ec34384fdd842cb59efd551380d88cc87527125b0d25329b10aa874e540a405e3c849bb29a38bd25cd215485c95ab787f0f36e11492672418064a436aa184dc2b56f1ebac0f78e3aa47b9489b9cd5162389010ba1c28c29fbf4697cf04f9500c4605fe3824f33bac789eaac845c96e5f04979a3008e2153eb4b84fbafb10e925377a4198e23bd729a8d862ef538373f75f663f694d29e9894f243464e898492d377bd31a99ba22c859cf57a3e15940999967daa4bffecd75f7ca50809d0674e39ba38d2a3d8685cddde2238fe54fb39b5617d97cf8e32127caaf02967045b7d9a42d499e2bcb8cf88b3f5cd4cdb3ca7d82e61b717eb3c69402f7091454208fc2754a346056d41ff9e434aae50bd54b108b1b9da163ccf49d7b85338cc7c5bc6b52ba36ee1cb25e23268f08ea4a58327e689a5bb6584bfb953ab7445572383a6d146da9f567567c2b6fbf8163dcada0132ca242671a49d244c6c92d815ac1482391b976f0e70728f74b8b6bec56afa0ad127ff32967c95da537e66956d6445dd59bad46d0f58d96179ee5558152ea2e7c1b44133cfaeeb8ccc613aae89091e73c091874bb2acfcea6fd2ec0c079815b80f0025ce79d4552cfeb36f20f21edaea14ab725e6fb65e9e317522627b5006aaf78cff264aae82d62d759f747f30dcbfbd8f1118d156415c00c31a699b288ce6f076ccec39e2637c0a122e8f31ccf702a82f6f8708b3401640a67cca1c9f519ba34c43a4ed99330e845fccb5ae74b93ba4a453a4a96dc4e00c0409b5b9d563656aea44a8433e13dcc50fd54c6df5eb1484440be21210dd9affd56d31bb4e2c440e8389640c8de96e7ea5126ca2a1849ac0914e62e6b3164588ab784d0bb523ae33c504a283193d12e75fdbbd9c41e739832d1911d1f321e6ca86eb08652e9151f56528e15f24c06a3eec0e18e0e652a2152c174399f5c784606cc1817759f4d63698349b931a41a900e6117863f750beefd12bea1569b9a0810366588ebf6e64d80833dd42bbf9f26d69453fe1a2b871711ee982d738437627202a5b8f89d50ec288238f404ddd28676789f37d55fbd187859bb48c4e1b4a5378edcd4b31aaf8bb839add86baf69189034a28ce307cb42aec31467c6e04fd2248b1e5dc095a923c0f4c589803388b2cee199dc93ab30313d3917fe3ed42d0f9b361dd8e6439568341950997fd42823a78bc9b9373b84851d2df3602bc3446a750299529c721e9139beaa7d48a90b6247d2c2eadf119baf0665531b6ff8f041f2478e251c0483cdcc02f4ec48f2dae1acd6dc97e56df4840bc3d75a01e3182cc973f4e712439e705469245b5e9603e34d7db8018f9d6fe29ab565af3f2b157eaa8fc562f07e3562339533100b234eb10daffcecca900394dda18f1f6f63887eec83ed28461bac1dd5cb6b07a65abf4628bf368cd077e8c49cafa06b684c627a27ef0f2cdf0ef2171c23ab4d67c4d5eb50e5c35e457e8f22291bf41c8f16623e0f2dda156c4c621d98a49a6a5a9c77ff9af012f21a0b509c32b793b99ed94b4502bcc52978a7f4c7e55d4382974789455c4db2fdf1fa20ed9800210eb2d25c790b7cf4c9378436ff276f97bfaf213e341e374d8792422b69849f88ad088195da045406a66fe461639003bd460b5869ae2f88bd3de1936b3ba08dfb930969bb6a32b3ae6c5c69158ee0ee8706017111c48bfce6c489aaf988258bfe52df321f9078b758a2f24eef637e77d9e9bfc871919eb0915472233881bee470627bae392b89a87d3a87da25d2a561f237ce3954284368b3e19dbec75d60c0f83c2eda39afb9ba9b51d3390469b5616ff15c39674fd9937b7260c561b973f388ed518cd1a3d0904f0eab6ce596c87ed173d3eff2e2fbac7827d41ebb88a68f425977c5b3e13334a7f9974dca12ff402e9c904ec2dccc62bdc0a56139b67727099d2b6a4ff4e35dabbf72368513997f571319de5c67e2e1ca95e58bf07879e172fccdda20470eed0b7adf8cebe40ee61231448fe7729a6a0e36f4947505fc47e801f6ad430297a04796a28dbf67e3d5771d5639d8454c38227c0c0d8a59adfed6c6424c86f8f5af9665b1780164090b8962bdca376c298bc1b1b903aabde4c8749ff75372ded7f34049d79fa39d806f93babbcca418e340bd99e19c77888f50aaca1e54e10a9f82b82715f69965a9381cc2d962a91e22ce9557e641c33bacaea12da36a846832dcb2068177662d8925f02aade793e034678c1d0274cff1225f5ec6f57e614c702433db59f1dab6f0dbd4f640a4f54f0fb4c2e23d3e431fc5f1f1ec969d66f34286f569e42411ae9a5f6bd7008aaa9bc1e21a2ed44674b8997049599c03dac81c4f52731b94db569c4aab5559162d93d5b66dd28ac34e8bb188e0d791b94183ee4819ea6023368b9591f19fc32d75ffeb8a9d59939186acd2831d1ccd5ec235d9c0bce37c425b0b43f825d7bdcee564c5f7073c07ccff5eb3f81a2f346d51aeacde14092d79f4afbadfa32d91db2fb031bb7f04c476e1079bca2171665c5a6ef20e2d6656816ee894a07040caf094ef6a40d1e1d680ef3e58e047d4c832e3c6fd8856300a5771f7e174cc716d408da987d941d39692c67416ef91e3bbdd883f0f52721be8845cb5f5382a404da51e4a034e56e69d0473242a5d53478f13300597f32eb12b87c734ed207e4d3598d2dace8ec70056e84067f2bf561aa351ac2b20f211d8978cfc31da288a9f7cbcacd989fd64ba70048b280802bf77047e73d06a722b189db961a56f5a6377a4a0dc978d58c1117d3decc60f84f6fdd5a58a18708a8fd3a4a5f4e32992fe5ca5a17409de53e49c9c0fad18d0b861fc390333eb1ef89826ac29262f176b115457a81f1c5937a4027715b4145137b33ee251b612b1a51b92863198015de03f8e6940d7684a3f744eb459934660cdb3a786c486abe3dc7b1e69156f1fdb041f280c4de505463020557d990463cda82cabc4bf03cb8d37feb6ab2cb6446a76341bed7f9d15b63f9af0accbb0bcbe98392a1187971b8c06a0aafef8f0b51d581e04be1f7b249015f077b8d6d815f76bac77c7447647320e53cefb7eff159d5be840cb4f7cd66e8bae8ba461fdc7cf8a86463ea4a62915ea05634db08f1bb774ba18e7e606a7dbed4f61f0e285185ba1cc50bf480192f016aee828dbf41ac1feb1323c22bcccb2ab08c7f945dadf4e8c72367fc24949859db10d487d60b5e6fd1d373f3899017ea838b1db36ca9e58e83ccc3c4463142243b4ab3da43a3af1468c42048c16f464ea024d39db08347122f1af05762bd4ace9798d04522f479d49b70e5ba7fac52649d6e9f77ace9f3f4de988e256ea09023ddb3011a1fbc08f82afc6c28ed7fef4cdcafa0859fcb041098551769b593a0cc230caeb60bfa360fc7db874e56cf9f898ff7c7a9cd597eeba9fb144ce3bd869b5d65022d6b4971a60625234ada92c87c1c85919a8c21c75751eb0c95391c784098351c84cd7237cf924dcc2418103bd7cb6669a434ae16811a75f35ee2bba3c2b8512ef69b4984e5a07516b5b62d6de367c3b3f8fcd3907d169031cb5c83ae8107cfb3281075337eb25b36b856cf36a5f235f3088ec325f1b857956a7646ad84d3db9c47e8a74c4d2c61abe2af3e598233ccfc7237608242305d3227ac61e9b3834f0e1908f37ddffaee638eb2773c42bf8d1fce24b3785f3444e5f0e91ac6904657c6f173e8471cc83c1fcee70c65eaa3d7bc02b7ded656bb6ab030f465aa4a5a01b0eef8fd274078f83b1dda18040ab8c547b98eff12be17ee6b29575ef8ad5bbef16d2dd450177a080d18de920461f102d47ee283dd2edb87dd3489fe6fc1e91ab6acf28fa2362f6848171f5c4d415fa97cf63530a642dc687fa68d1ec72cb9bd4329b713d99333fc14477cd68ef04bb809f04da479767f3dd6826fb4ed068b5228e86c907f870f07022457ade62213239200f6478f0efc40285241732f52cc1d57247b5e5df4aacff05f69d8b2573ddff9093019b04cf8481ace6abdf2651ba6847e81d63f4405a083e93e57eda0ec1b89d477577769686266bd9690b3dbeb3359e087d6c6139b7f44f5c6bb4d49f33a14a28d79c23a2ee78ce646d80248d0ec338159472939a90f51c490518afa209ed72e28d94af831944ae405948587d1b622b70ec2721444e9582db3c8ffbfbf3089e39cbdeada367194ff3332275436b582cb7f0fb4f1fe40a51165aa67372890404c6469d36c7d0c92e29436e55b05eaf0c405388eed0d8cd032cfc81c1fd8c0bb29b1972c9a6e78c4455f79a7613833e3c2f79f29efafdff0736144199572388d0585887185fb75d47b321fe6c56a38eff59d450eae585b95922ab68fde99989296f2f6067897fd1ea78acc7d1d152cf4a4e147e7606a557dfef1b335e60edc0175e72776146ea3c42de8b1ac9c96a83834fd299fa3dfa69a80883738413b6be703a34c18f91035857b39e8eec8a3d4bd41059c578d43b1dbc795a1e38812dc7a1e875e009b783f269ca67b67cfa851105d535d66e0262602d3f8431f8b2bccf69306c881f98585187ac243a634753fa6f0c3262927f481690351e4aabbc4e6db6be783f64322be360508ef96736df6014c81c397f338aebc9315191a331a5db3689d2230b2b5070d21aa6bc2fa767fb79032bdc2aa43bc2606dc5c306760fbc69957b1a240f7e869624743867794b3d5ef2789cf0e457220fdd01e54fe7ef3328775f80b196e13391e83c10d54cc8b92cc1229bbccf883a38704c91bdd7120a49128e62582755fec4b1732733a8e9410b52ee38a400b53e268df24a944a9143637e05c9bc5cd8a9b635745adf2fcf0d7e204916e468fb83694f9c3f72d4ed476ebfec1565e49d136adec0f363936e7b6ed00a55628ea66830eeb47193a7aba70f03f62fafc4ebf5f058f0bcc7da33a4b3aa18b0f832c4283d8bfc8b383ffe322ea295a3a43ae72050ee2911e4f81bebc42293912bcfb3b63861b4423b4fe4fde983e5e076da5a66dcf7f97477c124c61757504f361931b6354cd7e39834fc751dcebfe9a8d3dabdc8632f5141eaa0c73948f75650492f25234b94790129d49097d7320a6a462e452e72be7a4f1cf2ca221790ae6e6f64058e583f9117384fd76011f82ddd9ba380fea9802cac809c1b1763d648ede8b8dd59a6a0e3c13d493678bbadc91bc1b8def972dc1b55e28f23ff37357a7c8c146ab45e70cc5bef0bf46b0a455facb62043b348115a83067bb0bec5fa811fd4d990594588fd36136e69637dc916172b84f959544897c63b8284ac3d9c08e8a7e5f677e1aefc4f54c28380cbbff3330e08334d1481c939a976d11144fa248cc460ceb231e7ff3b45f47f452e71442d47de6b0bedf10188fb0aada6e65f466054935fb01a8bd3b05e1cfa4d29953fa15492182d9dcbfb5efdf5c5f29e6e032f4de5dee6409510441063f637ac56843184b9e501e85cc2e5829065f70f3eb6e0ca3cf304bb3539bacad1934a19588dee07a5981e7c309b9196bae445e8dac5198abfb113c12668ebb0d86cdd67d81636d63bebc1bf35229e31f43a5b467a571b8c48fe9160a8af940a428ab0b822d8ac45c6d90922e39e222dc4414ddb9286f9f4b614912bf919862729c1d6643227b32f9c16271e99b504ad3c78ea41547fd87f42814dd818a871f83b29ac6a1829c927dddf8dc4d6336471c87f3405724364fdede32b1cb20ba2bc9f807e984056c0c4620cb3071716defff1d059d409f06704be19f33e3d62782b9e76c77282caeb13a88e60c11b751f2b6509c8c4066fa446b64625757602fd837c75718a745e6a0fb99ebdd6ece30ab363551551084051ed2a9682a05d2a89ea01a8955ea9c1ca567eb4ecd7d6075559e4297fa5f9c79665a293c0b3e939acf15a06380225cdb8fe0b2771012d0f636ef6e59eb2d9f99890569cbb798e9a17e04f6e4f54e355cea38be1d26742b5fc46a8253ff1a000a5d41fdb57ecae8ea37a9fc194bac0c8168e67b4af13f1cf4fcbd639cfa612dc4be663c716dcf237bed11e558aef2aa59c0210c2eb265d5cf870f63e58b1196fe56ec81d9acb4a6c91e4abda86229131112da1be31d20f86603a04e81f7c5ccce90343188c088bb8327f63872edcad3780a44532e7596d3af49893e485c02c57055c2301cdf30249fbe03ba87f2672c8c886f6b4c4c6f520820741d2e8a547b0d29476045d01eae0b8334402b127d4befbed561171c507f2c404c80a4bdb7c1050e3de2c81099ca1e05e716f51d72099e50b1260da6681036049af7c03e0afedc45790e8ae8695349224798b30c8e77b80f2e1297613a1798095974d2fd6d8372adbddf3b583c39c39bbd05a8e7764b3f929b5cab3576beae261fcb1db38e19590b261817a3925b6351784d5467e7c8b8808fe599ddde23e073cec57e0540630418a3bbd18d300fdfdddc059df1cb9eaa2df9971faaa19197ae202bc8722e65582f2962a0419af08d830856c9d5b5b5aaadefadcf91b016bd2dd39af1a0287f160447ee23114437debe9b91a42726bdee1afd387b03013b4ad640107b6b3bb9520ebbaed07653343ac187edc706c6eba0cdf66837249effdcaaee595c2724b67a4464feefa70b9d15d6005e279ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
