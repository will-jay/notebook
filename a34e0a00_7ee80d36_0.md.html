<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"365efd7ee4940d9d057ef34a8406fc319d9c7e83385e3b2812f24e53ff4cb58e096da92a3906e737d60ca35ed736028795c2c626e05d88fd2fdb3e6eeddabe0b588c29fef4c5f695ed8e3f8cde781e1a66eed97a81e3736c86d80a05831f37b615d79d77ffea4920591cade6e6a4f7477cf7d24fc30a5256f0d6b2df6d30cff1aff833f8b369d619b08c276a1e249dfc3645b61f7379c86f1a988b6423a955c3b30c109d96e2d677c150b6ea0faadd634c82f138af17f4b7c9a615093de728c9538450cd877c51ae57d9c54c2932a9b30225d2d5bff834efda958e402520b3566c8d09ec945d7f7e56e76689479ff1a51936b692ad231308f417bb4a64fa92562d03a20898d8d44a206e44d0b177dc9447cd2a9c685188518542142a71cd840cf3c445c8d9850ee589ad925b672b8444e0e3eaff7394f083483be6261118f12003cad218659920321c6d1c5dc1fe7ea80bb9a456c97fff96105a23dcdf3ed03b7ec7e9b6c01a9d2d0afb8588aca0e2318ad2f6cb542fb692b344733304580502b86bed90ead31808251ff8587089080ace946f155aeedb444a4118e64e4cc55249e0dd0f0b065f705e6c03b521f9ab3304d838edb04f83d4fa8fea8966e63503f2daa293c3f45e993ec81dee5d786aca803d588735e0ef4d85123e4ca2712b299967665304be7888dd6140f7f1b5b961e9a9660620f2e245f80ae1f1e22d20128370bdf6638a4ec76bc6ac6d17713b011f9cb41b5e8b92d3633ec92545e8ec1e411bd91cb5bbe098e3a84143897cff9dc8d33c4ebc5c6dc0f8df8d029d3fb6787e0ef01639be7b978d3ef58c7b226dd3946fb3afaed4aaa04a6154ae4728f51b3393fe735ce6551654ce6fc8668d75904cd779af8977f982e668a138e141de83b123bba3a0477de52f4fce203f6051676cf88977f0c7e65bc4ddfd417b324f1bd7934632074572e8750a533bcb08fd925f07ef7357409837c7842b3b4defb7b2570f69299b087ba7aa4bc2b3c1b17630197b1c66a466c82a30abf2f117ab62f8a2a424aa9269e15a9b560e4e807276581bf6e277ddaf79e85843b6b7f56579efae6e338a44545b28c0a72f0a49d807dc47032a83970857b4a82c95d1caf40343507a116dd1569771722e8f7c00703c232fd6b566393eba946830977fa07be0d4c2bd25e355ba98b89ffe114a5a372dc81add019c4f460e071c3913b483caf48d45ef70166356b4debba3b87376a5c9fb40a93dad33ed49d94bbfa2ef303b7a88d034cfb037eced65efab2dc53e194aa44bd4df8db5bbb6d5e2f66314cee27ee7141d2bf5f8fa606b8dd1b8ebf5b37946fab5bcd9afd86c41470b9e9effe5d22da94891955ed3dd349cc343f3ecbb21e941e7816bcee4f2b81f52ec292f6a336f8207b52bed79b7235fabeda8ac61fe9cfbafc5d8978fb422367ffed4dbf6bca871ddd699b2e1fdd96072adae8ca691c6b28f9cfaabe6fd8fa32072fdca64a627f440e6bea5a2dbe036d95558a9e0a3b2bb0081b7d3817d38d33ce773281370f733ac34b633ff5c7e8ab0724866b4dc405afd635b5a279add00349c0db4fe6590404cc219ba4459c8021bcd11aaf3e6f5d4593ae2c70b5f051a986e681278ee981daf6795e7841b23b53faa07a6bd5c33821f852319259d30cf62bac2c7548728dc2d839a8ce54099aa399357322e231e165119b343b48085d149ecc29cabe70fe41496651ad1480ea568d0a6f12b50f23d2c2722002fbc9a4eb22162cf4f161047e554b0ed4074f085b7a4ea4510d9e8d199172e1d3949ed0bd1349c491f25690fa30a6f11b95a2b85e787c17c68dd73d2fc147b84b18ce7f3c086ec1acd249b273c5d8437567aa861fc06aa7898bc5b02e70dd22f3cad3af3efa6f07a3a7942eadaab4929bd6aa2e1210ba643be8d4dfd116c46206972ee0c3b077824101a65b9edb3ab8a560d26d096c7dfd54afdbeabc28f7e55afc5618569b5ea8a9ad3f3ec6f70cdec2c95441641bd42b0f6205491dfd7003e5fea417373ad7bc3e45e1992e9c6a029a91b21b3662bd960cd72b2555cbe27dfc53ccb4d277fc9a72a5f7df76fce75c13a60562feec806c877f14c56432fa7391a10121d3916ae2bd0d930104c6ed3ccb96a23077080f5f4767b9f4adfad5e146c6c7f1b9277b3c17006b487e8bfd5d3d28e168e438f7f1669530ba3cdf7015ac172a82a12dfb4a7026c262d85f8b8ef8ec2e49afe01ae2641514c5bcd2fa2d90ac26b80bf6b5ab762e97e1def0a5e1e30d5da3aa240682947b4069243a8019152a073a31506fde9ced46bc23ebdf51399565d30a856351bcc6c875d5dab3cebb693c5413731925f51b014ae2c8e612aec27b3668e1aedffb6ca1887c723569b8027f14819e3a70dcbc128b1e77de5115d05acfb2d0ddc7f5fb04ce6d7fbb0d983cea80981242a921b1ad86ce4331dd75f718a1e637c9a3643d653b8e95bb2b7bb0f93fbb62ae9e84a49f74dffbfcb01744194c10ef0c369fc816fc214b5a949f6076cd3b416ef48f1d11dcb994be263cba0fd0c269e4ca1bd115894fa1b1ae7fd713f7606fdf9055674d1a924cc274d4489266cb814328b0e432b5ee08ea9756fbf4d8e961b2aeb20487d93dfc457b3cf61784f38547706fc8efde9bdef585a74129363b22716c98ccd213efccd4bdb17e354fd3706f6fb365068b2f79addb424f8c66707ae9bbcec155aa0714f1767e4d5303e6b4fdfee941b4cdf6deeae50f45a93e05ee4548bd015570c86aa93f79a42d3e3e38e58ca4e5c409061f738c06f72b6dec53e3909e5dfe07e2358d0e447b334a33355e534ddc1fb0cb6d7269b439cc1323abed72453055dada65ddfd66f2b8fe8e04e66210a4b3cf45e29990e5f2b689a2b013173923ff634143215fd04a10a811d307f87b95cdd89d293a9c69142e676ee66b7b7975c7359a4ed10db2d7a280966fdc85ff1a7414fbaf13335151c6136dfe56f6f18f6b42751b0f0118c7d2c8ac59dbaf8f176a27dc902de9ff1ee8cda92802fb35d6b2cb2ee6f833b213d053e4b9cc3d956ac69186c1b268db433ee946f68874872a18f6b2b387c1b7e38ab74a95dec28810ca86b50be3ee05db341a424ca5930903800f09611acbd283852821ebae84498579aecd67dd39c05ea6835efee79d655de101c60026dd8a450bffe54bcbcff46104f46782658da14b9a9ff595861fdd1e0440b1fa2001d2ed4e5fce1459ab16faf7d0be9532a567884807db4f327c67d18ab819580fafdbfe8ab7936976ed7633b1a71b1f1da5f40223627b44a6c1120024e948c27fd3b61a54d25ca3a7072d7f00ad89b3d40d6d5026b66822aaa04ff3306d3919366b56a807be5b6e4f52f3a6b65f73e2736f9b77134037c25239cbf5cd3a0920bd51d8f2e8e17d238d38e5f040edbf062c7690f89dee0f8ca485f06452cb8485bf75d90c51f35869a724eca7ec408cc5dca52ecc03d9b85d03d85297d6dc5e3e389f991595075e97cbf48ca6848ddfb1470a854b7573163cf521a3cec196532b1bb7518fdfcc46b3add890da0f07674d3ee0b43885ef76593360633915bba8edd6312a29d0e888925a4dd13aa3f4bb9749d981dad3627616d803a537426fb2f18c5755c1da5b5fc058e080c4e7a9eb83f7ff464527810054589d3849a60c846c59fba66791a56cdc1147a9d2ed754d0eace4a236ec8909ff793e22c0c10ce846185f0f01379b0dc8434aa04e5a7dddbe33daf06d993a152197eeab0e4cd070193322ff8ed0ff008ce7fe781561c318b29a247f4f132d5613dcf0033fd60788fde044390f6162b908c6074f283f8ceb377854c57f77ce40a40c4779d0a860925a0bfb3952cb6ee1d278bf34c50b713b623848d40013da57a3b39bd16d81fbcf0d15d756aaa8012c31710915c5e620b120b7ea2f891005be223d3eb5b1c49223aba4b2d53e069cb01bd25863b440f5e14db38d2a40fb3a46d4d80f802fd9a36590d27f151537db0996e48e6783cac0d5dd57fdcbd67ae312a1356c05f2cf95ddb847341f5af2330b920d65caddcba984fe49f07584a0ef8f33385086970362936e72dbcc4ec91d012be71c66549dee089ea6d3d085ace6da23d46df0b2c042ed968baebbb7fb839ec03b0c83ce6fed0de89a25411082d5fed53bd360ba820122dbf885cd57d82ad47cb813e1b3ef6df3190dde4ba6291c339fe8ed413415c95b4cdd270526fb6736b108992283bb4fbfc741b0678200f359328d15424882cfc3eccd50f2fd98c486fb73c989b1b1015dfc3ed5af78a2e3a8ae47d97cec3b2f0ef7415d59b8c3b359cd499d5ca5eeaef2c601aec454e790c192dc11a59e67c5ad5f7b5784d1578baeef5a102fd1476dcf4568c4726855efa77bb0e4b1dd5fecdf49dc38b0a2ebd2bdae6a177e6b149478c59a822389ab31122bfcdd00873040a82bc1700439beec8386f2ea06b5c33452e65a5b5b68113d0cde5771b6f8202d10779aed40660dc456cb0e334cfb57225efe5ff2cb9226acfdb29375f25fc298ea160283f161fe599b503f6fcfeecc6051a1d4e2f1acab7b5c38bd4bb47094a0b8e44c34189c14b1f432ac4efa129623e5374406dae1dea4a980fbd3c874e46b0e2f130d4c503878520a67161ef8340630d32dc311515efdea8f99becb9b8c2c0cb2ecbfbf751c579b3dae81c8fb0effa2c045c2fe58bfc8c2f7230e9a6552b0e7c12172e86411fc679897ef929604bb2f6d52923e113af202031417f83a9f2e0534d3eb6bee31a2140b8895158f746e827899e9e36dd97a9df5371e9f8e25cf54d256bcd2cde310b9e9f5bbba498ce53bbe05640dd8948a62099b0a9313fa3b366c4e35d53559eb59ef2a261e8d03294cca0382eadfef5d65414e834ce19c1b937173d73eb62643ec17f5fb27d6554564d9fa8c6b7155e2bbf16f33faf92a0b689e2ada7a1dee7df8bfdefc01e66f8e18e08deca85aeb701277b1cdbda25d03866a60df83f5ea6e7a5f9e35717fb74ee7a1cbfca87b9b881bcff443a962f17fedb2763b67eb6d9f756e10b912566410abdabdec636f0d48c38f5af14caf07e708ad71e51c235038f6f73e9d6f8b71719d790906df67f3f91f46d4ead24b14162658edf67644294c80e5e7a9604631da3de2e249984479fbea7a0783533aa9784e2270268e94d59b9edfdac0bd34fc16023f1bd528af82b2967fa84c3c15d689b88c06d459dec11fb8eb8444664310259bca202ced12393d33214708d1099456817a96f916a38ec0a283fb5dfafae55f1b40f8c261e1c19379f64db8d4571d31c351dea67a62328ae9e11a9539311b21b67d4d447da233ca45783b668b99c4a071042cd7b5a8531c0df2831bce22e4d4012b576c1f943949dc6230a541a47b60ea7664325abae235b4dea1df13672b2e879afba466cf068c188022b0d2e0fbc3874ede071bfbb711ba50bb83878160af6412d765ab593640833e7e64e3492b3424508f1011eeb3ddb208d3177e9a56606e1a15c020be8353725e5268bcfd7334c5b6ce2a0172a8d028b45e709cec3b6e78312b7cc4e3e3327f0593a7c5ebf8346449531af5e259a20b17f1c6419e08be4c48c2a3ee3eb07708eac9e0680b2d053d6954941d9b1e638ba4a7adeda9adbcc54b7c5029d350667de397e3023f8a10a8a49b7fe4f23294238674266867bf5b798bd6fad71fab72feb9729ae121ed33cabdc5e044a6fbfb15efe8d70a9c8c1cb6b921bdea5657402e5a6124e0e3c2369f30408cffab02033609a8d88f7bf47c65ac4b340b820bb9b0f0d0b5e487f008357d688d6a1bae7eca5a000c8e834f459a93c9207dad3bb448e091e83207d5b67a51823db47d4bbb7916f836e635ac38fb47735ace2b6bf0333494691e46ddc84658a9086e626e1bc77ca784dbd8bfebe481e012835fbfb59c93267d26003b041b2d82c0680057c7b67d8136dd810c57e1d34059be797137ca46dfd35f6442dbb77f9c22fee743c2fa2c687bc67b1eba795740f3d4edd905805ebf182bdfe5ce323ac5d7d5011e03d9afaa75c2abf99c19892361b799e5700500055e588adf00840d844fdb0e500f16768ef976d8b3ddce1adbe9d8073c742ad5b93d7c4ca1bf5118931d3aa793c21856004337e571ca6a58c29a0e4f18f71499da30fe6f88f22ded8bb63b50e05d8b0955913aeb3c0d8820b4e926b3907328987203a2f76d13776414969b58b533da4ba9f94f2e290a23cb8843382b7d53ae5b659f118a8d0c4ca977f3e84709ed26748f2e0324af899f6e6307748e1fd67efdd8ca3a26084f73d1ff0768a767d1556554bab0cfa016acdeaddbcd038b85fca5753c1ac08f71101d84f1c0554c8a159a515fd0ffa8caae1aad6af8e2cfa063df8519049055bf86b0d29645bcc6b970348c881cc7e6c4133bbc517f4656279bcdfaaf97a8d66fc733c4d75923ea5292bb465efcc114f177fa3398634c79f4028d5cb2bd9a1e05d6c07243b814382477fc8d05e926c674254bfe4d62e6c022de40805d2dd1d4bd3fee6bfdfd9aa2a6916f54d1ed520c32ec821e55eb6817f6a02b1e8fd55ea2e4cdad45343116441cb2ccf65da56e0171519f33d382e28aa32c2cd701f8954b161f2eaff2fb129e50a23675d3d2feefc06afee00eb9d5608c196c0351218ad88eaa679e60bf7ffb9bbfa42599948b7a40956c94dbf0b5305800f201e07a81b4c81adb6e3147183e4af2a53de939c749b915c6a46723f57a8888737c39fd37085fc29971e64b127cae2fc16c1c57ee362aa2ce6a16b7a0b6bf523150f68811dd64047fc49d7d8b761168983b2c723fd99b8cbc66f3e6d55541d105fe031127325ef1f3d3971c1dc6ef2ce3384144f5f3be80437c7f60138e7adb22e37c2935aac172cdabb40426e2b459aa2d0313ab40f7cff6c1d48559319f30d2c0db985581f6f96c639eafd4ff24f056f2e3ab00041bbaef396b6a0b2ae6a1b3094944bdf4a11a5b2f89f9ba12160772d88d7a3110bafb7535d9bbc584f04627776e8dc868e8c8bed069edb8b0aabb178059dd7a47c375a3deed9d496152f7464cfef3184266b877a593f7c6b6828798792e336bcaf9505d80562beb4815fb9577d1aa037a749bdac97ac24a5d4bb425906328f4fb8c8e7bd1c611d323a8f58c9e717789d0634a6ad10ec2bfaa8140b540c4ee7ad81a8e942796a42dc6079861a286bcf0012b470d5de25601e5ff362f223b3bb6fec89458d164115dfba14aca51d02a3d884dc76af7cdfd03943c8fc2cce7584a7b43e3f17e22bcfc1d3358d4afcea3d9eb4252329887a06db42a939dc959616949396285e361bfb7acbed0974222c5b0a518e08d8fb840de59eb6758b769c13f502f506151fa0d2b8a49c8c152598ad51cccf8c3993883b3fcc335ecc87498fbb6c961edf89250f988ed27be832bbb4675777a776796b39beaa48ee4f5a3d9da533f6bad31f50a8498f8120eb51838942033fff6250f7996a3035ad4de7bbed39896edd7046a9c8a62380ee826e4f0a87549ffeff1d8e4ff6a9efccdf2676cc539979a74d80ce1ff5af3a8f210a89efa9c58383b98b164e0f95fd25ea2c79e2df1242357e249c55a6a60292036d817dbb4938b49a35a76d18d13cd62440a29aa307d4abc5d71ffeedc8307df0e72db7344094327f6279b472c6de2b4e784e938d2bf5467198c59b547ba60e9e7846ec0a588ef3e75e518e4318152c064bf3f5864597171b76784e116a176cff946ef30447dfab0f1963fa02f1e8a346fbe89cbbd69e97b6ee7f65c16a6d737b8a3d845c220cfd5bdfcfd6f6d477a54e0b68cf9423a69e2192322a479cc4e86b3d89f24dc067a3420bf272df0386f46b08e9a2baffb4d7b45cfbae61dac34d8db88c12264f77e8f26c9a52723e123e485c9f61a79f0b390b6142a564ef40ff44ef8e7e7e6dd6c1590375357ca6f1093279730573b3ed89d2f51574d5d7dad1c7a80136ea0aba31daea4e1a73ff48f666fefff2a2b0ebaa397922155f8054fdc8ba5d9ed0c36614144ccf16154291573e67e71550cc8fc4231f5c5af3e8aa3f4ae2fd2a8b07efb093a7ec38e002cf5b55bc9c8fca8260606e57b11da99bab4145a35fff4ff069acb51eb5944e748cdc6e11953aeebc5c81cbb4dfccc9cddf520d5ddff8a1af69a1d0aca87e45a76b73af46f5d221bf8563972fa2d2b4f5ced3d9b900775bb2b1d9918df9b4db62540068a9d42bde39d3b77ab6dc6d3a0c82d31ed50c5fcf58b608f2c4ec66110a1b0536c6fa81921d3c467e8c430e91fe8a4838e3bfaf67a92dbafd3bbf548491ae6d5316ddb509bfe76a99d3d2bbadae1f180c16443b519129b4e32c15456da5be7c6de60454b9e9f1cf1974ac6953213ee99d109f826463a7175247795682e7774ea860a29153e290a10127b90621917d3ef421ab543ef7e82ad52f8ee3e44b47967cb996fdc60f73903958e3ffd20ef58fc087e1130c081bddfa59aa969762b127e825f1c555886ac41f2561c628b9c93a7fa0c9f2b8cb8226759852ddd96a02b555609e97f00af38984da826f5abd65e67199af99162358aa3a1f9d9746d55b1e2f0803a319e1be199f3cf6af24c0dd52d18be4c6f17713218918ae79210fd90018731cd5d34b7a566afda118fbd53de1e3d452991c183f0cb0464f7d81d6163bf2ed37bb44faf813a1c1c2bbcdc5e6e6b7bd28b5ed05e1289d6b0411c8010fc92433dc59a21150730c620a282e4969e74e3cf7731d66c21a473b0d4521a6832116e52a8aad53e05b3e5aa1aae28c548aaf07c5a9b65619795fa21ae54e2d117a90391e18c5f91fcf091a0e8c0f6c16016a050c887efeab81ed875668227668ffa4715080f99f1a65168ceb038fa722bf0c154103e6be0255acc5762f0a70b0434a61b7aa2936c9d5d7bd3d90bf571021981ddd9d24f67e7e6a9eb54c855162219c0a939c878d33921c83c439d20a59694871ca9e207cea5e168a2f826848133f35e0cd2da720bf6e110893285add0d77c3827ed558881abbf1a34a627d9615b596fb3eb73a4c0395fc00d88a5ea25fff88b761009eb66ed64e7a19a4eba120d354f572290189363c4cb9bcc8bfbcd926c70ef6c4b57ee996316465954177ae80f4e462969c6a2c46050e13d6e7ca1283cfc082ba21b4c530fb42bc2014b5b08cfd40288dc7a73718897b07c629a48ad238a294cdda73852f12171b4dbe43a7892efd85a36a119e9bd57753ffe8b26027330608c06d3d299dd77967c5e9e41834e8433fea8da3c22ca112686161165e488f1e0662e2418a88f1624ae9f6a9cee47cff700b0fd6ff10228c3e98875d040d9b897e5e7188d90e19d482b7d3a80102709132e014b25df485470d08559d769ebe81b31fe010058c08b29eb5a9d690a8cbd09bca2c12370c162106acad994f772d62f3c0ae2b5093b2d2759072f92329515322f47a87767631ed62b0ee31c3575648b6e26f7c83556e83f96c2306662cc2af68458cd7a1355e646e3a42aa4213558a618beef81ef92cbe849e4c76369a8d62a476c82ed4e8a6dfd4e9a4ba6ef4c429a5ed57e4c88e988b01de4bbeda7ca01d1d8ec96a325bce465284258501e77dbd92878106af8527aadd71981197de9adfebfbde4e62f56931786519280ba004ee5cd8acbb7a246b53c5536912dac612e3f87c965cbd0df35d8c532234b7e3899867800278567dafbf9064b3cb315285486d19c082cf0d814c2c8bdadbac7a87a3a98b744c6c4b5cdd5c4e32820041495340ed3235d61ba5ecb141a62821395de1875ae357e1481c0563f867348a1ab418d74170230defc0086f1cc3ca61c28515e4903e9ab44c727009f5d27479d5fa8fe6f6481cbfbb43f6708ea016d286727242aa1632fdfcb2f9bea32767a2fb28d4be26403fdaa1f8d1e538d4a2f34ca16693d140cf9aa7de4c4ad459c40352730606132f90813c4a7e33cb8bcfab78bb2a40ffa2c469370c23eaa2994b567b46bc570d4c57d4fd0f4cd62f8fff792c2f2347f401862de5d2284a9bcbd1c5e2925296297062528723dcdecbdbdf9b281454738001951569b506784683b98095f7174e5b72ad742e4b32e0918818370b37c6efa0b0863a2061a9da12448a134e73e21c7c1382c250ac8b3329e88327f6f8903606689bf00e3a1e04c42aad33643f00ddd59e96121194c96c47ea13a352040859a8f632816a08495f3029e35bed861f4ddf2b82686587fd84641284b2f963ceef3f988ec6fc40d54e937790e7a7791d67fc5e7761fcdf64b47bbc642e4dbbac25ed224e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
