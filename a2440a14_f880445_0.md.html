<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fd38a0c0553974f1c229e780f77ebb322ee71fcdefd5ecb0058aca3b829240a235651694f54ffffbd24b091bffef97d3fa46b46fb4ee400026aa90061173c9a42f98cc6c01f3b7489b0be4ff50dff80fde69d57ef562a46835e877ba7f8b146c050d5df323d992ba59f91925fcd3193412600c23d2318141aecaea3148c2e15e14ad255f29e2eaf13bf938bab855fb9f10c3885800ff86a8ca755f1317bf8edc6738cf73eef7fc5a295ded7bbbb9552355253adadda31ce5810a65fef9fcf5d57e8e1061d701a2f5c1fdc47ef955026284424ec2e4d4630447574ac5c4573791d83110fcb654b378dd7d08a0dfe88bfb5c9b6b6465e322aadccfbbc62c149a84a17cb66fff507d42807b6418138cd1d6332cded07159c4fd05b0f369fe6d48be760176611ea1351fafb54fd1a489c18eb301ca6e95b5a33662fff5995a49f1c6c6e67a10e183626a373405c48b9a4b8dbfb5441d03db0305ba630895155d6b91cfdcdcd8f616f5ad2cda8c71c5db1fc8ace49080580fda8481d705b853cc96b0349075896f8714f5d4c1405fe6c2593069d14ad56e57e4cbc461411fbc087cb0b1054cd4f3d0b617c58f92fa6e7210b9bf62ae84dacf40774805c6fa49b5c76e031567b7af033682e8c7a922df4bfc4df1ba08c4a73a1a4c042f4475811c9f7497504cb93e4383494b085682eddd7f5d00400d3d0a8dfc341e49ce79d7d7a0262ac68b681e0f51d446c4b286f39b01a7cff98c3a0e86ada9f40503e39147fa230e24950671ca21cbdb80de46ec2574d3c5e726ba23d92da2bf105815809ec16391c5c0bcd1b447dc181bb3c2337512a7a835c7167e22f5cda0652415d74e7a434abe6e4e87ffee6e61598027a4d3a217fb2c626a5014a2795bfa194248e3f618d7417c4e72c2c99ebee0ff669210955d0f59939fab6d8645abc2229ddbd3c5a3789db2583690105ba6e28ed98a3591a5b0816f521113e55528d2598151099b2c2e5be69f44ec5d0472268b4b6e35e1bed1334986f7f06ae31f39fa53562caf799e6475742e8aca30bf66907a824622ebd4363e5c5f6020fba49d5b446ea747516f918deaa9260112cfdae94b534839a175aacaba34c10d9b0a717dd1245e28876fa3ef3f128ad33ff13061ef20eba93c31d12503a6631a5036ae96157ccb541b13607f310ab2f4e0e676f6b8e997086e0f8a357c2571b8688f76a10cbf0f586fabc9602b9684855d139acacca05e463fb0d9c9c8c955042bc99ee5fa242a7acb9fefc489cee11d74f8e7e8b899e88afbd5b508223381bea510d0f319a8bfde7c4797bf497b5d780532757158ea4e62b2c4235a37b9e437467947c8b541db4d9a19a55be62578dc9048c351a3b580f46dc388faf475026354a82feb8e33bd82711c0d149aedddf776eaf109ee7087a628e78975d09336e5ad495dba580f848b94c550b0b1b6ab98bbee20a6c405e9c9b0ec878b928e46acca716cd966b39e63c3765f77234383556f9a340d65bef6e329ac5f3b79eac3b25efe47a4a47e06d5b5d77c576f5c81ffa6c030f27cb0fb889769d79c5d7f27dcc512fc45288062cb5138ed08ae444bf7ae9c404aa15500064dc9ff7be0c01278639a1bc4c8ad169644c6c6343eec17057b8ab6c815b5438ab5102a144a531f95f682a15d271e3b003d9a6e6aa03cbd62385696b5e1afe6f818e0b26bbe08dbe245f5cddbed07a25cbd2a046f297bbe7efe8f1d7a89a95dd51ed23fd560305389ad0a6c5d268843c61925fdf840c61c4e015daf28def8a5d4f08a1218f1e3da695a209cd56560a65c68a2ff9474460b6553f50e2a2a7aa8fb54472a7fa0f492b5f6c98824afc57c4c5a930de1e92c78b0ed5b9215884f6840c28476db6fd00d8bb8c9b52c4034aa2ef4fe3daeb9e873b58d3c752464b4b53eef63e88e403269e2656873a604949d226b338e8bfe58efdc1ea215569835f6826dabd2a4585eedfcef68923bcefea0b47e6bf92de6b5a2b6bc1fca106c0cde293244016961bf5365b46a369d4c9e114b10d8d7a00779dee54b0a73cc39c1bb8a109dc5ad56c660841ba7407e083b94aeb795e73a59b8325b287cd0013d548ed50bf7a28345686a90a1b4922d242900ad038fa43c0d43eedb451c889e2fc666ed53874fcd32266b3a881a2a08fd5dd4a0f6eb27a7063143a92db46c2f3bc2aeddbe3cd5a0e682ff01ff5a05833669169c73c7a1316a39f03a68ce003b1cbf9fc5da81978d4b664e7563b038a284fdd875e0b0ce181907ef342c5d03d14021775e8e169db47e388a47fe8a2872df2c4a5550783173ca094a8f81c4eff7184777f0176e7eed2891e86de1dbece26636ea453d9527180da4839f16ed77f0d48f50ad59b67027bc120c1b24e85131173663238a0c9176714507620d065ed833666d237efdcf47c0b9d8becdcec27f7d676df1094529f2bbbcafe7d790402df8469335427998c7c864764a72f9c6e37fcaa9bda2a59bc6c88972c4eadcbd8270aa96d6bdade988c97c856833c9f32a641e0d60df93bd6486470f5b73eb8b0a1c550750aee836d7bcc3f8645c5810394c8abbb77d6ee996b3397631470e3ebb91219934c615666299fe98f597cd9d4dd8a98f0dff34bbf8fdba0c35f6014f7368f7fa9d793d0a3b1077dc1dca80ca6ebbbdeea7025213419bda196a54d21d2a059000fffba4d3764b149e248782fa287424e44a46b02c7c6a7ac09c783ced4a4516cd07e8ba1bf030fbd1b110e0a89e60fe2698388d2e98c8a8883e09ea4876e5e243d1f07d1c5d1ed3e85f361bdb97f95ae9af301c1a2d6561c909083df3c3cffbdbbaedb556d15f54826167c52ab0b18cf7c877b648a4125ccc96d260166947ee45e04d855d6eaa5aa570eede2fdc8863a1eb85d2367e36bfe4575a10d21169a561c5a9e91bff27ce877ee78c8172b6d2675a6f1dda3b5417638f13904668ec0b9c31e90d7d1f97844577116544c38ea79a0d5e543de8eab2f4f73f466a3d2821eeae7135a4477fb070dcabccd668bb05fccf07befac33cfc5be8ec3eabc4acb8ac94cb37f86c9bea89b0c0831c15225fa742f329923740e9da389115e2f401b5f7feca76b5e89041f06376df0e286da8d7e212b96dc23381d4d6575b3499f5c365bc519cfaf5d9cfce098ed43fc39ea8cda2a764b72a109a9636b480ece1572ee523e7645baecd060b0daab92c2f3a8a5781554f79aa31ea7eb298e4ea4e3396d9bed66f6f2d7ae3e80e8c7ef99cf662619df42e984e5c8e32e421a770fe9e14b99d88ede4933f22097df7c348d46262e5d74687502261803ab3c28e635365bceb95a02b091afd5f58641bc52fd8bded45f03e6c4dbf042aa4e8f03e48a02dfa288efa6f8a24480e705c71e5905d81b67125f51a354a6a7b724cb87228992b13b71a38343bd55c9a18dc694a710288f6dd8921a030f556bca4170e5bc13b6e0555b421fb3dbf8d0932b0ed654c82f4e934df16e7ff785b59f7c1f724d26d8c077ca7b2a86ddaac84230b5b5e07d1f83324b96ceaf4346055ba924a7e335db5c4dd5a0620f83dedea503639a0e806c54786f0c9f01232796ca45151dec1758bd15916d50666f23296d5123e2f8ee75369f9ef5e06589ccf3ef69547f83028d22d9f0bfaf7b38e69b6aeea148e90bf02efc3484296c259ea6af700911c770003219df2d6ceff434f77ad5a5bb220a0b25e1ddd0222c7001511a0a90e0aade017d6b63f2e531c2394f61d21dc3932e184405ef910a3a7155ee787e50bdf69f96a961bf4da854ad47958f12d3c2b7ebe9124086bf32070d3fe43a2203981f0427ddcc2e4e1554ebe93973ccee3043ab2eb0ea5be3881f32b3f28609027c4d26f269fcf4f53cde5959dd7f8c6cd274ba563cdae402de2947174f3eaa16d9cd1c8c9eb2494cf5398a8ae4aaddea7e17e60daf203bfcc64e965eff2abfc638aa6b54da76c24595fff9180b2e646d9491f0cbb8965e51af346e06f20661fc2ee5e120314ed24a8661b7b0daf275565d23617e932194fd28e60b8808f0ef260cbd5a7b03c10282b44d556fd33626f9d9ef9a30eedece05c942fc6e93ebd70dcce7b493988c2bfaab13110ba8b72ddb5d672fe8dec47b8ab316a9d103862db743a887f92f7737dd3def1f9dd571df273b9af7c11f6679a4d280617acaf10f1f6bcbc3aa8792288bf959e7de49e57abfaa518d8b663fa5cfb0e62a02aa571e657efff07aee330620a4201f9aad4d9b82c6468796d6a577780858d2e6e2beed793d810bea8b8b3301427c2d1e950db2de9543c335f0d5383c7e41ccdb1a8238027ab6c1306748b209f85306917831cf0fb40fa56555be7ec08b8cd79c545ad5175e2336a73deae8e07be06574b4eaf6a6b3bddcbec593d708ea6c5f1f11a075b161d1ef5713f14b80c1f3f46bfd9384dee0e927143e415c0060ab557cf4c8d14423dff9f243c3352ed070bb17e72b421170e1ea57fda3663e29efb86f37b15ca27ceaf2c7aaae327f9eb9806f4665634bac3086ff8bf0cef8855b82846755ca7e425c92f89261e2d21e24e75365e09ee3717b615c2077ee9f272efe1585a4a65233bb0fc5be1ceb81b5487e5b68724556b747e61b9ff3cb332a17d5cf705f79286675053ed3061f7f1de7ef1d4e4f0a2c118bd97f64782a3e219b7abea06c2434f1225f5e4928937ab15c651dc6b19660f2865668f5be83fc221eb8ad95759cb8865ac97d669f1f12c7d738e0251e8677ad939fdb77ca0cdfc7558452ba6e70f7ecfe3e99386519c8d3b4eff5076f8df2a33536f8c0e5432804300b49272068643e7be80a5c11f71a534bd04dc69bcb35beecc61d431c390c6d2ca83280352d1e4cf6a36a9a4f8504ad1eb0707a33457652df6d2d59db1e95f3e10525400ea5fd60246ff3e5ba583b60d1da64707821e93bad9208c97d3c13a18fa55352d9f43413f99330a5f32b69075a72854b69b387cfe259a80c6b339f8ad032929a237821796a1528f29674712a6c0f6c60be408113dfda6301d9a165eea611b87586cd9e01aab57630c64ca35f058ae78b8f34601d961e74ae827f67d1f2c1c626e090fc24b3aa3a57b5a40ab1328b32eee9d0d190075f593f6ca8acab94f0ff2c6c864e0d6d89ee7fdf01cffdccae74867ce1521d4933f8392b27d4ba844b47931f481c574565ad8541c18f88e4e321c7c31e93484ae1559d7329d0f785812f04c3254e0ae05e99be4c78b4727b62d845fd3c121016bce306d66e8f37098c65505f0109baf4991c0e2929bb5391c5723b06428daddf9c2ea1250b7cedbbea95b182b095344ef6826c0969eeb327b2469433d470665278e872e4dfca00dfd8fd6ca1783c14dad84ccddb8e6901ee89ef1e72ec3f2c543da4f64c913c8dce937f3efd119b1595171e9e5c4ef91c7a7719a442efad2bd32ea872f9322560218e6eb4d668ac9aa959243a636a67cd1fafd43243efa6706f948a774f695d67f0b4087a90bc1d16af9e126fdcbd6797eaa8524a74dd480bfcf35542a3d38997728840209835739107e4499be9d39076f531cb46e179ee8523ab9fa1cee4a1f2f060305ffd6e27ca8e3785e84bd6d8580a1cf4e4df2d4fb3eb1b68476ea18c6d31d0f663b401411ae61b244966808b10e92caf53b9452c63a454c8b6275a7bfe4d4de886738b84a26bc2b34b0c8fcc890ed31ccf0c132bfe4bc18452071ee87a1f77a928e46b76edce885f08a463c0151dbb154fe3026c5073a2a10758e3f5903c92c08d5e965484e8d2d05eaeab4e5100f7f3016dc28911d74e4b50ae3eaea19b26e2c19c98af51c86940dd19816ef4bda80eb9b492b9c3b6b446b1d569e0d8d8a93e5378ec097d9e5eb1d3108680b58fd42d989786224228b2aed09886616322a3af62b85459968727a22d3265cbf6831bdd50b15071dac92a327ac5e1e19ef3fe3b9115f8e564eb6835b5f437a50d04e92f98991d3205b1f1568abd45944edd64553d684d8722d2b3648531cabe1d3a5c3b0711c51dc394285b3e3af7d9c35cdcaf92f33d3eb11455306a775ea7a1f3f5a1ba587c7edd874a1301469b01c93c4271fba15227a4600b5156b9832741c5c8ebd5ee6d30dfb151504adebca969645ac9573afbfe11abe6c482acf1d9ec3c150d7a8f91382bde700723dfd095225e3bc2a80131b9c7f415d23db66daf01a17af1a5a0b8d4f4e189515e27cbdfe8c75334556e1905a7fb79f81a353ebbbf1f8c800e59530e5179d7fa8bef9de9f0bd914d54e851a4ba37582413359ea3fdaf1b5b8ff63b450d470f2011377421321983431315d7735aea3a9c16ed02d474b1f542b5c6a075559d07a4a27a175cfcfe165a4e06ce6a7216dfa119d9539946b33d69a24edc974239702a6452bee114b4730b0772197ce68d337a5bcdbcf333061be4ca1dbd20fd730db959c52280454a153566fc3dbe066f986bd7e92b8861ce1af6c1f1934b7b4123eba9539121db8ff4ccd9db9933fe2a93f6203ab3086fa5f743e45b65e299e63b6a1dc223b79c941137bcacca645610b160215dfbd5fb1ee2c54c152c4ac5eb617262e5ca40b5c67b8c2ddda2119cb2fdc559854204e9cff06f4a3f53e25adec21e27de1ea438c6c4f4a388520bcdafd3881ad6230de0c662fc288019653df83707dae4d198541157eb17158f5591c8ad382615bbb7cdf0c698789835f29d01885613b530fc214c32392a70999039ae9692061b3ae25e7bd901106362dc7b5ec3800ee20ae5fa9e3447130636e4240eded1673272f6a60f1cc1afd92492ca994435c94bc1fdd1878c6ac91aca7844a56284561d897d859a9b44753a8dfb8c25a02b3d05665528e02b497ccb657d4dfd40c6183596b972cf3458bc0f0d40d355a13efc44b51ca287f0d220fb777d6a16b4b9738c33e441fdcd287e9e1aa635082d0e88e4d47ce39cab3d73cd8fd13711c33b5012902bac1fa87193917f42d63d85acd47aa0aec3db15be31e0c1eac1bb1d34f0fa5ba49771792ecee617d0e1b4689f56012d3f818b601ad65ccc8819d60598fa7e1cc7d1701bedff4497cd64985f2c373d74aebb719630d704f8cc0c0db6d94c44644ad7891e61182d0f1c77fd6d97c85d6cec9a25a8d3732308a9b3d7dbf37ade2cd76431f8ff347eaf9cc4f2688764efc6a3f0e62fcb71faf6822e528b13385b834ec967cd12d538fac98d9ab3c6211532e6bd859553ee8dee1b041164c53dc288fb6fbb6ca2195ff29af3d5e91156769ad50f50451625e8d1ac5811e86c97bcf7562d3ece076ccc47725e28e33b2877e43f9501e37fa3e9d36059b4a2ff20720f39a300b3f5162f7639d198d3a1879c980336bcb9cb0f3b04c25a47878b3af88afd0131aec559b6cafaf9e2a0eb63900be0c92cab9a32ec68a211c28dc62e43497a39760fcbcb1b2378682ee62c069b8013ec6f98b42c28faa7c3de44818e0b49969741230bcd250b1b14bbd9f2680f7dbccd509cfde0fa5956a09376e4b823e22233885f2860f69f608d74338d536b71376712551ff723abbb34967aff8d8489ac8a3211435e157da594b4af595804b2e9bd127e9969754361217447568abd6bae8ed0e43db26352406f7a384a99f5708db04005430b49045beea18ba9b1264806b3b9ad130eb26fa75ac3be9f5f8c9dfb85b65a0cc3ee95e3af13e8de80248a3f5620877d453395a3cacb4569631ea48e7709335cf6ea8492e009a3fc3a6fed0e2f9142b2330689fab9ce0d73aae2de386b14cc7cda5eac487ddddc9cccb138b79de727eb9c00e4c1e91bc6a0e72ed581ee97b5d8d8e833d6242fd328f54f43dd665b5bda784e007c9d78095ddb3881606cefbc515cfaf4c11f0a2bc37d415206adc764a06b3bbbe51088ef5549b16ed5cd4ebf66173a24119de6e884a14bff18cea8e0b7c9174188a76a0d3cfbd4f0d061513709930a3b94e208e4da64843639c8ebfc81dbbea0a8f201d325fad7447b070a1ddf0e31539e03d35e442d2d6ac5ce462dbe0171209faa812f798d32a1e198e38d99927d5a61cdf31b2e6e0136ba92fc2d092f11897a217bfc318fed1e115b44499554093deb304b79202a9d0139f793d0eb76d485d920f85d8c841c1f397533f1c1650f9ea868af10aaa4af596f6f7eb48f38cb8059a6adc995dea0f711","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
