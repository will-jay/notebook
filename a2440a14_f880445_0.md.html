<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24b93de015b4ce33c07e7168081c76b328e57c2c8324bd3c811c473ca20bfa997e8fdbbbaad04c46d7aa5b82826184710f3a818a297f7a63b63467c82146a28c922b6834b87981c67420844067cdd608279bb8a3989e899d2d4e1804588f6b05c4bd8998b73dae0e451ddb769a6da1bcdd8720ed89eb1120f9bb0b21b8f28ed02688da7a8c9ef222e9a2194968cba9eee8f8b5ccdd52bc302002edde7a40d26b2f671654b43a4b8e852da33fad67b294014169c20ff771aa8d84239efd68ce0f58dc7f48ff7786baf9b915a027392c7cd5d6f71c8429664c3f6463f26ce11f7e414d24601fc87f45f0737efaf0eb459644d17b5d589bdb1dd7170bb6cfd4a1fc053b203ab69b861c6273bde04d34f559e37b09737786b39f82793e15a4df10e7d9875bfb1b707943e9a94639d0d1c9574286e3829bc5bd0ec54c19cc30a1899741c740d1637fe9159a764747dc8ffc681814a83ec790fed113a8ef6132b1380982f166c5f71e8d203784ce2e29d63e64946df206f99d839859023745d7065653843d57e1fc88887681c0d6ff9fd5d4456e5d5ac72c0dd7a9477dfdb13d84ef45a8f2033765877409a8a4f9b452d934e95b161c69f3e0f21c50a7e99c3482cb71bba8040d956bb2f9f5963d0439b3783be5e5519d7a161d5f43949a33fceedf79116263601113d25ec4c12839b9499520f0cb5831aab772f81cac292a3eaace6be6e93fb0e3705fb6c51ff3776adefc817204f9a29a46dbe713e9853a27cbafbda6d142934b68fb65bf1bf08d2677e677f468d800b4e5df315a409e388977c580f84fccf68a3379946f37e21c955101b9bf2d52ed0f2a0f1d56a07334202cf6175d97ee267da564f3b6d7eee3351233d2be63bc8f5bd519623e643e9274421b873dd0811080fdc5df9b2b2ef5b15b480dd574d4cf446812cb14fca73e437a59fe27716ab5e6494a942f0242b8063fff5c700b9f73ebbbe19735c42ee6b3b8e8f9654fc5a4b030e11d2311090eb1b3cbbd0aac442ef93d0fafd4f4b9477c368827d0bf6653417edf862b33219cf0ba8044e87202252da4eea3c8b76ecb60ea8d462767b58a054c4ba1d9361f38c8758d482ba609dc511ebf2ad2764c0436ef674f9448140f7f4f9ccda586a3dca3842ea0a1ae97843c8ab340a9ca0cfc65b5e8c3fa4a55876f04f5066b67b9c1f86d88ce3c69b5903b3f538b88ae0d0c8f143454b64bea0c66cdd16fee0038ad2b7089dfaf0dfbf2500f5a50acc5af49794a3a87f23f1f7c9b879e3b72278c268025c52a093106478ce69cf82a4442c4819abb8ce7a6b00fd90dcc37a6db2ebc9744d2222407b7e35671c76da050db019c517b43cb5bb70552f7b3c34fcc2ce22bb98fe44e4095306602b1eae60d6b1428c43ff90cf11ed4be64e19e6027467836b9595bc9152ec989edae768e68b3a78774028b65d8735a0cf97221a160fe953db6249ee9c95af68130eba4d790c68849aad77f590251683192f886e8087ad2ce691172049a54ad7c9e2c0dea8c12f85efd5a52f8149eb570118624178140934b5dd1428f76192af5be92b8541409b41cb2fbe0c902898255ac27a7e81f4945808e702a2e6e305d351a977fe096f35619b0211feea19ec0581580d47d45f4b7c97c6bf44d1bab956c5a82aed39051c8fda9889c3762c642e77c670d548d3efefb49baeeda2a708982b43953e6bcd34a674b8dbd5f3c2e86b1f6ca3031e7db9b068b526a3685aed7cdb99b649647b54fe4e640f4ce2cce8411163069eb2b15c305c9555e3fc4f0f69cf06db6419f44cf710d541a4cdb5f290fd9d9ec2cb4a025e9ea8fae2d4fe02143c61cb442e7f469de17fc4ac25958e3cc0042481abdb3314beb10bed20e468a5c452b77ef5aa8d309c8f213cc248105c3611280a12272891657b8d7953e4213ce203a7be5b5b18f079ae735fedc913497c794e99eb983539466e37e1b4653a752e1820f7afc5a7d782cd43ce93ea5b4090c9f81263acb529ff0d14ce95dd0ad3a0805e48ba9e4239aa2e124e789920899fb4b58b68b2c2378086b9c9ec4b185ed4ecbb0ee365126ae92de1fca969ec50d1d292b0394fc3255ab0c3be28e6588d714a0a9eeb8ab635e897fb010523c11df0ac44b28e8881b57d3a547fc740363a04484280b50784efbee99275b168adb32636935d42f8952283887535306775c9172c2a69295e34a66a606fa4ae2eb2f93f60c3b6507aa0a0c859b1d28452bdeb18e5a6617d18d1c4076dc2b690df8f63055bddd3d17f47d443dab9a9d9e9579515229f733d2c4bba35fbbd3139d49c775790de29ace4fd0f45447a822fa288f2838318ce8b5cd4b753ae18e879c6a7fd4adf0d534f5d9c4298919d350a1b3bfe245653f2ddcd57917b42e485c422f87e76334cffb84183c35d38b2914f3b53bbb0c5a85f84347d4a7d8e2f97688c4fdd58dc3b1dc96442cf39105ff7138ed417107effcf16f5f1190a285e05aa41059caccf88695bf5a7806c1b215565078862e4cc6f77c4dc904252d560bbda29bf26a3223b2787d4b9a98128918c5830748e7a6c76c4b4ac5cd57d1748b9a0e6ee007caed92be7a4e835b128e10e2dbeec6cef9ed3e5c0f8f31197a152e3b1937a07c57db70de525492950234b4a3a73f784dbe14862186f22bb6d70afef24403ab2e24b2cf4e42e2ec3b4324738fe988b07d98d9d37c5681b283697539ca7b923024d969f09054bb85f03825569d2d7ff5b6eb367c985bd4604e0937af04b8aef52cf11359838e5a2d28ef7fd466a59b5b55fd898da25cf9a18e7d5beeb9a5e6d4f65f223b618f1adc94feb962b7aa1aae727972df2e30a7f0ead9e631abb6c00e1456472a31ee18ea12be5e6fb4d1d56fb1c7bd72cd5fc8c0b48a19e86351883db3b21a35141a34b829e543bc4cbb914522013aa0427041d2f1851bdb1813e1dd33fd4019153ca504af08ff297db6eb295a413c8312d42fc15e3088dc133e27c6f942415e297a43472186337ca4044ecb73a723ef6a5184a8c100d6fb5e5373b60ca9a93c45c0e2047dbca8b2b9110b9ff8796af1ab1bbb3cefb5017ff020fef92047d37528211096a3bbc630ab46dc23731da13275db248510ef7644f33a9c5bc5114efccc354f990e5ce003d2d6aabe73632eb00fa8b8bb738bbbf04231071ae86ac46d7c7b80da72084b1e176b721476431cfe7b8b6cfd09657deb9eb534d31014751744a7cc3fcaadb560d1b332a3382ad387c28f6f722314dff388409e3573d5a14b8aa61057e265f6fa5fac286b1aff0bd1b479dd6fd421d9ee25216ff02b84eb47fb31e86d9aa6753d178d777c948b3f8c5e3043c6aa3d866b046cc28c9a0b07886e651cb227366a922b30fab05bf208bd2dece2201c7ee33ec952daae1aef51362a95a49811ff2e90d704be25c19be740907b1cbae65b038e4a102cecee386e434915d4f7c756187e30a343acc5bd59b4d95e9d6f3956ffba4a8b2b2923ac99a5fbcc82d26b18e691f2cb18840b5022f9dad6c89313e7872cf576ad1f7fbe9c59321f2052358479a4e5bf93ff98506430646112c246095d3b163194c9dd56962c00bf9433ff57d39fe88757b28faf2d716d43d46a1413a40821fc1bce2dd8c462cb4247ccf1fc08c2ee160a8c46db2e140ee6df2be4a1741092c9113c7c5e6e70534090d688486e04ddc5da740d56b59675b5a465b2510b9cb21d567bc2fbda1536881a76932467e196da30b90a0e0e45713af59c77b41938a8d12c5b6f8467d0ef66ecfdda10603ec163b07d19c814a00512b34a96d8b15d7d55fe1dd33a7af6e56b4df9b9d4ea599354518d7795e52f59eb7f6509cbc3e5e1f1cdbeb47717e5b0e1ddf7067a642b4a9b6f6e566b1c00d34b5568beb7536283f255445acd4404a6b45db9d916e7212c956666107c61b50a68db23ec6a2d71bb9dfff5be579bdd2a3eae754668b162482475330a07f69d006cf7a7129b9bb214b9be5761d368bbe7b7a63fb05ce8e1580ad865d670c14e5b4a5495965fdf8f61d1e25f9703690668b6751f2024bc91e70a562813ba5b0f114809169c09db64cf2ecc3df9e7c295340c62f7e28158b8d584e501ffe6a0f228185c630631c4223ef62ba49d4d2dc493cafaaa9e00047991f212e51c4b24d7c60c47078558102c293af071ea495e9f3866095ca5eb027733310573b309ac9777221bf9474020e47d9a50ac61ced7cabcfc9a46854b1ee13f237aabdedaa04c6ff2c3e4e978454baae04a3eb767599dede3b4280920a10916fd233fd2463733137f337b23f7cede6aa7f4339d77ca706cf774c9f24adcc886031b4279c2c3b2eb1a39d150d43222dcaacddaa53abd98a7a12a2a50c94395f2f610bd776c331dc332dd806ea97b6b849788f4f39a85dc662835b9178a5fa6b40205e2de112359d72551b8b640425d70403e6260405accf9e2375bff6819799a54c882607688a53cc82968b5c0dae5b9f8fd28f6ed264b2742a20feb7e4bfa08c3ba2bd867883bf9fa62cebb1982e584b362fecf8919df0f0eb2ee3a86d66c4b2fc3e58613272aacf702051fc94a29b8b9401e28ee80e3799f26099d3a1bfb4279c7acb61d726e884e3e6578f364d115cef4fac4be3f98484aa4b1f969f1ecb59403b2551ee4a4eaaee1c0d88b41965b7a9a80edfab026e4cd5f510522b96d239edbb03d392a2c141e0b8f8b17cc5308fb3f81c18ad2b83292684b8c47e48edd5b38e27f7531ecc8be5e6c22cf6b76c71cbe8b24b043996a4d3759150e5e1fd0676c6724960fcea98d44713636cbd7aa3a80610d655f9545918a5829f2f7f4fde95ec3de8390e54f4a45dad0a9319a3acf65fc79a1635a3c94b608d70918b0b2e0216d0f0ee423c697a2d402637914964a5e578b17bf4078026327f4dbd9426351f5e623492c252c455d0f63966d33c21b658d3a23539c9ed20586abbedd1e5a3fde6922442941762fb7b15ac199e450b771ffdbf0a415e0c2c74e29ca63df27c1a2ec4d05415cee3720d4bcb472a5bec6c23ccdc9161f56b7f6d6b3f9008c8de42f404c537aa21a7e0092afdf6e36e31bdd518f2d89eb9cefa19c3d412d7c1bd744dcc42a05ff7149c1f7a13df5824c1740993cd1c30d683ded3dc5f850e99f68bc5b51b88b9df8e4bfbfc2f0b37f46a5dda3a986da46aba39355040afe35bc5d6294c0d0833c742e1ae7feb450dcf48fbcfa6c678bab37448463182b055518c6edcd20293e8d43746ef10842b37a52f461bb41495a181558549cb610dbc1bfdb77ec6d8983f5822762a0e16268346368e7068cdaa933e750d54f54f79f5351b185f874104491be0b4d1957fa697fe075a6cca25589d401f50d87ee27a97ed103fd1d379dc100aca9d379f798f1e1d4a0ecddc3d21505933606e5b37068fd73b3451c4054aa969b1eb7989406503fb92a272f073df1bf18b9c2625a75fc8422a150b8c16e131cfcb0f484a2759cd130c97779c641ddfaf39e268f8b0d748128f0240ce37f25e2518329338ea4072b599f72e96c5efd8216cbd549802c1fa7cec1896f1516bb4693ec896d66557aff259a7cb0d0d54cf501c2cd6588f67350c47ece2f69e6de8d8fd307218d84e3deec28cb36df618de691a01157642122be128fe1930262bdd5d07cca8bdbb191c149b733409cfc8cd1c0364bec8c2ed1fa0d93276fada5f0e7ece8f29132c16f5ec8bb4616ad2bb4a55c83de5244bfebbb878fb1dc42d7067e1ac2854fbaab8cf78e25a4c93516894db693a055558a72645f760f52a80d2b780fba07d5abddc6c8fb8f9e737a351088036b03422c23f0ec22b0b97bffa5ff34a97785010e3d4b920735c2f283c3210a816ff4d83aa823cfaa2d124178bf33ecfaa09c97a989c5df103af9e363727c3e1a91700a96c1e77d24704130b0ffdc76142bb8edbebc666ca118a89ae59bd7d985f0c0f774bf0d0661acb290bde89e5c4c7e3790af8b27d7c8b30051fd0b770677932d5aecc3dae15fba87cc4e70db184ea581b2a7cea462608cfba6b7c27ce5989053caec2b0dfee4106f5fe336928435b77b576e9f89376be17d5899f743d21210b064a60fb2de246a576f3d425bce332627ee3a248eeeb306c773e761e67fb6d1bdfad1536633f0db0da02ad17037e382c9cc304dbd167ca296a097a8c9ac91c8330cd6c4cdc2563a49c7feb446d9e056dfbc93886906be8f7ec28e2320559f0bcbd20ca13013d1b213eebc43f288bf641fc5e09a777e852e1934117e3e5e8c38080c4960372d38e8f68fb0640f484de7af33fa440e0625f1c94defac4974cc161259038fc7963be480b8d796e657da626f8cf30b6e52bc045460f441bd8b6cb802711e5a2bf7bc4b134d27a7db6778e79568f96d03de794781ac029b3ba4e131070757d0eb222a3d15a9088cd5092a419373135978fc6f05b8c43fe9db8350b22361fb45dc6ca56d715749a6fa859aeaa1d2b6bb18d518bc9ef298443e36378012bcc8ef4a2fc4b38a2f939e8c385e92f2fe9e97b0ee6fba49b08eed5c9ff2b736426635486ac6bf55f763b1df266584168da9effa8cf41590d8fc5516625ece07f19b60e038e2b4e1fcb75f574777bdc87b6bbcaa87ff00af2e66352dc40e922bfc191a1a01e5321d2d251f2886c8c30eb07a349490e6320349145f816e048151a9d819064b4f045dc20c4aa98eb2f4f67c83a43c85d275761b67a152a6f0722267582d53ce22e100e4097c6d77c0b25df7479d19f736d14f1e7d255f225093a577319ffd3b4369c74cbf61e836e40d175c8b6c3bc0e75edb38d7ba34b61543f7c21b39be93707d92c34aa5515ec752bc7b7283cb8fd9e34331304d94883cca028e4333b6c686e92f949bfbbc31d5bbab4b51a7bdf321363149a3e62e6083d2476844695e2aa566471911f5be119d1d3d5cbc3d4c5a8792863ffe527256121a7b6a583c1c0404f5561ccf6b96902b73f0becd671c47a9f532fd5d04309cb7a40a2f2caff52d0db54e714b33a6f954af21d00d06bdc9a77bf6ef5215606a6edf5f5efc57cb11c8750257e09d0e9ca7979bbf821b743ccde3e592abd8c746100b29c5bda128035f7d7aed865dcddf7fbed430afe03d9549fb762be2035302a427985b505cb3879bb57ae1faf043501c97f1a5f28bad61682b205b8a924e2d5e3b3f5c38206335193bce4f0c58cd47ea4dc0728d271273b5a7297f7d155833d271be02514cea1039cc255a3cfac4d9e86a67505beca230b118377c5e094b4cf7552db410047f125027c1c11f78c9856a05a32bd5a5e971386e880a993316934113f4aa5f2d26b7162d00518640b6f03bba8a163c408b32559ebdb81ef871cdbbda6c967da7a9edb26cfbd1709d0320745e6d56d1ab2b646bdf8d3f5e84d3a266266984b697755d6da0f6fd4d34899cd3bd45f02f0f6f54c9ba98cd2f8d5182046d549a8bce7d79e022e1b051d777fd089a93d81d3d9ca9d0412492aaeee567eb1d03bd877fb73cbe780bb951396b3a37dcb475a7722445f7663c159be47f9bf15bdf96cca2584e0f79099bedcd1863350395e7bc14eb25c3c3b10205814e10323ca88bd602e7ab25eb8ac6193c95789375a4d215d1e2ec1a671c0ebf84831289ceeb06d049fa538c4f533ef8c8961f75ede62493f61ad8f22b233808a7655a70ba06442ab08f788b3e96556a8c2eb55f40b459b77acdec66c408930c940e2dcba434a32fdc9774804e83de1f5a79c34f3c241b152391125c661837c07daa6ab406ac64dacad8ce5e334297a6e1e2c956b17741a1c330bd77c139a0cf9d0df06cdf4e08200a1027b60010562295bc78852aa32df1640466fc600b8944c091016da4ebe94117d3652cbb124d79b3b02b624ee6499408ab7f4eb5785e61b2313be3bb925449bd9a0970201b95c46e0e949a9fb14e1c2873ecc940f15be7302c5b43bfd07fb6951204dd61e843ca14b2922b0153af3dc86a3abbfd3f7338e03ee4d687dbfaf5fe8f5f4d41f51b8c61835cc1b080c275f52d460293ce86c6521854cff9b8adbb4b91d5e810b4af9725b54f7fc731b462106e05441294e8431c09474209dde387274eb1e80dc533bfb698353ce09c2075a9a87590af4efdb267e7d95d8fbfa31dc4d9f65a22c2b320155e2e25312808d5c7d7a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
