<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49422bd20b8029f02ca4cf15729a99e97f194e1ee35d4b38d34e3b84d735cb79f8e83ada3e658cd83e4e4d3096b3178c83bb530f5651f6f6bd87fc6ac9c1ad8c56bc45f73af338c129e642b5b8d5dcf8a4e70951a0fcbd1a4b9b2741ec8ec7d8b10158a65a2bf78e07ab8d22a0a6889357672bb0b7eccd9d45a12a1245f54a8533ad8359d4f8adc65939fd1cf19a29c5a90feccf353e5ee984fc547a630cd0be0c07babb5df0b5935f6a88ac64ab02fac3c4a8e9dafb327a09e4c8e4c5e2b15590ee1ae940c9f776b5bf44f7797b6d7ee2e0cc6e7b1106c21d86024c66664852fa3f0ad91fbc5b650b9aa85d4e5536c2ec9df1a360c4e8c78a6dbb5d3a5f1f8d24e4607629550e62a980895562a9cf046c31674d953cf9aaa668b87d63ac270876e95c4d98238faaf6f2e3b9d04c496f74ce020f006b17392ec19378062eafbf4b8f9b02a474331c1e4f4f41644b067a51d8aa0734f3dedd4876c78374ca4aa9d88701191e680a0e7c26abe74b26e872a2a8fb89beac2522510a9a8e02fbc63b5d6cf5f14fc9b11bf31e9d1f72ee92a5cb61552b5175b1819bac9172a431d6c9a450f20442a4f410f43844d5156d8f1b878962f401237260d0f62254e69b4025f43dfbd22f46b4cd5a048333e207cf5fa841a933c01f93f52c70e72f1b3febfdca00ca7a69711e8f01adcaf1f5c3b0b40307b6cce01e756ab43dfbc3711fad92fc5544328342e906e1b4d17fca321b00c85b5a8dfbfd093694719e6d925002ff9a3be1c988a7957b1f604392bccc2f04d0318bd99788c4bdafb81ee06d494d3724dcf49f7d5716a423369f327a8cdf4988cd6cf67321aca2cd135508c80293af37c1835aea2fdb7f6210679b4ee6b579627d86126d0a009d1aeafad41e0fce01d6be2808a8c425dcdc5543fde2dede7e9124a89ffcdea6f269e7f8868df23dd33e9aba3cf1b524da2ba675b70836f1ecb110f1e17072447a84bef3cad6968e3b801680acaee26d59ba52e6147447239d8d89421b4d30c8cbccce8269f2fd41f2e8608fad7919314da8f8fed242358f0312e96b26c0a1905c0c28abc2bbe5f7e50f137470b2084f8b43ab36e6d08611538667b9c9d8628195ac67878005cfef3e7d19af5fabbc47a0c84190fd1951f584d762a4ec6cae6ee6d7d6d071ac19e224e0a49f07dbd65396fcd067aa3e6bba5f6234cd2c8fab2482acfcaf6905d8ca9aeb263a2b9174256c52d44be20269e09e08556b036cd2ed283d69368602a9f62afe1334db57f554858dcc427e88127eb50ac665f874344871d14c52752b63c9432dbff0b785b4514b5ea7f502b60c347caabc0688cb3db68404eeea147681ab49ac2efd46d455266ac87212f975015e5c7be8b09e84c254e8ea4cf463633515ad10e2c038a7b12cf9ac0b11473ed66a81f60027daf79d1460cbf380699c9e21d9bbef2bc593e0d163ce66e775bba294b6c61843684b01cbf10c46e69ebd24ae35d7c6ee271e9cb2c59f677dd3b538b24774b7e44977eba35b9440a5b4298229511618b607ecd9c0f3ffb288c449719ade22b46fbeba06db9259c8a94d4851ff003f018d4c565bd732e28802126413907f5b989865819da09c280c6070bd1bfdc08462f1b66c0ddee69e560ea4849fde337cdc07839f8c4274eef2cccfe64e4675fa4d03939e427e7c7e9a6e0deccd250b3548c2d7e419bec0aa2c6fceb8e3bf9cab97f6b51543a5fbc7b190bdb23e63b1c490a6a569071f8cc69b94948ad5b2a195f3627a92f4984c499850dacf948fea37c3609208d067623e25fbfc4e86f86ef98312267d5e4618c71b3f27af5cb13d5ec9bc6c6a72d4910e9b0dde687eab30ed84a791376cf06fe327e72a4ce21a22cf84a313d198ef4a328c5d57229585bc09a5bc8fafdf5c9fdb907cfc40b599b8a74be4248e3a8c9474ff17c682653c49b9e185b5ce84e19d70d15f9a8d232869a1ba97012a6dcc6f23ca1e015d0e9d7e5c80965321bb9cdcc748504c6573b72331bcbc30b3c49685fc896368d513a6aaf6fb231bebcad08d22d773fbd5ff5213903bf1146146ee5ec0c72b13a8a0a5097c7b50f344557c6f6ca2b3fb5101bc66d8b926b0049c3aa6f8cb9a36ae410e3525d17ce5f5da5a79e4ac2236d4eb10295e711ea5cb889510476637126cfcfc00207035045f96c7f738f5362de809c746b814fdbe0430543fd2d7ab2d690fb59c49e26d2208bdec40f208b26612187b2f92aef9109c5768d4e709fab0c4ce9626d8420c429469bf44566ad00754561f4fb8d5139675b564ec5f1a084204a6e8c2ec86c9ba353c21a311a39a267e300b6d4c212e910ba593075f8d66720902d3d9262eed98f1c052585afa77e5a114f316fe2c009f103884d0ebabcb45fc6b09533088a9055da748a29fef7098c6df763fcb9d4ff2509513dd7558daaa069924f4964bd7116bfd6936c060b8ac5d06b4f682f22f3f2ba71fe8b18747947a41f601c034a82cf16d70967bc832d4b389ca3263aa1f92d7d593d60f7fb872923b08baf99f1e6f6370b2ab95d7bf13158b9826b1048159abb2d57957cbf2f69db5ee4df7e73daadbd940056423e20650c17d8345362501f7c6d705c31348d9e2d41a94b7438e17e3d5a132040274fb49872d2aa5139cd567f001caf930437dce6472ddea1001a11537d2dde80b4826f4c01aa4b7d4a7a71832b3489fcf7c901a53c2bc1c896123c942426eb85783b77e2caf770ddefe24dd26e8771b591b55ada622dcccf02080c77639e4c7e33545ec4490bd36a35476765280db2950a8b18b8c49452c6ed0efdd10fe771bd7d403bbf252ab85f4e90f56bb19bb66c89d14c8897775ee9d392a47ba8c44451e6a1af393c55623168d93fd1e50d3c45f9ddd997999e3768db80660080f375406f96dfcfbb54526960b6415bb6e9b570773d03d82f1479c51eddfd3a48cca7c59b2dbc885dc6ac9884931567798ad61363836a08e76d8c8440ff43523676a64879a349bd6f213225d696f7bfddd0288699b118e889a58c4e390159b4ba6eab20276e3dea19d7477c1f6fda128ed726a55865202eec7fed909e22db31626db1e8ddc3e7cbbe80246cca9921649eac5764e43609ef2f7d348a9b490c174650a2b6b30072b6706db449d00719ac199816dd8e340cf07541474cf84c1f72efcc0b70b39a93fdd7baecc2335f03ffde164b073374e04afb45f3974eda44363323470eeb5bc86e76caca845c84a8699952fbb1368ad4da02a158e644622c17e9f726784a5ba1a773ff2e2e9f65da17e162a2e8344e5cf326e501beb7a944d0c364fbc8bca2bd2655130a16eaa32ba92ff89e85d8a3e1dffdfffa0ca449a6590bfd1086309e197e2fbaa77bac33e7055ed38dcd55829de5a518e8bb314e798d9bbab220e5a640d0f05eb2f82b7603df3736001adb8e6d7a11a5884ec22c64b32c62aee1aa514dca5ac7bac50955d80816c01a362375665848bbaa9cd81a0ae7707ce8f3fa56f19d77e0f15f33e947baa3cf7aa37a15077b9645f2869227c585730cb985c027de6312bb95d95bcf25d7e96c6be536df4277d04e73785e1a78ffee2f7502d478cada7d0907693d7fd32eee92e67545243a7948ad92eb596804e4fa3cebeca9f13b13f669fcf324be8d347bee739754bc521dda41466db38e0991049b69a0a6a557fe97a9401dfb80919f88f669c860344a7ad43719bc4c9e64a5f12c3390c4305617ec25a099ff9097cecee290e9d4dd5850358c41cc69d8cb42aa42f6ae5d8975c5c46f909540896e5e531b7dc991ad4be902bccc41b2468d8365e911cb36c93df5b8149416a72f5edaec57c1e6eb13bc7746a4b5624e755bd7ab989dd3c288c52fa021c1309851f1870f5355b0e5e9c4be95fde6dd16521f93284dd4275d8e924c06127cc5aa72e93bb33dfbb03dc7b1ea87a4a157635b048e7808e13a46c2d4abfce2b6eac2e32287ea001cdf38f5c715de6281359778a3fd5b7c661550fa5f0a58102c46130bf60b0e7d6c740e3aba7fd4b2650f0059339f09075465b796ee906cf394dddfebbd455e74818793d1d3a92645125d6057f090855381d78a8c2fb814fbf12d65f4efae68be9c645d1a3d323a5c16f02d5e452b3699525ca06a4114ba93218f831a3f0f08ad08cefbfcd3012193068311bf6ca2e5b76446aa3cfc41993cd2476a02cb89aaba6b084330df0d5da669cca5e40438d24bce514492358003f48fdabba6536ae62d0bf29ed704f8ef231cb1b6822c80b41c0b29e0e7b77c2ccdfff86c81da9c0cb918059b2f5afcf3d1030d9adebeb3e3cf7559a28f8a47c78c21974e0b370ccc0d1c7cfab5644ae15cd6c4cec8b4fce1d9c91ebc1b3f8db85b97f78765d8e18327df1b40d6d29c3a7c56e5e80a3badd6676f668fa15b3aeb98a461e7174528eb357be429915acca5953b65b0f3b010bd2b7297fb51570d91e8ab3f194b14468e1f430aa21f55260ea591a23f91d2d84b454582000b210c77196f2a68d46081fe8f079431b6aaea6baf2e73adf088accb90f15781ad6cf72ea01e4caeaa3d2a9c781948ea7b76ccd107c70e57eba210acd44fe08c6d8cd89d2d51646e92098ac02e84f557e86cb61e8a29c306227038ac39966ecbfee84b4ae1e858754de1aa9ca1615897a7722ba6d8a17f200d99b089c46d9b7dc726141571d0d1bf53d1a6408aedb4ed83815635bf15a05b53d6126be9c7dbbef4749ef0cf228ba0802f1ddee4b587f1cd951c2ed3a611242b5c46f84e6fd854571bb14acb6085d70f7220a2e6970c805b248eb4ee8b7b20c0deefa5fe848ede6df2ef10889b041ce02b1aa926c2c43899c0f6f4fe8a694fbaa92f5e24744df784f98c718ddc06ac6d91616e575c7a7b5f7941c01869a6693f4af04ae8b84672ae5602dd2dee2b159390346fe49bd64e28155b31674cb2c824b2c71fa12585cbcfb7e43d5494b297801dd981b8cc01f77f251259717806381ec591204c62fae6efa51da3489a081037d2cc7e583d830b243de9af4a09457e2cc33f309ba1b169ffd511cbb0dea081997fae4d2246053b76926d3eba0b941715b3687d1369107dc6ce4c0a2b372bd3a517896db16de9bfa4e274342ff0904481d97255bbabed59ae9f0bf2b4b0f6a2f688031b1d883aaa9ff9172621a8cb43cbbde1cd7eb3d32f2d269323b0eb53b14b01b9f02f6e09e1f224bcec4e5c81a9e2df01d42b43aab5ede9c7bdcf9163c4226d08e0ce6550b1b095419fceb7b56093420d3f283247636c3b7df1d80584a4c1e55ea4a189cefa30c65518a0b8a01e38ab6502ec89c8d698e032af94d9d2101dda93df03a73703d48f9cc94aa6c4be025d15887356e6a8d59d13cf5515f8155c3178e5394bb936b70a3d3b8008cff1975f1147d88550ebe511a05df03beaba88dc331178114e819150b7145c528ba70a218a07ff7087720e1a0cd14065389b13fd614b6416f36985ffb89efb928dc6c47f9a191959860aa7725aa13a02a60b1662b3d606c8e1193cfa09b0502f6c8a71b41eb5a40f1513b95084a122ca646282f79fe19850801d19bb60720272dcd10a3ca6adc3b49e2e01936dc4383affebe83d3914e081737bf2af88a8253bc52c50f3954600ddac5ced63d56d4b65283c79d7943b259020bc9f04d3067fc78f47d459a23afba5c1fcfbbdb3ca73bfb6a1edc24b0898e48ec58086b6a829f4840078582a99736af6bf10da2c80cceef00dc24333ac58796e064ce9152b6163793ca7f093e9315e8ab8593d0c3a5dbcf4e0d6c1e6cca1bc7106d7bea268f40cfa1e1e42018cc8e4fbb8c86fe453842a4c83e60b187df3fd809b26376309e9392fa30ff81f26fd14c52de694fc74623e788f7933b6f3024888a88c15f74d5fb0a9acf5ec35e508d4e0a1dbb7bd1d0b06508e7f7362223ae411f3fd8f85a81f12caf0c09fc6cd9020c9891e68c467606da09485027e43565e7e45d592ea93f6846b1f7856ef24543979f1ab0e2436734f3cb4a91e98b50031e1b92fc1b74437600b879a6dcf63ce1f0ad5d485e2af78bad5d717854fa7b4492cc0b72d09b01db05fb392e583e0986b79596fff09edb3b9043022de79f94f41a2aa67692495d6d5ac618ed83fde75e3239aa5394fb452f280efb668f80f7bd873437e35ed9fd8ba8b6b946cfd51061f53f3b666bd9ec6537bdabb027555786c86a2e47aa540579197ca1755d798250034785bb315419525a697b75da19727bb41640cf45e9c04eb57a1312e463c33f7080b43794590ef41ac53b3b22454156d535869dcac1ff2d7c1554cb4784ae1fb2e1b9f6011af7ce17a91829c520452be08eaa88545f43b007455e92a2316ed67cdf5ddd266eaf5fe3e9b819e2ab2f905a8611f3b5b3e97eaf5bdaeccb78b6324d92c4cad1caa5427aa66741cf8a3f6ad6c15e62817809c1284eba095333b9cb4cdcf7296205c008463b4694ac314713c903ffed8b57314029ec90c1422732fa250abcc8272916f92fda7b9fbc4b90ca37c46091ff431fb1e099951f64faed6e16f449dab6d6130e64fe0f80b600b2556a811e3537f69cacd433f0cb43999dc8606826fbbf6d8a07e8897f8cb4fdfc6b1425c9088c66b6a058150002cc2ef9136eeb37f7cffa2fdcda884eb38f65fc56d87f5fbc36c2d63fd6594aefec4d45a3f6da273b724dfbc699cbd22b8128235444758a6e01fa9b7e7f5cbcb46586f0b333b5b7ded4c18e8af801b4e2481baa3a02f5f92af8388b702af8e92bc9528fda61734a535db06b13b3b58affa5a2acf34065dbbebd93b499eac2fba5c9c34ff048c3adfcd65c0d93fe0c1f12db549b73799798934be0f8153f374f83d8f409324ea9d08f61056e2a1b48b08b170bacdf6b7c76b784d3783c5bee8f6803f7ff21634bf253ab0da261b783f217c50c2777a3737f6346dc88fb2dca0ff1114432cdd731a38686ac41f45cc0ce0e3c4257742db128eb1757ac986d0fedb2620684ba8b5a4105fba1ff6e4b70de900cde8b184166bc8dbf0b3f88f5d4042c353e67eafbeb2d60f3dc9a78d29fb2e5132771972e6ef008363eb592bd902076c57a79ddf8b99ba00cf4d65e9d11e3d792e26ed06509295cd2a79bdef337733e653fbb6eeb49615e31db090e43de40471409375b2be4a4da5dd34056d03a8f26333ea3ea5d542b29e05ae9a2936aebad0bbff980d4c87d02f357711835de1228e22914334cf2d827deffc19f0d11cb0b6bf815af32aa375744a5fcaf2303cb8b691c3ed4396b55fdd3bbb88f2e5b62c3c534d12907994c2440af7ae2069c494ebae152e9c4b7029d9efb7fe74630a591c43e82517d49a1a4fb39c3d709eece9865c133420a9b7b80b8b43fcbca7d88669c8bcd1f8b6d1d3694842a3a1d9ced6362e2594ab9d5134e8793f0ce049f6b1221b7741988853825e5bf5c71cb75a0987c3390e4f5f4c70903069022b8926f1584a3715bd7037ce547e5dc0fed18e062bcc6c43687a6e3fd03ed1d1ca5d6926efaa44d147b23babc15efe1eaafcbc76ff691ba9be4f0461988b566c4268585b41080bcf50f35c33f68742a0444619ab989204d8fe527ea12ff1178a8aaa1e501b78967ee8ddad201e517dcefcb760eb69c8ac06cba8af229510234c362a02b1763546a3ddff780d7954297320169fa23e7b982c9a07c292d2ce93e3d11c10e51d783ed15261774c5b894ab342cdf009d25056fc844025d42dc0dc82fd0da75581ed885f7d5f30de6a0338dba38b0cf4c7ec29e3d01960a0fb799398206895511edfdf93a29162170a8860a2fa260cb8234d0c0bff7f26839f53328d2d6f1e0087ebbdcdcbe1a5f2c2c4fac57679dcd5f863fed6e5ec6a4e22bb0926def095f055a63fb3d529eb278328952995d9fd7e2cf692c347f9507c47a1b5783eeff2468599737f815599840553b94ee10ce722eeeeb7ba3f89c89a9b2a436dd3304042804365a6f97477cac8b48089ffdf26454b39b97cb3017403e6e4a323b9cdf4e105072ce5927a498578b69cb75a874ba1c198e1bd8847c1c0c75c2702ff961506c1ebcc992e119ae4ac2273ffff24f303f9fd33423ae8be1bb0359b088bc50775d50621e2708910889d345c7505691bc3e76dff2a949509ec1e1eb7a1296e1c3f6360a91780b3957314dadf94cf59ce7a6717252b6723c09617a071a1a6e95512dd18be63257abda10e2fd15398258ccf3d609b0824498994f57232e1022de8a640dd77e9f7e288fcfb25662559d2876126e311ceb8e95f5f3d1c21405930da0433b4741f7a48b4d2311e59b37612f15773702ec1abf41da9700cbd7ca3ebf8c95c042464ce171d8fe3b7c866f2ef98f61eb738059f58a43965b9ef9091c675d92368fc7526a8c2bcfd56ca06befec4ae1cef8e78e68e2b4464894d55bc2513856029a1d19d7467b8833cccf5bb961bfb3a2065ca9761df81e1e3928d3046b64e779bffc0a156fdd6eca2f0d8e6806944380b7828616a7f4e1e1fbb8e6dc284683a259ef65aa1c3bec33cc3d297f3e35170b41c5db43d4e83b104a7747efc120e27b2b98965733749446b33258dbe8433406e32a65b05a822ca1b412e0be53e6133a446b8a8faf2115ae7bc47e8c327bdbfad8552248d6a6d6b7aff781811d489bfe6e496938a3637f80814d90c685cfb8423118f8fe79ee23be614e2a9a550036a736f45f45ea5e875e2f9cca3ae79009f6ebe3fbae45bd3563d7c1d7fe6d79a867c39b5b5b7a6dd20e528e4bb537bb262bfa70e76193ed3b88999d1568d3041fc7ec403f4f6c5dfc479799c47f80940ade95d9f24d55422c3dcd778c41a13a3a79f5bfc2dc246bc4eb3f0016556197f858c93fe836a55b74ed5a246f7d08a6f383a1973c7db2bb083ddd8842de74076f2591d720528d32ae703cf283bf582f2a2f2354035c153696f7c06ca8483f731983373117dc228026cc7a19a779df608a0eb02ffd52d80be80b548ee7e4534a9db0c094e9465810b34b9f0d1bd3460255f679cd1d4bbb3d8ee71e63560c1106feb0526a7953f976a0c05930aaeeee5f9bac7a344b33e9778db31836cfe974a9a2f8a630829f1e015c1f4bc0a0582a803cf84eb3394391bbfab477f0405eaaf4ef28e600be21c96a7766900ac2d32ef655a7c3325ff7392ac043a17f5cb3aafc81444ed7072a53c45de628150bba702855f353fd043271c6d352b498e8c9cd13b1a51d32e34050f7a9c557690ef4c7a5686b3a9fe3715b3f2e912dc04824ee30ac3b2758412c9a7c3f30803e2706e77fbcbc9bf4e58c93c9e160655894540a41b2912e5561f9947b6b5f045428a8c38efe9b3d96f25dbef591a1653451065d32e97b1562099c3483d5602697ff6573c948a060589bd5354237523343104c550b7a623cf3725c8e54b3ffb2c09e2d187fd51b779a79d78337c55cc93b9156c070dc6b782dcbf92198c28c54d7f96860ed3df01d20679be3f60c4e66c972010f8d1dbad37faa435900610ad8ec7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
