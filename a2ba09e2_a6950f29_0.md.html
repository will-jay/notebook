<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5051306a9794a35255774814333fdb401a58e85be4e4dbf781057878be4768a66ec227b9bd1651fafd447eead5f7a8cb10dae25e379a0715524e91902cff0411a303dc2e0a09ed8f4e937c08452de2fb33f83b31419c6a44aa3523dda2700534466c065098f1505873062b5c81318bea1c5f4360b6356fde938ed72e447643ae377ad77371557aae14178bee2cae6ef9cdf87fd3c72093f89641ddb6c990f4861c2bfbaec61c1845e0de68a686c0db559e0d3793e4e5950f6ba9505bf88fb5b085a0fca9c3bc977560a1c02c2bda55399a33eda336e691b5271246e893932285d47ea35393f84f46f63b5bc43198c8eb27da8378668c271fb41b5460012e11620459eaa6719b98eabfda8a8481305559d8aeb69503a20688b3252d974d6a42bb6a7f762097edcca1234784338d30bd3b7614dfabce90e7888726a20592aa12e74baa5f464ec52b73344d2a861037f0b9cc30aa1370c207afbab99b1cc815d23ecf781a29ebddce1333ec1b8520106637f90571a424b7789685c97b45316f5cf86b50c9aa313fb8e5c80533fb492a55460cd028c03647467550b509ddc5842816cfa422e711410ba25c0fc204b04a8d5d66e5e3a64b6e3d76e64dddaa0fba74732422ed95ba6d7f68c8e9cebdb8dd493d3512ca573df15eac3c5e5c1d94f48e470a79969a08894646be55e9af9e32ca243dd3a363426ab06f0d58ed35fa176de6d49087b0cdb4bcb771436c964aee3550b526b55e95d73e5f30b072044d0b71c3eab0d5bfdd179cfd32dcff0fabddecef8026cede75dea344e27f33dd3a9f55b5f43af236bbdea8d2119b3a7b745f98e9071ca3b4e08a8042bfc2330e92f3b08204533a7a5142850774933d885fecf6188b12f90876734f459ea64b6e64dfd1c7adab4cf6e2c1fdacc5d861b5d8336a8e95e82eb1eccceb541e984bc681c51ea1cc7f5c93e2e2ec616507b07c6ea18f3e85d0630f15a9135341270756e48ffa4d8188fb9d53bf8d444b27969375755804373d44d91842aa333a4f550267dc528a485b88ff2e20c6f7c7f41cc4b4e59b2bf5d70db9a65498a66b7929fee2d18c8fc34b478c00ed3840089f9239541e48b0590cb98bd29111cb2f3c3c600fb83ff4a51a92b5b2ba5c63965dcb621900646f831ec85be5e080a24c13d6ffe7e8cdcad9c3a86fccd4ad949724225d72052a7d35fee7123d4ebfb762d35c400b5b5e3a3d37742b242357aee698df985f1e2e9b5b770fcb4883a8141291e8d9e947c92d2e4741e9f991a8954f5b1d85c5199b4f8d332512855a7540b75ca39cf4bc0192fdd1f89562df4da8c9e777281a729fbf0839152272a7148cde5e6dfc91611b2564aa65fc39535a6f9fb3152e7e94b11430bcac9661cdb0990717d0b507aa13d2fc63cbb61af20e231e97189ed70e9f385805e7b7e5b57306e7e5e51d40bef0e7f1dba3381b51f06676a28b4a43d79d8ef1f7772363ff39952856769cee9955b05ca74e7d9763ed149a2b83cda5c039dd0da521750e3289cbedcc199c9cf9c1a2f28b93fa7747c6b7aea0ac6a74eae0c6621c2dc04093a980fda1c35d52dd287c832c1e66848b0588db3103187c4d2ed6aaf8676652a1c6de397cc728852c27ebca7a750cafcbf036b73afd4c9607f699897bf06976872dbfdd4a2a21ae3e10c9b2d3995423817015eb02b24ce512feccdf755ec08c03d62a5596851a47354b4a6b9af65be39b10f27618f3501ea885c12510701567267fbe81745953eb45f0802feb9c23586c5d79bfa89e78cc1201b1d958cf2dbcf7de7c6470b049d0a61372ef6adf47bc3d5af0c3e4b700993e4514a4c3625091ac83a328005204a290efce7d54d54ed6bc26b3380813aa80ba35aa50e5552ae70eb826fc6489db9cda288746f02ded65efb631e5bd6c8a8c4e4e90145bb919ff9e52a988a9180481c5930fc5f403c6755958a2a70c1fcb5cfab3f65df8a48d863bbe1d53e3578502a3fa94d8c12d15227f1c369b81ee8592ee2b02f00b9f2606e0377ad2aaa56b80574a7aab8077729d45d13598b5bc1a2af6358804c0bce91847797e4af4678f9fb2262474a0ff82975e16dc68d65c8505bfbe1ad05c685abca1ac8baeb5791aa2fd0f4219350a38222e929f2462adfbcf5890556205a41c883baf0b1245e4b8bceab48fe0c01058dfa7c93e9fd0a50d3c20a581926f74d3b2983df65c00a02974d3f46582e048a049843b4c5b1227e886b45d25cbf5f3ba16f8ae93e2760be95936a7ced366b8ccd189a86f7769e3a3b8ca3f527844f020b6bbd1a071e12c73376243c785ec59acbbdcab3518fb25539fabdfe569f7a75cd8cca16d8beb2286ce69edd34735a96358a44fb646e97ec6a8a79ba345ad852bed44f0044ca7cf57d2037a801c29b2c0f407c4312d7f0ee6d2a98c2697b37578dd9e27ac6b247bc18662663d93fa94183c536bdbeef95cf1f20839ea0cc69b488046c72874806d24a9fc228396e77997c63c67dc12f6ae6f57eea0467ef73276fa61b002e5d0dc27555473786e219e6dee08b9cec0d841e283cec0805d2908691538d82d8b0d1bcf09f0323c4ee3a336365bf90439c8c5cdd940a7b72714702a6447158e36461a7a3df10d6f0659758d728e18cded7dd7c4727b197b4817446f3349948dc83208ea028c5cacd79bf1a80efbb4b10b93f7b69c0fcc33019a9cb25e707aa88426fef6417495168e9d04e046acb2a09ade7a8886a16521d59282ccbb819e29b839091bea20ffa523c23b5cc16a92975b1bb9d60d8970302b7f8b76b5cb3e11fe8171427f2247cf3cbf6fa64f2cd02b16d2a452aa3282a88b3151d6befdc0c1098b2c2949eccbec7eeeaa1c4ed69336298ff3691bc5ba8851d9ddbadb8a03c984aff307a9b5606a3fdf02775ee39ff06344d95c0105196e37823b29d7867a9b06df5ece9c911c63d70f0d5745be44e1a4457bea71c0e06e4053d4ac3c2ef405669f564dacea54db3591a3ff1a76f05b9b074c1df92fbff6cf0079f6e152ff2b779348f283d2210b94a1eb66d45302d5a598d29426ef68bae2a8ad57d8652b8fc4203e84e85108d18a436775967df85842853ccb9c78bbf9c5e264bfa172a62760a93e51f10afea124f83587374a0f6bfda0a32708134204a785d307dbaabd9cb4f55592ab6e8bd92cb13a6020b082362b28314d8cafa2af99ed5085accc7559c07ed1a28133de074de15d7723497e73f8e82f48883312ad35342bdea5538262c2bea19c4d32052083774afd21725febc2015c588c54a205dedaeb767d3bb90efafbb2b1face9dc4f216f70b1c153794c31c50dd7e701b10adedd1a90e1bff2d1a612cd9fe4160dff96e4ba7695080fc8dff87b3848abf92334a6a1a4aca0a2bebd69f4f0181a286b9a4fa9e7f5db29251386fb854d051ff24379c98ca1e036f46bf2e2e142d33e429483ffd5547d23de42a93c9f00cb729818a2cbb000cfe27f65c8b36868b74d28c7a2d638040f71f3b6d7fbc57851f32d2cf13e9970a3a2994999f31f420f6c520d440823c9005a0d366c989a851a85805211c065d265db7e0e20ea3c85099bcfe2987f9ef0111574d2d4b1565a53b4066112c6147bb22da99ef90ee24ee0593fce6abc810b867dcb16d23fecd73f8ae175499fb1492ccf55e69be321f6323dfff4476083c0fb6a9a9852a8f813d2a76ea4fd995e7add391ef1e317e4cd607090283ab814ddef6a7437c54b92a1054f51d286e7be83d5feeb0416c56027b74d06aadd33d45e23c625ae60a5cc4c2cfdfe98fede9351e8d3719071ac4440cf0fe2ca4e8aebe0d9ace5635c790287bbd8da3b7307ddacc339188167156f1efcca8e4876d750d8b92340e57d9d1cdd1cf635b404014016f0c992d247a88bf0d8e376a6f53424069edd1351cf10c7f0842e5a2a28b17aa17b7e21e608783b6688bd8dadf6cddc6e070a2deec45fd249a81a691aed89d1b98be2f7096ca5d83a26ef2694b862676c805d073f905515e6013c825353e4c1256b2b7c7ad489ef8e62136392749eecf3ef01d1218ad22ccee96562495262fbe29632f3404588458cb5c00989480cb3e4d3847529dc014c313cfcc512e7886fa8e42e0b5aef91999c5e6f801ba8010249c865b2c5494be6d0fc9768b4a04890ef354ef02e1c618dd58bb33fadd5018fe1bbd5d91df93f60783c75350aabe43650c21f8103ce2493c4667b9f98c6748033b913b3cb5af2bbdbb8cad7b46ece9c746968214e9579ddd702feb841f042010efcdb2f803b816748e31dd428e1192c0311f8eddffc61ad8b2f71a0430ceff55b232ed60681898b02d77f606301f2be8d4a6148e7dbf9e45ba4e19ab6f670912669bd122da67124961c1a1ebd2eca8e02e2372d2b0da29c162995ce1fb9f2215d1f3d44d102530bc87ce7bfafaa5fd5ed48373c238d6a3ae6343950627560d505602628f9d78bd6b4301a07b24a8d22651d6b3d0175e1850c0ffa936fe2b23381719fa8127a36151fcfdea18c7705572cf2c982ee3a9bf46b2293906b90770647f4fc609968429289a18123773fbd68e0ad8719a3deb59ee138fa35bcce9e3e6c2b41ca942c8dd664439dc989b49e39468f7b99eb3f6530093949d1c4efed4ed3fcc365305760c946def30dc8a47d0920b945a47207e670de6dcecc6c1701ba57b73e1fe6b41b1b7f12d5bf694fe26b659f5942abd69b4dd0c1f81d562ab5ee44cd48f2a9f16a3940d55a45c84a9a9bf2a23f9f8aa37b0cc7fbbc6ab8080d762484b7dce3e50c6d327cbf4084d1850498e917561cf95736a387b76e000b1159d445016eda5b7e633660bd9942357596f24ad204b09058e6295b7967011d754dd7ff2bafe10dd32f641994c6a7fc218db2697ee0b4403cdacbd59c0968b390e421511eca70adf91b69f8dac0b2e1808703c3141a0a005cda4cf6330e1b4ad8d8be9ff4de736b49690b7fe1ecdd81d418436a91a5040ba18bde264a8f70b11a3b049298329296e27a0020266ce3eedd92c3fca1f02a9f6edf31c63702492cce3fdb0110585fb97774e046d34be3086ea3641e1cd0cf7a101843ffbcfc8b1c20954978c695d574257b79df44e610d27d12d5341085ddecee383fc9cadff0d5b7fbd4e0c39f0f4b572246b291c5bd65ceefbe4a1c1b1fa2c48d8f3b45506d4a3aa1065f3716181b29fb345a3e25ceb95bc5bd730f7cf1f76d77b81ec8e13b7540b47342cfeee51d1b5f8eeb2998873ef6c91fd5024bc414d8672bd03266943e85d1d154322c2866bfe8df4233d67b6346175a5cf80f886017beb72776564f60aa9713e502790c3e4994a5dbd9ee097f1231c922262d4e18e6b0ebf20ce57ab5bc511da9298961fb7e5ee6409034b0078e097024663f2e998ae051ba2e63c3a06643b429c1cffeb15c37a6c53247249dccf90501107f788f5162ac2195294d5c466b7a56f23eecd0112a03e8a058667de1c8055a0b489947f7b5fd1201fb52e77f228647a639f045407b1e1a62f620c6f74c55bcc2f3b99991db712eb0a7d31458042c4a6822cfd313d4fafb35baf8add65ec561da75f01073a5626a99a2326c8b2d9d26e5a4e679c0cc2a3f69060adf60e06cf6510bda6940e0ca30517ae05f9521f4f21fd17c6852c2b2d1216d31b3a57cc0a38533ad9837b3f16049924f907d57fa9ca5e3ae4f3428bc9a426d614dc4e1fd68167f52290669c36589ff0d9ed0579b725d854a0aba2ba6124e6c8cb77ca189ef3cd033daaad11c7ce4cbf7ef175af7e8cb1458a436b0d4d8a77957742de6af36007dbc26bcbac59413fb26399256bf17e4a47ba49b586a646c6ffee99372e9bcca865a031b9f15a321af6fe5901ec5b4d538f12507f4e78bffb19b6d99a603af307dc42212976ebc0c695f92b0dc51e8b7041fcaa3d4bc03f9d6d9e96ee04b79c5f64ba6e3f163db620fb93087ecae3d52a2102b781c1015db748cb6b57d229d04963e6ab7e3fddf9baf06a406b09c7c8f904b313604d7ea2966009179bd3fd12da1125330ba1cc454b384971994a8ce748552e13bf6a524b7940aca2597eea31685d144f74b0589ba0aac727c1f2e11adf06295efd60909c33fb842004e3fc76f29e3880120dd6e4d6a79641211d28a7a692c11ea5e51cf122b2293d91d3989b85aaa3702fdb0d8d0b4d457b74238f05d91d123ade922293b917cefd886a3aa27eab9492e0a5b9317aa5f6a85acb164a4ce1ba2e2a1975f3376cbf89925e2d42ba4c455740a4693b7718c055b59412ebd77fc27050ed70782d8ba9eb2590a1f996874a3f7839af169f707214053494833a4eee6d781e2dc013b77805eb607bb9e34a61fd6ae09abd8ea5de979c76d546deb8e6b0021f11db4a09a4af18294090c7222c2d4a2e1401b1b3a987993a4aa392cc34fb806384ef3269564d7341db12bfda0907cd02111162ff547584cda13cd6bc46767582ba1761d84892da41095f90be387b4376688238c65412f09613366e3db456446fb25c61c375159004a114edeb27c63fa3b0da2caea293dcacf7d2d9ea376757d31d08b893ac6201b5294807af03bd65135dfb586bfbfa8750813812a43c9813bc6634b22837323fea12a82c81ab90409f0564082f286a4c158b69c684b01ec1845142da2ee7022f9315e3699073349805f45a6a4e2eb9f3e493a0cb0a92dc42381dce4039c412d965bb3ceb7cfebdf775a4ac38aeaa83f9cedc92134471fb1e9fe934acdd8437d956153e22ea48fcd2701e9e15bee81353647fc6fecedfe13b558205d42651352a3b6071cd210d0bf85662874a37cb1ae40fcce89086a9838e29586595c98c8396678662ea0b1a07b95f2ffe68c30fdc806252e2f260c1a86724297b5a7936880b7cd6aa4f575731159a32d1296a18aeccd4a614f4a3f330c92f1ffa2b7557c81c699a53366fd6c667ce1115e5db7cbf6cbb162b92b6de2c0d050a606b90d77d76dd2e4291cacef2ad9c9d1ec91993b94527b2ff56e5420268203261c34232ae251bb10b8cc0d09552b1b09f13095874de27c74169fc84600826c5d7ea58114eb66d26139af87ce2115fdfa98705872ce4476e9a6791b44235425f07a53b26c4966b8e9d04bbafa258f1e16a36c7396c7cbd965064659f0826b9847b2d3e3c941055a414e672e937e0c8e7f2c8e93cf0d057cebf131048ef6175f9154e1c044ead480d233d3282a864a3ceae5791323bed3f063d4bd4409bbf7755d3c402fd29b1620acbd6e667b9c8812e3798146832c4a20caf3b96df6afb5f4c3b1a2bbbc8b6312660faafcbe0b1dd9466274985b6015fc9f76155b1e3a30c08e4dc099e7264e330f15c736ee127ffa8a700e37731d739b84d9b118ba56bbbef5bcaa5b0add7bd026d8d7acbacb40084a4f9d3c62dea261df32a7cc3f73292cb5df00334f08ede6e090a7232b80632b4aa5bbddb6eccb72279808969691f6d1088a46421bbde3f6c86d6ea311bffd55b1b8f6686f6b21193f3771cdb60529e09f06b91a5762b4972837cfb1fc941c5cb5af8c98bba69cd89e956bea039debbf6a96e8a340e654aec5973b91e651449a92882aa3f256f9d0e2edf6ec89791805647376d9cbe11c7ab5569e9d101ad47ff51d8eb7d9218ea0f7a563344b681e75e645c0c45159b1ee3f92b4b31412ac55bc28e162500b63ae39707d5a63dbaf186017b4af2b8bb3512914d2e7a686811f03a4f7e7df8f59d72ab61d162c1fff375a8a3546250e9be7061d08b767f5f12b61c7e8333f7af809cab16690919e99aef43201c987eff9e85f197529c900bef47cef1b584221b04f7a63cf3f391280103e12f49fa66b322477b51da3122940d705115d09e9f7517868ea0c64e15bf5c7dcc1a7d4045efe23b692a3d221e5e61db08a835aae1d4975f979fa8f21e47769cb07301400bb13cace9150fe296f31f90e29616c88f8ab6b87835dab1d01e0b1a156cf1e4a32297448c70136fb7842249440eda01315351ead663fb785747177ba511a292c630809f9203fb6678a410584446192a7e9b4abc497826254b062d7bd8b6658db124b4fc5731b735bd3711c2764e427bdb2e75326f71e42efcbe3861ece51cbb2b15c5263d5add5c55fb98c221371c74cbd00cd246f2f97a82affd4dcc1f1c07db15369770101f13b8728a8c5488da974350d4f5956e4e6e516b3eb265160df35c0e8cb3b34e533696fae6af92f85ca5d8e7b95136356d169fb3aa89584ae9378fde4a97231c390174002dcd36d7da38a2019afc29e5236041b844ce400e523f04787df7053d176387ec58adae6167ce13265bbd8d5adc71fba209f9631dbecb286960c1becd8eb4f3e1dfdea38622da2641907a9325e4501cbd4e97dd0563520fb0653fd3d3e82358f6512e4a93a4a781688bdff75a592a6c89ca38481f693cd42b53e41c84db534ba47bbbee7a86e8baaac68820d80480b064dc70fed3e020a52b4db20ba46d1e317a7189764bc5d68b905a55ea4ecc1dbbd48eba1656e044e6c95f3ce6acfa792fd9cc83247e349855ea4e213f38295e3be77dd82d325b9bbb45138055b94c16ef8addf64538f55f80c3c13729e6f54ca9470e0512fa76045ac3e4fddf64991be60fc4e35b6695595861efe8fd8e4a3bdcfb71b184363e402cb86b49af2153f8f3c307ecc1184eb3bb27f392655b6a18fe91cbd31e04de9449750a1d87d53524d94c9e4b7da5334251b77cc54141e3c00a3cc187f3563109cbaab61ef9819c98df4274bc7414d72bbf7463b84516a57545dfa7cc1bb99580fa96a79aad51af67b90d40b00430e7a4f4c2ab0878f236272103fa4db08b186f6aa5ad38df5a67cb930f73d2f8309fec25ae851c4e82f67df217268fd033a7b4c4a813721e53dff4fde773c04d7d80852711bf37a131506b7b54713041a12d3695fcc47adb4b8cc5bcfb8bd8c232b0cdc172467ef84ca0392bd136364fb39b76bc683a3be90bec046caf6ac397b08f28f9e944d703ce72889db9d6948f186d42c43ca0aa23c5ed648955e42886a79c2c0c624b52ed17291caa1774c3b09da95a9df734a9df8811bf0aea4a028ed47850cd2921a45d37dd4d1f4fb75aeecdcb6166674002d7b84dd3cedc370a2f4e32e3ac0b2ebe2850dbb28d58e0609cb1c20de01b098281a90e0e683a9d51e01e9d8773ec26df5921e9e7e070d0a1e10d12535605a26c98e5c74a9ed928e760004db2f7f505d4e4f1f0703d529c49d899543ed845e43f541ccdf1e60c94a2eb26f79a8e49a0b5c74455a0cced5539b995b232a2e129b3ba8d80dd1123d848a948e9b33ac5a970ed4fc6f7401c9642ca2982fcb6d3728eb5728a83210e5744bbe91eded8c5d6046e95ce9396d906c426f7bf5635c8a460de765dc0ab07bc3329f9e929bab807897d1c563823cd2bdc3f4ebea41b212473056632774e0b9c3811c1d343f68a16e90a7f9b868f44c8e07ddbd5b6904f0cf5487ce65de70503b6e28aa744a115303632edf2c6b14b8f73ec1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
