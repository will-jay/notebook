<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7047475e7d365b405dc01a6e006bf01a666bb6345574e49bfd6467d33d3d52e8707f3cbac7d295a958c9b63001735dd50ecae220d04cfe5b082fc1ebf536d76f1aa31b6652234a664a9668b5827291091cc5eee74883cf060b560865e29b60f5ad1e37a446a8cd206eda842d2e8fa017e83f5fe56218b770edcaf38de3e678bd26b23aafa5cd423857307df003be79fdc2d2c3e6e67173d7e7fca89917ef040fc9a2c116f22d0844ae867ccdfcfba592c0ae2e7a751a570ab365eeb5e2af0b37624ee7329b8427b4c1debb51e8682de654a4319f90a3f3f6374df0a39533575a78284b8394c4e4dfda2696828335f5011bdc23e699f247c470709ed6400cb25b45505060ff4470915e31958f9e1feef93b48ca8a16108c7b4ff553eaad6d40862603a4ee746c21795556129baeebc6a7a0d2523231e47411eb1a406036a2fc44b63dc4f2906ebdc8237a0a285437bbb79bc9d9c6b4d6b54e659352f478550ce8358108d30516ecd790dde8f5e5298b9193b61727dc9592eeb117f520d7b9922d72df6674c195e1af6e7ae05d9497291bdcb00dbe8d8cceeb4c9b7c4aa54e0cb65bec4694f839f421b18244cf3facd833fb35c5bf1b87cc19376d74d1b67aa0c023c09215a6523e674ea56227ce2e2904b1a1bd2a23dff62c4472ecb615b5b5d84f1a8cb04fbfe3d41f3f6a97032e17ec2c082cf029085783bf182713651d451e23e15cb246f4556ec5089d29aa291d091e926b7d4b2c8159a59b22fbaff30fc84d38c2f27c31f29482e5d3cf4bd8b02f8f2e0f935918727fd17a5e93c3d788b9b8a7d625b3182d150a62524472af0d066735ec587b1b56bb64528d3802b474de156fe8e3f333d71cef92cfb1f2fb1519042f4b1a456875764d70526a4962e13c198d70b07cbacf5d8e877ca09c9858709a5c5a7caa1a338eda1ebc46ea61c1f771699028165fdf5d9c5c01729506af9b926d0737c384f62925e8273c04b31e5ac773b3e6a3dfdc2af587e52563c441afe80a51de7ac5a1daa5eb2bbefba061b39b7a33da028687861927396ff47e01f25b583b4ce115df72bc7582cb2ac81da55c9407d24567a17a946767ccfabf5e75edb7af5a96ec68eb423de163b2a68ee04556b65342d33307c833c187fa0ca64b83e442a009016cc620790d991953cceec2f14150e0d6e78a06aa3168b666008c11acf446ac33aedcc63749e5387bffad23466c9f389295df7d4f65070630c4c718c135b22f220acacae5b6fdd995c711ca0ebde5f84ed6cce466366b99a518b90b76ee805466c278f0b336df2ccfae299e9abbe5e87f95229cd091d3dada9935031a92d31ffafda1d1075392348083dfa3df1b6478521989f21d40494e3b956c76d0688bd99959020591e943fc1a22efb7b8a4c38ee13d46d4a545d933ecf9d9217b16d71bfbbd57080a091bc8fe37de4b8c53cf084eab3c99326d92b7c06785434001f0818784e3ad483e8d2a408fa3a2d1439b7e1c26f2858370f21528f88d05b24bf538d68e7c1eab3b169893403b7b36f5f8ef4327660a1634025dcb3092029288a8dc774cccebaf018e5f362679e3cec5a56556b7995233f4f068532dff5c67d041fee12ab57296ac629488f5dd4aef66932e8a4f99a945bf52247e12e55142e5ee7c4b7b24ecb84181d3278ec30058c7d72cc0428fca36df935f450150cdfabf2fb1af929471427145a0620ba95368189a6e7717afb30184147f481d5ddf2dad26490ff952d0a31c1722176023e714b756764986fdf8399144bc61d3267c20588fac1f6ee6bdeac35e7cbcb67887fbe060d962095fddfb88fbda7f7b67bd29d04a5fb7bce1611694000adf8e708cef8120cb4c4d83013b24a006ea739c8b0be786a6856a502f8d45e77f3488e9d9f56d0c7c8c09279b4e3edff12f81b58e3aa1fd976833ac11d793b4fd3e5dfad3621a321f06f8e66001a615b2cf3bd4b826a1ba6e093b5690ed6f5bd1462a44bac824e5cfcefb3436da6ba1192d4fae8a8a0bfb2ab4e00c6b71f7e84ca2a361c32c678eea17ad8d6b5bad24a11c7e7221533fa497543c2f48e160fbb95607d1166cbba7877114a0f7ca1e5362a239a81839b1c5eac73a624e62ea0d0d83f9ccb35de0d4ef52c908239a8557847ae674fe2c1ac77f93c85aca8f655d2cb20b1fec0596e2ec030321c97ecafee2eb43859d7f8b57b7b4140c5d24d1303ab5dff13165e0f170cc38891065138efcb64e2ffe2ac06ef7ac64f0d19b9c846ee41b0fbf30f0d2825199bfec43fa3f7e07452ed71614ebda82c9e320c5f1738c183546b7e8ca1f8666fa7ab9f637be9301c580d34255743b2efebe3c06c3009a1e6e45aa84d04550eb2910e3b50c66131e9130ba5c450d742a24a5384852239c3179f187cf17507d293dc6cda7da179f903e0774ca5d9a600a9ca4bc1de5d7aa68f5fb9f9755adf3498520d3418314d0af55c26752247897839f6cc48ce18f35a4c8240a738f324d49a9301f8e680bd8a5af072a34a9ad013aefa6241e424f74de31f769a4af5370fa4aa3b4d14d55e36a15f4ad9906d98297b29d0bf9e9dda8052ee6a4f1fb6527d32b734b3e565118d5bd1d417633793c79aec2f54bec10088712edf8eceaff77ddaac49fde106efaa300c7c6e49a140f8ef97d7c0aa1124c249d45d8d3cadba3905bec5591b60b828df9d924f0bfbd5fc3af4a55af2d436b560859532c472795e3675a218585c88f767234551eba23e6ec18d2d15540f497690d9b7a8988821b1af761517eb118dd232c45b2cea13d78b728255056f85716ed57ea1b654e1a5ac6a2bb49ea6b36149539cbd3bb60f6f68714468a60777a7fd42fedf2c188813db74e9b0fd0742c085c0189cddeb634222039ed82b8f383060eb2e32767b2b723e134ce9ad29a04ef730fe38a1d0f2c71c80c45ea8fb2f8d69499e54d057bb275022b06b1831ece55d535f9f8438eb642f308b08a615d14b7cc9b108bf995e04d5d85fc8f52b3d17ee6f0b2617a5eab4017cfee82a5d99ce6d00a3cf4358bba13cc868e97dadd64767436afe2d7bc99c022e6d729f021a1dbf1e0c71bdc1338a1f92fec3dc9bd92e5cfb6de95b4cd47801580bec53bbbf14082fb928da4db5977a062741df59ac41dea3f6639eba39e16cbc099c91fd87aa48585a1ce306b13601d885da1474455d28ef495105d22ec955ea2f4ba404b70801a890c55905ab70b8da72d0f9a15f378df5738a17adc2b4da93645a2a3682613a5483a6a022092777eca2748695b07afeb75a5a03e063a794a73c1d21f2798a05a9e9f89515a29f3150d5188640a5516671a1403f346524e4f56037b4dd75676514e0f4b04413b9c450e7d7d186c14977fa9a7b79a8e80ef384955830023993bd2dbeff10617184453eed53fadf78447fdb9b5e05edb3f214908c4643fd2442c1a4dfa05d337793de1deafffd97ca2eff0ae9824066a33f567be625028086e92b7b0d526a819736e37da32feb00a10b808736566fb06e7daa6cd61df9f676e5836aabc8b5199ba753d13151fcf464aef89cf3095a8f4f293841fa68d3ddc94774589db815ed22fa33747091aa2445de7bc00da23cd2dc8eb4c952cd47820a69098a6bd4ba3568fbcdb267af4d9153895c34d3e5889281a140ebe05ef331f4e34a48a3bd17433a63ff192d8438e138bd5f5170b383d941cd328a3a4a7ccbcb3d21c3708b2c11717388b13843f03ae65a0e7c5cfaefbec783926703ca59cdb2778726eb6cb730f60854eac8fd271f2f120eebc2f3abf0870fe7242d6b9e24d6886715dc99c57e365d976a1464e6ad259d46eae4770015aee3823f4c18efbf1539a28c8a8e79d290e2e72ffab77fb33bc5928f9f1138e54a6a373ffb8a376ad25c59601a50f643be8ce287a4d656db26824b1bacfbad78b8d2200b398b2ebee8f5566c9a6a7f9b93ad15fd786ddd1aff11b5b266e4ae3e8299a995797cfecfea7d55cff553c8d8c3e332ead74d2075557cb9bdfc8089431390b00e14d55e825807ed4533ced284c20f12e295811fc149296ec6de8513af1d9b6a24868f171c9f4ca4a5123ad1be203596bcb353779894007fee760518a11bb3b671f4a69e92e7277213b656e8ff898dfb9c7796ffbf57b151e1c72ead00a70c99409fa8f69bbb47832f1871714feb6ba064928ef2a67f433ffed653c15afcdd4a1574dd526cfec369aa3c468d1f8ae06ebea3e441153835e57b4390a8c59c964ec9c41f0c5d85038062049ff0b80e92bee04fa7bbdd4d39afacfd94b50c893c04459135be187d8b04108f1b464212853c8e4ccd038f9fc49ce95021b165672e963e8211590e42c436f16fd91dc1fa11793307b01173f7b5733821e67a2dac9fcd581c5839a2e08adee69ac2149eb18a4076876200f53671c3a097d97886cc1108fbedd5a3784c2c436a1a514a40cc8998a679bd2d2a0b969db3b3fc07118038462fd9cd60f39536520c5251cfb6f7aa3e2a0c7aa477bec0b1a2a193e9e2db88cdd370328f87ee0fe66bd59b808a375fb58d7ded55499a874b4a0c33ad7dffdf8a3d9913c0c251ebf026e4abe008c83e22c5939a9280c8cc53c7b0617cad194f32ed5fd518b87acaea4dbcd372f06b488bc12d4e301f30e41519f7e173f0a941ec6daad5963715142cf447be0f7252e75817a3d712dd50c715ba99d995afba2fea5b35b5b9be0b14e05d63f4574982bf0c53f71af54b6c23867060f48c7c1870873d5a5f4b38e9ce0faa2e4e3035a99ea3edd5b196fa5000221a0f20918e69364321d9a9575717276fec51c8e8a1dad4fa8054dc6c3de6040377623591afc79790376cfea3efca8a295364d876547e46b951f71cb1471b2fc3bdd4cb0a26615a92234762af343e3230dd98fe58f8dab8c4fb640d15fb19207d4bdc7411bb876bff846d6734e6f5072ee256d283cf0dc3fe7c229e8ab4c01bc417e54494d437eec0292dd14e97f4f81ce1faa33a81c3382e0ee815515f5de2379584af34d91198e37ab3f372ed167bae0d57413d17b4cc643b1cf0bbde29acc3682a109fa6a4a0837460d2a095ce42bbc3af4f25e57dc66dc95d025e8f49f00b174c16ab13e1685419f41b5df50a4fe906ae1cf1976615cca0789567dc6a68ee412e3cb018e544056400a671e704abe381ec77944d8dcd8bfa699d9d1678d1c93fd70b1de0045abdc12e837235c19606aee6be8ccd00544685e4cf2888267a7fd5b7f4d4b94d79580f4cab162eeb886854649de0702efb608c458ddf39de3e6c793e8dd3314b95c41d2d42f0a1e6c6dbfd5ee26e337d530f9a469151367289c6ed515e7a22b6bad38881564505f6dc9c2dfd03dd6042c7fee758d972b23e838a4bc822a65f60305715e8f78c0ee7a1c4cbde99107f9c025e149f6c8102f62bc7bbfa33c35a199d754baeaf41b17aa761c35963125a3ab86c651b504b8d1a6ed2c12f8733c689a31298a0baca994e60890dd2d2e7599a9cb3a1fd60e7d5fc0a6995ee55b868fda92cb88eb9e85525227ae809210495e1ffeca87c74613862bbdf47e14ee9c21606fed69726dfd4bd98ba6cd230cebabc10f52b156cf1ccd7c18fc3161b6f1abf0eed5ca36d7ef82881cd806a2d0e0c0aae846c809f400571be67b698739e4bea634c2a472f5772c23b7e93f8282792bfc8ac8e40204356e2af292ea5076717946fcd7280003342d2a2617c6560a822db115b896855303a97248719e0478231fb0c0ec8d04f36450c7114abd86aa101c2e5ba6773f789223db9d3c99ad91d0a1b30c900e81caeff8bc415bab2412273ce596a7ea6e8e5a3d6eea7f812c7abf61fb85b1e36c81069e0b5f04ec45488779f43a9959945e36efd6d0ce565f8cdb40ed2039739913e1d365987c0778e85b48c8d3c7119327299266e9cbf494cb30f1e9812fe5e9843f832a58e89626c4943d78a17c3ff9ddda5136f89d858543146eb9b8e5d32f4cd51afb4376f5e6ced5a823def283a559309f2f76bc6a93e497300bb0c5d04ce4aaf912e780eed5cf8779aa5042c07b70bd454cc2c43f71a35a8120f81a5d470e21984836aa6bfd386b4e6a70b1ba03957b4f60fb545af46d50f3706a0f6e59b7302c4e669ae2aa211db080371ab4febed2a9ebd13ad87d6daebd015057c0dfd66ca3174537cfc31b968317ae42208e6730f320e3a7ec0ef1c5d1291d1bea2f3fbe3298c23f70bdb5d73d60a5c791b14b94a5a4d75807861ca5137a41b4fdd69ece1f48ef36554fc9d3b86de69bb7eb3e133a26f7298b89657287556df9246832ae548c40373ebda745be61efd0a844e4129f2909d37081c116c2dbd0c2d9212c27f196258fa321c6d5da9db34a8cf7e459222639a192b671b5d500a1f01d69d21a1421a2caf6fa8db604c9a80641ee91f226afdc01ecb5fd8f784d69477da240c25e27930b63619e268e44af489e3a73e418239ab2e75d825a60900fbf08846ca84a2855d9905b27059de1d3119d97a90ea1cb5cc5fe98b22c393f9fa9875e2082b53739295d31cc78090a19bbaebdd4c9f68968e9c69d20461d3de775da6443d12f171d173e17c66502a55ba6d382fc0fdf839928e6f7ada78e08a4862354c8f3a5ae1c6dee33c89bb1e3790c4765ed4cf562f2b6cb30f8457eed98c814675f989f122626a7935e26261431339d25b34685cd6e31c607c57ea95b5883946575d24a1bbe46f42985feb3928e8d8156ca8275313ed14cddc5c4d2c7dfe5bfabd72c4eb917b761db40a6fe134e1ae26c3bbb3ce0bfa5c1df3e5bf62e02b6937e6905500128544dc570accf6a1af049a5b2b97e63fba1bf829dfbc0f285d0898d35170545007070f409afb120603dea6994475c5c86013e06fb3c51a4c4965b0ccfdee2be44e5c12e1d9904b3288e47afb25ea7be84b4b2d22cfbbca63a9a6142e1a7e2aba93fb3c666442246d47032605c8c84a5a098cffc0bf5d804c0ebdbe39fa8a3cd1bb8b0a31566324e14f50f68b5738814535308baa1cbe59e5656c5ed3f944646b933d7f5738e4ec7e7162a5fdc4e938e5ba1af0f2ff24ff742a21c8d5669b9372ab774ba71acbad9fd44d410590c50a86b378eca95309a1574977c1078496ae4140fd58c97e43c9d28c006f83529c889bad6c2cb07a31ebaa89a78d9a63ce953cdee5d5f3ccd6d565a1fccfc5b011425fa304cb00dc52586950447da3e8b69e628ef588601494794a019c55209b1f14cd3f9a4afd16dfa14e4c867530e2aa30ee91b7fee0bfba45ca9648ad69caa5e436e162ead119d84ee205f81b49f35bdee10fa743009b0d5ad893afae24fc0f7084fbaab9ed74a93b030aa04ba90c8bcb7726857a75780b6db7b3665f0ee8a82ab32d59c522988c0b7fb920d3d4feea01c1417815ab31b4254838a2e142759fac2adcfb06327419312882008bd1cbbffa324333be1fcc031a3c7f9c8be980979625fa0d7b95e1fe2209228f23ef9a1b2b2b79649bd539778f7158391ea1d09bbd3b20d5651f011f1e072fe922e0f1da2ae3b81dcb114ee8aea2814345c08a950b4be54767d211295521ba0103dacb65d0cd56eac575e3d1fa308a0b7067346e85135a789020cbd95c45536bcca0aa2bd0680ea510d59bea3fc23255b24587a42e1475625ec4da4412b160922d51b48f28b7866adf0cb693b6d2d85b467173d60a5d925a3cceedf14594f266bc19d5449001176929e291a93a92d8f7f8d2bdee9fd3fe745bab6a04e5238a00ff15b263a910e183af0cc7d781ed2e7a5f2c1f766468db3d15e1c6faaa29a02dbc13afe58279da5f09b98ae78481688e6ed30bc008161d221f3e7762144dfdf34b28f9e201cf276e3fdcb6f727b1808343b76afb4bf5608d0311c77399b11305e823a19b70abe8c300e3cd91cd489579cea87f6bbb953fc2d02807a9e30f7fc676e454ecf94f90584c3e55bfce0abb5daf1ce73e10fde99b2ca4f969adb10b80ddca4cf11e0cf76fd92c0176b730ec634723edd9d68d6aba6253ef0e4882cddac2bd7242f10694e3df5c011508fd177e12c7d901621731b0b25ebb51c4021a4cfc0b8eedd4c0c139f5646fe3ffe6ad3c65339ac14d233f6e93561440c9cef89c1302cbfabed8b94f69d5268bef781070d0e330ef24e62ce009b5ca96d49247f9e1b313826510463f66d4ae7a000591aa48121e364859d5bca64e27127a446ad18f035d3e173a4bbc40151f01a49f5faa39a8537b2afc9316f864af99bb07772be2d4091f31b92b6d090619a377e024a5480251f8d218e65d15110b24f0b2165bfa0562bc0cfaf00299f19404f11af7997a12d0900b2a6b5e47bfabebf9822344e853c6e70f5aef6ff3e7c48a2ddb17f23cfde5fd95c6e66530b6e7cc5da26e2220446e9a17a93576459277775da26c386499050afd6c7e753f0b7d1d6e73e7f42fcbb97d340154493b683dda16b9f6b2b7b0f3cb850db7b96d405a165bdc48dd5450740e095abef85adc2be26f6e06cd9dca5d602c8f047cff677f104e75e1d0c5822c489b53900b518a405590baa0f514be240794e9e53d169b84b91e53d70415d2bbd37c516a99663b14c3396773f3a850e906e72d2749e4314aa58d4fcbe9e90a20796c6453a17c2e8ea1f6661bd31837e116a0f9f38358b4d5052c3b9a6d028f2d239c7a4e80207fc97ebee82fa4d86873f36a5df9c1bbb8abf86e7a30a4e27409d24d6453dc44284740abd056d0f3eb1f6fe8f1032083621aa4fd11ef9abd9f51a34b6f067361dd5d9873e036e192b002a9c1b58783b3012bdfbb0093cb469eb03298a3f1387f0e75ae385f5c2a60347f38fc8b7b2c27682455e89bd84a154193b8458575ff6c0b8182401acb217ac9045b66120d3993fb8f64615bfc6b7e65b16dc4ea4787b412b9f1d63a6380e22752782902e3e2bbe65a298ee828daad43e42d2a87c33b550720378db73eb95e8e86678423f3e504c727b81a726566132133b8860965bbd97372f29d5c640286d1aabd72812197b74cc7251eb5e7bc20fa71d8df95fb6d47b1e743b003d5a7a329dc5a82c0e1ba5e0769ec7f5bede738fb8b53ec5d9c32a9b2133ee4a145839246d38dd6ca62cfd001a39e1397a60f6581cbc4681f8b479a35b6462c0ee985dab3eef8bd8643cb9feee0b3547fc8979b148ca75b5a1900b2f05bcc6ac43b29fd8b2957ec9a7532f075b6ae4fcebda1a69055982f3532485cbae37ab266ecd0080e4d324ad97188f7d924d363acec50e890bcf2914cb2429c3c7167f95a46f08b8d079de9535f101d01af4c4f549fde15ccb6df0b0a0f3cbf8276d784ecc2b28a38c853d9db8af74ab2178987bdb9c66f9a97a6764122b3a9a25ac5e3457864e4157a682b7ab3fe44e2190bf5af0be669c5003d5382cbaf53fc8fe567d17b40b66eb97423af51b2f885ec667dc08bb46be07fb081b7f5db3237f22e2b98ea88094f3bea533350a2a5f4fee5ab3d85377639330d2dee7789290ecf3df89f455eb4564fcca3f9b786d57","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
