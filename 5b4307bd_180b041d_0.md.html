<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"827b3be9fd5e71e160b1e461f6d2a50bbdccfb2fb76bd9def8f3889d00387fb031237f67b69a7b7ee89acc46b0ba748980e05f983fdba4128457b6c343106a0213ad30b4e2f82c48590699501805515ba254ea0f4dfbea92e401045038c253f584aa0c4801d0db350f83c5eddbe905ed11904d9b722d9a13d42d84e5e8446565dbe791e309e21563cc0d7566d88937b336d2e3f60be22429797bbe5b0c93e51241eeb0f73e5722f871ef9957a800468d9681f2c9a7c13aeea58e89d6e1199db55602360715666bf482e7e63709e4a9c6e2ee205e19ee53bcb4e7ccc6d7e7f28d3ea9acd12ac63b72bb80ed6cba966f7df48015d1a32af47ead5920e0679da364c6c5582e30ae19e383d822fd5f23bed54ebda57c3323636fccc047c060714f918bb7d7f9a88d2cbb3740fbd58acc01ec0d306b4b854877f5226af39994758b9bb922f6af6606ff20c89a86bc77c9c78b11a27cbfce9f51bafeb31051431317ba2d3f09aa357be727d4a313104dd9ab7e357094cfd8be3c253d3213371d3d2616d1b2b392fe7e1c79fa593a6489103fefbfd6b99806bed699431d82376c7341129e65ba0f1cbb1bd96c27de1fb2083b672f98d5d717b3106f4bf689199954d1d6efa2f298927835f7afb264d6786df0ec1e93a60a2c414b9ec116500200dc456db6ea42a7cddc80feeefb9b606911fa2a7cca972bf9ad61f2bb49a73cf8c4a5835326f7590882507a0c548189c08dfc83c9acc696710d3b4542119a84b74ff85627cd011390091670c51b44048cc79d612ac9897cee1cb9a0ee6277c9d36a997aa8517f2765b61b1bec4388d6304ed7c37ccc3a9b8bc007a3eed6e26d1232e6e4f6b869c61301b704858051fc032e6a9e1d2e88e1c81b31a72b573f20ba8abc7a6f16408f78607e28104b96a1464732776352264d1b4c5b41d30bfdc858ee85ab7a0b1276c37d8db1d6b36ea53bc49e9b24b8d6d7dfe0fe715cbc35416c9b57a3a5344c7bd8f493c758456778f79b07e5d034928f5ff0a9dfba61d59081eb35aaee9a7fa94a7547a49c61c3c6a84942a7f50730431aaca88cf8a006debd863ad944034319ec8c7b32eab079962b541075d548265a6bb7772b6e5d2a3906601ef35c47d94948cffb3472a341ef3e6c0bb9840b3f227e923fc34f08ccb96df3fbcf2a7ab6a6195ea60a25406c268d4c3f4d5a79abbfe601c3392598a6875f8e0cd7a4cb4b9e08a249ded3e9de717f5408334c6e7ec7a88d98a002992624597528230c070786ccabd7d4b56cfa193435c694cac8bdf84103d0d6f86073a5ddebc94fbd5d9d3b933a8f39baeed9484c0f36ed84f046d519f495d53539d7dff73397796265677192cf7f1da1f9011db7dbed5194ca42fb6899afc24005d879d0f322dfbdfcf9115f05efee6a0ac167ce9e090943faaa493ea5aac09d128f068b50d36274436ae3b27365d4bb45a52a3df9a9746695783b79d065e8134cedf98054a12885547cc37afd0b90b3c51e7535bf9b8eeae07e4c7391f7ea23b0673a952abadfbd39a0f4d3bfc18367293c5d05a20f9db08765bc880b54f505365e423f499d91020fd915d86d3a802357fee0eff1f8060a31f6c36ee607e745de02170c9c1b4121be46d6b663420919d5f4d7771b058be0437feabacc67682966682d3a8a2ef3369631f8ef061c578b8f1bcd03445a973609ccace0971daf1571502bfaa0f66120fca539bd4063555d0ed038193170b232db36ae59abfba31415e4ecbd78815e38246ea9e31b67980435281ecb785eae798499cc27644b5cc41d759e798ea024557284aca5541c83cb7e88311dbabf5759c1500d7cddaa323d914058b5afb1697d6ebdafd5b3c117d9eb8961e9ce1ec9e37af4411c1eb117a2fc42292ac0e0a8f7f66e92bc258c0279111c57d27618d47f1aef48b6e95e0f2c7c04633e5807cc49147812e0580266fe83ff1a24ab5f3ad456c7721a10e7b109de65778a80c8c45c411513a64cdb23c7ac5dd465e4eb61899b6524d605775d75f4c7aa6ac81c3c1c756a74c1980dbf0b24d9c38755e09c466a2732a97aa828763c37d3c54a543fa9a341271714c404e2e3281ca251a1c0eb73cddd2578fec3d678a5f5a4b93b2b18da65b0e014f2e801d1f608dd6cbc5db57896b5059952648c28acad4417bf8d92d0d33d08ac1c7c17813b405d6c24dc21b3134782986f90202af5df357b74f4b95bbedf3e28153ef84ff5c87a8f35e4cc410eb71d0f7b635763a760749eb07f04c39ef8206ffdd752fef2888dd25e7fdc8a6bc958796636095d95711e638321422c00100c9857113e1e31a73977550c8168d21e3aa8a14e6914063e8071bc0f38514bd8f2a625ed2f093b57b70a8036048979dd82d8de43e5e700e651dcd85d555d932445036ae4f4c32ee468b69e2360962b02fcf3c831c1d6524c20174bb98ad5f69aa23f8cd899e27973643509357d6cd9c137bf331f3b9e5e4645e065efea5e995c6a4dfc13aeda0891f32ac3fb3413c1ca439a5761e3d69728b8bc03553448dabea7504d13d86fca43b3a28c905643b216e82bbb34bf27e6ed09ecbf2e435bc5bd236172d0b3b2488103f3fa388c14a8c9a0816b5b37c71874853e0ea5e13372e1cc954834c6eaf0b8329a254001bc64dda4fa1816f38c7b208eb12a35cf0ea56752ab3503f258f4da084fa627a03048279b8765827e22c1d2f0914af79c620bffcaf7d6487d40fe8b02df6253161e6a1ea837fb40038187fc316b7bcd34a0415ea0c81b7307048925bf4acea09349950f6c28a2b5655a43c0953fdfd2d5bca08d03888f156596a24adabbcbe01222266a51e3a3bcb64d433fbdc849e660292e5a87d614b47517941ad581a6fe86e9f741be2e54a8e98d15619307a3e99c368d2033a382469b056c1ea116381910058ee807cd29b199076727bf7abc5b90d7f69d9f46bd6a4d6b4be6da69c2dd0a7b89b78bc218da3087830dc576bb8d66730642323194e0121814e7bc14f90ec9215fdfbf92991e103b3d822d340c131775dd6e8ee6173d8b7509a123ca592b4fa52b869b00fdf33fce0308aa0854e1ba8d2ea4899a8d1422cc02fe1ffe72d8289c07e3a121a51e0a0117b527f8a6f94e8b42b75f8965ac22207611653cc86005d9f79715b3807899d285de3fe99da0e6835f033b351599d421075a5066418278e7fc22ce1243670279e09f8113dd8bfad7883cd517a052735b8639c2565e45a91c24b67f276db0d22113a85d5077d491d97f830e482b8231c0c9b81ec18f0601381082105c65959c1ef99aef134b82c20531353b4864c699dd4ac7d389b44c8f60262b323979fa1209cfe95ab7d92ada9110135300a4e62684ca0273b1843f2b23ebd0e27af5705801d1df62d1659f1c2c446d7a9f95074b0af6556574b195c28c9a7da8a5104fa7758811e97a025174f35c1413ec5eb979074d1d9413292fd29f53ad1bb223c0fe84d572538c9924d4f4a38e647eff4525dadb391fbea463d7c9578a7ce5449336d344732c3e9c0e2920bab2c570b298e5096385c03a43c8b8f62aeed1ccb2a9670ead69c707c543b906181fd631c9cc917ed75b92a638c8ef3beb5b2266075dc0eda2f08d07b64207b71635fb181036b364f7a0d80cf43157182988aeafbd142c036eb788f6ab7a9a52c0f2479f9bf4203e906c7d48a4b6a6df2f89e870f330600bb3b5c64376d0e6dd383f0730daa8221ae3716f6dd85c8cfa73e3f3a55d9b51d8d38262e3bfcf2196ccfb222437559166d99e54975570806c5e36b929fca83437106e36d59d5a2f36af4ee06f04afc3865960dc1ae606985d2be4483daf95b6d921e649b7808602c425410e4074cff227863bf981986d6f89de13036d758f4411fb8ee6233f2c2bb5d308b4394933e1c1b9239337936bda29087ccbe4ba0ff5ae0b8442d246adf3efe8a3df6f4e53cc494495836c945ab006288499efc068c70c0f130c86a0fac4c272261aa2eb7e97f0e7cdfdf1ee9bb5df5d6cea583e0cac642911bf1a389dd1bcbde547d4035b5d93ef98ed4b2593efca8aa11fc25de1c61a837577e9ca376f44527483c043882b734bbb2d85041ae0967f581ca1273dd6d3e466e8d061f0984c0733532697b32224ec6ba195896d2ac2dc677b8211226936bc4b475438242168f6706c0dd9525d69f101a28edf5b4869efc6c28768c38246e02a57e863c895169e0961ca05bdcc5a2995f5d4ff119fcbb508c414f79772f22fa0051c7bc4e8d415de576a55814cf25a972ca1377ebf96ac81be8855f8e63482fca9638ba0749fe1b9f221c78fc31d5299c90149f55ecf01a7b18abfff8a3b8bfac141c9d8375d1c26944f6124cef64793ae762ad042a4aa206b2cde4829993f786a1aad727f1e24ee406ec982e9027ab23eec210f2715fc182b9782a622629a15ed4400e5b50c389d359e017759c142ff19675195d02072fd991012fbcd125ddab6b86d048231d210a887514a06f9aa5bd186d1d90afe33c7e1c37461c096e385f223c8a31404453e106c39f9394fbfb2f3b2bfe5ae41998051052631af712f5b9d520373090157d7fcb53b37bd49c2e0a0a8c22fee63c738442d9ae7e010079d7b051d5730a2823ba08a98645670271b1867a7c3536f28970ea243a056f1ea1f44dd06285559fc9dfc049a25b00cb057ea45d09ec175ebd3651bd381f3f872c153e25bde159df4274cad2717394263355ea80e22ebfed9f7203417aa9fe8593542b8f7aaf2f4230a4a8b11961a26d084fe419f9139f90745f03799acafccd10d2b413bd08aab277aa8a99164a94efe80da046d63d64dd4e6cbefabbf0caa87702d6132814087bfcb307f51c0146884744a3eac30bfcf2b235511f9fa9299e43b7ad5a4ed509639bce6b708d30675c5e28f617e60eaf3db54fb755d7d0162cdad6678e716bec85344f593b8c388b6d018a482d3b08a93d14efe0945a8b42783f82deeb4a35ae5826708ae1d4538de931569630d82cc36449f3045a5e8686e5aa3bfd105bc0ae701ca67daaf02e06370b6fce22a9a2f69d6f49d0a7e51db84dddce9d98d2bc35f6b71bdecb5a4bbc34d54786765ba360dc5f2100cd40c3591544c48ea50fbf85528c87733d6d6c2616be95082e0818c112f8094881b6933f7f7eed89f9489154096bb8e3479a1084b699ac3ad7eb81cf1d43f92998dc44f991a3dab7b4af5684a4db925d6cc57c1053c1d86b33e6efbc1a21aa69ca7e0bb49b93e1c0d8ac0a616f600b27ac196dab8cbe67e16b72791be0a797b9cfda257323d656a40d9a6e50ee4ee33ccdd334f2e0779a708d4bab232e7b0c0c2a9a5ac003be7e4b3d65838f07632cb55165f687e7321ac84f8a99258969cd138679b49c783f57ab4fdbb4563ff2e2a73896e9f84c4c942ff839ad63cdf6528d921ef4adca76b8e593fa71f16b6b9cd084507953532c641ecf6b71dea5a12b76658c7a188826237618938bad0a47b3ff23289e9fcd0f10ff21a5e18ca786a29f4cb3e8e7065731dd875294ef8055307eee39f1d3610bd11b9da10c1284746b7c366554e0c571069796c7846d3edd408c0ef4eb8104a214584fd143e6ba57a8bc21babbaa5faef4dbc62233fc415c3f13811068da56eb6527ec711014e823c2485dda05da6c430cdb06d9e6e1d5a47cb53239f35acc8eef1c316702fe52d279d18d3ecd66a3efa76a0e6ad44e62eda4ea92f878e9bfc966b3cc5124c16f110c8ddbfabc1de416daf39cfc82bdaf77a47ae09b4d766a9aa94cfe5fa91879af0c5aa6c1b32d3dee60399530c1e847708d30413e4daab9785f67fcaa1600a4a075bff27f926c7da0f14c109b737c4004a1531154dd220fa1943ff43168c326f43b2298a028db067e3302f5cfe431bc7b39dae68d5866b9684bd8dfacfacb40dc3f38e1c6f9015de1f9aabb5c39556249562a3e005c257feb30664da93752a1918cf3aad6e6d1706c1d2029346826127fe339ed0b0e870327e1935e54ba1ac3ee47528ece519977a812a3494ff2d31fda5a2b697276e96975564b9e703be799f3279a6b5a282f4aaa6ae123fd449ebe43cb49888a1b72428baea133233b2617eef7002266bb9d530b99889791ff3810f27c04733f918df30eefbff9fd9b38510cf2b56169dc0a62975b23107e63c83f69c2c6c33ade80feb1c98e014e5d2d3dd7ff44b7e33fddce38d6fbdcfef30034c3d63c17aaec8d8e446a0e671d392619c2cb865a3038f5ae9f36b549388b3ea33939f847738828c5ff7d5a16c9d3eeb54e89ec2f5fbda7b70be36132b578f5720539c4d2643bbb926e820dc8f6915d9d970047f1da88986b8f06e9612a291eeede3eed0089964b6e3227c0eff1cfadde6c4d04b911568cb0926c649d42ac56f297b287c77a4d500306e3fd2267e33257d06333fe9dc18069ed1b4c6b4e4f57d77f7d30aa3ba2e66b9759bc3f1ef5917a6b703774a8d5b16c72ad538126fa6398802a4d2079db5fbfd9a2753bdc8ab089b9eb93d21657f266a45ed1cd0b9900b889a5406a01a94cad5a2e181456e3be2983671f78c37977c35bf577a092aabb4323342cb91ea18226c56bdfb138ca4e144a39a8597bd1612d6a3b6dd2324eec108cf80caf941554608dd96319bf97a8d799359bd08ef590bcda92ae4fc985ec6bbc863238c48ccc8c9d1f31e344ed42a6153eb696e7744b348d2a618d0aff14d5b523ea84131eeb8ee65c5c89771f9e7feae6e38586d773d65f7e2fcc77c838c341f759d687c8e2fd638001136ff4e6e4241f222c8500bffdaeaa04f573fb034f65972aa0f3c0b279f42f91818bc93442c2c8beebd452c29de40acc808f761e7a0e67f5390b955a42d41bfed672720cc5c8eb5614a1ce9b18820b64c0abda123571cab3c72da915a12a44ef3414777e29e9cce316c3354f89ac4b5081d9dba94a473ff1630b2abed50353c54a4b4fe6ca789a5af71dbb7b46e17b2d6c706909ab134e1332b47f6c21a874efca00d9bbefaab6d1228292c7baa6c38bff7aeff6284972ab0415479807d6d6da03a5dc271cc53a3b4a8a787f5fb921da141a89342bade51e492cc92031a3ecd9cbd062fb308b222e2ea26e96018265f7d987cace04e53217d42bb9c9d2bd3bc0fcab2b6a8a698e5d912d18ef55fc9ebbd0f43470f2b91e9e527b36be4e7fb1473cb25c56e610cafbebd24dc277e41af96ca4759a328e6d2b7370c3e3d9f80cb1e5a59451f7f0f57fe697b0d60a41097e730834729f00144fe66558a28cf212d8e8cb9e4c99d873a53177593b5903468a52cf608ad7e4d6b4a9e0b860faa0c30bc0602e3e128986a08904b14dc3e81757dc2172a72b449b2508260de0040b9df0f70e896fa07f77a07a21ca8ba5a94d1c18f8e89c856de5165228e83b8d809457ef21bdb507832bd66f722265f46e50926988ad290fb52c03da4ef6c0f092787933ff049f43223654aa0113e5914ce6aa3f0ff4db601c012f076d00e95743aabb55d403ce84b179d2725328e026b1beca801aea64b5c85a88fe65990881a314445df1674e62048a2a482ac1fb10abc97eaff193acf25c9eb4acd8e6bf09bc62c338613d4d52f9112941a3ba9ef0bc9baf37e19","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
