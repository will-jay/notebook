<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"957c2ef6effac5d09c5e1c0964a513e5a550c1d613033820984a3de5b1be774ee103512d1b0f348cba4f9883cee78ed2209c625a3798bd936b84e1ae0bb07cb5a83653e1396dc81bd19c69e0d101219816cc6cf8fa64536018839d88cc609bd75f2a4b2d25cf07efc5cb27e13d0dc2c6bc8afa1ed7c5e61e292180358e0961c2485010165f53ea920988964cfd7c5d369a648ebe579b34637c32a03bc5f2d587777c974d024cc873b825908b440d8b06c8d40247ab2e46a806fe7104b10df518734edd9172afbd5c19bba5ff97fdbc39f18d95469a00d6351df5c6e064f538372c9d7760b5c856b1bdd8cf20b20ca875a715d01d1d3f8039a2e14118c7aa2d4353a913df445b36f866b84fac85ae943ecec378d0f1c4486ea879cc7bed7f6f05182fcd1dde832a7abee2263f3060ebe6a1cbb29853077f86e2d4613874ebbcc83b418d07815528df4aa38474d3b54285615109bfd305259df4846a7bc1f7bb6e9e1c9b3d25d1c38b31c350f098c219b316c2ee275b230dfc5d8c06e698d19abb28840852140a00ecdef9bb398b6c077e1fe24ac10e5eb86a6e1d2a98050fd556a9e7afb7a5e8ce3c51d7bd917d8f4ed4ef20e9759431331131634a067cbd9f7003e826f00ad2324dccefccadb9837540b526b5a49626387c43be36ffadf5b7e5da0696a0e576659ead8d64a11ea0db55033af1f389bb991d73be58fb81d585ec2091c19c91b0c929672225d418558c0231d675314b220b8f918715eccb30b3f6da5d176f239eff37d1b61f493b86059bf72f518751ffcc38d97f922e0a248450725e121ba3c9ae874792204e0a9ee0bb265575bd41be8ba5f812335c47df6239009ffc125b768bfcd40843ed7f10f967fe549777ce6e774bffdd9ef27eab09da796fa875d26d6d95080b2c072d431ae79196f09b7232b79d0dae44d1cf9fe69846277957ba279ccfce4b95f33fa5bf7af3474cd791587e79c2b02dcdd910eadd5c02c47cebafc9d16843e12fc9d38df80dcf12def75db1f110771993fb7807ef0feca01785d9af8cd44ad9b645122cbd3b16c6f27f1b8c0b97343e4bca1fa49a84340ed1d1e4062fb743de3adf97232cca83d114b6dab9768a0526befa618704dd6ebd79a7aa76b3d89be370ade8d1f1b90f0a87ac5d834e05e9a58348722921b1cb8719e6aa04f363167f46cca0e0873c63af98619bf72c2b998f5828cea6f8d020612131c47d065c75f54a304d087b30dd6c8a7280acd1a2260a9f520b93822259ef685335013910a0f346a84e4f2b9742349f70d0f1e63db49675dd1327b5ba69e5712f6e094cd8c1d675fe7bdd0f4859ff86e9279bb01281cdc621c5b53b289ac8cc93cde01d3b0c8efb42954b24e06be307a360f71ff2e300113f996c7953e23120583e9ffe84f96cf67146bef0ec72a1b31221dcfdfe4ab807f8142dbddcf6f3c13fac193ab24b35b0c5aaf630af884886ada7a93e0adb88b246c823474806cf86d6524634efb82da2e24f046cf899a62c4e707a6b93edb1017133ae2bf25d1e3a4655291f5a98219d05a1065dcfe54e8ad388a9a5b07a68d4a6b8b0793d233430d752c512a6ebe0bd4f9947d482cde5c1f65d59133de168124adcfe1e018bc57111559adf7768bcf3ce797c5792dbb3457534b9378055fa00d79c21c64703320a15ed49153f57fada8b5d998a5652d6b7e02e4c7e7c27f704b62a81c16f271a08f6c691ace36042c3c8e11393a7cfcd82d7062bbb4d2bbff30891091c49cc4c90de148c48fcb2e81d5ed675785198495fe999e0ece055b5c091108da0c7883001a95a6016f4624d749403357fe44616b9faf30754722fe4fc62df851ae86331063b8f4df1f95cbe80a24d547690314311525535a59bc5909fea509be74e7827a669da571e54aceca234f4177d8e34e4c566628da80cef03abef4be6937aa516d9cdac0c984c25c8fe72a54086df62cb683e3a8eab3eb23b974fad84c733d7c0eb88a3d8cea07390885fe4bd7386d0d06580309873ee2eeb27447d876baa3bd45b9d9fc70151a500b1897fe5faa6b740cde654a5d5bbdee10f23c2f51d28bec65973e04175c6509ebe987e45daad2b867d0f4d7211bb5a9f35951ce72d52b42557648692abe791c6fa20230c676212892dcb4e7356670ad1cfe6693216b355c0694e4363940afd38407b75d15f15d8ea6fbf0294501f2906510c44fefb87881949008928654568d7a9fa840c7b2a310893c50fc0b90523afef40f9e082ac64a9a97dd72bb7b960478f003bae4db1390d7d43913ca05d530dd2769819d77950129cf17006e1fbe3e24e031d8ab9fd190c7ffb25b28f66e2ab9c61d4f8ddb24a98ba1019538fff330be018755bf657a442967a86fdd6ff68eb8e28d1c83e450962ccdba6b8af7fd14aa1af24fab12f06489bc44672fafae7f5e071c979ec2a2ac55805d138dec408f3bc69d24cb7ca72ea7d67d4c3c1ff8dffe9a3f3b7e46be8f86dafd14364f984d82eea11b0ddf40baaf547736373505ad6d6ddaef4eee66cdb231132ab7ac8e861dae62a2d8ce2e542cab798b0b40f2f2a645ccb6cef07057bc893c03ec9a5038769de9e90f69fe47300acc1596c0d6adcf80817ce20a4e40e4a52eabf5d8e4ba20dee2e1cd28bc38a2d022a7b1510e7f1a584075d872a0dfc973ec5a2ddfa8d3f69ab8763b9f82334ff3c9a0ca1dea0cc0501c3146e6339d7f35570e8523bb5dab55c71bfbfd968f1987d38ba62d483fd59966c35efe3aae252a569b45d130d99278b9026c2982c21b64efd6aa4f97b78f906899792014a3e54aab1fb1ed5638a842cee7e3e87251236f38ca0d6a2c3e43b86e560ecf6dbbb0bfc24132120773bddeab23634ad0510eda36e6557bf929e673ccbb7f7b8ddcc8598c37f5ab56fc71b72788f05b7ceeee32dceba3aaa699a9c7a0dc285cc6476f03e272fe2520f3b5e0c69f926d2b75496ca2b6d3faa66b36902965506ae19bc21bb2b5133905655b618ca6fdb6dca1ea3f4f44d633dd5545b26fd276c1b000a76ea4314e70864032ba484b82a433c0debec0721b3fc613d03a6b2aff29c1cc2ee00c89018827116844a0cd485db163dbc18276f64b3040694c6c7e0867f0f6762cf809889c52117118038b8ad3903774827733aac618f7dbc94661685141d6b43f0be3c848093621c6874266847bfdcf48ba8ffba82c3c4491ab84d33313bfc819816775a099a88817bc49abd5610de83731cf2ec18cfc2f11d87a3bc89e618a99852e6b24705158aff8a05d20de7cadd55aec2ce55e5f09ccd59fa80274e342c926737ea1810bb09cbfd5d714834d0d376fe9c848f3f06e0d301cc3abacb46c72a309eac988e86243dd1cf41b24b52c33d4a5b2dc92526801d7a03d5d8d8866c2ed91d057df1131e8e3c19d4f3e4f45fab6762d62282e4b0b535239538256df95eb8872ce4efe60a58089f28b48f3cd8babb879eb25a5dbe3cb0f91f3ec81db586d38de70ac3e3aee8455d7616acdb9c2dfe9abedd716053ff223cf3873a90556210dceeff2e9e98a6e7f1e467aef9e719b5c6a047f5a09e4db83a89a40088b5d028983531c3940c68176e9457b4e380fa4e65dffe23dcb83383de5f4387500984ddde752af82f31457ad8532713f14be13a7cb64b181d0b6021ba963686982cd1080099401bd8a75deb003632d923eed5b484f0d4569d161122b7c3818e8f94a85c8ce004b7e71d3ba38c7137c656f293e2102c73d8a7cb122cf8b08c53e3e4ac7dd07881cdb778f8d0f594184b8d3585d49deffd0f1ee0fe5978e39a45754cf25a90c1fec4ef64506d6f8616091787ba4423fc0589ae0a37805d21dfc624e01693fecd18d80c4c0cee720d80d0db8a9ac915e5250cf66c2f0105e0bdf939389448049fd0cfaf3d07a090411834415d6d98c4b4c0000dfc73de76830ff1435c8e85d821b4a9f601a5a16142c67644138681cb94be3a74189c644dcaa0d51958eebc42f7f6de091da5c640166e72179b71da56685de40b1f64fefb00b7fc727e93f5a0036c77c8a7cd52ec5a9025d00cd78c21193b6e46bfe21ea73646ba53eba83e46adc286c35d42b11853d143b3735ee6d7ab19d5ccef3bff813e1d406bf3b5c9fd7e0a4222ac8044262d2e7a7393e697a2b21ece6c1107c1eee27cb7868279e33e9dcfdf1e48fa53a6da2005abf52321a69acf3ba0df83645172bad31ac6df84bc14eb1a2a6736a71b4bb2b98d56ae4375710ac80913a62efa4396db4284fc0d4dcccd0cdd5c0a714dec33a4299d582ca30cc9378dd5d030ce147dc7468f229c6aa92513de8c596c088f6777d7d789202f02794ab5504c67b3a4ed7e60052745ec848ca4b1c99baa55d4c6679d3ee126c7b6be615cbad0f241a135270c8ad7c1528a9d2a0cd1dbf02f512418356d6c299e507f53cbddc168dfa580a928baee9279165cbe6152ebf2b816838cf6c34c6c841cc9102d4aeae825f3c53e93fb55557ada975569bfe00d39bf5caf1de0bf2e2a00c2a94cc9bc19afabfeb1b9768590c9bd6228cda6f42b5105d7f349913be1eb0d63575aebfdcdaa921e86d34f4b86f7d47771ab744a0e588cc507d8be8175eeafab875b73beeaf53d988f424fd24b5443c7179995e2554ce7108337b8911ce03a2aaee5cbfd5e475383f727fddcf0832a030760d5fdb4b01180a56bf209b77d61fd903e40813d7b4b5c47608f5da82b917881ec693e30cd0ccc79d3771e7fa61409f55af1efe05c61bd032ad279590514251ad3e43fbff83981ac97aebb71a601298f40e570294e13e112a9d3d356832eca55d897c5289bffd38701cd35da6bfc8a537d04d34da34232af6953eed8d5b3f87ff5aaffd18fe7212c2c54a975a13d77db05eec780f781a55c73e7404085772b59fecbe87f6498442c6109ac560dd5fb8ead56a2c7a6e24fa5502be12a9ee5a6a072acc063aaad2d8f8d22e5d64b67362fe5c5844d97412773c2a518cd5a6f206cfc2b0053aa0911e231e25dcb9e13a0c8f3ee77c0022a0513c679233931ae23547748e98048a0b29aaccef9a14f666b2a5a3644839132882d2f5b3a09371cb7dc51d3960a11714911466a192c4700582c0a15ab050e44a3dba7d8add50783ddfe37c4864b6f390e0bf87073f3dcd2c1121ff7c9d08b1418e43fbfba362e8f8bc6d16dcedc8ae4b479ed447dcee8143995764d5f88ef0dc6cb6cbee8ab25dbaa7357070532141d5097ba437191712116464497242115fd7bd2fc59179b2a77c695cb9fc1ff2ddd02e23edafed331d3f4106b6df767144869b32714c5487e6520f1699e3297725b86191d6648ded914c2b69fd9ff45e5ab5e4588b5f912905ceae8dcc115ec6a7e048aae3074b7a8bc172c4003dd08afdfc3cca1ac5a72c433b665554b9b5f3d52d01c667f5f492451d38a0394e7ed4f413d6ee5e435a4d838bd032fbeb87821f0a158cddc89d3206bc63150d63d4c46a1c9cdb84b89129db437d8f62e05c4f91a7d8d408d3f7346e245e06dbba8a15b91e495da58103f0b4c32cb00235420f44665de3dcca9df0f17a551aca084fb6fd3f88c57039c3aee8de595ae1fe52c3b65f332dc27557a0fa4189dacd90b36531e3d7b70f3de6d105622a2d32b879453055fe2d1a9cdeb8fb96ea9ba90572e58131c01a0ea5d68ebe4f7147d7af88703ef1e87f107201b01a4d24d4cae691d3d32bf2c2edfdf628c9b9042d58bdd4fcba6d00a89ca346efe069d290db9cfc77a369d67d91c116924a79eb9a2e1efecd772f4b5a725e15df2433e2787532ff3afd57dee6f63debd3e804a13b8b01d4a59f9f5d4d662aad15530a1264a3654f38738b5d98a785e5f43256b8e7af9d8db4b74aa8f320b775fbd8f61c5e689ce30cca7746360887b219d20c20cc7ed25a28665dd8fbf504cb9f2680b9f0b26f110968e5ad713d6bafbc54bb64fa484763d0c3e6d846c927184e394de5ea0da40951ce52bd35f1af8bbe7e5a1b524aae3090effcd57f43c5442a42f617ef005eb97db02ecdfa6f2b2cbcf97a4bbb6a4925ab24d2cd3767943a75def7099e67520da441eec1d85bee5e03269cea2386c5146353bb238d8b3477ec023824b38b95e663cc01bd74b4d54daa8fb56ccc08a9424bee920560ef6a67f13e256123f032f34fbd9b40fd776aa2983fa963fbdd384df4bea94bd335e11d935e5dbe10427387995b458e2f74314d0f50c77ca9e0fb685787c09edfa680f44285a9c7a420a4cd7bc59938f2e86c57c6c7a6f1283a595380e45f343d0038e709622e4824902bce6efc3fbc42d05d323612a2447595b050f6a06b3c861c59e2284532b82832de570df329c44487a66a3737d611e72e3371cfc5eb640978e7116ccbf56f0c890535e71efe2df19673cd82ad2a72451a06981b5d1ba58652b74d1d1a620ea086409d6524ccb65ef9fcb18df64f83c36e7538d27377c9cab476f53c1dbd81d693622c05424237bacce608b3ddd5db9a735c831533017ef0edf1e13e800089e28d6d3b753842e37409fd4aa3071f3dd2b0a6bb5eaa5ef0ec0b23ff9e171381d6f0ab2443053016d4b615f1b7fccfbbb788af9d58988ab8ef0a06860ee53c04c03b0b08bd37c300eae4b4e5133f10b6bc6d4745cd75bbda19e246f1cc1b929919063241783e62e3b454c2e61e10fc71b9cfee70e5eb9f814b289e866be380af82aaf6944e43dae41fc60f542c3c42c4e673d560cc1ed5b90285acbff5a34514c253c24432ce3c25996f31f577c34bb95cf574e92a24cc6a88d6aa778b854c4e5d429d018665a28e31a2219959aa0feb4568ada91b278d3fb90771a48d0855f64b4b132a9a5feca574c8255d61526def9f2d7bf0aff86c444d240df183c970ea18950ba65545a83839cb9561de059d3b98b39edf8d3b2183b4a51f47bc49ebd8d043702010b74a2cdd7c47faee6d980dd36c7ba07de6304c0474cd724824d4912f48aaed4b73de0451eb21c07e49b784e8b6727fe15ffe6e4f83d987f595324236f94dd90a95f172fbbd1d418833a536c2972514f7cdbffcc5bedb1dc1c88ac2f3f97dc7d0f7c76bd41ac6648f57c0660ef5bfe9f2f1ad571f89c40e1091b237381844468279b0e49b72c87aba5ed4a70ca33ea00eee2a54dd45a3ccb8ab2558a9d011fd9046c27e030bd44081944b55af815a166a4c5b9cbfecc5830393008a8b7fdadae8f40c92da3a8ddb6bf6ae86e03cc34fa0789400ddfd51cb32f2221b130c2a3e04b8eecc48b755b9f15477d6b4dda030ed03c200d6ae917d54f2520bba3eafdc99c381bf346a96dd27b185f9cd9509a553061e2da4a4f69790ed8df7f998e7961f85dd1d37f7fcc186daf8d515acbd15105fe457188840f1a5ed89cd1a0f8d3767513ad4b3cade2a7a0f73eb2bf405c32a15f8300d799fbffbe1362566e47de786f18aaf09f5d9584e6a96088ba9799a54bae8f65af576fc55e421c3c677d85846aa78c0a8b42d50a42f03c5a2e2c2ac5ef2565747e104d7f4d30eedef4c3049685ead48051531548be14d440207a0b51d9fee484f33bf5ba67fa651a8700d63f72c0fd4902cf6ea0029ea360dc86f2ce3679b95d398856169fc7197c82d1ece660cf1229d27468e428d1d2422cd5b9fc5cea95b0090175a81b4327c09e9e827851d9f27cf0c2b1c35e0abf140af3c698f058bb8f4657c0ca90eaf6d87c8c2c22f813ea2edec00e4515071fe52fdd302b27e3ba72a8690a705aa20b4d78bfcd411f8ad41c4f0ca7f8017bdb1c7f2200088336088a9f59c4e949b50e2afb45d5d56533d169ec334d736b22b3f8369f1f2dde4911833df66b7062bbf970930f65454c447d20def30ae1a5b5f9411f34b0319fdd3b11fabcec2d5c9f6ac10501d163a2513ce7168f7535dd03583858c96db7a78e272131639c66afd0fcf2b757cf7765ccc704322e905d2e8e911e5e26b719fc9df72dda06bb4eb7bb64e890f94c5d28fe2d8d67d1653a7fa89b4313614de70743d9c85709abdad062d48ea3341b464bba5091f06f11e5d65652c61575b7c8266b430e569c5ab5f8234978b090e7e2628b708848987449e10ea93ee22cd287515fd2810256c7c6280a27f2e463c1a6373c1cac12ada93ab45e9a563552bd5f7ae30bef711abfe0085e6f3f1632f5de4db9428abb2c0fed1709f6a7feec9456b32ec82ee450452e03350baa9bd1a17526899e58d457e1b4f60de0cf481898a2aebae2be8f927c0ead206db248193c6a3d128d247ad0b853dd93713f001db5bf05f5e6b7750fccfc73df910b91b838876d68703407c4fddbb5ae885a5c2c2f80f930b5ecf1d804b2bf1a0a16bc614c7d56b435d10caa380e57ce58f52b7cdf8ff72c1ad4a2a32866364f3acd2336b0fd1c1c1d4371905e1c99518e67d1619483df767d8f1df340fef4668206364b22fbefe5004215d7ab817282c6daf88bc7c35ddc841ff58a02e10f31fde648abb6d3e6715e616bd49d4e3def17a7f36e8752cbee6e2098f61d7c3acc0747b64cfb910a844663f86e6964233f9b492723ddf2ba246a15ca50f9d1dc7a207b61e1c06143051e76edbac895851121ec5d8907b73b1f70831a285e4b32a0fddb51f8a07f54e242a1d4dc11bff6108ad589e61d0c1b74b5f2d6081bd13a3c05883aca90d3d78b8a3bd8f01c19656389e0efdc8bf79d59e4f0622820d5240eae721c9e0ed68eb36f5f0e7fd064a81f0f7106b496322be2d28191750b28c1040b9c47c20027350bb434d6107fbae6740e60d8616b42a4345f417dd6476f72f9011a151a3af369c0ba362a66fc4b35baccd340f325dfe9d2f67a58d83154ee4268ba09648a8c0141a399035cd20252e5db4a36b4b6819618bb35532c15b13be99d438b716e41ab9b6bec8aeb08d5c17845c29c2ecb97d34d2aaeb77369537f487bcbe49dd016cd411c7aad3adfb8f241adfd4609e089a4ef948596210fae86f9ef6568683d45003297ea9a1889ee492b7fe145a1ffd118a58e55ffb643998c10be46fcbef60477884a9bc4646633092ffd0721558eaa77fcd8f5e5ec6ad75b20ebde0d6d26f0ea4ad16d4d16cea473dbaf3ecc22fe0aa797dbf04a22274b908b9328793a93fcc1ee748e59bed539209c40731cca756a01028688bbcf29d5e3b9e485f66c10c38410ecf92a4cacfd5669de4076eba1195fc49e1192303d34b1e8387486ab534e72f182dcec4c4ce9fbaa1935ddf158f0d52eebd73ab6ea358e5146508c18a9646858ab5c663606da6db03038f1271fb0d36a746473cbc352762abc25096834f389ce498a6c616b135803089e4d511074730f88596a33b2a9ff7adab75ce2a1d079e38f1373dc4aa9777f9d1f28ef0c1c6cb92041e42f19cddff8814080483b7323827304e091b451cfe900c78ea971113e6456fdb35f92ef90225ebbfe737d5c218ab5a577605fc9b8ede90988cd6927105ac7d5d560be6db3d91f4b0656babd2ec5ab273214b547044062c8d487dc8d2c09ba8b1cae3ef42b3af2174bd96daaa959d9ae4eddfcb3fc6f57012fabc0d1905d8537c0e62cc420704551079316c2c9077ef2f772d21ee8c21697f1b006e9a9decfd3910b34b64449d14d42f75f7437837e09cc46bae6da54cc51f691f8c94ea5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
