<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1dbd9359e29433850e5dd20276b3e7b889fc3080a1b72f47eae4bdf1f7a79b22d1142c116b444d1ec595852712978c5b1446c2d0e58636ddbcefabd1e482c96ec360a0adad5fcd77b15c2dc9bd0451a66b68e05435d3d93bf88460a7578680572c8f0710379c6051ef784c5b524e6bcd5e8f7145c11f2d07e6539a4d0f9e53ab16fe6cf69377150b3d9986877c7aa03b573522ee97ea1324ed29f1f5f09e7bec459b82b84388879de35d48a83a0e0956f38dd759b58634dd102e6e51c77134b9f6e1b52acd1751c8191783477391841e8bb378169e25e94c1dbf6a94fb5daa9c38840fba7f38a76d0a2b07c1e99edc57a84fdc1c61c4d6505e0b8379db3bfc6e41b8467c593d0b471af12a00aa4724a80b9b7f31f3cac3fdb94e7d5bdd093c398a8794b3e77b95dc5f0bc3e71d56bb6d9c1ffbab0aee5a0eb18dae484291387e41ea0be3c4c2ca91eee802215a62688ddfbd129d190f950ce4377de8821c1337ca42ac555950b799c759468e5b0eca1d4f274c9d780d07ff0b86f20d5e8a256191ba724782d1be5d9a708349984af558ec216728cb1eb69aa0d70cd941ad03d9db0bf97d795bb1d7fc2c17895e949a268f47de55a656892853837721063073387aa5006e0d6f3369e9c116ab6f04ba0202fa90a5aa7a225255e150d67bcabb436ea99184428de230764b8499e4413e7bc3578a43399d4930366aad6e9f749ef1aa7b46986dd0e9b335b8d91e3a2bf20d1c1e83d91eca1fa91039bbd8132a4ae3420dcb822a00b7ad40cafcb1ce6b2448470feb3259617990585a0514034fa027fa0203b3ceb2848a858f5f51434ffe3e506f4cea11d014142da6623fe5d1a6086965dddc4451968b6f75bc89dc64594947602a6bba167b15c2a6e84a2c676fcb7b9596a4189d7f8c73b8f8fc40d8a58ae471a337ac6e8eafba01cd2ada48ef456c2f312bb78c0c3d7a06f436722a6b245192988591290056e1a408240bf1dfc0f6e4412d162c40837d3dc71039a6c473680e453b049da99e547141b9d046f135de37c47fbe4cddb6b156977a3fca93301c89435229f1d16a7a516f06a9fca85edae28209121bc2d794934b6a00bfea5492a1f2ca642103aa03e59d77900860d8cd0595a0a7a8223fbe274b25ee9ec41cbbed4d10645e5dcb0bb2fdea255f83d1ba67f03827563d80ea4a5450928cc809998d0387aaa3eb1bb612b6c67deae6ab50ca06b661e9d394f959999dd4ab5e2ed69b1b7c3c6829e0d82988221fce48888e04148a12587102e52d65ac4087d5d03a9483a90d848e5d0de33655ccdcc65b2785b2977f6f175a7cfcb6baff2f46416a6a5aaf9751b7e4f3efae7822aa0c6e8c56d82f2146d377eda811cd7108df89a7544c75673c2da4d6a9dda8c2a9c298edcb580878cd692a70379a8d97ed00785a2e0e316cd904e24616341c8c8cc340b4fac081b8ef5f1cca970a15e89a54537c83d75b95c55d7f3e885e50d13f1fe9c4ef8a98114f3a3e098b3415987a9714aa4f4d39bc4bf95ccc5a0bb922f9161cbbe571fff4913d8b75ea86f2d003a01ffe6948e0a29af1638fc6780f31f3f1de8ee6e6dd8de4d3b2415340793d616c4766b52029ab62c8cee7ba50738b5a4d9723c2c33b41a2a618c2e0dce8c8bebcd424c46744c4c9186a3279ed645b45525b75ab791b1faabaec260dcd83716503d1e1783c20f84a6073369b5eac8965e67ced152380638ef5329e20021532e90d3abd5d520549a2ebe04dddfc5c7052879aa71a16671c6d40fcd6eb7183cb2d4ca17613283dddd5d19b1b95dd54758c94d4ea5ce6da84adf55f42d1c0770991b1e5f9299a4186ae9e5a8736aab9038708e400d03476136f963c9851b5d92c8699c67693f0d97586715fc26451029386ee6fffb6bf86a47e9bed1236fb137854dd2db4a8b5b250410c101d3d770765e069ef5f206fe778fe9324fc61aa615fafa88a0304f7762f0cde667719f9fd06c1a894e263c4a224704f3e22c0a704b79ffeb635aa5085367ad7728c764a22e6bd578f3ee715c42f0ce4b8702075c164a9bf81e7a2901d637a49dc4025bd3efe16ba433a8e4698551034a0bab2bce5f3ecbd6913d5fc7b54f3582f2e79316c25ef6b88573a329edcb8281a9a7c9a1993f1cf70235665e76f4571e85fa98f500d36f0e23a27cf56ff538e4e3c5a43161cd63846fd4758c973dfe72a4200271efaf143dc5b513e785dabb6bc729c14bb00810aad7249bca3906e36512e22bd96f002072c24d54ae8aebbe8665631d428edd58189cb8e1f908b7ef98e4dfafe3e83a2ae6b2e53ef4318404dc18b8e00171c5d875da859b5bb70b4847361beac07c74963660672a1c38ae6fe1865e9392b6f18611527af5883358dc1af45f777edf8d9e62217f47cbc841722593e60688e0ee44dd0dd0c406fb7b3f2b16a19681a11dd9e1333ef6f0d784c05f8d5b4f4ff82cabdd0916131bf355581bba95eb6c3e9635111e80e065dec8379f140fd2c8644aa7963f45ff37e4bdb0547d2b39fe5537d233fa433fbc678308f901c311b4cf4369eea6b0c2a508b4b594097850e6117a4514e4eeb9885c6a5589cc19753db62cf3ed41251fe402b9c1c1d22ce45241d0eb50276c9e04a6cb6edf66795ee3608b287a54a6f89b19c110f0803dbb750d6da256b1ad89c0936203a62d8ab1244b0aee39235e04af1141ac541e931c8a9a8d3c9240554d8cac3926395ac73d02faa1f3e72773b649d29b76811cb334770d35593810e4455a0a8613addee8cb61fb27af33774aab769f4c18de3e85cce5814f6dd3b6bab42e36d926006aee0504bf49b146acb07c774b928111565f965746115278a678e8834f796168a4171e6ab9a19244f6323682c2e2ed8d66356a289d29e8a0b17a5736a51d85bd526f91be3adfadb588e2456c9515eb470e3613bebf4d5f153e6a49e25300255a47b1629ff230665d57842cbc9f1faec693ec2ec38ae7078cbad463429f89c2526f29c4999d546d2fcdd03f20d064631cf4468552672fc3b9cfaa85d19e7c88f8bb82f6ce757281335620b78d5bff2936cf6df1f44d724e0617494fee033ad434297709838e82c7330ae6cca1481bbc562cb88258eda01544ceafc36f2ca7df87eabda7f0531a8ea6fe083aa706fb76f82ed8acde62ace2e07086c1747ea1bb3ce5c09894e71edf7ab5d211f19107f60431b9fc1843bc0f237c9fe1a0b73b5ee479eb29c881da3fb0c97a5f1cbe5481b8904f3d05482a14ef925bfeb05f1e87401d012dbd520c7c571eb4087fb4ae110c1b1a7a1ecabc1e56b5db68830fd27fd458f43023b8715c1a79214b5d7420c955badb6314ca6937573915b512543607f7e664ff958fb56320c157c8284bb5667e8eaef9a0efe260153f9598cf7de97013dfc3d835bd729c474fc339191d029ea686424fc3b0d207e1ebcd9bb76e2b32b295d6e10753f6dfb56b3f7086a7effa8cb6e565ec747f5bbdd3edf143a812f963b153ea4553fbeaeac02f922f8385525d742825c8c7418dac9baa5c6957c4ccd511bab7cdea3ff6fd9e51b9ecc18fceaa4b22a1e5ea0967e1f7b3cdd41544fe3dde1d76b8f1d46e9a088e5f3ba7ca311a2fd14ce8e2af4fc02546f1c5bb2794fa9ff5e57aad47eaf9aed30a888189aefe68eeb67904b858a47266c15ae0b7437bda5d3f231de264036c829d363c6e78dcd11eea88febbed0f9398b318c2421d1f1fc099853822c46e28142ad6555591810cd4bb8029710698936dea7011cef83f2997b32be4056ee784ac092683cff613210818dc3d32e1093ae13708f35f641263fc72767b1ed1e76296061e706cb37e517558020d3b168fbd1dcd170860c958a0488c0133510ce12cdaa93f0dce662e44a80e880b454f35e78942ce68cde5b1e0075e8031f76953a814af76754e0ae9a564ffdc124a21c686d12b8c680782efbe2e982e275ed8eedbe4b2a0f7c4cd6c07be5ad3fc947c0a8b1e6407dd4c033326575badb713bffb542975493d40b06d59596c22a865d3ff65871bd9fe8aae8a8f50fdd4c3b1a1dd7bac28e13bc4fe61d9a91acb7d68518e4605965e756cdfff68fe6f3883ed6854bddd16cbdd71448886213b072439f6c4fdca2f40f06bc901681913a4c67ca029c5a9f99f46071fabe5d012471255345644afc6756a187f910d2fe25766081a33c575251d1d580eca420c5f33b12a1970d210bbd94e7774b675cdd7ab263ec655d207ede8c9c14c2337d912697cc99e3a5e66763216f8c27e432d0a5836146ef7047ad2d184e4fbfba4f747d935a1318951fbd3c5f4799fb90142dde85f4b18e7964d2671960ee0956aa234a30069c407245beb92e76281c3c1e855c4576268d27073393f45f64cacbb51d053b11e9d776dd7f8ac6a557802eaea8e02f0c9a765a2601e044ec03ccb21d42fd50eac99acea62ffc966c8a44d38790c87ea1b6b5e689a37923d89eb485973fef28c19fbd0c528cf492a6baf0df103ce07bc04acb4eddcbd929ee1bc197602a8895468699184ea1c707276773ed6e81a0060671b5bc5305cc40c133837f61f0d0793222451fa383cd1edef8d4f6e7aff2e6e63ea70a42d7bc2849a54a816abcd7d49ea34b8fd81cf92bb85ae1aa2eb99c4a3babc2c7e4e6d79e06009197d0f2f8d4d4dd1babd2c8db0112f2df74933327317f4ba1edd6e44fd542ca11b131405d09108bc4488a47966d13cf81835debbf74b9b6428e5e6d80d1e2193c5e173dcba76f8209c1a43902a536472311b6d35a57f6d66e67c2b60824a412a34c3ca2c3def17bea3872cb7da94b0cbe76c0e1096b21a0d2502d6ffc17930a3efade2ceeab7080988b323ea838f4f34ea5f922d11f7aa9bc87af3390b3f6c6e84f9987f5404b0a0afffbc703434c67618d4ff30bc822b8a9609784c95a55a57d45ddc28149aaa1be6a8d65f5b6047ef0d1f211b8cc464067bb86478a0bab9051636d40125fba8cc24bd923dcea0d07c0e7df79c37a2ba2571a1c21f43c8361274c2feeb20aafc66d0f7ec720ba5db26e06f138b63050cb989d95f44af04f0e9cfbd70f433a7faefdaeb9b15bbfcf3707f7fb770681c7ea31f068b96df149fbf2e24b24a20811e476251a6a2ec32e3037693e0c6a2d023880ff72965d1b5a62c716c7dce87f80165d0559705805276dff63de07562da6020803929dc0fa736c8ff4b4b10eb266f143d7a44082f6557e439d29012eba054f7f89ec5c938d0f06958851875b373cb2af049947a607574d07042bf6d9dee4b4e186918059f6fa883e200bf966c8ee46fe987550401f43d51b081e1e558fc0ce944193e4e670c2cc4e3be7ac3ec9b44e14790b6c04dba930eef5c222f9fb092d001ad3427a6ba67b38a7d0a334eb612423b05c1ba45b9ec2091e4f8901dd4392f4b7fc70fd228dd1303441fdf8df7f030e7a090bf2476131c85ee066255e17d06bab0cbbfcd9a3559b0a484175b7b56da0ed7969f5fd34c4392732a006413f0639920d7ccefcc5640850a97125ca178d430979199ccc2c94c66a1995a40c55194ece19b9a14762a423b1153b996d6403ddb7b2ae151d658b7c5b23c790dc8b678cd56a5beeebbf288429c8f32db1232ddacc1ed17cf406fdbf5f47c71c749b69a317f262ed7d04993fdc2ec377a2e6d46dc654b22ab07751574c87beff292146a78925444e914a4bade31a9012424d78bd00fb7160a045cf7858c2c2d2c111a48f3c4b40d3e4ccb427602b382561d85cd6bcb575310ae441324d78081b110fd7cf5a990b9d24b29b34aee1f18d77c09cabce6c7e38391f2511dbb885508a96c4ae5843cf79634278cc30021e974ba1a1c77dbf412d46773d0313613a1dc7192d854fc2bad65837872b2220c985f22c832738aaa66200c92ad25d20206d21ebb87aec7261a21e498c3d2a4db268ba57271c1af0411eb77c1f1fbefb24493d447d8286527716263090ff316583a7cd28680c56d9e44c9226453d683156c7735c63c661c91cdec584fdf2baaeb087cbc7ed2407d75637714ec1f3d904071fb3b6de82e49e130660d7622250eda618352e450cdea540abcd6c7e36d3b9446e20c347376f4ec6318aca6a0b41fca0b47d1556180081e6ce3ddce8ec78fbc9af3fe07a7e610df32848104c6be7d4fab695e1f8fca5112f2c66fe75e075564f597ab12dd2061cef87cdfe212babe203c7efca0bb8058b808258cdafbe711d4e5ddf0911ef1bab5500742738fee517f27476ac9f4990cb5f4918dd425f18e0e641d95f258507f28afbf8bdcb4a341950b3259cb26bfd3672462af7d4bb1401fd5c52a2c3ef394d4dc406972e71fd976d69240406f2d6221ccdb89441405c261474f29c6ceb37daddf04e29a5952ec5f85ba597b64dbff32c66f2f392077935c25676e7eeedf76fd69364ca4b9d8e288f884397b6b45dc9f53327ec20ee73d90d78b101629f38d26105ad0f5d08efb3ad32c04fe855cfa715e591493a5f79ccaac715a25b256ab6319a9a5787c49566506d9c3bd888e6a5b266792bfad3fb98f69b0c57bfcf86b5e9ab7481375b24ed103be32d374d3cc0115b2a5a7d1417184fd3d67a474317e92dd254bf83c5755725c98f92d8a9d050e6894ab944aafba3d34c99f38ec8c6133d00ae2290db330dba5d07db54b104dd991864722572966ec06f11c6611a027e73edd3a4692b7fba8f489ae0ea391d032a4aac7214da448d5f8cfcf763259ad1120364e2dbe63b348c02bad42cf9e94048f69104698dd516896df55a5c03f9857f7df6e49e79f5cd02a6bbbceb26b7cda0fc1be6195d2b4da7abc935d0035367dc6be99f5d5f94cb34bf52f8bf98a72d5fee8ccb4f078b6809ee037a616e032a1c64078f4f88fb1adad4e2b2f82a5dbed907c98ffbfd3772e56fc9a372d1f3c25729129fbfaedec3b82a5bded8c3581888a056a45ac76e421a8c881cb4ed3534fc3a8e7365396aa760d817634d079b2f770cf9db672376a3be099b934f68ce756892f71259f996b268c16c3709790fafd59bf901f222cd75ea8e0a7dadea9243acf59fb771ed279f03d60e0d622f7d14761472a09649598550192a37f6ac5df7c5676752867655de0998248742c02adc638d9729aefffcb843d20244db931f5057fa165c848bb8299793f28f13a7ff10f9036d5931847319a5702cc34ff78f8b425b29a14ae1ba1f48287a8004a4d2a942e6d9a1b938b5756e110a96b87e9cd33915fa69bb92fdf05834364d01c7ca8bd003a63600b85c1f25dc84dd5d84f587611d4847042163902556f51c2b5fefc80575c9a3e5defd86bcd73a08a8f450c2bf1d1b00dcc45d0a30059b3e6b41ddcc56a3d992cef2122260c545e1d37869bc6162c235fa6dcbc6f253b8f28b12453a38feb98786508cef3e0ed112037ae8107b4a10c95b157aa7d702800aa42ee208ec27102e5c62556da8eb3c3ff7642173ce3695b4ea9dc59cacf6a561633e41073c1258e060813dc4f4bbbf3105428d11431a909695231411c3e90a2327fdf2eb647f4adfeabf7d3dd27e82833afc2e907513dbd12732aad57df5b3e10f681ff7d11aacf098a3406d7c5b091767dffd49d18b578d764ac1f6ebdd991004cd89add988ccee94478a8bc7e9e9a35c92b462b518d4885620ecfa90f07f5305874110646850d73041d178f23e89f43b0fadad46934cd49849b5878b11515062bebaee2e5151bebacf29c8f4e12d840d9a953cff85cb877af18bcbd2da5935bc3da66b1eeb9f52a7e222c3e60058d4f10df7bbcf9018ad43e1e81f393234e9adad6c20b37f31d91944def6f6bb0fba1ab582cdeaa1317f66f7b6932182ba4344c3dd27fc4bd1cb23a6a49dae2a42ae6c9150470061a4ee3cf7672680e4f43690fba8beebf07ab4e4e306595884a23b090a0c08595de55bf31d49eaa8d004a97328999daac553fa7a37599fc5dca8f91ba87a85062a229064396f03a4e3d648982c5404bd5e2290a07fd82f65956be9fdb78023825567a52187785a932a13c4afa2ce55f3a511feb84321567edd88c1118d9ef57e6f1699754d04089e5c4f1e46389e9e30c386449ca83dce6c2a55e37f8f2902e020d45116eb0305ba5a072e4995223768ad01f22eaa28443f79fa78e973c81df4dcb0684d4189796a7399fd5ce748d92ae0c49db1fec9a7841e354eeb5d7d29dedc072ead3fe061197bb06d53c2e3c1769ff46d86fa4a25ca91639938b89ee8f3ee22a3d779251d7bcab9248fcef58184366c943c172ab60089e7ff0983c7a8b5b4e22db5c7158a2d4a69b5f5191e97a9906000f60dea149b03289222ea3e2991f919e6e03c9974207a3c367f4ff5baaea1b12ceed014dbb51c083d5a15f0ad9bf3908bfca7eba5965a8a2a006bfcdf10c5ff3a17d771513c798f601fecd918867a364523870d1ceb0178b8935d2d74794c264f5d4933b113f1dd6a61c935929c2818493569bc7fd14aa99a93d207b75e1a53b06fc33f8f416bbb43b8b180ed79f20247fc413653eedd4b9572ff94f4275e2d9a486af48eaa2e33aa3749de06840655d4926c7769b3bb36bcb8a45c9901293e0ae2c8c47cfb5849642430f7eb9a7d6f77bc552b2e6539ebcba657bd682eea9ab1a5539ca6c2bff3544fb35667646bcc5dcb5b9e65db1a605e7ea5760cf264465aae73bcf372938e60b9512eabd79b04cd590659f7a735119aff42778d3d3c34d4d3a13dc14ea878599210f2e76bd7d9e8f03d8a29167c917ff8547d137ca87b894f9279e7098b8533c725ddc02f6b73142ee2b45899d2bc744fd73a2b7541d491cc11fdf01dfe614b61a0a5a562576546be4cb941c3bb3310824daf6c1600ff8cda25712b75cab87a7a2c1541e5be218cc349dc0ee2c1f951c3bc9040f54bcba39ace58f5390bae4161e5479716f9fcdbd74c818b8b167870f2edfaef7bd4e2909ac4c2acdfe5699dae9b2eeb14cffbc9428de57e9ce1556679de900ae495128725bb43b5fc907fc3a05192e9c3f9ffc22cf07fcf649aa28065a3596ff2879b7f3d16c09306d5bc78146729f979b460a4ef1dec1bbe66a9a17c283b8f7f84513a7b2670e04f13fa058db6d9b74bfad0e129e3d369a1fc21a3595eae2c09628e707dc106e2fc84f084f83f8fa0d9f5be75adb77a5fa97a8b6d8d9de7c025b3d72d5dc224c61c8d6fbf1dcc089b2f3dcc2b37ba3a08337969a48da1c76f79c2e553ff3240ebf804246c85b3818c0418c5a3c0a2ba54f5773393843c3b9f5e17b1f7aa43d7a66d8019c3a386742bb0cc0ce3b3aadf6e850df9b6a9f94056e9cdcd70cfdd4191428bdd1d7239069741778c607eaa95844ed0b807ac9a3af13c1e47240335eeb6a9fd52822f28f1c1e9d5154c504d5524dcc2048ff5cf244e8fdcc6c21c4497ca6f32014f0fa4f13dd40668881db0468c467c6d029fa50000eb478a42762c1332bc3503dad3bf2d47b83da9ccc3744ad62348e71bad4b944805395c66f1a25c997528e1d081a8d729b4cd26ed007f301c46aeea8881d6f47d51855bff1c8cf6ceab44529aee3e231b1c03022ec5a8fc8dc13bf479ec1bfcfbb68835c7a704a6923720fdc73c93bacb51bd151119ba66b357aa4ce421fd85989954dac79692b91c262302b9812e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
