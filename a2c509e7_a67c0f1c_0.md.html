<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22720424345337beac956010ed6e5f877ded3546792d7a522fd1f1da36b91b8278dccb8256e0f0d4538f7f03f1c5005710cfafc3c2bad42b86d126745483ffe14a4ee6e676e3b0fe6fd1e382eae50e0e19f879de21e4cf2b0223a58b91437b5d4b370717acb650aa6dd6cc5d6d9be3ba1c15030e1d6a62b0b5897641ad1500b0e1f255d27911401c70a5f0e7c16a8709b2d8cec1be03139f236e14b55a086eae1b591712882d45a091b6f4363390dc666edb56694049f403617d5aee1ec7c4141591dffc67c13241065575eb97b0f4894b6547a71b2d9231d8a623f941295fbb32061bf092fe9b772b170a4f30a20b18155c88203f07d54afa90dbd06ce1bde07256cd1aafcea78def5a8553e2c8d7f56d87ce888741ba00934745fd8c86e9b0a2365a2e33dff9395d9e7ad0b70d149ad71b5ef083858842ec72968c1d5dc67018802996db06a48c4c110438e098f36b5941d9cb742adae19c51a07f3b5e6e84876a42df5ecba275b8b695ffb7ec5e737a6ec6084e11b24fb4de1472279aad7c95aea26a8f308e9a4dfe1369aa25182b7bb84696c6c1b285a8771899ef49c6b88755fccf03d6d33c44de3189d5e82eda1748abab3b8567eb3a099c973b2316da2a6e0b1364d8989625f00cd32aa9bdac244052254309db3b7ea1f282f67f0cce9086c88397d372ff3b881a127875cd0f6bc01dc03f5f0e306a4b5d0150e917e6fc65d3e800a93b6376f0891ab717d170f4d693a166830720b693de6bffe5bde78d5e6bbbea5aeeb66f8029b4d6e6aea93ef01f66cf736122bac64aaa56b65aac481b39fa0f45258a05f3a5dac9358665aa7ce6e526999cdc6090b5b759de925ce722609df63d1967426e7a673ba380eda8a0c9406876bdb6e84fc0e00531d3b479cee61e3a8cb90db4dc7b85014be8b1eb10ac155a3f14958ebb719e08397eb7ad421b9fd5b2757e2c7b938f045cdaa54a86645edc4aa3b1289da2c2d468c44da91f08708e42da221a022a877c91d7e2b7e6f5ca0aef051f52aa0b9783dc418553ff2409d035bd8db273fd8ea477c0543139315b659815bc26c88cb26d7d12d4958cf22917ab0c794a57c308b54d8cab0189d45b95f66a1fcfeaba61a545bb5d6f64d7fdd44bd04af7ddd8f01bf27e09cdef8aae0d083c648aab08179f4d474ce5a535fdeb9fafba58edc0f68cd2df29f7bc1bb66b4375a09e121c7b407c9f06123999d35ca1a8b8a657aa6d4f29886a62efc6632ad708a2bbabffd5b2a7838037e93bdf9768ef45baca945ecd1adce875f4ddcef21b1f17034ddf0bf2cd11fdb3aab173e3d201e65e8475f36bdce0181747dbea68c77ac6f0fe628efdb66e535cf03a8a1a43d35fe3bcb45686a349d2e403212b21c3ae02d2bc06203f7aea9e8ac7c2f8bc6af3d32fc49bf376dddda9404b69e3371f97e2358c0a54fb771151d4c3bc4e0a5d34fc53c05c7a2afecd1235632e624a933f940fdd5f38268d7160b47207dc55e9e45a2f7e522834c3d53df7df2e2958a4e941af87527fd6a4e9779787d9e1459edc2b5ee0af6830a64eae56baf0c38a75201f99c3feb1677f08e0f1ad37c5be6a4d45ca36d50b1355d0e5cbcdc79dbe0e6d4ed13457315f11c141a08e66cc5ce1360003944d9a388d399eb6b209ae0f50f6b7a7450cdc6d3fc4a446ff9d01dc893a91c336d1244b17695d5d2b2964f1991d7e2a9be52a8181b01f3830f28a89c2b9309672558d58d72001734e949b55df5e13580fc3acc1d922e72d13802d42faf020409c8f17c114a0d889ed6b80f5863e4d8ec3d281e3cdd9d61dc9cea40cb5be185c78f10cabd79bff82fb518a38bcbe8e67368dc8dee4b1360d8e62fe1beabdba0a0a2b730d91443b7479ad13acaa136354b6547e4d0a4e0e3617c02218e10eccf31df2652b75a277438ab63dc45d0effebd486aaf8d91f53eb339b6f88066b83fec6eeb66d5ea1784f0f21bfd0ad244ec5df2a45d45d571c3f0559b89747d689270ac42345eef0ee578d0b1138b83ac778efdc032c88131754e836b9b64f6b742d8c29c276461fbdf4c048095e6ae2ba69cf91b914c59ae5ca9c675962cc82a4e73c9f8ce36dd17d4bfbf9e8d1b97735f2db982578b197414432b4ed72c8453e73c62cb43e0524b7ec36662154c518465216c90409c06696076390b116221cfb3ac58a2a99480779f1fcd1664de7bcf50ac89bd29cd354489695bcaf01bb78e7db9916121cdb02b313be777d0bce653e109df885f34380038f9136305cb18269396a1b9e29107807de1565e6d1809189f56af9f0fa98d41a174dd3416ecde4aa758fe37c9a0b605346c367c55699919679d894203429f27d2c2472c04ac00d877654a8cd775a2a4fb85af9d83d087e872464d1382a241c1e74237b8fe4cfd032709088106eb97e68127472cfa594b2a3cbb7219154c724faa51bd9a5fdbbef7db106da33b7cfddecca0ec3144bf5340cd7d733f68fc5054e4354d4aa8d5466cb50725f63115729d75fa538c1c06f7d6e15a15e6f38ce1b248dadd8fc19babfb585136cdc20f4bb77d0e55b39033e4e95fc1a6bca063f821b3909efd74dd404a1a8ab67f5e126fcfe40dc12778ec2086bf9e32ec6e91242e7de8d94b8d321e8175d653fbb043500b7ddc247e728952fd3b8e95e433af07075a445b268d04616f26288cfa2bb1f58dc2be39a7549f00c4bb93128ab9d64b6e1a53d6d953eafbafc29880d5b5c8e238a5ea2ab9c2422123dd0838abff2876236b93a07c50436d2dd4188e1da5a007d519f41405b312c39280ea13e4f6a65ef603e510f647614190ea76e68f00885b5d5d165ee26b8b8a30106aee2e5ce7585a64ad2e5744ff345e50feabc078709405e3721f41e542d826f660a5f51936e39405236bf02de48b184722bdc12eaadd64f2fdce69940e9fe743993b457c312e5ed7acc5ebbdf488a9a8520900569018777cbae9115c39342f4a387989898828dae9552279171a97bd60858c4b473c4d7a315f6bd9ebf1ec32744476516286e7d2044b94e44074d4c1e8779c1fe5cc306be910c4c60b4ddb7264150f0c63e421764e4bb87fb6f79f1fd8fdfa77ec90b6676c1dc88a200a4919955ac40d3e071bae25cbbc30e49f592a4f257340f5dffad10aac375126f783eeb0026219312a2b615665e8a8950d1cae4c7f7a19e94ae4ce94b9578efaba8a2e4dc651871eee8ef8ef49372e6cbacdaa1c0c48eb600291d736c56860d3dd373fa3ed8fb1a42626144a165912f4edda5424acb60ce6371b4b852a4befc919902c1dd0aeec6f14cb050df4f8fefc81b72cc4c4ff36c611c07229565464856a864a16fdf49f84bfd107137ff233b8694d15b3e97f93550dce5dd715594c3b60e1bf719ee46e35de06636b45857fdae8cb302548139a5f3ae6f82036c21b56807386c674867f69471babd684fe609a85d6a106e98b65874d5791e064275c4ff756d49df1d4940566b8e7355e78cc4bcf0f63492868a1b20aa4fceacf7d0948a1e2342597110e7e3c2c978a129443b1f8adc31e78cfe93ed30e4177c7d1df60ce850ba2cae799073c651744c58e59ad526c44af5c8caa00b705e21c61b6e5670598eea7f799794a7d1730e0431b9ab465a27620418b9e5f8c57a7254dc70331f854a8c794a9b8fa0171da3abd4473e7e705df02c800caf88628e452c21879b8f62763ca8017258a275ba9df25c9c3d3e4c5b81490c63d501f0e71ad36492e406297e6be7577b298b90fbb90864d302f321671733d85c8d8142acbe54e584f198ca54ae2d3f72f20a0eddbfe92dd7d8f6ee880d58b58cd3ee6575ba78f30dce10c1c53b830cc8b118da4b5a4a4d4f330dfdbea6dd128dc03104f0fac6e44a004412ad0edb9ca0ed89d4ca4a0091fe26f322a2a6eaaeb02bbb253830d65448cb25cfc1814665a0b67d13ba65b0e5f9fb3645785c132382c704d055396e49458d58ee27f472914df1b14c45fc6f1cc4679d8bd286110bc4ae6c681bf502c9a690b88bdd40db3f988afed789d492fe0079c755efc222d8d784bbdf0b1f249aec7de970272836ed28aaac8b85f25824400608d67c0481413fb144b72eb1a88e8370aac9ea0041516a86e9d104a0768318348e6fab9afa4fe45fa7c7a9099651518063ad58ba000600af3d281b0347226bd29e88f7c5faf26f25a07b055e71b2b43efb0334e0fee03c020a4a8a4ef3073b61eaa7bbf5e6e87e860f9ac7ff0d12f1f203470639c0ccee2dbb0f83445b20947d97dca273028d67386f37cc57b49e8f84dc965377cdcfcec2cce06f052992224ff1cd0545c67d0ed992d5b9704ec9d532d61b691a66e614b24c889bf3efcc27e06f73d8f1d8c0422e165f874aceca1784eb025f032918adfb8876f456012a78945b8da346301a2759d077521d0901f5765849a1b589ac4ce6c33e4669610ec2821e3d54c15c3d9bcfc845119b82f24dd6d9a9e8ba407ec84f612a33c28fbbb21009d32114871207ea9087a4a842c53f8f88a171f2688d3c9af62a30c918b8caf5b09e180e8a61e3fa1a435f4c83ee121346db282d8fa542afe9942f03e2f7181f80697126c821b7324ef00357856683909a22a8a125c574813c9e6f7c93cabe45a75b66ec69296c034503795618ee08014af99078c2f338d789589abc5ce6a9b93b971507abeb130fd5d59d59bd6297f85c9db7e90302b9776ef8979b250ac6e7bdff5796d6d41e8a00c8cb6f9290340a097106709927ba42c8c0e66a3fe8962d4ac4596ac6692a8a093ea8ff363bb25844a1ef6a7674b46ee9447274e9f957f7f3f9dc393fb9fc8414fc1e6494012f0861bb0acc3e74f6e8f8ab3828c86edfee1dfa73af1ccaef85cdc72716e8c15914021a27e1d7213afa8c6445b27b2d2752d94595276c6f82277603a84dab324807177f4f6b17803869b708a20549ad127cb50ed017733b2e5dd963d80deef94edc08f504ef499bdaea2c17d2fbfcea34132af21cbc68edcab7d6e84e448b6bbcd2e6d2f6db2a075362f3c2494738252effa9a3960dff920d8d1136957d7a987c9d9d2dfbbd4df99361230251b408532472123e1b5e31f94ec2a39cf68c26ef84df443adea8064ce550ba88eb283e00f9b4b5ca4d7428a8bd114bf0c78c704e0e1f9daa099619bf6ca56e03539fda4a30d0d073673cfc6b2ba4dc1fd9cbaf320f610d4552ee50cc018bf2331c6fa66505f49a6c9e1be600e6616d637e244d392b11cf3348a82c97b0ac1a8a7dc4a20d036922a7130f3685d26ec87ba88d51f7d8201b75a7473faabbfe2aef436cd0a1ec1a5c5da859d1e4324dc9a77e5e0d8f717eb48b5a3f42f529f454d2899808b36926c949afdde11f1afba43e9778a56c50a65363ab0309bd2e6585f12419152777bfbdbf2fb148a2d3002ca8f7ec81004dfa41bee70ee40e4c8c431992870c61765dc65d4a060f3eb97c71c211c0ca0fefed46ecd6c838c833af0d2f410cd3759ceda90d6a3d97c4d54804dac366ba04405c722065fbcf80229ebdcd36ec5385d7f2ef62bf131b3307ff77dfc185b4b1941ab29d0b27b80b949929a439143f8ca8c14bc14198450fde7ce80c6072c2c931131bfcb22411b405081ab18eeb9ae6294443bd7710a88359a6694446a39b82e3bec238743388ceb84ffd92019ac5dc4d434cbb03448f7aff87a18b0ecd90b95daa85fc1a186549f063c380a4864c6d8a03ca806c54fb354b7f646664c8c4dc2ea2bc37d3fcfdff96f1d01b1e6cb511fd659b4bf013059a40056ebf199be44e4c77047165f2748a587efb75687603a91d83ae01aa79779808b41de9db9f43c9add44fbc780ee1433adb3e2bec8bd420ba1b27f38bef6b759faa4360e26c03354bbe1e4db5ac269e5c3f10816ee6ad8e7b84765a4d8097b52dccdb0e55e383aa7a470ae8717c1fc4a0928baaa8bd42735659becfc204df61f69b513bfb7fc4628ce709619e667a0884d69870deb654e6addce88bebc5dcc788813cc1725a1ce361ae231dd8ac7a63fd05c1234e7450ccd99522c03a3ce6be00cfcd86bdce11da950b7821dab4e823ab134107af4f8143d1df6354e60b6398c087c342dad04f13a7c1f31a8876701e54c795a95570251d09d52a5aa9ee70a97d9ba40b198239f74451be2ba6439120997447a420818eec65297e678d398b8c0d540126ca0920112c04a5941e3352c15414afdaffdd93324f1006607d211b887b46cb260d95c847950533a2486c96c6b027fd339d4a80d32c3f4d9d74b0fc4b047cd6324717da8e2e4d3be292e66b95fff0b3294bc5888bfae333e1a7fb2ea3e85d90ff1cb42b2f3e45409c6d7c6f65235497c8e76bcee36e6568fe0a454852f8767efa288c425934cba1da7ddf946bc29f12a3576b528d7f87683baec6c34ddb597b517e1f9d947d71a0f438d3f2fe5c05e8855b09a3249d604bc4485436edced8f3cca56d0322e17d00580ceb2cb5bc3f4b34a276c2c7be3b6cfe75407aafef01869c7fa8e3c1b9ca4df050782893e1e240d781021d1077c220690db37fac39c0d4225a5d9449027d406c81d4c2565b83cc7d65d5060f9c0d2e7672e7a3dfdddf35015b24c832a110fcba49dbce8b3dff8fc5cd72f19014c4636920ab1289de159862c44d0be1211d35138649249dbbd288a43efb7213d39325402230f3c760544f71b6c3e5a2a7529b3e537cea8ce03bac3de23a7de4796054128780791e38db6941c6d45284e27cf890aa0ad382121440a0013151e97e49c1a8422f12af09c26f1bcd7d003aacfb0f578ba3ca42daedcb7840510bfe007445ae3ce764da0fd23a38256e097f5ab78639134d706ac88449eefeacdc253d2f3fb1ab04eb1def07416c8c7a39a4ba0d7d0e199d7052582b30bcbffbb4b6bafb80e95992bdaeebea70847f767459393a44a3a6e20cb2cc8eec7d364633c02a9f7842cd08ac53604f717c379055e79e17251027bc3d81175eed869dd4ccf573dfe7236436e74501d49f4860f402ccf4ab7c7c40685dc5a3cc0b0bc8368b3f1d65789480c931c145bd119a8a5d73b65ee445b42c2f5b892c690da3b9f6e91f4b83221b0220ec8637febd6137cc8a1353b12740b9b62c21a0fd4336647d2353c7490120054dd1161e6aa78e549f1cd05be9f18219aa4f5f13e544cb9ee6f2720eb91639fe6665c981d5a6974b3bef633bc468404156572a78691b6818bff7569df17e61dc56b1ecfe1d8e4b399404fb2d21ac0d64442b6898479250f1b0d66cd401575c601f491faf68b16c567490ccf80eb49cddc90cda6d06a49e766c1acb77662600fae3a88bce6db90ced95972187555b45a1be6002c0bcc9dbce41f1c1754f5679d1f4ee5db9c279344ea80489e0f6b610a95df17b8888464ebd10819a7f9df042cfbbe0270af3c9ac2206840be3f72392269ba3bb0985055141dad7b86564c40001f8b80fbceb20127fc6050f39bdacfb4d689757393a1c9234a502ac700a3789f1d152fe95f2144aed1d0ca29492bbefd71bf362048c0bc928dd31b9d60817d06113d3c3d34c867ce8d0e07a28b2523a6f0beb60d446f006e065d88f52dfe4105b6311c997bb835e5cf6970287386a1d43b97821ccd6dd1908d586f7ae64f948d0cf5ba11c43c0b1b013c84ae8905942a2a810e32278a857a207ad7d9cda27fe8cba2e040d03ac13d27d102ab32a271181f291755041ece5f44491a3289a09c5ca29998f74c67b4222c34159e6847dba5a32ccb3712ceca87440cac487d7f44d1ba5b8db6cad0ef5ea1148abb927f9511d06659dc37c48a4b48ef707e12d409ea7ce58490dcd2922cf0f78fa6e35b7a3fdd6a6e789dd2e4d9601786129c73c9087780f4e1be41c9fb9cb635d07b18bc7ff34fa7eca6586104c6470784d0703ab6a123aa5f28aad174cc4e5d898cd1ed310fa7cf7b56532361b73158c6545f52b26b99acffd417df3476fa7e0401a29642b978421c08f460f4087d93d1987b889220f97bad1715a4ca8877f8fc83ee7106aa0b751d858712eb72fac8b86a2bcbfc30083622d7fe2291ab32a17cee979696d0dcaa0ae3a9a995b149327dfccf16b1124c6e4c1e12f7781d431691c91d930a2aea1142ea3b477ebec7046d237bc32591c48083283d4a1a0546726ba39814a22dff6e6be63129ea62ae4630eff651f80af83d477b5a35585bce5337c09875fec075f8dad6a74be87a1d2909ddf2d9cebaf9dadfbea0782a55fb38d9cdd2cf7495a14b9f8ca5a7c635c6eddda8e40647e64a14272557bdc71ca57c26363730f943c9699d3ac0d0653e0b56420d3e74a9f0045a9fa064ad65d8a632ff8c16304408e6bd21a07019dfd77f9ffa69d468be1f9adfa9d87ea5e2dc0f3d30a77bcc61dea3ba054d8d88dea91237dee0575343a31969d17f8ca14d2343745a8a84b1e3731617c62eb80b9b665117948f79e2fda07c268cb2aa4d8e934020380e7fc8b6b343082a04b1fd4c79cff66679999d53b28694989d018834d2a8ea2e790850ee50ecd45f2ce68144a150a364c5c055f228dff292de575471ecbb17d2269f29a7a00e215187765270d13a295e085447ef0fdc85c685403cc734ed7a30956977315c95ecbe3fdcb527ac1fdd0c0e8c04fd2b273a3951189d78ccc36349a1b0ac0b325a97d5aa29665cfac9ec9a8f1646556114684dfee800a3af43214747ca53e8d3643e14de8936f156070e2b92cf0ff202b664255811d99a8572df833370eaf9be1a87e661eaa464adbf4160e0f2a54fc2bf3127283112ce28c30264ec814fc4e6d3e647cecb2678f5a03c7ea222b5d9de121c0c6bba33efc969bb295dba36547cabab01599973e390e235bdb5730783b906b632cd926272533a7d1555f73c435af9643d28d43b3458e764b2e43a5db8a2ce911e4a45dd9ddca61f3a393ab67a96e6c68f5eaa9fba4cf8fcd0f62b2a56c60564bf88cb9af4655794f3d326b05d732dabbfbad6b6a7c10dbaf49a2e7394a5611bfee455cc855a240a41f18faca0af4622c32bc2dbfad92eca778804ab8194a9dfe95f8b075ffdb5b29e15783359d2d3fbb7831d9d440d024c01c4148b3ba1f053b31c83e90da4bc93c441f84eff056e9315f1ae31c5cb43aae014a5c2a52b334a99524f6262415f7925f771127866f08a0ebe92badfbe15db880038d7d72f06c7ab59ebb66b91488b18fa074d7ed5fdbf5ff59781e6f447418ebc0a2236de1828f7c501a0ae2af202d5647561fe6c73a183e220104a88ed1f4878ec8dee572cf3c59b6b70ee69d28813b5ccdff9666acea7afbb621c0a512d9a77a56e67eb8b5919fb8a66e9dece565f31b83f96f3a0c92e6c644974f866cdaffe7e9122f07046bdb4e606eae608debafd214ad7757a0add5e1c126d8386aa5f0fcaf647ecc3c17917705b6c51403a0c54b80f6a1e879c5c2bf5ef534e536c86a510a333eab2ecfb75e2f7565c0370808ec8b50b553718b4416a277462a97f6f1188abb04dc3597e1ecfb5d30a3786adc003aff36773dab41044654b3cabf1bed0e535430286e7e385d0a96bdf30694a212b0d4cf30d2ada796dfb47c6b1cd1318361b0d22048262a359ea66d4f69fe1f15527f325ce85da155f43a5072281dabf2202b840b9c48ac6606c06bde","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
