<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab6f4af685698c6023e319c80e22634d2c478726d2050ea0378836f5457a03405ad6b5f85a0a7c6afab01a1c926dd7771811a19407e4c239ce00e6148df65f9d11d15abd0b08ff8e457f38751619a66508c87f0f3ad356aa73eec5fcddeb3529a0738cf8f9ae0c65f8170e651d2e8c5715f7c8f461a3429a6acec72a7dde3d84e02611d8ba4e94acc8ff64d9b1e45f8fb1bec233389dd5860bba9a18e852a86387bfc5bd371b35904910b77cec326f15d4f39330b055f8c4e4bba22dd0b8181147248c392a09e84fedcbeeb4838d83566cb5d1c467eb6d4b353f5effeda2302f43e2b97b16ffcbb49018f695f58783c15510c3da3a891ba413ae8d71d2a1180a5f4fb3f1c75fc4542a22a83f8d8ffed0bc968258d9ee448d3a09d373007df1edcf8f0805a6b88ee61c2b179195cf3e7b3c1b3d8510f5333ad86b796b78629f5fe1fc686d2eb46f4ccebe34f5befa4ae5cdab6cef7c18a83254e25325263512830c2b92517f1db9ad285080b853342e3b3be09506c2a262f2ede3df7ab233b61b15b67eeb04dc291326b377172c8db779780fa3078077eaf9f77dd418b0f65df2b21fb1bedb301386bcd3b3bf765a76b029005b8b1c99fdf562c57bb6ba1b94a0eea3b91b64ccece2fde2c4f3ad237d57abf37449c0b2efb3aa1f1ef60773fcaecf453032e12c31f464f0955e6c33c1f8ab841b98fac171bc29b698583426d319e90a3fcdb2fecc2debdfdaa814841b0f5bf1d6ba4a5fa5b653e64c1b2dc9a55bc473914bd9574be1bd29d8237b1f01cb8765c5cf2cf6d7b68541f6b9a840eb49d79bee583450ce13054adfffa453bf5ed1006017f87515aec7f7ae180dc49c69af0f49232aeb43d64c73072fa3222b7d82dbffd263e760e4e1acc70e069e8d5d7603401a3ad8a7e2c3d449c4eccc55b16f5f8143fa805cf142ea98e25116b26fa654bdd0fb6c686180a132620d1124138ff21c8b73988866e23d20919407684d08bf7375b81f35fa6be27b8074b6f1521176d2c7573541f2b175dacf0defb28f39d4f997fe177c2e4bf5ada5aefbc878331340bc36d9a65f44553664fdf2db78e63af8d1ee06fc09ca65808654a5bd022c1603dfa5e2450851d8c10b8d90a7137a82b69a99bc5327719c8a52d3a7f471ff8195b784743ea7ae0b387c90fc923d5d5da1719e2dc9c59f509d3c5a0e0ebaba87eb3ac0d425f95c01e5f16257ca2d99b7053b1e6285a5ceb1fb47df57fca931445d6ab4ef1099ee88edc51cb1a8560be70e27c5b4cb25856f576eb9f41e18a5a4c49c7cb15c8fdd84e650156b441b94563b627de9e4acbeecd0126fa270af5d075c8c636d1b93983143398f867bccb992ee4d0ed1bc70aa12d599ff25d4b7b5847ac3b423f5acae3f9ba89b42320c43b26e9f78c7b9cd3915ddef74fad1ebb5859fe71cdeaa18fea60477c7d7855573b62538060940a3bbd431e7d16360105aa33b019fed53cc1d23986d9acafffb62b469688941e6b13106e6b3cefc4aef3dd29daa390e0f51891c2120fac41d02be689e442d49d810bb0faf2c387971ccae6db2a11196a0c256c3659342aa6ee7f6e47572d124ec464eb4f73b96b615470b62e8064dfe330739809338124ab5d28534324c96ac56b275e52fc966b85c80e62acec98b1584354c8e3f1d01a987c1b9b0d03854ab57cb03f710c09211a241f33238fa44de559828662e4ebd8e1768fe27d9c7da7a8bb4c54dbc86b3d2eebe0ed5440287feaf87ad8b108c4da3b484946ee320a57599774d10848e3d040a6c6a206f89e83669e3ea297bfbc0e3c5b9eabc162be836119d750bb790547e82e9495c5b4c3742ccf5c88fa483fe0c1b8b1c663bb73aeafa214a4c4091b0394fbfd1fbaf64a14224428badcb7e076e9100766275a02071d09af08db52659c3047ca9ac60429071d668f094fd06733ca228b173bb82e056403f993c79118c2469e0f13f4a24f216c939955955dbb74f58df4176cdca7a5be66f7a75b325905d6adcd79a62dc261bfc1e82d62e3dc3c47d5642fb9565a21beeee3fb9f9d099b816f6bc50c895f5e05c4950c78782e06a2852353917304a4a7e2c3124f6ab932ba507736aca41b08d5ba31d7e804fd9ff8cdc44f3545be6d8ef83fa1a6d50635bbebb6eee7888072e1fb26f1eb7682475f1e30a16f0efa102260fe11c370226d06e4c2a1feb0b77f20e62f9eda012900c29a553e1bfa814b7598cf1f3ac7c4b74cc1c8d71858681b73215870563f66c9d8f8bfd813efa1ee81efd9c93255767164c6148d5c85f4f770ad9a593fec9295ded8be7b5ff2b755fad8551a3dc5a7877d24b90f464e3ed42061bfd7736ef5d6a2314050004c52455408efdda37b5f2c0042e7f1564eef641a81e932b89ddcb99a23710ee1b188a2e9218da539818e2f459dcfa97052df8b4189f00bcb85c0e8bb6605595bd5a801cc8641a64b16810b1cdf2168af9952522d96af1e20f27e4f6e0649172fddf444dadee7351df781b613b0d9bc3c86d6b831f0e80fd92cf1add4319410c02a25e669afa25e19da82936d88c3e9ce5fb60c8bb7e98d3debe7b7d108c7d80733961a41c62619c17e966b0f6126655447d9559535713b12a0fcc980152d6f3b3798dc99a5d36893849133b599527238cdf61637cc891d0161d3dd3258f0cf3c5bb884f97ae60f5c2b5869752d8f38a26baba032d741f247dab22b39688315682a6d73c59b06d9996ecd47a4369beae7ac2cc4fd458ceea70a6f4a317412f03d254bb8aaf0fec38403ea56334fb8e642c8431157810ffe93dd6b3065f21199908ca134f4ad5d1dfa7ec745918be8bf8ff3f859e28b023832932d93dd928cdfadabb23db70ce88a3ab8ab50e93851182f2afc1de74760bfdedeb38bb450252df09892b7404bd1e939e9673a5541b615003491a8a2b74536f6bb1d1a463101a980b2721045e1b560c7d751b1149ad1de675a22694d2809159ce190c5abad4f331124b331bb80f9678d1e0706c5a75c7e09b309a566a739877a1609a5bba83ca40631a5f2e0f63bab711b5642e04a07a133b555f2b288a2a2adc407053da4d33cf699efd1d7bb07c6cbd85d1987cdbfa3dbc2c0d08444e429dad8b4da633fa32235878598b22537be72e18599e7afb255ce8060072a453962a34c8e1514c8399181f4b34ed89e5043ff0db1d02c2ca39f92f929b59e88225541797ff22f70e930d23498ee4e2f409b54c6412119e7cbec2d82c80dab5b551caab4f1bb5376f07f0857813ec9c1db8a533fe55e9b08ade6505e413f10ef18b779a548457b338107d420581091193d3e8ad5cc0088cf68919e242659cabae093ae3323d56e648d60e8f924ff8e7f16b1b61cf4875f2802facd3d301b52486da729fe096492198ed5d4295d626aaf4c03d6a4bd151ab51332e5b1a9c29d47f3ec976653a51fe55a379e2f61ca6350f053dfc32e6ed1effd753c0f895e381a645acc13b41c8419c07f4fb055286d4932e65948de2f7b1a01315fd9e1b2348e56b9503f2b35e8d3bb82fdac9f549a02367aa99b51113a8e946cbb6d64ed50852e5da064a92cb9321fa6cc6ee07644b0c3a3965d323fc7a3ab88cce7a41535bedcc20e71aded428ddc4d0268a1c5dfc9054723ddba4c65fef8d8dda3cf8af32a356c4e403134d4960039d7fae94fb5f13f131d6596eeb7ed05df545cc07645d35769aebc7e17b12b15cec57f3192e0d41a891699dfbc369814ad0504265951923a9c09a65f4fd5c4b058636fe69f2e2a77450c141bf3a8f3b6f51d2df643027be63bd29bffe4042f339e77fcfd674c064bd03fb112b8037416b644acd6bd48c4965d4eb09efbed7a1d6e46cef6493d73bfaafcc717003443be6316b5c54ddd8ae0a8f5c90feeaad05209ae79e137f6b16dd4aa0f5b24a85c10e1d6d15b2339b4cd0871daf26e762ffc86d2e546ff7196df829f87677b9390dd1120dd9ae9a936b93ae03e63d8ffcff8e35e40650f182fba3b32b4aa347e92441d38ee93634d864e7ad546ecdac646565002389acf51827194b4b6dc31d70ab3c7d88c7469ddfd4e42471fb37ae00492a4552b9d0ca3614863aab5dba08e9b1ec114713d8987ee11a3606b75b1ef7731886d2a661f7aa3a603bc729cd0917922e194912556c4f2a7dfd924956355c5edfbc3ac4fb0db0a09b393011dc87a1f23effd260ebbc29d1ea106e2af684721c4504afd0200972f63dd333bf4733ab19f618bccc5aa6c764f0e7af711c919eb5940dbf78b987dc0ca47071a0393de4b15395e952f04b61aedc92b2418f6f31304c21a4e72d1baa8ca486ca2390f793a811952ba7bad426c90c62999f50df4d637fb226636d873976388c9711a0e9d1eae2215982f4fb72a9c9c2139dc81bde1fcdd61b7a06540e094dd84b6c18995e281d7541635a88ffb1d93f6ef80a2ab630d1a94724370bc98ffc14589811ff95bfb702671c7fa1c7594029ab5a325db8d882999d416184656e4e96df68618979f247a903d9a58c0e4303f1330cbe5c9a15cbc9310a82c1dc85ccd0b1c15d91e1080647ffe1f13d2cf5aba946ed7ad4e68aaf329fdd84abe940385f1f8afe0e8c2fc5f611eecc6b507b8c7089db9eab0f5ce7b8b56106ce813b4e567a23c4beee9bf2b1224a6a82980840417fb445fdec40ac5477a1b4045a54304933e9c0cb317989fda96ff59e13075d0617af6d5af707d78ba3a4de5bac75b2ecfc69d2d1788219f91195fcc43150f0bb9c5f3730663aad2e1fdfca64ad278e5d8fbedc0dbbeb747e542dd3f2977d2ec09e00c65527adc9cb54d11cbc5cccd8fa7a2722994faf0c4ee4d7586dc5d86d4850506a0f835db273ee835c7a954e9f303845b114226a58725c5424b55536ba1939cc557adba4f720ca324578c212e404adf0d020bff835e8a2573877c8e15133a5155b93a3ba4e89863dc9ecd16fbcc5a83e61bab9faab52944f6e27edfd6afe9e5395b284e0fbc3337f5e83e9566e7872261eee87530f588464a5412601ff1c757935461ec122ce22cd2ff6f7efd764f1a7f105b14d7389cebd3d1083d27354cfcd23cadce8d4c1405df38ac01bf68889d53137d78325a70d1df524d65616ea178201ca975465fead1da0d2e636b6a6f5d6c914e8e61479c60749eebb8935575f79ca04ea4c48e149d8cfab7430da634dd85f149fac176a4f84f88a85505de0493491ffed7265d0cc4eb6a22f37916ed9a90ce3a7b0471f9709950f91e5859096c1c4677eeed69b4e78950bf44e38ba321253f355ac395b6b937ccbb65ecfba0b323506f9d5427341c5582c08761bc573c70e1562a9abe9acc94d11e4da4f8c5df5b171efdd0f220064a009b745dc13be1d82caa154fa493a689602a93360ad73d33f2ae22b4c65660a6ab385a5278f983c3c07e8c0ed130fc18d8a4374d22410b7bc27d972e43376a7ff789f91973070b714e0728445c716c1b843c3a7f624ccbb2fd7e92b72d768ba5d958327cdab1906ab3c5a33c731eca95d202f6c0888a53885a3b38d64a4c5dba614d45cea3d62c2e2505e114a744ea377e9416b04941cf085917d55ceff72e6cea39748d3400bb37bd47190171650369efb24340ec52f325e0a994ad7bc5b18dbe0e0e8111c0d2a73071932afaa03f650a7df456b88e0c74b9022e061233d5ca4106c9fb4b473dc2e3617523035de999cad5bdff76d626ad9abbb17ceb5a1f3c7aef922d59ea056c04ad472757d7996c33fb0eb75066548bd0b3b2e3f443ae85d520a12ca3c8cd869d16dcedb49384836173a9e0379513140a4b7c10ad85ecff2bace3c73d28a1d749038e567833a932a5d70b620f950790604f7438c7c9d95bbc8384e460e338a25fc030357559168a4c3d30161ceb662e02ac80324e7b910e2f0470acdd20358a1c6d84e980543feacb8fa52b1affd8ae68b4e8450c8fa182979646fd41aec6cc4a90996d57e88a5ed1b49dcab504de98884bb1d949debd2cb2328356d646e4ec5292101026da2fcb19f62000b352cac04bdd71e646285a839c1b220cb31a63e63cf04aabe9001fbaf970e0785e461e1e0fa8785c1f92e60f1820575cfe7c6a8f7bc2a0b08c641cf810d41aa8ee9c40a7ca9bdab2d4c4424af2e82480b00f4a57d13a00baf8fa89e323de3187d7aeee2a54bd9897563597982ae207eacb568815866dd83ffcc9fe5bb82f4d7554748a57340bedb03d6c8945387a05137b2ce3db1ad562eb8bc917e4b6128affffbf584eacd8194228b11744dbcee54254824f304272223ea01c2b0512e1aba2a23df6638cbf58be913433780641840b7e59ce9830c2c6d5055053ff01e2d5e5afde3d09455acf421189439666b99c004a20d041e94b0174b88157f878f0bd170c472acce4cbe402fc5e945133fdaba9bdc1ce7b95f92e9f242a32298268e1cc5adc0f9ec7a9c442da9e570e11ce0da995b87951b08e6ffbb97d3bc7e1959e7bb49803784c5e79cbc04b5456ed363e519e32f18831c01a365c0b1bf4c152baf231d71eb98672f3c6f3a03a26e3ed037f233b24d4d4b071317ed7c09069a2db319ae33536960aa990165e6fb53a29049ca0bd6a43336f8ae89dd7d536aad04a1c516ae53068508e35cf49a36a6677e71affab359e8947cdede278dae38b198af1682274cd4442a4f3c1b0747be64e1e2c4acc281afadec8cedf4bceeeff0aa98b12dfae68e4c3e88cf13a73a4e75e808e7d01bed07b66d330c9902e435394f2c7a9605119a7dd54184b972bd8a6c11e1abd12fc8417d4248a44bea1bbe85543f1973e14c326d7c7f5611cf719b196ab6e684888abb481e6e05ee4db60ab2eb7eb1fa0a57f4caf38dd09b498867896ef0c0fd7d38cea99c07db19ff3b7303944d841a22620968ba7312a2e80d1c021884a235c7d2948ad37320117603f8aef282edcec17940a58cc08f81896af5c022201f72d40ee66b0ce74da87964b80363a430c9691b6d496c6f0fa90b0a1143cd83c50f168d712b60e00e2ca8bd55040b6c332dc40299b66ef5f89319b73f3f74cd80228f36dcd419ece3528b38f1327b2d562a978ec8ad43c89f0fc475b0fb29146bf625f34d4dca862ced6b1050f5026040e6306db56106c9d2462944890e1cc061f200a6a1f27f31167f57d20054cefc483575f2481be56bb041eb858d507e398135bec6595fd5bcded106830cf5fa8dc10446912a4ce289f259619eb6cf55368fe14e79d922a68dfbe667246ca12dded4768360aab7d36b5904d4f481aff749ce46ff75996d8430f6738afefff0cab60a05058cb67b5e64f8317a4394b4b0d7a23f9da680795791a13c7216a07574b7f40d3cdfb872ef4dcb5d6e8f1179d1f6d0a527b5f1695a6d0e71ce0fbcba06730383d277a3cf0ec027ea6b98229a186721a138efe45b05052ae7838cd5c4bfe7d42fb6ec6d82e4ce219194efb718a6d2ea6eb35f9af9097878e2c1990166eb1fc04f7a35daba65fb653995db1e38fee9366dd954ed2d40baeffe958d9fbe825945b6d664acef116c87fa05be2f0804b12f913c1ff470a24dc4683847a14ee38d4e3ab0fdf765bd12e37a5dbbf17fa6261c524ded001448d4de0d3be6922a6423dec78b0d0ea6add26d9eb997ac6405bbe5940d261e9ba7f402b433f429061f6cec03328595579559b07a94b118c91dbf599042307fc4d5d9d57a9c58a8a210d479c203ef666109265cc7e731db2f40aac79f5445a82f5287bfdb631d392a156b4fb93a09128b50af176401f9fe678e2e96ae5f9d7bdec8de6dc4cca1a59d02e38488fc60387554af148bdec0b62891e8d0db29199f2bddf41a76e0335fd9208490c6937fed4d6b2d5eb10bb537e012617e49fd9549454daf14e9256207c2cfb15f25e0b90101591bcc9121a8510edec14a4df8fb02cba6b396229dc01324c35e6a3d1f51476ab190df63d362aa9e3d3401e26b6c7a28bbe29520c3928b1f62856e7fbe0e366fec70996b5e5450e77703460864850c08736bfa44cb9045155f91b058bd1b22624ef2096cce1ec672acc45fdd8574790b2bc7941403e6d6626650db209cb77bbb762fae449547a192040dc13cc86a5269b6a6e60b2cfc90fcfeb2caf012b7c8bd00f339572434588ffb68297f8be7cf3abf6238f2b092c63f8c86372ad3c702db382036b2c1fd5b89713a3e10c52cac7ac402fa9a02bf712cec32b45fe9860cae4aa0351c95bc1c4a143d20e611fa64a66ab339b08b69dccd8a8a44723bf0d24d9c22ed39a8f9feb19eec35c96b49f1680b1964efb120a9ddfcbb0cacd38f6ee7bb5e9d1e4a84025475a4e6165bde9581df12a4c901d2fe25633b52dac10334891dba871af8adaed6dbb02aad04fbaa726abdc514e97916037c0d22e3194e2288f57040ce70051ee2ec80c2776cabf72f88693fd01fc581c6380b75e8875616894c2cc8b210a09f7d05118c087491700d006694395f979f1068c53a49d7a63a30d4116b2ef0315a8c1b60b5682691d8fbdb460c921691cb5ab178a6603d12f19b31171e10f4d11e8ba477e35056ffe323f430","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
