<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21190ac935d49ddae6e30758eabd989c8d70c3508691c3e556b9d0439785b6b51292b13eb03ce6db7ccb11b5bc1369c19f8e941ee1b0385d7be6f426912d0e1be6ac1b2653433d3b0c6b7eb66a020c839b784e51e652eecab376a915de2ae5a24c9a391fc308c16ded767d179510258e5afb4b97d45745a2d46540d53a6c0f05fea1e4120d9f7bb92e5151381575b889f6ba5a60eb3b21071a22e37909220b9912db2eaa4171f377b5c4cec0ef5ceee2635654dd9a4b49fcff47feed49332de9ac9df57f6a55bc99b2bb34e08b132c6d9fb1a9b4e4d2a305fd58ccf2ca79be01bf6185adcf7d8dda1531217bb24d08d6cd7cafee1861e19ba861aa32351548fc94cba512d7c2f1efdb25fbe52a8155553c8fcf07b7ae19865fc1aa977676a6d2799035414935a3ea0c294725308956c07ca459d49b7b1ac34986659130d0d8359ad95aaab4e4dea20f9ec9b557da6e849557d0a0272166790cb2cfc0329b924ef7e240c4efc4c0ca21efa93a0c354cff2b038c9ed12f1a97517de0ed87edd3b24342eed9751069121f603f838e956f7fded335403df6619b42ff44fa07d8095c281a517371509816f4d1497d624d0ff9f3ad953c40e22247574044c3bc084c064b316de68f02107132bcbe24b81f88b1ac8bfd71f018418f1c61514080e7cafa00973bec04f828283008fef50445c75766796521d943ae7cfafafe9fe8c1061d71872934f1bdc7f4843c4d32d6d3ed396add0a77ab76edfecfeddfc025e6c95f9c05d335bb715de9d2009385f67a91d1db8c60645411f2edd5dc6bed114e90158881321fd193a83022717b7e1ed601606c8db97cb2b2812740e00709dfea8f3c8dac3de61f047d997068ccbdf5d8f7dff5b582e1fec0d4a14f4e73c1de967ce73adadd0e0c2b5500eccd22ec6f68b2c8e01672fe6cfa54bb1e94e8d31666b148b56e025160974479c62d1979db4bb6583e2ca64671de100f30a70a4a883a3cd03cbe655c4fec1834e273a72526230aeef6a4d3d29dbca079eec689e4207b8e783b12f426539ef3dce4c509dbc33fca306d126449ac02344c6b098f3c2a8652ebd200783a65a302a84b5f037fa65ba833766c48f42d2c5db4f4baf65e056043cf7412dcefe0d377f1dccfa67f897a777053b56a17d1a8a3a3761581e2edbdeafb649d7146179e3a7c01f6bedde8485577e775937617b2fcd921228fea94383db99c9866c42bb0c6e4cc3c184008780d28c22f6a93bc176ea6c5845efe5e295c4b08a350fb3523311f1a254c1f8f4faecca7652ed265912e0acdad0bbbb9d466879c42b81eb512f68b3167a79950cbafd5673710e5234bfb7ec8913ea5be426f55bcbcea5c4abe057f61d909fbc51635e50dfecaa8e1a913d2e4db2171654aa414a229dc290c04bc7a2c0a9581ff9940a6ccc3788e5ae172f78925371b0376d2bf4106a7760089bfb3a2d21bcdf6f90938bdf37421bb6d148017a7d729615f4f867d9b705985cad514cb6bfe0743cb912fa6d05288a1113833c240e9cd2bd93da1596f3a6177869f6c8575fdb2aa9bc21d6cab2cbd1acc25907963b8cdd56e5a50b57af627044957ce9504eebee51af2b50bc3fd32a7295e35dcfecb5bdbf67eeec0e46ec7a2fb0ffe44a3ac7545dc8abb626e4f1ca419aaa71ba703d6025162d87a1d74bbd63e30ad4c8b043ca1e9a1ff0058d4f0ba9c8ef8095b3f4bb1abe214dc4ca5bb5b141e7a4601b5de78d0bd90062d96f2294827dd973797a51520784c87b35dfda9ff765645aaa88f6ec0e9e8b08db1719fba835cd5590f9091177ab5663205ec2b543fdba521d555327eac08e228b3c6c8860f71f9a771f089b40f8aab881ce0fd6ae28ec404361d23fb92d5e96854373d8cf89b46f2ae87ae81201fc276fc08f28e3828e1d32a61c8144c6ff86cf05615744432feb8c93922bb616e8d886072b507b8b5f48d5d1117d1a1b28281eb8e63443fedcc769a903d43ddfd047ce96743360e1bf882f371e290c11a3b8f81ff727cbb9d2015e5ae9a77c24fbfc90d47f217f95cfb6952df2123e54364e1b41b867793faec452f719440ed54b55d5dce14685159a59a88803893c64db64ed9b38231196c635943bf6861f65d972db6cce69cf50bfb90c37bdd2a00a9178ceb86d1e31346b73d73198a76ae06e6709ef4ec0f967c027a569d08238a808061c3a3f020ce64cfd7b15c2d0a5a4a71a895269ffcc720b65c1b49ef3459cd605e39f429cc0181dca1d6a854650d269e3b01864b10a662bbf5c950e6b3f53568195b1f9d8804f541e036efad8497c789dd300f6da9d0189e46cff74991a2a44b2c1a00d60e009e95afb35222489ac537799f67332415916bbffbf714ebe7d4ec165be717b32e1004615f0a3121619c92d7c06e0f1ff21951cdda48a78daa725e4fe41b678f26dcb5019349f77d93dd7730ec1ea451819a7a878f8b0c196db725ad8f2abe3606361e1ab9599f8432a908e73c23a958d3daeea4ca031c61257bcab910f346f6e2c3265f97ad2c17966448407d46073293af530ed2ec9f3ec1b5c966cdd25eef14dccb747a4f2e7ad929ca09f28ed2d9e62f1de9fb5fde74b382a72d3ea88538358df0f274b3a913c2296b3d8dff1b682f95d47346b7c382d125bbc3a2edb49d4739ba9384544318956223c113cd7af02644dc7abec744d260837b4cb8e28e3810af68ef89c5337b38ee8ab01a783b320af3b67ea11f39c3dba41234560652e8c5fc8ab8592faeab28115aae0dbd889e63719feb72666aad7558445e215ecf73e5d75b7574d6493aced92847783febf90705359c7aac6cfe116617ac37f6d81f6298bc36e1efb1ed2a9a2207249c5ef68a3535acc7524a5fadbe08160ed39805f8a552069fc496672b6677cd97f8aff41f52e452877973ce5d05d84fbf117166612a3b40c2e04add092a05cd0272a70dccc0ae35701a24851bd3cb781cc69734fef1efbd7c5dc497c805a17744374bd1a204ee925c6e86ccdaa479f12ec970c54a13db648c18b2640a89205052eacac88714b4b62414c15d57789983ff27d422b00866c7fb9f296c30d992cfbd03bb1db3681502d57ee6572946163f87bc00004838d829ffb974b569dfd41c6531272bf7e699a79ceb3607781e1570945ddd9255b8933100fa9834dfd807ee3b078a351bbe1b76007a92ccb1d8f8bd9a33ee30eda002923b0633389a20157b1b7797216d7c11a48e833f6627341d43d1e07bcbb48be43ac775ad0e946e39c24847cac33b22b80766a6e6dc0e5296f9c0a49ac625a665319ef91fd21911ddcc39fa4e8a4d94e1aeb0a36a46ed0b78cb05e46edf2335019864aee5d94d09ef4cee045c8167597e0be5056275fc621cd86075e11cb48a6894e6ccf10f7e109bad6aff71393649dcea8db406bd750dde5f91cf0283b38e4c1debbe8a9d56abdf84a55fa0161bd075a23ad124f0a6471aa9fcbffc69fadf19c17ad94c25582ac520ee6169bfa095817d5551242945be14b63712019135b262a9ccaab5128c0417face1b1438ed9cef9dc45c5ac9b2108c6c609504996a7c6e1b12ba9c9888c96dafff5781a0673015f3dfbda6c0de54b6f37424a1baed241798c81602db7c1750a33a59065414b180887dbf4e692c03d1a1ae99d11fc4380ed74375a65ddefd30c5289568eae6d70c2499e17c6b808038541c6de4c9a0a50b97f27b1cd8649933f401910a2039e99f28160d1641469b0f2167818fb256a011ac1f517e6d14fed058ecbe1fdcb930f363e02477f862bcd4c36bfc85cc868ce4c04fbdf57224531b7377111efe75105ac6369ed2a6cf85c1cb9faab8a5fcaed820ab122792abba562923ba714ad31c97c9f5f9382073477bb3c1a03a9e94eb058b00c5f74da703e4e673a090aae87bbf58a2b238da7b58bececdf610bc89560c80a9ffca4a9a63c364e98fbbb0b3c83f8f1bc973ae972c2b1068961ef09b7d165e81bd201746adbae7f015a9c30e7b94d4e96da32a8fd65138c06d6f316708407ee635860e8fc4b83460f333b97d710e67899a258f06df9f02a56be5bdd39c93707630e15af14b206e0c6e6625643966e060d22ba18e794d195f34a491bb380525b73670c4d5c5259796f662f07df3ad58405b02b7e9638bc63cd24fa35d7dfee2be9bf4876f5712ceb108562dffe01f2530955b25fdf6e2c540829d310f529a5cea68683f9d1c254ed6f0d87c3625e9eaff73a5a77a0a018a5446b2e94ef0c7ca0cc4a4803e27dd53fac1d32c6e86a576f7038f71af0f502f8aaa9e86ff9bb73ac255382169dc27e37a75d1d2280771b38dee1b3dca9469e62ac4fbc846105d3accc1f41dfab2ab92cefe22abca7fc967c84962a083572a30a5ddc209939c40b16e7d7b539b2e9e10ea3be5249853c2af3e2324cea609a93714efccc0a6731ff6d8db3a90ba603df2b3a78934bf368c101ca61017301f88334fdff100c9c5b1116cd02755efaa8865959400f7b382c4b75c193345c23f318f064f9dc24d1ac5c7dd13d994a1a4b9cf7185b45f7727ca6c79135edd52cb560e55f9076420edf9894cefbaa7b1370b0aeb21abecde05cc999113386a33d64d4d5c44a6454a8f65f982def4f92f40502aac3d7c8c1f37b135d35eda64315b150d1c566795cd14b60e3ae3cda429106bdac0bbc0b8ffc6d97cadaa1d365d5aec54659465a00643241880c3724b02642017c3f15597cb3208767aa83dba38eb3dc491e6ed9a66871589911b0c96433c7f3ee965cd37ee4aff46c21f52508d9dc86274640a4469a7021de0b384826dfd6b6943a472b251539c21644e04861c288028924eabf4dacabcb5e03f40a5b651af5c127a4fac21bb7d7bb7873e0db067c120b7300346f058a4f69f68f28df621095293e867a161f61467f06010d1d8962e671be7fe640a24b1ac9d050af23316d1aa6012d46c0eb01f77de06495cc08229d06fcb99e32182857f8cb0dbb222e05db4bdd98a14026efd8e5f39fc2cc6a23339c3422f30eef931e34242e60b527f2d112471358384895cd14ad60ae9ea00871a9a32f2214022eaf9f35a45197f633c1656858750c179c31281d37e0d9762572a891a2242536a71805502ffd58df88a08c74ac0faeedb217e8f30d64ab791cb516fac95a27ee5ec6e857fb86a9f44f8295e0ef32c5438bcab493621ec1c2dfa2ec46d8d9b0d34a14bcbde71e2e33d6941e71630c47e2222e78757e0a14a6b895bfdb6120d8647c278ed3c1c7fe23cf9cad7253e9a200bdcb8c2891a8d15b8a5c40de4f55e8a1f9d165eefc939072319cbe010d7b17c7247d170f9f0d00032e0645d6062205d874ba3c07d77a3b4ebe33a585fb6983198323bb25a1f168fc0d408f1421d9a159ae213889be4c2c78be6395d472fc510899abc80c0e85344344b73d04e026004bd9820813b5fa38ec3641d5478e527c27cbaa3c86f9d69f54fd9cbe49e9016336f6b532d33609415e3e8428c2afa09697fa81073485bc5c0e0e6a68f2a904ac7aebe777407e75716e44662f10adace3a99010c14c84f6b16c4e2da7b926d1af432cc313c3b1e0bd7198ce1f5d75779da72a4ec9d084e8cedd9fea3ffd072f9511768eb0c48ef9995977100e366ea48ca2090752474f5b95aaab7d5e36c3f3ec512bc8df0e95a588d050d62bd266e0abe9697e21226723ac5bb14dd302f0cbc45bf3b52e47b1464a132b33279ecb87c8a266b8e7669c2b8bfba76f68655a0423c17b29c16eeba533ade655edeaaa9941c82b0de4be873e779f8d2a4cd7a2661697ad02c1dc7f0bec404915565dd872cdc6cc02f926809db7e188f8364782d9f5e0e4d01d5aa4e0b83e9f2f4d2a6d1a9282fcf644be89ea08a83b081c53c28f8dae4b2b7ce868688f84a2e655bc707ff382b112e16fbca3e3aa310d3b9fa0e0c0d494f59595c2a9e2f1c746244002b2da36e6d42a42fa8b8a59f85b7f60795623b2b42adae9a16637728d6b25b663f3b1c8e2a3ebacc3d24cf411206af89d001acfabfec0b9b7d1f00a000719a55a52fcaa8bcbc397f57971096e715e0fa6da312ac1e204b3f67f034e48f373d1caaf756f9456af82a9c15c3cc9e3f942ec6d06d810fcf793c49faf44e219f4bb99c6beadf54e3f83a067005c9db5a67ead94ff3cac19e7b11888e5d9ac67c34dcc48ecbffd5890ea31e76bc1e75680d3a928045ea93afe1e84462ef2deb8bbf28cd108d5115fef13eb37c91ce825831b6e2d4c6145f7b69fd4ebc1f79c4ff29fd19c3cf00ec953ad2db06eee15529b0a9529da519a6d3ed02b16ed10fe967f5cb3ad60ff0c1d33628b37ebeeb714df7dc5e4d1beaa13344942259e04aac28502b440aeb92666342b0137ceac5b87b2f6b5e3886dc7ad7723a8565d6cd2fd54c649326678bd8d61dddc0b9c733fba2efa2bfd468054077e7b29727ea054373e0163d552e013e837148b9898e9f9e24af9c982e000b237f92169db6dee9ed2e2554d9adbaa75439f4feb961eecd7ab3f71b86aff373db6ed3f188b952357443f32a2030201503b0ed7b3a47ed5651916d89a219fc2a19ec6ec80c91a5e269c2bfd43855b80c87d7c3e95ddadbaa8680038b41f04e31be04f728661fc1c10b7537170fe2e6e7202a8f4ca57b55b6f05b33a0017a4b76c670e76b53899377c41c153de2d674c2a2399759e62e3d0fa812fa7c3857d18ca5bf5ed2ed8ae5aaca60b77666415e201a035ce0b0c4dd61cb2053d987de5bb80dc70b89a0c2ebdec3e98c345b7dc55ea589bbb6265cb2993d3c50524806fb3842f9208787087d6517c12667385fb7db220d0d415449aec6f635dfe90aba05fda99d04a9bf88d99405e202f96850bf9b06e055d3559a57deb50a3fc41d3a7ecff5109fda8a9ce9b77c22261bb57c6defa392749cf82fa78c775637554ba69d4aec93f32f2b3236b3c81262d0c128d5dfe591ef569b3b6f592b3568fd70dd4297b2ae2e869f11f7c7bd9be0ef9b5e5b3ff6e937d8634075a323c0c0317bf792efa33caf556eefb35cfc350bfd31b5d1c3592ca1366aa6cd31ffca776a281a9015b362ee8387528ecd4abe535abb3bd279c9e82c570ff9a5c3040c6bb36ba154968d5dd68451dc28a532794bb227dc7726dacf682f4ee2b7aaa1d8d794c08b171697f4d5abbaa767455bb79559b86682647b9857fe00a5e50f5db75d536b4ef185bddc938d2666095e2ba2320eca9ac68c8cd561c9673437fcba8a656ef32aab46a8e7c7429841814007280fd4e1e0be7b9e8ccf56855bc26ea088182d89cf169cdd35c81b3dee00ac464bb948e87a9f77602ec722e10fe86e61eb2451dff39345bc54a869e249c9100314d4b12b797654773c8ba4e3c5c0b444e83a1cddf849178b7b943dec8ad4b16a49dd942d2ef970be8129dad82fc91ce2db58c20b98781a05b62ebb6e784929e460870ea7f6cb6b0d25d6a839000fc551c2141e8948fc427b294cc50e606f3424e551f0515ba7e3f8a1d07807e48f84ac2bc4ba4eb52aa78ef425e86ce02401420221d1706e35c036ddfde00414489ad22e9b8f52dccf2a334a280ae02df1f560a3c747e397017f1c7b0a160ba056f73fc9fac17d11788914db2dd13a992028fd2005c28fdb0e58913c93137ed673554bac1dce9a25db6597a2542ce173dbd579d22aba05515095fb1572346a4963738ec6dc38709e25e307c4667b424577f8eea705b006df1eb2d0e0400ae07433ec73aa96df245d9b98e774f65d4656f1845a4d0e342025b1f5e1f471e122bd7bf84a2b854c63a8584d7119d946c12bb0466587e4e2005cf328199f0f7dc1ad1d71ff0b64f34d8bc22e8abc899487a926060d3b1c4439cd9b0a44eead6b1b486a352e465bd70dd0a48e41e5a8a0ff3937e83fa6c37a1bf7b12b50aa75dd0f69f09846098d76e3658b24a736b5b261ee6f4f3ff32369d5297e348225c89907cb84367886db613f7b30acb5df37bad27e576e9cfed0aaf19c143fa3546b983bfcfc8d633f45410cd9bc08a2531fc95379df37f7460f30971b756f1ec26bf1233fa11da841cc7e695c10818301247a26de30218d9b1d3141798ac6959afc81387b98a400e5a7da75460effb0aaa368bb15714cebe98723e1ee8af2ae699573fd99dd86e5529eb2f49a63fab2b6af5c1806b9dc29f004ed6131da5b3428a225704196f7bedaf20f99c2e6466c78a57d7fcf47bc555d1b2a1bc04ce0d805bd120d7e9f5b5be98c1f039c2c765dc9777c463d8d0741922f5ccbcc6aed27f3b32ad56e5a0b9367a0d33d3ece8e322eccd93d592df1cd3ef1a10f298a0003d1427a8822eb57e28242e158300f6a28d4cc4da54d72d7b111b5e4f2d250bd9eadf8bffd083ac1bee6beaddf4bc5a1db2f592655e9384f9d40ea2785e867b269c100ec3ee426889bc31cab743f225b3d391a0cc9d80437139c402bb9405c853cd2e9a7ef5d8eeda8daeb0bc693e8a41554a21e2ce7b59356379f07adf0caf761e660547a32d3b31bdf5e5cc11258742ed32e72a4a6497c411c7e6b5443c6ab18d359aea9633108","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
