<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a39c9940c42cfeacbe1d903ffa64ca963d48abc254c43c36ca748fe477ac148213113d8c1e90115ced7a80d67ee3b1df1b805bc662c3b9a36bfa2296bf180b2fa0e9a93b6712f4e6cbae6d27dbe8feb1aad7e711693bd8a2eee9f146b2f00ea5d55374fa400ee5686de2cbcb24459dea34335cdcd8bce2039eae8b389156f62ae754e22e47ade05d331783f08f2548c5e996a7abf365f143d10dc93bb204daeea11c545aeb020cd01a2e83e89a07a4616f11c013cbc3ee5241be15f3e11626d7a0255e579b3b217ac33368e9e631de668686ccba87345d8d3b9ddcebc088cdf54e752abf122cb74c592b615082e374bc3d4acc2ac93913acf3a4f2b5bd8495d447fd9d72032c94c8c56d48aacbd6fc7b8d6b547b43b319bd27873564323dc10788ad22d785beeb57f5c9c15e002c866b6314068a237df9914bf26947242a9ef55b8b1a3405592fef752432aae93ad264a81ea822e94fb0abfafc2179ad8fb0a66c320b6e290909f61a2ed1cf571bd56153cad8386f2316d999e160edd67ba375fbcb6e7533053d9381d8ba60096ef61b9bebdc35e8fa55aab122b644c1905f67fe49a60daf4cfb1465ad5e0e5d355399318a5c1eb50803c5ca2c2ee34eb192cb5ef79ca2dc3adb62f35be9f97cc7a77912d49cfadfbaabaaed4059457a9014c5f960ee5a116448dbd0838c47d37dcb5ee4c864a22d199ea777581bc96289ee07d14a25d0a21bcdf0a26037224feb10d4a921f7586684b067f4a2ebe9367857308817bac17f5ccf5193da62d249ecc62ec3d445fb99cbba27388889f94267ea84b6255dc24ecaea29fffebdc72c3141cf16792ec1a23eb705123b84dfb74307a187cadb90e4e09e2341d9ce543a4a9e7f5cadf70a80b18df497ae21c595701c77bebc7d74b79bc2308013a5d47b5d9c01bfa2657ccb1f059a333bfa9fd065d2289ce7bf4e9fba0829fbba78d1a9f1a81ff9cae61cfa0ac8c8fbf7dc5b6fc972699c8e25028e628139a091cd855b476ce6771af5f46cc2dc1393bf27e88d3a3e6be45f49372c01d0d98594b14616ee4a54b76353335d7604eabfa11653b54c3f03d469c9141e3b21b3202a2868b0c7f44d9e53168789c63b3267b4dc64384f2b76fff644fe242e273b9b8e79b306f6d99f4cafc925bd7bc03f7e71c11bb6934e6e5dbdefe7448bba8f8fee2f72c743a1921a2a3c701180a84f799497b204fdc39c1f730d4a63a36e0d64ae3e9ee7c1316cea7da8d41b1b4ef7fc1900fdb42becdba6d9019bdd9505c9e6999226d3d0f5f06308177a50f67e887447374261b357d12ac9432026dd8af7a9594045170db183569d9c682a3d0417cb0a9386ee8336048329263972abbe0b1229b8bce38af0dbe924edcc06ec808bd9c495008220c2422b1d4cb8b63da10dc8018fd75d20b7e88b551511c192b3ae6c06495d87565ad2f3bf5318d46bd29e05ef879e824bd6fc2ae79c97a3ea0397952fc0aa96e86b3cf95ec4bac1cc34fc607890595a2bc0248f29251b121455f9a7db237ac3529a35ead8d35cc0a9ac5b0b7723d7c31284c9815b29a27efd51d61ce69c5cfc83d77e1aa4d592ea9cd74488533cae080e90ab3b4d6ede76924f188f0953804d240e24c35fad022d8d1b038bc9b1855068d78950020dffde35415ea87024b3531b286d4a5f3da7c37d457431ac47b925f125c0d9aac5f785f10ddc8aa904de47f0e6e03b992b46c986a8005293d8e85a9ef9d33aebfd8823c6e9c8436310b2d24b196fe22bdbbd6f52ce99f698f3edafa8d06ea8b5f18d3ca08eed040cf73fde15b578be90a59cbba0697988f7c84f2bf2c87fe7a473c17841bd263539382eb3595e7dc23a4408072abd981692aff29626d4e056cdf68458816d0a65f5a616f5e81a00e1316b9ef79dd0238e6fb30dff7490f8886635535051987a6692e3cc89ca7c715c2ef9b6983f38002760aed66545810befc5f817cca9efcd4076995f9d1c0bcc43969879bfd110d1ac2ebc305319941a04ae931013ae60873be35440f302f33350725124ecc7b9fd71cf172c6eb9ea34f7edd6b2d746313106e1e97a16c478bb8e1ed3b60141051bf0be9f347abdc0eafba84005d2c5754b63aaa1358fbacb8939379a0dee2265fc2e026c36bdf0469ce31034a470437dfbfb996b74da3795691851d7ad0985614d2f31ce4a941ac264a2c7fd652b3ea9dc313c63ea0b90de714beea520a4cf9d6abe94b7d2997eda8e5297058d3bb5f3f3b72f8a3330378359d2757f5e0c6e26b6d4b71f8586aaf5e04c319904691da606b72251abe5050c3e82a415ffe94ce094f4950976098cf72096f1750d56ccb83a4175212f3c54ad4d35a001d2a546cfd22b87d5954f6182f984e9ad56dbef95ef89ed8682bb619a65aa68251c24cce50610025047b72d4f604ba45d6023029426f25bd620a644dd089ce4c1519a16af6fe1ef70670758c866f2bb766b756a1b8249b132eedb9722b937ab0c5fe317f9b73f26e6691330750f85157042670cbcf2feb80ea7c80495cb2d7dd7aac822d4968f5bec0c3eeddb33de72b6f5694e6a9c1102b252abace43916639753f9ff1cc8066dfe1d6832e95c9b8a43cbab2636b8f801f93d409e8ce93c9518cd3f3d23c387e3750dab9f5fb73bec8169175017d853741df11b56b70d1ce796bd52a91f54fb00b203126912f30e42a4921dafb9906184864243ec3ab135f37999b868bfe839bfd1f5d8ad33ebbd54db2e94092604f20aa8fc765de901ad2898ed419dbfddd0b95b2c8be043515c14af6672c2ee5b1e6fabbe953b1305eeac0a5c981acbc2bf18b2ab1403c18a10ef077673839d1ef05bde39802c12f775a27e3d4fe581272778af81625aba8fc736e6a92e2e3e818a9bb292d1755a30ffaf7288fe5c847df195f214deed6e6b900b29ceb9dc0e58d99437989d5c2026f07e3ae82c2bfb1984479a16fcef2f2d7b01dae2c3846af575061b46d2db3653ce958676af0f336795c84d5b955b82005a8cfc6bcb8ca6d48af47394be2c4b0de970d1ecc09f347b2782a4b016deaa3e2ab06e1fecefc81fa9b224f86d7b2a1bdb6db922a4a95b40acc1bf93afb38a70cb60eca919b4d1883fbc94ffcce65c2ce37e92391b512bce530f9bb91efdf9d9a15aa27f968ace0085d421bc0dcc23ef3faa84e33295f0455d8678e82fd64187f23c70a0f9fd468f08e6a0165c4f680b37e8d9aa83580ca249afd5565a9f547d1f00c0a371f0b1b12225a7a062b6d26becd57b75137c9df2a591202a4a9c0aff3bf68eac6a8ff748b3d13d730c625c46ac8792168bfb7ffadb3331749dff6b98b822a41d48742717c74b9db8218b3f72c08fab39579867c101a6a446bef34adffbd96d9cf1e2ad85a928735775b58389863d3e2818124839e880b530402bae53a0d4592a369634ba506ba7446187da6522d2229cdd56f57bc8c719ffd7c6c69c5b30e5fee4742255e476564e47b6e78e3291baf8611dd0b38722d0e5b8cd6fe809a368fed5b3d497b455e433df734a1db6ca6c20bc24db1cb822ef976c5ae06ea181b4217b22ae121494345dfa74b153b3b33f54e05b420cac244695e17f73f60e72f38528b219b0c8e43c69aa0a46b5ba67b7b42950d7d73906871c1ff903fb268853233914b72606f8d503eac13a96157420d63d01d0e4afe23ab4f286c250e337528b8957b3d3fdcda0eb8476785f559d05ee84db148aa4d45651df8f9cbd4a7dca198e3ccc62637fb3233c00d9f313ea0e2eedac6aa55d465571973c2060901646e8f1a28a110c37a314e1ab0b3611fe3ec8acd8b6167a09c2fcaf1ebe7ee09982a4aca4b7820bf7ad3f81eca57a738bdfe1c6ba3d833cd90e39ac807ae47a272bbe9e192d1144d56479d60e26e0282e1083e2cbb32147cc5747e6a5da9f5def48cfadbadb39ceb0f53cd87e8a084d90280914ab369f3d07481e9dcbbdec04b0e2490651f9590a0d8c7c2bdb51e3c09b06afdde053bb1934e769de1484ad9cf9b9db76cf0a6d46bf695192bd1e2152679996b445950df4f7e5f29f078265c45423fce11c557d9ac3f48456ff4b17eeed3f130f9e9130811bb7cdc2f6ab8581cbe99eef8e3c3b38045739f77918e3fc5214ba761548e5495896ea7341f166af1aa735d01d5003195be596c27e214f73783524869ab7d9135ec8dcb879c6d3e247ef9123632800c005a41c22f055f2460380b6a71704738e1ccceaf056e245a735bb3e7872b87c1e2c0db5ad948aba5410d61ec92fc61f798e3dd4de49cb3e6abc6280ae47899b967b581a5e36d335b717187b4c64e93828a471dd4ad22cc62f1d537df94ff16de43accb8df85e0b6d4ef77d437ee0a25432a8e7cdb7fe8d5bfb074b8be016ab7493e2b9c4ae767ad08dc965831313819bd04913e78b10643da76ac50567a8877d13825cfb2d6f2845f7ac05c2945166d00247a72cfd76e56a46a760e00495e97fb68de68cd715a71e3558b2ba9f2d315dfb64fc754d1515fe7c81fc12da2ec4965c692b2135c1aa011131e9c352b33aace206e1c37369410df7f0313c84f913812d9c4eb33eb2317154be7edd9e4c8fb69ad8249c66ed67f2c0768b12829bb511981e8b4aff2ceaf03ceab447f3f1013bdc48f00ef46aa9f3774634f470e1b87b089ad678d44b2b2630150211614b9bcea5e69122b60f429214cb2db336ea90400e3086cb82a509f712689d120c109b9877be868cc691375f9f02fcc2d6bc028d077e8ba4f07b62b4948661e8b9bc8128e3bf212953299bfbdc81c2edaea57f8e6e3697fe9ba853333cae8d29c7cbb19c9ca3b1b4863917ad59f8029cf571aa2ac61d298ea2ddf83f8098779d9f06137c140dcec5c6513332c6994a4945eab039b0b398ce019b73e8433b12e9078cbf8c0639cc5e30dc2e1b86159a45271fa7f3b3e80d2cece600b166c9b99f6ead2929026eb60bbd636496684db85f2090630869bd8c32effd5476478e28b7c2273fd8dee4df3a0f11e9cb3678f89fb6d422304374b13124791c466316b71df25cb94f4fcda81c142b56099ca8a827b1a2a40c77ff2845c90623ed052191f2ca45166a2d080ff6f9c24493d93b75cc65b29eb780f45bcc0c3a1821cfcd1576947ec0d824cf01ad851512fbdca5c44aa728f16dd6c3892d1c190f32a6dcc48b0d17835333651ba6bd6278eb583727efe954892505f7626e8988384a07a561b8e1772a5639e33c9cbb326be675bd0feaa13330117e3b8c3efdb4f008ff11ba1342603cfd2d585bb29312738bf584ac5eae75587fc1cd4fed9e94deb1a812cc1c38aa16c194dfede3cc66802fb7d54ee7364b3e5ea1f46cb424dcb78ad164d2ab8219596446bfdbcc2a6db432e0c50d6343326ac1cc6321f83d225ce6d1805aff8f8f730d60b50bcbc4e5e872615437b0fb8e87ba8e2a76112c43aafa2cf39bcc6029dd99b930902ad7480d56787e55dc2f910c480cc6f07ffb5034e6c6628cbdf8a8a06cdf5ad1adc14f52ddcef541c7ac89f29134b607ecc41014e77935ea0082b4e44e2113d9e888afa5c03142b21c121ddd73e6a6a99a748ea6a05bc9352e4ff98d8223e176fb9ece43e9515ce8d6f8df6cc0aef381b0b18ae745eb77d4a8cf7956b128457a29862e9e91393c61ad458e5f2b7cc0effa2604a152023ddb49db18c6cb0f9f53c14c87218b559f7053858ecad0128ae864a69d332729d509d1ddbe9da4cd0d70cf570be2371649320ec5844715b941b78b67727a71a2861cb37b86595732d405306189d22f2487c019961f687be271a2f2a17bd231dd5ec2030d02f4e06ce20513baa7e7f0b82952c604c6ed8ea4ffa8ec097245de83ce8d05dc05e28d78d56ee796e0e47a4e0e626e75da07abaa6cbe1242204b6ec1c6d4c0afe12319fb1cd0f322bb6239ecd611108807b4b456713e8ef90f44644b2caa3fba52d349ca59cf6f65f06e63c76e93fc73061dc7d8c6b3cf8c9a05a342431190186c635cb4b3788c4457ee594946f65e74f7524d6eac2e018ad08e39b82de571822f44836d27a05e04ae58516933cb8c84dedf971a2d857bd2c8a4029bca42b2484c1bd42075460864fc2c939df1bc363cd28c572acaddc0c7e624b572e782af131e215f398c568f47965980f1f3bb8fe2af168a3c2cd933dcf15b6ba1b6314c4c55218e3967b83eca8d59aa4eed15fc822aa4702f87104371c512943bcdf1c6e7ef075ef6251dd54b189bc14321a677704adfaad8bbea8eb7e9e7c8c3f9d61990a11e0cd3c0c37743c4e993deff94d7fc074f4611dcfac45a4281c4f67c82c6a24a7ac49d14b3c78cb5147e190c279a5981c2de9b4558749e4bb39d949bda574b3ef37eb798a9174d3cb7298875fc600d33bf4857fc059d4d08484028ad87c4dd79691c8eb8ff75850131fd299ae490c1b7d846ba40ed13477a05a7f6e6c4c5e49f71228779009bb057613d31ad7380fe250d94c73acf4f9b26f3a67c0bba7bc94bbfd6796713fe14e751938ca95ce4e89048d14e7173ddb3f8738c84e28b8f35b9034c74835e302d1a8596c07a8762fdf1a827ed3d81d4b24e8ff8163be6251b0e0937145f56251496af2401842d409fe6f4a7521351b33268e0b9930e3ec3ee8cc8fd85eebcdc90ceb38d0d133401bbd258711261e13f5df1fb2debc0d430e3ef7ceb58d2c0a2e847ce180545d3147987cfcd4cd52cb55e14340bad374a3c0003c783da0259829624d293d0a04963df3ca509e53dd88a9304e2aca83b6fb83e9b9e3f6da1f47c49341fc484e9967a61846bb89724ec19bbee14ffce3aae97377e1c10e71d4764a5c4b6879e06c269b575f26902482754228f9eaf1b56ff6cdab5bcebef5d296c30d9a05c9beacc67d5b99d52974b2ca656335487a6f55d4f3cee0cc00fd45fd3167513e60960a7f7d7cd274336f877891e98b06bd56d9ac255f17b0c4306fc80a0a50a57903e4e516769e43e27409e873deb8679deb3ce7f9d6acea6515e2de5e5c6de32474b67f1a6ff963ef1cae62c052dae41916f8998d3416d8a241678b9c029034b9cac7db2e4c6942c3ea52837cd15625580d0498b8d609bf4945b0b853b8d8123f14aa603443058c70acbdb8b4496e483d2aa3e9f8d5551d08fb47aa01bd0221149ff1abc6ea85d716f6d24308f9a4336be1508a6420e7493272af23f4c9b4b30618359e4ba33d56c1879c6e3fbe8cfe23322006134e7a7d3f98708db40b77d12117e97b0abe699c6f313f8199a74467dc8d1511628b229ef984d8481e13b0be7ecf5c3deef4ede799cb5d4ff334dc47a54f9d83b45261e589ec3fd63da332ee01422c38ab966c94a51d33c09f5765c36187e443c6adfa30e88332ed2e2f6780fe3ce9960a3dc7b8d4f2a36662f245e1334391fff22ad95e00d18e5530289be89285084ff47fb3b526ce8f7f674006618b4f76b8fde3bed28328b7684ae60d3cb32d4f533214b23b80f6ee6ff5ed9500f0996ca2c43cb6cfe5f393cbc9f79863f2f8ff5629de4794d27c4cf08165448e2890e5567d2b461bae95f5e896c6d77d1a7f963e098572d28a0e95501cd8afc10378e3b0d7364a73591efb94887cdf96031981c9b08d53aef1c075a424935f9919a33a6f01fb4428fc5b4e988c6b6e496e8482372e35a357201cc5f4e8c3ff1d96b81a28fbaf980bf15b71f282b93c43d1348431c242652bce29754cfffc45ee6ad8a12bd6ee7e40071458eacf6668ac4996722226699408a3a00310eee037d56df181b83bc3475152c23707dc34d4c33430fe82b73a6836a356111638ef1297cb5796ae01df1155095647c92673d36424730bf709226cbea7226d67a39cea9aafe47813e2a75beef90269d778e4ed06cd11e12b654d2818026561b51e61c2bcf0935866ff95d5e015cde0d6f61587c2f619d8d03d62e1fad8beeb5248f961c2b70fe8b38eb0ee28329de3619a2844f9d333c18d2eaac04ea51f4f352bc5e3ac7b8fa16fce3d5f4bd23acd56c6d900868c51dd80058128f27ab1f10b7a8e7a1f354e58341d22603431d56a80ed53c21cf5547305cc01e2d459efbcd48d3a3bcc82558f2489f324f555fa0678c8916a802a9bce4a873ef09fb9d8e233c01d42f47c3f53aecf9719fb2c72e12e865f894bca66e65af72f7d4de90881809df32c7d3dfdfd1c2e4a266fd47621903a5781d50f66310276f97f482a8729c14d01499d7f4010013c725b2a267840f46048ed576b23fa13c27c391c9d43e7eab65352a9412912e12b6f8432be7d8b56a53713f3d1a5433384dc74e0360e70933ab332f38ab0212992d93da2df15a4068c5ddf65255d19c563c26c74a1c61e6f3c17fb2464721eb53903f8e47f712ddbb939a0ae9e8cda73035b2d2106e470f772c01f2f46c53025366faee2d50547e03b438c515bf31c8e3b55df96a5cd9b093ac3dea6c48a842369f4c5542f827f1d7bb13cdb377ac688abde7d9c74600f67869332a42c520e229a30192e969cde06c14f5cb26f52d404eabffa78f29ba9ae973c89d481b3fb8e38cbd76e4559cfe79ebc497a7489613165b0f4eb86979dd550c8efefc68730a6964f8fe7be01ad58949df585dba806999e957813600c4666e0e4da4505c0741707fbab43bfcd8f11480119f7c26052801460407e5b41789a3f404d0ad65761624eaa5f9244f50bd83e98f4948b01d0ab0ad2041e659f144c184c1473dbe6e18119c107822b5f9a9afe95cc8ce2c7566ce7df2a2906cb45f9a1c38b92f1069c89af187efb8fc7af39558cb572255e29600ffb5380546aebbedca2867acefcd1b7b92ce0e48ea716151588b54590dab1e105832a26a8236bc786307f247f3dea36cc850f4882e5db326f3db473fa162f7248180717da3200e72c1e26628d4c920e6896d857a4a566db2a0e5606ae8821df7393d9d1f0262cce075a461c957d6f796ee1a6cd9f45d1244fdea8f4905c67adcfde1e1565f82260e37f724991a600e94bcf693d4fd7379aefc2c2a7aac09e4af2eed5dddeb18322b61973704f4482cba41ae6ecdb814c62ed6f1def8994b53caeddd507a73f6985f9f246770bbda7543537e6051b5659fdeee949bd8bb9b7afe4cf868c56aa82c67f940e5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
