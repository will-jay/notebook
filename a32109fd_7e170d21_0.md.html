<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be8b1252cda42677cb5e5f2f5d2235130f2c99667f29bf46b00278aeaf25b3f1a24d1f89a8ca1a27feb713342eeadade0514154d0c6379556e227769d0d3194ce98094299d83d564ce84cb08277451d99ab91867d949b4def2c15f212bb192772dc04a363c9607f0d6bfcde9ffe89b7385e049d1e72b89552e0f3916f18c5fc252df7c9d251a190b4b351d89b4f7a443b37652fbb0d1ebcdc393cc21d9fce5fd586fa57313da39dfa8adb51feefe1ab1a6c1735bd46be671b1e91a0a14703bd8ed4e8276107d1a72e941f0498efbbaa5394fb4f49e2a5e8ecb046cba07b25e20ed1492977f2edb1bf2edaac941118e8e02d58c1da6bc9ab6cec690b60efd03f8a1eb3cd23f9ce5c50d00214a1835ee1b1f12907289fbb697aa9dae7e2212618fe89b5aae14cecaf562a497fcdbc13f14ae52a386bdaac84bfaf28a47a40981656fb8a1f58c0e07d098c668d28cca7410bb4bfe9a9932b78d4be83abebdb773170677237d05f5050aaaaf0733a9667d4b15eec35259ef1fea1f10085a753b4a988765a9c56a09e03b4272565012a0ab995bd847bc40b1ff819399e5626da83ee180294728d5a50b71bfedc5abc33b11d8149b5d3df6de24a8d4cae4d8b74bb6f20ce2262ad7166ffe36897bec32789433cce3568998769cff9a4af22078088aa9b457fcac31dc942aa21f417656e5d7d5dc709872cef2871dbf570b620d521d93a33a4aeceb57de26c108011db207bff2c7cfdffbf999f8c301d93fc69ee5a2878e7fbb9768bb0cf01c028b9086d5f911538875caee55f3a8944a437dc2f2f5b98f2684101af993f0f3acdeaab84ef939bfefac296d9e5834d70c2a2d108cce043b7e8615fc7c6118a02a442cccacd92c070665ac42459bd2caef88e9fd1c9a0ca3a5625e1bfb075823ce60d1f7813a83c03a6322619b8f494f48a8b2dc9649ccd75c2b634d2d4ca1b5dc4c28a310d123252d707cac29d7dae6f91f74fe7be4e9872c83e349f6ade07323a8b39e69abee2a7ad119c63e8eae40b6bc99d18529b4675bb487bc0c566c8460277e0061084487ced229842fc0d3b6f8b2fa45ed45073358491c6be8747c87c3789672510aabba15aceabe9b122708fae052de20a19b5b416b318fab1f1f87e25b477db4b8a34fb6834241996ce7cb57d9d88ac7a786c5c0fee42edaef263111de660d7af8a8b00903e2440fbead417b1b64ca6d9cb6c4046ae0da8327e3e75a91f2b2b56aa91c47c3258c97b1e39bb3732d8ab6ca38e7b9ddd203a1d6058f016606ef53073f9775fa281d5d686289daa3c6c16d541f77ff67a246df1881a2171589f3f47180909b37361cc7ff2bcc82b4ac3f6f6fd7342d0fcb9a951d851a28d4737941e252fcdfec93debdae73888fbcd5f07e2320196dba034efb4208a97cdfc6781ec2be127a5700f8ebdabf5255609c0659d0852c9437102359b3d65895af2480185a393d2e1540964a8c6b13b9100c566b7854bbe38db35935484223ab2b30920e3c2625e1de8b588f3288ca138f307ab8af52788cb54f0330d915fe384ce0e73e07eb1465cc73ea17e70ae51a3b65628b11e7e5b2e521ae33075b630494fc387a764328064026aaa9b316d3915a524504b70061b7bcdf756f6f8b3394b6ce4da95222eafc5c8d6a634251853a762758114467c263d3b26d7d4e455ffb543a60f33b6a9ccf65d8710310857d12226d30f364df5111fea532c6634df059bbb30bcd6b073b4d0583ac97402250502bd6a8446950267a39a8863946b6eaf039cbebff90c75155e28c95b796d74d0bfb68f7b82d46dde3e68f832dbfbb710fef78e892528a3305a2ffa254951e43da6777fa53fd82f6a69cc37ca97f33736e69f2de1eabccca9d8bc335af6ac9496f181770c63af8bcbe2f52af6f857fac9a324d130172d59101c5e26b2d709c6337078b64583a6bcc68182af8b24afa4f1b453b8cc3f4e3ea585f5bbdeb249df9cb6df71894da22e96d1f8f8e8a833744827580aac5f70af74fd98d3fae631e7125bac9b3286c68b08a2090808093949cf9e4e8be37d077f372d367d847e6797923b94ff312440bcd27bd4f6b035e27e100801ee8a546d8d44f66a4633ee398831fb34c4a82b48ff9f74e88dcf5514941f36b76d9a04797c8d0ae682b98090876c427f20dc96fb0afdfb2aa4f582ac29b76292dd585b006b93dd7ae8cafd89950cc2e94473beea5772f1a28f02cecb228eff4f6fab5b31305f86962a108e4d8ae61d182cb8424fa61d585a4c25a0665e956a99ae0d56dea4944e83b7cad8b34ec4485ee33771bb5510ded2afbc643d92c78b84fa45ad4c29d3e4750fe9cf1a57e395a1e1887df58fadd43781eda11c0428ca780d9b907c59d6173cddb7e587d2546cfd0dedc5ec036fba3e98427b347d9f6a6fb78073de9cc6e97f5d926d6b32238354d52858aa466bf05498fded6a78be0ad1ac2d883e7877786258ddf5573be7b68d58641b9fd453cd826518df13c54911444788f9bb58d52490f98ac37222e1c00b43b96476623bb68b1cc097736711f130355007f94aaf0c93e7078d0cf9fba63d0d657e0853a79c28c56bb1446b02470744f957bab48553c8a9f710b8fe6a1e67d47ecc0d9f63d25e8724f4d5c526efd9258e7d11cfbc9380916fc1f1eaaf866f8839c7f6d77e06815c05a4e2fd6573d1695a2a84d7c9a8d1b58daf2359cff02c7c5ffb3fbcb72c88feb06dfb6086f8a62a140aa78bebc146a739636de2e35e22cc827024bae874e3b4a3b76a385110d17a64542dbf583018e66e0e14aa29a28f835828680592dace5b10e517e4872752f63a4b0049b0fa576a799b2c54ecf0c0910a07454f7815c27a5ef2aa59410ffe573cd55ca40187a8d69c531a1d3882f23aa7bc38b916fc468376159e4ec93cc1445d4170801ade7ce82422cc119ff328fffea7050e1fd624109dea8e561e77d706566593d71bea1afda50a3a8b27cc4eeec83403589670f50503aa4ffec0a768f3f6a658894e3d44b8ae82269cac2b9fc077b5ea1481faf89972e7a6a237035b331b459615210357f2aeafb8dc2d375528b28a3d4486768eaed6848e6e93a46c32d8e89e6566b62886ead2bfa1349d5436f73f85a2d490916e0b54a2e319fc7e3043e86b15f36533cc99d1a41807bce9adb8088374c2874e68c1c0e7fe969984d389695e5cf719941496c09076c87e0240b25f4f8a82edb9a9068c0d14168e592c5ea28e33d2bfb7eebe5eba141476584d3d2323039c110cd4fa25bf2e385fb44a2f41d38b5f64e0300796cc39f805bf2d96990b0d6d82f27080040217468eef69c51899cea34fd8f0c949404ea005167863d54eac0781ff8fd6bb22aaee7465ef2cadfbf18a4df655cf977beb037902eb4d2c88b6f106139061afb49e0b24f0e61d4a317bd88d0cae584c2c4ee2cc6335cacbc29d70707d7e55269c6045337eef82423c08b0fd6e10e8f195f2c843b19323a14b843ec9dafe0b7359da8fd034489f41e21be3289f5be0f7a0f695313a513d6ae94f6745883f27422c7ebccc0e32d5554d00e02bcb3e51ce59ae37065ba99de777dad5323dd323e7b04bb1f7d5d816ec7b5d2c59005854ad54323bb8d67b274e6a71f87bd40e7be58e3af5b0e3ab25dd7ffa64f1493443df6247b112a330f823dd270b6066f33fa51b8bbd45982cad63866903a8ac2bd08cf1f45bbc41f4e834681cdc82ac9f02942b7141580dea4089d07d5b6fcb6abdbd24b653efbe58868c73457780f5452c5eb3ff111feee5260c1bd7b4e319e8038a7b77b8f1f67c885904ca376585f069c5f742614494512a4730fb1adf837c333026f1ca4a8e30e65d85fca48129a8e1df311357f7998845bf21b195b531c8ece6364147a3421bbc8790e730a9b0e34a118616d0d73af7293140c33e63019e3d3ee1ed47f8cba271aff20e881710681de172263e2cb19e28e45fce99fca385906283767c3bf120589cc16cc9760984986ce478dfd3181e16c03e5b929095b216f42bd0bc96cd09ad52479b91e8d350231c339b069de4334e6be4579888cff3a7f129fa819f6c63c0619bfd2c71659aad5c340fb23acf9a75a9d7216634931ae138f11f06fd0356d87bc82a7940ef88b93efe6829fe1f0b41560cef30cf5d6934dbaac8b3cc9cd3f60b3c562d1b47dd466053e3751b113f5b81236646b242f11bf09e3a6ba87560461eb59be959f5e88e8cca7c36057f04df7f235fd8d0c6a1bd5c292c6f4ba889e386170f3425979c722160198b7983efda6a597857b967dd205d2167a5f327ebfd2a7d931383951439b19dcac01926afc0fe06ff6c3c5ccf281a384a6c13c9081da426120ef8e29acf02a86463396a55829aef4a6d6280178ea9477861cee6128c94427fa7a247051d38b3208b1a28586cbc1a090e7fc4926961bf9d47e6e52723db36e295de155fbb4a7c90e3db571e16f54b6667e641f2dab301701f7afc74553a89b6b2e74f2072c53f3186d7671e77fef508a4df92541520ac860af573f28e69ee7f6b4a7b5976dc19952cd6123e93f5f83fa429d0fe05928188c69d46af27367b377ee36f9245dcd443ef8fa35f9aaea99ffc089c39bae73de0db093301b15b329f9ac01932010575ab15331c75fce1b79e91960f91664536d90eb607b7579cc80df7c9b86bb1e2b212eb920d5461f62c58d99eaf1cc875d2d6fdec76fc4af8dbb171bae96795a2573657fa92117b0b4db4692f9a7275eb9ac4938e0267222aac3c73ca4dc187073f1d944e998a7a4a453fc05e0a41bb493e4c80368ad64629ef2b501bffaaea21e6c849fdbe5abbe1bf778e1f8ae48961a420468857133bd6bdd033ed57149c931e692d45f41e510610148db2431ca112a61eb56309a238e277c0c9d624cfec9b10db24afd2361f85cc354aafe39d51ec462e7e63ffa1121370d507f02ad8c38da66074eaddc610e32d10b49d5f48b9a3b0a162261442071606a416be341e5b430ab87bef86af2f72cfd93e2c59868dda1a40841144242fcab5df030a5a654f611c07c16c5887bf52e8e7916c7415b9d2f1b6d243fe97a2c86340340d3833a7f7dddef724073294c29653731e19eb00390f54a02a93fa28b4fad4f1c9112d0dc42a79abc75008ab84ff81f08a3c4c757fab9ae57cca565fc4964e5c93f79a313cb3cf113b6ab26516448f9467b408cbb5366bd9bb70f71fd0ace30f4dc8acb1db8cef5d43376dee0a592c31ae00a7575c69dad0abd151fe34a3f1aefe8742c8e3fd2e1f75b408647afcfc44de8d268a7c7c1d72d7df74ed87896c0eec3fc3d7b3e3ca839eaa07683c56679b210fc2d54ec48b30afb5a9b0c9a18f8b6a4962ff9da4b1d7cc3b38bf793fb07caf3f8046814a15a71e50e707a236dbcc8ef887d506551b458ef619cb65325de6c86e3ca3094cc81bb8740e1cbb3d390d55eb1b7ee03ddfbe10422fce4847cc106a5863def857a9d9c12126a0a21ad9b1dec8b54e86031628bcc6e4bb2b9d2ec2469604d6a05eaf4d71ffde1db31434a08f1104d1dee17172d5b1557000238ba96d6b1569369782455dabd3ae0bb9ae69a50b083ae3b49ea28b8c90d7fe2d94f7f0e66fef38a0b1b404c2bce63ac82c021864836f8301458a27de6f4e0c17cb01dd80b4fc5778ab042fa0d2dbad0728cb8656058f3c7e3ff1fdea806ed6c1bd0bd094a04f958a76aa62a98c2e809b275a17c12f2ff2b3d40b58224cb08c674886edd7d45e3c6fa608607e240072519716c26128fa102a36c54f131050cdf83a3bcd95674b50bd8d1f7793775839cb1f11ad287868c7ad0822574756e93d22398cb95588a2434b4e7a6329e0fe7784cc86310ead699dff2b5e27d87e9ee1e573a0e6c75be76e48215cec3fcae9da3d29c5bf704249446b4ed7f136089ef672d7cf885550560bd2a016e369aa12241a9ae2f7071974fa7ad08b9f6827a60452755df371845fa73acf274c74a7dc1891371273b257c540bf7d3160ba91178788994d94e6e7ee8b24064507ce50e3b951c5827d2166f1602a8db05217798a6ff372f59889ecf5689383fd9baf7a20246b69c2b83e11783e13d99952084776b3c152f579da4b50ac73621c800a9cf4660887dc568faf0aea9ffc7235a131b35782ee5e45a87b441aa31fdcf9f76ec40de69d5984e18ae9eb33ed8e4b7d62afe70bc6d36c1bd88fa67e4e042e75699d804f4312c2725a0a72767ed43546560e3541f9eae5f3273af35e624958b2216cb579871c9eb10279947e9b5eec05c0542ab28c8c271c0c993df357cfc3dc27924e977ce7170d4e1d11cc550fdcc43b2f437a66379c820b1380088b04f0340e9cd0914429a47b0de808df23e8fe6c74aa7276c9547368729d57fc58775fb7cd6e4ec6be2db32c01ebf7404adbbb99262ff14c0d97c839f7c3ed1c65cb66c8949f78f1851aa5baa78574e1d0de5cbe5fbc46a75bc1cc1a3691d83f6d9e69a942fbad77c4422838e747cbc70adc4319413dbacfe13f48398568458997d0569f0eb7c9cd5872c46a6023df0ec79bebcb8c18b6a31d462db6dfe96e1e1412cfaea6a698debf76f07edef926c4167e1396f8f840173d789e5cda680b37caac4683f0721a0f72cd2633f35d2c514234bcc56ccff83b355d6bdc8c42695c42a63250d5f4c61ace3863aadb48a1499d5375a1b3fd50a342e730f38793a6940e398369a60a4b018a9fc31d336faefc9e7a7c127fd8738667492462f219395ebd00c40c2e167d575bd99d0c7082253324545a3361a0820a36f1241f0e255f280fcde4964b458e6ae717ffcc3743ff6868e3180d5a0f3f30edf444ee9188b57b61d504d84f7d7dbcd9cd9b67dbfe0bf2f4e929a3e890dc0c3bd882b91a2ff02dd41fbf32baba75702791c1d521fffc42ec71b094a613718bbdfeef124847b71a93381767bc036f0cbfc3c14338c9f628529915b57a3c79ad43cad075652696f5baad5e30805d74b2f9c8fbe6120a3b1f4dc3e0975a22770e749e7274e5853ff7db21bf040bbb8c75bb2da175b479b8bc9647e63914a50c5000df2eb0c530a40474f18d1cfd5537d112f01e7c7da5357a919d856fb5273b6b8e9272ebb50d6f1159d37f4c11325cbcc8751284a74aaf44e8728ad087b7bc2e7b8e54d91d091994f9822e3be2b70218748b73bfbabe7ae77eb12200d5ecdbd5c9c2ec817bb53b02064edf8e36311268c2b01564255378fa85e6ff7cc549c7fc6af227719a3000ff1b0b204300d647bbde7e1ab3965426a49e11471e52f54f564065cee3f4ca4003216accd1bd4c11a614ad666267a745a6aa307755553d81c0ada5bb3dff6325f3b763a243921950098ea4bb4c7d1f455d9a1e7ee75fa7ced87ccaab8e5c06279fe641a3f7935170f6834b73fa9361fbe6fbeefc2dd659e7bd21eec8b18ed6195044c75871120a7ba29bebe318b7e96956c88c6bf219d4db270ef2f2a2d616aeca0b9e2b6861f542bf990b48ecb39028de9dc5c40b45fc9bc3ef0dade4510e7ee9b687951ddcc983e9b83e91cfd5305e51eedaf7a7beb8d58abd88b5968acbf4b0c78fc67e498851e8239cf8dd2490892d390d9a4c5cfb042397b791253d066fac129503b0813c5e8a681f1a999b0a0bde1ef8a755b39d0392bb01725c7c1a6d68a47c17059bc1d55a850dd852a203f7feb61a234a1e5a04e554af9968e82c336f4299b7d3220a43b8aef40219a141a6de38d78043653362e68ee32c73bb36f7bde0283d91f73f66c6c3cc70e0a8c5740dad035ddec3e384724f18ee17e3b3d0740a4aa539449aa27df228d64442ca75c26ebf60129fb67cd4f99f65ace6446bcf9532625b9781b221bbb949f93f323602f03395ab2f7d96e36f9b7a15eb6848a0aba4cc26a70aca11f131f7819a4f17f43d08a21d87e5246733d494606729d900421be124ae4feb97ba6ef957dc35ff284ac6a7524799b36e25e255b59d6da7fd2d98e8624357c255606174324a5fffda59a712a867511d42c3aad03bd8e170512ad501adf6fe1e5cec630519a8e17ebdd0e7a3602833cb7436fb3e5d902a9c06f4ae910f9ec2c60e522834c427706ca8ab03ba39a61b61e3c8dad2462b1b841ae75e7d0768fbfa66246bc57f783b228a4528397ce61d6d8f2d2932e821f41d81e375ff2243e2edbbe52a9ed0dace94055755e29deb67aa09c39c33331c527b400146335873362520390d7ce962d5db3a9e0f45c26a46f300ff5b6e2f5155747ca6375611f1c3007f911c7cdf695cb3d55f26990d092edb55c7ac2420c4dd900d03f1f0532adbb0ea5cfec789a91b2edb3b87c529f63fbcb8cffb70fd865de7520d440dd417a6c76dc04ff444c4019ccb16f840866bb30cb5fe60db4e09e01da8f268778d794ea1396330c75a7a46187d12dec01ad98f3a49865fa6c7bc33876a6f7aa0a7036e6429996461507358285bd8882cdb37ec1faa9cd76e454a94114f60693e88367a07a58bc7fb6661eb178fbe6d5f764c692382b89220dd0d6b6016ff5dcdc2584af433a09f667ab990031ca00c338bbbaae8f8b793ace7eb72859273669020edb0a5f1e7f2ed9c353008499a8bee9df3450a2e7c19bc6635f670025a60784f9b548b8a6adfc00957cb359dd2ce5c271f18e075e529b908c1be1d596ef20b0f3fe2d199983f6701653d7e88b1aa8ed31e8cfcdaea814978fcf04c6fb01b4142b7b1a393de4231336a370557f74571a4467b723628cfb327e9ca2c8240e653c9183f8cdc1210e3b538a9c40450869b8a8f089983f9f23b386b421032cc4c1248e9e65595397eae856cedf483740972e2aabd0f8ff2a80339958e1b78f58ddfb2cbcd1fe27488c3d794d4f338bca01b22a18e788517eac368ca8dfacde6ff5fd199039b176d63195af54a1708566118ce059380d983136a11804943149b3437b86fbea09099b4733947b69b1bb1bc2449a3053be2d3569d251ae624272d017f8627323eefccbe485d3c040e42166e452feaa0e10c8638049ed5825fbe130e95cd799e219e9967dff3039f5e57b626f0b912d2994a1104cd41cf6307d607b81f9f69d792ebb7954f1afaed0422a0fdc11fc38a943cceb93311d25c71bf05648a502a52c149e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
