<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a2f36552282f95574a7fd65a5ad77e4a71349b3437bc1b4672266e244cc8b4c4c332cac2e5879f98ffaae5bc092d7b599b1fa15dc60be10aa6bc092da08304745d3f0bc3ffb2e9682d4205112d069e60d9e65e60a0ade8c273a57f615b3909b2816a317ba40a293df845236fafdbfa4418ee326a57ffc585b143535298dda5c0a96593151a835172f02a633df9672c3698bb5a31603f5ba8a20501dfde7a4616ce81d867be2485cb9685b21d90c319445b8b8b75a9dc172bbd4a9183b865e3865c535fc6c5624b62b45f0e254429b6d4b91873154e6d1558c44d593333b0edb9de445a2cbafaeaba290229e7e989997b135723119cdf412b927d1a13b2b4a7a3be435b39eae17260c498ffa66e04ff18224b8446d0cf4ca9c65e993530c4320f50026f93533815cd3e656ab90d7635fe8e495994748f6ce79a8dd453b6ad09a16f06c216364c5e8201f158d81b54e94474f70c88e7e74cd6845844b53b840ad7b8d4e4080fa2abb2cd20442b337ac611b4ef2948e3ed5ed0a0b4404974d082c06c689e456a210afadd5696cbef7dbc412548e8ed33aeb928fad947269619fe4fddab1713958f341f1fe851ccae8b2f679b4c2853a3c7fab7d2aa8cfea5e9174b26da7fc0b1d40a35fbd67b01be78268f7c774b774fbc462f37d088e806663212e428407dc7e06cde2ab6860fa24de110adadb315dbe8bc65fa4e2d4868c84b3b76d6d2e351e7601ccdd51968d97241b0053589de37489792a88bda3f78f3c9153cbf2d25c771a632816d447f00fbca5dd329eed39e0bd538ed895a952deea685831bc8c5ce948ef300d8ce1cb0a577da6acb1aed4c330d1636fb9406175c63675056cf2860f118e484a25c84b88212891d0951d725e37dd0978023b98e333f5c175b4943781d3a3fc5b43d516b2f7baa45da28681986ae460a4e9cb0b33ec9296a8d649d7774e137dbfc77d5a5dab0c217bafd104bcf85097a40a4f26baf9e51dddd1c9bff22e4852b65311f066ee1737328e87a756a87d7661419b9aa5f67a678fa3ea39aeb8365e094306c25612a4614972221a14cb7f46f1d6740b57db01c0f850ccda9c8d90c50a4096bef6e9add340ae7d6aa4781eb0484ccf8758576270f5e4615bd54b29e7ca7ea80893712fb474a1da4f69b1ef90df23a71bc72f77f61d05f86361761743e6b1bc8dfea1108857e0f0bffd1d7ec83f0b4f23e4194dc3ae83a0247608cb9b89f996b441539a37336a3a52b96ca973dca2c4812ad06bbeaab2a0db117f468f3915f6beb22a45736f486513518bf96620460e118c117f11555ae1923417afef62d9358c02a11684cd9e9dd29eb4623f8283bb862d005e05c9356401e8ef72f0d9bf0d4def00607efcf6cb8afdccead12913cc522e8e50981e6c6c0eb71364d77c232ddf896af433789e7b9880c644d9cd0e15f6bddf9c04ebc04a1261776e1981bcdcce73f4990db8fb77eef16d388645b765dff7034da67a061566740199a9bd9487f5a689fe8c351889dfde97d8faf95d53e702eaeb949df7dc4b208417b46a1ecab9c144b5b69b3fd347f660a0dbf8a79c79dfa27a9cd4f54847eec511e4fb4babc815d47e0cecab903c080f0f2b68b94435e2562c68590a3faf41c38fdc184604b6e116453f1a43edb1a1004d94c99c5b135767ae8f2c34ba318cbcca27ad7ecec9f8dc20251b0350e970479455c38d53f0719f7214ad48e032db1932320b44b93e5014743f17e42cdf312505551614a1331634298675d8f36080971599d94c52e72c27770fd407f23342c4e9fc6bcf34398c68d298ab51397fe49b452a163e7c4de3c0956b885bb4dd7bf8c36b973a0ce835094ff436da5d81f1b6d5898ca0cac238786720be94445ddc02df452d6d855109bb4be682076fe0c88b8ccfd53793a7934ca377614d5cf9ffe5783fe5155be7cd0f1560b91c7b8887446b6d1dbe33d131a9f1f8dfb0d11333183764a7925e66feaa2edf44cce3bb584dab3f82f36c6082f467372679cacf4d3f6724e1d82f8c9ebdf81bcb4341aa6310be574dd9b2bcd183c3267b858e4ac2e4d59ffa072da73a134514d8acaa63dae2b20b36ead32bc79c8e7fa130402a31a7e7d9035132e3c201190b99758d7370c21ba98c8bfdca57151662d7309fc099089da09a8927be5a09ca2e98972bba23074cbcd55bf1e036e0f87be57f144451f5272739e7404b6aabe5bd8244eb1f99b145cdf776174090875a231a1312730b0b3f953d75d624764571e2e8ffa94a455fdfad52eee7422940a343f5ff7c774d02599a4c8b2068a1aa9a3306ea7bd64607d0b9f2d1b63a4f2df2f3d4ac47579ec2449ea5ac793894057ed73d944ee8ba5a617b9b5a769160e868d9d183b5ce8b15d11af1437d71e4b5507d1dc1db1c9c82832d9c880e92f44dc70b74ee9ecd1d36684a9288e54f7d07a7f199b335b4d988cdb0818acb0e88e21bcc47c56c09a0a5793cbc89253647c18b14cb21555acb2617dac23f932c9bc8da292201a31c7eef8ac9dcb3d7a7aeddd8acfd71c888aeb0ebed3f85d38b3e2af25e2a3985da852e7c427606665952458221b62f11cc423c5f4e7eebc8900f1c49bc8cff46c87694891c56aa6e445685d6bccab4bb9c3558471f2490afc6b364335857e7bf9c1cbc46c8295d5d775a95c8d0fb4f421c2ef01d5948d1ddbdb272da1c864c90896223eafd47e67ed53051d099a42165ae21e88503b5beaef13dbada227ffffe31fb1e8c9744b8ff11f24afb7ecf785cd6a3666ec2cfc029b84f5acf839aef45c2b0a25ade1976b5375239e9f47122751fcf5dd869413d5c7c2b8b8366accb587eb89355ad000f3b91a2969ed3845d382254aa377cab42f13b88869e717c733ccbc04cbf8240073811a0d41c525adec06fddf125aa75799b9bc667ba7d500552ee65f86d967f7d97a50b83a1230cbf3aa0c9cb2a06b329fd95db76d39975efe83991ef53fd40123f03704e328caa72eb664c413fc644413ac4279d331195a55670989297dd64813b980df146f86296681ada2e204908f7996b11597f4ae9bc36fab3ac78216b002fda0eb172f19562ee349f1038274946a9f9092d1381c329601972f781b37005331e08a77f2eb8f53bd5ac17d7271948d1f61b06148c7048289e9c0416c77aa831b1a272471b4ff7941322580a4903bd8f19ea2f46bda79c90dc2eab0c2345d130e49f43d5cf6395b9df2417a0d089956f8a768afc3dc7f2f3069b71560b9f46c90493b0b8f01c384ae2b652e1ceedfb0eab506e7f1776b45025cafbb7b777dd7c63c1a6c45fb2eeaa9b92e92296d6b4165497d7f2fce17c7306e9470c034bef2c2fb99986abab22b82403924773bcc575e8ec8d5e39639bdc893ec2dd0ea6e22c95e2a1739f2a81fc64460d6291e65ed788c9335c506baca4f4b3f0e19e4544b6401cfb189423cf3c1bd758f768ee8cf1086ada60996f8ca6894cd394f19897794ccd15e0294a611be20efcb8e20930b9ffd905249d11e2b464f7828756d097756cab5f0066b0f5323dccc9fbf101f3675b96aff597efea1e8296c9c38c07d94d849f30f5edc7a36699e637093da55e7248dbd3937c44921ac30b15d5fdb1181b9d087eb7f052bdccf669ab296f99c038e2e500d5cae428479d0e299cd8871e4b0171eeff4c144abeaf18a083f6dd7a18f64b08bf57ce485a8ccada50c5d64c55d9e5c403e6ff013b28f818e80aa8ba251300b53d89d8da7c2e56fe2ce2205486fb503fcba1638bd309baf653920241904d4aac10d01bfd107c25dcce1aba6f7ef006c5240bdc8b4186868b9bd57e75ac87726b83c91b79e097371524918a3bc3976cb94f4c07af79841398b34e2f2c1d0024f9c97809957247fb16ae6c19080e50ddc5d8fe578ffab68b7b6a8ca5eb400a45beb172fccd8d187863e2778e110bc323bb56dec021e5cf0d0754172a5b32638f3d0601d129fcbf9ed88b5b3c3787522278d043cc20a7ef0676bf3062c86b81b8cd1272bbb363e49d24d94bec50b59cf9d33f29d0839ec1e01b394c642dbe72378786995df5a119e3de966aa34c8c35d7785267e7faf1ef869d98d8a44b8e0663175367efd3d2f59eaa69b1f21933108579aa7039066307068486a6d855176cd8b1a8dd6ee1cb60fbdce7d7ffafd007f2f9eaf629ff2440cb402aff413ab4b0d56b43d0683de198f75cd892ba01539b927c45c57678c22d800dabb1d6d5812583e46b2150604f88ea9b3ebe3375335aa9ad01e2154b0e8286fb11e4cbc37a284d74cefadd0693e23e05360f1a0141e837adb5e13b91abe9e72bb4735e27671f711e6aaac3957940c4966d7a7a7252f1f66afb09f693bde629efc1bad5f143d6c925752bdf8fa4221ac15f0e605491c0dc56dba23e7fe1dcd9676d8380ebd56a37c216cf7d3d9b40c7d053becc84e29d9194ff937ca4b2224d65062766e0f5ba7bce7dc778e222377358c02ef7a75d6da1d2e0046bbeb8630bb9d56f095f1ffd0c3d2c83332793a5bb06a66564996f3236c6f4e5ef2db497a12ac31cbebe70dfe8a415b94fce4f4ac30ac87fba5386580dcdcd13351055105e6a5b997de1c83a5ad6a114fbb779828620395498e7b5ac7aacc73b01d268e76fcba3cf4203fb2a7e5c4528afa67b6a9e4a801d93562bdc795c986603088b4944e06b44efd43a0eaa329221ffa6c867a64f80ab71d1c27a50c7542cd59c7dafbb1b293dd1db32721c059037777adc394e65cc7ac81a7dcf769bf00a752d7065bcc7ee4eb7d483d732839b3080560f0de60e06c2f6218a2aae43c298dba0d61dec920eeccb319ffa60128d299c1a0a7ec5822d57dcc2e9ad9d9111b4206b554d34121eae3f812c87f8194da0915e3c65c2e8c8186fa75fa91ea5e45f42d7c19f8dd36080fdf5c9b50f7df4348fd9d4455444bf1e7fccf24ecf0ef9e2545906dc575236784f36e69cf698f2da7d5eb5490aa0ca68591286c4eb4f003cd256bdf9bfda99b51051ebb2049c6831f4789b15db226e2eca87f82e29f6001b9d0d434e12a0d597526c7306a834ca279a76dd809550b8fd2d8f12b78c7c542f5f444d13fca23939ab7fe7aff96b0e4318d4692c55bdcaa786b13eb85c6b083d17b90663f3082901049d43a5ac0ffc8c4f9bc1bd10f9d1c4563a095ff807c63f4e9b01420370474625e819c2635352ca442a23a3ad8204941f160f30e8a13eee80778d500c60f14e4b432f6cec21d07674ff7761c7c9b1af27736bd8d3ce8ece22ed35689738d6046bb23233000e61ebddf2d9bba22e541b9c1a4cd95d46431f15ad4bf3cffed761b07cc31afa5c2f741425a202eac813f9586c647676eb6fe500e8243255bca3b75342922d5c93ecd8ea943497d0ce125ae955f9cbe10009bde07da8106a1482026c9aa8216b13e048e955d46920d248894243b82c8984e28ef687c16934cc29db8d225a24d8ea112d419ecce23ada66ce0e61ce919abddfec4bb3ed007bfe5f0817b95cf5800551120121cc2350d1664c148e79884e3a9ca9d1cbd277adc1aa1d3942bbd234ec748a333d2099f84aa76242a39485c91285622a05d2a81248fdc2f2a933a4eade869338a755a9dcdc2a0d626f08ea058e0a32543a28524a34df42221122836f88faf78921b46be6e2c9ff1f81e3132cd70766099489899b20f3e5d9c1a997ad836a381e7b34be062e90c758b8384b2a9b2e828c88677962d85dd229f1a3d4cc8afe49872e9ccbc28772a7cb5a2134f974b46f8befeea321a07ef0618ec7ae6c0aecf69e843e3078ee06459da59a3655e218af232411455265841685954d8fd18e418a2cbf1ef5977d26992b6770c0eed72d7d08e61b83da365ba3944da2b4839afd21bfa7301ee17a7d883e47ffc6fe6592ffd32fb5caa2380181e9b3524576ccb97c32bf73ddac12b0d0587c983e05127f2eb27fa7903945b8c1e213a37824f7ffbf55239cbf4ebdf0d9a95d8ce55a6f66856116f6f65905e397ee23f31ed2176e8211fd9919ef508e03b8f0d311c9a97abe96242739ab372cb40f1287127e7984f87f491fba77b730e6071b8a5210f8be65bff7aead4d0d322a27d63123ff25836efdacd8d7ff75b0f477a44074b03b240a0d7b78fa506cdb95c57b299c8101c9f890ae63e4e5b84dcfce502ab1444cbfca1c2dd0701168ca9ae71bfcb5352c09ef1abe11d4cd80c1f764054bcf11eb3d598a450170451fbab56c0a32fb8e92c4b1b354aae8ca9cc1deef1774a616a3e3467cd7266040273f20d33951cdc931c065d5c58e7789c13c4f3ae50899b287710f33d1483e15b60f54897176362611beaefd963828d0dc82b432a1cd4763ce01b4918842fbd6b57a7b641e27bf08d1c6d312249e043776ef11977a6a349a1d454ac05759e7172c5b606f0edb32aed9210735f2d648b443c978617b341f8e6287e1b5ea6d1965bab244802f9cf862c652b0b472c99a5cc60bf27b0d1e81d4b980b7fffb1ddf04e96affeb719ae49a93d4c51bdc5c19d75cfb70d06e372219fb3c42bfa52140c4f309d918e90df27da2c3c4ae4721dc37d65a96d5c62d018171901b32c3ccf034f194efd8cf09ac0de4fe6d98bcc7053a47d695d99182cb075dd44a60d2a970665446b73805b08160bb8c18cf985e8896ef339bc01d7d0cf58dfcf53fde730f628290bd36bbd3c3ac9b30265eb9963d02f14ac50ac118d5d09298aaa144e96a3f5855b26e23aa37c7b0e31b22ffe09cc1376318c299733a268f8b976e1ca5ae3cce868bd308ab03b03ff223499de7e94503e501a890d0502f58eafc7cb55c793ae0c8d56ba858b40c17d791b01f3972561c18cf3e03a8a9277fc95d991c710f139ca018b411350489aaae4896badfe9ba6e3b5da2d9f5512d8bf9a4957a75fb26fd97f628442596920cf5200f68f3f1ffe57fbff16fe667f099d6c56e220849c68caf4d77af2f8bc521248b4e43a4c3cf3ffe747bab044be7a2ea71dfb9782794e3c36cbed0b1c8a38996bb63cd3d4482e682831f42192d1b3f6b99a0abc22a850ef7a3586fa2e3b3cf6e90219442a85243367a7bf99f2eeb1fbbba2d17ee2b507eaa522f0b6801d29123307bc34011c1a41b45e4077cfd6545853dbd1d29fa6f65cdc8ed9bb9af26cd2895a8a75b81d4b14380381fdb57bdba8a6d52220a8d0d3cc3c7f3760a6287ee060116fcf373649a86fa85f551d3e7cf445f12da6883780d141f588138c58ada383bc4f37529bc41444966c2015f7c9669275b174e9d09ce46b9261c0ec0009c30823346356a41236373bfb91736a9be5c1f157fa53c3484d45b8c0bcc784e73662b422f287cd23c24545d6ee7ce1992e64b22616b7b1f488a626eded22814695d3e332d13c426bad06bbe1c131c367e3289731d530f1b6473c73250e2c971e97b757cf92787bcd40320fc4dfd62613b87ea874b83b7357411b3823d2978631bb0f6fbf5a77dc5ebdab1f3b375f26308a3a3c6a9025e6a9495765e3755297f11a0d9b8c581eec61882bd96036e5155007c62cf31705ba5e580d6f316c0f3a063d8ff3030d67ef74d9d05756b9ce9ceddd94eb71e9a8f0d137b363137d5ad240a9fe3a1ad50500927b64bb7b8800b580c96c0db8973b7fd9aa30655295741594525fa02fe0b03282616c482b9c67275069a1d7bdd0f1bd86b5bd9ee760a5a40724be73985fe1fc1153c59597c26a57d887db88f01312dc7fae29821acc35195d5abb40a4eed1b32982ccaccff11bb79176b1b276becd7b9aaf06bc19dbcfc43ace97c0a01ca969303923ae89804aab4169efee97f91d4ed37bf5f64bda0057d5f6a938311964f9bbeefdb74ac6bcdd7084be620be527ac96b5568373d2b57d8520b61f77b4140dfb7aa8eb3ff8d54134ab75df305c347086a11976beca7c13b3d307766f47b7b865017ffa6e8cfedec233ae5966520e62e1e6e1ca3474772392ed23f7ca7941c6114cc66d70f67b5156c3ced407b6b15b69f4fb78d9731682ddcb3c47140db4fde02b6d6fffa8a7dd0b40ae8dee459c72ed13c22d20672c3a9a7ca3b99d5f91b5e32db32d70bdb5085b53a8c8d2fbd831b72eafca7ccaf4b6b2934ec00849af024ad551dea2a10a42780a035508512a13a4e76abad6fe55b6fe2342451bd7b058afa87240534359fa41763a28bdae54443735b6c1b800f53aad3c108423ba60849fb45442e478125c4185a7dafa530e30cbe633665eabaf33e213206d2c4168733c9c085027a596a7889431920f0292aff361ba2ff7ef1313366ea8ef543ad50ad989e94323e6221accb2b89743ea6b8bd7d775abba6e042b2d41b2dbbe58407b3eceb9bd34c5b160de431b906e5918c2d0cc91bb296a9126f94eb94acd1d0995b1bd917ea5d90b6812eb57ef8b568dbe8df8d6f1b0b253d2f92d13bdc4a32f0235933ec0f3ec24b11bbeebb76927a1b6dbf267fb14bb1f9f07d534f47fe637f67271bc5f0e4d8d81613ccf8e2662c154bd10c6f2828ba4d1c0d19c0ff2f910e2debda7d21ca6847202c4577a5fe06378461128321ef70cef3494e872f93e15b7a93d7e55e9f069050d9b05caee02cdbc262de46d8df8430111e5f7a70df56005d3fedc9eac5c12f30011418c2cf46e6f0a6158bf1b7b33f9a6a2feffd0dece8e04b7c3631713a66ec42c0da9fa1f26df1020a098390239f6816cd1b8ce30c6bfba4ee9e7e30850046d4a6472a9b96586332aa2e5bb15b5947ceaad4618cfcb714617196199bb21fb6bc61b11d7cec548140a8d3e10157aa5d56e4f279e2a0d55fd90a25911aae208eefe0f94571a0df7b558222640c366b5604026e5bdefc8c25691d90477682d3157aa929b75dd28316c2cb6c231fff72b3010d4a31ef82d089e58bb0b74120d45795d57cd24bc611921e125e7b6fca4aa907804fd0761bb961d3389ec727c2111b1778ecf563435f9de64c1242387d99b9d55adcb834c827fe124cb83f92aa196a162a290a1a6a297b5a213a5523c42c9e781a29a79383aeb2c0aa609035c0e4d84e7deaf5abaa352f6405efaf4b219f0fa228a2a022bd119a01a9410a7fb94337bff6ea021eda5b2305627ba821eea0bfba7c90961351a913eb9e536081d02304138d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
