<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ba230c0f26bfb1f7520e1138ea550b53f880899e26a27c2bb6c128d1570c46492c65f50f406b07402101d195c68a9941cf36778ede81a99ca9c7313196b177a49dcceaf767c68521e062ab894da7eaa3774dfeaa254e36c35b12607e9269d1063bdf5782715f9f7ba9ada4e43a3b625b44563429db6cf8e2e5311c67379d0a6038102cd75968e849efa97a7165ca7bdbe94682afe479b2cc927a564aa2e2c1ebb62673b3be6c16513fdb3f44b5bba367119d0471b94f1098192eba443313013298b6fb44c0e4c92e9e3d82cdbdac27650298b8921826d275a78d4a7e9331b46fe1c803875c6c4d2baba9e241d0db9f4153fa30adc2cc7a000026bb644625df1dac1623684c47fb17aea0880c75cf5f914b19e6adcef5a74df5d3654fdf152745e2f346aa9dffdb8e89a99f59a556af3000fe0d6b4b525059f6875f713e896ac4d65b925ee398b4afd6ceba4c3b17c7e2e10a97231cbfbe89812e6ca40f9efac09c241d580a9f50ea565999b0757749b0510d02ed536130d60c5726df3939c8a3320fa7e011ff37645eeff219e9747f1c217c0af74e76c48a072e1a4a56394581026bb8243f38bfdd37c1dd62502bc9036a1fc6f106115f9a20eef4cddbfa46728c055ddae4e2922ab9dd70d978ca3f7ea0f2aacab829ee2640bcd26e31776d0f76186e8519c7aba14e541f4936370bdba3e4bd5c0dcd05d1464fa0836ffa33479b0b205dc69a873817f5d2406c7fa73dd515fa9122820f5bdc4791614144a841148584456fb42bc693b40d8487cb29c0f43ce7137c09b87bc7bbecaa39169e9aafa839d6cb1bc11baf96fd22eeb2032ee68dcfa03ad24e0fa331c5ebb33928adf0e08f37beba96c87ca4f1ab61ddcaf59a0db499a2e91bb65285990fc160d52a7c950d4e8060e0faf17b052653e14bc6278ca65f8050faba717429e23adf712f91760d440fae106348ac59f4310b68e39ef26d68ae92ea46d7b61de60683767281768c8099a341eb3bebfb2bb6c1267de755c216972121f320a0c79d09a879c98790bf1d88b406ff9c7ccf45f7a6913378e0de6c334de26b234eab4c32012da236a5f7a04515a240be4b203deaf51f70d3ed61d4ebd2851c3c2a6a0daeeffb03895ed6b9c0f0c185e0169d840287803cf049688c5d821e577bdabccd9c75cc4de2dbcdce24354b9c14cba014ea81e72363ba9d63f5c70636ae49441d95ab32a305626f66e9eeae8e1a84770361c13e011f091e079fa997d37a3310e2c32071d11542417c65217e11fa3f68e7a3c8aaa38919352c762d14b990ce799d428ad4d11b099f559f47cdab5f437973c7e558b89a5ef99796c1681a0ef3dc8e09d658ec1ae820a6f331173997cda41f1b86e013cfb726e9cd8fcf8cc57fcc7769fd6b8498ddd0da3683006c338fef3da53de775914e8db19c55f0899962196d1a3bae5b3614438020c530cc1c4330afcc1d48fdaa794d19ebab08aaa1272da90fd5ce468d8a8479c55ebcdf8af760d849a86fb86f9a01e387a63b6cbb7279564290298ed44aceff8200c49866e519111c35ebcd55747da1715bcc23cf9cbfaea88615d8d836ff1613f87a97fce53ac9245a25b5a8be13648d2f3df400a6dd5694632ec0ebb743461368e27f8f7f9dbd3003f803b39fcbdb50f122caa4db9e64830e76dac4b6788507a927d1f3e2ae37159e35264cb95ac5affab7a77311ade2b0bf8506fc9306b46a248fc6587e041f04ac41e7c196368112c69de9cc950f97712b7e621c86b6d429274958705d98207e1dac35cbd428e787f4ae1798d81653d188694b8792761a9bd9b3c33a72006b80e9b2d40b99b701407116ee233c20e3700d2747a199d48adb55659281be5c011612c06e872a6b4c80a1d03a7936122269cb3567cd49b90861208b45e1f6415a225c0bfcf8548439ab9862ac0197f9b0534593bf50d31b7ffb906b126ae37425492dca826d2481a018910f3230a4dd58209f242aad52b106fa8745d23b1b62574ed8071eed78dc1be4fe9e74e380c090650c02835eed3b3cd79eedda46a92cacb79a4af14fceb10e9b4e21417fe7b0dd3ad4584ac201800d7d8e2e185b481abea80b5fd7bba6887e00823dadd43f233ab24cfe09311331bdd54c2d2d791939d72bdb3392659c386bae4e0a0ce07094a90dfc71c46d1b4422df52b8aa373ea027de1c2087bcb3ca630c9152765debd26260b52491d89cd9b62c54a8af9d93230c9c54677f91af5e4d2772ef07b82563561622a52f4fb071585f9ecf4ca08ed58002745520321d4c61e863366baa80c2fe07f5a6b822244a0f99b0c1975e9dcd7571df5459dcccb7ff688b3fa1b8a5aec44c72ae52cd6e05d2cf8e070f9c71f6e2ca1f7f98a980ba678055514c75b5bb8343d0b7e211290522aeebcd1f91e9e09958f47aa7760decdd949210633cd6ebaf3fd810664f5af84171c41725bd164c14a11e9fa02a2941075ae96392311c624e5d387165f0fba2b4c3ec317d6c935607065f94e33b1681f8e979e45f06401143aa204f5089639a931474e33f1d797c8f882486abb4e9b9027be498595f3ddefdbb9a3308cbd3dfc39bbcbec51207ccc59dee090728ca4840f9025ad2de1766cedc64eb36e7570ef83c4d74b6127ccd71c97695f6068bada1cd1e5b73be1a17b8259fc03ec3281903d9091814cd7564b2446584f48e135177f8a468a5c70616e4420835284d942397a9affb05cea59b661084b120bf447727d7b7d6513acee4d90e73a5023d66823c810ff8ffbb73b456d61f00a95dc340485959968c00db0dbcaa4e61192c95d3f903f02de0eea7a2f0c251f5be7043b88cd09f877e6a806911c042724f752e64f9680cbfc556434f154f069b31cc8e80e034839481ead8937de31202542f4f7e1bc08f75238aa6683536d6bf6c59e950edff5f9b4b184cf7e07e7887e3b625ec9a54ea15ec673de249c242ace4e40ab2b6bfc32def438c681a6ddd5a7e4846c6de5b52380d8f7b15800a2dc22f04f99626e891dd463ba638422e2e5ad723db5d56eea3e75f8d118143e4d1f489f1941789184d5345d050e4baaf44aed080f7f9592ecbc18ef555b0a27ad6917f7ebb8bfa0907255d0765c0e70a97cb208fc391b1e1a2175630800d804000119c66c2da9092612a5cda1b8d0c32eab149dc021409ca312952ea860990c59aeb40582289ee1eada07917b43f4ea2db32e67435b00125a3be0937976cb7fc8b9119354ec9376469cdac18d46d582e8941fd8d450d572edb0f51459aaf9fd1f8840718fe7dd3f4df9cabd670b295d094949d346a0c24ccad17e0e68c312ecca099f0dd0a4859bf39bfceb4c7bf709f7f82cb6f502ef650a9942394c0bfd94d49d5b817636ecc9e6dc7236bf946533609a126b2ae9cb496ceb06cda8dd547690578b13fdefd1d2c07002fbfef18407a9a3d462658a698e0df41d94bb6294a50ac91685595af84b5d47ef6b2abd52ef1866c8fb60f4dadbc67b7d622a8a8594a420b83902c812f8c42f24a1b2feee0e7b2ad495b4545e6cc88f1255aea8c2bdd1be36f1e6897d2f5ee53b1fab924a5d1bb48f7486efc1ee8e40cf4a03d039d448fe4a9c55e703ceb947672e7a1974bebd6c458045138f2f30b3381bc5361b8243b9322e31250840d78e0c079b52e120194adf470e5385500d63f4e0c3441d04de8ade11c10822ce05aed9f6479ec018399016a5837d66b93a0256414a654adacabc4afb5082f90ffa1e4b4a4a1fb4386463aa3046aa37d7b1a6beaebe3ddc6e34f1b0e57bafe5708f415ac65ab1e96d887f21f2bc39a2724ff480b31e2af9d4117a0748b8c791ae389b5a0f616e0872b2ce1e43fcaac376f2f1a3164806a4dd4f51ed34fcc6828f559b5ecf1dcbd344d9396de9e73b207a7c518a25c5d13c6be67bc255c5df99e5b276f5f31ee1830c595a9c47d94629f4cce1fcd7e7e313520c35874a620ce607d3319db5bcc10c528b7f99d99234b8d290fd092ecc7f3eee8314d01228b06fc1021387f33bbd36732445377107b5e9da2a8f0864d7f95e0f87563a99c80bb499771834937646bd7970dbca63d92fa9ddf33c869d5ba00fdf4ea3c5bc2879149da2805527f26a04514a53aecc909088ba31798cae0e4ca706bec982ffb9ba83889b72c88448539f795db809df560b43c420d11037d7ab75a775fe45290c432704947da91e55329e33cb58460a713e9d8a130dda7e294d0aaafb3a3da3049c5ccbadbb137353f2af17200395fe8e05f6249be9bf6d2d124e5168f3cf211c0a6a1f50950954e5bd8eeeec5db19dab5ae71501af21b48c6dc7f3cd9eb946d37234218f057089c8b217c1a23eed6a7ce8a2671752cf5aec931a4f5b4d18af1cf296be3b9f4eb874de72a0d500d7bd0c5fe5d272997a7ee7655029ade704fea740c69aa83daa6a9cd30a5c3bb61b76acc08dac45dce0faf803ad267bab77b63f936ae03b2292b5255a26d7f3d53ac58ad6cca4c224d2db8078d65c7fbe9dcbc4b96ffedd16a7860a6e25ceda90f65830e5af622e8cd24b39f6c68f39b6e2fe361cb9386643efffc06038463551fa5eaa228e3f67747bdafd478273c0f24ac22e9e874fb435c2b26821906f2e4aef3e2a32ecc70b910713af6442bb8a5f46a9f05fa321797b1edbaf9b1470c905c245bc5c5712f0be2c7a6f7d1901b7ad7664ba7772734c528e7b550631dbfe9d80496c74d433b2c9a8cd78c46e320f6d0c243124f9f1956c455d2263a1d4735040e0ab26aad7dd3da0cf699c01972ad4975d2c0e87ef7354f6a643d245ca1d40f873e05e304b689b6ac0189ebdf3921863836ad0cbe363708a70b9bf983c5baf32b3dc2006e99e290a14d3eb427a1f5534c872757df8196b4d1289b735fe85e429fe2ee0ce0f755ad635f0d1a1cebfe40e90c6b98f8800359bcbfb30b0b9528d8089207c3ddb4a154eb2146af961fe6877afd950c60a4109ca97d1e1f9cd54c56e79be70533ba3a232d3db1c3bff57f12f4574dd94f7c2d8c6d3ead76e76706d9c1697c0d261aa2900f8e50d23613ee1bfadf56f49a5367aa712ed51ffabb5721aec85c1f53efe4e24187ec597e4ca9e023011cc320c0d30002daf06d088154a13acb9e4fd921cce2d07375e6c83530648a762fa76e52e9e3595cff78bf7fd938adbccadd323919d9f83a9dc12f65e180d0ed9f2058cb0581ed058b5972fea70b18c32d4be2ca654b568a477b1f8dc81a73bd2ff261d762e28d4b66f2750187b32e18d8251b1db4cf1d63da8a7cab228588f5211d88dd683a38d05f1c4fdc41be65290a9439375bd02c048bd781c1fe250256ae39deada9077b1e3152c4b772c12fd7ad60113bebc2be31bc91e6048ed5c3379b6d4a6824000e992a023d4040676fa31ccf5cdeb94e5d696ad07f6a458e686011a84ae6e913eece2bc1250efb03239bca9c38af1f78e52d9720ff39975247229c9da8fb27495fecbc0228170ed7cfd8a70bf134a5e09f549dc7a960d85fc6054824c7002fbefac47aff8cecb9056e450212032ce24aef445ab79aa7bcb7f4b06bd5ef1fbfe80d89ce68e7adb4091190e3e7971efda3d2a2a398b7602e5364a40d78c6b30a78cb778ee4c51b645fa7002ba3e07725f0f99bd2af012a3295a120f1b06a356f7c8b32ed0f6e465cbb1268892c1bdb2fd6e1e608b86119b9650744fc6d78e229c948007131e4152c939a8fd37c665786df62e64022f81b20df681ff7ea8c85a05393dbb067fb4dc87081c3276e2108fa8e430e02ae9a01598053937b5d6b3bf4a00245c0cbbf597fcb5555ccfb4cbe2751022e4f203bdc249687f7f83ba8332a07ac5ef1e50ec31ef56e29fc863e1513eaea274b7bc67e66de20ea8e313e56ea1157dd0e8d1ce2a7a419ef014a4bf5b886006ccd7bea7cb8c9b214ad0f87e149c89c7380f1fce992bf8b99b32269ebc57a9d3603368bc4239bd7858954504e02460edf60d83a010a927d653e30969db6bc763f4684a611affb049463c7eb39b0b34c3a31eae64a08ef94548d6676fb562086339b38d3d8169496d5dbf19c8fe06aa2aea260b16d6fdfd2d38e7006d00e5bb929e46f41f3226f01a6fed911ebd10cdb58ab8448dcfa5a149fc333d282957f6fe863be5d5774b242e544cbc1eff889c826222df4b369f9d754216b05f45b565600a79ab1b50787921c5420ae9bc9968628e6daaf5537e98dce005be315f5b5b69cda8698d1014a17a382fa56af6682f081d52504070d11e51f519ac52eac5995d28e5cb9a105df970d6815aca13710e03d0553b5b827728a5c0ebd0659fa2c802b23f5331bc156016f1581f94d9f8dd6a71b51c688165081c09124b9f3717d9bbf32444cceabf2ff72a7dc8a3fc281e7945e8beb28f9a11036bea4b8b0301766af16b79deaadfb02aad4025009d8f3a706bee65fdb2408a9d22f8d50c5a1d5c6002b73c04fec07f09d106f6454f51ed4879c09df405e285b1ff217b367bb924423cd4b33a06988e01d61d76bb30f684e98a9dc3c573e3030ce917be8b73f100f8c85031af5c25c8b7c08b05211d83502f923ae3fcf9943e5d9d1da7c6da81f1441e21678d4b941fe05e420a7febdfb654d4262b770dced20e752ae5b622e12b02f774ef03d4f85ca4cfc20b36217b8adcb28960415c2113df8a4f658d40693b0f92c823c9353b088b77a56f65676e85f35b73e9d1ccd94577fd085c4cd83bdc96750b7bd1b88081248f53a2ca05aa4272b8ec0bf312e06b766558a6444fde98b4235164d8b5fca66013b4cef4a9695d39802fcf221fd6ede9b345351e55395ff1a58be2e1293e76829e328aa94e5f2e59048fbe123f74322d0c0af2b427f96916436d159635958f1dddf66d27c4284f9fed177b3be26301f8349a10d5c288d04815432d34d603fabe253b7093fea74bbdecd0dc2c902e1201269fc85b51c42b5e9d1e73cebcd942e80c275b69d6daf0214895b4ac7e075f485adbacdac2a1aead97d39804151df6b37fb89118b33db2f7fd4b8fff3c866a63955ec6f7ae2c1ef850678ecdf3774c497ef7fe8427b9c3f69557e9361b755c8f15b7cd046273cb6a3251a569b9d2bfaec2caa7c48c3d46e982d7b19205edf37d032117012c30283cbb63a0b64bc09d8e8dfe66f64c539dc68b02d3a8b06479c0b23ab3acec5b109aa5e42d37452b69753fe4851dd61c1c619b90b26461a52b77fc5e077b32285aa16e04d5d0e16379f729801b209c4ae78a3439f5ec1b198931a50a635869b7f74764ce334b7f47379ec810f9f55f1948ac684bc9552f3461ba6286456ccf7b6f2effbf763a9d842fd610061a757221270078b8d50f2882d08dae2ae1441d9a3cc687986e6d13e7720d29432aef8d8cb67207734e6a96adf3a32565252ef7146e57dbc69571885838d3d6dfc814151a5849fd2c895305039dc56d35d8a745e98b193ac727ea8311753004b884fec177329858f0a17e215c0d50d73380656a6230173033a5ddcbe12a2ecabaea1b64849259e786cf7ba652adaa5c43c348e39a89a1e0ff2666a35082eb7575cb90534dd3a18ee341cfb085cf3eb1a877ed70e86e2f1dbe7c2250b49db73dbb6a5cd43af396154052b5ae91375243915bdac1f0968a3daa9492e1f809400251e5a6f5261f98dcc0bc170cfe24b93e492f21e56c78c830f51b0e660c49210606b0053c63daeca3e774c444ef422d9907b1e69aeb039b1478b03b300510be49141ce17bf166e7362c0df226e128ae387ea20877c8c2a268de635c66ca4b1b6fbdf5be5f7349befa54dbd017bafd699c8aa60ec369dc8bb3451ccb1fa2f3f07285c712e8e180c267b63b0ed2cecc79f911242a7d1693b7d4b9ad8d5ea190338a5d371895d7abedaab9b2b3a0c2c783ae59bf6cf7806de26db4b90997d0e1b7ce450a3bb204cbe8f26588de4f21d45c8d4b84911cfdf430503f2fe6bfc7150f74b73073774049eb7669a57aa9daa5e01be126ad65f56555c8a1a572d8bd3b55176b2dacbfb51c4bc554507b70e84467dcb174a752d516a999d3c68c37c7f08e619678c1db02c5a18919d5d2cdcde0f2ef6904729e56c977ae0a84154de530946c5d44fbda61688caafe18c99363f8ec162d70dccff61afeac0f1f0f0964e02df44c09c8e97a3362174e9885d807ccf366863d8da84bfd9be8e982e2a23643c61a329d8130a7ce6f66636ac6c2bd318e83d79323dd0e5f3f3b0ec3aadb291314273e2dfbc6103601d29d168829b6723dfdf035b576554d61395c60ff83259ef1e11f508f09b8f4d11191a52350c6c4990cfcc454003a8c3b7d4d3c302323cc762db49e0643b5a7672fc77c011a18ef642b3bbb2666f856257615c25018fb39e86d83e61c0a2a59fe8f02ef8cccac01a258e3c007df38b00a553b40d1eff244ad11d4a7643021bba0a5dc6669795985838d0dae960ce10e9a9913b5ac18410d51331ba232a1b774561f2210368753b1acbc4e69150bebfed12003db40aeb8e392ec8e92bf4b83fa00cf7870b01b68faad0683a58bd39d84624e0d342ac43cdb645d06c486535852df26afe772b7b8b0ae939683ac209d95ff06c6a3363abadba74843f0fae16ee26f797d36b45c5537ea6886cd5dfda09543744aa401406b49fd6c0a749c6a3cf52919a0803f99125fb1e51b5144194ce903dcdfe459bfbee8cb230c7c61dabe7f8dd0335ca1ab88eac4512988b41e247b778b6578cbd830191f2a469a93781107e0ccbd2121837b532f5a62c2371a853b74f416e77073f46406b4bcdcd61addaab35dac87144606b140f7e8a8a10a10a02417fe1c4a26831fad505834588c8f0f3540c3adae68ec3c2dc82f28e560c25d2a6c32e28dd0bd18a50c539d4c1c580e6e0065f0a71dc44e493cd93260fe70fe52aab5e699ea8ca0c8f79693cdf0eac56ebe3488045c525f5e246bbe6736d6a2087895af41ae899d0ddcef71e505df7e2e7243bfa71736d039d3644369f0ca37c7e318733088f42cdef1672851e788f3b9b47a2eddc7b63ba20b7fb06e8c9ad13ebf61a3911857ad4be1c1ea4f982adb59c4f3111142e9df1bc48485b42406e8c78c6c0c77c6091c9da9fc25d68c694d3b541738566cf8f60c54ecc5543cf3728441ee35210b8656e15dff2dcbf6ded2ec4ba9b7a7fa755cf3533147db7f6319fd2ae88bfa3e9eafde68ec0ed0ee863453e98833372eceee74c828887b77a3d934afcf7ad2b35b3289f4aa8ad0b0d8637829dbb23e733a7d8f991da842f104d0896f643a08abc9116561040231482b9fa8b42e80a312b8bee335f668f6ccb0ff1eda55688e1202315048adb868a8b30aaa404128da7281ad4662cc1f48c1178dc1318fbad0e2c90ea65c01e2a3fd33e56caced683a40522ec61e2ba036fca0bd9a6a7d378668e596837340526b996471832fab74a274e5ed637e9c114d0081006df61c87d91be47a2c2cae1f9d225bd55c73a1ec364989f38b228eecd5fa92175b992922d5c44f2a5c2a2c0e520e21f80bf58550936d1a7b8a9544d671de023d930305d75ded86f60dc6da31b0a8b23007d99bc314f248fd3087f4b05f563386cedd145ddc52c0521ac0849536572ffb88b96f318369b0f655bf426dacb7fde34398c3ddef2dd046af55ff9aaa311df1eab7b4f16c19c36d7800cdb574fac93a51a56254df1397ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
