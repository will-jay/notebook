<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7495038e4e51a04dceee80230d2dc707217d789038a459775a5f67fd44bfe6d0cfc0b9213edc50f0d97ee1d8ffea588ce0b2e7b11b6a59acb34ee042f8343c135a5b96187fc694761bd6c6aeeee5dba09868ba208d551c6bee6b38f2dc7f031507f8de3febb88c248a935e91961284329ff5c63561029711c2c1d8111c948eed52748bdae4704f31870182326180dfb09162c3d33bf81a27206553da34e6c821089c42426e530bfb45bfdefe8dbe5e41fc5ae8de453cd7b96d50b406bd9740fe7b4791a6a1fc070792958f9c20cf95df01b889ca133643d74ecb5697acd9e8456f020fb6d720954ecbb6b07f1be81da1c850297b91aa82f5dd75aeaa2ec4b2b37fd4b3a1941a79386839d32adb9dfda1c6617949584efa51cb7c8aac321f5ad239733a892d0bd708468368e9733d76f7cc83a806a4bed95e8a6579ad7787d8823dbf9533e6907121d6f05e896b1defab6b6f61d346fa9ba1b85cc2137d969e58fd35f30b561d520607312f374a1bbe8ab0bc134f77c61c2d622d6648b20fbdee33cd4b60ffd7ec13f9e04c8dd07cdd122eed7ea491f7deb800bef0f4be6411b9391c66fa4007473757af7e8c84dd1a52b124b978ef27407f7eaf446615bd3b315b3306620a74c5cc6afb5a25ce325b6188f73581b093322858f70c9b465b2767514418191ed94c61008f27540b32da9242c59cd30340edc777ea750e5790569ebc2896237b542065a5dc36c602075b2eafd8a30d50abb3713fc329f59ecfd31892e5b630698ea3f83453ddde9e96003cb318912ed185f6342da2e5b8efd1ea5dc289a37f85bb3028ec0df5b4de09f841ed9e86c7cb257df74cf0f8a0d65eb77b79fbeda31d01e75a840dba7d6d7d7edc00054bc636f6723b6cc2211160ce7557bc1f78a38a98d43209aa809ab11d8785591bbbebe40ab84f230dffe351d13bf1bb0cbb22842197577a58ccacd742d5050fcd95d67e98d0665e84a372782a3241d68cca0d280a92aa77dffa006011ce0db8065ea75d60bf6bd51dfd7b0dbfd890dc50d5f9de9bde3c5d09af6c777dd66ecb65d7d965ea9bbed7f3588c565e32f7b73fe2a23894094617243a10d8bfcec5247b940a7e059fc01442e44c4c2db456cad3b68997b56abac0beadd460b8eaa3b56dc54a555c688f2d20f6721bf41751c46529c6179600d48b1e5e16fcecfdb1f4224e5f1ba9eac72fbce1ab271e67fe9e090253be956a0a46b2846e880d28bfc9025d8fd45a7d29b19cade93d2f39ca3fcec422725b1d69393c45922c73363448f65dab219f1918e5e71f78a69dcd8da1ae89e0036ebbea12dc9343c388fe806ad001f1114da8431cb143202f99a27387f6955608b8615c258207f3da79a746d711a21e5423e4d0572c82f693ae3cac7dd463fe7b863529790e37c6668c4e2459e89ceed4f5fd83a5e91118c53eec4f1482ec8b5726571fb47ad7b87530b727afd9f7b263b7fe5fd8d514cdc24b6ce2131275eb7024ba458e71eae5e8cce93af87a4e38a191e6cdcef284c8381f5644fe0d7ad75f49bd486ba21310c9be99823b242fc2f88ce7e7d77cfd28e5e2e05d5832492fca53ec4690c403ae4765b188c013aa3bb5424c26a07ce34ad14b1269d85f60778ef2951a8741758b1a740586fe5047d0168346cdcad921151aa59a9b3e3c35173ad3fb4f17f8bcc3b016c0d150ffce4dcc2c55f52c24cc0172202c7e492eb52fdeab29bfffe9262ea4710cdfe29a603942ffcb5b37e2aae2ed9ad4a0a0a81cafb58c6f64b618e9a4db29024360601101d261d8735e9bef870ed89d254b83eeb99185cf29fb8e7364491c0ece689af40197961767b3e313c8a82553fa1c5491050710f61f2b6541d540d2ffed8ccbf64696e054e4052a49ac0213bd3737bd07fcd71a73ab6df32c10fe61a01d911dd541ad36829b7143fea567b5aa2e37d1ceade356dbddb973a116ba5aba113301e6ed844be42233eb8b581084c82cee3cddac83975b05efc6a14a4a285d6801178ba623a9d7d64541b1fd62e77d9281227dd50e8ec94139d5be49eeb754705f144ebabfe346a8da37b90a79cfae89b2fc38c8fab1a40fcd4904c486d1ac1c8d7220f8df77231aa11e69bfa723d244dcbd6714cd9f547a7cda41740d2be4350a6b6bdd517678bb96378011419ef5c5ac7f69346ec683e57407463ea78b26cfffde3d11d37b61c49b2c0ec4ed9115a1fc29737cb16aafc4d4a777adbf26cba41aeb703fffce3d9014e704862883770d3684732d8d36a46ff8e40e8329a1945595ff931dc8c8bcfdce9b68bcbb8f91788af19fbf803e6b104aff8c8e26b114db30b1f28f7eda1c74bb49686df9b25537813a80c567174004819261dddcaa34495e0c04b2f2724539667e6141fe6ed0b79124df0fe8494f358dc099584b86256ec473dec1fb8fff4a268826a2079c1198523bfb6e75364346bb6f71f982dce1a00a00c5c44ac00d46962e58b517e13aca7d336ce44c376860dcca3559976825f1b9fa6e4ca6b9e19aab1d7a19a1fcc4535dca38167bc95781ffb2137006477ca12fa548469ae6b3026cc2a7c42ad6c9c178a9c1d0845879b063280c01daafb69093ea1b3f3a2469da13c5b806072f8e480211a4225a9ab61cd561922f360292f9b9b5cab80ba3c08ff39955526381ae726033b2c564add130e1da8cbd92764e92c560e2181fd798743bea1c651639dbfc392b7ea6a42a0d5c661ce6cf69aee1c9276bb31f515ae0d8ce3884bbdafdab31033dec814d88b5b63e6e502db60876531c6896be5817886f0a2ceeb13f84f7ef2f4b5d1bb8d670d7a52c9e1d8f4cbe8d67055a04e8f131bfdb0cebdfbd1ee5f387fb2262535aa16c286a7bb9035317716de0d1116fac6624c4e1f07c77143bd693a91690afb772b25595456b140ce6f92d69e34ed4c3871b68065fc93f1cd1ee4b5402971dd32f98799ce3a87333cf5b0af360a116f15d37ef6d1d7d19b73c5367040c315229efec0a2586772be3ecdfce025439a5f58e20e75d09164207ea88975d6382d08c4fadda2c24cbe5aa9da3562224c6aa0cefe86194b631b1dc9d1a1d9c859ec2851dd6b4a3065c41750b78c276285dd59ed2327127fe76c17a4a45cd9c2259546b96643e1b11459e68de28b0b3e351405f742b5fe21328df583033b58d67ea7d95a3310eb4361afc9e6e839be24ee5c1b42ac3332fa0e2d4c20e43846b9d244555ff229e9a84a54961a3a767874d3b2d096e20e9fd2512164632ef38aa31f3a7e53b06ec9ed744f7203f9bacbf7a9815e0f929a0c2ef8160687e8a992316b8b45298a85d68b9ee48aeec16bbca3afee5f01285ae6aa46921af2a70d6ab79dea44a9e34bfe0c94fdb64c57069da418d80d5c6e332978ebfa1c768fa1ba356e6ddbb6edaf9755d8c0383b53c11b102705933c8be5a9b75058908689825e90fb987eb32d2a0d389a5bf7f3ff5bfc71654a16ec7fb9f6d1281a750aac702f26eaa8f80ee6e7b87dbfe4f26148a939624ca6aecda2cb3df3fe4e18449c32fd5923762f2621ccf929636485322557a474c01818593c60d1c2492132276a92ab9374242a76c200141e2dfd697f6448e237f048685307ffee9e4c6500e7863b59cf6edd02a0a63cc08158c8bd2779deeb8ca9f3db2428ebaa6a52d53c2305bfa94724edc244fbf17842beccd30bbbd0c53451e628ccc0d0ab1182b8b58a770ef576f09b75bbfce721603a8bc7ac9e54dc748756d5f85f9406b2c35868cbc42edd41135da6fdcff777706d2837be75f718131246d38781373cc0a4b8aed6ca8c12d9eaf2e9af776f04fae9a235006d2faf404e147b6274e6e41d3a99b08c552e1f2b58a198d40060335739013eb9434c52238adaf3c3f71e8b6bd4706e3bca3027baf0c85ed697e52fe3a20183f76de35471326198980fd541dabb9d303cc9f78075b3c4cfef4a5ac103cd8a59368875cf17f2bc9c4a3ea362c2db12cd7d635e1ed4607a3b8becac2f8ff0a6c02549c470f91753371d44eeaa426b9f68009a7f3a520fa57d99b9c1c233cbcc65da9a56bbf8416c583d6f163644196b334b1dc163c88a4646f71a67760f77cc1a6e40bf3ab37814e088f69572127174317081df308a9aa42ad076cb041154c3a5fbcd953acd418b9497b64b7abfd4560ef82d64deb66e77a37e38801c369fcb89b3db4b1f6ed3c681ed8bdad7b70203c4e8f10e49b1a3f3f9a07f27f79c7cbe8d712a3d9038f8a74959a34b032c436efec7b16c77eb7b38c0698a2aa1d31220120c3319c39a9790381df462ab72ea012f285cd50635ff1131503ea8345569dc881f8c5d3d08ead5f4689ad603fb29b9321e1e693e6e52748c0ce97e4af373615bfa2fbdc3ad39beb0b118b82fc5063b7202ca54ef603a4792c2f3434913a22dca75c145e8764c84a0411e5aa22135a3dabbe6718e3d83a06ae8de890f1ae48c9a29e9ae502bf17befa1aa83c53ae0f0612472d98bb17e6742fe6c0ce14d4310b05c0012c031174581cb469cb6b75cfaa690307201c868c05aa660720022aee0bb805001d0ed917ffff1b5c7b627259be0f05738e87ad82016ef6bebbed5b3d6aedda06bc58aeec97c63cc057c0df765bb58d5ea3a3b9ea6578c0d79feca226ae8b8320119726d54df2f81abedd3777dbbf6c13d1ccba623f80a083175b2b487181abf4006f88a9e8a356eeb79be0e43958d5088629d2d13dad2efe27866e014ba40ff80ff8b5eab9e73577cf968ce1aa324f9e91d193182d6b2a5e0088a10c7d88366bca3f57006ae59a5f6a7f406b341298c7c4889e4b5cdc93b01592999216bc032cb1572b321048c157af3fa59af3574a28ed27f1c5f0d13b4e9b8d6564c246494128a1e69d6b22d3f111248f78090f022963943560d67d222536afdda753fcd817294343b25d343a61bf05e1b215b365fd059b2f6a8f74ac683aed1da3087398e579d66f9bb8b75a62ec0d00664f4eccda197c77842aca6085259bb836e62db26a58a06d21357ce6a84c7c38373e4c4c832aafe342856a9f42fb0db8886a445db715bf90350011d6158d1dd6670ab1cbe221c9db39211eabb8cf126e617c7974e32e39620996293c6478bb95c00638267b982b984b9c25fe1a73bae8dd0d97a43139db6ae2963a6f052f70573f2e76f4a8a0f9c7eda0a79430ecc448b57ce3f5d027008a61c5dd533e015f774470b71b6c4dea2cac3bd6f82ff9779252d9b3c800be767705594672f55fc8f59aa5c49260a2c61343050efeaeb157281f1e531ff8d19ec365598f3e00487d0a6ae53026b742b22b4b0408f997e321e0bb5989bd96d1d9bb402ef997e1d4e1929d39fa70b1d61373492bdaceb4fde6ac589fdd30c85789cd38765cc6ae5e92b9cf1284c32e2d439a959e57b0f90fb1273ba362f90f3f2238f8223438fd92038c85c65342c0e4e52af4bd7e9b98e2f62d8a381affbe970b36f93344351a1e9b58c86eec4228a27d41beb43b547e27d51c1a6b76b5e0fcd2276bee4cd55d7deee2bd86608c59e1e8b208b9753c858193b00954f6fe9c88171e44765ea49f698bfcd157898608a6878eed716f7576a5e32c178c8637976de0845a6a653b8c52dafbdaae3b6a6cd162895478b3105f93d4cbf0ecb84da6dd67b873709c0ca2bd41d7fa663feedc4c3cfb86cebe01b1de48ebe7c6091f9cd7001fe0bb4fb4d5aada521d335b52ea43a2bd92cb70f5483cc697999a527f9c88538c16512e7a7eb8010a741303a0053dcce43896ae716ff121d81e02a73a93557e761a64efc3478086df106c8b26763143ad94522b844484243418508c8141bfd28982c1cc6770f28c78a4a4e43a8519bebbfa2de81a81437fbf12b7acf678202f9804bdac5e8354d8c9e876319554b3ef07b38263f54f1edc38fcd413c591f07e556adc8ce0dfe735842fbaf2387d5bf82e9f20b8a50c13c5e5654141f3084e1972e1704bc42c4cd204e7e0bcaad21e23356d0d378533c09fed7a5a25568465fa962b538b06206c0710851ef7d5ab8a3e8bb5b5e33c7454fda0ea85b7c7f2714ec891821fd88f64094a1ff4697fbcf3ca3138763bbe7e15a79bbfdbe9106ab833f88622c898ac891d5aa87b1c86abded803973a8ae0232ebbd1c62f011143785cdec8a7b265fa121181ca27126a4db863b8dcc2820816c2972c229b3cfce22ffe6e12ea86c9712c110335c6c49a3cfb46ae7444fd36b4dfd3d9cca09fc52160f04b900adfc8c0e9ef6fda3fce2fa26f3ee6a1b17ebeecf3587005d13223741529ce842527b1c797db3351d3aa9c5aa6aaa8d516415134f4bcea29d62bab45ba3b93549c7ddb46a88d844401ea5673ececfb5de6f2aa395d21bc1b096000d074bd4e83f0eff1997d0d8145beba469e09b3d8e3044d175357f4af991133fd4ec009eb50769015eeb8ad1ae382231377b825062348669d83210c318dd60616df3fe1dd7db99f30816838710b3a3b9cc405ea7f2cf9f463bf1aa76945c5da9db1ee7d9ad4584c09b6346fb8c74043a6bf90effae5e44ff40effc2154b5c52f3d19d352d97945c2e332b5edd8fbbc1d8718bd138f64b4ee7fbbd2553c359a0e1649e2c6cac16854a3b612498726e7435468727a3a77116fd58c79ccf83aadbdeb859a64e0e57ea186c4f11572b69da6bac028638305563df84f20b4c03a5d7276f5cdacd3b69c7dab00d5d4ac129a4dd125806db211ff7fa24e7357424f33c9c03de6d5ba84b57d6d5d0525b6f1b0ae71e4d36c623512ad06c95605cae3cb361610bc82a78c7655b7c60eda8be9ab7c3dda0ed6515eae955207b35503f4f2bca865219a144aa38d440795beb2698cbb0e66c4ce09cf55d46b37e34bf16ebc67587271236554c2097ada27ac1f6d931dce3eec96126e1cbdac2aa01e3ec02c4bdafb76af217a2a0495c5c9bbd400bda6dfaada8789f7f1c56157bb176aa5dda4a80eac175fc8e09cd5186d7d20c74da324c7f79421b3ea0b900062eca618a5ca655b949e209a72a22c95d1105366a047666a1088b9576036e206d84f74c2af36d3e7c398cbe79cbf8a406f47068500d52927cd55e7acd30e7f7d0028160fa000fc46a9e4e49e02090817fda840880834362fa28a17724c52e937aa8563f95001e285746a16277125cdc1aad1499b3e78f08496dcc7b567c7a7ccfd2fb2fce60230a65c662812d5eded6453e8c7327bc57cba2886ce78d68ca05037c68bc6f102e29d726f018ecb3ac740067d27c4eb85338fb789fcc2403ef4aeacecb338f35ac707b7ba482776ccd347d0d98b824eaef2310f6308eb5efe54764a0c2ae4504d55a265bc2c3c42e2394158622c744d9feff38837951ba4045971d072968cabacf69767b137df0a862eb5e98d0874562fb970a228c0ec254e4eafeb08da80fd0b3f51b720fa55a6ca7844388db19727262c69a78755547a6f3dd78c5702c720341de6ea99649a04475beac30ab451a4ded81d24bcae9d7521b11099373e86375ae8af2e7b56566e9fab6291196c3da4ad05ac192accc94be38597142d81130c23bba50cae8ea1ecbefb49b55554dc2fcfdac69285b328bda07ecc9fcb7e33338394165974ef31e71d2773eed866196141ca306fcec838cb6ac42c4df749fad5b71caf33e207bafc0ac5030ae0633d2cd2866ba27704adf52d1207087f5650eef974e189149eb17b7c7a6f94d435a61018849c6ca7c18090ee2ef1d456bc96cf9464a90cfdfaaafcd8564a7a62f416bf06df8331aefcb1d4ac6990e6a0b5390acde9833e56b9d8fb7a438e59b61c28c9693e7d45e26198e072fe1971d6baf63e29c6e49c838e9213fa5addc2af73dc9e58469904e6652091dc65e5748ee64607403d116c74fb0e84d1ce535097ac942dfd1aa38b814f869fada148ddb16d90fd8312a8801bd3efa6e4c784dd65896a56930dc1c5d6306a55f7ad33befc061ad83b5e6df940d85230e56bbd1e92aaa9135ca97bc61c820bb205e397a0f4ab6b15bd60e254e0b33877cf5928a24e6608a655ad5a2d0490edc0dbcfb8260b76c20f5c3fff9346600477f9d3d6acdb674b087a68a498311b020cf4ca22186bbb5f616c4d7c0d8609bd3098543d588dae6ed4e6209d6669cfea2bc7b6fcf3c2f3be67e440dc38977a6af9be8265e8f43416f3feccc98f8250197c89617b142bfa0674ed98ebf2cb6bbcf8980b4c4a61b8cd73b530f2a715b3668200ce5ba8e7aa508b42ea73a6c11f348df9c76417d23048030b51d15c1c4c4bc8175bc2b4e9e529f2839180da6bb0c3d0b34bd54c37a6358773184f7f85aeeaa2509ca148d1f23e045d8bea61109f12b1d9023754769663beb9d0278272ade8926e5dbb7bc957348db6a3c0e0e78d98552e3bff08a442cc1dd44b0b7daafbcced89980a1f593ddaa4f645e234fc8d52adb972baae5a3af1158c1d8272780a3759fdd7e2945a74a2fc75b72cb1e03ed37b2712231f7c71f8ac65ce323db7596d5c58f3696184ab4d967c61f04b0f3ecce25248931aeb93d04e72b8ae0d3a1c547226a371c4ef7f367cbd6085d21deed8bc0b8ea28f54c9fc88eafe3bf59f8e88d3ffbfb403d6bdc486236f140f912305e09434f1dc21c44d7857886ae452c6fe01cc271b5a8fcefd23b1f7e1a51e4b6e44b346e2119b85beb99b413c83fd1f5a3bc7ae1d3047bf074c13dedafd3d1d8ec5777e618835ebc2a5a20c7b700b4fde224038c911a245582ec84bbd209fc71fdd49cd21b1d2504a273e0ed2c23187cf21b616a34cbd906580a93e865bd5bdc7854136b5c994b704a8c796993b762328af888c98b9a601958dada3809a6564d5848036ee40edcd9dc2804b45bc09b0a0c417ba610b0935ef2a760feca1827e0c945655728d43419973d4e5fccd03c22c63e9218f8f9cf34f9f508b586fb08e5eaad5977cb6114fd14346c0cbd0eb33885785f4fac18f73058cdc19dcbad16d60096cee5bc42994fbe7e6b013d11ba51b2a052127eadbe218719b709ca7cb755ae19f3d8bea2c7705973bbf705f321324eb260db79a7fd15709cf6091f30f27afcefca202ed96689fce7e5032d8173479e5b0473322cd169b339fae52938d7659c48471167614564d806e8118ed07fb74f7d691c40a7ee636c84e6f0e7d1e31cd06d693d0af99c390cac1b75bb82e9fab923f0424d7f2ff216c52ccb95c46075f2df8e063375c91421532c85d78d7acdcd93a595457f7b5f91c4ce9306fdcf9d9220a69f97fff3a5e2f0e7eeb712c806162cb80dd0cf3b1a0b247cafd0b023f48e20f84435e9244950008e8aa45bc2e145148c722eb7ae1d504579554b23db6082a1ba5642dfcf93f77eedc4a523b1ad41c1171ee4224710fc74bd049f5b74fc14f5a33b946883f5b6b5191e7eed2258c60f5172fc427d6101832af6a038da5536af92c38890fb07a7b9ff513b373eef8fbbaad269a95e821796f801f6b48de34d4a33d162ea64d2fc682b94ad2d6b090d972175afb5a9c646e37cf6006e821ceefb5d65ec6ecb1c92e0e75520d3c2624999d8be80995537c15fc8ea20602380c506ee15c067ca8567cee2ed83a75650c12d79b9ec9ee65004330dc534896354c734a4a07659e5bb5eda4191a2e9307477a13dbe8abfea5271855338cb4d466f3fa5cf92cd30f7c484bc9161229305839160c0d0fdab850cbf886433","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
