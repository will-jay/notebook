<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d6de646bd345ef120b2876e4a91ec4a3bed4196f98fa84098f0bb5029709954e47a1dd018fa7e58b2f0f862c884f7b49a2d8ce59b351c3307e6f648909c006da9f88a4f6ae5d0ad05e9aa525685cbb5348921441b09d53929108f2e160aedb52017d626c873c1073c4c9547538367c3d6784ce995b7075fa2bb6d5b2cd5931a41dba1d3bf1dc71ac147ec0846b36e72d39ce370bfb2800f0f89df4f82dfa7f68c66c0d909aec3a217bbeffa24130fd14aca60e037d4f1e468fee8fa3fa2aec88ea3fe2e7960faa739ee940527f4f47f930deddd6f4194fbb1791a217b9a6435c60972a03463469a6ab3da8fc1b03f67f262fd052b1ac3938748184e7603ec0b4fe2f2d2b3166a5dc0eb3b5ce81434535a381b2f3e775b4ee6a64824b5fc83bee1e7dcf12513fdadaad5848b0a1f839bea9ad20ece418baac716054932b206574b2f87d5b507839ca2a17e8fb939a51a5e17ebaff228acee780ea35939f04cbff6811531b6a1c9445952bbcfe02e941b3e5e4a127c7bd7cd2b2ab462fc8912d9d12db7db2f2854d2a87a679f05fd24a71d15d1cfbdb54384177a86f0564d6954c8ccabca060d78775723dcf183e7978ed83f967c66231b26113faee5097ce93570f5b7e92daa58d3e577f8110fdeec8172ef1914c4a13b749189638987a3c975cf2c68911fa02e01a917d4c393b93b3834b840ba04c41eeb691e579fd698e69fa445c431ff2bd4f725518a9f64810a5d2fed15fc89de11bd10e0f3a3c6a565ceb90966fc18bab3734be2126fcd5e9e19999e2c4048a4ab37c704d075900d34b7533ca08f7e6c0ddbdc05a083e3b75c5eeed9d5c003eb023d55b7c9a38ac1dfa343b88b8ec83606986f08e926ab2e32819e6acb4e219ab9e492240503ba19d9ba4fd36406339b5b60da2b7a0ba6cc55b2a16ee1effb285d215a7dab5ab707a9ff2e25715c76b8a180a2a81703cb6c95562cbd9e721f145c2d75dcaf61dc10776b977ee2599c38159743c1c8ba0c164a04037cdf7e2db12a40a820687f78f1eaaf8b6e72f0d5cde2e4871400a5777fe8f8143050bcb8457bc22ec3cb7ce2bec40893777236ddf47e43cce99d3f5b8fe53f1c75fc8c55d7a365b70b8d98907350a89ff7d021fd361fb47f9e04647d6141a13e561f0a3a2de12d542fe58c33a9c4bde1b6f37b7659027ab507a90816dd4717b5eb45c35953f3570d0ca94bf96d408fae4ef2c953140842d261fd858d4f92aa078106745cfe074a0775dd7175198cf76f24943aa6ccac02ca80406822f904de456491c82608b52fd45e56c90caeb55cfda541cf5772735f339b8a257622ed60ca63fbde9a50024f78cdd518a4fa173b217c755a700563923912b37488e18522506406d52767acfabe9295a13d07a53c523073250b3f255967abcf0bdab1651446d93b399489074971cd197fb328cc33f7ca5372940ab12f2df137aeeaa63f68a087f0095055f861a9207e1180a4c2e024805fd9916b60d6f4f8723130fa897a7f82bd2e950ec58b4adc52e84c34d5f1f88fd2c0921858e315d4c0da7cd53574c729de377cba435e7355674c76ee4d0640e8cd1043d5737334b38001b271e302f7f1ac157d71d1848b1f6bf3cc27669736ee4ea32ba48fb6f7a0d96fc15e8ba72a8e165d5635ec6e02fa65db3ee84150e2f874be47187436b9c1e83efa41d81b3e9d65b0cdc82e596db63f66f362e44ff2ac97b3107c5acd2a1a5182f38532918928e57679f5fa9fe11c22a966dc5d895611c0dd8ffec3ef0a8c2495b66dcd92d3a1aac38cea38d47248ab8fef5cfdcd51d984e776aad20ae20bad619b4398f3b28b4cbc55db8ad6c73e44bf69cfc98218489bf87f88a3f8c872e72f5344892b7227c3315ddde0a599c28e864d7200967b97e8f1cc297f1fc3311ac3de90b24cf8a970d7dce813609f954dee1a08f7092f6692f78a047f26fae376ed0a4962b627559a1bea331618dd0409d7bb32b707216db19753a68cd6b223c97c0766b334a147d8362ca91e5146b0d518653b762c923fa03070d8a2433300d1ad797ad00ff363d5b88bd19f9599ae9c23173efa6029c38d8d0789194929d11f619d04095b10584ac7371da9f778236fe06262a424243f9f4f76b56fc451cc9d6de7572737eb390aa2413fb115762ee4f230f02b09181a6db56e26bb7c60d4dc475856c2ab31ca20908112cfacb6286c07ac484d1d7ea428ebb067f0ed480f5904496651ad18e73504ce43587d148cd5b055978c58015a7fe46b0cc9aeb445966529932e159f075a59da5291aff393c47024fbef2dc17118653e35d48d6fa83c326a5a69f9214466318a25cac1412d599d35a5e14924f4d9c06965e92ccbdb23cf944516790ee420aa6e6bc0bcbe2edca63fbf3788b266e1910029ea3e3129fd882ccf4f30e20c81ffd2fc633c1f78b7ed47e3bc913fd711b13648912f1a8a66012488ac92c2c0cadca72ee6b3ef3cf154512e51f9a6d0e21cd01c5f4dbf0c66388da12129f8f1fc45eebba26d1b381008e9692bdc2492c591a2035b16c451fbb925ce5cc6aa584f4f9dc204b9cf7e676f23d638a58b388dcaf9db4f93979355abd411fc00766ad53a15947546d4d5e6ea2a16026b11d14d7cde604fd585c6d1f35dcd3d9bcdd5387e98af8fd426648be419b6bf56a5b18ae3b3ff413d6142d5173dde49824d89582e0d158b477055ffdbf992987bceb0bd714bf942910b00059395a22866bbcfda75d4bd3663c2a972962924af5ab0d1ec5958cc550ea168bb78791a06225c8d40690ea47aa3c92c6c18093ca7341d9dc752de5462a512974d1f5c25ac33bfa8e96287cb5b26cea022e3d95920a646bf8b7a74c858e4f475fb8f5adca5ec9473c9b9713ff858164858f5c977c2582ea5d8d5f5c8ed131e171a56096e92ab742ebcad81f4367ca9c5243810c923c32442ff199e02a3ed639cb38a977570797b802e3414dab58448e3b286be398900c4d75fe2d56d8ae2f60813b9928e150d1e79c9b8ba0569d0b3291433e387a273cdfb548a7a3792ce829946ef82b4bca16453da8bebfb173c25d3e981691b3d03ddf852671305e9f947c4dba5dd884b6043f8d0a8f447448f854692bc08179c344a1ee8f37ed361669adff3c667bc5002b1baedb7a2161b830dd41e6be28f865c9fd2a1ce83a8dec60c412e0611fe2948e9623b183277d3010cc08092db585ecbfd8f4a9e777c7659dd3a7d63f2d52164f05194f6fcecbfd93c9a3a17497622b50c1a001d0eda8196818fdff197715d978270a828f9bbc0542a6a794af40b99a8f34e2310a4a6286dbfada086d9c9a4026ff8f0237096eba0e3ff485d46444b108eecdcd14564d5ed3b1c9b6cfe6c334a1bf9103d0bab3087030c0cc246c43e387600380079f31449c5c50800404c2c646c2f49caa73e451b80e8cda420e46c9f67a5c2d0a6bb579095d45b323776d9427c2b209f35aad13f58ca291c7a4da86fc4c9eb207d45d8abde127f352921a2054bf9536983138b7f2734c2122226ebf49d87f1cc25c2227fba909e63c847f3ee9b590bb1518449e20c13a0356278d57e820270531bc01221efc5ea171364da32ea9e7232d6b996dd70d7323ae9cad57b038392187b640b166858a3e4995cf818c0b041151c582c99b44583f0b420b3000532dd968377a5e53e446dbabf5559b44608ee63b4c89a8eba31a3c6588f10eedb333a39826e63ace0d5bd8b7733d0412386e6cb75ae842509f4dd1906aad132de196bf8b244b883a13d4d1166f422d3fc20c21de12a3d59c2f84fd13fea34ad287db6a3147c14a5daf50965b70bad89a99e932f873f9aa05cfc0e1bc90f35c24946f2215c1966025fd65db5bb15c89027220894facf6583f489fcf40c4afb66eb495b3b1fc8bb223d275cf86ff343e1c5e641f9af35a52ad139d4e3f4f61557f9f7d1fbca3d4081e4576efd697f27e52b489a4b249cc84f6d7b0929b7372bc1694f26874bb8f3408e3bfd67b5acbc02f8b67a326e6a9706b830d22901b905859bd8ddfa6d8ee3b921fac400ebd14cb88afbf6d7ca99809e781efa03893a016ecb5c5f48c7fc7c65de3b9556b73c885934119687f5d62d01e44d05a10057bee7d14594fac38e642b66315ad0ade17afde696f000f259e39b4c643a335662f7d2434cb4ee25f588fc1ab64a5b1c46d8eb637f10af8c1197d2df172ec5399906506e76120b283b64dad9cf17b2d8a9bf58205ff111ae6fa3d0c8ce9f363278c8b0b1ecbc505b1907b8891db6bada4cf05544dd1f6cabf536a00bccb1afbffaaf1692c0c2b1ec2da2b798aa30400c9c657354f80544ea2a9807fef7ab3a066ecac36dc660e9895a5ba6e88466484c48c38433b134571ad318f795de356fed89628d87096e1969b1c536f9e52c86cf2d4b9a66718966a33fb5e6e519980926358a71182b5358cdb1f44cc5a0b556f974d1217fd44990391142305c3462f4d923d208eea44cbdd3c9f61cb51f0c16dea00b9ac39c1967d98fc3c4e0fd90a1da751b77beb401f00dc9638ef391067b781e5024e30b87b963b9ea66ddc600aeab5ace9fe10ce5607ba081b0b7135e2d12783987c9f4c3310b4f058355a3cfeab16eba1e5445f3770cd46a326e78d5b5729a72d555a5b50812d734756753309a0de75a14c9d0a94b5c57a567981cebeb613b043afa3505df03bbb4c01445b86ddfefa53db57748c281f9d5606ae76fc70a88c08e1f27fde6a9affc2546daba87c00a7dd3db62c7fa6c916c71daee0965cf517c988510b3705cff5902b858fc45a37df8887f52d8492cbc2a27a8256e4e8b2112f9b3f3a9f7f052d5c102882c30d25018362c8eba8f64476cd797ebe3567dc0967c09caa3318489cea18a585107c279b215d9af7a0cc610540f79140543a1e428d5cf7155b34c3165e20729bbb6d6b4fc6b1716fa2f7dcd6926114cf6f869026457d53945871ba0159b295bf4aab9f65208c748ad135b9cd09812553415cd10f74509d54fcbe50c0278508d0eba7db0a3d5756de59baaa3ad3a4f659059a55025e0b254ac8a814ddf0eed8a8c34be3305e9048be5c55986211531dbc6d9cb9b31a11bc863c711c4b463af040129db8c6a63aea4570503e9f1137ccc260cbf44bdfc842f41d2fe52c09c92d7f6f34d6958ce545b7d48f52988976608d4e5e8faf2040c6b8b69205dc353e6b85c3bb43c3315b21059b6330f992a2e3ab1b48dd42ad79336ec1ba759bdd4270885710a328775e7295521c6304062924c1faa8f544c60a48cf664a897386cfefbc25933053d6bc2d715fa8c808dea3d8318f01167ba35f67a0adea56c2f8d10cf520c9c96faf1f20950e7db751ffbe1cfefca8d14c92b047251feaa53185a725fa4b634ae45dd4c6fcc931b13f6a83b42e0b13049e4623eaf24e39ff691b51ad704a1fa44f4f0d98d36323511cab9a2d41a45037cd26a82f5a8ebfad7a55c336bf68498a0fc1794900d271ddf3451a6484dd80f16ed03ed4af43b9e2bb1d44b41e0e1d718e967db22d3eb128c966c527a658cfb34a770a47fa393f6eda2b268e7dbca968a922ed1c256e923d7f24ff871261a31583a8258e4fab5832f58fa68e9aefe4dc915dacf82d1fecab4b679033ea126277d31f5182adf1374d749983fdd49a929ec5da859f5f68c9816fbab4fbe116f9ec144b1d71aaf0c86ea1d3bca04d3e7e97b29026e2778446e3bfd776ada6a36b31f37cb7879326473c4233e4a6b587674dd5d2ca2dc294e9dfabf8fe14e23b374c929279266857f2afc3df4539dfbe2e51c8c652148c1545faa72fc10b12a59a925a80297155dde68d0f177408e3d1a26048bc1eb76c50e343c84831aaa15685d832289ce796679a749d2da2f70d073cd099b81fbb8b3c86f84ca2610f87e6d4e59b2e5fcd31cbd3e412e8ec8b66bfab641fd748852d704c6b9dd40559da8b3175cb0759692017a7457cb470082c38924abe2de8bf5297f11bf6714ba1b3577073e47b9488666d2037feac44290c39dfc2b2c76c376012ccf9af9ccd06ef203ff8379838c9e222f6dd7a43572a60a78e8575648284819929b3ec07070538316326351ca4fe1e628022d1ef4e8edae3a901e14a33aca29a8835843da63aa7e30453b76c45b31d1dd82daacf5355f0d3069aabfe51df5c6cd45cf00c0d63fb250e603da8ee85cfdd5eac020f879b05f261f55647cdd3e946f331b666de7b2817db649530dd79d70f445285b8ed781ef030943456935246ab8f74acbccfa77ed9b50d3c7d3d416b168dfbb41d65a0a46d697ef55a3ac314f59d29313e80efab52098855561092a142c2d494aba5a27f633b0a2a61f2c1d52b681b01b5d76bf812deabda26262fe91ddcc503f60674450fcd6793ddfe2e3be8d7d959910739eaa3b3472d43ebfd221b32281e7c0fd168b2bac5f929454dedb24e7c2b22aa0b3bdcb2fd13459da4d9b1d6c42d0d9aae4547d3c04177094b33e8d9a75321b73c76b42f9f0482405531bdb48016852bf1b9ea6a225f0688756d8e0415de659dcbacabd4cd766a70c073efd2a37bc93d5a811ff30f13a87f0a94b39ebd874617d4d88313c9c3df8dd0179b6c36d7cdd156144a2145619a86564edfbc64aeca2ef69decaf6c13234ca5448a4fbec547424dc5c88e0d27f76636fea6137b145fedfe82c7d1d9b50162493549439d0990cb4d7b3d04a7772fcab47e80eec1e3e4960e173398c8da34605ad978b908bea05a172235d0c3ba7cb467499a8bd43ca0a426681a16515ff50bba494ab2d5ce4367adce0d85c81bc6577a291af375cb73fbe2cb8ada9087bd26a233649debeb21d31a79de5ee48e49a3f20f6e85907ffea7ee91f234598bca328b61d4f81a075afd3039ab3420242a3e205aa1b8c58bbef8b6fbf2662001186fd32ac4efd679be8e4cbbcf66bcfb575f936670198f946e8d691b5f394cf2169147c68c77f9305609357ab05c06ab5aac36905bb8f92094e91deeee5b51f5780b9fce9212a1ca00717c88b627465e40bb8aeb9a285a8dd1e0b18d0f9a164dd0aa3c8f1b4d5d03e168892ea38edbf5977b2be5e748fe397cd3057d9732138125e91cc5fd83bc71f707940b67120e83b98105cfb46670ed5e460af0ff202aca3a6e16ff1f00a63036a214ab0d2a600fdc3586754f504762408263d61479f7c94e39c29c67ea38efa02ee0ce91580cc2adfbd1921022b31cfbba7102015427e451ab0292192d25b3254b3b77802fabe16d5511d7131058484cd58cbae99a33f1c6b93ab447af4aac0586444e5126c94c298cd43c604b83bb2bfb4a1d702729bd0a5ce057bfb674b48a8d86a9912ee13cf0c11383ce191da84fcf8f0416bd367da634395c125e6cece346007ad82a40fefed9dcfdee1284d28062c571d36b60b7e434b15c7c61d7d821b0c2a25d2e42ab7e08c069f9e79527f808c07d31b67004b9ae758bc39fa5a795fd5fcc8f4a5d17e04c53448e54cd6f135c009d8cf37de43c7ceced96f4a219e75727154280c6f7634c90a3b15f00eb64ae82e270808141302fc8147189d77e249e6a3a26d3b6336b88dfa63f546922a737aaa00b735efea65b11be999ece38d0c88cd68092d7c65d0e3172671d0209db22fe95d683c025ca0162480f742ebb2f316cc7b930faf2de553f5ce35f7151ba0914369c050ed5a6abca6e151edfc8c63310e0404d4fe91ce4ccdafd1d92fd553aea43efc99e7f8ec154822552463d62892d87a048132ed927876f79fd8471cca17abb8669f102fd8755f1cd8fcf469c2c95b4449e89a0ca2c85c2f829973869113ca6dd1a964cd1699099d48b66579b6658cbbc43dd0f713bbba7fabff07075bc8ae04301495f94b3e17ce5b3dcc4f7498f4aa816beeca15da9360a24f88113bd01c00e84cbe7f62651f06f3586633f600a3c4ea31bb4bbeb74be658053340ed04d18f08d45ecc6f260429c98dae0e5481da4aedf133f0ca0ce04a0684e3644f7b705cce219a489b7a203c80c1ca9471a42bca07991cd73e2ad1af10a88552f9052ade1370a616e879ba7ed1b0cdfe6241f43c0141fd05cd56b76d58adf08e912df73434483645a9c09622ba4da8bee8c549c444549ca08d380c4f3f05f79be9e3d79c3c1491b6e2bef145ea8fbe9252b2e9f8fe668c69036151dbba9223e9e36a942617fb5ac6f64724c1fbd637c60bcc6b81143f34b50776ea132229abbc83aa2152f22828d6f4dbad186c772f93f905a8d7037aa49663ef896d54543e119d26e7b748e52ff5b73bf0141ca1e73f7ac7791f0a1b6fea8753c6a1e1bb5d6cee1fd60a4d06471df0a31761040372567759abc4a7f795a41a422ca06c52ef7fce333fce85820cdec14c5c52d41808c69fd7cb38d764d03210104b65061afd8da56f5e9efa54b9eacee80caa2a82a4b5a4bcf049cd5df5fe26796864c9585f71dd0986540ada6a1a4240c09bd93d2b7bb24eaf5e16f3548b1474a4704adc056afee28b5544ec31d1a09cd9c339681f84e564f49fff8436a5049214768227ed43a80508faaccfc13da843d0a673bf2a85b91f6d1f3a15ae9e483dc2e3017bec75741f0da3e53750af93ce0b187066bdc9fdae9e7cf8cc7b4c45c62d3ce89fcfcd922f76dccad0bf5cec302c5addff2a65f35ca4f72cd558ebdb7d576297d53b73cc2bbb7468166911ab13b160bf80d2f69a65a03acf9af107f66e4210d1c63841428a00576527ce998c8f3d3c4a8a651107a50480c4f5f8cabe922c6a126a6f238d79c65298092078b2902f724bacd5371c7cd79483677f6b5ea1c314e1466a866ee1e9076e6a60a766fb4316daac2c989647118fdc58dad3ad5a30661aec678d2dcf79a8b08854dfabc0131d2ec9a2d4a2a6798cc6bffb90d693e87788cf41c4b34de5d5f5199325e3cd2dd603f0424e03f4d7e9e449f4662f6ad71ddbec6092a6a24c941235e8eb217c20dda46045fdcc685f38575c436d9ce6d2b0d6584b345f2b1c3d6df7e6c9e3f2065f0b00a4ca3c6419aece75704ad3f65a3b22301808fcd1032e2c6ad31e85d861a985f9eb21ba51b2e9bcda5802474d9ce95b7818c7d7d9d8473c36eefee09461e4a0f63041e06e9cb668e1625bac11a90dd69b6287769b869e6ef7b272653b77b5415fc199ece64ae9c0ef4a5578892e1249d31d575f3786f0492a1dca2ef6e21b988e097eeb2a66133a31f9e53183108a9ed0f727605f8710f3b409b0278efac1ce39c1026360cdda34055d19aebfb5b4cd4138c630b55275d37fe35f6cc399be0f877204c130fde60802a622f72296da4e4af57c951e81d967d3d309519394ae9cd3d72587e3dc310f04515dd162708c7fdda52889371fe9f55f8a7f0f43fc5ab6572c5f5f8a8231334e725c5e070ff2166422a99480ca7a5e7c9bedf9e42c749195ffdca5811baec769940b96db359cd8bfff33c82aae2dc8e1e0e2611804b6a5354a85ec57f3e4aefeda1a0c313bff6079ef762940b3be4fd0f9bc7132f3f2b4a3cb55141154cabbf5bbc76e4a2633fa593d4474f721cfa29785f2c6e558f90db7200bb7d74b36d55815b74e14b48faace3eb52a13912829cff69c245b8a00cbd42ae5bd7702a37e1a13d1560cf6cb8733dc62f46a162da7124bfbcb1d332b34d22f80afda6ce1b17af62f196cf199d6dca4508cd1cc59a9adcded6a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
