<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82408d783250ae7de7829a1ff4c63d68ec839b93d7ddce2f2af201b658cb975a318c063cc3d12d9495387667cefa9f172a0fa2fafc28334031fd8b7da3d8ea37b5fae03804c777c94b51ad267d074f17d98c8a945a5d503bc7d63d44c302720c4d1e8096121be4340fa4fc0cc0cbd0a1407469d593a1df5b5403eb5b86075a9c0db94c3044f93e2c31fcd5dda4e7f069b42c5428a535283e7e15b771c672f1e23f2d7cbf73fb13afcdee151c58dc664ded4ec383b2919b69c46646d040c1ccc68d7217e6cdc80e648a98c52308f84c0cbfb9964e3ad0ced92067e32bc0fdea5c52c505311c803ecd282552f914073c187fb6d09000cf496150d02b93b49baeb51f34e985f97407b8a558d94f7c23b953b0211393af83eb65aedac70b6b7bbfc09fd6f55ef29804fcacd08a9f67d29750abbe2d1d0dad43d250442466ec44236c279200788cb0c59f4123251da2ec72330e1951ad295d4e251cabfb32eabb86844781cbfcb95d05eb470fd8ecc2502db5bc2b01e72581459ee39ca643df1abdc29c8978cca455799eb5c347c14e8e7bb789dfbbeaca4dffe2a94918c55aba744c9c014d77ab6b30cb3c997e497455f44fd0a93a6fe3719931baa47bb2660f7ab7402d1aa9fcf2b7b45aa2a9e61a1883af215a3e6dd6586dff47e04f37bcebc62380cdc343cbb34b9f798a1568a772633ab46db3870c008e0aeb4a4f9dfb7a5a1dc9e80dd3cd51c7af69c4809cef31381b4ff3c794c0c80ba90b3a5b0fa8f56e6bdb41c41bcb7e4aeb9eb63bba0f18ed75507006404b7048de49c4f1ba200d18e0447763f195247becc2af06b9b3e5d951fbdb0c605bb642e7ccd9c43e5c3dc277635864ab7ddbef44c22e9a6cedc386b804c84a4d37204218df9dfbd3e3e35bb610bf2e69bc7367b0ce88ac6a9215d33ef3985754d08c8c5c368b49a31be6bcba1cdf9f4fd8c285e2a4e3e16685f62164ea4fd4eb35dad884682a1771cc311f3da72cd9fc3528351d4950234de7e8fbec709711b05017a05c5f235c2c35f5cbc789f59679dc78f2edff8dd951d9151c565bb8831e5ddc5ecb38ae0dfb3cad23c7163d0dbcfb1e6d6c6e3d2baa13b48f06d35159d4a1530f28516b7a9d303084a043b0ba479968d371f1e23e0e6d19b7fb3483e20c8329df721351ce0a2d1ff3c596d6b83f339492a03d88c4de029d27a6e0a54109eea91afbbf383d5a6741f3e79837a8e225bad42fcc3335ed555e5bfe7789b065b511706845dd891944a18933886f8d4463a9d514d811a74f1fda4e2d58bf3ce0d7bdc0fe1b169abeb4ca7c9600e99073c6f40cc13998ff6d4ff875093beb2b1e941c046e9a736970b2111d0fc310ea8df53b6dd97036f8ef56b84489d3bafcaa36827ea31af5f93705cadd2e93a1d46dafb30527c1ba575c43dae16afafd5c7335429eb3a9c40b588425e874afe761937cf2a265db8fb7f7a7d8c4dce8253354c7954b4bb2ada9ee5b3e46a353a90584312163443f6cafbab1becaa22f618d6078f897465f17441640abfda34f9d42cae42d022fed837387f043e1cf3ca041b1ac42a2f8c8ac21b013d5ce1f9ec97be8598ea03ae71e9f50ee2a83c08d5b579d2414f5dd192dce81a9444e1b3a73a5c98c33e5da5ea200c5424271b14b256485a79662e180112249909a1a0c1cdaa344929b7be4ad27fc947aea58a5bc4792cc0e5691a7bd9ec2dcaed951e9654f95b312e4705bd5a4198f4e073161faa5fab570abebd7798133250a6f22f07cc5436458d02d3a4dd633be0773979792714771c5a9d796b423f884c56000cbfec974d2968c9307eea974528fe67ac5715c9bad851d0d208ab8cd278224fa7e33f045794f28cc5c5724ce7c860ca2fc3dec7e8b7ccf8ffe1d9ffd114c54722342bf17bf1d8a725766a28d4a5d7e2fdf4a5b27d8508f9588bc78c06f21d87cb74a8ccb1dde6ac703ffc417eec4307e0a449a9b6facf15538b03df2097133785729575a146ac24926f2b199b78330af7e7a9c0d94945658a67a1c0e2ab88092650691bd4e50a05a540d8b9f6f1f8ed6cf52d6509d5215bb3baf4b9581d44a0bf5ae11ae39684ee44607ac14babafb9adf76e46f9ef72cd9fe3c5428a2c75c7ee5314365e8a29e85d70da8bc8911996fa207afe0c2071a4f424003a4196951495666fe612117dff490f09de5369df16b2a9c6e550d33caf13463cc8696787eff77d533a4fbd59550a12775ab7a9f1d9f74510946677d27e097d0bad1863322a74ebd59f96016b372ad2f033dcbcf9053e274a06c9e871ebd35ea29c0c5fe79c0132d5d68051928b2be8e13986b16836f11e110028483648ec157111c047df3430e886842eecd71fa56937e967b444a3e79e0ce64c6f48a39cfa61c5808c1199d973f454fba7f609738f07d40c19ea42cfb53fe0b9244b1f78d0b5f005408248d3a415eaa42ca4b876e8245c45a92b9cae91ac8cf07c9cba95b9448ee8f287c01bdfbd24a93710ba7be7f21c5dc156e45689d56d955fc271cd97a389c7940e4d93203413b741c137540d52f8c73e658d5e88e21ec2e97c20d01af53201ad4dd73f494d1e68419e6acc9a17c73e1b57202c05b62b03e8c965c58abab4e51cf537bb4fd4b52e407fc19a064a2c48851f6b62af4552a974a919e818c1d3c944ae69f028ad5ec3b5bee2ad6238e81106b8b69ba96aceecf896388ba356e1dfd3dae1f33cfe5443d3de8482d71de0f014af6fc72d8116d4d2f41f63466496de89ce83b7cf79c8a1331ded3fe1a42086a3f106842b008007b19f5f155621c6a24ab9ca8470dd9ee49bef9bec0c201694bb3de71f1e8c790c7829c5451f3e723640611b96319053a8bdb4c8982c3a5e8391bb829442dcc8faeb9c81361c2079c532748855c5a559edf46f1f0598335c56423af8211019cb825b8c47095843a82d12c3a4f57118d0553dd6dec2a23a6382fa8b6a1d3ddc2e213a6ee9534e207c733a9e547f91a655cbfe862846cad834d58360dde6022651b296a201e17651676155171b9ecc3d27e79a8c52dbb0a02305230de5cd2052eb3938bb4941046c876d042e972a75fa5269dd7ce50d61c803bc14297a2829d63e156733ad433addf93da99eaf140cf61496d58a1f8ffac8800fdd54b9684f8a9f0704c4c9efdac77f4a42f3fe263dce1132d12e6688591e41c5c0e2861cde1dfcae99275875946bae60814376aa933eeb8dce2545e91112ea2df36ba16a7d418f8f30fbbc0c669c1e92443f3aeb79a89224f4e6549172be97b2f853b599602a3ec799f9e61830fa55c923ee8a554be22352064cb1d68445e23157fcf3e3e860572158fd652ae433be9c1361d85e3001e8bcae620ff7bbba2042a7568a319d46c0b3c45c2d3236b3e5cff304fa81867115b219bdd5d80f49f8babd99ddc0e1b1b3bbda91ee74c1bfa101bb5fc90e52db72fa5ad1d911bdfb42fbb606b5d47d6a59aaaee44a5e1060c07b1233d092d17f68c21a5f2b4d3ed075eaad406a9849401d6f44833f8ece31a9a54f95fd9b3dbf6ef0bc946a2562cea12fcbc31ddc2fffa0eab8f0b0a658686987262ede2b570073683e122026273f0bc0d769b2e1f0a113580eedda9f0671b6d20f866075ab141f999d395ae683d1fa773f460762f367ba86bc93221e7cb62fd8346f798b457f56de12a83e07f330c3293b9e132a76bed1acefc432cad6243750fb99a521650b5b6787efb02eab609f99e0baa91b5bd930a576534c61712403c4fbbc43517df8245602b404d7cb4b7bfad557eb8071a2f779dc986db9b94ce4979e91114e0939bcb2a4f6292bb8f2ed6f6da0d3c769f37af0237a3165ed0a7f176aca5cdc2377e362a5cbf9f354b5fd0165b51402ee9bfcc3e2eb7e046d92be79cf6009384b8cafc4bc812a7de75b6c76f497ffa4e1eeb64f947e81454503753ee973bae9760eeb6529f5a6f2aa9b733c2fb150134d27c1926aff7851afe917a6efe26e33d6729c0bd409b7bc54a3ba8b47cbb5e5dc9564f165bf141eb21378977f46bd1e45ed19b418752fafb462bde99575c0851baf662e259cd1c47be207f0422ae1173537bd62dd0ae43ee92d97213639510ee3003c471775e697b506c036ae02a3d9990fe7ff689b11122e8d9eadce0be952ffa3e4394ddbfc3618f0f30f4b45b091559e8178fd587db0e3f6add39d3864aae72cf8052f432e88064fab5a4fd204edd9b995de3d29417e1539ac4914edfcc940038dde6f4805e017b136070cea268a87b6102c1b8cd13cb329f286d330a7ef629f46203331c2a108ec96912167988ae46a00f6eb749e904d94c090b79d19fb1cd5cb1823001b3aaf27c7dc4799ea223111da19bbb329ce70d0ab562be4a49ebb530da58094915682fdb0e759461560916ccce8c1b5bdf4250d1e30a1a34fef1908613e0fadd09d69fc3bd817ba61f490206f288c8b1a7a22b44351dc66e0dc20bdc77030bd7d46bd7d5c822c435f75992d737a99139e09f21b7c94ef9a87526fcbd49c24f094639cefd6bdb5256f946101ffa400e71853f1fbd60a1ed8b82c4d0442bec9d4c42aced660c5d3fa2d0ee223866464b36ca09b3b43c5a3674c3b65f32a93a4ecf9479b412b809cb78b00bacabf0add0784d09510397c9b6665c6d4927b4d0122e2ad713e3eb7a225f680abc06b7b9cc0f951476b48097acd5ec8733e095402d21abebcdd9a6a82da218d4d5144ff8e7e48616b24a1b071b3e6f721a2f16896c18e88699fa371a8e8dd9645692696dc04c8310a998afaba916b910d4f3e052879b5e416ea443276a94a5deeebbb51ad28749b377f963cbdd58d95e057cb0967d348d23901e19dc76989b32bfcd1cf0c4b2a7cc6535e8bbea66f5329f9453a61a74b19bc26bd5b46d617fd5346c19b9a61872176c9861ff9f84be9b3d627735c16ba8b8e6ebd822b4d43483b68f91f4e62201ddb6bc62b75a4d10916399a8d468673cee5de98324c72ce39ad731dc0229a54550f9d55bb86da2d0fbee68828ac8a6e582150f5e568763404d5b6b0ac1cd517630ccbd08fdecb44c21bb4839e1e1e0d624f60dac1407ddacd1685e5c248f8c1e42612998655fa6b5b73adc35d1da5845df629d86ced5583cd5de78d461b645a1230a6d049bc27fbef228914c251931af268501052c746143dde7d0aabd8431ae2c87bd29b3207d782d22f12ada479bf1196f45a36f7956ed1c91acf90dc80f6427b7fb843bdbfb12d337eec65c4c5a28410c246ed40636a72af542ab03a8050e0800c3cf5480916b92d04698f7324eaa2e2b7cb6ef21e8b0d30a8c661997d399b08dc01cb4d84d64f79dc6f078aecd7b3ba81dcde145e9f0b24cade835b76f87dbf8611b0ee7bd21368e3a407cf9693575bdb7bdf49481fa1eca0cc9339a996e3a24c1d87a3d41d8a802a82c4cd95fb2029f9dded48e9a5e34f554f019ae8b4caca5638551d10dfd00e482a99de106e1d62baf377bc742e4391e4aece9e55d236e272e97eee34537b7830c9c1252a03019666a9dcd08f4f5e061443466630382314ab6a0609cd20fbf45b91d5caff88331f9fe0a05f6e8be4f894494b659e51233638e5dd7c0f9f2506505a6984310dafa8d79b81a4eafda47a768a3c9e5cde31af17ffdbddc008b11c4827100a99794b20b6e389f1dbbdf4145d4dcbafc2d29d729fc4976e9698fcba557bdebab9d26821c05f5c6651c26cc2bc799ac47a2ff7e6f0929a4b7c765893f1ef36a22d9395b4e16a172bc3961919a69cc0162444ea678d943f33b195cadfd093f98451b0612f53e28eb51271d49a94f23a5a6a743822e8a56d7484074a1ee7770a4ef617ad727522ac1cda5c6da391736ca1c7b7960f06b10904e9d7ef652deed6410b255101730910256ac4a672076f0b8264d65ebceca12ac7470a83cd86d3d140f78814c35e3da93b5b850e6b0db66cd677388a3012533469e7e0be7194e3e8d3f0386ec5d58466fc1c1abe0e61118d48a42bfde2d264fefeb5501f93f4e58a635c17489a9cc5a0d36edf55c31289039acab1bf71e800e3c8b7b4f4615e912375f8879d0514d79861f1f7f259548add7d2fb8c4ed3130c27fa8034b26db77c89f5421afcb5a9f63e0e32c5a8dfc836f9f616764b047f5ce575e03029896725db6db5434db82b3d53b529bae28b5beb5c9d9730195c12ba95f38e3969091ad66e7e30f2d7b502b2feb59afb67699304ef6660b3476311245f9cc6f14e1862ec086b55bb1f4254244a26f1f3c5b7246c97a4281bcc5262d43b84c01c481746cfd3fab591cc325ae750c013d7646df54339ca999f640759a50ab8f43d1b4e4dd16a14d9bfae66b5bc2e90831b0141858de4309d5780d299c3d848a88dd4331cf22028c082825bf7b8d12745dd056b8eabee155b14170b2bd0b240d61db41d46dc2f308073000d91ae4695378df8c7dded78c2a3a26843dabfb5c0cb3e99e7a4abec5025400ed195fdf1870c9f604fbcca621f9faeebd65d1d8ba2068fd717ea1be0dbe728053a38fde329816cc9852f0afc9ae6e6dc973c5f1ee13b4c4fa530ecf2940c4b235df5d53b23b50df75fc728686176bb90775ef3fc85032198eb75ed5d8a85e930135046d4a07285ab2ce3c3b0d0513b84ff282b84b1ee8fa5564a87b0900cd8d005d17581ac04f503463b80ff20ec3f7e11571091826795f8ba641b9c5235f4b48279b1d62e217b3da3593df77e1ea885cd278ba543b269978a699573a678fef5d4fda7b038bb8d7def8023e8724dbf9c2e3dc32d70a67ff5d313ba8b415b09c2b08833f96e97b9c062e681c8ab40763e95c4d33dd896162e5af08f2b50acdb786901064276c2d96313a67593cc417fba83b82b8b344f6b66603afe51b990d77f044a7ba8d2d44d71fde6c1858198d666df5864931b4a2eac8dfe565f3c790a49fd2b35a381a674ca73dcd7430506da93caa4f022ce9d8b3a565facbe258c0c5e7d23435a755ef48f1539b660d9f9aedba78337ae934110168454d9c15c8819c3a672a8030cf8798a45a7d8b691dd471fa2e50fbd479a2280968959059e44e0e663b95cd792ad917a512b68e5e0a352235653e115ccd54eaa9ce5992b2e968d469d4bb456dd84804f25b5270d13cdfd265a58298a17a8ddb09da32ffc9b25def8a0864c4d88e1f4638b321b2cfed43564703abd5cbe505ac5e108bcd9bbd3fd22d9624ec63093e2905c5ab3f6c377d23d0e3ca005c3885a367b891b2c0ccb9a16a9eeae2a27aabc2765c9921995c20fd9b9ef29909751f1f921c6f03ee83dea175d6ddb9bb6867c697d7b6c6cd491eacff8eb6219113480a8bf5897b538d90d48e3055ff35103eadbb03f16e9d7c77125534da8381900e5ad3184acd6db75b93fb8701437f58ea450a9d9137ec77a6aa131cd680ce6f1bed33825511b4c41b984219e57a9eed5c734c9ffeb3e5f28ae032d2e7050da9aa790a604d007f7ac04771d7e18aa809fa459a35ceed10e9e3e8288699603c1213568f745b4326f525b190be9ee0d5fbf9791ff01218d39f4aa95174451544677c6e0487c7d00403eef530d56c4e77b464ef316837fcfb97d92146678caabbdc79c215589ef45119a7f4492f62a3fc38b6e1c37afd2d6b424134b47af23d6ed284654a836e393e6114fe56307f9444c1466f6434e10cadbb74862531f99b5145f09f72a09e3cf8fea29dce2cb08a36e0891f497c038c1652708037146ee5639d2e7f2e4f366a3a18e226bbc8c8a64c5c50e0dc8a1ae1991a9aa23a65930fe671653b220a99bfb041ec93e9687dbbaebcc55b1cdbabeb87b1b0bd4502f0d6609c90b2a05f6c28c23abc59b6435f63e881262404f6727aa70b24f7ed0ceab835e2ee2da37c7cdbefd2deb212f5920ac21c46dee52d9931b3d23da7e72bffccb436c2f92da792011994a4b7945a5f328696f887cb284fa22ffb7eb90e9d4a32824921b3635cdf7aed54ae56e384634981236670095b1a86a63839cd1aa6a2890fe3d887db23b470b0a5580d1e5e4ea4f0e749d924818ad08056fe969cc2cee573f8b2c0997a1698841d1b9186df4d91d5f58aba70f001ea78fb7f91f5e8f25a68b03ddb656fb6c6088c6eb8028f2d299703fda5f6ca9d9cdcbef0e53d9b6b90c7f8d7129f43da785e0be71c563dbdf85d46b7b69cdcb0eacbeeb9ef40841bc161f88eb4079c498e017cfe0cd6702287b6aa05642a58bdb19f39c31e9f318b47828e580acd4ed423eb330434275acdc29d46aaa714aaa3efce7c60dc7375c3821a22543295b8b61654237eaf940aa1d5e8e0d91e898c2ddae1d34490ce55670867a8bd1fba7f1256d745e0e87599148fcc91a018148c1ff56e12f7f6f2ab6ea7b5ada7f1f8d42ccf682cef617743437eb16acba8fff70e7409c452131c9704288aadb2718d2896c83a21295839a0eeee0117e27b15a04581bf559a8a47606aa818a7dec6e737efbe5e7458dfcc7f5943fcbdacc9eedb183c11e5ad37ec831287b1b8c2164f431a5bb638fd9b3333049fc1a93ebfe9f9cf84dda4f67773318220321a200a56423052b83f1c068e23244f516a8c8d26fe6012e5e505565318483ff43292d28e4f9382a63927aa8607419790e543a1012054fbf382e6d574e8d2cd99d1e972641ce6d0f77d27a1366c4b7db19fe2201f072fa1f8d045864e1cff9a456f360a016d20a3711d7e4bb672dc9609eb2c8274b8acad10fc43be45780f3d2daf284a100ef4af573ba923fe61de0bf9e0006c2db77814540b83c662b031bb91bd60ecd2893673483675120a0c2cb17050166e5ae6f5ee1d825c92a2f1b94448de4327a7958f2a58aeb4f844af907129ca297fd7bdd565433a273ae6290370fadaeb47d93242fe1da422106c19478eadab70e9702eab95c8496e4d89dfbe7dde78764a926dec45160bd8d98f5cfa3649ef0fb8675962be3686ad00e92c4ad37eab096a9732d068178ccfedea2d395ab7779046539ec43f17f4b3005dd36393b9c45b0dd029a562198543f5b6b1d751be21814673eb78c0a83ac9ca309d9220530ffe99434759bbbd4ad15c20bde0ad911b0a58afea0240b985bfcf4a05497396386cb380b69d80a0bef9fb84561cf32735bc1073926b249955b5bdba5738eac5e927a639385dfd36400911085baa21fb31857b845d45b5506d46a585fcb8741a9cad3144fdf378c1a57c8d9d7934f3cb23ff80012f9248013f3619b1a076aaf5e12db32ed3cfd7ac70df941ca63de0c16d02cbebecc62630327602e992008e66db585b1de94818beb94121dc4d08684f48d8bbdc3595714939486ec9b78775f6d2d0ff64a1b86ab043c38d504d0d3bb4d4f0a7722ef30ea662fe7a5f4a847de073e458d0368bb58b9a0432dd388000dbff874a12d951daf5450045a1b6c7856d57003186faa2b8c3965d8f868eac11e234ca199a59ea5fc0c2aa3fefbcfd70f5894830d6409089e55bbed43f4059019880e11398a6cab4c086be3106270b6909cc4e510fa1b874cd145fec7d48baf80c59e878cbc431cec84183f31d1de89da6ca1cf0825af786f8b4365bf868eca6d790b50639ba5f4d95d6ff5125c25096a29ef6fdb9f5e79a7937790ab80ea4b26c79b80f5a66196ca08b367cf18a4da094a5478cd3b4b8a30aa707d171823f8bb48f1b56c6ad2a69ee03fb20e261223def1d3e19f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
