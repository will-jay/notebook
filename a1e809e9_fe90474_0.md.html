<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8bee2424f237f5c4da715fa95cdc4483ba851cf1a59ce8eb742459c419a45000f8c1213562aa4dac27aeca380fb17f425fb9a70ba148b95c92a96893a6a5cd5fe8b5c5b00cf49fd01869428e516e701c945c1e3f70bbffe48291500c7cb0a15e63b87e3e32ff55b08c6464604a0bbbd3b5fd741cbc604c032c3bb9cb768696e08d3e630c53fd4dc439934c304f15134acdf055d2ae60bc8c25e3137516c8f3745e2acc25c7876eb539e809af9d1f6d5b13288683aa73e820f6f3f096cbf442629f87a7b491bd608932fed9394488456cc42b1624728f416d6eeeaab09022885ccb8f6132c20001754b1c45ace208c0aad94dfbb5025e46da93e4a2b8ac3181e7914bfe8a5edd65ae391cd4d5589ad7c7ce26b57d49c41005acd9bbc2164a37f1924c2a725e99960798bc334b1df185f3bbba32ac9ad6ed8674eb363504ce3a73a4c1bef3a5e86fcb1270c5458f95ec87f6da8ab2ba5ba6d97ce6855a22412f913bf6bcc58551d738a518389f4f151379cd0194a0a94fc46d0b9ea7dfa3d736526ec172b046d1587157755c0eca5e84cfeae0e58db68047c6567d53b30f607c5aa2ed0fe40457a3af04cf18bad70a1ff40ee98585f7d8ad467a83f05d963a47e1b9f315bf78c2648893accfda6cd887764bf97d63cda6242cb4cb0c641e1e5eec19ce7fbb2985e03fece4fc1d83f70466ed674d670b91bd0f48e6f4b6b5601bcc99b55402b049d30226807b80ed7fcebf6b0d54c1759a35549ea6253dfcd3e3df7df38ea8db70bce19d44d5bfe816d44eb38203f82d0d31701c13aba25144199941bf0e596024d8c87ffb2b76e2654f5dbba22a66b189716361fbe1f15c1713c6025d7e86632abcab2500ce4da10fddbd31ea4d848cd5bff9279935e8e48d48f72f17b7fc499947dbe465864c53952ffe68c921f8092768a89a98fbced6f198566d451914ea387adc7c7269e851851cc382d31e987349c39e30a216ee03f4e625e3ff3add24b63d86438e248b087e7f66f00842d5dc697b9c488690ea856840f0549b7160fbd6794cd05fe99b1538a5ab83a39fdafc5099d3080c4a3a9cef934782a7f365163128d1cce755643ceaf2f0f5171cb6d7a395b1cf268e9038a570b347938a0af50b70521758b026701f90941304464dadaa8ecbf7c478075f77981122d8b1878a77b8f4db1a8368a3d4fb919eca8e09e43e5d30b5a2e2919fe0ad83e6cbfb00e1bf15c301aba648c99a7f2d7de18a1cee466977b5625e2032940aadb675092b5f341a8017d322a6412f55771d924c05273824a2d2871dd1e183a8ea2d20419c0261ba8fe588e02fe8197c1848990ff9ce121d7371c675b700892ce0b020f8971566d29f60e7275fcd300a188d4e965728827b0fe7d5abca946415ba6242be60c74530eda3556417377c30a2870ffecd5e7780fc69e890ed6ee5473246132908dd97fe6265f3cd5f9292c25e41f75c1bb18dec32056adbfe7f934b6a33e93a07badee5d88163bacfb18e6ab7838cd3f0c25add71562977a9fe51c8e41746976a5b079fe67011ef4f0d101a04cf180b7b1ab4c6725a6e8bdeff3ab6dd5fed28ebd7eb6c34b78b49a941ae6fcc70af101c3e0001b505e3e50fbb8b43ff8aa5a09ac36a3247b33e3f3ea8456e6a6d9570a7e29e9edaf5b41a42e6e99a0198ad6a17299a48ea93905d41f0873280e51b2650d53de78e310fe4b95ca8b21b460dafe0a2604c10ce2097087ed3ba4398227c111a47f47472865d029e1cf499ce4574fbfbeea0966d35488c9804f789f9a721daed012bef719b6c7857c1cbd3311f3b1bd74dda02da39ff418b2f01178a11e56496f79f8a705afc4551764b72bbf9c7240e74e5f4a92d0264223228453c73841201ab278dd3613429f7a1a1e5d709b884c8a19ac3369476087b97461b16a967795e0490721439a0e45e6889b19d7132ebec9883cee15dd79f1069cb0984264f92a7e4b3f3db199b6ce2bf91042b2ff537f5f49fdc5e169be59a80ad9396192b2984ffac4e3d201efa4e395ef16d0faabf4397dea937a42f90d59649942740cf7a408e46c2d1b51115165ff971f07205b184330d848c219b8f69c04c8caabb3366c2c4aad4c1be2e07e6d50466614912ee5b5b3b807df4a24b97b00fad3e15581f3f539e90f9fee57f16e08a2aab79db4fa44581685bdc54f78e2a874d173e36a91c5862bed07755851e328da5b517a0d72a1513014cd37251a2846b6972007584a2fd396f8699e2d652b6826a13561a0cefbc60a49d6513f8016f4e2cd7208bb73f22ddbcb2e240a84209a7f9816abc9b1c433d2de4bc79dd770ca706a9fc9b7fcae49282ba04833616483d2fe722aa7cd542cbec0b630d3080f2450427ef81a4efc0b03b2e80816664629aaac8f3c6bf9c6ec26f140837dddf35c6971b4edc2c0d0bd5beec8b55e48979415f786bd0dc8a9472f8f4cac7fdf460364f4b4de20c479390c35c816115e04a0dfc0c129febf3ecba2bbe8f060eaf81c7080c5d89ce746544f40cafb24151ef0f10b3e47a5e7ea2f3c336c9b1e54ac360d6483e28f0b2f11a5985fb5cfcfd0173b8f152a829f0d154e13ee7b30d00cba8475d2fbc221148c03f3473d5d19a72fb85c040f6375477c10e56a8d8233d64ffffdb7620cc31ca9809fec2de4c8f1315b87d5d55c03abcab8f49c1c624ad9f4af1ec0ef1861b9ee69f05d131d6306be6d9c8502f3328da87b60ff7786561444d6a5fe12d88ac9d5ee612bf374161bb302c209678b57957f53aa8d21e2534eaa0de42131cb356ed4a36547020c8edac3f26119146b6e9c68b36017ad9157f3e002af87530ccf0c2888a081062ef9555a3b7986e289d2588c98f96aefc911ccd94189e1ce214eb006289f6133117f247487ec355d53ffcaa21f8cc217a7e842867cf457bbdeea6790bbb395e90f1dc568b8591e6de977387c9434a7e5da7f487179ac576ed7ce33ed4e56bc58721dde0e9d5579615803ed149b4ce4550f01b70d625af6a2146d7c9189a231e77ba0e05933e8d3c792b8756d1ae8e9f3a3cdaa79c1bd65de979bec213cefd48f0b07cc92f1b469fdd7efedf80190860871fb8c56e2101e3f29f77ab1c33e1c7443297995da72494170a043598ebbd6de57b9bf5d6b4f5f12a4cd0529b97e170a0cf4dd105eaff7fcd1b63044a1233d6a8359b1e2712e29447049839af54110888a3cd50b29f81b42f7d551ba1c9d78ec2118b6553c8d307b9025083c9b9c6af1c826ec35814c321562cdc1d9cf06db4e34873a3534e16ca977846b284ff75154152152506d8e67222deb8378b61e8ec4730fab6974a1bab1b8b2518486a3d51174ec5389aff6d87f9e5548003b2b291add13b3f2367dc2bb043635cf549b2d80984a12e5c328187c6e2cc0446072827b4d3ef34c867bedf563f89a901d22f9cf02a94f75b402c0a3a22e63a4e747ff5735266d86301ee5d5f2200a88f652db5a388d2ec6b0b2db803403cd68cbea29ce017c319609cf1a61d1bfa383d767125e5e69c93ab0db76954a9ab99795f756baf92a6ece8823e464fc4fac7b0ebfa8e008243f9c20274369dec04f4a63627cd4d2ba0ca9d8d43d3630d61d2d4a4a570e5174145b388e3de0ef0e054ff00f553f36f9b00bf7a379517bedde2000ee2fd549cbb9a737ebc26645c7e18f1978d9350d90f94c3148569f7e44ba95e411db368be9da26f17e5c42a2caf573d8f32934bc8ca2a58697f7d041cb2ad8b0c98b7e024c21b6fbc1a19af40dee509a687b3700f64f9ebce35a8c7c7f6f5be4933e32aaa4dce8332f9d72382975aa03c8cfb7c0dd6ac69e668599d044bc74d48f90091739a72ab7117f600ba5b47315ea6d3fc871221fc1ec90938a2c7edbd50b69d3e09bd8256df1bb0caf127138aa2a5c2df65449767d9cf672de462861bca88ed0d2f83f0d724b6ad547465a29e47f4029ded373f3d2532bcc055afba71aca3f95ef696c018524ba745039343bddba8838b97afc0d013e4320a5ab2d27b8a7d4abf05672d697aa6a6c774165c61fd1662a06622de158fa50d6c1d01e0fd2b71891435095f7335b520ab321a75d468b4fb760a3ae304b535ecb0da3ecddf668744a203048a15b8a7d7167d5e12fc9eb332cdee41b49028a01249126574d7bd7aadffb0f75f93da4792d0233456df8b57d0c5f9734eda56b4c9f5a9b9fb04afc789bfc377d39da9715dd5bbb168f4e5401017cf46ad00ef47ddbce63e3409aa3286a7de2f9c1c6723535527e40e7ba5cf1137ce63d8cb40a8e07568ad2d16d914e47a6072d9ea5b0987ccbcbf637298a873ec8d9783a99762f019376184c9ff797ad9088adba69085a6179a556c66f3543b6ff64706b0341ad772724c1a44d87f4c53c18014e18da9c881a089a63151a62b5f06dbd5d1b8610b44a2fe85cfa39571565322725745fe81643bbf2e8118608649fa5b32a6f657ffd3ed21c6146f0bee48921c5d5e1b68115e73dd4710d27b965731fa0e4617d1295ae9bc3f819b7dddeb9e7c475d9d0359bbb6a8596acd3d21039c5eba5a171caba59b70392246b9b5b35c2511fd0c3ede6d0b8c7a49a7da5087a9fd82ba6e9f2c957a1087c4aa9407b1d786af5366c96bfd3d60b7a00a98e4b1a68e5e4fc192437ceb01429ff5eafd8df45cc0b6ea3ad7780bfd00d24f355cde650343183c7f4bf346ca11c19db65e8f3441cdb82ea9c8367a60da978992593a7aeb4c4c91593050d82f405027ad1e2eb49e0c642aa8d5e137f63a8a3623ce4ff052b37425d07880f3d41238209a7705002140084d345c2edf5b61eaae768f12b916e127b41a73b7277c80c5d2246b2c49ab987aa05d583dd60f9c5cd0d4b7bf91915c9b1c26efb6fd890e53dc2a98e2d8863de574fc7c7b8c2b401c490fa6fd89601e79c18fe36e30c2e42330821bc972622d746ed4f94b249c9bdbb70ec78be50ef0c1aaf13e4b4bea33891addfd89d141dac840d3952ebc69e789e660a870ca4fd0efe88c83079399e68f9bab6d716f717d61e586ae555ffd03501ce866a0a78609f7a20d775e088f2c230299b61212f9302050f4ae03bea26736759e7b201d620bf441e2ac8b01746ecd0e298d2f41ca377b6683181619ecf349a2adf6fd74982851e88e0cc5420b1afef0d36d5e81784e27d4d5a26b70616684a8cc3a58b263a2be9b028e9d76f19876efb6f3897fd43e8af3485ab2e9f011a5a98351f12ea57ff87e2abcf235896e17c7fac1e71120cfec72a3d147e2d27c900e83d8daa23b8f464524a0defeefc58cd3954ff69a629bb5a56afc73f2385df6cb8451cdc0c165c564e31fe2edf8ff8681326e02e74e0b87cf6089800a2f60da84b576b854f7c76145c3523e614cc5215ff7425e060da4309d343539fad091b41a49a7f4924cc5313b7373a653133bc135fd3eb7b8c5ac6ed131e36c212ce95ff96252ea11c4bc78a19c491440fc831af0bd79b1e8e166b9c8d97ee2757b0c1ec5780d9a383b2df378befca43acbe5a91b5a4ba6000f7044b65d50c7b39fff99bf8f815325dce98a02422a11763a6610f050a8780f92abcfe228f15f2c38ce30739b2d1a5fdd530d02d93956680556c8f55719e43195e9a70adbecfaa9288ea2ff98ee54ac346689aa4aebc2458aec4ca2d26ab6e5c30f27f7514e19ca031b34ad2a8bc1ee9240dbc380f7bb278f4d4df7ad5dd268411fcbba238c92b0840f7cb5859409733f5fa926569dd493e9397016f1ff8eab0750129602dd1ba62614f57283343cecaf3062d691c66380b36fb5a73a4df976adcf18a4d9d5be62aeba3d3e4730db521c8da1fa86aeb3cb6784dc00abe8f112fb18872e0ca682cf00ac17a80c629321e18fdb999b6e7b51670d661461fd9844a08fc9d25860bc293eb1fad939a1b0d4c1d19405102b928303ee28e22165847b1fa63d98bd0a0f0795777957cf219da6d206dc58a616abe968d250ed732602f99070f424d20764ec39afd4ed43706d4e0f5ebe91dc55c809037dfdf728d4e0ea0e8558a6abc4d0b32f4bd36ea076469b51c42f12677d4b0b7c015911f9fc6264d26eeebec80039f05e4eab0766de4d0a918907fd1a8177e1ab5e9700df682e38a4f06e6a00d78e4fee30fca11196e81a9fab3b83865e2a5cf9ac76ea75c4d86e83853b88fe0d20e371075d40aab3ebd770a0b17453918e191360b7b2b7f93e40f39725063a4bc0393002d83485e15e5df02591c94799fb4a4cf562748f6b5eb3739936f0004e93ce13770aab92911f0f0dc78cbc0edc327b41fd2b3c21f0d525b8cda924ca78945463835a93b6fe66abf70345d6626558a339eab95b7876cb395a75fd99d23ba6e7dd1103d71c325a375310b8ad9d43770e9cf837884f31e2037561f89b0a47d6969279b7a55fb5325f05c9483034ca70190591101a7a9debde4c614688696ba65592d74488c7dceef96e617414ebb6cc577cd0fe3adb9f6a7bcc0a8c7359106da8297c152da2c7adf60603f4e2a5dddc8bc808eb6beed8a3500ea47ec40ee97a753a344cb20de109810835de1fc867308e9d11dd530fbeaa3cf79d87119601f77e5bbe2f49a167bbd5a6df4c9dd0fa9a902027807ad0a8a7fee893c6ed7d3a58f4fa93f1a309267c0a62b3c0e2532a5fc659a5bf134aea1d2be2a6f50a9dc1ea6afec594f9920a553de0cae1c93165719fc2405e82f5b5379be2ac7db92e7f64b7e7965c744b6fe7c98c5fa510cf06319cc442256b6a92e215bf8303ae11a27a6402d78072dad49606987064ccf186b4226427885a19065577114c2d1f3dfa32f8fe9f94b6fa8ce0ea2c9e4912b703a348101468f0deee6dfa9653034f0df5bb7a89f586e3bc39e4fb63a2be9d9c76ffb8b26ab1be0a32c9c2955303d8e6245c8cc6168c4592c37f8e9a322742c224e0f6e70a47ea051c1fde5a99f6e78eb8c452ec166ff59900a97797b24c7fe2571f9957acb8f6d8703747776d609aee42f7a9dad9a2f6a5ae4ca60c730d1994393bac9d156c4934823f7dfee3093652abb919a0ab02ef55adf9de39fc193034c7db4160b86f9a5b4dca564518ae48646a88c18e83682e8184b7de98ccb4654c18c3f4944a6d6f13b908f829fac8b76bb5d1a241f3200169ce0a3c3310537764af559463224dbc31fd8a817cc76e28852fc9af1bc6a5858f01ede986756f03f84a790f1b378d87abbe272628dd8f7f181becf2f7d63779f8071860326010b7bd1b9a51df79f27b29722e02f261d08604872f3cc35602d675c3bb8405e05c30b54193f259cd7a7ca56738bcd2caa05e7a8ea3c51ec469bc604249db146287795c58606cc0a45a8444143fcd510ae19075224e51f348ce51ec2890e8be8c062b819dd71e4d1e7d96c06d690559d9900ae272d68f319173c944948d96c6fcdfa4d699b25af3f037d73def7adfc835551e445795c7e62686107960d10dffc0d39dddfbdb9948a4e0d554386222a6f08dd07d352bc50e4a842a32f672888f7dcea80d92a3ba6cbfeef7502edaa9481cabdc8cd731ca3bd0166b40b6ef9865765f5375f9ebb67d23d795438e9127c47c1704f7ae707382b5cc3a2d8309c5471db5add49c3daa1957baed63dbe4aa502a7681f36cefc92b7eb776876873dce862cf6a83ba81bc3609207a214c966b30f9b7a26e19a9254d8c60c6065849c6e588033bc9608db2c1865a9a350382c236652b0453f4d8fe0d2e636337e4e97d40877872c034913dad4fbc45e3bd272902fe50738ea639825e936b198ba01f14815b719ec9521c3de413dd5eddf1cd9b9f85b2fd2a02f1a0a4241f426a4d85f8d169f77a38400299ade07232d822dfd3b603003728142e4741cc9643b2bb878da7a22eb79bb7dae2ad0296a22b4299d6e61b553562f933281143db3e5d106a5b7bbb6d36f8f8d0e1b26da558d4b9a44cabf2f39462fb624510e93e4908885f1b6278cfab2aebfed6c098553df0a9b40d995c889271704d0695387d74d0d09769d3d704dd9e0637dab81d52d2a829cfe1d02fbeda8eaaa6a234384b25742acbd595b6cfbd9361041374f346e6fed79f8b526d82561833e23d43a167879a887829506ae8d009b17bdd74dc41032d9d7232d4fa64f2a41962d69a4a19fd69fae4e7c9073b277bd6bef21c4cff1b778b15f9fd9f63974c054c8de4bf5a8ca0def44084d5a6aad6e130431784f87704cc14369fda16bfddd7c8f57806db11807aa95c756c218db9ddcfe7bb1322c060a8733dfb0d2f49e3f05c19558ce2ae927599fb6b462e8ce963ee53f428041b08fbd2a5c4453fcfc599a67112ee02951d485ca1281d8b2077acdef6121650c280b71c1153807d6a123d350d4f3138c9e19066546e1367832e8e1f4582c38903860dd282cccf4f4894631be0f75e747ad6c63e00c6a8b102adee973ca41bff1d065b62bfe74c95541e65e276a81789a68543ecf5adac2d6ba0215a7f3bf89c292ce8f77711f36f6edf20ed1153c554092bc61b82a4044de80027dc05077a4ba24702a90cf135151979e1828404b33ce158501bb83a2d4e4937ad5eeda94b3661920e0b9d5c0b38f7d7d8058aebc7269538d1159483518137cf506ea38e62374ea165bebea0bf26f16619fd05fc238683357348c1897b8c968211172e7b40c4ea82b012109bc722dd8d8c2cf53e9ab4a1799613c0b6f42a9381e22ae955d8bb7de8828e7d0383b92e0125ef757ae745cb1c6c4b6e5f054bb6ce6f9d7f7028a06c768803d94788ee646842bcdeeff99409681b140e86cbf9d6099e324a7f5a722cc77ae53b3476511","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
