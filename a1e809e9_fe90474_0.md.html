<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77f4e10f944c3908ccd52240e92f4d79a414b28fec08ebcde69c794e9e9c1395e380e035e3e892c1fa03aad7923902b643d38cc6d0b489ff03d1a3c34cfa04f073267b1e736534dcc12f9d6ce7baae90d166b642dd86cdd85a8ed0623da547af026e6633eaa8986b4a9738811da0228b37b22291d1b3cf699d5391df28f8a03476f31dfef7fe501cb3d18e0054c6f5c0a93c7af6b423655e04314ffd8f21079a4a1aa1a7229eaab270a839199788545c98dbd111bc890c9bd5660933d3be84c000970d7e31c51c0a03035662e0d4a4ff44fd36173102670f905c22a2f7c9f7637b8e596a3d07522320cf6760877a50b155b73e57b10e28a44ec42ee0fc65bdc46f8f4de49a033205b5b96b0dce51346033b111f07fd4abb36186d658034d660f472209949f744a3e4c3066bedc670daae393f22f58f312ed756f66fde2a3ddff2888c74d3d82fec8edc2f37308273b49806fffbe01e8889e17e53884aa9ce3a09de188b0c6821d468f75a5d792e523d160d7afb23151c95c9f4d84b7ceceaf7892d9b2d5b41a83e6fd014c558456f40f08a40ddc3547e13911367e76850d3895b3e86f5fd6ec1a636fc51d1072f8cc29f21e38a69c6789700232f0961861402a66440548f09cbb7b1b7bbe47c7660e945627b10a68a800b4c352010ffc760cf142c74d7b66b84c6dcae58e4a632689a817e8aed6609af5eac7c54626a9acdec3835c43d7eec393914f400e74eaf8f7c29626f3d87c3b090bacf1141d40eb190b62e20012807a8618404d09c04888859fff816b3a4c7274bd7614253ded361f7728f7f3d7a667ef496232d033bdc7ccb229c3723c82efdbf03fe537236d726c5875ea3d484648f99ebb27ec06ebe1eb2a25df89a30fbc7b6ea496b4c03b6c940734aee021d46e1a0b5bcd828ca7103f6e2e6018cb3b294936508d0e5f44dbb3949a34ff56f90d3138d7799430202e82139f4b844f371b654a80a60ddd78c46a0f0e388d7bb621bbf0c68978eafa2d5fba18f94d0158abea6bd35b04b8c8c3d29121292fc0926a4ff6ae001fdcb56bf9031f46864bf7c08dc30b2384d65bfb0b19f15ebfbac913362bb43ee4566c17ea66ec49b58157a9af145371da2e5213a9c40b1501fea50363c07299c9f714436ac1cba84fda221c1b61ee57ebc6edc8dda0c3b6ab10a5f121cf73145c6d4965ee20e60659093f91694ffaf76004fc59426f485633f9cc0422f2f9f8fec06fccd5b823d2a5a27faca50e7c16b99ad89ce475f8b472f2c0ab0d45f0617869e1d60355b1dd117d17ab38ec2c4685b6369165dee587ba9ef2ea7293ba0f1f9b098f69d0ecfba52e7b0ea41d77a7e04791ce824f8a6e8151402d30865debaa5ccdd27f014ee15b613c6df91f25aad53350f204797ca7b16536b4c44665e9cac87ad5741e0609df3d77f15b9f789ea9bb015a981ab627ba900e435fdbd307879d4ebcb3db69402d325b566b7ae487b604218e1da1313aca4fb5654ef44589750b8f97f0d5cb667bf44b5119748b36f3f4dc6706107a87c79fe88825f0138aa4509f5113db2676e03ec200fc7a10e1574a7c17faf734d3d5fb49175bc916faf477469667431b870c420b50e7cc2f73c63bb8419096a700440b8c79d3c3e278a6f3cefffb4ff29ceab9e5ab8fa4ecdd8109dded6972a710288a809de6d8fc06cf188cf9feb5f8fcfa0d6bb5af5f75c0f136ad54fae763fa00beba947d38ac32751be25ac5bc7f291861d5588a4f9fe0c1eec7eff0a7d436abb6f95aaa904ef51f075088787070794c161e4551ba10c83cc38677385f94f48df5aac0021ad42e026646cc500f9d94149a38e8dc5572d4b1677c6af3c60e3104fff8858b36159a5776ae116d7111e9d3e28ed4f746f28a2fcbd84cf7a2e169a4d24862ed36c53bc85bf5f181d2a1714e40cf79942164a150e02bb6c8007db536202b9fa5b2a1ee749758784130581db293a17611be794449d0887e201d4536f76885ece5a872db08e6007ef1245c771e26748a7b22d3d876c355367115688442a4afb17648f9971648924323b9aebe9f2a78f298eeb4d555a7f2494c8b88cde3c569614e173ade5fdb016efbf2863bf2add24d576c21cfa797dde53136e6aff7242d17c24f9eb213e4d7e5265002469cf082981cb8f0b813166ad557e3f7c3b3bce3261f715947633e9bcaf02736c2f6a8894c51389079c333125522b920207f5b1950810620f9afd0b70071b9cde2a3576c00978689a6198c9e6719f673d9ccedd7bc48e712a3b2bed58d6fa2946ba685916aae782f0610de4da29db596e5e1369be5bb8bfe794db539099bc6e2d195466cfcc2f9e5700a3dc5d9f6ab826d2996640089823940a5cff19c4de7c1b74d7c773dae9f0c9ccfe7244488df213f416a8d7de4d06afd79f0546857c45921a6d50b81ec43b140dd414e42a7907e4e9df629716619610b4b619141034e8c9f583f1760ea733d0d6c06ca92d83ac25e39826c5d3ee168ec716eab2d4d35e2582c2b9be1501cfe3e904d9913985d7eeaa062ba2cd8763a7b6b18aad1dc24df0d0ffa565c843b89cac371a5f1e5fe0958fb3719e6ad46c5768bffad2caedbed4a6cdc2d88c6554ec5c5fd584b1ace2a0ec6e390978411885b679b3330918833597824a6ff78a58d58ba25b8046b4df3f35c41f7334d132adc89d0608fdf3ef1c480df401975ed3e4b2af1cda3f907847ac419a620bbe0436eae51e6e0fe84e96ec5214b0edab3ef14a2c77908dd218dfe126e06a0f64291882d6ade8c3960cc565e4deeee4291b042f1d0d624c80323774a065e0986c837b7f102625542821530b3a8bfb03c2bc2672998adbf44e56661643613ddfeff5fa8bcb23c621a17ac34d7b21d53630c2e3a9a2dcc4792679be1ba01f585edd7ec1e238fa4a94bdb9454b3ae9a6062401983674db44a421f51557e97a72b149e0ef84517865ba058504b1cfd14e1e609ab65d8ead3d67c11b6a5d641829c4c83920aab3be468d9c4289e9f9ecff7cddf76b852b57a2c77a5779c2a51d9570c477a64aaa844355105a311d1c6b5b4306b2967a92e289088d7bd7d3d80011c72599c5adfc52d0dd12abacb61729571473c026fce403f0242e6e198daa6c918d4d921aec23ede56438c82ed58e66fc41a2aaee68a2f899e72ced1010692bd666864f533333f73d617e37e34c94e8d8e5342e9e619c9a472c89cb82416790c6431af7d0ef2d443502272ba70134716b543df6c6f3ebfaea4a4c044b904045b8589b702fad89f86203f98f830617c5a348102b7a99a209019adb18853d2f00937562063f66618ad9c77eeadcb192ae9168f343a584c4a0aaf168df56f75befbc1870103023118c0734212ae942f679fe0ef77e7d86a9dcec854f8f8fb71b355101ae3eb65db0448a6e81c3e8aa64298f0559ab77071a3880de9964863e9a43638be9044d6d4023e7c671ecd4cbd85164770d8ed34e19553961134a8294351ce997a612c203048ce07c28ccd282a757714908746dd2085bd272c06934c73c1f86c289a2f1382322b5b059ebc95a274960fbffb62fb8fc661aceb0164bbf72e6a453349d75a940764d8b2d6bea9f1193fd0912fc69779e09a4595a57bea73963ac8ebb899af5191bacd7bb058eddd32ee09cc0f9f926055090e112e3c2178d8178ac01e34fd0bef209e3dd318812a0dc874d45d254e5a002f9b0d0b956d348d77926e81c0002365849bb3f03385c07b72c258a62e8fe1e54147c16150f0dd5e29b9eda48dc3586e9cf72f9ccfa10ece16d81967a77fb9b77df4634431e05869aafb6bec902731f0e78bf3fc7b5a125cfa9c37ee0cddb438a71ef0d8ed10a21294b070b977d0aafaad4bb274a734337e4b4992e0e5d9ac92cafbe3777139fe777dce9c430f744f32535e551e1b582f6fa8217fae17bb55b2afa5bd0207df2e27406ec36ee168180afde163ad4487433b88a8db90cf0568c73bffc8bf453f6626e3fa903582aa18825e4d701ff9c80604e80e1bab19dd9bc89d48d8dcad76a4a28788b5f8affeacdced6e30111c6499a0378f005524760690091de4fa5f46b6984e5c3a298dc6f423b6deed94e07c625559ad1b50cde6e1a66c3324952c97e5566236fdeb79aa6a6deb498185f402666829c09b58bf44f0289e5d918e9152a0ca9cd2ba3c5ed4138374539e1f0d9096099b44dd123acb8e875b35f8a40406603b2c4846e48aa9db2719b03447aa557cd37d82341c066e05d6f5a1cdab256389a447d3d16f3710fc4decee239c13fec8d5ce496969d88abc80c5605342f1e122c65e559ecb98e4b267b068584c02fd77e45c30f851f93e221ee1a0a4ece796c193133db883061eaaaf8576e3a791d1645d0587a4ad59fe9b440cf062c6f57bf46d2dfe980f5afef919d8095d366b6c6830ae384b7d843f4fb4bbefb271d8af3265b5ece21b01eda6f103579e8f3c5ed496ca797d1b81bd4b2091bafacdbaaf9a657fc05038667feb75f759c8d6190a1772cd7d7576a0b13172cd2c6bdcf3fc7105c20338be3f154ce17bbb547813ece61723c77e5bbda24505f184532136ff89dd5061b4f7b4c565c19c76f2643f2b2bdcd72e6c0eb3f6a1f93d2da782bfb2f8f5f495bb8b1d3ac3e6163440f8d8d906a0333f12ec3ff86d933a53a9f911072736a69f39cedcbad8c6a84d355abe9651cde48a7971bfbf65d4db05df3bffcab194dfc56af5eca1b9d62db0608bbd102d2209ceb200cb3cd827e3261a37ba8ce7cc27c016ddf97692faf64817ebefb9bf9a7bda2df3fa8152312ba9f5b1e5b1dacc0a052d720f2a6e0eb9437d59213cf337e908b358967a72e20b1734f1c59623e771abd97d4652cba54906a7ca54448183b18c661fcd417ec666d2a453fb2bfe03617fb397e21ca6e5376145b1b9f38fd8c73548635fb2d4468b9445d603176bcacafda0c96695734edd9c6bce20ec5b747d8b23ee1edb95eb5f2d6126db162171b6d7207e1d55795435fc52c9c3481f3489cb31ddc0ce64fbe1fa26c92a6aede8fb19a27501a1c6364539d2112c69ec96d21d9808f99eeee63af3365061cecf5c86e9d0c319ec4089e1143ccc61a554596b6a6004d643b16f24643d447e4331dc06b95eda6ebed0e4824ea047a2715b7cee0aac586091c95c834eb8a9daf26f22493768f281d86369a8eaca187592b0dd99af3b21272b52fa66f66b94976d3e0f54afa8c260fc0f401d0a848a35d4244398decaa21035b405dc76152c37fdb9d3ef5d189b2806ed046578e2f80f294a7bc1eabd57c6657d2a0799e203fdf26dd744f9ecdcd94873c0564d0a3be6686c7472ceef1eee6ebf42ea15e5a4d9a3f0c6243c6ad9aeeb42f5cad090b36537040033b5cdca2e19cd2ddc1247072b98d917776aa765f54eefcee9400f8f2fc03da021c79a86eb221ae95528f63d20dd6c6cdd6b3e846434c5ac4822b3cd7531a9b3ca0aed9f105fed6fadbd8b11a22c17f8fcfc995b437dd820c05034acf8517c3a6f55df5a77c1bfa64a453d1aeedd1551df89cf395ffc775c713eae31245e10efd8da9e4bfbcda9c6991d312abc285ef2a2cb4bf17ce59ecfd64a0bd3b0472b7ce1cbb4a3ee3be09f0c7cc66a61167ee5f816d51b2631c6b1fc6d163921dd5d36cf945c9fc485d115885d5ab8303b4f072151d8edd31926e91ebf3288085521c7e64149119978231b087a2854b84d8bf37557bf55340e9e8e75ad16744baebed59cbaa651ba62bb10bf1854c36d9be1bd63677d7bc9174cc6a554e319499f6323fbf819f2e29f176fdd5c3ecd53d3e3dd57b563caca725c48534807d7a1d0132e12f4078cd1e781401d3cb8fd276130bda777217c951e96a09e722584a18c1e304f1d0aed6bf157dc1e4ed15807b41e858daadc89f111d60ca2810b610ecedc9fa3b55c03965ebfdd29fd1b5f0a9162c408e9c13e85a02c2eee5f2de1b8bac5decb0a6bb7a71167b63824820f0d4fa60cc742feefcce606bf433b5c692e12f2e90ec53c3a88b4d2b16313b97b727996fd746cbd98ae8858abee3d6bf0f8685adc0ef048fa3c7cbbb170e82548d429420f783b2c186235cde272f07dfac24892e1ebdce207db323c9d615f886e808d4d60a745577af33bb8ae2989acb84ac014acca9862e9a72ca4b24026a4fb93fc5d8f31127d1c51dde5682481041c29c029451bd140cd2b909c4b24a6d3747e1ca4a5a3fe8af251cd4395c243111bb71df1f51fcd728a406595026e48bcd613bc0b4eec04cb09ea43d838424df835ab335f8f74031b88cdf75d5eb16079159c8cac0cae5e83bb497f6155cc319180a1792a934580497df9850a004289e2715ed90792068cb076d5b1831884b774935f7dafd74cc053b7a56a86da61d272e9855c4eda4a0927e2e5143227558ac4656166cd5e30548d23a8b09627a1d6a4e414f44ad5ad1692f170c02a4f7aacccac854704de33d54cbbde968c0435c4a530b9ef8d7279309659682e0cc99f9fa94f757f7f7604b6232b0c75f3396d9f9208142457b992262b866622446e2eb05cf9e8f02a642c502f2b3542570307fefb94f10ffcd8dcfad2c31970336a79f7ef30335e177f5f98837ef518139121aef8b81fb015743bebf282ac04d303463b26b060f553a033750c207884869dffe400ad6c3d4c81be2643c852e58605e4e03980733deff226c06d16174ebf17aa05d4364b0adadfebcb7290d1fce5d7e85b67933079e8f3d1807324ca13441b646564accb1b1b11162cc689ebb8409adff11c67e7676e947f6bfc364a5481ecb4e1b5974359d43dfc60f2c8cb9249cabad7d76c8fdb5e7824481b74f1ea90689bf85ac18bee218c203cde8ce4f47ebe13694bdf2bcabc4b13990e970d4926d114adb17fc8fc36ee356f1dec21bb2dd511ab17bfcb4a9b76185c012d207a7edfaf1c5adfd28b3e790bf2b66b519ba425bdf9ec8cf4a5c6781bcb796d1459d963671d2c36aaa9ee7d55afb57dd7371f8d861b58118ef9cd7b051d3f64279fcbb9de1107d5b0110f21a352a34909974a08e26947a7ca9979527bbbaea472fa2f2e10b80bcb27a611b1881df05a5c3cb2a9c0aaa034cfe57ecdc268921e207bd93425441e238cddf268cfa5a09dac78d539a96a323a9a5ee6165e7c7a592d299ff3f2fb8c2b26445158d46a11e4ce27e12a7816873943f513c542b3a9e65ecf37103031806f7596701f1ea33bbb6a66ff8db4ee0cfc9315001f86fe2cc1b4f239d9e813f23960666e09dd85d0662f71d3368730dd4abd2779fc9b7a8a47ff01c025e03c6963e4230c7cdb8eaed063f74d59ab557a84706f211c8e37dae3641bdf5e544a94f8f634978c37f81657eaed1c4fa0597d2c2eb36cc78130efcc0f2c8c23c292fac68b46caeb99e26208126a589fb37bcdfc1801356ab60489b1030f34ebf06230fe514c6ea51a43de29325fb12bfdbd597748d6ebf52d80532a9dcccbbdca95944356b9f20f8569256c044b2e289305afa02813cf8d854a29de38d3c97b375fb990102a7928c2ed2d86b68834ebb16beae7eb1773934c049fefcdaecff37739817437afa84af11e7357f4543abf23610be1f2c5001801d6ca4840d124ac2675633082ac33d942375745099580af97a024e4506fa4111a10fdbf3c5198854a1d1c93edcc5570d92c5de34783a47ed52493eb96990901628e6e2168c4e3564f34da6b2bfbce7fdf248df200419431d367ddd355feaa8d8b475f5ff740e3e6bba0d5f26c70fc3b6ace13c6c9ca7d4c72717a586c66436e3617ec732673e848b44ecbfeb42e07d4d2343eecc44d99ce127374597ea5fa837e4982bb7cd3e588f1ff3e2b9fe88bab4eec13cb8ae20fe13c9b8c0b55975b01d7ae800fc9addf8b0185058fcb26a3ea2d4e1d3f2a1a08d11fff2c895c419e6c6e436956876ecc4b6e73c871d67b5a002da1f4b3cc786cd2a63f725e07494f1b84d727a80a691b5c6f1208edf21218a41065af4ff870bc9aea47839449b4399988c746efee13f8c0cd0a1db6ad0495aee575f56dcfda3eed7bc427716ea8e7f8ac5c81cf0f4b1aa963c16ada84d989caf709e67d40fd26cf6e7ec358cb3412ef356dd6d02cae2e461c842455ecd23b800b0f627b9cbf6fba9085ea75b507d03ecd21eda87d2c0a4afd8b903bb913f98b573508a465b8945f4d21cc04d2a255c89a362bf7a35aa8025e8606e4f1ae22077e3fd2e245d962a28395981c6f20be18b6299aa9ca759c4d01dc68f72111eb14dcb99f6e010fbb5e4cd4451b1c1e0fbf21664d7946c7d8f6cda491101df73364820ec60815e6a6e793881ff1a4293efe517bc9e3d16829ff81e018f245d4bee5d9c24d638bf8652f35adfb99d73a665940dcdda28d6c25cd0233bb519ef02e0db55db2933e3b01452b353a4ffdeb055c16c64958fa7bd15da0b81cc24f6cd55d51e3701a4604a9816220fbd1d2bfa1b36af19c441a5fe8ca77d16d8384709f41e93241e57d19e8cbcca359d5c5bb520f48c49f1cb919ce1b8395fbb549f1b47c776a5618722627cb2c55b1f6e1991159c864d5c9233c8add5297df1d92c2e4b9d8a70c35ffad6d6c2fdce47962c066d6a256fd0cc878c0748a0489b0658a90bf647295ff16af166d7a0536b80cb151b1f4b192f766e971f10ca8ba9bf98f8859e73969eb3ec2f53887688cff468d19d26034e7bb1a8753d060513586fc3f6b00c89931774b401e925e395e469d3fcc1a759b02314cadfad7d48d36885b82d29ebc0eca40d7d8ae7e5828632b5f64701f4f74933d2546ea3a25c5489f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
