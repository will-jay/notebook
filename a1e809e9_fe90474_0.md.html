<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cb790953c76407f7b9e919bcca36df64eab78a9cdc496f2adf1c6ab97730758916477d965ab496cfa6075974e4b8f83ad7fd4ccf07cacb6557fdc05d6bfb4654715937315b4063f17b76fa6fd65271dde0081f57560741471b2fffaeb9ad9d5892669ad2fe4523d0e5f2f7d9132b6aebf99c9dcc5beb417840e39a5d14101410eef00c272e250886785f4dc553fa82e062c55f3432d0fe37a35a60e697af23df270388610d2e67ff54df909c4723077be7b4c1e6a226576be3c39ed111125da7d1c505566ba026d43137dea90dce1b63b80b2dd4e153dd6c8ee4b8d20e66aab3879f16d6b1d17651b2eac3f8616d4c4b38a429dc05dabf1365d56f2ea895c963fc63e836af79bac763bc76bb9025ac6069a8f4bbe56d50d546dffa0929ef962dd3bc398f785a4c4ad6078994fff4ba461ca9c8a52188bb9fdf3dc17fb9558c0107b1bf33142ca8ac81301ff8aa3813b24395a8617f89f6d52571725b92232dc21caa392ca8192d8eef2bd51a00c76d1e9e6b8565e13465e3b70d3b6dfecf404d3d9eea398b3503b178755c1ac253721abe09ee32be92d29067ec0294d0acc68711ff48c39740a9da80d7210eb02adb274c846d46fb49c781996a9fea86aeb85cf84ce3317ec9b7eaa35d60d925969550d980adc09c0bdff5c560e0b7d44e478d55adda099d4d8d1347297b273052aa0513fa934b37ecd24f8ce73a9ce7c8ec1b2a3bd26ebeff54cd1bac15b1f64472595ecaabeebee1bee48c67e9fdd18fb530f92fc1419d7c938b12af661ff57ee52947fde3c8ad54bcd337fc849f069ac57815442c9a675e5bd8f024de584c602e49dbdedaa9dc87d4dc47865af80fc8acc21b497f8664332a8553a4e4235b64d8a7204f502d15a982caff4ae868bc2e9064b4554743af0e900563acc414bb1dd52a6e39ae992518a2e221f0fbd6cb9a0b854ecb63d1d86e53e6ca23415546884b80e396ae4a5d0a7bf47a00407954afd53b4f0f9df2270204f314d6b151356f7bc1180ba04a8c48cd410901a993326dd048a2b8ecac09b4c6ae07077be1008738f2500fba5bc6bc1a4ce1fe5f5200b094f041caaee2d5c1d7fca5483c7855189cdffc6e38b8683190d28fc306697550607c70ec6e1a03f8b388173bc60551e5a98fa3e7da56b8d0d28a365a850b0497e1c3a0dcfa733d0f6753f4fedd0e3245919b589457cd4fda58a857696b26d910fd3576591a3d24e5aa4a92a0db4a07bbe0194e3720a6613fab411995ba6a275aef2ef9f661e945af7aa7797857fde45b5315ed624b31e4526902392f8c6586d765126dc024137a46932acb7e51f11ade6b6fc5c528248a5b5050a56830f5b63a1444df920667512cc23551e42bbb1574fc0cf83ef562bc3a9a182919fb4d365aa404dcb636b72b1eac14fe6c367340c92743759a13fd13986f206a722f6607a77b95e9e497f6546c8ecdb1efaae7df7a6f9e2d4aac0796ed69e4152a5632cca20bef5e5fae5520208f9db88d9f129f06cdfe29fe9b59fc2c8b00d14e3c6d5e4ba77860b58d6a529ee56bce0bf9127a963386012f9eea0f34bf293dc2cd4aa2cc36352b6b900298890fad1802319c81efb95194bd1e6ffd95f42738cc2eb36e7a67a3124e2b83bfc2672678ba164eaac4a5827802e3b2e4f96d1dae6cb1ac6a5f5581fcd0ba34e098f94aee1355634e9b34c0018f0ece9476b67b09ff86a4b65c5c10f7d1cb6fdbbdff6f19d6a952f4d9db3399f4db539c1922232fb672b90e280daecf29ea1b72c6d772486e0ff75bf57717e7fa430b54f9e982745dd52c0e8575bc5162f6afade7ebcfa76d9d03983d5c3165826255b8f4fcc624f3b163cacff34cb0c6c7cbf5148d64c6158f1114e2d865a4d94eb167edd2a67706b870bc6a37d8b79c54c054a04b70b3397ecd258f84bd1469c31df7ae0e75e323a00c9d5cb043be8704db6422ce70f77efac9a32a7c81113f2d21eb51a4d64a09f1bb635ba2eb4b6cee56b9c6efba05d6efa735c964277743c25846be65e883ca3702ad2b1f1b22db6608796007d2028686eab0b983ae6b81bf2bbb4cb100ffd81e64919ca6ed1aa1a91a2f19b5b21f868573d382dd9e32f3076b79e75c3c3ca2e58b2aafd535bcf963b55ffd7178529ffe7679addfa97831d0e22789fddf5be2f4ea696f25845576c21c85f0f4ca1672856722e0878736abd67d831203e18116a511203e9aa454e6713ff4c122b0a4912e5d43fb335e43a103bdbd12992b627b47e960d96a23859f4e040f0db39439d384694a0c4dfbc1c5771487c0af562555182013e967fe407dd7d2f7b9e453a8d9711d6c44af179c6076a4b297c93fa852f8c680ef17064952cf404962ccdee5c68657ad0a4a54fa7c6ebe07fac45c184106845105ed689363c230131f1ae3c864a74aa32aecc8c611d6210417c015d4eb48382b1bec9db37572f3a0c53beb86d3ed75622c06fcac6fb779506e62bb7e5b9cec85486ad092a2a8105d5b2e68682fad2412180a817ae3c40945876243489df4fd2046660459fc52ae489811803600aa3619407dd785ac4f8fa9a899c879075f763bb2b519a04124955946b13705197d7ae04b29cc8fed82f5aec3ea5d44903fae532e2c5505842690157311b9b7e59aad82bad7869b5350df84101f6d68b57765cbceae60949344e2a8a468fc75ed4b108b10ff8fa8845b59fdb5300ae7cb13a35acce5c8fc9b9ef243df18cdb7145a8bcf17976518b3da40a68f1fa20ca5a9fa588fedbc41dce25c9f41db4e81e5d05338b0e88935ce289ccc16e11429f98baa93a08eb1db7af1493e091e98e48d4845bdd259d9a6c3008840a71ad38ed587ebd3c412c75a22d6be3cddc18adad0fe7587607de3f1ed9381ca4609109d75d9ad39bc8fae917b9eface53784676ec75376795e4e2ba249b3f707518e1932f1bf32b4d2d5edc37be2dc28408b57d00df877b83f4dd5df70d4adfb63b09d51c3cd25892c3db37f90560cfc00eed8326ae1a0359b06fe38be5d090209bf5611bf071c43c61e2adf6b2815cf6553a5648a1409c01e0fb9a4cca9dd9774c69c0cbf831bfcfd577933a2f3dc276e474540ce814210f27596573c66abbfd379ed518fdc47bede145a3fee59849911211a76356a5c65fa7bec6f9b8622a43ec1bd06f526dde7f1bc755b3ff581c5134bfa81ab91016b51171f8a5a9aba2a8b01a0a88d5daca0e843e3bbf21df7abfba00533b14571a2f3059db3b398f2b7b506cee59b252b230f815b410b644d7adb3b696bf92487daf91a1654864743c0459b2c674f1da2707fe85d34fd3e87195ddf51e83f6d63f8aa7ef5965ff24a03535752605876511ae6093653aa905514f0829f44796a06963b8ef85e0c0bd3d3092306bc91f115b8d3ac014751e61c73d0d97ab492a5543d7b691eaaa1aedf32cf29bcbce77331ad95c16b60dcbdd9e76986ca6c6957623684754606483996fb8261041bca777cf41f242aca71950ab0e2be9e62b7c62e7a529898b70304c31c76a9786c4052f1a3c3d3bcf1377b61aea8fc4f3a5a61ae2ebd945269ccac7f10f44f13feea7e637434f3668a28916b400b03c07cb933807e3c7b2261e88449bb12aa1abaf08232a7aae5f24806c258d637ec2b032829ddf2c3a8da6d484fa466e3ee0b7d93499fef0b2d5e09a164f3cf368820199ae768dee87662ccfa86fd92b77442f3ee2f9e2b2314e2fa1a5b8f673175db26d745f76570273eaf73d2cdbb0079809d408c102c1028ce54869d0b4b2a22ca205eeb86d119796cbbca178da416f02110eb0652b05b44109d2ca7bfa8b9f2c9e24a11259f40eb27211799f4f6e849579aef832d2d882588c2fbbf15428315acc8eddd5b788333cee1ee4338b54cd3dfdb5283df2dba0ed070c0caec976646331284dafdbe08db10f9fe6759d87ad8edfe130054df260fb7997ec847f6acff7ae0dced8422a3ed6bdf367e481fb27546e9e94dbb669a6cc8c5acc8ee6bbe86f77c32e57cc5a8983a858f8ac90ae683aac62ed7ea11b38d51e2c45bdab9ffc4648008c5887cf7959498a6fadabaebeca413753fcf8af804ac1528951f5ef6b1dda374f5ec9011c5282f5d3fe50a8f3f3ceae08735fdce63280881eab18ffd822f69faeb76a3a4b517b03a4a3b49a04637ec61a6b265840ed84657ceb80b7d0fa577d9411f0698e04240e4114f616cc72971388602ca33493cf683e6fe05f88ebd64d07854a20722c5bafa45f67474cdc439a9e0c2b7eb18e1ada3efe5e565bd0700c381b4425b0690f430bba8cd235e75fc8dc27823a1fbed05cd0e6577ab3b60e51f04e8a409851c868ecb400ebb428e343eef83c0fe68a86e2f4bb3f0dc8ce3a22f7758e3a642c2e40cead6a566743579ed7f6fe4f96d23495645d191fd2cf7c44f93f9a46bea75ef6ab949cfd308515c160f065043b8a3e10a8b2ae2a6b51c4e26c8b0ead13766c118094fbe68013ecff025ca353dfca6c9fa887e5308b193ed2162b49285897cba1adb4b6dc658d13a0e560cd40a3c77c6f6eca05c3a5d228554fd1279ee7762cf909c9625dd661f6c38b6e9fa1ef9796f32d4c0c531739b616d05c7baa9bef9b134f76acac694d9440e5615966f9ffbfe95a4ffba43edd04411ae06cfd9ba6ae806aaa1fb3d3e7388dc0705ee07f7b345f917086aebd8458a9b18c4a4e339b15811f9454a9d5732cfb5b7dffad97bb096186c5c0e72ee88a328e00a7ba058d2117865d7e2d49345e30092f445de9093397cf2e1e295bf18b0cc8316daf10b46f756c5b3643558c59cdf0544dec7ece549c7542ff684dac522574b096281096b788cf4eb990250a1a00b0faf1ad401200c08eae0f1c107be7dbee3bc4c3309d8d580385d7f98013c2aea18cb43bb92958e69d7e464426235f926e22c28486646b0d64a5faa37ec561361e1d9479d1cd251d1969082fcbfd4ffac243574a08cfa60d78782b0d8a56ec2a6b3b3f5c519fe1ecf7c83f382ad1e0afc03daee1ee448d0a94b6bae881da5e8f355dfd15bf857da73a50e3a9b6096fd63efd7a0cc4017e6e406721e03cd80935c2cb68fa4a0ea1911df18e43c54f6b4d8579db87a7de751db6fed02194c6bcfd3b9ac631e72fd8f7649b571ce2931c439098d241a47e88929290ab773ea7469bee6dfaff15b6b91332991c1a565662cc88c3d942dc7dd7f0b07cbc8cf3cb9d6f680cb4d6a253ac8f01bb8fec66616acf9971e37a29d8e0f4875d808e799ae8e6814725ab5e73844e6156abf79bc15815815e73b322823a0bd7bd7b08c9fb428651a6b5e21c7357d923b1ed5a91e6f27792abc5f35d375879a5f2ffb82ab7c668300d42af502b4ac25140b7747394572ee18f54ee6dc6050f38d20347fedd986b2763d2413936b46e674bef9a3f19c67595fee99f947fdeb7964c6dfade8360d57a288cb44d8e588d8887c77aacb9daecfb870ee59b5013b8daeb6b953aecd080f649ba7fa313b7d1c74885197eb4439ef26663b5ef39780bef61b0959be220a5f101c9c8c943fe188fad4ef3e0b394e35eba987cf85efb3577778ea703e5304daa5630e702b78aaf259569b6317a037bd228ba75f66436dfb59826f95609b775eceb0850b3200dcbed245155813c737a2c25c3f772fe469ae20915abfe6b35469775c82ebf9b2859df3b27b77f0761682bc962094734af9f8a682b65e8439826bfb3ce89dbd09bb0f2c6e11926d025fdc4c84118a64643be1ecec660c189e1db437b62f3d81b2e300021a37bed46b959ff501caa5d8752e94468177ab84f938e21417bdd60a449f515a6f2ada719b9073e97deb659ab5d3fd47fc67b83e243bad2339a6f466616cc7da78b7c551cffbf5c9b4d72e31ad593502822527986a904ca2a242ee4cc1ba362ed79914b187032427a97deb2b30a29046b93ec38951e9e9e6d33e6d4ffbe5041ea1b0d286d988d2b85268b45436470d6e7bdc19d0a96b7a45dcb284b3c9467c84ec9b3fcd4976b88bf99bf6bdd0ae09eed04c650f8692bdfdbf0f2309e9516184342597f6ef09f9a32871e36678be4ae2da98c2b5420e82b48730e333a601206c23682f8506dcd8cc01fec0cc18ca9bb15819c0db79343db56a08a97521118b4e4e2b917a482365f9125531af4d28f05e4b90bff1a5f63ecb84fa43f604618e48a05877c498a91a858f5b9e86afac7b7d5c844715fa50897f5c666118c45cd5a7ee5961fe856a363bda20309d484382c08e02214bff86ab68da7ca8cafde383cda82406753997cf138d18256686fa49f824d64ebfa406d59d93502da85c1611be28c89267b80b4afcac934b252e6f98c5f00b8bc7816eb0a26aa1a76af6e14370eb0158559373fe6542566741fce7113c643a82427ba690968549476538c4bf72e8a15b85acfa1396b06fdddf892df3c831da8fb9b972696d3d35d7a0d8f41db436a2f97aca06b932aa31838d6bc365af45fa47cb67d90dbc5fd5666fc506c381076fd5737f46f3b3c5bf06a5d64d602edf7bf3db61c4da20521ca93964163dc4f0a5328568c59745774bfbd7d56cd1b40ccb86ef869d62aa7e112c6af0482b8faade0f9c498cdca45f7c27d52c1b7440cbc267862a94c9322cbedf5ccfb0d2a201591035e7c04ba2f011db924af9344a8ebca0b538c8f0a38bd20093f15234a9a3ac5ecaebf690a98fe4eeb301bcddf4d2bd4ce3c05f6faddfa6d39764fc345868c48744a56dc807307e1b4d47c50670cd19fc794285d4cb9284a02f4292a9915b66f72d9cb62d3b7d1a1f0575d45a1f0bd00c22053543caca2ce144cfaa3ce5e49ad2e569ad7159c20cb31ebbe5d1641ce7b03f34e8c5a30ab7022ce8612d4de3161c04ca24567f5a6c7069c388c7f19787f96cfc079d9bb837fcc79fa1c7bb1f739c59383d579a8f8c58032fac4b9ffa9dd340b81d426d7b975b3f9d2aade2693e64f5a50b1551ca4caeb950cf1143ec989783be1be69494b7cf05ba4676842f750d76a750d78e433dc25a565c5cf52eba7d16daa78fb11d07685e083a09a22872d490c3563e6de37d7ab96859aa24df5e27ff2adfa237da434d39b335266131b35c9875b2165d166fd8e97fb6967647528f90f56a0d5e22edce070f9b5612f563b837e4e9383a78753f7d4036d479c656933435fd86bee3cc54bdf364a958f1c89d70360f1a85bcb375778ba6c744c164d8a0dd4a241bb3ada0deaa760d348d31041d62667362a718468b1c1af48d79f20770492a37465a7be125dce4e3f9fd024d8bd179b9bc205e22287e25a8c425777a6105313693cbe47ec330e93483ad57123d7c32f2fcd64aff266f958c3877802ffd629c0aba27affd07b10792552f118425fb7c7a65f803608e79846f2c2633d00bb0e75684ad73c7fe2c248f24ae850347cba5ff102eebe7780d20b52ed8bb00fe12f04c432c0a77e4922b8f53b6a1574c85daa9596cbab1946cb86211a34ce624f46ce94be7c1f5361f6345ef5059adff15a65123d241a68063a79204846fa61a59cd2d7cd26b0407e1b72c89a75189ff4c8533e9b86128d016b08b5ad6afda3cc8e753cbb4830d5e06145c5e7a6920d25379a99e1323badf1e816adb7b45b562170f7914c5051086913ad51473f6ec8c18cb4e0ff4771ccc10e3e5eab0b085103bf173df18052c779dc2b3fb61bb7f41035452b87a47e97a1c2f288297d70043876eca0e60676ab7d94328781cfcc56dcfeacd272cc98f8bafc056ad06e3115226faaf2244d5da884533d5c5b00aacaaca2b3937e789ca782505bd84d7384be7b4489e4397327a73fcb13c3f972deec635ff1c1fee39a8b85982eacb2f6770ddcad9f0f4bb161decff941cb7054c9cfe6898bc5bd20613ea5c9277366eab56f16318f57481c25097c7fdc1857fbe1544523b8bcd4fa8e6d367a0c50a7a65690734fac7ad4d6b33ec77700c637008fc9ef9516fa2674ef4e70b7ad93a0cc7d9af064dd34091429b8b62cfb185b0652eaa3a6ab1231658c25b33a5b52cc9bd55028c4da2efd49ff0c09b477493bcd0bb485315e6d00d327dde0d925d1d105b2c9dea845853577c2c507815d96a179c8a03d85fad54778fc42d5902838519c2eae38cc07abe4e2ae0cd206fc3e8bb6bd1844f2d91bbf5e6f23300f8177c19602c854f14170276ba8225d12e7ec3b90b276dc0b9bbc9720676f199f9378c8b84811df23bfad5cd3f5587c9f8926dfbc5c9fca048ef128571a54324bf984f719e815f3521cff88aa93b432583095dae5503ebf9b8deb328891369b063e9f291e466307215bec02fd23dc95e7275d123ab9caf664dc5577c36723279a30e41a211640ae9e25a82e2f5eec88f5877cef357d148f2ac9aacdf5929fa082bb64d294867c57753e483e2046d947159cce3b59b4490f5df50e23bb732e46edfc3f466458c91c33028a83dbf59a1e90e6c0252020ff78805b2c71ce689188116fbcdad2e935cd5a79f8af2e0f8c3d719f82bc2f529f60cc5a067a6ba6043bfc16adf2f9599d6887dc584ff7235025aec2112f602c090204d39c06f2baeab8805a318b2bcf10763870121745b1293ec4e651e0e55d44188da6f0043e7e686a4bd8a7fd5d69e70e423ebd7c02db6d604e953ea5a68e8ebc9bcbf9e1cc45a316a9a1f3d58633636a202831f48823650ab19659e93783b28c46de54499c28816aa7c5cfb6792c859b772577868135d56b4ce42bcdd9c6ac7e77df2d6dca6d191c3e652626f467beb7a07957e9ca17f56e93486dd0dedddfb042c9a8684e2d66c737ec65af803ab0d190f2413fe7943d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
