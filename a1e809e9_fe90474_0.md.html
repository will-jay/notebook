<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97275abf4160dcec8670319d580f3972d8792843a2d71bc98883a3d7870d49ea1baef419a891c8936f223010250afed7f672af32e0c337af1a58165a0cb3a476e5af0f3745f792b29f3600a78e6aa683e14e2301c9289bcc29f44a33c0011b5cfbe3a67146c74106d459a26e35c664309fe0f4c6f3569616c24dfb4cc6889296e9165c720f5224f7e40ac4417e97a459054dedcec0705d60e223d837f5d4a47ba9538fe3a69469e8730e86026e6c1040deeb554c5d27b4cf85df8eae59d97e3151526d13abf668a2b26a63b0bb8481214292ab8464a5a820423c437e56ac6135a3e99a77a4799bdbd87c4520754743b16d9845fb59b127c23b6cab3051c8f4aea75b72552e8e8b1cf5da96d20ffeed93ba9efb56875868aba1055862c625d8ab8fc1bc40f6ddad157eadae3cfa2e85254001f784e845f19ec2cbef1e76c8a7b24109d0279541061175c1250ea8e11706b610e28d03a3f4be6d88f870409241d38b3ee3e83194dc5f93be508cd995e08423ff36fb5dd899c1fe18fbdf9a25c9bb1923556e711e2a8635f4c50eef0c45ac1964e4ed98b96aabd0c090a087f662ba91f37f712edbd2524d896b13f86ce5d80a209005cb87b58bc109de0670b12aa1dafa87975e1de3e6c64a516bd7b786a9a145bcd266e23a84de0a180ea02fac57320a2930916a9fef316713d7becc9a31b5fb63165887fe743a263fccc4a23531f071559cb21af43e4dd0146c3b292a6e3cbf89aeb711c99baef9b3e3181b54129ffdcfb9bff8037a3ae191da14cf02fdd8982fb2585288a3990c2db6f901e2108dbff2b03dbf032ebec2bc3ee4c4a0e3200427fdc6e7e5fa050bdba3278c38532e330706fcf62fdc54bda05b7fdbf81a87ad1dedb96f7f25200f13ac32ba57d7a42f4e90b9aabb9c85ca7f1eac2d5e20f62f3cff7aa85f70472a559b368fdcdf3e4435c6ff05285e7f8751c30e492c6f1637c02033f7dcd1460322d46c350a1b0f14a86ff543cf5a2eb42f00568dac338ee61de8e88af29ef532afe3c6bc5f1f1cab743c0f763a1a9827bb13859175459b45f7e241dba508049ed2612b547fbf3642ab5af5e0aa47f7ba37e0a08d241142e4382d92e2a3026f3430a13fc63e4bb347cacea59ff90f4311179956fe95423c4816415174f0d7a7d1510015c37bd9a2e3fb6ab57390905ae191adbf1534d3c2672962e35273e3180f0e5b449fda15cacb5898e4d154aa8d43ea6192160d5c6426f12d664c7a0f10af629e6f5c66341e993a3a73f755418f86646f4cc8baa616079fd511f19bda3a223fe90d6d754504316e731c7efb41bb3c38fc98316f88d2163075c60e1574d31871625d95eb500fceb07935ce9d86160079857153ba425b4c3d0a40ee3b8bff1194786af425ce14128ab4ee6c7c03deb7215172ebe6288f3219f65e8beaa86bd5ae93b6218309770daf4fec3ca64f7066ffcd78e53862f74d53266a2872f69d3bd8c772350c2e69b343a058bb109c2960b87fc51bfec9a074d66affd556362dd0ecfdfbdaef66a94c4fa3476029e5e831093ffcd9f32b209bf92bc39b9be25fae8c8689252dd7f6bbbccb94a0089bc5664a94f5c1198d0a88694e5ff13cccb5d14331f957888da310e13c505aa135fd3f06ea95c786da731fa548346af2b73fa410f843148614cdd671b78fa37a977bc48bb790faea9936511dce52dd88a5cbce6c926b725564518570a118bccf59db558c7d501ebf91f9b7188dbb6042f8dd7d1185ce92959f93c8d7bb35312927ae0394dcc5077b598423c60963363bd5c54377efcace72e60faee20cd48e54638daa4ba8c7d07dff35f1ecd960c501f2ed731efdd5b2ac187385987cf3958a73a141854d85d30dc11764b9378b1b8277d72de60fc26053f6a667b0e1b6677965e54bdcaa4286205e400807e3fc46f15141071c69a2e0d7cad5f673db9bec7c58b07736f06d7c3ccdd9410529301075185f005a39d59fc72aa06b301ee211b3c0aab60352c2771cd9f93f43898637e9d507a067a76bfbd680a8edcfdb7ce3b561f491ab38aed1c300fa274e8ff83fe5dd6f5aefa03effca100c77d2614c99f75b7667d018025d8c92b2da46531ba449987cae56866623f1c41214bd711cd5880588586e310d34c970f89122a5f4843afa455eaeda4f82b6647b049ee737527b724858de02dba59829abb41a0a317bbc839dde03126444a032a9154029c0049afdde9f8c4b636f1e6cad0400b5828bda0ab9ed47775b9f0350d0bcbefd3666871d8c649d1afefe7a26862643c5a6d698e646636d6fd363a5d3629279e8aec8b47cded4ec9505b7db9031c44e45dbacf86c1b5776415cd4393ac1c8623e06e7ec8b8548cf0dc514f7d60069cdf1d2543ba96ab8df71a899d585817cf5b6c7652f187bae58adac83a06af68376df0cda83b87506b90ca3a41cf0a8d65263f08558b9571dedd22adea9dcc1c1d78a276705f9a7334fee9f42466968e59a0827633faedf27c6fe2bfb8ead935796da7e8ca1eadb88422b31298ae800ee4a9d16b56253561e20d22fce1860521c84ac64733d6be6fa0e7a9b3eb2985c7e6c1cb6d90915f93e62d4847465a12de181ef71f7bca3a5114639e31e99dc604af204cdf8701ae539c8f5a655cea8e9dc3709ad85f4232e321e54d9b91d3584c820cb1ada689b5ebc9de97f72d604077ca8ad21aa6367e2e9a464e34c39236697cbe45d403052d6ffd12a63e6861ca9e987cd3a2b4cdbb6f6225623f5f1783f16c0f5c801d4757292e70257923788832ae7fe4a69181bc249c47725f78490ff9ac102f86c762239ddffc3c480fb9ba74eb3114647a5ef21d661722fe88317dd0e85e46420dfdce6856f5117750556094c34dcf3e31052d0aa394c9ae6466a7bf7bffb86a706bd3cf00b46e4247de3ca1f6a4b55acfecf9a23b203b481978547c3091106c84e9ccd8a3d76f172dcf5e58beab5d65098c21ab66d50db3065e0b9870cc4e02c556cf96199aac80a7a1e091f6621641e80c5fc9c93bd36fc7f49c7ca14faf03f3e67d637213d9a823127a719772bef91613fc51a2e2a10f8580b923ece4953838d9b588e70431c2427c84a7f2295401f368c31fa268cbdde142e2a7c8118d84f5905baee96768844ca93b950454a7b249e3cede8b2ea662496abb295da070245d0258c371feb03b0d2c67ee4f34bcb986f1d383b0e2755687ef43af1d25a9d5cef18cb588ab19040d83354ee6d253aa2d5b2d080d21c45a87a4d81293ed28b3981f67c4a43a7787d5302c6abeee6929ee6d563d672919bb281b96e76cef5032bad222d5ec5d36781d13c712b39c3653b3f5a2b47a5a372a0749cc05d54a8efb65d0dd45141a7e7aceac139c40b91102666e107950a823bfa8b40fd65530fa7868f7102392d13a899912c430a40ae52dfaf5c595b76d620d07d0654b2ca9c806f21b693961f18d512a436b75de64917120d1146b86796a45ef4cbc75afdff7b1d8cdc1987d8894bc3982f4d12f73fe83e1f54beeed953c16d55e5df14a870bd296f1798101f3d34dc9f200345905354825f59955742eec209f48bf3259179c742f2ced176b1df37747b8b3d84804563c0da06609509c82a9b5dee299ae32974234f7ac766a8627561a1b97c00a20274422a8af023938a6fe4d2ba4f87292b7157800ffec57d9753cb04f5538f8ca56a5cd591baa8588d9cde0ad1744243bec2f07e28ade6e1e53bce194967199041c587483a249ca0f6136e046c27f5160531c2bca28a901ea2722811d606e0397dcadc078b2f51893f8fb207453883f2f9dd9583135f4280c607c7ed55051106833494ad785f89b4345704a1445888b5e6e99604d0dd18b7576dcd7d87693c6873759287e952b3e7c030138a83529d25a03755ce01b997199bca5888b9fa616056545ca4222a150921b5ae5ea26698f5e2da4790fd7d1b533ea1624dbc3692423c458f576be2ba3488f7b6e0278563dbcf24b4b84344a520de2b92bb556baed3919f2d3e448c0b0b0f64190aa7a472943e840b5388527482858f2ad77a5488e003e78432020835f6f75c0a08f93769bea6e2dc758fe507287ee91166bea5f8c03df311cae8bfec431de2b8b228985ad84c63a11d85ec76423e900984205f7f10fea11f917743a1a184ba804ed4a50b2825623f8e50d7d34eecd2a4e8e4d9139c7abe298372ebd597ad38fd899d5c1384ad26cfa4620d142cb6f088f03754f9d35e28eaad7c724828d468286a43cffc7e3826443e547664f8e450b80b2dfcb8bb90e73fcc2100c6613ef6f27f9ce26894126e10d1a083bf9daf8293405f4a01ecbcf193ca4147709421d8d340ffe38d6e37f4734e3f07e3c0bd2cf4f8b36fb21f828a95ee2da792a67dd8aeff88ae4395e006d5cc266f113a27212c929332f67fd6aad26e451156f560f4eb9b93516ff416fb657303ed35307622b24a3ac6e09951d01c9d395b5a24ab3ee86cecbaa5087d6eb2e0410916a5839b32181a985941ca0b5fd301fb382e7b7ae8c33a9b720e84968b95804dd22477dca37588e04add4de4e0a4d8e39b490f5fe9371a373c2ad378fbca447c911592d8e4da739325feebcc5640bcc7a8196384a09c001612fb8efcfe96f98b81c7b3aabd0e004f83c92bab5df546f4c00fd2e1f2813d52f2337564d4d61ed934ee9c9fd8d36942c68ba08f906588b258a8feb18b9e0e4ddd883f699deb294357e58ead4e21443ce1bb19cc5abe501b51ba6a306e3a322f47e349b5bef5e47257f833d3597196beeefcb16932b2d21807612a8a42fc09075dbcfd109ec3c23308dca59013fc450bd7f3759c8b12f6d30522a1afc6ff0ae2d87207efaf5c1bf0bce61e5df304a2c94687464cbf68fb0e879abcd299e8b85b610942962f9dc8b1222e7e92ae3994204bbe0a38ba250566671ab657aa128a6fb479c6c39d0022dcfcf0aeab8c9332a334fa3499e76dc45864a66bb860bd1b499f3ccfcaf1a71ea343e1a5b803179e3e100eef4720fb89a7be550afa748417c4bee86e499b92d81c0669d34c588a56890282626e8835b393f32b865d60307a95252029315b506c7945adf6c681072176e15ea20bef6e169bc8a30290d85d9f9e6dbf747da24e90f3396d8bd2d395bc2cb55ce34fa9a61cf5133f8f7ca4924f82b820befa4547cab23bd2f23167256d54f87a4a9794bf0a296761ea21a9aed95274262f1b416dd9266e3bff89d1ee9c5137dd72ac21aa02d6d8464fce124b990ceb2e42c5c238a562016d0e80db26bc160ce7ac5e621b6337eed3ebc170767bd90a1917d4ab93de165d1f9930f47ebda794a05ec53e28b99aedd4570576087ae6b29d10ba4a8e05fb6a0d71f455a8e541cf1de2eabe11c22114aa32a4d3ce4e17ae8b29267421c62a8553828108b73e7d56427efe6fa32226f259ffee4d1bd6004495a1b56fddbe14f18f7db6a4d7bb18e4ec412c77dc57a648690647a4a0e885510b6d4ff1cc060eb4faaa77513bfba3892c5d0981dbb6cc72b6a1fafd70f8ffa1205b8875ddf4945fdb53fa15449ec371a947e7cb1ecd08f662af4d1949fb71be9835abb9a44764250b9c333ff80fe7318be670fb4612739c486696840dfd54a35869d94fc40d128efdecaf23b2cd0c8433a45ad7e498c012b98f5d4f898efe8cac40390f7ec524bfe487191d616bf85a6a98eb40cdf8759fa102e3217da59a047bc765ffe91e442ae687074eb701946b49efbb05d9fdfbec87ce5086734156bff582a901f40ee9e5f7e100436aea34653e5e5201a7b1692b690d5672e5108fe7b89ad631c89f7757bba8e6c4f3314dc9f278fe8d4cbc76b23da7d1d318f86116ca0ee525e318dbb3a3f0fe074b157685309832af9832b0ec847f739c6b24fc99d9cc38383082f56f0007bb357e99a94cc2bad763fbad61728963ae40be6d97520296189e7ffc5d7f78eb186720dc1864c7b54f1c4cb73154cb69b196f776b275df5bf50b6f5b29e0738293b051587cb72314a3814f8b5664c5b400809fd4a97ed2346607e8674c4ecbaa4fe85830118acddb9d0f13c25e87982419ee911e1773ba22163ca4997ca5e9cd8ffc00f094eb87d1393907acb19cb732bbd417099a53d682bf111c40ebeec7706f4196a5bbbb0897b3ee635834efd8476128c3529ffcb28a7ed7f3c98c097921e7cd62d9d489d399f9763b91989a752e41bc0f50f9416d46f023d985a9e4148a1a348b93932105e703be16b2a8968920e0e8df46adbbe5e3fac64a4fafb1ceef8d12d6950b7732a01bb628dec112f55827c9f4e02e7687290933d331d050701dc4e688065eeecaa9673cf4252224e9956f4f7f8e6c999405753475216c72ee6722bb0253ec170bc835a77f370296a4f4568d57471d77cd14e21c00909d997f15cdf4da89553000c746e158a29fffa50d25be985fda4026cdcd75cb70a209b239c1e8ff5c85c3f5af92a34d32eb0bd15adc6cfb0b9986890096c7e694fb4682a835e4f4e10281e7284deb9d37af85903afed6ae3bf3fa1447cbd38ae35311ec48094fe77991d9a440a608ae9a4d8751bd8bcb9cbdb4a01217cd2f75c4d6f507c360e40c936d3ac8c38a9bee7ba8887ce1d316dcc39f5f091ae5b37883cb99639fc05c0b598dd20fc8a3efa0363b73e41ac1c23651029dbfe9ff12e7f6ae5e4547095c0029b814ae060175bc475887d853babba7c76e3b74200208c3202add54dc9f9aec495e02fd2556c93ccaf93408e74c27318c690d13364a74611071879b95963c062435fe23aed863f29fb23b72f47d1083fb79123a14b083f529bad794606c90afc599362d4d6680046e5419eda3f07eb547fe09d9dc19c896c55bb4213f3e8edd625e5e257e6aafe1e992bce1a855c0c9aadbd88e202ce5354efc063a02a2bd2398abfa26baa895816c7a19f4f52570a8ec509f9af50adefe35ad8ef21e81c80537cb277ba1ce657c7cc274e3dbc7c3b4a01b9b0deaf56bf34b554898311f158c32929a2f48733e067c9cff8346375e5101cf9e061fab28c1428c46ebeb8f0a015199d1bf2c86d29052df08c7aab3687fb4b6a8f6072c7386c24aa95e2d52728597d08c42d80f093d00c39c7450bdef7bd39109c6dce49648a1552541b56dbde82a9ca7a87cde18a3a3e6b669c84a3d413e087be232abe7b796f6ee4e01917fb11db8e7bf85314aa5e53886ccef9c7001680d015f7b840e19a5117d8d468a729cbc48af261c34465a645ac374465c957c826847eaf6270f8a9a84612188b48a4e8edb79273a57b68a710a070713dde54c1cade4fd1e092dba8737af509ee34e5e6e4b8dc73dbc53c3b57a1712d706488f252e7e00c7bb47f81bac6f0ae8f065e8a129c675d6c5c9c174d0cb6feb9c60d4625ad80a64977064a29fabdecff79c5e0008b129838f33788a29e77627b8da6fa447a9f35d209bd5b1eee5e4b70b9e93ba01179ca48772b2d560074dfe33f48216ab287f50c30c2b0ebf1cf304a4cca177c61a29aef4cc08ef86a10184823e5f3dac5af0ced12c4b528ea3bdd245def08eb5674025929ab7861f95d9727477a15339b6410a9b2bd13f2ba4811b05bed31e5b9ae6dc2f7c6f877ddc5eb63233e54a4a5698abc1e518126d3c2adaca0bb9c113d8fae7db629cae3af0c147fce91b210ac4ba18c561e0029aa8314519de23eb60ae1b4eabc8d4c3639fdfbfcab45b3c1cadb4a31a90d7dc530fc44822c56d01534f5d60841b65395b05281951caaf47660f4571daeddfa7bc59b16a71a25066153b1b4b299f7f16f806dabb1ae6775d65bb7a4221bc3087841104ebcdd58d3fcc5a256bd5ae42e7c687803341281f9fb9eef54d8d3077562e795b032a75a286ff73ed720ffa799c690bcf9280edaff3903b5722b1ec0dac047e0f89a17471c8ceabfa62abf1af615807d473fe51d41d783bc95403abd8267368c9b359325e88f6a8f0abb3e1afae941853f275ad4fb2c447bc2716dc1e13310d8b00716b19e94433c02a38f6217c68edb16e7180380d94ea53f821e0cf359a565a8ead4db658e3a93227da349d29ae00ea08aef178583d41a24dbf1b0a07351aca0ee6808416c1ecbf579eba403da9faf7eb67db7dc66f887fcd5647b02abfafa09a641a39abd5de4b7df83159bf3bd25a202d28906a0634f8a95d7cf1c3bd4d50d8a1e1eba421cc8ee677a7cbb557a23bb0d69aa773b3df25984119f0fce7c841fdd041a89e36d432967d937490904b4b73ca4463d6bbdbce118d9366a6700b9495dc8a879aa807def11b21140dcdf7bccd20a22db5b6271172e3746fa087837f0389ca2b0c574391b1496e025ff7b32fc88c6124e36c4439100d91edec608518c3d5358b23e01accb7edcf889dc35a03992ee2fb5114cf102885310bf1bacfc404801fb6cfda660c6133ac60800e1a8aecb3894d07c4fe263dee9bca8a0d6c4d0d425d04267bbf66d3924bf602f506a8768125e14cfec6e9e0f0f07237d3bf7987884318d490a1314a51dd26b84a783765ee33af9d890d27ab8ac8a381f0603effda98095344a5b2c47dd7b3d03844544d536f492851eb36ae4da8ea35160473b68770d3e653bbfa5e4584d2bd2c5d804156c1c152e7e4bed620d4cf713efee53690d66862351de2c78f15908eafa75b81465ca0918eb8048073d8afa0591454384e7dc8c84f7dd4b2c145cd4528992c188950321d0a3a582c0c088f6895ecbf3d134f7535725f5f0a1ec46e6a920525a68f82167eccdaf4a2469b70b4b72291d272995e251e1b2ea454da739eb2c3ba066ba85963","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
