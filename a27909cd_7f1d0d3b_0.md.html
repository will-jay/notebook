<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"888736346e5f23e66b98e388a089a5d243bf42a90a0ac2714ee7f7c33b844dd1ab767f5aff84c88add9bacad4df47e024240dc0df395b26a9b099a49c42b61143d724798cee5bdbf2d01cc4570230a3d19b538f76a58799f1424ea1007f6d2c733ffc5c3a53d475cf18743ec852ecba9e36a69f409217f19534d88de0aca815e3dca1418f28ab1a4a275ee9b7d1c3d31566185cdef1c4498e55611ecde3e80c07d9e4c51fd6800986fbae789c9c091b9ea8c2b18c0e607f955769b6d4503e4880d3fdd88963f780673c1256cca1237a2d8f0d451efd484198b87da0b208d193a32f481f86d7d2d0ac0928f38b63e2c283662c6887ccc5d3c350c1dd7411b55507143c3bb41ea9e8cff1f92fc0e96c337820b6df19291ec9720afe24f83518c2a6e41ba1b1d5da2460438a518524e56835687d37c550c6eab89789e3699f5017c1b8653cd86272ad762b2cb7250562ebc05438bb43d92d466206f442687bdc299ac6187e8b6b13ad1a9e1c4d4af12ac39d4420f62d8a2fe6cdf3198130f8c8138e5e738f96034d7e7097f6c8791ea6df56e2a047658d433b442164d3a5bd560ee68f24155192d30f7a6c46bcc4520bfdba689fd4238fb7aa01cc16d508dcfb78f09abff0c10dd09e376ef015061c3573b40b5a6a3b37a83b65eea4f8e533c3bab177e78bf149335a6eaaa6b5a0b01e11f152cc9b361ba9ab71a8f80a06124978a0ebbd63e7b8d6f29e550da1ccca88d7bbbe1682f44029bec3cf457c24d21652f3c9e596bafaeccce5c6f22871c2bf6bf726008f717da9afd2c4c6247d5e73b1c17c130abc7740ee35fbb1b7e5f3c2996229c0e9fda63bc360225122141381f6954df75412d114f4c851f5f53bc264f16c008460f1cf35f134afcea71a2fe1fde9eb256ce3a707a4ec0d92d1cfde674cb8d8774d34d2692d9daeec121fcc26f9326d35fb63928b8225268a312f4fb834908c9eaa573cb37006898b5008bd11566b1e35d25f0381bd4b72d4638dfe9a7ab67aee0762b80d25f6121ddef1d9ac173b14151c9d3faee79a51d1938071ee8429c3b303973127e410d3d017813a6d77a228b9fe00f0950e6547655650089c72f16f60b25594add1699f8bd87bbad44719221ce121fb3bac7693a2a6d439500b7bfefc724ea448dc3d61624dbaf75334d196d54de12bce0e33d1c44cdaad6c6714101f06f1f2ba2e6ff767aa3b630c3ad165b09de66d720c7e83385c853e9ac1bb8370feb00d9f61b2c4b17862017ef8243c560fde87ed0eac48e5f0f1cd2537a31ee2ec5904d06cbc631dfa0d7047035e820732aef1ed58c68df30274c64f5f1c14cc9408108cc493b665074b230eb9eafafe1ece92e48b642cb8e919e1c5c5e72bf11393d8f4280965c5a643704c789adf493e944bfbfeed72030f3a1f258dfff5b22ea7d5ff8176f7b2fc079cccd2358079d4dde2825cf4c89c5ca3625173a102c628a2e6ea914c3c6ed1dbdd0a4fbaca96b0ab89b13f77eccc9734708cc241c7d0972ac749a69b7c00e6c307893d7f7aae91d168ece0dc00a2ca1b4798df99251a328d47d84cb37bd949e5565d23d54febce6dbdfb48ffe5477c921d83385e362fd23b7d186e0b69ef8cf7f48c3c076393d6b5111fd8bd777d1924d7f12f42fc1e67b8421f44c1d10588ff4e0e1b44edfd84d35992b570f93c1ba29ec3462b2edcd6953cbf7f71bafb9a703621b6bd182b1787a5c03ccf662f285ebc8680f807e2d046453f1b464a25d8c5052acd534e57fc2eadad4fdc2824f612507abe0fcbb4f64ec4f6f58e46f888aadbf2b372d891f40e5b9093eae9130f65e090a5063de03ba0445a6a44e38076942cd3658fe802c1061b9099bff1e31358ff975bbb822b862da3bdbe77bb4ac275c977a3be151ab38c3d27b809b7299b35e8e7a77d9e3967acb2f3fcf68e1d2bb620a047ba75564f9d3e527043d692b1bb95c72695a4df6adab866f8b209323d86b6862550e9508ab9eb7d807138b1f6e4073ffa38e842a40a2888f2297be612eb0abd8442662498de00662eb29f8f66de9cac50c6d258fb932bf8162f8648a59b59d7b3e8a9acc8d3ec6e80b86f576977a4792456460ecd1333d86ee2e3ddabd333270fe2ef4020f2983d1ad4301f2c900e36cd10850de3dbd6b6f887b19543cfb3776f9e94e94beb5da67b9dee296b4cbcce9226050b1287e4893dc4446a189cfba5e20c78472c54c3ef146ecacfc2bacea4daade7e14b656702ca71b8ea3be09ed8a064cce332ab45e97a41f921bc14c5f6cfe479f82d9e01a9b05601d9417f44629172207c56ca23d88ab4769504d66c1b8ef70548a90c87af331cf8fff5bd383c1db54c53390922f654c2587745ed838559140396329a5edf854f5e8d183bb4ec7f70ae6f3f87e8d88d75030af99b77d0432a862d3d0e36720b63c1f22e19f23375ab77069ae8b59583d70190872279120af172fbe4b86d1f58ddc2f0e153d1674f96c97272245b70184d0410e2a0b275dc2e59ad1fc3cb72f630d10b475c8c337b6812ae17d54a12f37a0b74f9ddd77267118cdb927acc42a8a967641403c600d315203246f34d498110fb7e20a2ca9cfc6f9fc6ed6b1e26973fe9a76a79b0a5fb343595409247ad410efd62a2c3354025d3d0064d4ad4c0ba276bbffd31ebfd49e9ab90e936fafa289387c5ce01bae1102c2acce41cc57953faed23a32819c9cb076d0798589105fd02d907c5d5913fe84f92b1f779c989c8488c4f44ad278f7f8f0541a4842161b39432bae51f6e3ea13bca105f8f25ff367eff25b3704a461bf65837a2740f8a303f881a78c9ac5e5c1d65e47921aa091b64f8eb340ef74ce182675f7e3c00b4eacf523dd49f8347e99a443a41b23139183ef8dc021e3b26fd170eaf1756f88c30cd24514cf566fb87a3eb974b97fbc71b6b27192973838ff1eed23d2e94e0c2494482081a95e478a174e8499294cc2f904635a9163ac5330d912d96b499c98221dd472c115e6312fff3a2c97c902260195d166f8b0c73b72084892bcf3787854b3ffbd8f91685e48e56f9fa597ae07452f0972cda553e11403f42c92203b4df14b264b218e7c8468d565977cf346521687f22ea4685c9bb8f5a19f5fa8443d4bbe2918b6c3253b4df1bc8d1fb3e32c7c7248116ea74446756b5b08aa0c059b9b1ddc27560f84290a803318037321666ff9a57f92e515a9e7bbb1ed60582c6ba9cfb6c6bcc9b4efdee6b2ff2733addde5b45b6e8a41e574ef20cc4fa4560b4c1785a27c10f5c34a1c35b1d5fc275b6151b445740942858b6ad5d7e31af3c160021a80ab2cd71b93e3cb3fa95519030b8e9ca47375d4b0d79b4da0158f9f3c8901d9932058563ecd84effc53b541c9ad79b234ca6a075494891af2b5db618b60ee754b1a6b3ca5077b5ae2d23f1a14c282c50b57783397dc6af6a0ebf1f46e4de1db2d5835b6b8421059cbeb14068b5165c71dbb32b87720ec6ab18a52b09ae225b8a6b041014bd57d116efa5eb623302dc6b7648a541c5732e203db585a8427d2a8aed743e0bbe4961fedeb7f511460775af06d1fc3142b032c9c554db9a77b0ac515ed898167243d19b7bf45c2e8f2863ef4c6cb83b2a5878298acda8321338215159c5c80221da063c4107de567b17f3cb3e860c5c0a159a376de0a1b2f3c9ec56598e849e5cd4f85324dd488d16b1a9771e09150c8457b50f792388519fd7ebfb1ccc61af556f4fd977c1f65afdc781d4b23727e7eba72ee960cf6db6414f97e21d9d04e9c04f059d7268a8fff8813daadfa02a0edeb6041c400c9419ab5a72da546949881ee58625abfd662158f5bdb3e9e16406b82faa126ff23987d2e8d40f6bac87da78f7d32c368ec67697c35226c9f67776ecbb2dee8492e3cc010566e527652ca6e2b3f4a8b519a00b08d8361a9f3cc99ab8c11ccd3b3c4bc55c382450bab11628edcf1a2fddaf514607002cb3790f21a83c04389157382bf3e1d9daaaf21b8ef5fbc3be31f0749a8de5f1e3bef768af61d737085351846f72d7f3318549b8abad9f2508981983ded6b9a34bb75aafdafcd17e73831513259f3705a1ae35850ee462b4b7bbd6d6d3e2f4adf63bb00ba7e820ae9f44f4bca5a46423736616cd7be937d7f1594894a3b857c9153696ba529d28ef729eced2aadcbb18145ade756d852a6204026fce1f266a5d58ca09fe85a80cfeaa0a9e2bca5b30b71fbdb2506ab0a8b873782e3303985831562fb5061c6ebce49a407d49767981107267294d1152fc46194926dbe0084f7fe3c327f2a3b5b902ac53d66cdce89d74bda22244f89d768e83aca8351d4b372b75b5694784dd69de924591c454cf6d83bebba202411ff4a5f7f1fe8f8849b2b370462e30ded05dc69981ace76979d1439a1eb433433d33353b31dc6d69c9a437d7cf95a3cbb3494d919c0595a0ccdea051aac494aa22e927d3fe6b12c3345119fc03ce0ab2b35401b2cee075dfadcbd2f6a09b808f961b399b5af92db2772656bee6d7310965559a4e15adfd7137fcd4c2afc3b885b85585506f9289e62b6fa964f1192bb2ba11c75e67c87dd25f03c015674e7c3bd43bb6ed2d30e52dd4163428be7c867219d9d724f3ef550023a7d5b817fa442f53144739b1c695ebd1698da66686e2ce12b60d88854f6d85206927f29891ea5aa5ef2f2d0c6c9b4eaa173d221a724880854c82e67e9304cf1bc7a8ae4ebdc834dfd6d20eea454272c44c1b74f27949c3027e8cd81a6255d68c377c34dd41fa35eca06a5985b8ec8fee4f9a635fab3ae3ca41a4ad905278b0226793654ae31fb5fcd0b99af24d7a408276db4c7a07b5f716c685826e90eb239b622c84e0cefb59b86bae0fc7a986aac9defb1b90a5758f8c37a24c1eaca2f7b13e97f23e63c83530d4eac644b74f67b84db1c763ac171b7428c2dd9ff733b91853b1830588ce03a7d3d8021631c937f05ecc0a288dfe4131bf4bf1a48fcdfe7a28a23eb8e949e29aa8cb6306c38dfb93fa100cb82d19c08c161b89dd4149a11f9009d5affcb15f5e9b694a1cf55a233d0e2eb68075589b39496dfad8c923db0e125c2bc9583748422dbd4477c5efa94048a99b1a6800c0ea6465495068c5012589599792d2b2d8049e514d4f3d573dd5c3fdfd0cb6851f01290b605edd89e893527df0f57b42c722f4edaa5dbe3c29b63a2956e719328e1ab75a29d5bf3ea77a6d58de07d8406f04f1835886ff3f5f88c89b616510e1f47d60b94a9900ab1838220e09063eaa1275befc080977da3f2aed948f0954403bb32e1b75855c885074c18cdccdc00db84c8c4976a51c3afe9b0d9e901fb868bcf41d46674ff984d0287214c2b5fae6d5da8a89701abbbe098cea0cd40f47b16932327661ea19722e8d3491642f73526cb42c30e96b152f7e4c88225f3baf9d000d65c4542e2c94713da683d61b3be9aedf4b10870fc90327a06d25d74fd98b58b49fa495abbd1edf603ffd02aee51617af04c4f9f9f0319abfcda3986b04d4d123461d8600edd49726a285f9afa5660732cc9ec6bbaa09124fd7112ce5c8dd7305418cf9631d6818b100e99aa4d60d0196c67604308fc2407092847f1c5ac5ebdfe7678d1ce99ff448d8b244d826e11ff1d6b68f5f0b45f5d2da1a34cdb5a751c4a19c0f8ffc75a13e4a1f5d1f0c25cc030f6be0a18e1d571227d1ca65a46fe00e0b64a667e35dd72aa009d5092d3bde972e6ade4bdc646b020e8798e66f3687b02a1571712f202a923bf1022126769b762637786ea8af77d11591740c6c971d901d900814d7e2e5c78ee20d30aecfa9b97d50d6a068b5b27017d45cc478f5561b180e2c3df829119bbe550f555ed0acf047b95b8f7928661c432106922e7e1edebe9a1578d79c87938194ec9dd533a45ab584c322f6cfca15558cd64115a0054d360dbb21015feb30177703c704937e5b430f88d5ae826a94d4af241c773d598b6fc535ab58ea209ab7323067920060ac64c83d365b1d9a128dcabe2b398db26abe9e2e21e7a779700c5cce7921df255273e557ecfc0bcf6a3325009f07273e6fc7e4b58ce1cee8a98ef62f0b105fc8614d1352bfde32ce7517a650937a98b76e1ff26c239a82b669db6002d436fdb6a24e7626986e223d85449abd2d67b115791de7212faa4042edb3ff92e29b8260d5375409b28f4bba61dc93bad9fc5eca494425ae0bd0698882c48f1187cdc7312aabbdd284f1adeb9a3c97781de6f9a5155d0cdf51a5fb766c0d6723e59090d566df9b87c711005dfaf87ce083509cbd37fcc83356e89f8a70d406f2c33dbb661b0da66a600b699452fb8ec8932fe4262c3051e4e7e7017d35cb879df77781faf558233e6f72ae41a31c8c208dcd6d8d233fa50bac3422e80788cd382bbea6a443e47e9eea95ad2221ef7c467cf20570b31259685952f2d285fb9d760d3700e13ff3fb02ec5ae0dd8a9552d0730298768216bd111269d2689f4f0c5946bea3783d2ca0bcc6873b72634c8b1ab9c55a61cb6a84dafa93fc93f259e02d6f4110de9458fabdf9a8b6cb8870abaea284ea554cd48d45889d13877fbd7340a4db8ded381c8ffe94980413ff67f05d086fd878c2f9dca25f0328599038becbf25e917637f0d513876ee9755764cb3fddc6daffd2a17103696d636400f1fc7484bc71684d155f4de7413dee8870fcf7974ba78f5c177cf88664efe3d201b4318304e679d7b8d451c3a74367d079bded8357dcd9861274552e0e16305a8358ef28c330e87d74fd3c93025a45e570f596cc2f866c78e8e7ab5298440eff913fca2980e7bf159931fd64cce64db0dcf1e1c8f7b61770122b4d3872676e6531f9e4b071e8b56c66c08e54654ec6e3dfa635e7a5dd405057c0cdd368230f7a3c4db69803853ca4de2a96379ea7f5312d9b0b9025494569e57770595be61ffee1fc058acd3e9d69c7c2a881a6449122880f8f92b4469d7b3c6a601f2d4946c572e3aa24c94b7bf2a3775503c41562f75276bd1449f0ab55eab9ddf399a72c0fe8a997f3e1aa604fe8943ad791cc3958eb8ed2b58896075d0f9381ae36ddadeafd6067cabb580bf303b9671dac16e9ef7790eb7adbbba1f54531da95e338f9b5cbd98ddea3d4ea3673c464e935486efef7e1371c54858b506ec83f06a1ab3868396b28a5ff2e8890ca796561e9abb0d543c73b6f0caa3a226e85abb7c050fe2037b7d32ea868970dfa395906b5046bc883dfba197f3981b8aaf2129b8ce16ea40185a955ec635b712ca227cc7d790ed4965a6e459b45ae7581f06ac9a9ce283dc2b9ed728a82ae839ddb24ee2a7a97f17f0f7c23bfd8cef45523741dd71194071fd103e1ed5f5a01633d89ffbd168c44ad9da485bf6795a50fa6143b869d9a4df1eb24ad4189d93bc36438a75ebe5a0df74a810093312d17121b6a1455ab0b4646a92aebe25019ec212084e01577486ea859b6686e0205d779163cdfe90b602d624e6e8cf8c395a9e842db6ad6fbf29d6391ffdcd9caa5942ad9f3f7fe330b7a2d0d37b60b14167112ec56021f562ff5b90a36364ce55ca0cebde234904d5844ee7e48fab795d0d8bc8348d324aea82207600c6bcac4dd2d7cc916d412cfe8ff52100220ea70ca58177a01a49336bb3f1c9f800b84b2fc517e8228e025168c39a9b2cd56254a20edce51b8ce061c62f7d78f68e07ddb0bb40f35771924fd49e849094e65586ea228a24e64d04add55e85f6acde338e1b39264904bc9074cc39497a6a7a4f02d7b5d6a0ca4bda08f4976d4ba3c895f289b52f04a112b8570b53deb6ea5a083116a6dbe05fca8ad4f7cd8960633ef5be1e6013577adace05b28757c6ec0bff5ec1a0b4864cb1976931a4d327049dabc0c451abf48865d5a5b04c61a9011a864ff8efd8ce4448d9732b75e1e13367b246f45577cdc6fb400bc4d6e253972cf1ac531dab406e08fe9ca5033c65c79b6a74fee1a99efac3400f771e4d8f9c8fe267125afbc6ffd3f9e36b9bf1d4742394b5a3f8d8a02d054c8da4a986eef383c3dc9045b4a2cc9e1c223ee6e3023362f7dd8740cf3e0339ba0873acc7c5dbdd14b4ea1fada2999a31aefaa0d805a675bcde01e86580b8d868601bd9b84bd492fe2861d4c7a7c0f08084b792d31f53192b3b0a2413811ceae547628fae6262e8dec84ce86ee8dabe28410716ed09841227ce88abaef6c8bd68d0bbc0b7ce8dbecce4b49db26c08091770fb1def9d4c4d9f9f2261bd6414bc7df4e5a38d41bed5217b4e66f5b79096e8397e3cfc694acac684dd2a9e6cc4e03506f9e9fef94343d451f7804b2e76ba2f46d935bab0efab146d76a2242a2ce54caa67c3d61e5896724dc4d9108471962f1bc6093e730c886373abe308ae7b6062bf4fe82f09dc9fa9a578036a705e5bde3311a40cf5bcbaaf68323a2d60724593ddf73b36f301184ce23b0d1ddaac951a0873e48e9a6c72685c15aaa1c9eeef69497845b1f58d2ae1ed16801679f3de632236d4aa7ba352b1cad47685fce3542469a3d8a4fd156b4c2a97c46373d39c40d2ba80bef7666cd3a1b0ad79298d9defb5353e1646d7da12e6bc71588e560d3b7ea885effbca686cad62727068895bd9a1d84a4ca7377893f97ffa499302501c156a1accb101affabc3a2968f0fa4b2e325af40d391a09832edf767ca18c39b013b50a310000534756a65b2f058900acdb74a5b7d943e31e3f0a4c77a7362034116aa6c643ac1b9fcbbbf4790245ea2af291dfd746cb284e2cf119fffe35a75cb1fcb90db04292edd505970bf8e08b08627928f3ac4bb00c67578153cb86e073c652ec2417f700294fce328b84783958a94e942180f3ead383392838234f4e7faa93a8e94030b0dc93d128d6c5bf19b75dec73adc9c3f1b02f16d9a7594d1227620fac0a10d022436a5b417b148ce365d3057fe3e9d2dd0b451faa40ea636a5e5f435f6af72151aaaa0b7f9d0a7767f544b524fc02e5d14c6f9ff1bd66370efda67d1709dbbf325c47f2ba600bb72de28bfd528470e62e48fcaa52948e2b393b439819dc3b962f83bc45ed0f57a9f3355249c92c41974da7c77f5c0d43628566e98b9c705977d5473711d9ace564cf9141611e3482298636c606f67db4775eb12502cacccde8eb59ec273a8de08ba638e8f75bc108627ed2fb66b5581136039b9f2893e2eb2e7464e628bd860472e16b4fe6eb234ac81114d44e038003480f815fe9018da7ae5156f9a56934f7e36436597a78e99f1530429adf3b897c419973a7b6603518567b49afb071a41edc8c6899608fed808d1d245715c12e9d5f96d8451e71d3bd785f18d518f7dd43695f562aa645a050d3876cbd92948b1856e8fbc42be4995e04829e3a780ab3f86b78100ed7a0d3ba14b05cb60d11963767d6b6f01beaebcba8650cd02dccfaff6dd3369f0864a2fdbbb3d6205c125b661498d374de002f6d34beaeb5dafa4a47943452ea1d7d5e063a5c128a7cf381951e6db6d53fee1da9d4a3ae9dbe2fa480b9c8e00152d5168f636c899f9c8a0db8eb48ff853c2150835834c3f60200899af4aae4e56173dc0dea2051badfe4845b57976a50f11e5b4c56151ab770d59351ce1e4de0d929d5274e55614528222f2bad7b16dac7de84c4ce410d355178f439ecc59a98dccdfbeae22e8dc31e1251a77c621c00728d9040fabdaf8c4a405dcbd251e2eba26fc4a4958215aa8372186487949f48b6b096291b7cdadbc1e74532214263cf8242caaaf7800683130cc84676844cbac897b45e22aaf515e46718e74188797fc537a0d932b72f38987903db2448fff04357ec3fc940fb0b6b49fa95faf330c69e646a1fe71c584ea309e6555f6303df69f2d8be4841aa9ce94045c41d3c26b76b472738761adddbb7c67618f40fdfdb917157b426d882e704c498f1713d1ef73499f738384d5ccb3ad9d5a9de1e223050112422637ef38833aa1b54edf696fa435f51ebf526e82f9f548c417e4f5046dd6c583eae379138efee0729fe2bb74c4c58bfed2b04ebd41883b03f3fee93450124acdb7a7a8ce00468d78c4c80b0ac78765fb92bcc2d7ac0584dc17fe911b25b6449cef8f9b795587250b6f0354f6d6418230c7e246c1a716e5d0be126eb9deea9596c537e63cec1a5e2874810a86aa6c9fae6d5e2426abd76c0ad862e9287a7fd19f3fe93fdb169b8b2c91851c64451567e2ca582049888be26d158d10c14c804e875359d49057603b40f0eb17a9fcd0d6e579ad31f8d894af57bb63995add36cd4d55a3d745499b04be62038c85dccf8a75b2030d8d148da19acdbd7d17574766a1a31099ff2169ad3be184e83b52829f72b4c70cec9b33cad8b9d00e6e1ea0053205563f9382c18db28909c07ce24a6ad646ee7817146f1ef459a531686cf29be7a96bc21e040e92a570b6f0e3f5b6db47d5cff8110b0d7e407ac120b85e0a9d37661da0fae3dd3ef48e5f753bb850e6a204d9974ed61348623afde4e7d4a34dab3571c43c2f66551c9da7fcc52289bdd9085077a6990afa2280d654a22688ef5d79e78afad04e5dfd412f46fb0ff3994fec76df3b57492613f17cd72f09ea301bbfe13a5a0ec557ac3190533ee053b02f5264eda141a916d98b3e9635b0dcf07e3192429706dbc3f2549a51a7171df8ad4ee70aea5f9ed77b1c3e34be0582daf14e27e8e42fea1d7edb3f11987738dcb02431e99c42c442b76a42026656525c900ec2b520c5c278398f1ed345342c4d1399459aa6fa7150ee79c0d8c629dc7d95f23602aa3ad3e8ea3ed0e814c5678ac8c9d3a613101417f86c6bd121f7318d83a2b4c2b6fd6eeae23917ce17b6488228e1a083df88c42876470705be6d33506d386b94966d71826421193024b4bb4ebcb44dff3566dda5f0ee5b4bd399d9be0c803d132f64d07fad998b7ec4487184f1221306edd4ef5c1a1c27fd14364a36d4ab0eff860e0902517ddcb2d875f2ed0114363c6f4a3cac030edaa7bdddc8571a7cf2373e6462431f36b0443b462a119f4e656bf1a3e1590006400b5c384a6d76c38f6ba489871d37e6f226c94367eef0de72dccfd4684679239c6550f446fd6e0bc0d72c3929d545c2f1419d5b716b02b118bb602d1e97bf7ff20ffce918ca66424eafddeeef41cef9bdcbd1f85505f9fdb3b855d1e03c73e49739814d0cd3130eeee3e9401c543f69b31f386a7ef01c7593d2ee2fcb3a0cbbc7b61ca9488e04d783332f75ee362639f66a4b39c053393d22b399a0963c507d5d36ce72dae3fc7518ce79814cc7d860ab9f12b553222ad79212b1b2f958eea8574c3a043b82aca84e9e6fd69ef5e202c7d89af2432a61d25188dab920c71329ce3d67877b42c2d59898ccf709875fed9521c0ce35ad995d5462c76409fd0f34b9244cee5e6bb5ab19599c89be6babfc14fe71422d3ecf9465ba90590736f07fa3ceec5817b1ca15b2b614b94b3a0991843ac9d01374d8532bcaabb920e55042a5c227a4afd98250c60f20192a52b12744c14a8720304db2b2f1ec043dd7851d9def12ae0f6534dba8b01b02b962c2f30ac00e5bc3fad4687114ae2ea0c40596e37851acd3667ed047fb1090dcdd92c4995753610971d0675be8c70dafd795450d76b35ffd307202fe39414bd71eb6e26ebbdf7a9bccf1bdcdf5f55ad8472d1f56f107fe91fa1157845f763442834da30b6e4f3d7b7dce2cc13846dd0e11fbbadcbdfc83686cc2f757ba28258011b9dd0fba24a7cd50d5b1ccf77e22ff5aea38ad5dc1855d518f4ced20f58462d8f35998a9ab351b15d4e61d19c8faaff3f738458ca0641667e4ae8753a46af3b4ebbee2953d335849b63dd5c7c0455e39ae87014","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
