<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"658a6109256d5ed75527838159a216acaca9eb8bb35295c32b570bb3b762cd1294f521a700cd78d9163994afafd6d2e2c5d4ec75c29009c30ed6475a93c241c43c83b9068de53d963df80b77211f795b77fe3677776bbabdabda024d37059c6e8be53ec3ddd294738813a0705bc8e347b464ed77299779d5b22be64c1901c689d8a62a9a4503addb8d815996920ad0e4dc77d64d26d854f78dfeea5e63a316da62c6e66d8115a22262df0b9682b13ea0752cad063eab5a03f459546d9aa3e9e26af9712901e85191e8c809d86d79b30da6b0fdd1e8eb51d9e892288073bf48510f37e6e99d09daff72c6a8eb40c36841948a5b277d96720c3a0b8f5fa3966a210fa944a840641b6685a2d07f1cab05672d8aee5daaa78820807eed15a9dbae246a090d638060af437ea1f8df79f0e43a0a89823847c5577db850f66514771bbeae1332d86ba6bd54e4ff02bc9b0469e0b705d94d1cba7d1fea7406b1d9b8483e8ec2a91c1b5003b37792347278a9d5955be7fc708ca579b473b90bb0a798f89cbb87b830176ef5b86af09d6aa1177a3d921be8a195a52a184c7c0a325bbcd5df20a97d92415f1fa0c0db15952a5674729600c539aa8b34ef2db7508adc8d41c07ac9d71bafc39a070d465cc7155f9b4af830f02eb51c4b22e74f7f8b5a5f5631d56175f9593854938cc402b846955ad1747832a3d73d16c10a16468f978c61c6c10f614447798093a41961446caa39e612d80501186c587aed2333ea66827141ba7b87b982186ccdfea1a459c656f29aac31c98337181031cd4b5add36c7901e088dbe244d3adbba626cffe10bcb808654a7120ca1b4bd554d76859f4bef04f8e727121549884d5c34074590425fef2e169e589b3ed2a36652e174a1f33d1dc72b8c118fd8a03eed731f123ff68ab61dcc5ade4c7408c24aa7dfb8493ec17190194bbf16a4fb32e7beba47990ac7f521e024bfa6c09d3086a3c20855945b40f5487eb609d49241b919f11baacd57ba66586285528ee04b2aa2c1da0a800312476f7306e955f1348e9dc4c346d1125b7f1a7ad2dba0e466df71a04a8ab6a6967716380e002b56309b785b4c88cc09b8fb0ed3a28248805cf78cbb147e90b4656e15788e9b6eedc88754b551b9caa0e4781a3496b7c53421077b58f7ac22a8426127e251a07b94d1ed0460ee36b6fe0d8ee5ac54b74498cadf770c836748993eb9c63ece748dc135e729fb3d1f7e8d9f389a47cdd56f0ce482a4bf8a2c4bbcd3421e49f0493e998667d42702d946a616c2e228ecf25bfefc26489c1b4d4fbbc4ba125155a869a426478efd49869cd78e05d3c5fc081c8f0dcddc28e2cfad4ef3982cfdffa64ec5933e09af3260d7c0942a5178320fd9f67532399b64a8f2bcf9536f3353c91c60c4b8e4f85235f2b05628ca6315712731653ce11e7eff08a1fa5a6aa54fcce73135133e8acd0fd2247dd6a1bf931f70b261189ec29aa14b348c82116e6e4964c119a7c5e72bc1c2f1609a2cc8b6d18160ac78798e9c02e068abec82066b21651aa9af06d72525a369d00b946ee1ef218a4a9507de92a06b674dbf1607e8e9f09873058f01fb1172f83b26afa4fbacd97236c7c87ac384da52048ad7b2c07ea90789978d039cbfeb48ee2bea0dbd11d9bffe9a2634b0b9859da555692da98b7839a3463563f3bbd1f294cbc16bfca293bb6e22e608f639b791d14126aa3492166df413cb9673329a39b7c35de6afa9f9f20386f5538fdfefe36dfbca911f12cc4bfc20034269ba836242ec6c2fd41eb9db5d1670c13f15e6dab58b68fdb92f9c4a3adc3a9d56008ab6b9bbf67d8a7232e63507b115c8a47cbb297dff84d8c4831768ee45e32737307efc0bc12ca149d8392724fc5dc44444a952502f60d01759d788c705c54809a49a8fdba018695f647de7c8b1a92d6dc4035d28e409c55fa514cfeebb544e1bae7334ea23c45b80a9ad776a13bc5d95a2e0cb2a0b4031424f2a9944c100ade4d299aa10dc192999ca269fbd99fbf857d9df856b695aef13c1008d075e5b3b99c7b20912e566c821d5fa4afd361ac73831d775991e45e46a4d08fe958fb671c9bc75ce8918a54d4baeda48663feee02677d3846cbb57810d809d9b605aab11179d5f1877be69c0c8c529eaf06049207b72dd1339e9641b15fc99c00c6a793da13a7c602cda01fb6e46d1a5e289ad09c013462d9f14e8ea0830e341741b9b1d7baef48039b86e9369166797605460e4c35ae323e54a1966eaccd993925037a7b56804b26ec9668ff3cad66661d86547b9d078bfe83c3860faa7e1fc5eb70d2a2507c7c9e64e5d2d57dfa21e502d4b8089028e24fd827978009ed66e0bbdbdbc840a749c1c001ee9f852bb72ffcc1ab1c49c47f72c6e2e095b2def0b60ae98b5e20820381ec1d6f269b7b453c733a0afd3f70d2a6094c7ce96734fca469af7232f6fef1c08b1e7eb3b65a568041b769b551d8d0556c3affaa73ea9ffdf200c8cc768efe3c5d078d17c6e8c9810ee023fa0f3f55ef32034815b21ee553bf465c47fda8272cf6ba1e97b300149a9c085e2fb0f7f0485c8bfd7a7d15284eeb56adea64d011761710ae6a82d24fd7638bb0ed1f962d448e725bcfe58908001933e462ed8c8bc2a277150d5613ebbcdabdf00128bc49f21162bfb690d68adbbd99ee35c83de0986ebecc1686cdbe22a343e7b12a27baf485dcc42f2ff1c1e614cabf43014c3b4a282d78c1a5cafcf38792853cc0b82dae38fc7263eadc99f5ac78cf7879b72f58b9d1115421ffd47e4f727a4199c2abfd98cc5e461a438fac138471efdccacbad8f75fbf9b472c08bf89b7ca6b1330f28548224a58a93006a4b47b85e52de2f1c19eed06ad0d6a54ac33bfb89cf7b856d627f3dd897426d4feefdaed27d833bb9b833f9f53a4535e97786b06e814906a9a87c83f6d7463132f0391a4874a131e3a5c4926455a1902fec9322af78a0396f40724e220e31c76de34f47ab9058c7c30b2e44a6065afe6343fe93a18bf9f0ad2c716b3c72497b5661683014465948d2972292e9372f72b9c4dd5237d50b431237d176ee2e5ded099cecc0f9b7b2f4c5b885da61193e742c936a107498bb757d4fe360b884fa8294d9c402f3194cdd627a1b914dbb89b73614b85ba64f8c1559b578a2f3eea81c605875a90473822da3ce1b7904c524f6936e8e34a2b1affb87619a1854b6cefe2182b1dc13e4208e42254b947cdd854ce4b1f10a176e7039c378088a50ddb49307bb3070bb68ab995f5222082a8f547542e1b7127262991e019816a55d5081858fe722801f6882074cfe4d8c1b11ebd980fb0343986cf456fa92c86124f114f735d91b2ad4b8857ab3cdae62d7b252f9eb95989b598257e42efd0af3daa95fbc935c71976a97c26fcc466af9ca75c537e25ab47ec7ac2841986389e3ec8f2ad4c5aaf626122056fbf807e0189323c836e0f18ccbc2bd9626e409e9637f72265b0fc9a2b0837736e3ad7eb3eb8db48385b38377568c1a5bcbe04c75fc88ac7bbf92ffa12416a27e10447b0ae47f9a4a0178bb39f278eca7e7f5a0fe0cb548672697c39a52ea2ffa8790225455fbdba90812e6fa2f22446c9186c8616af95b5a5e29c645c3c7efe0be74fa341997846bbcf633e81db312f22d974b67383157ecc4edcc2ce03fa5ff2a61ee9507d5ade135a926e260103c88edf09428d74fe015b04b0bcdd0e874ed6d3b8efc87e52ce338729d21ebf49d922c30317e34dca0790420119cc8f25b0ae5cff9ac3fc808c919217cf72370dc96a973c7891e523bcb3218c72774a3d7bf07634fb03f22841ab77edc1a10a217f2b860d0ef719c0d003aae62638cd9d8ffbd06a558cff475fc773f75731c98224e410f8212edee1bffd93eb982ad21f37cfbcedcee11dcca71a01c4fd671801328a2fc4ca01ef3f95316eb0fa1d59f8e93ca10abaf1dd3287d3dc098ef7256ba3b99004f8ad25176193fa341bfab8fca523231bf5062c99c921565cf00468af013c82a12291623ffca11fd49d37025c471281207386675d21b3d4ebecd99ca83d5d21c316aba628a1c7e55630fea52856fe3794b8bf7e0660291cf0f4a87ab400f8c802e261f0d7441a9b91db3278d1d877ee486bc78efc0f392342efeef685a1e95f9110ec532b48098b9fe2a81f8b9d081afa7a20a06edd9c37b08e1dd4c89b0e92d9e5621b3903532340da6586e6da90988c09f50abbd756ed593c537f2fc612b4ddae5fcdb683721dd8e497164ecdb74ae189311d40938ae215c99c4efe62c1e70ee8ba7a5aeb3a843eb66eb094a200453ea75d6652bd96bad1501962e58a9832935742424dbbab7f0b3a309bb41ee4b89e00e4ac3148d653498535779ab98134cbb3090c90823879624b98cef998376fc7effb87c5540e2cf19da9df941e59b49c30af2abb2ee46c53797fbd31f1ae72ae5055aaf2b252f53b543843861a5207c029481fd269e921c4303666f8fd4460870a8b11627e6804f66935914468439eb44b7e179a0f4d6f680833feb8b41a233066fbc23b0ab4583d12ab92f02e19cd617ae509a822f23fef252c8f474964cfe328aa5aeae72c2f0d73e0921ee553a3a44a126d4bf2b59f43e6783ed62c38ad785a0d9a3f87a69ef92a0cc59ad5c10d4e3edca543cd27a90b92c00e2e1d1983c8c59fbfc269e3e256c54abd8940a00f54e591eae4b069f4aa0000b29aad3db81a6c1bfec83e888bc360f3efcbd268f1306a80951cbaee453b29563fd72e3a4fea5b5154b146163c95ca414acca1fc4414fe89f6cc6df9c32539c92a480c1b4aa34cb5239559f4d8a52b26583b89e1a550facea051fe7fda2c81cbed050d3ca5c78bf5c78146c7345b3404be7013c61c0dc67912b1bdfe7df562846f52434d26bb82f3893d71cb24daf09246f572a03219e173e918bc9759c880b16ee8cd418fbaa7719a6ee1667f45914f81995a00a4a599cf5a48e8bac6097f2342d1215bd6b11aa1fd0dd299c7d00d3e5bab0c7df4e9f574587882a063637b101dd84ac7088aa8245d0fe9b2b1a2116925eac0a23a00e08e3db137f7b224809b54a00f2dcc48dfa1b0d5de0ea349808abf13f2d64cc766893d2a4d5c988158c32f7c2e4bd69abff8a079a60f8627168ef22cbc61d8cd4ff0120f0d52b8bc71cb728273731db7d2c4273b10397664c57235f65ac7f3d305c7b918b89841cc171c30f972938d4cff89931846f9fb67ce1d70d4c4da4f09190c74d86dc281fc9a349f1b6d29978ea6d11d1debb3a95f1fff427bf9d887969bdec1026c329ae8b697858c9c7140b760d7f4cad8e51d5bf84d9ec77e3adc575228eca523b4b9295f95581c0016f363aee7561a5c703b3e9f421524081c4f218edbb90f2e44ec69f2cff2a84c609cdf345e20bf82f958116c6210e6d6f387b86c9426b9e12622ed2388e908f7526206be70548074edf8ebee0319fca1150c8213fdacef55c601f1b250fdebd85c3fae5a550f32386483627e6f2a3390ba15c3265b5f478ac14f6f495728f6f018dc12998807fd23da920eed44c19fff6d26080cadf5028df6fbf4317e723797e63487fed063024c4a9272f64e210bead27c2c97a7ce4034d5bf8983578fd98128af5c51c67a10e3601dbdbd376feb68f68b9ed29bcf7eb6dae6747fdff04ef5e2131abccd857222c6e4cfd5b70286e68e9b67ddaf2ed50fcd38373a91126e2dcb3ca26b2b9d8d1b395e3c9a36c6b64d2b6675b4bba27997d7152450b0398aac9888dae53b44c1e231812ecd697b7e1413952221b1cc0e45d6eccbafeb6b6adcaeb371f82ea3f81fcadeb8929a57ebc1ffcaaae91543d9b66ec2517c9a66e368aca9b5a5b2bf729f6d369ca62bd1bc4fdf780eb4145b74669530e4909fd88f5b9cf9dcee7176c66a5bb14f793766fe0235098ef0d24fe8458c62f91b6045507fa66c309a2e4395ec9703427611b6750b4f28dde8bc4d6189b0304238277ce0571a06927dd1afd52fa61073a743b1e32e5dac75d3d6001371d98aba6cc7c5c8fa509c555c6911a95c39f6248752e9862784ea86c3e593e8e1c495f42a22be18f9948d2f62ef37386d335fca49c170f0da9375a3a17c8a95e59514ca1ead8d7c18bf97136bf2c945d4cb0b4e85671cfdb7ec2d6655efd29d563baad8635ca4e17d425c0cc444456177193772838c81f153f3372f2b840383f4ac7e3fda242e1a8e851d25a0baee56ff5322237c142420c742b921972326cb79706de8b14ca1e716f1c7beebb04844ff17cbc1c3f84bfc4ec40dca437591d9f1b7e0533b447e87a0951a6f47df03a9d52e548c0bada979a5e1e563729c643f4036f3812c95557407af26403ade8cf4a5993affba827c01a3c8167744f5615f6fa8e6facd1f01077322111c3e9bf9679f9b38139859fb1d373d0ab47ca8adf4a0f9ae58ab11266f8b1ce8b78037a049db832e26226fc705ec7f65febd0be6afd3ab6f43cf1d4363d95bc3554dd93d37d639446a7d7f3041427161604538535507e76477d7753acc41be4bd38e49b5a2fa3f9c306d5d5a06590fa189638cea629fb3e26b5f142f28289ab98d83097c1b1dd0acbdd768b89e7afcc0f6f6508274fc4395a7c95021fbef278e19d6cb39ac7f839d0331a5d4453610e68c1505e5c3a1771d1f25ed7cad1080d6f6bdb21315d2048f9ea56c771395d0f10ed2acc581a6d52413d4e5ebc217f8a1f4835fadb2021129a41b21ff6702095afd1c00e5bec7f16da241f1fb8341e32da87ac97b1e38d9d7692bf2d3c7fe16f8236973213dc19265efe74b9f417ce43bf2209da9f549c722f1039aecd03d95ae8f39c594d50d105b110ba5340d866428434771b3fcf648a8676b8658278d2dfd79cab31f8e0a6182c026f21ca26b82467946b3223114f0452d50411060ac9c91298ee8021af3c6f2236535004ceecc3f0442be1d1de2a9a33b727474586f306ecc716a3463fdbf7961cd1619b20202eb5199d018c715144191d386bfcafd8353c1e210eec4ab8f7956251fed4c58f52fc3ede96127b506d4a6610797d89bd992df6391ce263f32d94df3f3222317d628f67c6f1d7c5c90da8bfe694f5d67baa98800678a732c06f26b3a2b68ff589f9692bc713193e35f245c7eb7898d0263f36f4bb431edf2e00e5d1fa4c9ac83a6eb00f788bb7872fcad9f3318faba4499b51b2aac0fb10d272bccdd71622dd941b37cd55d1f9a47b719fe67954d6b45dfbb4aa0ef4abaf61ce6c9d3828d85de1aab1dca65992df3ef091be4ed2be59dd74e502e860e24dbeb1edd254a306b74043c7aa91d86a0757b494c3477c079a0a9016ba8f3cff9adc98eb9d3d6e3dbcb43f0047c79bfc3c4acd08ad6dd5c324e2659222b3b9552732ef7342e722eaca0bfa94ef8d498234401f79ba1209a6b46dab8c40c5a2b0896b92078ef66dc764f4d2644168bc0d61450387f398344bc287854c0934fbfca5f5d9876a6c5bea2f2a68b4581203d9ebf4d3942053e8ace50c000be5f8cbb0d38b66fad4f7c4f61ab201b4783fe8e8319a2da45b2cfe657e74f66ecd480b40f3af598fa312a8d23522e9ad6ef2c0d77e3097174607e640bd8566f946e68477c45859811f3938a924811c38d75cc761c0d4ac0ff0d83c95e584edac7e67accf3b5599e8bc51c2da52d12f8e4910717caa732f2a4bb766374b7622927780bcf2eaa0a57dc389c41a87758b9517b08264553bfbe7f8b28bc65f3dab4f2064b6498c2f27884065c927a7170658fc4731e0a64ddc4f5a3f025d95d33a061181a269643fc65ca82037150866f9cd9b09cf98110987b3540af38b4f1f4c5b9ec7eb1da330736c3d1d802ed47106a3ab00d6c7720073c888613d21d0414954ae56ecfb0b222c784779ad6c5f4af09bc0cd208a06dcb80556ffa745088a94efee6713602c10474ae72a35a6cbd7a5a79430f9f46d14592853421cac25a88b1e11ec0e7e656df6cdfcb3ea69c32c8b19113b30725783115c5edaad8c80442e3d8c6c74db4de95ae5b2e5bd77f63388406342915088b2695e7517be474328c4f78137a45e4ef9efb2db21b822962acb9900bb95484dcf2a7c9f0cee4cc201c056c5aae393bfab527ea4b1fa82f649b900545567ed4f17d94971d1c9c2959e48dfc84a0e8e4780eb57376cb28b70fe55ae03a0a6d02b0b081f753e87c197fb19129f43f164e271213a606a55a8a33efe1b564342e9f6c5fbbc0c57cc0f4938f8d2d3d86b809212b196d6ae3f1a7fe00d0facda0cf1f28db6419f7dc2268a5b07b094aa9cb3e491486ace43de7a92e85b1d3145cd9eb2f7c876fa7fbb36eb2d47c4a86bf43628de8ddbe24d29a398343501432ca6e65aa9a3041afee3246128c5bc4545eeaeb209b8c99407edc4419590e0608e557a19907d5c16c0ba2e229978af5705f8a3dc2b000d7449d7f95fefb8ec01b12a3c06b943a83a0973f42a9493d6cb222268f948b34905ae447aefc7f4da63a74fb64f88499f457b8a6a88f2b6c7bcae1b8a872f91dc4ab705c0e1bd6999d11319396c6ba2b163252cac56e8cec978a0c27ceac3981bd38943fcab8dc67632a5ffc7b71dcd7d7d170164697bacc377df0813c79f39ae36e637a8a828b344d12c1943d9cee940d56601a24fde8d27c65b184245b55a030a402284567766ab92d49d7552515021b250ff180dd3912e67c7db69cf7375c0e7894c6b4ea73aa4386bfa8b3f1663a8eb4f4eb407b0af88201af38dce71e3eea3befdb18fc293519ff18e139811e26d0c6cf959adc4a6fb540fc7a731a7eddaf946202dce571e99ed12457b00180565407733198642a0f3a47748b645e0bb69dc9ccadcd756e440514c2cefb34d3f99fb1a6885292833f548ec1c9640bb24b3662ab0dcda4efcf4a7e1a37bf0d086d142331fdeb4aa2b9ff35263249f4a27fb0db8875c14edc3ca3de630e8aa41fb38ef818d4c43b9dcf6d7014df88bd91ed070a9112c92b84c2ecd04760554d70b0a1fd159a03cf705abdac9c7ce0fb077aa24e8274c4b6b48eb3a1d4a96bf264b6df211eeee2525836f3292c8e22c43d27fb797a6f8e6ab6f9d4e6ca0f0a0f03907fe47767fb961817dcf9745d5ae4430a82f13a393f731b90af256b8192d4ed410773067de7bc563aec81d81c1cf2e013a26d4f389f45a7bd7c99a3cdcbdd419dcf1bfcab3ffe94de2b2240c14a456db9aa3dc0d6e2f2b4c6a09744b1eae49f821a28b672e72f9db768e6957aebbd399acf00f4b2b9d152b1d1f601ed32fbfe7dc2876239ec6321b51f15087fd104242aa1180368c38bd2b89112d3a2fda667f1b448377947c2febd7bdd74f54dc00625beb71a7f818df8f95ffab133bd6ba2f32082177160a3aed07dd55749e9de7cd61c275583a55d362e77b6439c182aeeb48a870355731f652445619e86488863216975af9effd485c4a666d6232832e9959da52c74d6de2a1dda31b7edf8917ffeb276670a3e7377d069a175dc5692196af8e87fd8deda8e7edb58e2417e96b68960fb4441160520c13f572b09704a80fd7ba7688ec6a58165151b5515d502a0c647d270646301ec6da2f4648a588ae8303368a25e819c965d94a8ddf93804810b851cd466a5ae5584f1841348526d7f159329c7d69fdbd02f7367e77e2bcb16559dd7c0bee624eb2f95154676d6e2d5da172212838f898e34bb35297a2fbbc7a4cd3c3acfb9c6159624f3c883c3084039265c0ba16fe7f92087fef235673151c6632c998cfe0e5c212e190839e74aa9ccda93fe416dd6f13fbca55ec71710901ac3754e920825642696498b824e60fd54cb449a980ecfc77fe1efedd2cadefec3798159532f31ece8cdc57a469ba8db90a21ae2c826aef4939d3637bbc8990b7729da5f4720016e862963ebe84e223d9e7772a3f11213b89f60065cad9e901690adaa9755410fcb95f3fbc87d97666f653f0cee83555f9373916e0432eab1f787daa0e49cdcf07dcbd07224ce976b79271ec19c5ece0c6f0e1e8b5eac7f79730332f43354b1ddc05737b49b2c146cee5fc977b7660b61768c3725df8cf44f9467cea36a3f52e4fcfa60cba61e406a8c1aca2efb28d284076b86f275b221ce6e40b2086b054e00d52f96903b2744f20fa50fdf68f17495491e4aa58c99cb2d990bab1d3a7bee07f84edd2df35b9d87b3a4e6457a03e8d1fe7edf729d54b5f2d91a70c9d9ba34c1ede82c5ac9e104dc175f68a3bf160e7f24dc09f801eea18347172623286fea7d5fa74376ac97ae52d1465f39cf6bac1ebbe5119e95730861733ea5b9cb4ec85e7d987bcac6f825b5347f87e6dd62da59ade584dfe3b34116604db54ead7df7726adcdc9640dd54e384e8b43d68a206b681468b15fddcdbd216beafcbdd8688eebd90ed42a90467e87b881aff994f426d57d047408827b95651df20d76dd2a6834094a4796196df229a996655a5f20ea5e6954be2dcb21b7fc36d3289d0c9ce3b907c838a71bd987571aac94307fe3dafa983c919fb6a6c089d07b04c68bad28ceef6b2118f1f31310ed7f9de0c11d64cf10a0f9d5d7903d3fb46a5a1b2c13b7d60ade3a8f163280a3c9d1994c1d81ddd8f1c750f33efa5da5e978e2401091fde4cf897c8982eb2e20d8bcad793bdcadcedd0705efeae12899116406e6a478249470703d0881ae01f4248c89e1f5dd65cc34dcdad616deda4280764772aa251ff485660c7cababe2a2e90e4aa3da3f8e0630dce25d8bb6f3d2106777df13d7e091e148e8f96873bbdf3ef0a780a7cec1a3ec2f1eff1df1375d483852d6ed3551f808add2ad9537689ec1498a9030b0d2f72ed4b76ca651c554eeec047019fdc6b94423cacdfe697d7b5986ddb7ca6bb41af07ec4b0732e57a033eb873b5bbd5669a545778dd95d7b20b1c8116c2a45c92e5983c83a540acda400ecb4885c8070f3750df64e331c4627c84ea6da32fe741e393de74bdeb9de30e20736eb098ac39d7ab969954283e4b7d8e060e8b962aa16b7baec84408c0263f7731a514c2bf190c1b38f0095723242f526a9c81940bec1ffa29031ee75202a97ff0a899c6a75405cb94f8a2faf9fda1ad3867d0345c739337f72a87f18465487da770a6b98f11fc54f1e16f4625c8e5584c261ba81593e48beb66b1ea6d4d35ccce5f909f1aafd013c166f4a1bb1e917d20be807034fc1b7f05dea292137dcf5586ea46b30e96d41f8eaf6385908099f4745e3af6175f0144fd8569210c3e4dde0924761e34f0c73b2587227f1a0bb6ce85028551a17fb1549915f99089a6a90a3331a79f584fc9e57535c4b0d93692db0d7b758e21ca2802dd6154703f3a1300879ffc1babc0364708b10f89616fa8ff3d67c0e44b366a1511a3f6f4761261a93531317d3f17988bf9d5f44d1f8914c692a80438855a548781be29dce712e68fc3f5a8ad184cc73494fd439cafa524011c1d0abb39367b896774cbe81abab57674fb2434646642c565fa3575e2a46b085ffc77e0313b611b109bec290d073d778bb95d85638ba791494381bac64fbc3a55b4b582e54e0c1b30371fd24e4bc0587a8fef25e6965575d51ce215a42710ede06608b97513af428e280f5b6de21bf17f20ec91629a765a9e54dafa603ae62697685cc77e84a4e2d1ac4b3167a0abeaa64f245b7fc2613ce5ed605169aa9d9d0dd273a7bc5678a2a7ce99a189d137d4a765c1ffef870cd843ddc585a221ac79d90ad687870456ac7f5a0f6b5a43d50f1e927213db5d3416fae0d31ea759010a1a3e84cc2d5c13908ceba9cd55f2c814a074a49b84920662e213a2ec751289e9d943593b82eec0274cc91f1764cae31bbc5fbc1929f0f4b7b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
