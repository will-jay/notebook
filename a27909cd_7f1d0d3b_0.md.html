<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c814bc38e374b9cdb38f8bef57caa44f4f25e455ba670feab0e66255b082b13e3ed158b333e19883ab50e1af418bbdf57bfccf467e8534080640cca6e81fb5479c202dc72e5368bc5dd2decc5802455bbf18c01e9b7e68dca220683d2bf301ecf7cd54a07febdf8345ee6f0ddc2e57ba08f7c24bdb763c9065a17d66fb5af49a2d88dc41a19d8b617613a0f8a7057ab6c09db7a05612658c2cddc355209b53077cd21b4274fdbddcd29f0d5a4e9b7bf0b2d0958043efd4486473a2e838d5b6170bc52d55ba6a5789c3fd5162ae858b80e9994a3b2fad6db647573a809852445b06b2b9b2b1415c75855086312d4aa37ee01220faa438848fe081a0fae55ce4d4254aa353d9d37a44e8ce4613984c9801a10e56ab4dc7d22b7c29d8b9dab933c8c56ed2ba12e73086ee1c8a5f9fdabced0d38125f2ff91f941f799229f84e0b03d31d6dbb3d1fab701e3f67714fb70433172bd01612fea30d9b4f81f8a959ec4bed8a84d027b14853defcd3a12221b1d4768d3da953008d7d8b2257866a1d28cc048c3276f8afc39418b592885e2e7726394d785218e830d49c214f47f4c88daa74d21fd195a4363a304a55ee528297ec937fde2a278ad0c4fd040a4fb33f1ce11b687c140fc70f0d7350795dfd399dbdcc88e008d795c65f3ef4ec83bab81871ce198f59a408f15ee854f7987853230d755ccb77b9b7197a0676951bbe074d092ae0127d13c3447949b6ffb13e1dd5bb02585f1ad4f6e543b364332e30944d59ca280f3f5e117df6b8a29ce58f42c0e2aa1f46081c6eb2eae256e1086f9bb58a9b53441ed61e909a67ed0c34b0c6020423a7fe262a010c2aedc7695478ad6e7322d362caae2470009447808719a50d292acd7234e9291e202e83970006367344fadf9cabf29b1a936c8255749e34da63242dbef3e809cd297203e7a4191599a8e02bc18c2869c4bad0500168f5c10ca45fc35d283be1f01a957bc83c1703722fcb140d45f84f0c53aa0f10077460a17b26e153b5435e741642beaa42959a527e2ab2f1c2c81f79574329ee91ea3db79dc97226abf35ec5dd158d07c96e1fe5a2c4e9191471a54b877e6f5453ef535325a8326c78cb4637b74cc06d9fdf0c1cae42bb7533d46a7271b54bf22b02f0dfad687df33401b1eeb41c16426d17794f0cc4736c8692d736a8779f0a2edfb6f185a36511b13eea29da5decec2ec0a72ae916fd721f2180d7a499b59dec4a4509f0f981c72528f0deb6e387f9118130ed93a5632e766ae2b64c434c9420dcd3244d770c1040f858a7179473e69f6916bead6e56b04eee4f42a80b3294da691afbcbf88ba21e25d5078b97e42814d25765525a0bf7cc5a21e88832e73fafde213f622a5be8f202e64eb201396bee6ea5f58e8073274c721b2edd56fd79f5460e041ace40fb0090f69592a5760c4059212a504443b95fa4a087a879f5e30c21e659c0f9f63b7fa079d2901800bd1e360d92213624f50b133381a0a6fd0fe6c1ad29b1b7027cd476814ec8abcaa6deaea331f6359b6a3b3973c4760569997f6900685a00172caa5e0da26e556b3aa36f9b67d83cf49e072bb009dc42b14059edb34d4806f0fef7b6793225ac7d2e9b1d6e9387efcee26da813de386dc09df2f5d929323829e42e24c07e094f80c2e82e78ac42ef48e056fa627dcfa0427c315db7d8ec69bdf15ed923d04148131a0a68b0602b522d06f240a263eb7ae29a054486ea34066d80b13c4a02f5943477b6297b18daaac23abb5bb70965b9d705a8ec7635152aae7f26ab33e00f57c20cd08202b3c61508eab6827361e4dbb6a3b6bcfcaee6645e0c8fca2913601f619d87deea7f5a530c9c30d02ba7ce281a19a5042a01d47fae9516a1a958da5400a9a1817b4a58501018a276f24f3b914b793d1a37a2a621a814702d6551ad37fe1f9451ba40518f6aabf05da955159f61fb8ee5632f7ae8c09fb401c575b62214d712870296719e944831d38078ad549e56e7f0eea6cbc557b1f413257611c05705ea6f687863a9a954bd8654f6735b4243a4ba8ce5e5c43f43bb74174d163c1106c0b530688e83952ae411c8c84c403448f3d5b76b6601b4b2cc5f72d520a4fe653e1ac5b4a40414eda11f77375cca17ee9b0e81af042d190e9ce18fcbea0fcf2495f8ac994d5c95d5718d0b91a1b0262a61da53c32c0dd91e33efa6e3d6a86bedc4963063d01564d17ca7121dbe5064a306258f2e349995278b03bed993cb5bfaf48dff3ae48dc4dedb5e6764a1f6fde0d17377f644a09932d05055c9b2b504b65a24377905f03455fe06bfb55e830f455721fa58877803edf400ff229aa25bb78070f075f790741b17b4e6aec2d7d5f79f46989ad8640ef6974197be6f34e15a094a5dc1bb1093ec17fa889386fa8e70aa159ef6dc8baf829612cbd0bfe58ac86bcd14f5b0392d5af6e317faa530141d264fed47f4d1ea9ffd790184e88a94b859d3b6f38d120d8345b951c059e26bcefce5ebdb845b9b328a642958aaa6c99cdb19eb8b7450123f8d70a40f2290f5d6b0840d509d0067ac578fa6bc6087b1181af204a4635531ca66f95fb869416afadd7f586bde6e230514994e31c5a41d1699385434c78ac262b4c4736eb9cfd13b68dd149ea3d6bb7d88ff83a8fbf3f5114b82c4a0ab3bcf81436189531d95097ddf087ac95aeb0a423f7e40183e02c8a911e3fb2d9340d34f0ce7b2966cfd419c4281d4d90120be946b95d8bfb74f7714d0b8653acdb5478bd05810d5eb388dcbcfeb186221501b93ba865805d462a8a158bf18d82ec45a959c180eeffddffdabbc11c84ff9997032e1c8897543524b9363c3c45fc7f3463bb7c54317784d4e5c673eac70e72026647eae862aa176abdf0cd809af86c3992de240d255b2f4c640923c0de3417cc54af0bcb0fe2e740002c70879c24d43333b9b9871836dd391b59cdaf3d8d335a6209e429fa6515ab6a58d5dfd721a19f7f6c56ffbd73053fea2a146ea05a549c51e42427bf266f8d77d04e55e7acc1fd073d67e4f99d3128cd640db61510837c1203372d63f8f063fd5497ba39d1b9bcba708aed3a45b5e1584b600ce3c71a258841712301f28b2bcaf618d798ea0a4af7f7dd98b45f09b415e1a642257ec6a803f20c546af4886f0d79bf4a4630c39dc43c9be81555e4a896168543f686289dbc632fc5ab1899fc135d70f283c2ae46d3e8703f2c45c4b6e85ba1dfd4fabd330c6b4c53931e88a726406af7052b58a7d0882b43290c385e71d1fe4bf6ef3fb45830b07872be3a406baeaafe79fee94c46f14686801b609eb55aca6fb9945e383b41203e979d1ef755bebf541a9cb5f6a6e4a2bb5349a208f701cd36ea93fef90759659e148b7b0440764731d9ac0e45f2cbd11e1bc5837dd7d8566b3be6757d94599ac942f2e1799a8f3254f18d6118abd004fffe3fa355203a50adc6bc44f5a3e15387084c67ab13ab818991e3f78a9faa2b59959a637c91d65fda9535f5dffb64a91fef77abf9a9e091bf81d7896ca1271da929d4c3fb1e899cea1683f839d5058d83b5981852b80cdd02e5116d69376ed6413022f86572e69f93789ce934f4affc22ba0d0399443c58883cffe4db422a18413562d91dc8b0354568333703db45bdad316a8179f5eea35823d2ea264355818dc80ce7aaf04d9ca8311c41d77ae31f110d4616fe66afd0421e087546915557852acce6e662d7a565662cfb9d6cf1c02c02dc503d7971c898fdb4a0704de97790e8a1053d80bbe84c625a8f5b10b5ad3d1c9491aa68dd6bf8d6a52a246c5fdf11b9061363ad07d59387f5c841ca3ce17bf228b5ec800362a24546af7082c8d3d825103ab3e2a110d3cfb4d8bd0b46456987d3a51ce09f0ef97f23ed4fcedebe619af4185898b81dd980549ec970254095a76cf3a3498b134bbf2b15e59fde4506a895c9f5a413ff797e1c11669c3482898d6974e58429676d0d12dc1879880b0924b5fe383eb69685f1e6d14a95fe459e0b999c108b4f425a0a240cbfa012eef2f804140213f59274332c087d96d946aab4a59911579568e184d611b3321b233a1131c51a233f0860a0c7428cee8bec39129d0b89638f6e0d162b1dd788271f9ef0725f1bb0b6c88a15f813ae6ebcc11387a2042b1f9c284c320eaa71ae0b6b1080edc16d3f37c2012f405d5d41346712febea09e4bacae6362b96c938b982901b2d452dd40900f994ab5bf6ccf2db108923568de60bb22d0ee4fbece6545d669ff45f9015eccf15174edd65ce9eeb4c5f55905aad60ff1acfc22eaf738f1ce89a4cadf779f058385e522ec6f7739ea3cafad241eb676aaa28c8546a4753cd1e6f8ad45d5f78f9940c7dbcda5fcd0f8b78735286d7b345c0872d7d19fc47dd9827de96e3d2f55fa33da8ecaf3d596d146553674b83d49dad236f55d7bc4c70a6f1167e53fa7ac7dbed720310b043797817eecacb6660152d7430cd611ebf5c9084517fe184d72bc1d1262fe6dc583b3c9ac5e1bdc8d64d4019f591f52a979ec30662b7520d00a06d86d0797a626f360973ac548d9b5693779343b90373345a65a203409b1af1e0055c9867375896c43d4e5d90158805be225d9e2d94c89938ba1d9459a5b88d40ee8cdb9036fa38722698f25f55902ed88be97945b1a79fe90cbe38716ed52bec6e924aaba4a8a1890a05c37478860206c0fc4cc08d60f5fe8e5f353990ec189615bb651771c311da5a15b44f3ef7cacf93e449edc867bef5437b07caf0cf86b8875657a036f9d7551664c58c08707e0921358ee74027e1a499f852734737f2cddf16ce8d3e3c3f9b77d7edc2febd0273b6b30401ebac53ed442f5fc1a146515835a7055b07e6e5521620caebcc57b493fa6dec3debe478e32eb31f4089e61e962aa5e8e2a4fb26b53e65b1941f9025afd9e40d8894e7af487c729aa2145e9c924ce35db751769c30f5edc1b07a905d374a97a63f790ddd48800807bc87aa43b73d19ea4c961a3f45fdff13529527f025fbe24d0566eb02fe646aae6e19bb9efb6b9550b52ff00c0c161022e93088cfc462ccf93564c53551bccf841b28b6a68276c077069ecfec79d84cbe0882afac107cb22079903259a15d585255339a95e9acc0002c4d90da07c9d2f8d780b1dbe185423bf62471a7314feab47fac117f15ab9b6dc6c1a3b41c53eacaf2d2779be583de7674d1ac0ceb04dc94daf974ad882be2ecd390f4ea7dda74949b2caf06b8ac2d0d43e46fabb282a31939ba1bbf401ad216177c9d69cd55b140054fa08f4b7138ed4ea3aafd5740e6e9c42f498f16139c3909f388a206e0fbbf7b8a8923d83f3d1d808fca5a6fb92294372579f54b82d5ac3a6f0faccd1e325e135b03a619721225d10c60719f562b8aac7adc760b4d21ad565093b37a6e818229dff9253019caf0e0562b2d3bcb2567c421829e4ab4a20b0fa81956b2edee902a6cb88e7aee4616adf32faf64d762f0ec3fa434480d078450ed2b0d2790489da44c6b41d61dffce4531d3c2dc8f4fda1179438782ade3c41339ddbefa808939d78ea747782a1d6a1dbb8c33c919056b4ea51eae1efcb3355d2ac52329bed9ca942f311ae6ca2fda247852d8c4862acaabe563565a104e964be4bfd411004fed979601af64a0a7a5a31563b2d8f0f07b1dd405cf5e5fa2e3468d5a44cf0711ae7046aecc16f60c7f7a86bcd14523bebf41a041ff2131077e443c0eea2f48b73bae59009650d3f1aa0cf12d95aeb6b008701278d0a39bdc317e7f04cf066ae88102af4c63576bf04c138a46d74d9d1674a9f81f7102ef872188f93a70a003f75a6898b99d41500ec4a0c7969b753a769ddd807a057ef13890dd74a611fa6eb9d2c7fd3d286ffd95d3692d00e3fdfb3cd71c6142bfd0966020af424a5d1004863e18e9db999d352c59864d702e66c2ef9110254b841eb6bff08e687054083214e08f947d0ba03a6dafefced978ede48db2d5b93e106ee7e6f247a9ee4449f2bb5bcceccc96f43676086df5291046f2b1f6de8bdcb0d7a7eda495203bcadf13943cf6a3a703d11fe0aaf649d60b2a80b883d91c1310f11914dc30520508e01a88397498925d908c0b753d4f4625e8eed8a4037d25f6b285366c33f18e3f405cc5e388985b5f39beaca48381609badcb36abb92b3182aa4f8144e4a06c575800392722e3074ba05ae1b4843bf12de7973ee39d87b7d4297aa3b28a9c04a331e11032e760ca2e51dd32d8e619e8691cbc3f67af25ed4bc8b1e2154493d6f65157f5d5434763cd87fcbf8508a8f5013c1ce57af0ed8156cf86cd269505e2088fbc4c3f9c537b7a0c4ec3e12988aefa8f924df80c5bb4fde3b073787bbc7b7e4835da8f2a6fab590114651c75869bd52980ef74addd47d6c359326ecd6e5f8db7d3d2f604ad8356d43c5231b441e7d644114eafd9ced11ffd24b96566201b836f557f24d4912409e4539f2aff1a4f4ab55f62b41de2a3e6cdb86c9aef339b209e85b0a32ed83808bd8a969152644e4b1bd0430168ed954b6af7b97d178fda5c89752203e4a9c8d949db5770c668aae28d495d83a6c569b62733ee15c3d1f9c57a1f1eb7bb674de4ecd010d75d1ad02f251eedf7ee884d7806feff069354c703836b75c5dccd9a7e0c935a5fbebbc4168139ee0f4e9ff7cda6518f688134cbe1064491b10d88643a4d3f7fe997e3e501edf4429d1f076de58bd457c792f59db05e85d0899ddffbc1126ee6a57d008315d013fdd3173a98d314992446a082622e87ab5a39b7571c0fade61abebb88021845f49df21eb678283e66fbbea4e49e3fe4d98df92c8d89bdc6df617ec9de062149fb870c773274dc381759673997d743add71566c4b59954a427f76347caed8e67692bcd8e9eb64c6e7aff4a14dec14fdb0338652a2c69320cd532020f37e609b73b3c2c6f01906c083932b3e317e3cd3894d551ae373296c088258bba7202dd92deab55ccc99f4ca199422a11f0a902e20530085aa38543b31186ddd9433d513a38aea4c60f058251a95d3cd2e36d7a419e0070cc1a79a24569858deeb1614a22c3b675f77e31fa66e44febb3e859b9f783eee04973f3171491d515c3bc078c1d631fff5c912b21cb23cc2928d06ac12cf1934246263bb741cfbe15bdcec88e467a88185b1fca423c24001f8b699a17d03d246c9541231e8b06987f9270a7632cf4abb56021a2824d0bd57c5b0cd2ec968aff69bf22360bd6b8c0b7c1d0e017625bdb764ac0914b8eeeceadbccdf40a38b70b199ea7e35574b958e25040ce1f1de25c7869a3e3e3b91a99a24318d4389c74d06619e39ae9858c388e01603e923c2f261d0168264d4e3f7d2bf4eb9c7d6d4d4664682c8b8f90039c0572c03b141a49515257a5cfe4097d7c292acd4d5019bc01cd0e1833cd0c22e99a24f92603bbfa4d9c6a7a703cd627457c0302bdf25416a52496b6b2d4edf29ee3144f269ab297be8badae9527a530a1b0ba583fd77bb583323705902c44b64fb7507322de0efe11979b13218636c0a8414b76b4f9482c3b1d1c70095deac5b18701e3e6110d613cdec1ced30e4421c86df0785db9d63a04d48798b45b23fede6994ebb190de139b7e8612787fa3a22d82a362c573ec8ff1a20302b28791b843a65ff215880742398469b2e378f2468983b82ea86560f564983673f41197ea2a1199abeebe9bd37daeda8bfb25eb5002e3b668f5ab7989467ac37a4538a455c91bd819bd36fc2af1fad37b95b266983ca7719b8a569e8eae29c95775b245fdb2e9ac34461c6751413bbe6abb37fa114c517a633ba33681f02e45402b31b275c9e485f76070ac90a2de8a102a2e52818815b813bc037dbd04b423f97cbe2cd9e5045af0184c9220e390a5d9188c62e6809191c4373426a0554cedbba95751963ca89c60a23b855b79f56ece86579122727560f06aa415b1495c7b9a474e03441976623633822a4998267388c58acfa0e3eb063cd56c757725909ccaf3ba467b9cabf03ca2c65d73200ac47e9bd490b199cc6bd45eaf51cb3042368ea346d6c2fd3195de85cc13726719026b33b1d1710eb8ca6c398868c7ecdf82a366664ccc49e2d65074432e960e73f5122cad2b0d2515c73ef613454ff7d12a6c471e177ba5299d81b24bbbffe92d23656ce1738e2ab3ae7c65449f58ad86e4b387e256c275cfa3eb899aacd1c38a7c86ae81e18b79a9b471abb5fcc4a12916aedf931e2baf3676090616384a8789b259314e79373363ea306dd20277631e06ea68d28b338012fae34a3554320b45e57b49701eaf4f3aca43cd82e6a6df2949e2647b7fe744af2192eaad217a76e22c131e58eac800f3fdafe65f9e59ec15f46f33f3a1be22acbfbbf39b77036ea4d4d22b7ed335dc17b88d0104ce5e775cafbddc8d8331d7bef988c1fbc26e6f76cd8f2d7c73a233a60a3c23eff147ddd50bad27a22d617c46b5ff7cf572edb749e3ca6dd474e841657674244a8d560f3f0c104264fdc32fc8a8cc1db2dc81060f4d60a9694b23c2bfb2ebabb9a806490534b0604c60e945a48e4d13f6e202b482921b01f52f709eb9b4d41f20106e1af1681ea97832fec8190d613a981d38de438d5468dd4a2aa475517bb9c1f7c17cd85d00c681a580ca24a7891aa760bd7f42db86512648ca7be93fbfc5923cd9f8f5ee1aafbf89bdac368de414d5019519180d0ac9dfc18ee855f623e6f385e66a136a19a036f87cea9f4733f1cae9c9076054413e6a588ef8a5604d7058b70861015280251b4276d27a307b402e9c721173006e3eb91e22f39ceffe65fc7e0b059d41896a037bc273e8dcdb5f434e259ed4f8206862fb41632467588064862b3ec69eb7c039c4127ee2819f4467d18c18e1d16280c7a10d593afac6ae0157859d59ad3e21eaa0fc4fbe5d3de26018a49586e5fb6734bc8899b6c3f1015db031bfc8a8bc1160bbef88ecfeebc27b7537ad0c83c18ed77e755191dcbfad7d7b4b8fb788adacaa6b8c6ef1aeb754186ca47035a52f24ce55399f901653832698754a2ff54ed6ae802ccc762dd532460b8e24b84bf2b8bedfceae65ae117c9ead4c173fbeb6aea6d8a1e4014710842d280156fb17b5bc25efd00db230041efd9e6d6b2140924e66657a55ce09cd0217bdab3f4140b1c98a04fe6c3faba1dd1775031a1b86945d9f62e2f6ec9f3ac2256bd0e88c1514da5b8d1fa255e2fb8d6b13dd3db557e9b18cea55c1353e5281201bc4a0d906f550df8a60b497fcbc4a9a10d2b70cd8344ce00b629284346275ec644d23a5766cb1097e73808aa461a2f92162fe899b14055847c2bb785df37d27f9e1b05943e68ffe4e28a263a526af1c2d9ebafc3f55699d7654c1781c29c299f2fb830d654c1251d4057f147c9de303644337de2cd7c0561736e912f90eaf2de2d725e57840af2ec00dbe12b7ba84bbaf1966f82c455edbd389e1a857595eacb7374fb4ebea8c3b23ee834a2f3736b6989153fdb6bc44e9bae321dee4707b2b235bf41391f7c1ff3eede282f85e38ac0e9359df10ad5c0bbccc3bf5699578195ccc9ed40629089bcb9e0c68b8b51bfbf1851b5944d2e519705b5f7432b992d44acdf2eafd8a09a0e9f4ab2110f30827ec79510952dcd6b0ab8aed2fe5ecee5b9405fbdb29d8cce6fd306544bc0e60575d88fa38737776f9a636b5d315fd2f89ff3e90a785649539e51fb75e2abe25d495b3a225da7f1ac42f5b67727558542b282a39356a3517666feef75b639476dc11f414d75bb8861cf622a606e2530045ace628f2c180cdcb56733360fd7a089afb0564d0539a30ae8c8d355887b5a4c47ae72eb2ce3c75249100b7312f1927dc11298cdf9c429eb1a9077b153ad3e9a89ce515fb7e4aae719e9a5f2a7ea418244ae84750ebed705896c36ecae0ae301198d166dfc0179d6379dec368210de04c7d8a96bd091e14a9fd47f78f97c9ee998069ce25df2d5d78bf5389b64cea9b9e88d7f2c66e286932d16dca390ad4e495ee027477e7929a9b49a936457b3ef1321eca681de434cb14e069f7146da37338999514ebfa851ecb5be3eda83ea33e6aecf366a1952e033fee88c1263bf7b671aad905d76e57c60706664d2406d2ab29127acc879bc689e0c5880022bad5a285da0449d4218eccde141b46363a0fde7a8e3a2701c2c482cd7d59d438393c33e1434a7cc0a71815527c4176375f8db40eb30453d7fade555a35088a22720f163fca88fec3e8396eeeea2ffa3e3a20d0b4c51c8cfeaae3f420dae0301bece0b39ce9d281d0f69ff1347764d157a1b1bf0e94494d2787e9e9d2006be000acab2e6d20a8d313681cdb9f9077f3b47682a9eee5962170827e5c1602d55ff89eed94d1f03b4c1df1a4c5577e01d5d5da805d89386a1515a29194b5499f5e94227138a087ae13dca6311e489b2680dcd659a16331f4fac1ebb94fc7c9b184b2ff73d32ce3551e8cdaa7ed8775abac008b39dff16110ddff801653f7dfdaee045e055aa8d90c14a2db428dee06c5488f7b107707aa7894109e0b6d104453a688ef482d560d023d5a41fd06456b3cf61caa1bf897370a93c1bc478aecda00ead842ee6a8f91d377d77998a4c546f22f2f45e636f5502309a1f4eebc10296681e73ec1a992ff2186e6f0d019b438b2e316daff031b0ed3092736ba1fa61968025eb7b0e27dc7412d2a7f7b22880f7fbbf0f4f5e1b6cd44d8eee97826c83aef8fb07c32b66e5d8f4162cb91a759356d392d5860b26ef81ffe31d258669d1ba61bffbf7581e2cd4225015872f0ff73096209879695f974166502e18aec0ac183d89b95730558e2c3f01489337cc65f4d649289fc5cda7bceb3ec4534dfbf546593562773fc0711278e1d0d1202d83c541b57dc12d82eaec5af1349c4427192209be8feb26f7768ce834581a75ac5624ac41af4f34e8463420e31097bbb803c0e890daff28cdfc4da5f8531a3a93cc2df03c21f2953f0c6f2231f75e7ae9615330d813bd2d7a5ed8997994f15e977db79907b3a516a503ec92b2d7dc86e547783d9a35ebe6df50b515175ef1cd84cce6a931027b1073b69d08fc2518b20bc7d63c872939c28293326b44aae83f9afe98dc383d423a7e25b64ee5886c6f66a9a8eee4fd7f92bd8f5a1a1345c9cba7aa320fc0dc9ac42bc21494f06ff9a788c147080c3db6110d70ae652626c408617350f800a35d99a089b9d07d6e6d6aeba3b4f33cf7635dd43d79188f7d76036f7fd4b911b4a320c57c1f4300644176b25984a3624fc13490005f5caebfd827f9e377ef1624511ab7b574cd4f0287a75ac3116e5db4fea92116b55084dbd452d43ad55ee4417e358c4153b401d3f7220c5c22d1a4c2ef7d190e514b7b35de9bd7fbe9849dcb8d9094dc132945ffa16b38dd5ba9e9c371ddcb3f286d28e53b1f10dedf9502ce94cfee0fb7c1f561215f990841f2b6297155c04fd31a1db957036c5d8ce0206684d988e6046b8a1cd7f5ff8c01906cf56283af47313f33047bbae50d963712520a81087bfca66c120a4f3a88b9a7f765a390daa23c6cb47e6e029c4bf1956191bf9a10cb2849f3033ffe72f5a1fdb490a151eed2ce0e4221cabd10276c54500b947b38b4e78509d22f6c8c17a7292b8c0884378781c6140f9a3d1e800df77fc7724705ce2c055175d737add257fa9a007f56340162bce7181a377d448db8a9fa5beb176c8b67f073250c9eaa41fc2a9179529f69f5a1f46e5f57ac61ec431c168b1e6049b658922e2b5f4c74897c3c42dbdad130353e353047621863f422841f9c0087181bb563974c01519636f01ff9108f27e7f58a0f4a026864419d10b15e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
