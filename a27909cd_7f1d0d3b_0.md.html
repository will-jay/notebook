<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a6eae8d3f585d703f9bd63a20caac2ec78750f1e5d8f7dc7d037b473aa137db128cad1ac780799f51e954880c189eabacf95dee7f67657bdd3552d270e0bd78056a9310da07ebdb049c2e1b051ca7b942269e88c078302975ccf4c7d6a9228b7637d6d9683cf668b360d93014226ef44f2960d99dcb08815a168560df7850cc583f557de9f1f7000ca19ba18ca736df330f2b0cc986a457e4942441b68c5835f38a87b5a96fb82a3b83e8a67809c4f73940d78d483f58fd8a04989a239fcdb1784f64a35f0afe9108a404c35309ffb78209b6436e091e38eb5648fd8385246852b3ac62f0116a7125916536a6179026e121747c8eea559d5efb4837431e306b593c8ce7d8c0e723b0cbb6e836c8211b0fa5e9cf2c660475331d30cea6e68c9c7f246454f2bf50cedeb0148612b6db3e9beb80f645b4aee25117161d2348d3d598286ebf2e8f9a1e1e6112193719f2d73fdc3b14c35ed3685212784a7be766296c13afc901ba12e16eb7f14e31035601c9aa2aa3111402f9d6ba2992eeeed6c945afc63c9a7f907a57efdc7a1adece4c721185ee2860f67080195e65325f178f22f6fac9f50658051abef1d567fa69b6aa015880d6f53f31f7a5f8f4aac638b9c7e6f9b502328a6c445ed31355afd4af498becdf1af2935ba0aebcb742703955f4be84f6344060ec3e8bafb0ec8c5d4efd83f40b0350f4789b65135b7e1a83fe058855fe852cc1d9653e0b8af612997a3baa263caabbed77b732a8f729844dbe914207cc513c1fe10625c0a26530aa154d800bcba375466ca12d02c703b102fdb129fd162d3b3887649600d53f1a15e8b26e7afaec06f077d8cc90b4e875e71583021cea129c560a0ceefe891013de828527927973b21f1dfa9e3748819727d2e1d9b60a8517a4a4060cf38c516f600ebcd2d8a265092399ee2531822e442736e9889a3bf845fa66e1bb892075ac1f57c2427f7f648b6305c0cebaafbbc11bbd24a0050b609e6882a13c244315908b412e1ebe10c9580f2d0aaa3d93463918876a9be700faf5789e70e176149c8bd8901c35408ae4e5805b4672772fa20a8e37c5f8c9196eb462dcee911a0cf83f1c25f72f3807c2054eca7a964f07eddfbb8b5dda8329eb91df437a3c5ee15c28786064d0568ee70ca0a36714961a6cd7824a1ac81150ec398a6aae0d40763ea7d13f713e6234454518a87a300c10d6531e241e5ec14ebe6c6a3c4dab922956ee4b642e38d91d2331d9093adcf3469d33e67ba020494b9589c88437cd8eca1789649a582ca3f79bae8d12923372c40218592c3ab72c4ce044c3a2e449633e3ce0c34360b427003683d6d964db089944179b6e324951fa6c15b5f586488c95aa3bbb87728e4b5c5376a0674f14e4c9c444ae8ed8f2419d5ea244b01a8adbf245ddb610f7c0c84b97be144889237f609a3b92a630577b5964d87fc399b1e3cb0adbc937e20a3c2ce7638822df576f7fb385e495530c8ce949048d2dc7909170802d2ec805522c4e6612c280714be03f166e288a2a810933a20882e02719498d7760c63de8ef4a373ff31fce6604899f5bb0cbc9e475acc1ab4bb340063cc11fcdb990e3228e4b01cf03f0930acb49dd118afa26848596bfcca1b94b9f10501198d494b9404401f0e1c60eeb0c8f996445b7e59cfbbd85a626bddb81b2fe67c4e5a9d100031d1399214aa8e707832087be8961c764f49f5ed43248f4f62534070beb0ca3a9bc1d18c8da33d103bb73aae18b46ffa83a9fe79a7f1155bba11e84cc7cbcccf5fa545c273fbb9f51a9101c44c9c5a869f99ed537b82d2c8e1bcb28fcee42b4c20c13d7684b07323798dd3c56e0967cb884e8b85f04a17f6a7def5feac81fd1461b49fe0dcfb2a75c124a872d97cb3df71b8633c41ff93dc7398c7b3c7207636e83ed3bba05abc05425cb500fa94f116074851f56a0f6511bec856dc70e9019ac4d74fb227c145b26abb8411712e007d92c49fb6ab08e0094a27619e1128dbb53dfa1662b0766e6adb891b93207f8e357cee1c5dca044fd3f7874e94a5719ee9a8f22c4ce9ec6bb1c38518f5311adc36957b41c60f1e7edcfd697bcd8768200420267585730cebf3d4d88e6d8c0be32d593e699aa973b3b217c0ad2b9f37902c86b42cce526d1ac07fb6f2d59a5d706a21c5cc941ff75f973fd55c18a49f95998ade000f0a9c4ad8e78f5fa2a1d996f3cbcac542f07833af18ea10b0fbb20b9f81c61ed2b208bdbf314e49f1ddb00913b50387948f70e6ba6e34333b8eff595e70f3beaf0a1250b97fb836dea8a2fda1e9ff080626d24ba9f4610e173fddf97270293ab2fe403d1e12fc6a03fd56848b05d6a9dcdb970ae04788187dec970c3007b955e16a8ec8243d35f7c1d2d226d3e713b8014eab45626c006d0eefda65bf54059108bd14a8a6661fdaac1814fba2eddd0f3a54488625ece79cd11cf920afd9df3ac33f905900ccb4b4513cf134999c78d9634c4a59d7c7e37ab6a899305e9c96cb6382b660ea92e0f860297128c799aa14827cf14f07457e0ace2c3b815d347664241476d1716ed2ee9232971af788f482a4a709399bb3bbb954b5911dee4ab1e7992f6d53ce67ca5a12a11232ceedd6aff4fdc743d6bfbc8dbecd0c892186eb5264f283c228ad288ec8eecf33d298b9b70a88cd96ccd85a0fa7eb4be2fabdab365724acacc1c67484bb5849b532ada4ef3bc1a1b9e7df27a1c1b4be3482ac38d1d060b4a293cc21a74455ba94cdce7a3bae5f8e11b394ac534a9923e7d0fc5fac641255f0a962a4012cf4ec341b2d2c201e12026d32596cc00a6db26242f2ac31f4d1b1831cb4c7491c96e870111c0cb705cf4e7a3b054934daf6ffafe05f398a8b1b1f2e33028c46d11ea9c1595eacb5b892570345c75db3582578006960c132fc4b00ac7052a40e502adaed88f04100fac63bcb66d0053f294fb53fd8b620e9b04ee48b62dda62a0b414dcafb61598aad739c3ee3580acac97b659a4725aed10b56142d5db2a8a147fde06688892c67c6ffe4639af929a8bc33bf59a9cdc16824e6a8e626bed3f95f7ffd09bd9b61db02fa43dc43acfa69c464903d28d3c3daa025ca6c467c1479d05d17bc19e305fe6397030acf239cd84e281ffaab26b7fb770e982b07bfac7a3fe2ebf49ddd41c4a7c9bea8c2edb1b77ec9b738c6036d32a759c3b5442a96515206b11409d2067a2d34c201b5d18207e4ec93777f3da51c59826e39759a027c7c33b9449ec064187aa519ba835f91413f8a6e8f920dda888060e479fe5712faa6f5bd79c8e44e35b4ef510698fbb31e32f423e23494fe6f9f74b4a0a1265988ac8eeeb45edb9041f92e6d380ed9023dd0dddfbce54d7dbd024beddcae710200452901236a1af7dfe364ea3d20f373ef8ac56ae63eb76388830f0c2fef2138310468c982f2ebadbc7c30319f8be12528a11a1d1534bbecbab2de9bf548125c8c4e9472332f2dc527539fc12839122a0e5d17039e92bbe2daf33cf3a504f60ae6c7c82ae0a92504cf95dbdd26bc5c1e42e236f55ab14136b73ec99ac8164434e6b693bd904873f3cf31bc042911593b96be50770e036e46f9b6ea049a610b0d5868b9c1dd775a048e8a748cd890023d40f11557d9bd0ef2c00f67a2b90d78eb57eb61a2cc222ab7ad62807cd502e212180254292f2d103b594d738e8b85a9796e07b05493fb8df68a0596fb125d96b07d2e282b155a5d8dd37ac2e35b5369080e866f31d0d856ed8c6d9731ddd9f40e0ae6bc5703c0d754dc18835f698d8933e746042bf5e33e7219ed6618b602c7eb3bc1f3771315cc08579b37b2482e152cc89edf081093d3482be3dc070b8c7f102e2d2488cc9984f805415b7d83c96dec74b195f6196ec1c7259c413a5340dbad10528ad624f0315e1a01050e413abaf9ca2c44a9a47a365a23b7db9a0ec48c3f89710c3b02bc447bf7650d5daf0f88a3be5eab4629cbd6c7d258603aabb466568c2061db08cf1f2cd3f0a5a28dfa7770197dfcaa2869f6ea78dd6123503048654ef106e94facbb58a4eeeb263937d2ca2f8d5146b951e437deec9d143fb086aedc01c0226aaacffc67c7d7393f8023ff0770b3ff65ab2c30127991b6485ce697a97ddc055aa6ff96ebe5b350f4bd91c47ac787abb7dd7c8ebf6dc38120b85e009c335d52d866be05e48bf184784ac4d1b7939d690e7b80356d246f381f8523a6dd6f939bdb64f9c9bf6f5055f83d30cdf3964116334c41f1377d5a6824935e8700ae351ee028253b0d6ae353997e9fbf90b25b05be38f6ca07554e228533fad484efd995ae8cd0ab7a09d7d105250adcf68df510724c6c25ca2085da6574ce7a165b81a3289725d35a2c9a5e3f0ecb39567ee1647a152ea6e09109be8c0155f53d369b6670d05e3cacfaa5f3c71b3c5dde44fcb2c6b0e385a8db3a00524d0a028e4ece4119f64db8150657541cf55c51792a97d80278d81f3a17fbe49559847ef7b87d1bfa36ec97b366151fd68ad6afd29de202e83d26bf6c239b362be79037b7124ec61d16850e2a702068c006d3667f7bab8ae0102b86067c7327febfd74766cefe42127d3ff689873708338975f342fb8d7d8b6b4573aef34cd672d6c4fb77a108358ee0f64559c46641c3aee68805f8955e82014c4c4202f4439a6514299390452be66da2e6dc9369608771a30a7f14e158e3fc013051ff9cce4e1e8de56a54d81f8d4b569c1b3397673d7ad0859f2537c797376adcc96ef9123813eb43ff3a83eec6cec835712903cbe0705fc1a85f3c601db9d6e07dbd77b329156b03e1fab6cd710124fbc9504ec0b1998572642648945d22f6ae1ef3da2ecfbd8f5818faa2cfdc28294fc1bdfaaac7e463f04e6fb58e13d3a2e86bf8c217a751bc8ba9382b7939638ec094345e4bb955714e54dca4670242d78de881cd99d67f833084d6c92bb4edd1c4db48ed6d1b43b62cec06128401643715b466a347e7cad640d2e50985abf81ff008da39a352ab0b98b7517cd22b9e1cca54b0ceee36d131502d9e51061b628d1d95e4a7cee0cd5f6c30642eef564466d804361cab39965e9c0037292de2279394ce2cb5087d9dd86b381aa4cc15233b6d28d0ffcf837eb7fa1247590fb70ec9fe3515f2cefc35e5c6845b94410a41a265f0afbc5b9422521826926e0f76fbd9b8bed4a5c11f8bcedadc1ef936cdc271ca7e17c753f2101a139e549ecec03908b60bc90832fda649ebd38585bfbda8e129de36220057bf7f990fa65c6be3bdbec98c5f6e0fd4ad5f7c08dcbced0dea0d18848f971da5205cf06002dd54993990bff61699f0a844873840f025bf6d461eb34826a37374fab5ff7f34fd698934b9943539228370371e73cb27ae4f8f2258d3071c3cb9c48ef0babb9a3df3c82ef71d14018f6fafefb72fcf5a402f2f9be91f49f0adbfd5dafaddf39a050ac99e8daba75962a0517e77fd0d37563bc88b23bb9c2c04f636d7ee685f0d20c7abc918fba1ffd0ffd67b259ed0d70f4ee245198533ca8bcf731d2c759ec13a873a4893c66387356ceeb7ec2f8ebe8e0d174d719172186d39bc7bda4719b94629c3f8958c2ef7216a6c15e282e5d73c29425ffa2bbf45fe60b62690bf5d0d2999dc3c8917c7975e05983311c6fe339035858f7fce778398c6a5835a181fb1010a4d99f9f0446bd74a2c8a3c1ca2d45a695571ec30b8e0bebbaa4b0f9e6dc23954fb94fca102fecce6f38c08dd16a5e47c96dd9851f5b8c8f0b6f807b20f58aed35772cc132d4e9168b528484ab6d1c64075b6715e2d61528dcf2ef69858f33d9e7541bd7920a8a8b248f33e3e2219a44689d9c9713c1cde1013a7f36e520789a7ef6f6cbe2b7f1e3bcff6ce56d718cc6c5eb2245a14a7745cf5a85f5d8a388b979110e14d7add967dd24ec18a7713a2b82e9365df90768fca750dc158c1a4128c91f92308318eabf256f012ba12eb86ccab6823c534c5164203092eccb3008ae2fe9d2e644268e257587ca30b3506abff362535634a4de6e668f37ff9e981180ca407055fbd21037088c789fcdb1482e483a5b6da548afa533f239868ccb496926f4154cc2f85a99fb003b1514516b65dc39f35ce96768c97b081a04f59899a155bc1c42cd10b18bf24900f8a99c8e897e0a9b06d48c09d8540fc85e84c63f111563097d153ad0e87cb834089b2a23dcb2948aaf09d90097977563d6f31e0f075faf62c38db310d07921d0f64729471403809c4a251686ec75a27c3a76394785ee052774a690bf8d4225d2915039bd2e18c9fc1d8b803ab09ce86f2ddb270609a3a38f81949049c67708870aac2c0028b06743e5deac3e43e8401f92c297a3b8594c88f1af0bcd5fe346650ff020cc7c077ff422f1c8f66f81322de9edb8d66159e00da9966e530a04ec3ba1f0509c08abd1482a8e121ed997c4606bd86513d6785c783e19e89470a628f0c3dc8c7433bc39e77c207b58d52635bac4803a0419100b5af326b48ba223b2a383aafe892b3dc91c4ae085fb9504c71bcced60385dcbadd12045af64d72a6e76eabaa148c7760ec8a9890d56e8bcf9943f509caa994a79c36b946df770ce6d83e118637dc71e606f3955414742c28ccc5bcf8a91ce5bffd416f41c3df0bf61d2c4cff141ea50256b3a90ec66e2cc85cef72a15f6b22340dbb88819593588dc1dbc52420d0524d69b2d701927b7524ee2fe4233b3293ce678fd55db944d33ba72d92e1134cded71cbb86928d21b10df6b507b9157f14962426a56a4f6ac31278b63908d65d8e5b8d571b37b6e7fe2a4998fd62b42f18b39032104abfa86d8165dcd29807a6fcaebef9fc1d899dbbeb52b8f4716fb3c64e666942a135a74326b7a38c459843fa1c6826b529835728ddbf48e6950817586474a6200227b4a4e8f1d4d7f84fcbe070bbacd135e5da6d9c1797a30f23f35616a1809c5efb7ed4909f1187360845f946c451600d3aacdf99bc06fc1452ecc75316ba4452083b2db1dd2f728ebf5035e098cdcafbafbb5fd776f31035bfcf99cbffb98d18356c70ec85c19cde9d9d2c600e53db2dc11cd05a3199b787bbc5c2f28c43b19fcfd594a90687eb5b25ff6cd652d86c65e15c127798d1e8c188c64fdf99600643e8d50d5d9fab9945bc4996db0a911f14c2709d67d82154f49efd8ee14ebb13de02b5327175261e9a92be199e1fea5cc4e17cfaf7334a2a3dd2fc42d9af209d88fe69886700ef2973b0cf9b48e2155a80f9e1c40fb690fc673b3ba4c398e818464199188e288c2178bdf6bc0ca7cd51358700bd67521cefd874d2c78ca445086644d121ff2d1c23d4b22f64d5ed35f0b6b1860f4003f20b76fb99fe2d553f700aeabe7c756bbc666282c9a4a16b5103fd74c89f5ad814545a1ef8a57e4c0573050130501ae8fd1106dfd435b8a5626133a48acef5d7550a2393e40b2b870d646dbc603cd54913dc05c69e96a39f2561e0aea7305b37001641db08068479e6268fc5525279b88fa7e103c9fe13b69e3e85bd53a58623e205868d8e10a4fc7c644b3eec4b835cea724b7847cf2917d7b3948ddc15bfb4034c408ff936692d7abd0fbb9ff8abb84f1083411f9561aa7c28280ff36091a76b3cdc38d8bd16a7768a6787ba49c55be8a20edfd7ab579547061cdb1882e476bd1d44c2381c57eb38034428b9defd8dda0065d96d85bf70f57d443f7da44b60363e1631e408b7ba1cabb657a5fde440fd7708b2668fa32dc159c0708f7307d0ed794f037e3833108bbbc70039dfea74f45bd3e3bf100b962d56bdc995068469a6e49ffe0c6713b5070c37e53a723f13af8a0080bea82b139cef8cfec00b968022be159432ff08855da5dbf2975a8a9dc4350069cb769d8b0878903c17946ac5c651fd7abf35dbb733d41803363b713015eca685f05521f6e09de532875513c8d9cbb129151f229f4e98df1f89b87c049fb22f15e90f95eb4c61b73412d1aafc8e413b11d3cbee4d38d8b94a322f403262664093fbe67610634357de0b1c585f587d0291424ebb74702fa2333261b7355c0bcd12937c835fd87dac2622693623007b02cb48e8e3891f908ddee395646506e8cdcaa61d88e6e702d6c7ba6a02d1c97ee11e72d45e1afe2980db98e8ddbcb61921777fe9709519d7a23fa22312238249c3948b7764096c1e7a0ccbbb0b972881b7d11f9e8baefb2ed3b18d8d1d40b1312f6ec02d320e2620eb49649d9428378935ccfc26393dd667d054e0275d823670b9e688e2193f266a9616d1c87ed99a2801e8fd6106149940d2080195c181451300d768de760ea47d23d8f97a4530f4445917e78894f8bbe0a6b72f8f4cf03589b54a88bb52a2171d6a11880754452d948bf41272fb3accb8da51b0b598f063cbd3a06c29b7dedfed06af87362e92996788137ab077e5e0f388d3f3a9a930918b3cf05a64dec538b7d227e44c13bc9f436500504458ddb9506ca10b48ca7f3d1236acdf6068dae68de5911abb77390e98b5a0e56f076bf9656a77d6b78bd60558a4c247ed1ed67a71c93c40cd41c136c4af2755f7138e55e9d2d556cbac853187ce6bba952aa0800224fee1d1769810627c9d1de15e9092dc66f28d7592afea639fa208b280a2cb5f4752ef7bd6522eb363a59d45197c58912d7e6764ef2058f181106dc5ddb8d23831e75e453d96d6964f720ac5aebf089591f76a299ff4b5716a04c3973ae920931c52f4d5135387a8b3b3fc675e2cba8e97f5731ab32718cc7b1d48e778966ebd213e8cfef6e29913049d030337e809635f8489c52e02ad899b56ee7d74a53fa25061466cbb7f7372ea3d2dbe372bae36d5294fd167d6aae0793e20d2c4901246f6476233e7cf5994761923417fe71449db64310eb0a12d4d39a73a5aed68e0a0beee14163218b1817f4ec512928faeb99cbdb0ac81316de5b13c55c450c720853fbc617f7461bdd5d8e059db8d3af9f0ccd03ca3ccb0e11abc1e9e327759e5d754d82cbc761976d97d0475c039a4cb52a7b5d88680dddd085fdc48922fecfe3620b58238ffcf53fd0accb39179a484b43e130a00bb65d60b31834ac52e5e3146a8c178b9c5667704c9cc6898ab535bc2156c754249727f9961701a7a6c1f683cb3f5717a4c8544a62a9c54c0eb6464972d428f70364ae487d2d32bee648bfbbce7934d695cc32f2d16cb40f74ef6aa03bf380090fa367e3c23441f42fa5c3f1ea9706706a7ae6eac05d7f957550a911d9f8280590bcb38a6ac0629be1085f50716837cd230e673828efa02d0392fe7fb72688e88a42699ad29e14a5fb280f31439d198041e0de73aee384454920604759eb4d20e0c7ca482da393effc63fee9a38620c810bb76b241ca635fa3916c20c4c4fc7e31775898c60929eeedf5297e81e557d2585fab14407ac95e9ed4a81980da267d51e9d9b6b540dc48294af1f2f3a016d6522cf5d75064da45aa772c31a9eeb30bdd150453178882fca1bbb0a5a01e7b3f68624638e6c8b21951cec89fded0e3eb0ca56a19145d073bfbc490671cf20eda5e212330fe13c4b01ba514391e68c08e2a10c0be37da7d4754c117870e62d02e8a3a8710c596d57070cddd7ef1ed528ca8d22591f4acc96c5515bec8a59f551327a6b13f2c769ba786dde254485ac95f116b33e6ed2ea0d3120345caf5afa751b1725b105b4203d3c497acf9d321994cf894e4092aa7088db385ca7c128a0fe79bd59451a339992af37862192f166860382757fccbc0598ea63dd1c1188ead4dcf73ff79820ca228e1b9505bfd712a57db24b5b00bbab28db52d6e159c30988e210085b1125affeab47987aa199fda70867a2ad95eee80433ec61f6a5126db9321b68ac89c11b217d2500c29656021b8808b420e6cb096f1f539e8a26b82ec60aba88ce04e31ccc0b296db4b8bbd033fd26914d5c0f70e956b8eebd44f4eb2fc378500eb7be6d665695372131690ff429d689edd14e8f6a55a2655584f1ea6669383502115387d23f569e0c85f94f4853893c69b49bb7eacee27a5b921e37573a9806f6a0f1823479cd6dcca10914185b075783745eb51da51330537bce70908ef68d36b2fa09980166601c7a8766690bddd689fccd2deec800bb789c890203ca5c50a9aab701790787907211eb495abf6b439f027e455ab6dc1cb76ce91695b539689582bbc49986248935ef7a86f518b249091177999c6e09850c95f2dae16f43a6df8431dafff45693844bcc903c33df8e94394d5ba882a42500934fc3df2e8cb68d305d7e6f02b2c5abb5f4a94aa2595bb1cf4edf576dd9d47bf084b12125d3383cd64daaba2d8240f4a664821c783393b5a7ef44e0614bfaf7887848b1939da0315a1bc545ebc023f0ce0f83dd8f2d70ae4750ef775a613ea85cff1f5cd79aa501614ae90443bc4c4094cb76919ee255d462bdc4337e0e066dbc726ab1b073833530e45be84f83d48f6478aa1aa459272a68c4f6f2a31d9c183f63715c774e7eb0f1a0646ef8b87451a36bd68b56644a83b547a4d8400b84c900783fd758aa928e1a3f5bece62878a9d90827ec07530959da6ddce997bd085ff452618c871142637ee1e9ebdbdd0bd2413a52a794cfe5e326d7316e0e81a3d9fe658ede6afc3b08c6b5ce809d0e6eb9cee30b5c8eb92f6cd4b1a7536b25225cff1ebca1935635d9470d44b6fbf0603becff4b328e71e32e477452c7a98fa6d4e355eb9d005f4830b3586e6ac2abd80eae6cbedbe09d959476076b652b5c5de0358fe02d99a80ddeb25dde5035ef34e3be021c2f8af484d66d69b3df09700c4f8e06dfbb7e0da7f3b26ff18d2fac77114921692a94f449ad27c4ee68e9ee743a671df7f29577c042953e466994156196c71ec8c411c27fe6ff34c240f55c0fa2c2250bf35bfc5bd890fe07d544feefa8044e3a160f04c234fd2c406af1dc38e8942d3bef651dcfb20aa1fbd3f216fa0ee37ea9381b638e44d44a94eb4f1e773a0c6dc31e6f6d4ab89b4e2744f0ddf75d354ea5308d0ab248a86b339f4c367cfbef609c33e5f55227ef23b23f0f20078f2025f9b0a592ed63a87e02e0d26f838983769d85f5a8ef2fa7ed36335c1c56f53d200bca76113548cde694a95f2b91588227aaf9044d72cf5662194f224b4b711e645d7f4503e876b929952df92043d870060c5665e4dd0abcfeaf46d34135b6e6c0852cf29e69e45a16d1b699194892410a16e7c780a5a0b3a43931728a6e0712f219cdcd16e908bb56bb84efd3c6ef5dd55d4bc40263661541b8ab0e06c0fb43d73f7ce0b8a6df94ba9ea3ddb3deff46fb1964f72a4236ea96aee91fbae2cfddd4f106dda9a4787f1922b58006be20453326514bba7a0dfb85e9e3a9608a75107541273d15fec60204bb2435f7ae011a46cd60e78193d18e67ad3f9b680d060384961f6c4bf1e76616dc00ac2552e64320aada433a53d37ca0275d83ca411f6b21449be86be767d2501dd2a0c36718d781505aa894330e446a25fe46d77b963b83ca6807fdeffda1ecf62fa8ad011c117b9afb928af7e9d745187f593715f2a38b831e64dd0892aed216e468655372f8c2db4e5e0e15bca2c7cdb4bfc86a466a83878ab8f3d66be73bf29488173ad1ac6577623cc339f348c986be342e437490f880ace05a3bd556b029733dad9671dcf6b57824329a422b3061652585b95dee813043872cee0fcbf2b85e599a078bae2460a011344bbcd72a9eb0eaf13de0ac9c3e5c7033ea9590fde72ec3eb76518ddf077a2238a342322cf7315b740e76a10989c42b63c0a628ba27885a790d7df916d9cfae7a707e2a83bc6291bdaa119636a1de607dc383d5c2b7a6b85b38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
