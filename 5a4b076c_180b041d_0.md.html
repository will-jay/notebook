<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97dc37818e019a0f8367d866cb4b445e54077797c8ec71aef46632fa48423784937dbf9bca6dabe42eedad91bf658093524e34a80d988b6f698e4f562d91a72f5dd3694e777a73ac02d08ec236e3a5d0a6e79040708724d69375cbb5ee0eff3664c7ab4151b428ba34b77c7dee2b2f4c9c4bc0a95e0f3855e625512228baa6e2e39d4687899b23552274e4e45a5c00c84731b35db046aa96cf9f979a9f1ca07805096291259eb8d287e0aab4c817d4e6387fd5c531e93e017aa4f40b0a845c30e1f0d28848cd863c313782b5f3697a982961eff4a8009e1a43b0b13a0467f8289f23406a71f9ddc1539dcc50616827f316920d31b9d96348ab728014ff29e63aa254d42f0168ae906f93ff349b7df3e52a8f30b6fd1bfbf6579497f89bdf6ce4a3978713846fac41f6f6cb714cd0e7e087df4a54ab4e5ac3d2f0a4b560a3e83d3aba982618d2f0a2034b533aa2eb021c23669015633941d097ebd9f3ae04efac2c667c2c4c6b80b1f5b56e57ca01a987ea0d471238ed1d9f8e4a56f4ed1cc76030cc0aff76c7551a910bf242c54defb49e246ffe7f661e010618488a1c53041bcb44c6f742cef52a0bb3ed1c16719301972c3c1ee201373ee81adf5da44df308b859870ae42bfb04b6083798479a7a657159592fc47d3584e5b46439c73e0c8db87458aa832c83c60ebeee1157e826fb91258129f4b2ea0e701620d81688494ec45c4ac96ae163f8a30afe23994736c38fdd0460ca887af63fb16386e148adb273cded08227f8880b548d327d4bb11f62136139d12cb7150a8cf2732d20abdc2eb631068f52ff82f92ae9f0a3a39c9626c02bf867050ccf180daea994ba01100a0e9b7defdf15c85aa3898b2c8efc92eaf1a02c5081dbcc5efc5051bb33436a93b2f8f02891c50d7e53472f533571b07a101f7a147ca0d020c6f6f5eb3366f2861439f2326f604b65df2403db2352a56e420d0b1922d655a7cbeff58d7bb90af82f3c9fcab7706c304dafacc5ece010eecc72f1f56f6b864b4ba02073fe775a852d3361a56e55b430dd594a7684c620cd07f9c417f948a8a67fa2a24c006864ed7aa80c49c0de7e78f55202eabc9d065f280f014c402e09980bb624699aa3f2ceaca18055bb8c92925cc61643d819614acf8b3529560a3e8d7ce40eb55aaf92b2028fb2a9f1ed554183b628e05861c9c5ad082c23fd6718bb9205d28591a5bf1382df8b9c197281d682c5aad56f2c933aa68a4669b798aeded58382352a823c17a968710dcec41a458b8d252dbf6cee1e10fc4e7b72d48a673d851015968b3e80907d5d371123e93ebfc5d54cf7cac376f6aa553f9f3a3348194d5799e1e6feba3fd603e61ba21dea46240097e7682940ebf63d80e4e5534dc84d8993c48aecce1450c659c8acf7002a90eab402965f765a380beb3a8e5a6fde699a2a2809331d5007fb4359660640987857a9c21d5c9b40159c033668de062ae7de054440b672f7cdc2f22d98f9c418b37783aa0d5b917748db22a363fbc56916d1c915f3c2ff46fe180eae572da92bb66e7d2e2dfc3cc9d867189cac172de815bb3f7d8e6f14175fedf153d97451fad5b32a77dd93377e087f47845f4dad9b2b05f54cf400b5346c39a0e368600a346dba9cf94c22686586977ebc0c096c06e9fdd4a3910d7b85e1a4abedd247b2ab12f7ad6cdc3c4a7e3636c6abc20d90f07220929f1e40ffd15e522d995e6529744726a4c77c3a6663de130051a99ffbd6e81f38f22d9453a3ca9601d820340b1339f59154c495bacbf56a22e7b382e2cbeadf92d9d23ffc92afda427e982da77f870440186761f33f2165da9d1c09935eccfd219f343cafe98cc504df80137e44e64c937f90f6ffaf9c6327d200356a5187341a89da8a3af168346743b98a0db58500829fbef85229ebc464f2a420ebb89fc9e2747b06b13747d5b3670d9384dcfa3212baa6275086e4e5e763ba3eb709f95699dbdd67927942ed40e5e0d3160e1f75f7ae5e967ca2c2418f574330ec30481956a47bd8c451021f7f49944913b933305432550d301b4776d1227475a48f352aa5b332295e288c1e9f9a51dcd4720b7752c7cacfcfbdf801c1b4c8422cbcb51e5c61695761de491b31f8c8bf2f33df192ea25e265c5aa6ee296c9b07bcd3aa80de2bb23419137fe688cd7c17f299e197a3fcaa7d2b9b34534df77cff0047a89fc6da056e5892de8ce465f1ece1503c66fb83a5db28ae651b9c0675239d523113678a9a2b4bc598593fdf710c163be3e24d327285e070e7062814a390bbed66898462f13bd972fee45a8a0a245b27bf23d7a2493ab7bb20bf8ad2de59f25c63d13c7dc3302bfa130192c5aacd6355b3cce3afa36eb662bd3adc56b2aa509c2697630826460eb6e3a9b78855054929f729ec897df71c7712346a729b1968235381c6f9f09eb3c2c7f9a9d96cb16d24c45ad1bbb6502f12ea9c88bd5f823f4a1eb77b11b28ce23078ba30f4e213aa60863f9022f0ae2455c48e8ef6d9e245fdedfaddb2e2612b58c08e01df5536098908de5824ac47c34b3d52e251096493d6e330f123527d4459f2347981b737b8b1f37c3dcf766e5e23c5e6b673c34e27415f5f07db98947ba8b86d25c39848f40d083d4fcf121a4c6cf050a0cc20dde94337bfa0cc28a2d26d7e53434880aff9dc11c6caf43ce5a88e36c1bc147568fc318cb15a5267cd733247eff14b4c6bd49bfe6a83fc4847ae772592a6826108e6ce1bf677d7efa423c3158e20e1da26a3bcf13d41d14da2106c6086d7ee4e722d3a7d8a70f2c629b400e8e87f3c96208105648ded1597f65fafdc6c519b38a56f052a395ff9d2da003664a8a0f97921799a93c9033cf81a4f0c6e059dd286d1cfefa3263d8b03388e9a42e2ead0d640759ec1b9932d149e9ca0cc55d02365460ec97d3d809552d346b668eafd42a2690bcb90d613ebb6f8e9bddba6b638bd90d4ce85819b046834aa046080270b0f124823abaee3d3bb720db8b329ad200ca708aefe88652d17d23350ac9d3e99a41a4b7fa840f264c84769ced1fa09a70f36d04931fe49a8a5a818ab28efc0c17b84e70de877dd96e99ad838d65493f669d09696b3678541f2d46a456192cb4bc376fb92d73873565fa21e5138241168a92c264b9b2408445efd1eb00cbd2342f64e3d0c21235060f0cd975d18076a8077b136c5df892043580bb843e5dbaa6639f1f543472241dc6870d2fa1ac17a1369fad9ad20f3ffdc9222d951f53f1b0d98b0c8a176c9e9b49c5c7013d93288af4716d7f5a6645e6fe86d6b30eb6ddc5464c6aab725c200c3e92b84b943b524ab7fe89cc2e3b229b610317741519c7b3bd03c259caed3036c21b905c60bd147f23e60500a1b6e2d8f8d03dcfa56d01e762d1ba5385228c634c681715e311fbe32056d4ebdb861395d82f1c873c48715d1b0b1133e1d396eaa189fd416dccf686ea1e833e0bcda538e96e638db326079e1e423b9111d27ad86b725462ffa9f65915dc6bcc1e0db73e03702b26a00951aecbbb9fb4cd913cdaa2f195551a88a5356e9efbae9cb842d9c4589f9587d5972f610340dcbc4801130f2ff287c517e4d946843f6c10d58750758fd1e8586b270c316dddedad1faf87706eee31bfc01f954e4714f60f74c8803cfb934e016db78e08095d01f0fd1d7ce49fb1a4b51e352aaa2866587a04e23688401866c20ac552b12212c78d3b3f0163aff4c2a5a29d6c05177fb2dda12413abd1898357084a943d5999a874fcf1f51fb0a7eca069c05350f9297750d656e3d173da7b1a4a5b04d16a7277261c9dbfad191e7212d1b74a22ff45df1c739ae459799901ab17d4b0b230d5c6fe5d27a64c86c59485b6dd2f9516f2a89b3d3d7c08685a4254d0d49ad70a0ada93a98edbd6253d2df280098d7cefe47caa5138362e6f8844fe2ac9f164bd9ce9b8465b813bb09c46f56baeca478c11e77fe9c8b92ac154a3908de01d19b523b09199fa2c09271027db89042aa2e4249275139d16518729f4f4c2a0d1bb7df703b63cd8c96004af873f71c6c3aa7972e5521bd2cb7b9991ce753c3cbc5d39bc4c33d6d070727194c6a11a60458dd4c8430f2466c47808fed4ac4344cd9de14f7463e4e5ab83c5f5045f64984f739dd69d7b6cdc28a85250260e101ab210ad78563d8f79109964a20c2cd4766170113adf6cf7c719c217532d7016bf50f22a5c8685ac2140891970288f0ab102ed98241e2399608630b30697965e36de08b835d2a19f42c37a1b4feef8332601b6159a0a98106e6e523c34f11ba6d41dda2c8932b56e72c6eb2bda5bf6de075cf6e5f6425a5cfbd5fcd1aedd93e2f60917da747f4bdebdc1d50f9cfc795cfa9130451f21f70a1593d99ce05a921eec16e347707db1a8c5da7cd0be3f4c7a2a3690998ac83799a63403c52cbdfdc12c4da58d5c9d5353903fbdc197fef137a2c50acf8cc99182de3527997e3ed5c994e0e5d3f59b5045c200aba2d4dfe30d66d4bdf09a1c08427aaa3e77aa28c8e38169c1652504cc164f055c548f911e761c09b49ef4aac45198d6fc328adcac01363ac32ba91bf5806712cd1c6d8651b36a7adbe70e8a2027fab43f968bf810a979afbd6d1c9a1adedb92b9f6585742d897ea145737519cb192c43e5f8a7ecefa6f1b932b23aec2defbf7876514e48f7f525a5ae9f295ec824bfa92dc27df3f210a3c4c48ac0d85d84b4fad1a8dfbf6d9748cf0484f7fba01085eb4add0f4ed464b269111c9b397d004e0fb474731a0ee42ec10e992a4a2c1acc84a345dda1348dd78ce7ecf84d7d4e2d00ddc6e206ac1f81a4addf646e6108b4118aecc10e97921aa3b8c72c15b905c55c21074424fcc67a1b2342d261c3c18958d959c5ceb95c83b02e8cced69a0a2412bcc6a067022ca5549c6814753e3bb0aa2ea7b28251dcab55ce0bdb30526a9b1a057e4b436065f8f54120a8dfa1461853f8b22c1c6ee12f32fc17a16afbbd294f0d04f58a6f598c224175afb479185c7d5674ce41b30bdfd92831eb4ce4a66420e07a8c918aa571868841b4a92e91d3803ae50b4372b52c3d3d0c4b22a608252acf3bd3af67c3da5c26fa36727df7b66a4a06b7ee1b43dd2063317018d113df95353e50cbf097b177532055c29498f5b6ebec625ae46328da04c62c22458c256d81b43cc2f417ddcb218019a789d8e0f9a153d1fb88a0b9f2a9153af08f87de03995c2a4a2ddea13f8ee5df3a468444211c07da59f07344d348b07104ce61f55a7a071ec2c5ff4214222e4a782d0f3580a56200c5e4733b22a4c148ec9c5820e214da1cd30343626729c986b8f48a7c180b1fe42227ec416867c775c891ee673a21bfa09f22b242bd1452bd0bd1c85f4a2bd2f61fdcfbbd7be93713adc03047e9326c634e9782342db2896993a030bce24849fe7fefc19206a91ab05e014f73b2e0c9b13e34112dc8320dda7ec18bc4f24dc52b527f50df6767548bc49ff0e8841cad4ad7449801d59931f2c086c0c948fcda22b3bc81bc7111170c723662aa693acb8d4e9bec305aece086595d6323da80bf5fdc4fc6e34e9ee6b2dad5c0bc940f5f312412e06ac4b926c55b0e37e539cd7ad47fb81bd348ae85847f3e4894ebc67b64f41b5b3205314464a21f2891ea519f55541f531a749f8d64b017a3acfbb9e7cfba718027476c4260209247f812c43d709c25bd4da361dde00b4efca889c133770f59f2f1e2a8046492bf0a581d0643241f6885c20b307206fe6abf035725e870f44fae48b27d63a40b3feb3593cfb87e3b61e707bd35c3ac9e2e16145f0680c6574ef2153261bb6b91e2991a333703367966998d2fb082378f6e96f3f7805b3833e7ab4a7fe86c5bbed29bb26eb4ecfd3e971b070de1a6ca7ff57e82ff5d520503e90c9c2dc6b79d0b3733bec66447dfd8132719109b1627ddf636dbc8bb0909b22d02c4f58ffdc9267a12943f863a64bccd75373fe05214f0e838ff0576784915a357431cab7bc69f328efb455e5ed1d1231a2599588d1ad065e28b175a54a3b4cd350ac0689e8c84deb6dd74f8a80d5e9a431402c8733be37f91385abb695fc505ccce5b620d4b53050dc4d908a76bb6fb5176b95602a03bcbe1a6f67b6711527d1d5983ac7ec7cc0126f56e7227dcf3d3188f8f53d1ea697e4a45182e5f603fe9187a93498461e129037c587a7494e50f64bcbf8f8538ed20cdfadb5e3e46db104838f211546fd4ab872f7893dea1c000cc753d975d1dc17f3c20983963777291a1a3514ea68ab6cdc71e1d6336203f1849dfda0bc6efd51c8be67935a13b8942a2b5da68fb6a89f79de27fa72cbc09a62da7709455bb802d2d967b73951d28dc9ab971eae72b05a186013236fe148206801a214dcae7a37d4a206c41214f7d9777606925d3c6157b2b199e12bd30335d9ee4c9b8470b371a9598981d60b94f943eb891ab3a3e5a98d74603220c4d1453c7547da80cdf4722fd2dd0da05aa2fd8cfef18700f1a9cd0a18e581c7b064a1d9742b193a8445d9864ab2b6e8c87a0383b8009616c5f55a34658e1939bdfb1142020a33fd0551386174058aa15b39675e35d570c0cc4351aaf39735deb8720075ebd8cceb4a758185e5447c329d340014243af6dc642b76affb084ca9694ca7151b710563bb1281414ced9ad78209f8c066a685f813f8587289099f8b566049515a83cd74bd1dfb366e3700fc139e5cccae39bc677a9390d97c9bd2d33978243a097fdcca85fdeb969a1af45b6e834870922f1bd645280cac9f8e2132e17f993ae0287bb87a684f9f2e2dd51b6b58adc06b5976fbcab14fba9a6f627abe2f1bc139a6eef552d995f63a6c7c6e884597720ffb197130a170dd7466a6bc405e93c6885d71ff3a4d6f72e8d29bc6b1c7ed3de8f02a57ecd76e06d1b2799c7d8f1a45bb32c6c08d8f137498112ebbf91cd5faf20c233985604b4656498e4800ae91dfdcdedcbbd36a3fd863e66a80700ac3b65b751c963500be2d9804aa3baf919221f32bb7b1a2af3b24ba306c060dfb2531928e45e68ccf31ef4cd98e603d53b40b77a1f8e76b58af66ddf1ff6e0915d019376b01f9cef8e7195efd699d8b3785a37cfec56ceabb150afcbd44aebb3e4a4799c7804aa672929a5f379b9b20a2198c9d93a6ab64d049900f7a7b62e1541cc9131afaf0a50972cc9371c715c65397fa7d9609dec2909cd79151f98c2c14ad1a0e8edc48f938dece7623752dae36b582b6916f3fcc6071cfd45c811d39250b2b6f24d6c7cf01063c42803ba0e18f97242219663b2e15eb390942e69a93a274c401c903803a0621f6c9bb4e77a4375fc288439573d470372569e2de1dbc7ae6d9c9000bd216256a901a0b570dafee4ae2af6d4eba7ddf0a54234ddce70eeda4eaf99fa2ad40f8dfec65a3535d36d2b31befa50260196da9d4f783e95965f21cedbde9eeea506c792941e38fcb1eed773c3a7fea0bbd3de5c9ba21bb850989b1feee37b176f2a90ebfce592cfab54a62ec5fb83394815dd5231f03cf443cc75e886683396353cee7c5e7051b74b59e08207409ad679cfd0c97204bcd0d2100124ea0424a478854a874aa85f5fd21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
