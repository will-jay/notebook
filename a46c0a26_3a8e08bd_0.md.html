<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6090f06471ce7cfc5a4c66ede8c8353b4881dec0fd12be20fd72ed4ce345b9e897070ab5bdea4417c797a7b93de916b345544237313c117e640bf3dcb8231c39e7b343a6445900ef5c06e756da6101c030ba075169c2600619b449dc6f37021a023fba92c0731baff91c10e7c9259d29b37536037c08cd07be9f37c30e74dfe37bab1e7bbee6d897dbccf8d6d92a4f0a6fb1a0182978809a5a5bd949cdff7ad9baba60b8be3914abb6785b08f3ac76592bd7f68781508a1593a81f4e7f2d29aff7a0f7695f01aa3d90630e6083c13909fbaea42d66e1a95e7478de486aaf6283f839a62bc0c0a61c465a6a068a5ac333072508b99b198f9a14271d3cf5b608ad1f1c314c4fded9ee9eb6bc54a2ad93cdaae0ff0249b1051eb66743a807a1d0939e2b202d8dc30a454f5a772de83a73a68953fae132d6dd896266fc1378481984cef96521ae689466f059237011305ec517fddea04cb9db67836dfb3ad8bf74df8cc9864b21099e04f8b9375b85f211a9891d90d48f5321361778f4a2835cfac337c0fdc4abd4cff357f5b02e80c1ecf67fd94f21eff2bae0f832ad75c15fef249e05cc5f175a68279d72b7e324f8d6396b547698065086548fd4770143dfc9b0dfe2ba3c1931ffcf62d15c20bf417c393ecbe0fc22aaf1c88da9fdde1c09f6704400f59a768e9d816a394499b0ef03e23b97f651e5759324f6b91aad10aba08ecb834ba2ac856e491c38e520ea16a0ea4aae19d1e2ecfde9615ebc16d2da74b65afa6548642cbf4adf65dff751c5e7732e180d24dec6912f693db70142bca57be8ac9e034ff25a2a9cdde29c8704055ade76c5a6a884b7830cd1968e2f5f796446295358ebd1c0099d7b7afe86ec534eb830e6dd8c06bb586a7e25833c3d20848f585dde9ded3869ea2bc5da93ef8375a2d42a12db8bd8db1e1930ed0d25a4068034c552fcc2bf90199fe83399dfca8861fbae36dcc1a2b0a4bc3cc0ae9dc94979f5af49fcfda227f49b3a14964c66aa6482607f0f43494d88120868910da2678c2ed5b43a5a648f82be9095e31f012426c856b102add068e3703632ce3366b15d6818d2ef78b882ed8ae14b2f79c065d48a4e5f33b4ebd5a24d8b81299ea73d1f8692b94721a8395902fc8cb42cfd9a014859d7bfe1ccac8b9c122ec9f42ca024363a940043292b36b23eddd881689008b9f8864831ae9dcf9051f1499b71081f28c3a3217ca6ef07c66a115988fbba83da1951b0d5b0a869f0155aa9dbd632595688104bc0b30bd620cc0adc7c4d09770a7c43d49610ba607f0217acce1bd87138a025f979e8043c369b0499ac8b71c608dac2e586679a4bfb8e6ce3655353c569f2dd2424bbdf2288bd77dd01c66f3e31fba672f936befbbffdb27a0a693dc34d0eba74a477f9429d7dfe24565fe7c56dfdcdf91d5abae31ce36cdb0a0fb914bed59e5c583c8c59f22156110747d4a2ab3cb7131ab242fa5fb0565d46ecbabbfe66a94b30365b25f6eb703bfcd4ef975fe13bc6cd313a9f407ee9f3135a6d16620668d8f668e4bb5202812664aeaedd2e115d0e0595062e6ae3e6147f41c12ba444add18a14d90fc2b7fd5219491a78d4f4385cc0c681efa7361734e0c394870c792863fad855bc13170b1e7fde1f1b93fd10067fb28fac69ca6deba71e99f87d5d59998550a4099fe625a80e89178cc696325e2034ff20530f675b48319c0943085004ef6c60b25fc09f134fa0470563170e48964164000933ad54fedbdcce805bc567c4d93d4622a515c23868ade091f24fe1298f8de00caf4cbdbf0aed17f67ba637f06eb290ac7b7ea018d12d3ccaec54cb27066910d08c91be2dadb471ef4708cc05cc7611f0bb7e0a84f3db9f4616745844afd46eb30b09ef575ea2633253538b2c1ff565290507d94e5d3593b3b272ad229f90cb3addac230c0405e2e660dc2c3ef47f97c7d0d25edc99b0c7b334b6f36c923cf203b306be4da9b71650b574f6e29c5b6ddddb2e8911ea71f7b7f463728a70a2ca901e6522aacfa4959ce444f3457dd3dc1565802c33a0a675363bea2172c1e5e82c393c3689814073458f7f609401e30fd0c27f08c39a4472995aab292b5c3bfaf0b13e2b49f257bc90446b95237a6a5716e08af559544a2c9fdf2676ebb91b4cc93a1227c2c4c214998dfc714717211de4452e72f215a990d6fc8071a88c3869cfc0b859d0230e0122de86b65c7c4a060bb4a75a55aed40429c0867c2cf6a64104578a00c6c44acd42c185e94db01490d79f67cb4b804614691640a42da59a13e9589a2f516ba7eae09c6fb0dc4517b1ac955db917bd0c1a4368b08a1b79fcdef882584ec561388f68e3666c220d5223e65a8859e048832e3d87088659451d33c6232fa25b1cf0f64741b57f327e8c160cc58cdae1a814458ad0c70b321a5b934616b44460b2cafbdd8357d5385a577e81e2ea1212212e5c66ce67b209be47d14d402acaf0a4afd44e351af3f19736fbdd9f695085fabdd32bb760ba3c18ac4aca4b0408854a7333fcfed444a82965b32e07ce89dfb1bff53cb7e6d8fcb8bb0fd9541e5d10cea3d37d7ad66f8fd0855bc292a93cceb1af7b31771346af1bb6f86fc234594601251f105a2eb18966494407be521ec566691ec78f73ef1a20c947f9c5bd0469dfbef9580fd9dce6fda099bb93402eef5d7e34388b8ae1c0deb8e34ee9288ad2f7757e40a16d6ac3ffe8f847445caf96c70f91a8befb6c922e3c74982157eecb5ff345ac24d9f831da2ae5883d472557f97ca7ad525057f996e9e1ab053d8d6352b1a3263b8d15cd958d7d56b93d1e46aedd4e28e5e18c360978c28620b86286ff6bb37e8f0a7311ccba92b5ff5d27c02a4fb69506971c3a96ff75e753eadd61f28a8e5ca5b542113b74105d4e2369e60e29c02148dc9c326f9d9d7ad37ff3f13fa1b3fef69367131edc4571b645c0b7d19337af30f827e05aad837d3a5eef448744b67614b9e1e223a98e7175c97eff9ac4fbc7915dd481fccfdd6bb566cdc8a8d789cad37339552dd622d10066f99aa0f664c45eff9906695c811ad838cef046c4d0ebde1398c67ab0a2bd463e88e81c1d10c92bfd4b0374f855c04afd7fc420ec85b63ca2f0d8bd040f6076ee89cf78e399205a989b849448c91945033c7cea9dbc1cd9771af5a124d416c4c0f47237df94960c9a4c12e6d85d0268bf81ab822e6f80c2a4ffc8223da5f57dca3e9de5b7d93a144e922f0e7f13436bee521923c4c6545632f65eb89c43a64c64575dc44ecbdce3f0813492a4429580a139144a43952920a4ac8ae092ea62df60e26e0de042b6b71180ab9d470833ffdca1eb69ff8022a260240ea14521a95dd0b7ba33adf8e868a4dc7b2e71902d976d81cce1a00ef0e59aba418123f4a6fa509875b4cca31a4535e63f590b645aa2fc47d5a8da037fcd325cf33f459842176547f1572739be6c568b313b66d080bd86c5ba3175c4c427c8fd5c7a07c52037b6390117ca80f163322b8403bf795b99974103e5ae55877282c4a1cbfac878b918f44ac1d0f0b8ea95a3b28ecd7875345b19f27266ac44a8fc312458ae4535c7aa22279afcf2c44b48276808e2230f40d6256ce51f93dfb3cafdfccc0780de3c70b7f81055b51e2505677aa0d33ee1dbe91e032f01568e53c1737456bec08ab2a6c6415b9e0c90b64144a4ba42bb71f76f58f8935e23b6ce892c9b7aeed1ee21da53d3cd7e012bd452a9658795062f01f26bce8d351b7247e664bc46b1e65f4d2d56a19f1c793f4dafd853f973111e774cba137560923e04b643008ed1f462d4cdd437d34b7cdfbd7449dd4c5618af63116165b8b6839529bc2264ea8fa510aee54e01996e92771373166931f28a8d9a1cd4c317843aaf1f8994a3759a97d2de5283a6689642003e8141b2aa5b05a19d413e969efb38cdf938159cb62ad11ce8c20bdb096e72d4e4f083d8405f4a53525ae403576f24f8b8185fed7a5accfb84306bd11eda1e0db5754c8e4e6b95032939424a62b7cc4a536008b592a16e15655c205c68a01f4694ae1d7b14f413a45949ef549703f0871199720d37d072c75e0a73bda10683f19b1e71b7c08ecc01515623be719252193569d9b107d843749fe14b3e4f32effa0b06b5f275ad63050b564112e7e8897b5bdc793555a244227912718f34555b72c4405ca27e61174fdf26390acf9501f518c1cfa006b4bb816f108f71cc5286ac703c2f31cd0464a7ec61db434908166a33a39a165ec06911549f4a93403c4c790cad6f1c527c182954a4da6c6ae03e546a2f4e077b71e2dc0b10d85c92caf5cb798ddacbd99e091f40eb95e104ccf3fa4ce727fcb6edb28f348b8ec92c670a8a8d629dd1cc3240ac88fff1b92f681fbb3011d96d34bc51d8b6abe7af0473b4fb7e30a506129cdbb06581dd0b77f4eb974c37f5371199718f269798289f6e8fede7c40cffc147b5b82b6535e4ea6d4cf97e877c968e3ef67c781e4e164f6acab1a3708ee95e537efaec796c7ff2f67c42572d66f3c2758cf5a75256da1a5353c11c972c35a14ea2d28682da34a602816821032f0ade14eab79070c8238b936d99587a5def0cba5e40531cdad4d2b3b5cb605bfcf5bccfce528522469dab486d172a2776882671f55bef2c5fc33acd29e291b2af0e705d73fc90d718ba449cfa2c082f33f7202b7afef0e7975b870b183795d94d4e7de0d32e757132e9798cdbade55a37f16ef0e910750385372b2993c1d258ac2d0ba17f5cf501e7921cbe94883ccce770ed4299adc5a782f4d656c94dfd8d768029e5cd0817ab97e58a0c29b50e6e2659df21a37120992cf09a0322c9ef69b9e7258613d3ed1982f81a3350f686fcff5103eea7fb4e4353b2d02f87f87cc111ca0d4be81dc07d324b88c51c96a3e774ea1435d5d1e380b5aa8f76b55aeda38c3e9b04293897cda4c0e278eedd48f383ecd397c271e8bbec45a1263206769eec19b939b8de7388abd4e013709644f58dc1c1575cbe0eb2a200dcee2d8189501f913edb1812d5f75150fc254f04933d564364106a1a44dd2bdae5ec7e33e70cbcadedd356b2d6c1c6ff3616a4f732e11ec60249ad88ea2093c2854b6bc66fb580215249ee2b76752dfc7ba0fb8f2ed3a248910246e847ef3269684496fb3d002989db7d208a4e9d028e2c819c910080a8a1decd29f604664f3d304e4ddf3feed745a5014db2a4b92bb10ed72788e8cf7794daa7ab20ce27481370af289163fc6f83ab8a36a2c455e9dde0e32bd092556ee3c51692edaed5462e4b6f41a7d0486cabcdbf557e0024ec35a671b30e70044db30b2d376eb6717e9329a8890efaf9a2d47be9e7a3f5abff6192e0ce776edb71b03940743099d6db36accbb1240fa544cec2aae29a280d3c96d7493035d94457ac4e788827f76e7f822fb37f7a2b83ba96846e84263a27e01955b76ae885f5810cd62ebe84e39aa537544571edec83ab14499a74909440abf2830975b23751dc14759a92cba2b92552617e5a467f29cf083946fa1320f8fade738737ab08fed950a8b7d0dd895c7c6db017809313f80edce4a182fdb351d6a5bdc6cae602096d0a75f807add0f968c681218c1734f3f4ac0a052c3c4fa39a93d9b9fe0e59cad21986c0176d7d8e33c279aa7c167f174055b2233facc7bda04a39737026adbb302ca7926830d0af5cce26b77d023b160ea8728d3110034c89f5eec935f118640bd57145ab320c09b62396477c63a436aaef1b4ea6f105ee96290ed3a43c24c7280fae6562f5c09a1fdf91660fab0fede3d86e15a2e072611be2a6c8affebb8057056e29cef6fef7793dde7a79a18054f9c3eb4bc150abab338a393ed2056f478e50d2c71a371e86f15628d1f9a2bbe73ddef126f28021a099f29bd777aae96ebdd5d8eac57bc6b439609bb4d18534c9aecaa97bdaa67a4bdfc9374b12a8c00f4b454aa777492a235727b7f2cfbbe4daabfed249e5162a1de78e9682c2f42ad4d4ec87d1f40fb9669930ee6344e357c15b892201928483fd6e7fccbad01e3c891dcc46cad3c66fd29f1246e41b3fa6b1e3d25b307d568df89fc824560a6bf1b5c5b982658ea4692e01a384abdb27aa5d7172898c43c0f35e8e3e633e476e0849e79b4975d682a0a6c9a3c5f9bc1ed1ea667f3bba6e32467b145774d41cb471d88a5a5a2d58f585a98a0d104bc66e2b9cb4652cbf51c90cf562dc08814038fc76c27c540824ed274e7044f32aea1605c3c6a10983ca4f478957b3084795977938f5a160806b9fffbce9d9b7b397d69f250c71119053a49ae7c60898c6f625d87978b22f79e84351c743aef23732b16effa1af78c469c969f514145b78fc585a0f5939a72967ee31a4bc99fd435d2753a5cb72c27dfa1a9a68c81c7be3f74815b88918286943bd3db026f50e2a8660bd56cb5bbfbcfc3478144adcca748bc5f3c61d43eff511506e367765248f8ff065ba086988e92c946a70f80959fc431f4772049c7e7078fc39ec45f5cd9da51d8c5d132e87d155d4add162e82b7bf7cd85d15e4002d8b67259c84c21e4422ff04d105ca5a861f20c3f8010a4bf231604b620e7126fd70af2cb48030cf84187c27eb1be5f62940ddb86caba329b45099649596016d4583892d2dbaa6dea6ab6600abafe29281634b6dc0b88269dde5473a38fbf86ae5560e28ec7e1a0369a9c5e32274772a4b9b0002a5901d9cf833a2249ecf7d1b8e2d7985edea93f7a92afd9b6c88b063ec7341c237ff2296e6edfc4928350e42059ccb9648527ee34a282905a503fc44143d2788f68ab70cd205430fe4c02f5341c987dabce2afc33a7ce69e10e886bbd26a7edceb2d340487c0fb14a82d9a75d9d795e8da1c0fc8bd2d1be77e1dce90e798e02eb42eb8b8adfc49d492862755c6821ac16f4bca0f4ca2c919103746984e92f25d46f2fb719b0b348a71cf18dc339f4084d1434db028d3ae3c853d558a10904c1a7069abab8a4c908196ad8a87e687716f8d20210fa2009b5891d4d46e20e136dae5e2f6299dc44daf6c922b0a9741a8d39a28fe91be4d3573a6035dd810454f87a7bebd22a33c7879dc1047d119e19733d6c92397cc2119303ff8f757a4a2d5ec3f991d9d4615beab9b93e060f6cc2aa12ca2b235119bc9e9405f582b00c69f15ebd144d223f44ab41e9fc10c733a40c328bd1397339a2694e722aaf931f43d882acc28f29358bb5b8c23a1698cf3fc3c1985527f03f89409f3e1fc9e824aca489ef80c4bd33ebad07e046c5f329de7d49ba43fe759e41458c349255b9a55ff53f89e93fc88ce049548faae8bfdbaa64b08fae0885224b49b10632224a6e0be90a7edca0dd950b4b405dc74b6760442864f91361a30c3ebdac6ffe40254f7843d20bc60c5da835138f10fde8ee71fa2fd366c69e3c48d4fd45c06f268e1d541d11a02b9081eb21adce792c696064f85dd88c5c8872a7405b6510edd4e12edd429178c17fadd3b5b00c96b281014c62a083d7ae9e6f82c96e48d482cdae949e18432d8df2d2f6e59c4d1339da3b52bdbcc7a1f6233cfa0a64b3f70d5bb1b05e77a17feee219bd667367b77780b8b6de1e21b69bca70a0d570e6fb9982d0bf55c16d63674819d43787056a83010a74096439c451e027415182e337a038f9721596527a9bf99473cf83f3b7a1cc68994ebff858c193f9a81542d634704ee26eade27971b9d0bd63af39d23c4102644bc6bfdc608d21692d50416c425ef4edcb1efc790951de31ca489e72daa3dd4e75c10fccf557e0e88877dfdfe081f9c76a3eeef79e0f832eb14bd49f0efc3186ab2473a42dbc453a87d9b82935cfd066677a3f686b1c7624ff40c2b0bfedcafafd8a8bf2a01a8bccdfeafc86dc9a889149527fb77ddfd533ad20e9880c2a8dfe638bdc2e365b8c90e31db5e7ae1ae254bbe24983f9e012970a1a19af952b68644e5fdff4731b4f4cc16857dbe2054d15c8f8e7e938bd559877a4beddeea50a985dee1007fbe251963f624b33468b3eb8532445cb2d1281af7e6be379bf9336fc68d85220862845ea196eb879f05c503d8d1a17b32a52639dc8d676e95329ba5a2d161a48f97610af09f5aa26890e90b2a6e024b0d239df130b850aa3d6a90f54d6868d009f2d269b06ea6c4023c09cbe1200ab08c684998ee0ebab780b0755a95818a24225a8d239b97408c55acf473522946bc074f6be09f949b138429c5b8c322362cdc0697e86809b04c6dfda6c9cc81cac52effcb909e4c624e9bde5f04d1770aed1c824049711bc318ea854c6be9276aafafe3b002fe6c7f74b04f6cbc096153c5e0df7daa0270d64a9ee28b21675d74788b0aab1e8e404ae3398ca7a039bad94b8a309e8b8f1b9664047c29cf99f2dfbe9d159f64c17db5d822e0fee0c55d1e2fa1f392a5b200f9f03abd366a4f576cd40ab48b131484511eef7770e56a0d66263ddca510153024c98bb32991419417d01103414085050dfc59e8ad040975d4fb6a5791c816478423144a98d9b09d1e04b22cb62aacaaaffe660ea8c241fce0fea89e1284af9efba46e1f759e9a814bb3a8e42029ad89a3c68aa54a4d6c6c7a46368b883ed4fac51e211de4ac6987258b7f6f679d684dff0e42bffb5907cd1f2a2f3bcaac4b87b58e0b6921a316975187f5fdd790035f97f4b1bef02d49e85426a27edf5814d7f703dda33a9e783e270674ca5d40bdbbf48848e441093805a951eb7e51387ac2752f9d153a1cb55e9d726f3e9229378123d0072d6f9bc013010d3da8dc00d51ee7b62ac3eeb58355754e62236aa03a128c451e442a39f63068616fbc0560cdbb9958797a7f8694882001d1131e3e9c85e46c04be73e5333450d99d5497fe492ac0ff5928b83a35c1978fd342955ee0ad36b7113509d1463db32c1b60b928d9a8c18567f76000277af4479c43addac8f3dce40c4ce9419545458414e65fff6de55b764984150338f36c1bac4267c52253f2bf6716dcd8f6699734ec92cecea0e48036a4da2cc841bda88ab76989372beb0d46a45646c4e2255248001e8aac1e443c80bdd65c0e28920a5f6156ce38e0a5775f264cb5b7595a7f3409757b1709b4810668bd539b46ce5e4ab18a99d1cfe9f39356c3b52f41a703037577d8b8f50f040056c0d93448a213a51dd39d178f95d64890684a5497fdd772c2768716480f00ff8ca3790e2e0c3e0b47fd6431b5aad023f10c15ff8907c461a649adf0ef69e8b9cec4012e16db62d9f0c2fffe7cafc9af9a21f4efae099c8a861710a8203d34796306fc4b327e15ee2826cf8deaf63f9ccb4454ebd636268ea97bc5442da66fe02bafab07d9ecc73c21c2f849df53d77aaa5fe02807e2f0ec2278d6b0baf90f65c5539ce1b84955b354f0c945c2e0e6725141b3806449c7330b76017f9a76cb7b44c959172924d9c3269a06ec878083ca61623e2eb6e97d669008de22a6cb95e45c8224e29fe7557e9166a1ec83ddd6df9b0abd7cdffd4cc00d929cbb42fbfb382c19356183b2216cc79cc2458fb16623b1c6fb6d7ab0381490427fa1017134aa7cc97a32c54621474d3eb4890bc7e1e0dedf4c20913e7307057f71ec30fc5a0b2cd6ea1ed71eb58306f28da80d4b9313f40621c83f511bcbe17ffab8fff8ffde5a66b2927ac78b920ca8910742fdfe6369e8ca9c0c318dddebaa2dd05f07e8887823595b6fbbb44762a92882136a57b2563428f27a87e10acd9f871914499286e79e3b8b453dc92dc4bc3e7b8ea5dfdbe9c61797abb4bdfc794f567c91a3c1cf47a48f903fedf20ea763d0baac48527a500dea6adc214ca3cca9561e28c4cc8ef5c99055211248a3f1d49186215b16f6230db7a1fffef1cdfea16040962f74ad6c158361d18b02e82b036143454a2690cbc5c69e2761adf1c25a60d0d884a331750002d1204372b15bb3043e64c904e38f24af6350be92d3b31b1f0413df11b387dae1da34436194b560cf2a96adf9e8cda31574e98fe310edd7f1ac891bf326039ebd0afadb73270ec936307f99648c4b7bf94b4ccf5ec266968c2634c7d6a35f1763d9ced836af6a3ccd6f531d39ff87fc9b1eabfeec5fd4a160ba073","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
