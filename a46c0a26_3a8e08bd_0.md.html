<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33af397c2364b5f3d916fe0c6eab68edc16a7ee2e59580b3a0ba4be51e8ac2106f0e90f4c9e7f7d909caf5a4d176656ba0bd6a7e595e8f0c93a6e720ac8333f86cf4ca7f90e88801d0e2270865436a334edee92c214d64604091755a763c342cda55b809ba4478b3cac1ac752323f18f0b576551bdca9182f2fe70c10a9b65a7170a3ab57670c17470407b72b147965cf792a576a944a09587a4ea7226e30fef2f0068932f7e5a3a1f5fbeb57324ba886629e41b30b9e4097c179e9aadaf99a6029c94b4c497542ffb80881b4c93b1405ed3a84cbddb573978ea2ea84c45459f72448bb9d9ab94bd00e8856dda537123330660f9a920b0747f2ea017b2658176617580d8657dbdf1379bce4a1ebdef40c72ddfa2114515300a52039cc04aaec85b889db3b7acbd0a325b1fff6d46e195858b3182467d43076f613b226b44d144a08a6aaefe0074cba56eb14f83e83e90e136f90a716e850e40ef0374c270576840ab042e201bfae5ab629adf4fb4563752367745320bc368d1f086db013fad9e1b7f0272bc863a93ed373169fefa65fb4bc47626bece4a784835b937ac4f1644e2107547c380ca8cbb99e2c5e94d96d1948d83bf59fa72350912c49c5b2e9307fe082f0b1740adf9d52e7668d43bc0c02384cf75ea9982eba6713657b90c8827dc1eaad32b4ff19d6cb1680fe6dd8b60cd1df06eeda44f09882de76a2093c9e03200da2b75b02892e848514fddb4096015e813f93bc15ff9d5a1f7c060ed15ca6505f5d96db1077908c221e8170048596acc5b4e8b83478693d5e185d7c33dc639d5c67b738ef8f38c5ed321aa61c06aea1e1928933a2fdbb6de90a26d8c8873bf03651a09b361ed7782525e493bc86965c349d0bcf88c05103f74c5293b16d29b0a764e2cf06c5e805c3242012628f6affb44b8181aeb0882ee71708064ef8b303cecd8e284b3401a46de0dcfacdda1541e158c36702f92c57f4a0feb8e9b15e4c6a9e059ec0370b7708e425812def99876ab4adf3bd3d8901d30f7abb5741e8284cb78759a908a7b986a9722c3c4ba7cc49ced33c1734abfdb2d449cd52fe371f696cbc7ea9ce0a2439d29150d4b2a30d79d31c0ad5dbb2efcb99ddc86fef1508d4e183f35ea07a55231e2d185d073657e6847fbfe831c1106e330ce255d4d01566195087053bc30ce79506e3c9b2bcf7241d613821590b6da54f0df689d11caaaec4795056a94ec452f9ff462957728e9f03807e4657c0f053725d245be239e6afb32b3fb91ef355f4ec146c53faafc723cef549ab5abea6a6c06d1faeed2f068242cdff74e5131aa128d67ae4ccbc4024512d7d64e65171977ca295abcce4598af8d899c257d33b04be367562e039983f824432362a442663f55ce6c186d0f50492079d2810a1fe25c07472df35db3f1e7eaa038d7f7b8f6087be6590f32e318495fc0d792dbefe9e315a1160e3bb9d4f840b500a7978f009bb431c9d6f6965b8f1ece169ed8d3220f5516e9b059d3325d2e2ba73c6526ad6fd7798124412d8fd32d4ca197eaa8bfceea7ca37bc11bf1313bcefab39843cae39b3b650ffd5d010f33ef89d7a8f922b10eae8dbcfe9cf40d13b55fc18332851cf20680d17ff9b5032342e5e5cba205950bff18e50883a449ec3b893100db1e6a918a7869f85f195021289fe9886cba934b5191189b216d12284380345114615b23e7ea4b23da97e0ffa51fc79798ffbd361b76852206bd19a8ede1e546a2483fce4b45c7d38e4d743dc373fe37a6bdf9e6a2d300ae322c028ebcee29aba91f0fda6d704b099147b81c0f73c54c281158f806ec56d734d68bb344142e349f3e7a06332917334c4c17424ad269232c734dce176c6f61716958f7df046ebc31d4bfdd5df6ffb8526e6b33242775bf905a4ebb31ebb6c06d920010bdc028a49a352ec9f54613b8c3ba90032cbdf4b20b3f99884668c721ff7705e76ef8d23eed6c49134deaefce7ae65338b17cd460b4bbbacd60b0fccc8f737f90a0671a89bb2e6b7bda8a393cc990c57149829a8b300576b40862abd2b4cefe3891cd476f79159e5ace49b1fca5dfd8e2801a0af88d45ff442668e091bb2cc272864b6cb41c06d9c83c1c39841114369541333943a3e47393559da9914c52a16c8aa52c5dde8bf7e8ce6290f9a6635fcabc681de8118bf8152677f4d3e6ccc908c95376b1522cda7cba5fa882cfc8ec1c858d01cfefd5c669fcf66e17ebe23f5f837b70a654c999862a17f15828f5c05c7d4f59adafd8269c1995b36a44d035c9285eb890afda52973825f0689daaa570c1a18636da6706300e9b2553687422ed65f875707d78d7db1f6d4fc18760c4deb3511eb804f94c198e845ddeea7c1ece8bd6a5a22b38b8e027c30e5e59c58c8193eef3bfce13fc154386222e2797fd3148b651df2d1ede4808b26f9f3b40a1ac598dcc0699b007835fbbf77e19307fbb10e8d6c3cd972d81a123920fc3e2cdbd8462c6fe2d3d4d2f31560de80039b6b8533524b8611b42956b8883e8bb350a6a0fe192da396827dd12277c1c88c7ea2090919d3ae90d58803a7da27512301e95ae599ffc219a07e8fdf11edd3aed6981300ecddd2bc313320ae8d77745faed0184ee0f963b92be008ab7cb5a6fab7f8602c917bc239a7ac4dd6f91067d00ce3897d34d03212896093f6364bf58fa4e15b48271bbded482492851f5357d2b883b473d374466266912b4da5c616def2d202d7b0ea023fef721d651136054995d533facca594f6dd7751fd87de81a7678cb55c6f18371311c531267a309b5dd8d1486f6452f253af53773e8c2cbbc23b37d480b167d1c4e32cd43bf1fa868ced48ec1a450abf47001c6a15ee77c7fd0dd0a3390a1d2df4e97a2f6496ce9f8b606be01e14ff8f6b0221562bd3fe3dc75a587c862a7dcda512a39519b5d03b3c4af57b074c6d909ac511ef8f4220714817724544019fdf527b4c47a744b6887d8a5a5641c249371072e72672689536796afcb79dae84b0afdab8231790fa1b60598e6aa84ecb6af019114d3bc6d25030e96e12986b462bb8bf6dac721c49180d1bffbcc7dfd21352f280079f6b02a8ac6c197026ed8b47383745760283fc0ddf76b1438e13c381f25f770d27a2e4d0b89e906d50a2f78ac7b7775624a1b667aec2960eb12afbdd7cb10ab4ffc1917c1509c1949c8a4cf602408331763eb71d385ecb22129a64c2f9c10d8cad5e022fbedb6b560d66d39c3837969d3a4fe2fb0f7e52795bb87076ae6f7bae78e04b8d2ba73df3c0432e1fdd91c47ccf2d42c2e6afad899df2c7b1e10bb300880c6568b302d00bb69ba4b0af8bb6885e41c1c5580e17f190ac27c671872dd155a6f6f8afba8e08a5edca011d6f0e71113e5f6579a4b722e23404312f46474dc59b8446fd83c51ff16c97ff3c154ccd49804cf79ec1692c14d78219804914e49f935cf691f5a7eab1bdef4e554a90edd14646c17956364acad698051f96caa7a5bf2dd830ea50b09033a2803a01c136a8907b44bfe7e7f089f2edccbcfb08402ccb3cf03cfa03216e3a5cd4c4383abc843d87e31e0bd201d4b918ecb8f08972d6e624780399a4b89c0984a6d27196211f6338cb65f6ee8244e5f9e26844d140820deb3941ae25507153b9ba5bfe49ff88658303e9d5cd2c031661b36e18961632fd4921b1365bf3df6938689af42b60c89b5ec1318498e6867cb8df85c7c26d82ffb5b9cc824a23a15b2ae4c66f7ef0976e3644f53d5e9385bdf768b36e2ff76e753a9e1d55a829423f24b4a80ec3945e46a75b1b2e208532213fce9ad9f3c8bf02943264e3544752c6a53d42208379dfa804818cc308f737f68f45a5f56c2450356e2ab10c18e5f349b2353dd8382ac046297f47560535531df6ca2c3766c4b32df2df252018d6da0d6846311d90a20dbe44f502b215b7592de53c0e88b7371183617e8a907fea754eb6027619854808e862064ab75f08a013ea3d566fe8e262567fbdb96bceaf42fc3d37c49f33a127efdb10564d695664e1dea3166457ae6fd00f5c55b199b808300e7f0fc22e10dea535f2b54caea00f7df7a05df9f6422fea7e00022aa64014ff89b48b0ece18c399c5d776e5e809cf005d289a6c2873bfd296f9dba2d406cddf983dc87c02f28401f63566914b8329dde532e0b4bcca848949cafefd86700ea5f847199284b13d99eab7e84f6e26c41d32fbdccae971fbbd943b4252b41e8805ba2fd8a00a9d9d4b77cf04a52a45c8de2ad4e51178cd36ea87d901ec2229e457a721f81dce4b917c3036a95515928bc70831eded34ee31ae8fbdd7c66b41e36f627de96b60b11153a76cc1469be1691307c26284a1e9b689145fa3bc52c9cf355798920caf9a1f6c100eb9ccb12b1566bf85e0c7d7430a52aa8b592f4f75a8d1b9907400077fb677f99b1f4f36b4a0bc3bf2d45b9c0590d27ee253339b6cb5d4a038a8889053d2e4bd2120dbae153f35f45e93d424e48345248f2586038bea399bb4cd0b09fb8b2dc38bbdef6f11f564b521e4a65fb688388e1d76ac5925869f62dcf12b20e0a00804a8695dcc3d3b4425be28c1a824cac778485a13678971d1617e0d4ac90ef73cd52f4f783648d037e4d8ed76f30e174c2ecd4ca3af34c6c537f019e895106399030c0dfca4c5a887fba59febd774da53961d80a9a47db16f03b6a7ceb35249a1720c95467b93eb08dc1b857dd1822d41280f99cfed4079b59e0966b36b6e7526c99251d6b867a822420ba1051795b8cca10ed22cef31c831bd40f5ecdec26874780062e2ab3e77e81d072d13792af7d8dc8a7b191e562e82ecf2848b78bc41246f868c28b15e5ed2ef01b35300f0430b6f310e5b360417aa11c663de1c6a3a0d958c06522c3e6de7bbabc2ca739d05a3fc6bd3f73b8b8931bbc802a96ce665e9f4867bb932b7a616d312eb11d0e533332e05f27956bb57c8eb86c70861e49205078dca6debfa6b4f7b972fcb5c854282fa1850530dabb607e228ad6aac4afb25860e689f9564965ae674464dc9370c62eeb3fbd40abe28f58817847167851cb4e75e908cec052a39f5f26fa004396dd27832fc4283fcb5d1851961f47bd9cd2c64989b45c23fec4c7c5dbadccc1ffe43976b4c1aeb5db4ae86bd21178a90a9175cd4aa22c814ba14ecb92e1f28a0849c366dc7da547fc834fd0ad76a24287126762208992edf0e7c3aaaf0d7db0432ffeb8695a75148936846222430e157957faee81208e7cfee8e664eba56f0d2e71a9967984962c4da2b3ca27632f54d8aec44f6639a52d315212634e8d701d444a8cecc0d342a154bdb9bfbd032fcbcff1aedcccc7e1690a31b346fc100d22f28b749efc25729cda0a25dfae7f01c97915148cd05c8935edfdccedbf4095fba2ac5f8b202d4ebfe80fd458879d87377528cdc1c6478bd3cf2dbf11f513f25d0143e7270af8bfc10bbefcbe5bc339598344f417e7e1575eb5b888005e680e32a843b1924ddc870e2613520bd52d1c09aa13808c8b2c8cd6345c71e27fc32f44c02d687006af3211ec9e4b1794a3aa9b8b3ebc717e41866bed388682e2b16e1e2d72f22c8a1cc54821042971e217a88cc23106dd2eed5256bdf9ce33f07815c52bef268a7dadec193b0468840d762595c2f9afa843a919bf2cbfa7c1ae824596468f96e5e1fc304f8e07418210cad0c921a192c0db9a582a3c18a1ef039ac9b65d68f7e744d047336f9d72607d1c3ae9b6e472b2329b0275d9f80ad495811588e02bf84a856a9c887f8c502c346183f721c1d5a2173a84b9ccaf05aa5553231c925aecbac3e72771ee36e44e00c8ecc11c5bf2f50b168ef2701e0ba1b8a81984d5cc9442ef4fd21a86f6a42e471d892e4851b79b2c9729b4ca4f974a8fc90e682d2e6e8aa91a5aba117be71d8cc3b19c6402ff17b29f12a2c0f209e4c44318f8b9a7015e7bfbeed7c109bf81bfabf1b9bc6322c937494e27e19ad1e52fbc11cabc862208b529ea579999e176d0ac99816ab1d653e88c070c8da6ac5f7017dc840f1634b37a575487b3306e257abeab64f2045a52ba8ac030d584b0e50f034d4d3cb5f8d25c7ce8903c2bf47ea5d242363356caaa3026c9692875491efbdd9c1608854ae463f6050fad7520bb356a49317c3b049044be66528a0e728b1562dada8220c9bd68590e524bb5b9f291054f576067a4b5342842108e5e7ce01f3d0b6d88c2b5671617c5f8c571e7bf2ae604469ed1cde86f4a1bf3e73afaeb9ee4dc5e723e850615c621006c2c928926d7950e01ff624006b06797aedc27d122a6ae60b43decc51676b071dc914bf79dcc6613ac1bf093f8e36b7804f9c6c69c6ba4a8a16c158c71c6c5253b25f9142fdf09f333f388da6a089fc2efd412489b99451779ebbbf38585208aad65b3657cfbb7241adfeb25821e85c80d7ec37518abdea439d9425433bee1f3a3e5329ff2ed03b14d57566536c65c4f5eeb91862bbfb649587683037b200fd377886e0fa515b16e99894902e79e7fefb73b017730b7268ef8583d0e8952d3c263852837100c51939a0e9a91c8a180a0661b46b2786ac2eb5dbf1b7face250a064db97fa5657f427c34f1741a863d60f817745e6cc9ef33dc054f36cdbed93f2bfbd7c29ea652db37c869c1afe1b104838794aadcb09a1663b18cbf614b67386597e023e8628bdc79c3ec5feb71ff89faa041f52bc7ac142c9794f635a357d1f59bbc38c72237b1d50f66a978f19d1694aef2e95face3460e227933381090d0fad1307f6a6db70211717e6bbed9997993658c60742e7fe29824c2d59996f18cc28fe0d093a06e1f7297171ace1f9a4803ac133c2c5e7250e09441191ad06f0e4b4b4a48f23373d25cb050e782e39118f70fceb7275cedb730cf429db9bf4349ad6b6190a6db53ddd3f0ce911dc81d83146a1c54bb57cd0d9495f290c3af4cdf2b41f338e183f1bdd0552d903a4652c0ed53dee1de14335de1eb060b725d265c403977bfeb2557f3fa9562b1d03f8f25e48754255fe439766fc71ac632ae5dfcbd146f7968a8a022d8a39c1c8ba9c21fa86422997cbe6a7e96d396046c36388e19ae0f2cca1b1da87a892f2a11efb8c47837d55be25a7eb4f400669a7c77347d97ed1cfb69cadfd909925e3738382969eecbad9d7698156df30222a7f8bb020ff22d8e5609c3c08e9418e4d4dc49d1d89d731d8aaa37f9ee6d95d5ace14a9d8eb832e51661f1f47ff0b3d9af5c95e6f9c5191a024e1255a6b1a7f5cad7bf8e4c0307cd14ef6b11e77d2e00497e19898ed5ff9879d1de6e03ba4539ae117b2d2bb6e8dc280681958305fc65bea986625aeae635e84243229e197716146d0a08c0db18a95275fcd26ae5fd740dc81f60ca1dcd12e90b73fac25ee26f229fd59e8671c66ca87ddf8df136cb898d536ea06e43fffef5eb7330adfb800e8feed76daa9f7c41b049a2eb0e93212785746ea1387e4952e27848762a606ac24545493f8e0b9a7464039217eb4769cb4c1d9189ecd08b270c536dd7bd34cfe8831813eaef2c10251a53a2e262da2f25e3a7ee517b732bc4ecf1f7bb60b1ed373c43105e661ea9a3486182d44afc049ee6d4ce3725eaa4aeeddf92641c4a7e6bb72413afd8ebef568c454780ad934934478e5ce7c0a57d979e365b3af01f2202df458db2f186805717c2b3c4c71487541b82c79dde258521760d14088f9e33cf7c245058ae471c4dd00b32b37e5ff1baaf8bc6a6a599d5dda3d392dce3d44dc24b68cc6ac656e16a08af90ef81f2ce40058084a8b81f1bf4828526137930863f9c3bff7ef8d6333609421772db14a89e4451c3e431bfe54a746e17a051ab67622a6dd9c364798a2b62c0accf458b2f3b1b9c02f062813897f692b43f7203fcc727b3da351ab88c56d12a64ef1b95b59d431fec4e417dad3d7fd8f5231da804db5d7eed402942f0fcb83aeb8d7159b03c99b3da1039de23e4cc84ace09a1c04089a1bd8e825e54b0856917c1c3c8863a732e66409d0bf9f28a0a19de00680b3e2053e35ed255179f4f317c98ef6e0083289b9b6aef6175cc86a69b0dc6201399ff6e00271d190003fd67fc6d71220669db07d314a3a87bfe7ea718a621f9a053ee575a55f90d00fb693a62ca53609d684dfecfdafaec782edb2cf46f769ce99ad39769dc7a098f898a79b98e8b016c56b421b6e127f572792024e54cdc00b6ace589fe87be40f3dec91c3a2723260656a0475f3d0cf43489ec89751c69a31130ff8a57fb33c1298e9dc9b9f5a6a9d128959f845ada269d341fbb809fd895ecfd04b8bc695b4b4c0af478d4c0d4fc08b24f8567461c06dbed7344afdc634ab6f427b889efd58f4dd5bd2bbdf8dfb9feba1d766f8ecfc948df7d12775e1b9ecbdb9811c39eea6c7a2cec959a06945775e9b8d3625f08e1483444c0d194a34b0ea84594ec4980744ee1d0ceb73f8c0434062a7f1c793ca2b8cdcca1bd5ae612ce1a109ea334f0d7da1099bc68488cdcf0892fc5c47a263867c0d54181b2866876b55f54554ec17c29d8c7cebbdaaa4bd1447c1738238c68084ab36d0c87dc596361b45d8a5f2b62081e7eeb011d90c43b95acc651dc44366a70157e5cbb862ee84563e69e76360bbb0dd9d83b31967479f30c8ecd194ad9ed304061eff2cbf5c4a0268dfcc0b0327d5b8e6a649969bd1353c9e77cb7a8e1f842dea20f5576d24448b7a385a94f2808bc582f8d7741af00c8d83781d6168079d919b75856a6269c60c935a40b2530e6fa7c81ca49d507502cba3f8c93ab71a595a3e31d5c1455e469a82860983eed3e4d5954ef3e5561fbb115024acb713570cae8f0850aa448e007ccc9de9298fea48e8ff172b70b7339712fbd44522aa9a29aba0ece97c5a4eb42d91bd046a7db77129ef16e83772540ccf2fb6f1c6600b9c2ae9b2de90e6fb9e60e8cfb455953730e1f6a71416a25caccd0424c361a39714ea0b252080ddf79a3a1a899a179e8005cdd24c1de2e9be6dc75f94f286d5adb911274c68b1810b7319729a17156a4d127453108514e077ee6c0746a48692077e31c8fd0c68ecc42b51173da53a185d005220abb5a179b82b64ea34a07f536ee557683b11b6dc5979fec1969a6364faacf629a603a1f9dbb9cbadd2c543b8cac2818787763434bb13c1ee1fda9a33337c3818083f944816a1dc3ba00e15ac80f4f23197b0b1e0f2370dd6af42efad47eb2d6ebd5c524cfd2e3e6e44097ece82cc7d994990bdcbe56c98d7f4770701a62206a3221f8157a25648340f580236c8794d3c48f829cd7ee3d63db9451db7cb8dad270d31d7d620f1508364d1aec60c6e9c71cdb5bff7f7157207c1d59643fc6f078abca71cfd45587de45c2f2f9b5ce9e5c4cf7b6cf923ef7ebb35d670d98cf08d39eb1ddf73479b5ac4b37414906362d6ae937cdde1326fdaf1ac1c06d28911aa1c4810ff7a2d7e03e68e9675795b0fdfea666f7039fe973ea726c1197822b030d68a94e7d33441b5500921f4674b66e37853b221c8bebd23473a90ad1441fdf93071d2c150bd9514741228ca3d50569ab8cae51225dfc977d41b77430893a81fb903b7cf14754e8e9bbdebff932960ddfaf2a196a1d774ce327225cda4a1386f3ecfcabb58f2d2dbd7e7a8b48fa25e76996cd213f191ce86e14657598ef9c137c98172aeacf722cc36c9cd34f69d774c3b1852aec11412a49bb353faac77913cb34384fd928f8fc95afbd2a5fff85a69b7c6735a88c39b7c55d390073297a7d3c0eb6d8af98a33f66cae7d8e61d2b8fda90233e179efd3a2d0c06b88287f97cdfb1664c9cd7b8e6d2257ac5b5aa61a243da7169ffabf5a4f50c1db173b2809e16ccb16616326f697c95cb82773a91878241fb590460439949c31ae78af66edad6151a35ec471ab9018b207ca5414988c1b1f5ac7e5dd83ba7a82371ab330950133d0746f13adab5482608c41eb3e9ecbe71d231dfc8fe86c4176d8c4c0443e85ddb3004afe5e3bd7839a1379cd1d89992ce865ae2a54ff6d8f2f0020b9c73d36a7d8b9377c8af0688a6059a3bde8fa60ebfca5f83d5c9b577f6558d3d6280cb1a8a9b74c9d7fcab6b0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
