<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff20d50d34f6c43d4d49c36586d552405b120a9aaceadaea145af0ff18262f8b5609b35a812243f60a0121b77647bf43d1c1a21eaecd95748e079ad29c04dcc45645a06c664b9830fa60d004359a33fadcac01421742ac3452caa74634418d803e002182061299a332fe19c6490d9f551ba5a333e1e628f5c4bb9b4bcccca1a9c22d517681b8bc16f329e48905f94a1873ea2a7e941cb27f018849b72de49a608579ffb20d0af1f77b85061d515eeda9c0d83c628752d6906f2dd441f25dc95c447d75ac0edefb86bb24482bb15886ae7be92f05c0138673d33ae872cfe77088b3b3e1408e199912c96af7662320d7eb7833b2eb4ad0ed6fa3e052ab5a9117818e2234c492417872b7219f56607be81c1b597bc363e6862e9f479912dcebf3c3fdd131fe93b2176144541e2af22f9420e64c58f7ec6d553756412eb711394096ea66f9f0633092c19831f3a068782350a04a626d1548e45a9267cb046fa84184bca882c390d184e9782cc51e0fceccb52b5537da48eb0ffeb01417457c715d0188a9f10001f776f878c778f9aabe3aecf56bb1fd6fc61b99fc9842b2fe7577bc6a71cd68f7547c41456e3d53dd3f30bf6991ec9c0e11910e6b5569f82e3509b9b7e15d47907dd8fe3504e0d59dc078e6ca540cfd19e9fe0ea80767afb9e91bb4d64581650515e362cb940b3e6f207434ccdf3e26ac3a639579e684a659da8e4a2a8a22d64439e6f1801bd09881e9bc2888006c36a65f64ae6b9ca7a9263e8a1cafaa1e0e56c1f2564cf48bd09fb22736a6439bbde2bc54641f5ee77a3e79739fbf5ff10918f3099a81d62d2eaed40a54e63166491e4b7bbeb400d3f1eeb8193f3e37dc8c158d70fde0c8cb60a9aa830bbd8ffa2a34c40eb0138b0f473f4b30af2862286d6951478228003ad3ed544e3be6c1026f4c348f8bc57834a6275ad94c6aa972db3ce0a92b8836e128ae1f995566a9d4d9b475e98c8ca74ca909150be7271cab10c266da88b0702708bf0b6637c10861b94448a2bcaf06cb4c28121d04b75293ad14e57b1692afd80c6a0f709fbfb6070dec77fb09448acfbea632a8376b805b8d08b337f78637e6983a834f94a2d3dd8852ef90cfb526f37b2cdd5b64ad1302e917c549c125682427acb02cdf252d78d8bb17b110b64f351b661b690cc8e63f7acda8d3b289a9c7c526b99350ada9b507443632134cf9bcafe3f638e2cc21be0ee1fbc36d37f5a3e06d40c70ffb6793d99d82737b7eab81b76c884a756cce3875636812f09bf8ce59225cf23fd96415aa050311ccc1d7eb03952c76728e343ceb44f5224bb559c069d6ee85cc15be20f5c84e50479d9765513b35f99e2c93522d3cb8134781ee83cd7ffd47d278957b6247cd985547d8fd1d35a268bda44c68c28a84473ce1a4f1f328d832ae90f2d2a51af0cdcaad59fab2eff06ec102ee3003ce606cdf3c2f6cda12390d2764beb65afd3ddd9c2b2e1ad5ee1124f44fafeee6f0dc9ad1968d2a50759dff5752da4059015cab054842a950c21c822f8eef9cdf77be1557c981ee4450a70238c3f652c72580e9c63d50067b284f459903e8362c3743f50bf0549e813d4023547476dd8db6acfdff04fb6b820fc82f762abb0a1536b0fe34be97e67fc6a59807e90ecf4fecd902fcd1c61d6540afe9cc32708ed53753a3bda7f1e98b2a4e831b5db8310cc1bb0b5d20d266cccc61ea5b6e4a3d9f2575ceee05018195ae376dd963dc6d671a7cac6c97b8d25e83d91b1e18230f6cde8b160a317470ec04d277395b43fc1e7d83f59a02359b870c0fbe8add317e6970d0311652d8b3241d7a53051a775679b4704b3410b8d9fcf5e39aff1b4fc837a0469d7e8922ce486b0866fb25964b530d9184830e027c22df86bd80794c3c2222b1066881da846a4e2fe8cd69f726fbd4e1ef43ff9b4fd996962445bfed146846c3acd304a9d649b3348d1514b7c6277bdf9f8b779059dd2270bc34bb4efbb7452f36e03897aef9552152437c91926cff472080f9cfe4f79cb73378eead93b8805de09e04904873674f8c0151563cd759c16d6a57be48f428325f2f7cbaae2a28ea4aa8c2eddf94db75664135a7a1754059664b4f36b07ef53ad37835eec6b6dbaae99963ea1760d919a4c240605c9971af20dc2d3f932184d3e1efa177454b2dc1433797dc6ef7cda2764353a69086ed8227e22e294089d66af800b18081e8328c5154a3a72dda9fe9541ca6e5e70181423b8ec0786666d8baf07e9196037d24efabd5ca0834ee65cee0d1ff98472e5821e7c8172987d1e8eca1dbd76d844ff7cf524a8670956d5f37f12b5ceae935c478753c3b545e9d6b7152c606973821b0a4a5e0300688ee2027b953a1bcefd568d37899ace6eecf1bfc3e2c6e20625fa94ecd34264a22318629568993d38aea68c6984d93fe765e03ca042e2ade914be7983840de73708706dfa9e628804d12d87139eae864ed8603304c8e5ec3b80d44f188926a7370deb0bcf3dab8b7686dd7ef469d8fd32125665bc5425a7ad9a97beebd292c37309924f984dbbb6a76be67ff3ff44b35dedd271adb6dd73d05c679cb1aab8c8b13ef8a48f04f822d8e752ef8f79d23f3fe4b79a867ae7af45cfb152596a919fb48158c2248afe68a81a07954bd5ad3f54c77c3f1e4b778634be079a4c405e4ebd6ec5a4e0da5de11b52b9c5f527e771b2af11cd7a83c55e21e83861d0429fecebefc16f505f02c17fa4f816bb0414625a28488134ef5803a8bb037d2ffef2c2e031b4c58c52c54b9abe7f7da9b246bdad8e2ceaf61e7af50790e716a0d9cc24814f4a5160637eff00591071605e148857c7888036dbbbfbf9361e50fe55e301a2b2adb213a1e1b891ecc91dc356efe8c216ea7d20b825bd2bd4139b1b00a04b95a1d075bedc8a5eba3677f6f8d1cc6b0fe2f04cd7a02f7c3040e52a8fe8f538b0f532abc894cd22d43ba0f0998fb2d42669ef90ece344f6d86a20ea9595c94ffe84279b1affff2b861120656fca007f25d73903603cdef9c5e12ffa8833b5e624a04ecd1839c800aca4cc68b36cfc43eaba599f08f31e5b26226627e6350a46e021a944829cdeafd57870fe12e38c4256bb0e3eef637aff0d7c631e1b5a23e665042f9994d6ddad9dbb2e94c3a922d8c9d7c707031587dac7841a668f3a98ce89a8107658fee3a2877897ac65cb4db832be0c87f633ba7f7f0f7836cf03e2fed1096a5a854647a770f54c6c1de26e589c42b1aa9b85be6aed5820e0059c24e78780272cca02086bea1d4995a8753d6c34e94c18ecebfded92823c15931c53361b2eebf85f0083dc840eed993e2b986ef0c59a4154a0da190c07a02a440d1129b654ec42932a768450c5e6227fe95cbef95f93c1361bd26e7c96f8e2d5e88250b81e3fd9a45966ecf23c58c464fa122efae917c45aa36e90bfe84d3c9b6cf4d38a33251231fb96581333e7eb60d906a534698d0469716bc924c5342c7c860a4a905b2d20e75cc8989cee6e0a6ab4df34ebc93220ecac96bd1a61d3395a5063f1ab532204a2465fd69d1b555291f58845d589b5322f298c9fbb5974e104c68f0798115b6b9d23776791874e3180d7a75b5057f89c42a79265e386030fabf426207f74fe731d4f0979dd230a151a2ac457017f43d6d9b147fabdc4a30ed4d05852082eb1ca076e4f878235c605120026afa60f111dda7df3e822635b779df7fbd62c1b0a47054b8bf49987346ff39345d48552ceba00268994b9ba828e0eac7c0585b94b611806e01dc52f9ade7a01bf6efb6541376f496f3c1ea2a0e659efe133e3d13259030f8d118714f7147718a75e6030302a26503fddea24c8ebdc8c92529c569fba20798361a667c1856e91e9634085b6f2994d18b5153e12fad913663e9e04bd0344e6d5fadbda4dcb6a5ddaf5f3debb04a4d79f7f8e1b1d47a60c29501cc65aefdf3b714add899c4646f4288b5ecf4d4dfd1a5cd94442f36f2b4342e6877304298c910be2eecdb7a1e9b7f4eaa12e8d0a23952e8c5369625eb04a153e18a45048768940936403441649db528ca77aa77c84feb605eaf7a4c9a42fc0202a910f2bfd31bf1f803533a2cd4fdc9d3c8ac723bbdfe74f4ac411b57e1a924d695b1a35c4420cfbfbff8016c96e93f1aabf0a770a5fdca7648eae69c10183d5388aef40c68be0f8f47d1717c377e1d7d61f74187fb6ea91fc99775e2d1da55bcb5a0fed9c46b13ebb356fa9cb6736d8db5988500b35fedf3ae2039ce94dec187afe251e3ac2ae7500e9c15d8d27742203eb40e23577e3bb30581335214193ebe812333292d1c6813bef9cd7b5f199126b4170961a908b04676ccba1fb212ac0beaed3a3ca15d4b48c428d7d62387b6cf7bc4a832fd77521832f41150b22c8fb83ba03dd1ede65af7cd6214fdc5f878bf0958f37e8a63db1a977dd09e105fc3ab96779cf8ed2ee80e53a1ffa5203aedea440dc73a90dd133729037bea38b8aacab63a5eadb3ab40511377c12b78ec539fc13c88e68a95f644976dd0835b3809198a4e23777c807c7a0a1d875f197fcf5aaf41c714deb2866655b51250d89b96ab46088405bfad2e624b9bb8e65eb42673bdbdd47b562a0583ff2bd056a2f627ad2bc4c1e77c65f84ab8dab73ddae1ff9c772cdc072346883ad2b9d40e4f0cb9598ae87b8e09b78b5695f4a010e9ff6bbfc8fedf10701cc9a17a319fd928ed8b813f7410fb310dca5a591bf5ee4ceeaf64b82f27dc80bdd2948529397592b5f2edb36234279407cef7d5d628d37da5348c4b8fbb7f33bef2eea8ecd5472fb91b3d9539d4fef2516b83d9dd5e3da3ea05472a7cdacfdaacc002d15d8d924f60e9d932e7d4afa57fb2a14513921e13721c1772b7a1861077439ca04f8a8538127a8c93f6b71bcbd05d074731fb11249b4f6c100c979d91c8a362d0ca5004309826dcdcf4a3c689ec212093ed112bbb7e2391b751f165da324e35e643b31c8c7a3b7424dc76e9e9c6f5e3158136842374f733fc0c1bd13d99e096e7c97d5ab4f81b1c5fff019d11be7a9afe743dc4869bd67ed536d320e8c8133d6588346b89658a82cb4792707d122d46423ab2f0f75a9a486b024724256141d0e3de9f0e69e33378d473e2363d5542313244fd58767634ec1d21baf399ab22285af290787e5c99f2fce0a51c9ceb644d85b66900b6253830a58f5a6721156a8a1fd971668e63b19a4676aeffa47b9c26245d93975c07a9c7f90b304f9215544035f174f430079b01e90297549088c74e242a5fb608cc5617cdadad55ea1830e773a5670c90b9bfbe535810e13990c44ef37610a6c878f76ed6167685f7a851b20fd11357064b6835d085d90952e07cc711377ee4f69b28a556c7f6f8adb8e6f2b58c028d09c3854401baace3c5f396a4ec6702b3f7c7b86ca742283df978b8ce9244be59847d905213c04e09aa76566f70f19f926614c512bfd66ce5bba6859bb15608efa3d329701ed841180ef19ef65d1cee5d3c4439f3976accba91c3bd7dbca997b88a76684e02fba8d4d1c6b9e366d59740909f28685c5f0b862cffff41d6392b8c01737c7f2b18900907f7595458a06a3a5e06d188255f271875f6e74b98c6c2f73c41d49320399cc91474eded1d9afed379d2781ca7907cb85d1e7d56b0b337dce641da53ee2fc842399484f4ca187fc1651755c3e79fffc67e1078b8172b7d623df3e136a6664dd964841c3f6bb41db84e54b337f295ca3012a45179af1737451b3eb01f888b87834c99de181631f15eaa7547a7280db53f91ee58d4fa5c8f87a89a6911d8a03669b4ed9be5a45be512891e5df97508a1764ed4aacb167b333df56672c690de695ce1232c0bfd339b02b6c67be0c14258cbf9744693d446f71fa3b938ff1b144d852f80280b651b36fa2e793bdd7328d025a532a8dbdf9745037bb7b29a36ccd4a2a1c602b78abaf84f9e05e31df4fbc21241321c00c09176d655cb91ffa46e4fec6826553012c2c744645445489e44e188575f25cfe3c89973ee882b0d6e9cc89ccaf3fdfb25ad863ee0ba388b0f1a98d7416db345901c038c1a7c9881924d02c32b7c6de1647e88c5b2d566985be2e5d3704332357a98cf99f776bc5cdd8b0fac43f1862df917606c7f8747ece43c2d13ea4382bc8129ca205151905887a2bd2d6f0824aeeedc03263c86429e41848ab789d0b472d3378217605758c37161e8322471314fa9eb69b9bbdfe6ca0ec60493fe60f126f9a82dbcb6f864b6cac0537e2b0645d941c03168ae5a6c30f88a67345a3ea9845c3ba634b4cb4869cd8914dce7ce72d8831d8aa707c64430cf977aa5ad30690d3a4bb27683e83179291e6cfb90a8c5a0aee684253b7e1e10971abd8223004a33deaae8c93be9640c2ea84aae77f4d092a307b2b6e95b9c82c083585a686b533399731853e4e9446da8181c5f23379b16d71548c2563c78ac5cabb01580210c1fc6ce8924ebd9cc1b4aca130f4389dd8054ab92c4f066790d9740a2e8b929230cb9f6623555d17a96ad904a138f0bb4d15a4a3101a94438f1ec60c67ecfbb6caf0987fa28fb4f82e10831a7a18b261e0cb5e9992890392bc9f894e7313f898c81e9e2c00c591f81acff73c55f3034b2c6047f1b5a9ea49a4cd1f30ddb2e902e24159bc81449f8ca3dc5834302b651d7cf5499a154e4e04cdf0003004d5e8a9a9970abb946bb844b9817427069f39812ad56ed59e75895b8e1eb7930acfae7127c47bac64e8f5cde60a2a2172d7058f3406e9dbe9bb37b007477b1536bb49cd6c7e635b6c2d3315681b6d991b97a89de317fea949f9c1e03df1ee645b2e417ac45fdffe0f13198aec39c6eec1de6098eed914fc133c4e63297b9dfebe239f48f054a3f8f184fb20030df8671efa57f612f8d9b211d630557d30840cc1294653aef2eb74499d964ef950c5758193c34b12a8370c587d873aba55130f9310bbf02b1a0ae6e8ac01b10bd23b3f26f0cb000d623050eaf3a8fe258eed09dba65c69c2f56babd28e735361a8e1604536dfd4c5a55f74a5c4e2ceec01ef55d0467374a181f2497c4cad9882f3d07c65ee3f2cc137f4194cd84bbe5127c22636988dbb4696260d3a277d1778f23a76c930d39c64dabe37c481aef5638dc331f61228ee0b3075c5572db712b7028eb034cd34d70218e09442b5dff88be106ab17c518c2467d044943de4bd9cebd57b23aa3cd183db05f961d601c9788d5648f96a6cdd59476c2fe9f7b0b6ac27fee07ceee2235f7f8d5a23f5cf0c3b55f6454f3f9ee0f26d40580f0be88ee8023cfb6bd75d4529b3c7a12c7bed8b7bc14af2ed81669cd5431c81945b6b04c0ae7938b18ee3385c40431275f46c9fe702dbf6c6f6752eda8c368e7bfb1ee082de99022685edaa5533b7cf455d4aec16567a933e373203bf7a76bce6975b8015186041f1b36f6a9ec10d528552775546554dfc7e16f519042468e06fa5c8476eba81777d1b0ac0de902b82f99b60a70f5bd69841053e8c3c1b3542a48d73f47f43d9b695e8bd1ff4f50626a6241ff0250b96eebfe62c84356e56da70cacb1ddd109fe75f48273eebb38f57bc3cd424d5f9e5671bcea9ea9c844e53ed1e6313dbae4bb0b9ae5a60a123520835f8d8278fec4e2529201a36c64f915bca29c3dc7c5a703eca79b02e2642e0a9f0bb4795f1b5e45153d3da6865893af0777c75f4a50c76a7eae3264173e20533f5dd6e8e17d5c6e3a2e1df4464d8f5d99c8cd629f90fff01ff495e8e9c46fe3d245a99b2b58a73df6551ae04a21aae1e2e414c1fde4c399284db6a51fb5486962b1f45316920284bc17f1c99a3db1aad134dc37628c897c3a1b9313746783dfe3c81ccc37067d7f6b4fea93b1a028caa9ff204a3efcaf9a05fc5e64ad4052a0d3e7e5f9df091c0d25f95d4e041adc8110a279e84bcf6a803d32dccbbbd490849297fd7be6659b85e2088ffeb0fc280084321218c3a4d84438f5b90049d3315e9c5441c46727d3801e5292ac1686e248efd2a2e1527bea7632db60ed2c5221fd886a8579eb54739df90bbc57fb969510c1ccb0fbaf70a0b528ca6d221423cf126dcee25ea8a5b05d848a90b8f98ab15c53526dcd84d3325743a2ad3ece339787804d3fc1c9b5765f43826805d124d5d4422a237c071625a537eb7d1e48ceddd896d9dd35fe87e3bd35738c923476fbbffcff3ab0c11c2aa5b38af9c8fb402df746a4602c9a63d59e3c27121899b767d3b8b9d536460798894a987ad8c5c03ef8fb86566b2aec1bf38428a8a8fb4ff5c07f21f0d1a61ec3f125f19d5154622ac7a4c7ced0141e7f3979b4aa3db58e10d6558a086c170cf274328a2f26096d1b82879b7f10f2cd0ce66f1f39e1bbe6465e5eddf8b54a13b1fc1a2f09b00ae427dcc192ec125e1d375169eae5404332254e26ee1c0f4b90c31d3af61e172e49b3bcdb8dec8c3587c3f50bd133e6487b5307abeeaa173395393730cfea5e7f3893743c34bacafa8d730234778335524416fdc0c08b8a20d471b9ec793cf0a881b28ac4841ad6f182da5c18071d6f5f2d2317f4ee105f11a79d0f9de19c75b031e34fd70afb011e48422abd3c93e58ca3643ba6b8452cde56427b18e1b5f006291b185d73a5742b7cc2422e206128a405ec45e4f4c25016a126514189004870ee4bde0cab359418a8b6e113a52e71aea230b0d33634ebfbc938ace0a0e7e95a9413fc4a5dd5db3cc5c0b678679221ec1ca88506e21e349448f8dc5bc3e9224175b193cdfd9bf7891a25397cfdc5b69cf868ac3aa4ba15a4f118e069a651a7e4b0e2d5453c366e322fc16525aa8d135a961a012894dc2c460f30d3f2021515d7fd8f7152285a6ae8aa931d8df1e787fe33dfa83636d66a3600115207ff341b039e872dae475a64a8e4010adb8e5760f19fdaa5b60f84400af8acdd358f9499c67d76b0e6d6d2d83cfff661f14332375cb55c352e51ec8815f7c71cd2e32b44a29c7f218a4240287edb4657244ef79d2428dac7686099121738b74beb893227b36dc8a9b936b380469f36f5972b7efda09fc7d2925a7d9332e34f085dc3f1ab7f899249f5a0823e07d3a5452e809d0e6f4926501a2deadae091c69ff3f853ff06bc8bf6e0cd81124d3e6faa39eb9e13f08308195e184a25b62c9974982f3167c0663a9fef689bb6e0dff4078be6979deaa6ae019d025a56eddea767072a7bcac5602fd6ccf5900b6087414823878d8f34fd25110109b4527d682b4b768d84840f10b54957ffb03652ad6ed18f577e78f298f7e47e1df7a4c13b9a3bba69d5045a1d612a9157db8f5717b7325c04267c19f87c7482e3803a79c3b27605fa2c06881ab84037ec941a4a0d9b805105caaa4eccc5cf598afba075745f9181179ade69afc27342b7ecb40ac96ef90ef68048ffee4ae08e81efc93345fec426b36ebd4d465ec1dceefee60841536ab0ec1b4c289b17b0b832f88169e9c6b4d8f7ea2cc181b3fb6aba651c0d2b59be8d732e19c871d830c6119e5087487326f9d9a97e1cfc6c4b32e6108cc14652b6106a733e8f882f18240b03c3206cc12212945c1bb5ff27dfd1cef8d41aca879ef2dc441a306c11fe886eb8dcde776df17382325d3506c75643537c2f12c08c8f5ebec6f3edfbe0329fb79df83e2210ccdf9cc8adae1091432666f83d99d016717151f2f518cb433d674b20cb5c9c6e40cb613653fcef7afdca3bc1cfe2e804a36b0ff1ea564a2d2a806417944e87bc50bb4e669191819242b6f721227654797555f9fab42dea203a9adec408fd2d417fb39bfa265e902f93a9e258e1860d4d65bdea632db6aeb3ec6b5a8fe0cc9e54d21e0371efab13dce1ec4633994ba6a282609d6ab96c7988f126ab5d919264e2862fbdcc5ab19b3e2263167a3fd6865c38df07ed9373fd475485773f59dadd7586486e4f3d2e656a321ac006dfe213403ca476ec366ab0b3a32aadb877b6e1e1249b34eaab905be4a8b82b909d7cba6fa2f5a734b1e599ebe5b39cf4cb1e659a82b7ad2fb58fbe5bc03a615ec96f06f559d42a8c2253685909d50fa17f3a0fbb6c36a8984b0ed284da115e7551f75cbea1c47643ee4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
