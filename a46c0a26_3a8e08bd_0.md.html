<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b00772d16fd76721a7b299da5dd3d769c7d811e67c46a8149ab9087bbf3791f702ceba33d80ca5fc636605083de672463071698d36ec6640b4f99e71e9c635d701a822bf903fc2303312c0f9ffd0e121be5e97858033b9474c05ad0cc3c4caff5ac8ffe1bb041e48b90bc91498377272e95f4a246615148dc42b9a8c9674f32370f54864dfd3329f91cff790fa087db03f16584e3e30900ee75a0579851f3ad3dba26961570243a7762cb6078dde9cc30b10b79ed1f3b0478036f177d496a5681c7a9cb19d6e31ad9bd385b6792de43ae0d0b4eb94bc5dd2c486014870b0cb0d8b05ad8331f1b95fb0806c6ff08e9b292f2f04ac6945f7bf972e391005946006cf8defa85d81c315fe28a9f235d5ca170c762b034714f2a4e919d0b260866726bafdba2a3b96f4054e700be1166ac99827503523bae5427b4f41b92364113cc850fb537c5dda9bb803a4ac34ad8b937bf44f2ce796931d2708da373f1f813936bd510dda4571bf563ecc81ca9c30573edacf41d2962fe4d23ee7f2fd38ba218c3c94a140c00631e913d39fcfa48ee0e04ff7b8c60fb493b451afeacff7b9254ccbb173f744312a22ccf49b010da202efe231b35c70be876bd78cdbec41bd29d6d78a49b788218d1e15b4cf0b342dd37072a199a601b5357570cb030ab7e20d3f5d9511200197efe328a0ac9560f293a92b71b07ed429455e2b5d6349b47ee3429b3144501b696c6f38d17b066e0311f188ab52ec6a286cbacec71feaae86654e9b4934acf0a0533c8744f16063ad48e53c6241c662cf9bc1dcfe1d6c002effd85e77f837c97cfdaa922756e48ce37ca3ecb1e672452bf51d97f7d31f00796a931c6db3ef5aa535278490dde629377971f004afc271109e80fb0254f1557151059361bd85e5d1875198d7b6012c261a45a140c94eaf39aaae90e3a08894686fa07a045746b34ec1aba2e61aa384cc2f8f8175771d1066ae5c9e7468a9ff80f5862f1b984ae96f33517ea054ee88dd2f6d0448e9fac30ce5b2dbf1b923dce132c90ef06bf9c5967e8acf71929365fd3d20df340f2cf4492870bb7cfaf12054d2b14772771296b06db7bc94a8b7a432e6280193a564b16ca7c011647723ea74e9c4952149e10c02b1ad5a638d81f0adec5d0b508becb5af5f60977bd8f49e5ee8c50bec93ee770c8685cce5e6abc90108531d8ff1133295f3e451aa9d44a2e7121691297b08c9104f166af037279c5c3045575d1a8625bddec9283b19840a10b21240d6bdaea517a99e4c0a1fd4d8f3453260197a5104d72cf471e82b613775ae6fda1974cda1ba2401ee3b1a6c5422979e8156e44c0ca83c7684769b31b54ed2bda5269b2e7e852f1f83e20754a81c3b61daa22f1b40f40fdb885b8c1798d7461d881183261c45a3c192ec43cb796505c476cdac21e9f24ac42aac50a78c2f8b63a68fbaac8e9c485e19f7d2acda2d52b0ce573dddd78c626e9d0eb1b38a6a36bce8448e78440a9805495ca6b9eee1614223bbced1c74323f70178b36636f2c9b355aea556e72beac79eb9d4dbe3c21d051a28ccf465f95a760f86f1f0c4774c961bc4fd320cbeeca2dab5f4db20574b13638e64353a446bb5ab508d5a87502c5bfe9610f4ee3c181c5e1cc6ff70af388e4596c472b03a01d231faeab411ea9b3404476e2b6233138a8c8aff491412e91d431e691b2ef07913c76aa2a9d5d5b448acc6051c2d07d64ff487f865396007f9895bc8caa213f4a4e2f1cfe5bff6c52362a96c2a63e62127de5bcd3eedb49c99b195ac793819e8627753ec307b96b75d9b3bb31a112103cfc30ecc975f7bfd9e543b21b7ef978fe39724d9760af6b7a858f5e895341e9ac44abe8bdde70301b8226a2b0b6d4a1e11dd33d41f19ff559f76453b51054e827bd380da40d382c8990924073e218a1f9821bab053fbf038eb91e4cbecf17b0900ac49db5b19a36c9ac41fadc0491729994350f417e7997ccbbc30cc9f4a0d8f460a8b6bd513694e9c27e8548f8ab4e8b64c0f0672db8f0d91b35e49a656878432252526f184f28b90f7d91aecd52db968f0916925d3cb8cd6e8be8801a405a9f7f4470186e1da96df06fe6612708092a4893d5b43057c9aa1ce58fc52c087f52ed237f75cbe678c46f87fa316ec635790c5e2ecc2248aaf5dfa8e6d3575a520c732be9f0eccd548e6e0c1480137e1b9d6d640c60bbe93fc3726b0271784689252d243aff8c97b0f9ddfba195cb084e59e0b7e7ea2322050d46cfcab8de93eb38c0b17964a2e7e1ad72f2ea3319869f7c8668b3388e8ba86d6c07928df492df78841b383a3552024937fea6524decf727ab0419cb566a7467b600890ecbccfa0049aa834a8b7c1e170c81eebf9132c2f10022a8217a59a4ca1f853fc75e286a1b6f204d84e7d363a1aecbba01b9401d6f58ef6adf0e36a1d2eda37cd405923bb3d41ff26ec060551ac1b7d5bd85d99f0ecdbac8cb1be48ea8b93b64a7fa182c4d6cb10b1fb173298cde2a6a784e2febbe5a4b7710eacb8588da2128e5c1a15f44ea92920d9e9578b23e8d94f7c70bfcd5eb82e8c1018443de4ac1c51ff6672e39360b1352f9cca7fc778b9224f6d73d8d13ae743f3597a21453be118b4bd535c7cf908a41b221ebf17e4939540a6d3c6c97fafea75ea4568609b0b469389eb8780bae826b316a75d2258df5398592a3cf511893fdcd21dbcc3a6980f6d2c79b506aaf50095da008e9526996d72c5f9fe69d825e8726b876174b7535323325916c05b67e3c58b2853e162afee17fddd1a8af4a5de76b82162e44c529c898233f73742df8edca85b437bb6ba1be63f1e5ba19aeced95659dffdc04c91771f3e4a3b8d9cbdb3f9710edeab8efc8a0d03517f653772347d5691520d3040ab6c1a7e8a0f592384f4cfe8092e016a11b9f9bdc7c657954f3fb195c0451e026de066b4bb4f9dd5571a04f82e94838f3f3a187f1c3cde664fa9d1b7fa470545c62e68b2f3e6bb0ea5a76e9b11b89489a150fb13c9892e16892cf407eb5153bea794907932c9455a5262d223fb0e1395d6e38269f5c0d9af10745c4575853d73516d6842bee3aeac4e7510b222be11c5c46fff763db7e402233761ea6eac83523711fc00d33bdf846b9f772fbbc59dc3c309887d68f13971b257c59aa617a1e96b62446f800f943f6f0eac688ebde65157074bdb7977490cd586a34bea0b1f676853fd0db73ba517d226444ff808199bd34584c8d82ca658a30778aadf6bbcae67f6fb8204c300c4a5eb169bbfd69c5d13beafb6646b4b2996dc62297766fdf505a07a7197b9d20ff92b74818129814fa69f48c8bfc4bde40ff742e5aa0e0912c161ed7ab733923b07e2bfe8e653f47bad8651cc34cf5e6d00f776e558969a8cf908df06181424e16c66efd8f5a4aaa6bc7dc55eb3f00da8bae2cfe242e0a6a14640234f619efbd569545ec78e41c207b1bf4d4d5db9531ad58dfb202ea35351929f056bf99ee7cea1e0f3cbbeddc8e9623aeb189d8b07ca7dff4002b2d433357047d7d03d1999cc457fb077714294adc0f3cf9f1ffa3b67838d64d10bf07044f754d4e6df34828e11dff254514ae0a1e85d859a38950fde410379ae9205f6c977bc6f7751531082ab17d2388602cf54febe6e42a4cf96a77f159bc5f484c71ec847664e1ed30632c186e356788e7a4bb9ab3c6f973f40eefd267c8eba26696294667301da1b06b9ecd182aeba11c4a2566480b3c9b17144df0cfe131e8e5c41cfce30fec7a8383ffd57a2d1256688b91e5bafdb89e19a25917c41a2c08bc78c16e71d20b8494741b0ca6fe04a0bbcf4d00f725359c92d31b65954c2ab39f38c5fa1fff2901d2c9a8048ecba1555f67c096e92e9adfb73593ab8a94d211d21c45fa515e144fbd0c66ded227fd0f3c6fc90c8c38ae2782246e25df61987f805f4acb1cde798c867656f3ffb3d87b8e21c4fad05a3393e2f5910dfba210a150a793573322386dad0b98e2247e46ca0cd600ba6d8271dc6ab3c0bf708dceb1a07d177c1191c41b74da85abfb6d63be3dfdd7360ebc060ffdcb2eff83ccbcbddcfeceff74c0d02584aa3fe9de83fce21ff933c08769bc93261728d01171fbdd59099b41c52c889f5a5a15d47c3a0921c958e3d54fe3b092d37ceb9040d5c9db408d42e8e8be2bb87080d92b1edd209e277245820f553df893ad939b56c934ed6375f1b6743dd4fde9a5d34b0158b0b597fdd9e8ed998b496f499d04f2a210cf3fd70a21beaf24289ebab575ffb0a131a78a1228ff012eff1bbc18fd382bea1442eab37e4733a5a40b5fd63074bd32e4d55fb8dd826516328e564e7e10dbeb761931b1347cd85cd8ef6b636728f64d21f3a3f5434f072d8442da16eecc34105ffefa69bd55241ae9e5dcacb9896eb3b836ecf42146c83a43c14e4b8364fb9f0bede60400f62eef2d1a9650c5c53794f4d383ab36d437483c31a54e859e5420c48ca36e1b74dc93c8c7177405d71823cea4f3a2a118c5b0033254db6baf37364485bc2bbbf079be91052065c7c1a14708702d08d6c69d61d94620431f0f15e3da2ae315237398bd5138b390f8bfc5af8413c52c18d1a4ef6c2dae0f6613e227980aefbef1558550d94f93b9d99ebb12a74cd49170a062d9a8e254351f6b12f32945dc2c119dccf5f23184146d9bc9dcc1322ef37c1a023b16744c165a31cea41f81365dd108dda8d59a6bdc6dea5bbb07b8ef0715e701c798c451bbd1aeb47d69dab5c3f694b5fd3546d01079cc980c2009e8499eb0e7c4d9c4f1e8a00de85882f7edfdcfdf14240b76e24035f012a286a2bff74a6a16a672c635972ebc56364a90a74e5640879399b0cd3fd721ad7cbd5643753820a53d6a235f7dd3bb2f4e7a0ac121496cfd39874934163405c9db249c9ddf17b6e027303b55437b25863aef702c1d16d1463f3b64376802b7dab5d34bd0e18e5e5d625aadd621c6046a9b4d7fd536fe61be4d9912dd5c22900c3534a3b4a5a7970bb9aa2d6659373cc4912d075380671e013c8877ee11a74b67658df7d90e56255c5d15081e7a9047cf8720e650a945f85884d81cb2323daa3066d0d79dd2b4e0d7c8588f687ac877bdc61eb7f92e1e3af0795fcf932b647c23dfc14d11a5c1f6175d5b1d3dd81634a3c6445a63559eb3518d63db86b84f0435b1464f1f8440e4a86bb9670f10084faf71a3257030e335d0dba99406b1dd658ea91d7fd6de4dbd697addafceb160c7b35f18b79b749fcce0ecf22da0a64953fc08a5ad8ee8969fb2e6b62f502892acaaa3b6091a652a97f8243aef30ede075ab2684dca5545ca14696966e7d66666e2b67e37b5cf79b61cff68937a2b8e40224e7fa5de4426bba30acd8a2c18a8917cb42c3a5ae61fc9875a0c5d28dfd9feaaee178e1ccdaf1287359befcd4aa7349cceac3028a08024ca39be80948d81fba32201459feee3949cca353dbdb191b103d133fa694aa526588a01b57cd8e312b3d3ebc224a52b77e2c44cd838826801df347fa1efdb2656a1cefdbdf933974f527322f484ce17c425f307eb0b6d27e4cff119b96298b96924af8512d53ce833f849a9b9648242353c080dc6c52657c121394e7ac3ffca9aba38fc8fa14637e31eee806e753581b25a6b2c271c86c53fba34ca1cf25b35bcf9a39d6b6974cfabecaef0a9d97e815f5150a219717c3ec3893f745b040010d1954d6f0359e99b3e2d5ae529be02158054e68166f57553aeba38d94c6c4173ec516d17df932d96b6e2c34cca512aed2cfc3ee4b04b347b23d7ec10ebd31326c66c6eaecb11eadd6c7dd993fcc0a8ae76623ace2c5bb1867075e564a225fc062d7ec7c4cbcd271055d53e7f15fa9b06a14e5cd70f75e1f940c5715697f6f0694533808b2bc422cd82f37eaa9aacd8b5352d0c471d86b5dcb68d273ea75b5eb9be720c81efc48eacdbfd254d8eff8349c32726871727eb525e83a140d400668a047405af6266741d1edce3284773eeced90950f0b60b0cfe6651bd86e42f4c81a713c4242dfacbb78d6b0089f6a0b11cef823d63ffd4a525b0a56eb828d318592ed886483b91e39e08c201226f80b55a9d6b48d54eb5fe526434714131a757ea131d28dfc3476e88a703a53c612624f906fd9105a05f074ff5cbdefba1800ec269d5f1961ce259e1fcbe32a831453d16ee21959893846f39ae3f47089b3e8ded99c69f1c6b878ed054a1b6904f2e034bcbfa14ea88cdbc5d64804413cbe63ce2bbfd16ecb5e1c7f71a3a44618a359b1bdfeb60efe6492b34607aa6db44c0caa00619fee3d2fb003eaf5e0c2350b6b8ee004bc608f84412903b26f981128dfd8e89d03788f2d317c6301ec2ebfef196f0c4e5a6d357b294f4215c2c836039ff138d131fa6c52b4c04196f4ecf8e253de4f8c2412d62c9e5aa67577a2e12dcd01826939d3286105ba87a11f6630c1996d50bea0ba780e01d2b7b0e236e45f012f7bab1c597c5de9a82791b86aef3627d8b63a93abceae07a82fe6cbca72a743934afe811341ecdcb46aaa597b605c6aa71822dd66a9e1600a93b909d2e81773e8e14d85c690c59cb152e29fedbcac1c597bdfe9d191a3af46803835888f86589df668a39e06f22ebfd19aab6f35869128efe5a0fb9ba6e98f555ac33136e3dfef86067aed0d1eef7bd59a3bdec1da288e69e8c22f7c8362459fd97f02b62337a6c4a7e03fbd6596e4a9a8c4e9e2488446321f8018137cb7eb82c29f56d54645c9c36704c9830e283f28ad9e15f6e4f8fcc7d41ef3c0ec2327a3a34ce3faad6a9f5e40e2733c7fa790d85d82387d5186f08adac5210e676b859995233652a8ce86eafe16136ffd32e32cb5cf41b3879ece23393f3bc608d9e3c09a0f5e0a10afc0237231fc469ed06151e1ccf1a9ba0eb37453045f59698c1b3d19755bd64f72e70a8435adf173b8270990186687ca385b7e7d0fb6649006d9fc484fa1c1d7ecbfdc88745188f139849e97ae04b127a3dd547ddcac4a29ccc2e2ed390e1a80d7c1726bece42dbab3f950d481fe1230eb6a54ee863f8e56b9244fb5c3170be8d9d318e71af5104df914d3fe78d9a4505880c9a4c4e0480a65e1cd21f4d7c199678d2abcb300cdf08fb016bedb69f29f5c9817f94ed9ecdb0bf9c9fa8236868303961f2e1b136e8b4a96592e898c349d89c9e46bc09a206729d5176b8ff7339ba908addbabc8c925c630dc4bbbda951f8792e1d0cd99b34bf208f8ac9f1825d24835bd69f3a914021e3664565645bb44c0c289ecb5fa497191b42471f3c34f1811554d9c12b902984478cf879050a9e2aecfd4cf8288672779de5bebe2a3e8f6fbed4df6dce294e96e6a92177279fbb7af4e3aeb0894cb3658d4194d1422d48ad8a08f4f2892a589c795362e4d5d8bee3f40f2e8aad09ec278e391f8b21776db24d0fe1bd3e4b62c9b1f6905dcae54c28a4e295cbc715a6a53da9b88f1fc1460d7cf9fea157cb6b2a54795b2bd49905b61b1528cd1f0ab05c314b7ba732b297fa369801d7bdc5dc064427ce5782820db987d97bc72778d3d288e0fa66a4a301e19e0dbe890aebfdb15a1d197219196d785e09b9233fb7ea56a995e64bab3dde281f4c8410ffeebff4de049cf46f0fc905d69ef18579f7206da4397656c98d10adfcf4c0fde8e3678a4014e8f956e3058eee6a2416892eee1bf2928c6112a26a282781fce6db85470b77487cb85e0b641b5b7e1723d42c0b62e78d0503e4780a50e529a0b19d5d25d9da7d1bf6b1f42bc7cd7a3a72c3296a057d1f4bb54b9f2c1ba2eb2f38c0c3bfff259de2bff32452ed279138a4679a4ade0dd60ecfd3f603e628926c66890cb8bb0ecec996cbcc490dd13cc7df831cdb6222eab6360a0560371673c52a937d83278bc5dc1f8dfb0d6d6c60d6c02bfc69d72f540e70a6f3ea5cd602d3c92ab1375084c2b609d3e9556e22c15ddaa66d7e14d72e285b4351392097402e20c15c088cd97e3b852fad8989db48d6d75a3360483e57371689db1bd217bc8e90fae2614a62bc2ab060aa0dcc321aba82779aa294502886618be6872d8f7d86d92a249484cde566af8d7b1bbb64f7e8807904ab429eb84e959bffcc7e59e7f8247e7eabe71d137422e3ed27dc4872380894b8336ce33b75bc3c29b93d22941dfdaded338dd86159d54195e524a036f5ef5c6d2db59aa0a79e3c8c04ef9827fd3cfdf504d7c9b93d90179fc00854e66b67a46b6aa71130952584425ed2c1012e85badcd7a59b5afe5444b7d3b5a7a614181244421b54fcff172c8b0c25f6a76937b9498d80681be13ed3464daa10615b92252cd7d099cf65170369ee5ccdcbc19ad3036bdcaafa55f414abaf5ac7cf9fa2a6da91e86ed2631c3148f76cc2ef211ab41c774239a635bf34e6a3cb55a690616043509f498bbae68d59988c0bfc9a9864cd6be0c149a1ee2c7feae031b10bb96aac839bf2160b69b1ab4ed34856ff63e2ea284084bf01042bb2d999b6257b897576a2941ed6df52f5fd685abafae5bf7276a00956da2df462a678bf583fef9c0c059f3a563cce7ae2156c11d30119e955010bc65debab2489434728ba1916f92068876cb6fb63bde790a570d6478437de7949a30df03cf54b8d6ad04feebc430fb7df6d4a59484eb73704473fe4972fa4c8459e9265984490250ef3d32f0196d951221a33966507860b251995e768129e39fc5b4768d906c95dfb56a54823cb66bb2ec1cae633630ca2e8b153a6026446ad51a9b5b658c6a08d236d901f674676474216a4658373e2f480fe050ac2392cff43951f353c33d4c49c9d34a7146fcf04c24897197f6f9a89a7dffb9f1667cfd04bdf8121960de1853b19e58e40abc295a89802cbfa16450261a190eb3ef156a09459e0fc3bfb51ee74e4f4a9529beee0fa0fa94d343dce42009403c9967182e082a73cbb09e3126521c16bb0273d316367b6e24adf57aa8687b27980a8d4bf91ad3f4d730e83433ec988823f8b9dc0941e3f130971a1bcbb7421e72a379a37949d46c04321a16988268c8da0c631c4355d6a6e64d688b29fddb13d09b79c2273d98987dc1376c3995878e47de70d175e0a8a23591aec0ea91131d1363dab4bba0a53a42c968a8c1c02ac67ee994e3944dd886c7d7918d84418243bc7d5b5dc01acd56c246584b80c7d8757628674f324e278fbf94bf03e559f015b8eedc2fa83271021e6fc2cd7b9e8420b95687c8edd57da81573957601c574f3d0c6df77d2f7bffe289331bdbf725ee20d3aa1343899c09a26e909f9d7cafc2dca74104f800a816866891f1154df6a1aa5034010714dcd7e84498d75280ce81a7173d64e123ba33d79021392bfeda3c31a2e8f5ad3f75d281374e2f3e1de6f772e9d89816eeda8271a871c62a6b0304bee9a39ed5fa7862fba637ed0f582f67fdc2854b83b9b580ad9a52d5badd7369d110ebca8c1a9948490cec61039e7c8e3cf4daec01dd5b97816633d094929d605380f7f67f1473dae6ff23d3063b9db52e75101dd70d4b7eb88a6bb713c01c76dd7550c88ce500448884718ad90c663401a696f032b42bd99b6c10fa2f85e485aa769974f72fca03a487d27f41f283eafdfd6c2fc95a0b320109341650d793d55925c62ee10fcc630cac7db39734e6c7ba8c03c199c362d25a37a206529f10418616180e6a4edd585783f80cc107a10d0a58f735b509a42c9ab2807e17ea8cfcd859817b2df2a1de8d60ec8eaf7b5fa2c3c00e82fe7dd3cca40dbcadcbe3779e28328d8f6775775a7a94f0a72f0bd559c85b2cb799a2843c096139fd42cd9d6e73db43d596a97841d8a1e18df07991da96d566b76dd68c55d4bac9b768ca6b4c592d2fbc7e2b5fbdcc664ae37e1d406f926192463cd6abddbbc133664c81d3e11b1eb50cef53d8c9ed56e79c2748f04bb91e63741afafe0a5802ff7c6d91d6f748f8e3873faa898f9a222a4d628605f80ecc66e610d7df2d93abe02354205a316f2c313a2aaf770c662f9f80e11718abbf76b81954016414a330ee0822b566edc32777babf917ac603f0a09a8b4c52d94783f85e9a49dd8b28f91418c48e155369360326461c9a44c21bc09ee904a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
