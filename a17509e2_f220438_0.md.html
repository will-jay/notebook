<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18155fd46186e475228d060efd9fa1907284625929b19477be72821d0129707cc5b99b9077882dec891eb59d9944316a7e4b2e5b189cd22bb91f3712d2eca98c47b21df62af74937f53b96ca3b7b3e47b23ea94162075408acbf07eceb592f944f9e6b7b472dfeffd6619fbb06ac5b8ff2cb0aa79f179ad3c1d84be32b87af825736cd97c85610f89305151a79d23f68cf5f0fde0c9b0f8f60e84678230686e9ab87c5e425c75cf957f6422e9b8981086bd72df3486787bece7e78d57e92c30f2e1fceae7eab9f65aaf79ccb3abbfd59f09347228b45a4e2e736ecb1422f2de4a9f34ee82e7ebaed252c5b57146251e94dd189684d85350e848ec2f7f1c35160b0ebeeeb0b69cd3261b5ea6ae77d7376baccbd542410d1d36a74eddf96091dfae88e12612b945a64e7a522ae32dfe7b97d8f092ed8a99b30f7b5152a293414c652ded166a441959850b94de70d77e63ca579c74b61d110c648b5f37430639951b5a19ab2a7f7d65857be8f85baa819b5d39c415e610bf0c5d5d1e4666ec43762cef877eb6cbc1994715f4624cacc30324a2d44f6002dec81c99db334d640deab643b7969a2ba859593d157a1cb38bf2d81fe2b3459d4042cc121d5eb2eb7c0a52957a0cf2b0d0b57408af1661b33ebead4a8a5e6826d6210753f1e7ccd2dcc5158bbe88c532f668fa23a8953e267e86615072442f396b3b30e73faff36a728fd25178364738be82645d78e6d38e2d554d44f1f0648961124ab3156aefc3f6de099d45f8ea2bb2934fa10c6958816b86484c997a6dd8bcee8eac751a3ad11ef0713e64610c8f2b17476c66ec620badd87fd85ebb2f3c010ed622a0ab60538968b8d0b0fea28391ed1f948771a66773aa049cdd1d7b32757b6dedad8cdaa08c31eb6a0c9f9d2f6c1a24fa01df9d4445b17b5eec48db727143a97aa4b3da6143e5e30a19b078780b866524805c23360576a0219af9e5e9871e9058f71168e8815dfd7a65e5ba4eb40fe4e74f8f25497aeb0b29cc5a8648a7c10a33ebf1b6fe356fe1dfa2d897d1eeaee1e83a96c523418046289c179436fd6a7bde4b4d1641138ad032edae1acc019d996e50fcacd56bdd51423de80ec7d39273dff2da22595571aa20cfcc6f0f635feb616769ed8afda88de2a2a6714028db0444bea25403c4a8a5ab76e67a13b6565130445d40ef0a08878b86fac7c8df07a8217bda782bfae47b33c8ece605514a0ecc8485c7ec6cf25de65906ae98b31eafde5a13b8c3239a6b747ab837e1017ed9000c2030ece94b733235d1f4e28edeecc668db18050ec3e873ebce5aa490d89c8a1381af68c6ad5409278224b25e6d85e2a73b02635a0d8129a6c92226427aa535cc52f6a7931f00c997e627f5cb2b1c6363a05404cf213bacf2707ccb5732a69724e33b391a66c0f3363c958d6d712001f6e30ba1bfad7561deb34d34aed73948fa957d9b9cb189968bb55f22c787306ce385674827b0c4ad99c9dc79c9f47f9d72ea7dbaf92f4aaf77cec11997a14ae0179b944a426103ee1df5d023b4783ed5452d38ed2076b3f8552989d4cb404c0b3cf61c38b7398f06b105bb922d2f5a644d1d6133b6b6b98a7715da878e8ad1a9dd90a23ff01720894e3415545397f1224aed607a2bbf740253954bba65858f314c988178c01db489d568bc6a034dddb4ba381a516a6c8d0cea0f208a45e0c0d19705d4119fa91d1d2e84c1fe6e10b83cd3e3545ce497a7f0ecffc2f3b0365db4aa8932f69f749db56e478755575b3cdc438d4dc704c39ab829b640927cee391589c203b95f4bceb417ae2fd699ef4fdb37eacc8de9e3d3c90e077bd7f36957c95b540cf8e6a23586b859923abd6ce1a4258a180a2f9544db2091793da9a8768815d23199b74f466c631d7b0a0f961b7e205d0baea51c81b8ccd4f05bd7503be941f42cf8fc4ab698c7801d3667252ed2d0981e3152dce3c80134e4e0330e12fc8ebfc211088e59af04565943ed32379ab3581ecc01d607a82e0c1e4ad332af4652d3590a65fa8eaa4add4f632f70e728012f6e1fd2bb8e34717111c254d3fc06e0ab73e1c6bb4adbe9f44e5e19e2bf78004af0a1c18ea306f660f3fd30a710488ce5f2adcc37f8ca364836d99400aba73b935fefd44cb8e5fe6e2157ee5dd18ed5cd706d4fe0d7baac0c056c7a5150d3ff3e564989ff4271664ba2b6a43948812c63029039bbf2ed60a941e9ccf9b8d27fa74a57ce0d03ea8a126aa00c49cf405b39f8cc07e00820cd5ee33160034878b60b88346b05a22b2934492587d8d1e3a0179d89dd2c2f04210ff8816eeb01f054b3de45aab18a7ed5dc58326cf26d7518be191cd0cc67cf5f7b93cb2b03e01d093b1c1dbebefc9c38ff9fd721b34b75947d0d240de22ba6e66c5b24c34061233127e9b1b03887d931717833e66d42235d7b4d1d319965a853aaf727ac88054becd40bee9cb84bc169d989de2b14e5798d0942e003a67765ca24d01d69d8663287bd038235c6e1dc1e177606f97df03f4c4bca9b9380e9c3adff11c4918dc64e751ad4d9544513e144b1776d27dab6f1e85223780e146338ee56665e003730ab63a3f746a4c599f35df0dd883a009f1f825ae38df9db88ac7c7b9b735a5aa3a0cd3409c08ef59c94de5f71fdd1a5b8d9c300e4999e456ac4dc518e56a3bd4c68bbaafbcba01122e26bf76a84906bbeafac566a6c21b6597cd2b19bc57532b05cbf0396179977a796498b157b6019170be0c80639cf46c23b3c6ee5381b28a818b2fbe13b9fc18238b36436b4d091e3314aefcab7045a779cb3d840193ea99f2b000069972bb651bd9e81acfbb2d874773731b5e68c1dae65917d084320b0c387a669c2fdc424a83e0c42115608816d71e2a32224fd2d33017149ed982c3a7e94373d90859d767e66bdf316713c4654f9621f4f872c76ded66c2aa66afc359c7c55cd79b04c61d763cfd68e2208af8c2207e85a1f56ade32b334526d02390337b0d577515cb8aee0708cc957e576b595eda9ed281021189563776d3d0f8db80773a48cd44075bc8342a5000a41bd399304acd6b7f2cd9f4b87a7facaf68045562abe0c5c639946309a88d9e980d603d96c87ea3a3b5f635c20b47d0eefc06c377a56d55709fee09ecf635d8e1e29ae06758e7254ed9a44d2499aa0a4ed38d07f61caa41616e56f5ce6f13bf8f158acfd441fb8e5e889f47c3e30c9c14042829fde8c50efb0604921dcbd60536986abda0b0d43eb10bf2c5b7f87af95a3416802a82c7a7a2ea22d30fe8408fb0a9543f9435aa3af8dc7ea485c5ff42a1e52c350647123597dd8eb003085e8e88d3e0af53178c534d00689c7f929d7acc8ed729499e47554fc4f53792f52f25fbdb4481946992768845908e7196e1953fc7862940544263c4304d4b99a6624f61cf993a63bfbfcab4689760fb938d17818713f2f2a0a53c05dee9c96a6d89a491cba34afc13be45b946ed1f73facaac9402476b14650f8fb3ac968f3c3fa585184ae4ddd40e6c4f86c17d9a8c4d56e36324ee1439c8e2b95760d083640179af7edf304030ebe66fc20b669384083c45f56cfe5a2f1a4798575c8f0edda5d4d278f0e037873c4a287874888fddfb898787eab2b10b05fa85807abd07e8ef80134893576fed1fb0738695e3a955bf602551ab97bd67515e3e8689fa24e002d975acdedf59346590757e20df8743000cb7b45456fdfa33f13d944fa22b761197676427b8d976dfc92876d23abf343a1a556d5dd671ae3a4f29f9aa9211289ae28046538e5f74d76831d2404c8b1eb86ce662f3fbfc94d9565c2b267a70052ea602dbbf30dc90c2e23b4e261eec3ada24ed83e9cc38e7b22eebb00e0807aa414a2a8a32018ba1ab0a9273b341ffa5d11f06a9f88141d477c8e5a5caf04841f8ede8160fbf403d2fdb6d8f6188f7bab58270e6746e06358adcaaf8081f1da06e052f3d4f1103db081c82a7774842dd0fb8ddc80f4c26666e7851dc76e12e43c99b43468674ba6d5134f36d13d0a32fb7387fba52c80cb41e7a79dcd758169ee245b52cda62ec874ca0763efd4c6a4ca504641631ff2e44cb7dd93227d7a3575de9052f1db73af3dc9272ae6fdff8c7b79650a5ed76471a835fe63380dfc92686374db8992b9e4255f651b9d61eddba0d7d25599a6224f971eaffd3ec799738353ff452e65530251866a66ac9d93026e2f75a63483e40962bb2806a91a5b5279575541e71f2ad56d72b1c77350950729cdda15d38df7f5b3bde966670d571fbc38711fb8966b61091ad12f42139b732c396f5bbad5cc4c5c28a27128963cdf032d2e5963c15114dc75c02437a889ac6f5f11a9f638d6452b398faa994c1c2d9506a8956f3f2a352180e0f2aeeac4e222ad6b589c1c038c1d9e9b259ca6527bcc4df575798cfce6b156d99aacfc38a63b565359cfd1fbbc2248fab13f07353fbc4307281a01d5103bdf1e79e5b2c985b6c656457d73736c467080140ba78116d8ca9f34ee1fd1d2b1a9c84b42b97a346216f2570d7aab96ca0069a995873b34f73119cba165312c22b727ea8834528a0574b0426e789c94299fc05ac43d613973e0c8687fa02f27f30ff8c90579e83553576fd169481b2a64e9850904a731308f56b33d00415e0703bd204990a15c44b761c36f76f86c75124c11eea4018de677b836a54cd5ae34206d35b31ba58bdeed081d754180a99b2eb310b7c78082fafb291ebfc186e9045b18f12771fcfb9297e93205636951a02d43648199b1ded0fac54f2fc4531c91074c2215242b291fe205ecbc3c5654fb06310d89c4c280be5e5349a593b095df02455f341337264884f6ed71c743a34ec736e37a642adbed21fed88439fecb81203b6c38e88a5e2462d64f7b2165185bd59dc11a478c78239534cc55f8a2c8b85485b17e78029c4813ee2ead47b4553a31c54fb9296382894c5b2b3eb0aef657fa252774a35a545ab39d9a3a34f6094d7a1ec45e54adc5f98b540be102e44baad732fa6aa85e585cfef9ddaa540739b119c1bea62259a64613d88162e14cf46b10e838e28ffc099491321a333f7117d8696258168dc8291950a1016d117d968246a5a86d698f90452fa3a9f01f2f20d332a9efa043ac24aeeff139218b8b921d153bf5c4e6ca27ed4fea1c8d39c89fdfc7190e2ae3d24692a0812ce41a437b8e8258c726a02501b6653a4ef68095fa8c76700166d66731732c80f6158966743e892141086db7e7935bcbfe9530715ae50d8292bb3e244ff96400c8e6d91ca568ef5e312570285daf5bfb2d8076010b8988df6d8ce4177ebdc91c9902d1d0bd0c3339a515cad9f4578e1402e4035557a216d9ca044e19c88c144bbb0b7e55d5b32f2dd30054be8521f8ba42f8819c7fba6594e5d8712938b23f04d13ec6993e8c0f156e9bddf489bb4009461d7b9f2d2c249ae611c6b1d722b5fcd015af592f04c5323a7958ae9edea2cd7b6bfb8e2f2046a3a5a3e09a16cec00113670fda5ac79b8a70c0e5ba743189f2da83082407cbc32c5adc66332668a62d0fe2d45e392901e2daf4178d78d84b7e806f1719f2d0db2ebde3ec4e8d42046de6cdc491d5b261f59c70933ccf77c9c7259da6b871620742a06a4ef13726a384a74f9d148f40bcac136da3a192e08a7effffe3c3977c5ab8241bd83f7b6e3f9da6ea90902ca54091473ac8437664bb027369b2a626f8be2f2ad3eba29c8d5b1a31e019464839153087b24ebacef9873781032841754a4bb6a80a03f69827297ba7a5ef9dba84a297051f4c1055717257bcf181698c236bc6a559f195348e0f239ad58e0dc2dd54a398392bf43316a5b792f87fc848b341d7753abe9c988c2275121a54bdfdf2597fb7a0ecf4a6d78615682a3290dde9fcc7c104b0790eb63255dcdcb5544474bcae7014e3ba2a999e7a8b69616f92720490a60df19d9f23c17cdf379197403d211bc896816038959ca516b8ea6601680efc6eac0271789aec9a4f960d655aae75d278ba2b1fd57c53f7c982231d73900a6107a3f2813c53ca16b7ac29ef6779447d8ae7e02351035e18e39b7e6bc2c7c08243fa7073a8d56d60f8d706d65fca56b7ba9831d6233b10c9ce664e7fc8de07b9f6f42b00c7f5f71e98843bdd370f5c97a19a1cafe416d365071b663d0241848975fe29f24e5d388c76a9f39f19033edcaac9958378861655e33e01caaea2613fe6c2c25bcde34c1d81ce13b991c7fd9fb42a9a5c377c2dd6b328b1ec82996abc756ca48e0a563dae0449c499b433a092cb4fd9573a3494ee8820c05454d7aeafc9831d89274160bb9dc59a1d9d5aaa60d3100bc761580fc3d4a283c0a84a8f838059e1c9151f8abfec3578f0156f605628e9dd43c7b8e573819ffbb3540df0cfa49cca2d55bacb8403a94275d4a105ff39a7ea9bce30bd44cab22a756302602bd3662700e4736a91a0d341fc9650b13fb10eaef026bf05c2affc9db9b5e00516ee2dddc9aee149f465aaf4d332c72d6e19676ba555ad7c6dd395943d1420b7459882680ea9cc8d28ee1d8ff7fda23d73a61e1155779e8cad26bf9f16a80b62241f618e4e71a80dca86258669381f3df2fd14c49b640fecfa8ba262142cbc9b69d6dd9f370f8ebf0b6727cb24a73351900addbbff75f8c5944ac7ef5fbc99de261986d679bb7d47710a6309018eba16fdf34cd8fcfb1cab39ea0a3d0ac762d467b0227495c603a49cd82740978fc6be6cc0c095da5ed3db22a336dd62b8fe3aa3272b609de9fee842f10e1d4b0a6885ae46a48f4aa124d44dc624b2ac9bd5fc81a83893bf39d7e778ee9e9d8459ba72ec3f2dbc2804dc6e74d7beae41169cefc5b6166a8bff84f167b36de8b1493b35efc828bb986d8e52e52a514a784382e700e27b285cc24e44db30ae84a63879836dc878b89052e70015103683c4e820c411858cc88cb390aaf01a4302d5a54fa0cc9d4d4bfbf26a1bfcaa542b8bbb473f8b6b200f0931f101f2f311d7c09ab0adeef01504661f333343b2ec589b4f16596decb9e7df453d43d63ba5e15f701913f43639aa63b08f657e91bc520b99a786c79fa6efff99eb25c7c0e72edf1b11d6cdfe92e0658bff662ac819cad795df67abb1daa419ab805a8b776d50590bab4b38d93c8bd76c8965957122f1b85a0cf411080a8e10fa969d2c4b303d1343d6b333c0671070c91126adcc4cec1ec2ff5d96728884e0ed032c336d011761f66947f9eefa1a1d3d79f0f91fb58cd7c706650cef686277d3937413b2555ed2478a69da98a35fcb9fc13eb4f4ca4645fcf4b319eb82adf5a0efb9567c7940a722bc8c8acdb80cea7bb052909e895a35f8425c01a4be981af93c00cfd40aad02259b217ed88eab5b9cc3d619efc5641a06cc5747441cabf3604e560f1643f176a60e4cde74b3b42d28b4b7cfa35e2bcaf99a96ee72888cef3052710b1052262bc7ad6cc2243851970aac9596cfe73e54a754665dbc33367ee39e753d5ab71fac00be06ff1aa2e4154e142ec6078ab42d1b42af094a1229045d6f041e8e55399b3cf759dcad50f8162b67ca8d35ca64918c377a590d7ba68aa56e9118b37947fc1c3808c64bc68c667987acecc8e8ead51cde7731cc03cf1ca9a38781846970ac296d925fcffd0357c7aa0a5a494358695f8f5f288ca38e82b8d0ef6a3130b5b07e4bd4387c52db00a1f7cca0b1b43ac62f28b3007e42ceb9859b6c7784eff933aa07fff105338466c8532f8a049b1a6ed95724c0fd1e797bd3cb0dd08be5a03cc232f821c72d9b9a773b94461e86c094614c3d3721296c5126b044d49edb8bff881c4c826671833f01284f42168e705c0d0478f28d454e2dfcee89210772225238a8c2676f3d75cf7be2e2d3822fb63fa2374f44c215976b0541d0ea858f024d5c44ed172d86a2a191a4d1374249ad9509a76be497e7ac324ee654235c38afda428841a8251473b855c75eb57c725c24e08e58ed532cb4c0099e204bf12d91cdf63a4200f903ff1ac8e0f5c12d71d9fc1c91ec4df353d817faed45ba279b7c672680acfb80a91832f0619f0fd89b45182c1df692b0c6d9c0d8113c95c47bcad0ed8c02f24acb33ca0d948e389edcc7acf87f8084379b44c615a3cd69b0989540b76b45c9d6e96a926a446caf84e2da4654d2c97441cf0a54781c28bad11929f8b78cd9ea035faf8d6ff8d3c65786f2c5016836874fe6915e4a0e6544ea2d592dd4975a7df612da9c8a9349e032c1d1d7447ddb87bba06cc187ebe143367b4d56aa7fd72a00deca90c20462d17249895816a51ea4373af6968d63c350a3d702ac568a2b450d86db642cb6d009b4ce3561fa6076358623cefe6648379af23ae3dcf5b6ec99b58e1586ceb2036f5686ca716c02738e801ae39f911310a2c234ab1a5b6e5b42b40de8084969bb9d58a00f5f540dfb3d7b6108d2ba259cdab160b69e11cf8fd56b52bfa288d1aaf207fa6186ddd0fdefaba6376f59c8adb36c23b46098af687afdee11bea7e983ee91fbf85944c573c6f370cbe562d201add46dfcd2b2a4c8a2ad4a626c77e95feb9b25c0feb4f01aefba4dabd742aec6dd3fdd8fa87ad64b60eb50a2b238e64c687693868c9530afaa6c21b359a9612959c70bf06368fcad4facfb206878b67dbe86859aab71e6a4b59a125e1800560d827a080f551ceb7895c00fb5f7be2f5b05145edc00ef21c60242937ac6e0cd6c74a94972037f02650732a9b847621be41c9d8f429468b33470bab8db5ab013882ccf29aeb88428ecb485d8aa702c9feb1605a511140db952c614d8152a27ee16d4bf817e7851e6ef0204cd24c1116096737328de743d323ea49077f0ccec3bc16ec4d478e1e8c4b02c1ede948adb8de331d93ef7fd65357e9b30f4a0f4c61ebbe53078becdf2a6862a63fe1a9d7cb381fdaa449b86995722b625acbb88050aeaac61905f23fcc0d71cb8f17b04c9bc8a473ac367491cebb0e1009cbf3b879636b37c453722a8ae2d335e6f4f6e786373d574cbdc76497cf19ce9b06a8a2c543ff32ef71906e9549392fbabe7c8b4ade37e3247ba44c56aa8034617e4ec0de796ab584b9faecd3b164398b1a2f13f10c447f1fe556378d3b2ae96025bd216fb47cdc3a0da54628bc39a8d6388f7b924346799b34d7a73b4c7450adabe0c35d0e30426f78468cff2c0fcb4ff1b5cffe7a7ada15214218be6f6223c9d000154b97fc60f248f8ea5353e8bc314b56dc2e4792c38be9e4a6c1e0ac5a890d586aecfd46e9f1cf08127c7f7e4efdb0f62816e442c0dcda2b154e09f8239606e615e12408a098e1fe5aa4afc9aad4dc3922c47c5ae13743494231a45f694300cccd804476064fb81cd56867aef04d7f46093c359838fedf3aeeef3bfe18b904b0b8bd6fa44e0939f3b03d92c21b729dc61918326f721c5c82f21032060223a01789d24e3c6c0cf5ef9f2cac7c2e69b416be13e4aacdcb368572ad9f759f2502c094afc1f91fd352ca7a5106c1b041787fb170d847cd08a211dcb1a6178edcb3bd3e58c5be87ffec6959fb2f48ce849a3d1399ced2694e12f86608ca117c5c9b2bd4833dbc8f75d88a50cad22ded180230fee9b58eee7b4a6ff2e2d80097e19cc7ffec5f39272a5f35a58f70bdead922ea6874b6b618f4bda134d0e40d6f2f10e7fcd85656b3cd02296c4fc76dd469dfba3160be6a492b77e7836ce01d7f981e8572c493587f4607131957c34e70d87164741f9a6202bf6c02c011eeb17df89e7cc032053c9ebea611e92a5ff9a2e21cbd7c8c1e4a5d3c26de9b492d200a5f96f02f2938b3c5d2fa7dea1c22148e05ea813c385fe331354451b953e79287bd8772256c3dae7329053b671636d7b9742cb443dad8514abb40704cb19d4bf977feac0b565dd2d696274c07616b82c3f70aaba5f62a75685dd133c326523caf1e661c224b4211fce25dd453e3bd63505fa3c2df81b178a231f7db37a31f012dcd6be24dd230e0f1afc49dab228113daa6b8e41256e34abf544246d175d15d8a6ef51af5dccbd6db50217a2902f99dd5aa9fa19fe1e1c84399c5a567ca4762bbb1418e56ada78a8431ce5f60e175e18bb2da1c021f7610c32165be9b7808f7e80fe6772abfc0a0bebe8b83c50d85eb6818bf5afe900e7e62b94cfac769c7772b8c3991642658e09a2ad4e35d1772a1c0ffdd54f7e4b7c59fe60ab07fb887c6b32d2f571f1e5f7efe1925c7b159b45cdd60b2611701fd5f1b195a1db71ccd0bfe2a65d1b0b526c5fab76ecc6ebe7af603c1749842f066a4b637cfdf34e95a1f19f4d35896b7e1231ed4a73e815b8c10b3504c67d12e4e83b4c0774837b70b883861bf0e9528006225cfa72d6b75bc3cb3efb9769cb3317a1768c9bcbd7a72c09dd0beae6108e54d795965e397e81c070f8775ca731b2fb32743b53a7947ff811904fe0be3bcf6562ba48535d77cee8ea3746909a6cdb83ee48a3ffcf73a9686830cb834d450f5309a6fd8cb38b138b912a88813a0cc0e6b2dfdd4a14e9043244e9ee4b695b9f3bc336145d04bd286ae27aa563ba78f16892fcc33e20605fddb4ed50e77a315b6f5eae2313d34e0911c85bdaddc0271d576e213dd6e6391b4c07549310cea2ccf6f190906f972503b86a2d01b19d512d1097c49bfa7d8fea56b4f742d22e57c30f0d14826c14290ce0cced91aee9e2120f239275d0b88bc015e841f12cf21337068a953624e90b5d0ea93b6b2a934a436815e040a6a25ab47a04828145871c26a73c9941c46ffc39085803c58929a6da011efb5e4d7b74c2720d048e20bfcfaca9d2b2335b50b9e3a5afb56d91b43efb628845fce0e94b577e2cd94574e603c7ee225497237e4e08f0a4e5f57512b888ebf25ca4f8be1c862ee34e1bf865759187d71b8209950c8e1f7d0ff13ca069f46237eef7bf58cfc0e005e3314bca3e8dfc1674f831fc5af196d5ca9e13d513c9faa78a64215190ad9dda042bd61f2703d8a0da3378545370a07e7e1c2c73fd95f0d544798240f77f04d54e2587cafd628cf0568f31b96dcc63a4f535d2a36662dabbe17e8739fb587abf0875ab4d09f6d40ad1d78ac02971a3ede4bbf936247648cb4c1847d91fd71bc10bee2100f8ea9223522161354e20f4d6660256b30492bd7de9efd7a9843ad642fa7fcd10760a62240a4184451658d2a73aa78f47fdc74b8a149e3aa2c7727220e3fcc4a0ee549c4b4cbb0c2a5fd49a32304544e3b4b9639347b82bb5f0ff7f89918998ffce01dfe29a068f62a23fc38a18a6274796d4997285956ec16624110c93705e1416039d880a824b4f9c21cae620262bbf3d22c9ac13eb5992546fa4af78113b075930ed79fd879ac31f4d1399df71794bb6f1070386e9107ea87d74fc75f978f63e51c3e9a5b4c8bcd39c5debcea9f195930a714908637b7eed22e59bcabf228eb3bdfac934c6fb17c6620cb6530ffc23027f2dd84986a70524d38e54d59322363b3691b74ddb6e94cc67d0ff42910dc9231bc5b2c5d87d7551441f494fba0de027c22eeea25688daea73ab45b3e918a641c8ff659a719aad5b119b3ef37b2ed3ca626daaaec870a086244a8863e0675c5f7d839ec619583ee247632850787e4686f6386b4a1036470ef7f494dc4236c6031c98ba6d604f23c188d6f3799c5600574c6416bc89040f5852ad969a0a64654e62d1f5c71057bc13849e3e724cdb79ea33a61578c6da41d82ce626e108b894aeaa6f7a5823225e035a07c7b3ee397e23964f48dadc39df25f0c49a7903e51b80d7c49354ec366f065c379554d730e569bfd087c57762dc6f7b34b67f3cc14db533c744ef7a91bf016ce0fa53dbc9ae7a52a4bc701fcac32c905838d1659bf382db699def76d03bc9e9258b5e87b4c6206e72fb08462bf927f69357728c33921a54946454b7be9c48244249d30e6e7e92cfe4ccb063d2d319bdcac04865c67af892b1247dee11cc245b5773e56e7b893bd399186ba68ce638235a1189ea154de0bcc8db55dfbf75e5d842c7f5b9aa7077f7a3474ae2b8ea89629c85e2559f821206d12552ed1cb7eb1e7250d77138503ee6207777654142a433a00dfeb82b9c7ff6f6c75be011d556d18216fc09e5fd4d6514d189c5414965364d8d1425e192485a4ff2dad4457b12ff4858267064be5a11ae50889063b0e66c2a323102172bec2278a41b6f60cf21b800f02056942de10e48fd12c2556fbb7cd4bdec1182b0a618a51d8508445d8c10b28b99610bcb6e7e4f2889e2966b6d338bfa9000523e875d7fba18f09dff486e117ad0cd30f6caf7d3b119b569508b6bae8e0512d430c739583c91b34b33bec585c34144f7d592b24b4b9457a2b2808a0e351e76d5a7b967b2488ed196cad4ccf9046d6449e250d9cebdaf6c5684cc5a2a3f5c75e0f88398c5291a27a73eb948bdee5cf2c85a3c403fb3df8066861809b2b1fd1be45304c41af7026f8efd89fbb5e7b3c3680c9bad8788c6e35f65813ee706c81defa81cb0ed18196dec7a1b9465a7dfaa2c32c9033749a89cd0972be084536ee60869d9d6b4aa4bcac0a52b71b453def88be5a616f42bb8c736ec4535d3018945d93c09bc4a9b6aadba7db07fb455741321549e9b008c68110a8ab6f992779a229e5f34099a932559a9904327ff3474b78da5a69a2a480ab988df0453354a8f8f7918a70d8c270d576b25a5dc715f47a7da5ca2ce7328b812c455245aaebad64eec16348dc6a941fcf0d83aa2e21d99d7b05139980412bb10839ad9465195be194ccd2b9c5ae4e1e514ce1617a19e8aedfa9df0c9fdbd5870e0b0d1c9354e5486430934db95c01a7ffe30ec3691211e7be1afd33a8bd9a737aa12d5db932159500c9ae4a72a10fb9adc189e409d13206b1574bb45785dedba98b05de9f99e73b45ae5ca454aa00baa9f05393caa48d7fcdcfb3175f6b805656eeec78645e81dfe3506f8975be415c2437c300d493db96d324fd779b0a2f9406271a7340b25ab6f7875bd0f2d0f36429a7296a966d8298b3ce70d53d09308dfee66308a519be723c74689ffaf03c178059e6a5473350e56295da9e4d652f1d44c9ac85a693cb656fec18d7758a24526e06b2c0fe67e2f234de65a2aac26d901b2c38293abedaebf10c90c5c529cfca9c7c9a62f7bc47705b1b732eeb9afba87ecf263cbfe3e1ea49e9c7339d1d77d1984ad5758cb1feb232a77308e87b11cfcb8f9b7f838903eb7ad22d9a0d170280527ace690b3b51a3ea321eccf189c58922f3e6a0be59b434a05e07f841b3f47494db9bb9b8dc95b0ada7732a8a57af4d3d8d00d875bd7c827a2ebbb7c46dc5e7c720395a1d4e366f011913738bd1d74879c0a2a5a154e0ef4677a9912c54ce1a4b3b7fe5cd7eec66cd6d37b56bae1f1637381bc47a475d90e5f137bd2d39a3fc4fb0d4cf4f02c04a3e4e7cd0526bc6eb6f3b0723a2e95a9c20e774944f825b669681e2e2eaca16a43828a986124ea3b3d08a100fe8dacef6ecde4a30f5d92c5ad8601f010b6fd942f72ec5385e41de342d41c6119bcee4abc1ea835ad15f440d7d418960832857724a41170374e81b2dd8cf9e495c04278c8363d6081129983cd733802d02434df43da1becbbc0172fb84f608da99e914e3b39acd7fe304ff50e1d21d7dadf6cdc0caa4f1d0f530517afb4178c544994a666c4f79fb1835aeb2bdfd0ba6ecaaf6bcb85ffe08a2879448f4baa9e59ab99f7ef289c28e385b3f925dd94bb6e6fbfb52813134b4e7deac810a6e22456ad9b7300593bb78a60936dd76b4d1d49ab7822deb5b476dbde099e7e4fb2e6c7d4693248e452c39261f715441e8a43e5089c1f57e05b853d08b6937dd743663a52b43a9758c2942ab86d6c126cef4f909fcfce9c841cefb3f1199ddfa5df0e1a837fcd2db784e600f904ce7a9565df3e6fee94867270d556910793625be43839e8e7677ba223bfafe02b4408f09943b1a5434e359841fd980b9fc62e1e6953ea256bb66ad008dedd7ee6cc08195b86976a08f6ed25d20f157972d0e411fbc9d69a23d5bb57368871a46f071d3baa9c730b6d852402f4cf450883fd53832b26fbd8fc49cadf1b7d2f519eaa7603947e1a42b93aac6835a29f5ea77ea53957ef07a8c192b660691a187476a1e9d76677720820d2699908235a5876610f1b9aeaac220b28aa36fe999a25ed39312b087091ff81b9fd06b288e396e85ed9586e27d1a3ee3d94a2bebde24aecaddb4bc6c8313b88277255c89d14247ab5c008f801aa4d2b24a4afb73ffd98b89998cb49c05c931aca9c2f9b29ed6d848ff5e434e56127a7c3d583b4b1282bc65424f2f6073f55d2f311099ad0715fa86d9f7b0e4b1b171bb6f15d28f9fa7fc7cc5dcc9a90951d1e347bcebb0d27c20532ede1acc51336244fd09f1b80f7a9e8ea2fa2585f04fac9d4984de4172cd06ad8d3c86dd67e069b2763bea78154dea26b4d7e3ecff71acddc975fb3335de4364d29119910e8eb0f7832e6dd016d0c4c8686cf5b633dac60317e1b6ef91c301399903ecee2dd9a5699ac8ed96666ba52c5800074b1d1d1c5b5ba0f377d7a6e144e69e15de5bcf24ef84bc9f759e0c3bcb4f59edb06d73e4609dee7e1c9d24c632c4d39b8713e04bde239ab89516634c84aba48ed675f157db258be4c472a86556a078df1c171f974d5b39d8fe739d63443350fa1dad279caef5a3552550780b249db6302974581aaf3728feec1eb83ac71069ea85aa452e9dea97e476ce6f34250b9ffb49872989736f9f28e6c442a497034e938046ebd55f327a64dfde5890361f9f418723dd964ca1bce8ce1e2753c2fe5d5a5286d4711fbc6cffdea067acf967d1a546c9adcc9a0a241ac49da4a0abb661158a3f799232a68b68a38ce63c0bb57204b9af4b13e3345888d0eb58645b3963f879c61fdb256bb07e56b70c5f25edf4e6b4f14eac050145b39c0e22ddf7bc0b64e6910babaa211859ef97bb0f6fe7a383802a652b5400833ab9ecb16e39ce491b094ee471093c12b8ef6299efad3bba6467f3fc65eca86b2cc0b64dd3df4977665b9fefce8abee9e99dd6313aea476fc72d49e6469855f3cbbca7b47ec0f7d787fcfe8d891a8f000202e98a5cda0d981bb7635efb88f3ad7aa78dfacf6306b35bf051555e17381605391257a56717d26d353f8c3b584759e4d66fe5de964c9e7986c58baa700677ad589d77c3e75caf596ee0b3e171ceb463f592ff42fd4f63e638d496d15d2d064ef27ed55e7f89eae2adacfede5497f46df805423f47c91059a4cd94fb1d4e7036ce2446cab617381edcf4eaafe2119a1dcce85a6349783379e362ccb952ee91be17ff51ea1f82b40cc744aec9b780c8f2823d144f5e36ad2bc348e0d76e82b163ddff9875c78393d1f5523113fa8c3043878eb9dafff1deadfc22f3559e35acf101434f575d704aee081ba865c5e8113456b178d04f0855ccd12f73a0a70542a4b335df11fb22294039e613322041d0730dd4fe63157aade7556d9927eec312c12a762f48d0701709809b1a44a1e9de0b6bbde1d569447f4c149d5c848a16d56d25249b58890999412826b3081455845a85c5c24adf2f4460e12a2ef83941b2c316f3a180263a76efb3d5249d2b2dbfd391d2f67cf0e29f5e393062bb794ca9548cf46622db37a417240cd2540987c65b6f897c4e28da6e643f1994bbcd9afa8939ffeee78facead116535f852fa35d78a9135bf11e3f25ca43c950f37089bef3ce63aa637bec563135c5b6c7b4bf47801509617fe52fb204e1c87b1b401aa7e6bdc7540749a00ee5952896ed5e5a57205e7646e74527c88a1bea06ecf618b54e3a1795feb0900d266a230d5475e87fe4a20b1023fcedff014fe34c66ae7592bade9650e12abab1b872a06586a60f6fb6db472679018cd7f1f16baed63ce6c639cde11499fd8a9a62fd6d836170de77093e2a1b0a22bc346e3e10334442250078bb4753e1f9b23fcbb4d528514f5afac1cac6a2987a7712dc28bfebb749b99a8408eb1a56862d2c927b6ef63c0265e68ed49d5e11ad20688d28c700e5269a745a6dbefdb9304f2aaa5c07c9f76412fc1fb491aa88640efb2e0a0f9782d8f827e3b2ab292272231062612c6669963c769ff571108430e5c6213f497c2dbcad726c901a0751c9fceb2156785bdb26fbd507c76436e961b5e9865ff8ae9e8d86f41c67b4816349024a4a4d4fb8f0088812a1d95bd4ca8284cd0cede4cfe321402c8cc9239cd9a067d2e61b87a9372c089873edf2c58f8a139f2074e1b6d66f29b6b6b7be7f90262f0ed6df792e61de1a4b851dc9d9ec29ed78abeeb754e1b66d8c1573c35a23793db063fed7898745d916f7ec73cc59c423aa767b1fea89f9702972647d2bded7a2b0ebefa62cb1cc12b63b08ceac7ed406cff5be134239deb59d06fd3bc2d6ec902f8927af88655a04cbe22e432198069093a018b85f16494626e51fad7b60edd403f0873412ac8ae7aaa47f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
