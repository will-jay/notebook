<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e134d21ddf3965c2d0e9bd7ac0139d22ea24b46ae447f37c28e242ee049fa1d401381129c50768f4a4371d3ad839a9a8247893a17275e8352bfb9335eae2a31731462d78f6766b2d210408a0c3a4264763d00bc4e8615e053b09537e311b0338aceb1d4942aa5fc45eefeb9ecc98788f68d316bffbf631062b1de42c784b357367a77cceea967039bb186685b7531e8ae3e4c2230759b32347ecc4e890726a4d14a289bac871fe52ab5305755ae28516fe5ecea3de1f22eed059bb4dbd874a638b38b010b1b538648d9be596e41c9f1430afc92a5b636c72da51d3cdd79293ee1f5612f45be9044ae459693fcded83b9b1e6032ad63733f4823a2c5ba7371955f9f89cc4461b67ab1275d1f882b9ebe339ca7ef9085d5d14bd7988c3772bb8e110bc44e816650e9dc85fdfff4fc25fff0c40e5d6ba30f124077974b7cca81bb55b722ba2f1a5bc2f19040e600d4a705195dfa86d3097a53092015342dd1be82dfbc0f3e4ff76fdafa3ec6347502ecd24215fc51bcae596aa938b79aec2de7f74e7de25086633d5c959b51abfd8813917c8a2b63306037dcd5ffb1f1224f462f50b4af6f0b621846d76714366609a57a4ce1705f8b97037b05d8c7b77e4206e08e28c8fe016acd9232d38a3e27f2ebc5d50a1356fc0fa65fe6db680c356227e1867130046df04ccc3eb2394741296846a1f8757670cb8fe651b3390a18776cfdcf5d8822c0d5fb0fbf33c3d98f1a4ebb54107a1cf3ee5d74580519848768293b9248f5ae58facacceae3e4fd677344803d6e341a029d0ae0aabf03ab299323449885c4f473f2b75bdbef2be6f6118ca55dcf077564cf24a836948f19cbc438e69783a7e4064998d06a3e1bfb4f0286816ad0338143c375a2bb62ac69ce8d4211fa0cafb777e190b78ab38493830d29840fc23e35fc4b4daf5ee100355c3319b99662e2d17b915eef27f1fe8d74786ba60e423840adf0e131a33c22ee74acd7cffdaaeb4561405a9f98fb8532a0d3a62a9547aedd723c401d768ea94178bb09933f2cd32fdc6e9e5a2de24f5e8c5ef354aab45884099d606641e368b94faa8e7d55a590b2f7cd682ff7b90d989c661b47ba78a921d64abd5c8c6be31f3a567f64000021ba001a3969dc06a2aa24e8e0cf30a13645d949cd5edcf7bcc1b812564a35df99e9db3adb173fca212031d8586c9d5785780757a35b523376de669a9773411e1b1b92da38d51a9b4e1f367c48e5942eaba2a87f579605e6e931d3c81346cdf17c90bb4bd25bddc14e0cf1a0dc5b2abdae1ca3b32f542b2ee0fa7ff43ee751de0fb80afaaac10e608675b62c28494d2e8dc222cedb3cb709ae68cf44b0692b3be90e78a78d0df98c6df4da5d8fa55b3dc69268e17bd7d8dcbb0cafd8643972b808236bc3ff59d2d1b7bd66c954d518f14416e0e781c6f356a6736d430524ddd00565a7d7a89081d3d110aa7478b824f305f7fe677172d7315fe0d444d45067cac7bd732f29a52939d2adbd0089671bcd21a6a924841f4a5c620d49ff027f79c4507fd5cfac18adffe13a67384ef1f3b8d10c635d336f5d00928a151dacbc714dd995d8094c7007e8c3eea036a849f960796972d9d9c6f78c2e6bf3b0347542a87917eeeb0f7d948ef8b15fdffada22bd464f1fe384e55df3e21c44c881c538315ce2c2ea9c6d3d68a3e18f1124c2d6df502b528a17b0569518a0d87949a697fbe5e410ac492f644ee8cb3f0f3587e7b988e60c025fa65ef9f0bfdbb85113ecb854dd21af542ae43395bd6be6d3796581eb5c9d656411ac8914a0a5c58cdab778194f495a89eb7d7ebe1eaabb895f7324c1e1a4e11c43358c22d4d420257ad86eeb0f63bf7c1b1bce979cd9c72c4b43c0124b44b97d92501eff8cb620101eb76ec2068acf4ccf3fedfdafdead0fe5fac6d127966f6e52ad78980b70fcb6a052341a4c308c60add9129533074069ef0e49dfdb2b380b16dfe2f05ee878a67d645d554a59fc820eec1f8e3675d58e78b4802a068d31979c51b8bc4584e1f1df86d902a68fc966b1ad9acad9e508d6f68f54e49eaa11fd20c8c4af3c9457374b882ad9123adf54c3a75e2fade029c7b4478f1c4d9aea1557ecfa16242ebb911b3549b1c784ccd784468680d8f5343adc5b1ad438f4897575b439bb28255577152975842f14b0776f8ff27dc85a37ec39b0fae19562bfc30865d2f18c36513c54fa2b6944bd8fd09d97068e12a2a02effbb957a26aff1deeb159251f760eaae279021f5f36d7bf93dae7035967475dda8eaf3de4f7c74948d9f4d65e66ec527ba36f1c1fbfcd5af320813f90557fc838f2784f5dbe7a0fee79d54406c59ba11c4dc9b3624bf1720034367f9a0b8f68b5c51091cc9ffeb352cfe4e4cce8bf350eb99254f49c95ac520cdda11791038b9b6800700d4e5c8f586815c099c871be63aacef930ff540c3b09f15306352d5eb4c4a9adacee0863949af03b7770ca211b9a782be80ff53a26e69eccca9ae3ecc2247c97763b254d77184e8e7460a068476816526f96aa93e37b0f1ae63e9e304bfe9eb790b1a1220906150741fbfa35fa0865063e5ea6fc30fec791aa60e8e16bc93de94fb3b18d6168acaf2a7a31508e84a01a4e38f6c00861ba8ddc5dceddddb674740559e9517f689763c5941d95b6e8ada76999943abd44e6e1e6fb0dcebd6d33266b9e3031a774c730949ce04c7b7fdaa3e18c20d6ac056173a694a4bbe4a62b869ac660b8c4ba1a93efdf1ccddf2cc70b8d2f4cef84f5c022b258860314f5a3f2a81e0bfb0262705589ab82af17d2cf8800c778d351fec6171d43a30a6740cb478fc1fcb90c4e3f70cc6ac4dc0b56abb0b5fa0677a853c2e58c185a4f6fa7813ddf50ab0bc70ffdf0c60a74f625c767228ada624f974df9c7ca9a49e24a6a952ebc0f7838a287fe18b7cd910db976787a0ae7001363bd035848ade6dd454a0fd10e41128fd2162c6b0c281a8dab7bf21c822a4f28769236b76ea02d871d259b43569be197c7aec024af15fc70863af4ec50ea65bd327bf397fcf95a627c84ed99af09f13e47de73751c4b74653b2fe4d9a86dd9660da5a602ef1739a4588efb7f280e23c16de7b32dace50a03b13e723a4f7ac69bcee339f1f0b266bb5401133ab4253c1943f18773136fa7bed9a3bd74c5a74a0fcb8bca23dd5fba12042226edcf9b482b5d9b58cbf16ef1b372d27cb032bff63df37645cf2cc728f8a9a27a92409762056f81e43a7586e405298580dd818837f28aeb2369dc39eb569c313fc6f14309012dc76b8d4633449ee9b2093c0e892962967002a912298d4f5117a697e307dcc063acf37d90e48eb98a0a9aeb2f4533ea2d71b9790d501a0f7f7f716e5da911b3f6875bf38d3e15807ccfa6072287a16732eb666c9e3c03e01e223569b980d23ffacc09be23201902ba024a42e4dcc98f8bfbca4dc3e3af63c9779433f72005fda519f2ae5e1a87081b8c09b18e040e21077159f6e1d4309caa7a393aa791adabb3cafad6f7d5489c9cd6e58664ad4b56bf61a51c5f310c177e9fbd55bb74e7f99b87f453d57113daf8205f83ec100e1a8074a5ebd92dcdd88a530a003d33d1ef6dfc2c96a536e3cd3119f23f4727fb0bfd6de1dd03702b49b9cd77b7252dba398f14e023bb5ff12f0c47d655653a1c54673d285bfd23eab45696269b3de98d66d8894534b3b7a49cb3ec18e90d5657c8c4f0b3404db09a12ebe558efe24b1461d379b953b452b7c40c941edebc9fb0cf17cae75250e2b873b1f199d5d252f8d1448a4429631c1e90a9899744e027f66fdd8d80962acca670b82b46e0f57f68a615309a4546a9727a6acbfc4857c04a71c54cbc3a9f1d7305f5387b5459c5b1c7ee3be9f29bfa246e9a22e6e3b0ee572d1259743ad49c7093f8396f89401ecdd7ac3b95436d21fe48d53a257e45fc75827b7d878d8e51fade7fa4c6410827840ac5e7087f100e31c31c19e21c855f34aac8379a25272017d7b0f083e9ace4a38b929c60ca93a83a585d73da9c8d2f3c65f65f46f521e9fd70f2823a918b4cca37110cdad821bb47e398d0ab19e7a17a3fd08b58648bb79ab500d2d8bf883c9192f55578afe9c11b0d7cac8d2634ec79bd214f2ca077d97ceb948c1f008ba01192b886e8d75c72e0f3d4a5010cc48fd0710d3a477871af1dfcc32a872591d0147b83a9511784888bd33d8a3ee363e468bc54174646f2ac042f6580e44057847e6db1bf61d9f8604e2b38aa65a23321db33f36f9eba0d990884207b4c4e08b75bef679e111d96d65f3f336acfafadde2f41bd77efd8367459039873534fe5e33caac0a0e94634077048c3cb543f4615086621062755660cdac7698cbb0614eb656642e0b79aaf30ff1ef6857fbf9ef87f6fb99dbd6f8e3faca88081eba941f5c9350b62c67c8d5ea36f65201c23c3cec46d211004bfb5c0ca8e5a60e318d979806adb367af1d36b50b977895940afb97df52fb1199d248109cb9a4aa995102989bc3d459da26b286a08d216332c0aa8d1bbdc0dbb9001eb58dd997ea7cac9a741eee92d21f3575be3dcf9634dbb1f535b8cdf9d27fcaf61edb00993c6f47c8d6abc99aa298a5c87223c07ff0bab5525c722851fcc236e0877234c2abdec95fac8da0cd5b168746af4f0137620aba64620adf06f09ea236e2585e4cc78c866994aade6b01f85d0b4bd0e94d2ca084c7526ab982ae61252b68cd63f897d1484b5821f9b86b52cc61c14900e5ae3aac4c5042945c97f6a5e4a031bf494d5d8455cd30b7fe503eb8454e9ee7d011c83bd0d067ea91eda72ea53582009e27163ae3029f9705cf95cbf04b07650f14660cf5b4be269818ef9c24fec9435f04a129a509109004b7199178a6fe23c1c17c0fbe6999d606525800faa71406927e72e47412f55797b2ebb4c59c9d4aa97aa473d126db60717ca8ed88ea483501ec0a5b37ca7e00124a2569dd00088ecc1a5ff36279133088145a45b94be2ca40060bcdd0bfe2cb8c20e4052947f1236fda9d76bea2dbe9f7925ed03323c8a4a526fd100b3d862fd6386563dcd1a1fd9219994f9a03e0632fb3084ce5fff388cdfc68c093025ed012fc4b2fcb5ff4b6361c86bbe30533d88724d6dc789bb5b29d958ab77c6f53253836dac01d76371ea72bdd657e857b402d73d8f29848c1abfdd96f7f1c1b6c3db4600f5afcf3886c787c415a2f49420b1554513ef9d398dc0df6f030312ac888886934effaf7f9139d824fd94e026a40b0421ba130558cef00f5e03aa00157ec185b4b0c367d0c9a6fe52cd7bb6c834bcefc0e71d79345596f70058c46a803085d55cd1fc58377bb5fd1fb0bde3d871335943caf4b3154b8d1a440673c1dad83426296d713bb442f05ca1c882ad7b2d8cdd527507594f4e0e01007e4363a7134f443fe7d5cd5e15ae445c10751e18ed9c47bd052305fb120298f82e9943617d613d1ecbc59b0dcfe076ff94d8d94b91b6983c16a7e80eda102fa7b046a7b1132cbad5997d57436fc6ede269f4c426ff69eec20470b7dc108c9e0262fc361f60b85993f5c34166b2386c34c2b4667f41779b4425f39082849ad59cc15232b99bf21e9f69e50a7e30fc64c10771e02edb590fc4863be761896546208e79e070efae4cc1caa839fc73149e0adb002033cff4c601ecd8bc3daaca54a90b662f6a1961e03edf0e830d3aebcc4646d945b1e2995620d04cc4b3229676099ed99f7bd29ec5990ac130d77d64ee61ce5faf39c55ea4efdf3394c3a8f450904c4911d04e6b7adede359d28aaff05d5c23ccf16a7cd67a7688c85f332e0dd06180a6e891c19020d5599188a3af619653b38cf028e05d8d0e6b1885335be9f2394b73086386fb8c73c8c54ddff021a434c29b5009d0820e66b1a64a1d406d367556021ac72896f09e0925bc9f6e84cbf3cc1091919c63be2d8c2b6d913defc37936cefa48f73a888a367fbeb2c769fea98012955d2a630878775db545e3588cedcbb79fd39bce39ec5331a23b07d71bb1955701c174fce84463376117d6bc57cbe1d51484d8f57bb7d58ba7e3c719210e6cd6539278de8c132f4c826541b2bb9fdfa66e7c7b7b9dbb3e82e8914d6bcaf6c115a3e7e7787e1044266f4ddba9d6a5b54bec0cec0ab9d44acb6755f428e7082ed77e2e1b8d1a083ae585aa843aba3e7a73d2c54e8539ed3d0737e94c18d34b7d1fa9c41d423e660c82328c7cb5be47b24db29c46e07009fc32aefa67502c124798e3348a1fdae9ceb450f956f760376f9bde46f4bed5c2df02ca9a788ac7be852435e039aaa0eaa183fa8a523d2a356370b476e563e8304f39a9d0517c477768cc0ddbf047d2b56fa99171f451d91448428e5d66ebe49ffd82695378727336f8a6037750f47ae8e64fe8d1769987b74f1e3a12eff2816419a7289dfaa35f9ae4948d4bda0f906a7140de2a36f2a27f9a701462124c1a872704a5712e55f1b2c422c3b6d7b59a99b2c978220008ab65cd2e9beb0add9548f9e781fb99ecd99cf3d6e72cc6baa3dd0e1d24cd18a00ce4252b9bd67a1e688ae6277127d0a953f7fdbc25287983285f01dcc5ae2b4b2860e6eccb54d34b35bfa57d55e3b7be2b3606877152dc3b4a938923e0d03726018f2683b8d12cdd39b74c974dcd80931fdd769044d12fff0ce86717db5dc2579df7dd8f13fb46892a8ef785691f52ffadd87f70fd4f82ff4024ac187e2e7af56dc8deee130156c40b04a1663b544daf0c1187a89d1806c82fc276844eb49051092a69da72c86118370f608bd28f0eb581374fce5377f47ac248ddea97f50519d509989a3d405160652746bb7fa498a0db43744e73457ca281d931c42c2b6e3a3f73fa837998314bc1d07a32042b655802aca0151cc3143364a17b640ba6d5e10ea04149f0175ec66a7a05586547fc96c197233c70808df93a1be3eca9407dbc4df522a994f1f58eb2cdc25035547fe0ab76e5cc5f75b964a0973b1ea199a9442aa363b6ccb473077015771d95ca45bacbabd72e90b0cb7ea36137563c7ce321a05c397bbcb1c41f9baa69f4567058d8f46e71a66b0c163e429a8e756f45282bb91151bb1627a8e569b7f5cdf9b5502eda6f0137e713ecfa743c911b724e20041abbf43181b359af2d52dd72020dbb1f739e02ab3a42a5dd7518756bb041a6969f98da24d6c6ebdafdd79d87a2602e7d2864b1317fac4c0ef6a4fea15920637b70ef23c68b6143e2d5032daa32878f90b8fb8f47650224ab860e3e404e565393ffedf8120b5fab0e60763378030093fcdd5fb3decc010b453c938ea50870c228d968c43c7130111ca5fc5058cb36258d60c8c6d376fe83e5e469a6b6e5a597add4487d78bd2a9631dcdfecf6fb6b7e6e649ff4d65b54a8c7cc87be291958b281112cf86b6c1de29acaea15ba7eb3ed2ff3cd5c75ab87740dad8038cd144fe0d5de9e98f261f866e88f23185a614628c79897b02d3807f1c6602e0decb529aa598fece6166b67c0c2ae1eaaf8b54001df52bb6c6f9c56d835e399a85db7dc256e000b1d3a890533b9c982de4388e08ce5e3f5031c5f64171deb1f474dda384eb8ded9ffa935aeafb1b22333271c159df8bd75766814f11d5dfbbe8ffa5dfaa77cc9709f028b5de80dd6077c1cab9c2cf1456b45b834ed0bef5926ee348ef41b6d688d906f66c304bbcdb80d496512d22f58649a465897a3286da72010e11b0e4084e0f9077eacadcfbab3b46d9e0fe6d6281808826e93b3cf391babec87081d0ebd01e1117504c06d6911135c2cd63a36cff5c5c93793ccf6ad64c0a648b1cc43c44dce1050d1d59ab55d66fb628403508f9a23e9ddd3d3f8a0ac85b36f767591cdc2e08d6b6da9a6afb35f7b675de0eb9406c0a18366ed9b44e00e0fcfaf967eb08f4421eeb3c7fcc5c7c25aa7bc93a7874e9d610d8065d67d95c9f21c9f966ea760fd192e0b2fb76bb1dd51347b9fa4f4fd6f8f10e9280fbcb573ed421a757fb34a83eb8284bc611fdc5bee4bd3c488b16ed63c664424546e39fb5732b7f3bdfa9220dc764086547516775cf6b47e21aad6fd6a9578fdc521c7f73e8083b6bdb4056ef00f9808c907dfa1ad5a3b54d73d62dd190efb1f9925f019abd860e4046b670f32899e66ea3e6f8a99a1a1b28ba54cffbcaba5e09a477a8d29c64a64f190e2d5bfde058d3920743514540dcd9c19c1a1cfffdd3bea9f37d72880533b26f2cc657b5dc99b8a6743d1495321d80c23c66b83ef0686390aa236c14385ea12156c30b6b49357b6ad18514e13f38fc36f6fb64149b04d00a32b4010ce655aacd53751cdfc3e4db8b5af550dce4341e268958f115d47e4f2ffbcd4c563c2ed6afa92950e13f628c0dda80b9244edf57414e6d23eb5514dd24c994fbb9541e812d14219bfd9d6320d768ee8d31d1f107aff5789e48e00abe9764c8bc2a539cd30dd75f61b6894b000ac3315106e99a9c706be4281ca6dec14bb895a5e4d87741ba90182b36855c8c31699956b2e04a2be9f9546538498d98b73d6d7dc5f499c524d5272a85eaa7cd25ac645127588fdb2e613b4d40f5356e83deab94dea182a67463dc4692a80db95bfe2384f5fa5d1e9366c1c9377ecfe516a8cdb9ec7f4ce1a5295d415cadbd6314e41ae14a728f552adddfa2b6d49b0e735e81445e127a4e5eeb373d296247db7b71d6c579107d9b3c19f07647cf24df318f6a78acdd51b110c25d54646e38b8a70702e6c5e88922592ae4ad646beaa5f1589a793e9be26401c38b725541959279af46cf89da1fb04f3feebf2099300dfce9d21a2db2ab0854d61863d55c4e8b6e1c48cc9e4608c08919a69fd41e4915def48ba68e4e4936f50e00d19e2f143c7643219d6e7579e7a36c2351bfcc02504a546913fc365854a47dd03b45280e6a39ebdca44e1a120002730e3197a82428160f239896d34956ea4961339a9efb6716a4ed1dcfeccbd8e1834442ff651b77f08c643a96fb8ffb7ed2848156315dd964ccd7761af1b6a428995993268c3e596e09205bb1a3e2d244702fa714b822d7098b3ff50695d86837c27e3f353ea87151a23465c71c7e572863d207bd08fc5f9055dbf5074b9e7774065dd8b4abc616ef09ef417fd05c78ac4725ab0defce22e5ddb5c20e9d5852f24026854846be22bd1810eadeab33f1f667975daeb9589562ef79b1f33b2daed746b7e7bccca64250eb36092caf68ce44dd5f00e262be0c71637affe9c2fdf3382dbee985d98f0496fe21ca3d0d32816c88ab9069ce1461388b8c9decde77461753270d2e18942971a283ed9ee46d6531bb0e779cd7b055c44eb507e6351edb536790012a29a325a39df4773347b8123fc8c1b77548f5696cd853a3c8dfb823f7402c57ca09bb1bd04d4a6e26cf02ad20944f75c84f62b3c534c8ff1afc0b8a8c4ddcef9832fca404172238c6fce2abb288e64da1a5db714017303eb72eb3caf6cd2435861445ed90b00a3fc2307c6420e2309d620b1287e735043c7867b26a1a924cae1458e1d55a2dd819e9b86a2d8fbc032deb4c23cbab6595ef142c1f1a455119c42fad6bf7a965167be20ea29602cfeb6e9b05b8530848ece34eb3debd3daf3814dd267f30b5a562e73e309cf4fe653183c4b6aeb2ddc93e3147321688b02bef2f0a59e920528db518cd6c082175b231f683711185f976184ff027eb1567a1e85e9b480c574ccc76f222c58647e6d2c78dcfe8dee130b3245d7ea0d6b99b90e435cdeb908052884f586d2ea1bc7e2d4239281695ca3f6a2fee85d74f1fb2a1ec6ae715da4af0c00ca4c119d038ea727ceb8e97ea8659dd9db1b6fcaad3a29e457e7a614a305632538abc457e9b43d475ffd8cf94b92b10e7d2abfdee529c0aad02379c03ed5d8e03cec7d6362c7d425ff4c45e4e6ece28a0fe0d0472ddb0917b94d773de47d962d73292a6ae2776affa533e3dc574419869bf463a1371b7330b7ae627e317c1be436cd28cf6feb0840dc68d453c2823e217438fd44f4657374d0ee6cb94f04f1d6a48575aae523fd99bab26ed1698faa210f36666751e39709bad679f7d9369e61019d2a5f15f57b1c8ca776813ad1430c30afeadd1529bde9065d9fb40147b5b50005bbe5b4affcf8c5aa16c35432bcc0edd4b6a2db222030276eb8702ae4e0b30fcff775d1dc693f25802c58919875384c9e9e6113641779214916048955986e156282ddee3bac7539bae39c014d151ef05149d4f9edbc03a1ea62ce12f7c45670a7b1393f63aac11dd0afcf676896213fa47aa1d61cea6b7c75745122e53a59478f7cf976da9768b29740ea3f494bf1c965904c88209b648b88c8e9eb86dfa8dcfba2c9fa5de6aeb3d4ef03a1828d798b31c9c7405704cbb8e56b35aea0f0ada601b506ad57867d97868bd5560ceff06378603946858e4f0810519d88de3013b275f4645889dd668bc45555ee59a61cf79ffafdfbab0d88bb28a77aa3c7103accfa5207718a390ee4235a24321b5a7c6264ed36c829e5ce3ef206321e8ca7fb1119326233b53fd836ccb43a1879ebf0d7f6632f441e4426b291aef999633b41f55b0d581df5934176ad2ab1c78b52142409dd8651f0a19cb0feefb10285cb3aba336fb9d90bbf73cfc58e3fc1caa79c423c652fe49ce66fd8bbcfba66ea6b59dc5aa6595f0ec2db812b061e40752a8cfe2f3ed64b60ceb0610a4bde813048cea64a6ea2928919e814a13ec290a814bd88a3968509b52ac09741a9f3034c625e202897b1ae7f8e2d00e7b305ac16a8233b92d4f4ce24f3ff3866d786cfef03bbce21f7e9b83a8310e077ff25f21e4f38b55d41c737708ed64ff7581a7718538a6e3069bc3c82e7af75052e95d6c13ea5eeadd4767798278c3261f3816d3647efd774e5cf6469f07a4538095730d3c8d599391031c0904f0c55e7a94f9dc20f772f21ab7eedbf0a93061673c6818fc7030605ea9528a9d6e9272b6af4c0ba1a981188e4b31c7bae18a233327b844eb973e8c483fbcdcd245fff18e1d5de555c60437a9f1b2577a39eef4e72f4aab44724f0418ea13b1f67497c9e0e95e2cc4600be424becb9dfaa50a433dea4651cca2848f904b4ebb41bfe6418f7f37a4bddc0b098bdf66f9cc221618c1dd2744b9c4061aa954a0d14fc487e0410b3ace390519a069c5ebd1b797a8be04a818ad235f19661a6c114b7c877803ebca9ee77672df4e45fc3a38c1a85be9c25d581c3c0b71303bdf48855b69450e037f14bf52ad3af41d302aa6512e8e9ece69fe9a1549a2b33685a26c9bc12ba75ad3affc0abea78470521dbdcf5fbfb9182b5243892da23c1b5620fc97c44bd90a7cc8bb05b99894d4f815ed5c04d97106b7c9c74bc382e3810cb094727b73c1a7ae6c8fa9fc1b8744640c8c189974cfdd8d00b017a071575e145e4f5752a368ae940872ef6004cb13fb9a4bcc0797463e856c0568280a9945b2dc6ed45f7c6c25570f2bae4d9d46e27e5534d1c4391a48332c12c9213df379b7a25d1fe589103023b4e9734dcf318899b173e215fd130ba2aba88d12b79ba8f422c7e8fef151a5d71d00245946f830630f199805b59693766a694ecd059ffac1df1922a418799184d2f4946b9efe5949648e0910c0f0ae9faf1c24af2878af2ee39d0ece6c6a728bac5236185bae1ab8a6fbac9e294039023c19801f56fa5558e75655dc3f6ca46951bb2a8b53091d24bcb074ca5aa5853937341778192adcc0ebf50477d0e1315c37dc36b93c5a2676f5c71cebafb1ea50ca3d8869c7fd94e1f76c7243a5ffb6c6044bc43b0683d432dc64ba06eb9f2c1112dec74c266d35d821e011024d96126f40596e689e669c4713cc8ee4462e921020cd18d78a918b896185b0f666aeb79cde6c0a099e57a367b383390abe5623c9759bcd01fad0236196d4c9bd2ea3d39cbd6b29b1e7baddac8676f39c80eca88124fcdebf95c17ce2136ed820adb905149812c9d9ab7d464d9861a29af5f660227a5fd7d0f543dad28350e80df9a8c2f76f6f801b8d43af680cbcbc629ce54a2983d42f582fa8bd39360a059f29dac4f538b14bab0b35ddb929814d78ad0396dcc928301d1227a676435de56982e3e07bdd1a34aebc4262e9f317730d33d1f057cf2f9abf76a417043c6c4160cfb0fbfb5d8ccc06479091db5fc833d2046a28f8c52d590dbdfc0aeee6d2cfbc1386ba8ce68b91387572d5679d463101cd30969385f12c33aafa591f85a08d2d9858e266702f396b634512797c18b46e889abd1cb26dfd31b6b8e95d0fd0caaa688261dc598634258cdf91f9455c16a9e4de7d607052c3eca747769808dfae9535c594be409c48ab6a00d7b2e06fc887f0b19c09364be1b9c684d3b7a00e2eff39659674df3b9dca96788b09b269e91009ee2ff5387a5c4620e2ed65e7af9991c46610fab2018be96f3906b68f42830eb9e7064f903a8e7270ecc10f25c9044144bb59cca805cf628a03a1f52195a8ee9f11d022e7dd47c8f5d0293d689784647efd3af491f51fe42f92fbef06bae894729a0972e52a7b52265c5a94cc3f6b5a20aa9873c6eb7bacf0f49ebcc7c44127e3615398b21c53abb8ba8e5b4fad49386cde40b5e56f58e7ad11758565f5125e1b2465569b5c60abcad3ad584cad361b3da5b0c8044e74e5b78361a080ff1a3212e6976dd785ca88f3b05fd8f64e42b77ee7c8500cb5e69e310d4db55ad90f55ab6a20b4e35723e4c7fdfb23d13a764bb141241e40063c777a6608bd753faa1cd0eff7f0aadbc92c422ca1ec25db3feefdeda9d32b49293bda4f751ae604cac4196373ac1aa8a3baf8998115a515121c9b2d51462807361eb3c580b1998c4a71cf6f730a0e3284beba3cb1dae82ba226d7f8e6aa4e3b415f82b0d56fa0d4383de22e6ec54a71ce7f1915b799df4db17afdb96583235f0d858cfe3f6611aa3fbdc3f2cc5cbb83bcd3a1828e03921b6c0284404dee67ad00a6c3523101dfc650bfc4b253aa147c238135fc117308c7e6acb07e0392faffb82588c83e4635d20d29fe1358d02305872ca3e761483e21b6af582ac4d4d7fb2ee8bd65a8562b28bc60330fc5ecb291f8d503b85f80ee7d4dc9e3a065473062138d4bff475239c4ce461e99ee871e1e5b0c491672eeccdbc1a70d128c5df2deb8c559c62e873208d6d9ec865251fb91b21cc40decc557ee3a29d61e656dab65ac44275d24d908b3f7afb9e294ace9f2168c7dbea32dd829ad9da30dd61d1ef69b012f37d916b9d3e758404a99a1452fafe4f99246baead84896626b94907ef830d435bf5247bc6a30478fbd66f756612a99b09905258b0d6a06339718503b928f0ebc4c11caaf83ec24e6dba5a0f18195e860e462e8592621187fce987ae218c4c73f3aac43004eb54ab29f855b77e98639483de8df63e61cdd6961ee1efbc882d87256734d75e3896682a119d656801ffb17dc15c0aa7df70aeb73f353372350f343e8d1a22029e2f872914149f974dbc85af5972af7c813c8b49ff29f144f9839173b48db8f909236db5b4d56c477c240dfe4c698287c3f0f5099f15a11f8164542ea6723f6d19a8a4be652a73b0be0da6f6c34c36c53a559f5fd8cf974a5858c2582fcbeff6c612cd7cc03bedffa1eabadd90b0d133aec8d5acf8feca83c803c8a460ad818ea3b1d352bae42b24a123cafb83792172acbe18b5066d4712d312370e344f53985412a31196ef2664834046170e35c516376798c4112d952e4cbb6ba46997647e1a5c9b83c36402c25fbaa1c77fa38afea49ed65911e9bf49c5aa7f244bad9214980dc9e78fdb6ea3817f803ad35aaa775aa464d687ca44522ae6207356be29e09dcf7512e981213ae5a173f454eaad342d4003624657b91d391b1118636c61e84bbb0fce09459dd4507a0292d36a2f8424378ce2cd60aaabdb684d7c892a498dd3d02b54e3d6a62ec2580126f8d09fe1fa1b8f39ccfb497aa0cc2dd55a722ebbba23f420ee5b0cff5ad62ba80e588e1173ad1f6af685c64fb2c1c24857441cecf91c651317777b3ad970b124f80af80780bdb67187061a48ba848d14694ca11f4e389fd70eb78405103d78f8379a7471f565b34568aabba2c366df6b1329ea66c50d7ecc13b917c06a223c8b7aceb2dffdf43ac4614d840cdb277f9a1982642e25799ef1ac8d85f160f95bc875730e959f4940ef097685080b017e41d35cdc98a2f7ee60328980bd93c2bfd17cfe9488c92035cfeac682d373922555174698344fd47628735dcb5d1fd56e0d856e0393d414dc51be5364fd9980403079a96288a71c89c8ceae8eb44fbf598068a51a7c6c1090fe2b2d4677f0357854000eac9f1ec8261952188885091c4d4339c22d7772713832c7cadc3ffd8ebb4c1c1b3af2378758d2fa991b263b24f6415cfbbe12b755517f30476e6d1d08bac647c68a310882a1489917dfcfd6f6879bd896785ec787020b8a8809525fa48d0dcd6d15c385ad4aa6f292204f865a5a3ddf69547a18e1b5e816c307a0fe067d58439cf4bea3f1cb8337e8716515b62d30c9879d896578210f0d9e2c9a0bbfad378e86b13f0b0fdf2a07d04cb76f6bded32fb719f102312ece4953993d07df8870c98c9989134259042c8f8e90f3cc973b90ce500b23271a5b2cd214d7eaf9808f45ac55375f17f03bfaa01f0dfe1ad4eecc9ea93809a2e13518ae5cf15cfb0ca70b26e893265003190a7f2645c622c33a9c6c7b1caaaee6f702533c0c78b8725e80bc2e01e5ad4c171057c1f77e87e0fe6aa12fa6da4b3fc713384417e41d743c6d9a3ca264a6d773702f1c2607a623e8b7081a1ddea2865fbffa6ec37a68cf1ea8479a5701b4bab447a0601ff861806d57a717fcae9c8ed2ea997fee93398d20084d11baca81f92971013091d1282ad239077a06f25ac654221d81e682af8f1d4645372dcdda2f90d5178a4de8b6d7ec573ad4a345a86b9324ccd976eba6203fc3b86be8a0baa9a70cd13d2ff64e5fa1a4936e4450d6d364de6de2fa3e6f6d3a72994de312f8e9a078d1397e7bfe798bbbd016073070891d5bf4a5e7e370eb29bf8d23e60c9b0014c252e4a61927316b860500efe89c947456197f3c238e0d23312ae981d366bf2df6357ee8a40d723d8fe4a0f11e5121039d9f038581372a43163ec32731a2db42917c5d469d3306646b434dc28edc28fa93dd978b4cd0fe3792d00a91fa2d881a195c226cc98e7fe928818f8eaac6812cc9903ce46c3ed3d89b401035dfe7a6f4a4783d9060bdb9f2e6ae8b971e925a052f5d27a77f0020ce5de8a7aec4a284e93c8b51b1ad625a201a862c66b6c8851ed6265cc796a97b1fb2688820b89110a6a01502662cde37ce458b19632c7a2f4aa3ccc3d00d81f5a324d0078ee155a667d4fcfa29367a736d7fb8568a80b4e3a7710bc2c3d082e7c52034371f5f5ba0ff42330c83109357c1297e53e6bcbaec17dbcb4ac146534289be82e21fe9f7690b467f72e178a36acbe01ec1224c21f662c2f2a436130f7c258b18a9640c98212b25f12f44ff0020bc7a11e245f25f77d9c70fc00e609f831b7fe1ffe4058c46bf72267444ab5c612729acc5955e27e3cc3a586e712bcdf1edeed914f72ec888361fdbbb2361b7311cb7d55add691b16afb876b988779a8d27df0092797dadf3f9532e3c4d08788486f1fa2a6c3f506544354b6e286a608851ce8460bf9ca0d43a373046386f07b812bb1f755f7005fdc5344608e3c081285a4be19f684516d0ec2d5562b82068b5ab753383ba26921d5028582d985c3e2cfdd35c9032875f9c871267b3d74026bf7cf520d7421bcdf0f0044beca7d0d53e8239473e37374dc93f707a20a7473a57d00e917b5479458cc85a981bd53cb1569ffeee9cd2569be7533ec9225fa4d6e96c9c5b3a536e9f8adbdde45ef8e5b0637d4d7b572c7b1c3d8c6d53d665e06d9e3903269fb5c289b6848919988b294e337cac8f59ea257a9059967954840ede602b6fe90a6df6282e25b57a17728db29705ccca933d8c9e71461bef7aaaea3ff54c79524e544f6282a8a2a014e21a3697bc822c4a63c283d77cf6373491f25a4907a5276aec3fdc5678075503b6b440186b6cf690d564e2fd07465535d7ce7c83cce1a775c7ee09db8769c2d9730f60d7fe2a1b609881c063ac524ae82772a768c89107df47c74b21df39c625103a676d12679122032deac1cc2fc2e9c056c2e79b1a86d93d2b2a97c6355cefbc25a0028fe5127edd643","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
