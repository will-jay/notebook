<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56221bb84011fead1e37d1b2fcca4e161049ddd649e5f19418f5f6607d97a67ae265eca45d12ea838040e7c9ec7ac19732bd4bbc94fa2f18c9e5451c0668caf7044ffa5ac061f4c0456a01351c69ced3ebb89b9f0c10940f0acbfcbeb53b6f63d56a9332ae7cdd1e4be159aa4001bcabf446ce8f65e50dca7a154830305315945f4d469f9e4a22e7e4fd22cdd29c98589f57df354cf62aadeb46e8a506a3d2dafec4bd5521d0ed5794205469b08af68810ff6ea58b92ff354269da710e252947f80208cf66feedad2ddad13ab91feeac6be5aab00d35c5d9ff2a1e003548b5efd7034674cf1316cb07e48eddba49cbec7f6a0ef0c22c695dbf921cf06c5dd8bb68effbc8c6a53e247fee87dd50b79858bae068a126c60e6d2b2b350c12dae565a18a8877a5d0ca0bec70fe3383e1eba1612ecb886d7a56c644fb9b4ac052e6b0bfef01298442e0418ced611d36e62bcee5ffbe0f110169f7b0a653df691fa357dd30c59d10bad71b6dc18aadb84dcbaaecd0e9fc921f5b8189dc38a6f4c63fc20504ffd8da9d89fb9d5b8be5129b5724ab3abbdc8d832288de43780e42020976198c4d8be0d30adae3bb61207d2b27d144933e47341a91762854f5daea56633151cd408f4fefff1c0b1a6dc996178758548793689ad4109afc08ff4e7f2f2b3e441ee577894145b462ffae7804ba05aad12d034c137bde6bdb0bfb8a5d3ec2bfa0aad99204a489b0b59df3c66b88fa204b5dd9c4b1e255ac3db59ba1cc4e13f0f72b304fbd84cca2de68be2444b5a1c8cad5b173757846b1b1ee71d8145e99c40393623fce2476e3c9d9a55c7376505d9430892fa1a0c9205fb282ccd5fd2a8c0625f9afd21e821fab5c9d9c6e72b62e92d05cc95310295dd7ae9cc4500d2fc1df5d08b3fcc3a76ce9f2f2f5ee4e821a27fc6817e8279da5df66d02a03ea1fa9305f1b24ebd323b6f41aad0582761617438e510b039f9a9ca7b69230168eb9da0107cabeb31c2411af9abb7cbe703bb2713f880ecc69fb8b51b7815a8886116749fc07cff2701d83f07357ed04004b2e32e859edd95a69ae669b815f48b16e46a8e7d20b694389302fd6284be6421593d05b58de898f6673ebf8c6b985e795f29d4c42cfd1ff4148e304a1ffa37a4f5b3465f86c554ff4bd6571b5423c6b3f0dbcec6e1c975267405f07f86f446ae9f7841f6fb48d29d6d9205266dd8d043a82a7fc720f673d99804fb68a7a3b0a9fb7718c5c379bda36ecfc918bfd42d2d1a821be878a28c96a77512d2e61a3c942772699bdacdb2e85481a63e51b6ba409e29a958ae412af7682558376575ab97a3caea73da402571c7ea98f42d773fb91c2540b59e5512bf5fe19db200546b5a0018e4417ebdac4e124c487c67f5898b0a5474c8bd8ec821528e0788b48bf391b1fe9fbee106a0584ff7eafab92eed8520a9070da6c5ac15f209a85eef784b19ac8c5a9815704d714bcd0ecb3be0e79aad1bf9e11ee9f2d5ca9d69a6d6548c88ed6d5b6144d4137572331ad7941d2b5a724acf8aa1fc255e588b0e9b67719f54e98b920613e6557c04c0154f1f3d5bea3bc1800e84e86f24df8fd257f047d8f23f8828f52bb965b1064b7211da702bf012ca4eee36a5b0791f85a39c7498b0f593fe16b0471aacc23bf7bc47521a073b4d62bbd79c0aa8bd3d917370687af138c5e8dc6692af38c32e18ec9dfea8a210a1a6d39fe26255fe53210d092fbd11e7dddb0f2dbf1f1e2f5763b4cf132e74e2a0e8712bcad32cec740ae3a0984fdcca83b0fd761d811beaaa41fe512bfe58f696834493c47e17a5a2a3c7768b1eea71414c56850b6c53ca156e6986863eb3721df845bb371abdc9d19a9a1ec03669bebcf84f03933d6ef62e9f4532a33165d40df5bfbdc255f8c51d51b3ab83a7dca3e608c9f86662f5fa6da7f5b8608ab2e490f0067125d3756fac7c4152fb799c2a17a0218d6da3fc6929ad07820e3afdc9b505640ae308ca0b81c4d14ce9d23cfbb752e6e41d966cc97236dadbdf0caf527a604bb222c9de4749d88d6feb809016540a1877dd2fcd1cd1353ef62fca0292be21e47507bc1de6a7a3a84312057ca797e7527a39ab4ebf1a0023cdc5e47c66a1470059d9b067096f4d7247fd9077faf041c4fc639d775a455290091eaea5aafae287c9176b79184deea2545d7206852e9507b6469049f5383ec5eaeafe6a859d1fd186d17c2291386315e3fffb4df05974d2e2d50abfecc89c28d78c1e68ee1d6171f5434082d883c04ca180575118a702820cbc8c2117d63c2d754f5abf24941210f2324a4106f6daa9b1e2d42fd14793e5ec8f27897551e77fa047824a375c87d4d40a6fdf3d1bb114aab0cffa4bd644a0a3dd39c1bbc3307c20d8df8eb3945211ae215eb791e8d5535e97ee62941cd7916e6ba3d3326fdab53a09b96eba275ea27d232444cedef956ee982ff9a4b33924ae2aad19e1a30eaf19858c27abf3e4055d38f568cef6cf67176b7c63c0cda2edfe40a10d90c3eb0c61d62b163e7cfdf6a8002addb1060b9676e88c3e685759fac5b05f0596fde47f0d7309745104c87aca55d3f70053da1c74f87e1fdc51cb36f92550506c8168e940adf31df2a1fdd2c968848d928b26faebb087cb753b1527b392652b10a96d00c0cf74fb365db7e51597e3b0bca9e0a8d7884770bb1843218cc4bc0e41e4804602cd240a01727f7479cc4a4395965e396fd430399947b500b7f17a367d6d8176612d76e7edcd398a470a2fcc1eedb7305fb3d047b43d9c2207047e08a5e48713cd24c4fbd25942a4eda1d1ecc8424a415478c35067a2a29bc91633ae397ddebb8799c252563fb1cfb097085bfec126e3240121966598f059ee277b21f59badd4a2480006a464929ac3465b9a4a1a1595e3060eae072d044878e2dfe3808cbff9e0c93bbd1a11cb7d332f3747d2b050faddf25795508a1f5d5855b150022ecbd6bab4e3e789fc2a770c4ad77765d40bdcfc8ca2be52292147415055318d32005d8578f63af28bf56420fce4c92e55aaca9f36cde573de08d55a8cf839724c63fdd9a0fcf697e98038ad72b3e58e3db77042d8ee21f0de86dd4470e056070a53f27610007c60090c5e2071b2b5cfe37297343b884318468d45851f52ca5732702d87eb54953f1355a25da8eba0834966cf6442fc97ad84b2f5871e5ce46e7c376d0117659dbf4ec8d44c5696cb8018bc206714517086e9c02bcc4de4aaf414beac9d5f381704d8953dff5f86c695dc3d445a1ab04c540af4f8a14b824763a1ec56a816e864477c1f9e01a209387ca56dc075fb03b20874e131b97252cd513709cca59f8230f2b4e4a9a21ec86d6faba66139a9157dc9ebd6a10d4ba2665a54aeed6874ae3060d2059ebb3805b2894aebabfec4031882af948cd3bdc814b5632aa81a4dbb3465ee910d5e01eec6ea7cbbba857220ad642a835812e2b16a2a364603fd91b79cb6da190dcf07d88a3f68db362fdb27dc6d8519fad82094a85a692e6e44233f6bdc61d8f79f62c18d2558ebc4885afaa28564d07be61a88593ba15ded011af3255aeb5ff255ea550b1f728253c19f17189091b9050cac1a8bec8468799b7be89415a52c7305be9ca687cfe99b97f5061d6ea3b87de908d3cb140f92f29816c051f6afea0c19551a679d621de979975cb6daf1d5324ecf70ee2278f79906d213a4327a00c824640e8e558926b4b4b6470b9289212ad9540c549e0b7958b1b25aca5cd2f868bb15406d80452afa84c5c65d8a9ee8f50ac8e0c172ea4bec7857478ff4004420cedd347a39c73af5be170a8c1ed31bcfd6858be618450a8440f3dc197314e9fe0dd91a135efed99d7905224865e7af5a2d1e235449cf08d35e14df720c058a2ffa64cfe3a31da511de816975a8be130499b4c2cc445389eec233cb71e157d58b291894baf1f25111e2f92712513129c60ab0564e7dc5b50f87554e4b42de3207a2a651411f9da6f68b727e041c09de4d855aee0992ca835f871e7e09ecf7aeadac5ad64228bb0b31ae20e571b7b818d5402444ad2488d30c2f352d9ebad8b4640e0d39cc8e186e3393a8add5c8af5f9864f44281257608b0193ffff0b363366ddad6008ef77650f9e4f80e983823038a261a0833f17fe51b1e604b79523842ed9f5a4fa61c32ababfef43909080b2ad61f8cd58e7cebbdaf9bb452bdf3fc908c8cb87cd46f0b3f8d028d69c0bbefda50f3cb0db49fbd4cff4c1ae558f743bfcc4bc82f804da0130ebd97c1c7840c60e4c0a1f65be6973687415e7c49a19f1b832742ef927ccf5df78c1c781ae5a3fc4300318bd50be6d33170d6518ec68cded97c0aa6cd47818a847ed61288b87b7e3ef300c9bcd9addfb375d77b03c7dfb2c1d68fe7d00569d69f8d2bb62d5364739b5f69a725960a0815890057efabfa3e165bfdcd45e4fc82d6f1b03f30c16d29692a15c5ba3e66fb490a04d0c7d5a31d8ab0e398504d6aa97e9e68b2f6118e52f32bb77f2b81628ca912dfb80034afc14596c2f7a2bb3d585e6c7341b5ebeba2af66fa171edb54bec71b0fe4ab9ab81593a3626b26f1ef9b1852d32becae738582cb7331dc4b00aec0de0ef22a12c08823bb28ae330813234ae0bd7595c5dfb0098730b2a44e3325daf16b6e45ee38882ff84b74a24270461f7b57b53a2275207366db58feb8101f6bc7cd112d309837ab4bce22d79fbdc5ed03c870151ae05d72c2b1c7bf24490a607ceb3626051741b86f94fd0e7fd3f13f0ae694c6803ca273b842a6e743894e939482a679151972533223fbad1c9520679d7161e1aec9b9c76fa6a2ce1f13ea8048ba10e149d674cca477fb38fa1b33d4ec3db3f94b6221337387fcff0745b4c917ac7b0fbda3ac9c532b5a763686238c09c37e4dc55470b5821eafa98b30078ee1d4bff03bb51740eccb511ce32e8f306fbffe17932977aa8bff9021175f7b2bbe0b91a8a543d80edec0ff6b996b8173dbe5a95a6ddc15243ef5976cb2563b56a26f8fd908c99f61692372b820b05cfdd9532e188405f84caaa85a4e9cb4833975ee42f41851d9f6f4d3e2a1b43180284573e2aa1f92ca8b241404ad43046ebe6297c95ba0d8a81c9b4b49b025ae1baf66622ac1df86b3b64348ce4e44c004ef0a0592d95149cceae72bd9ea470d6a76c61b0b1c0f726bcd1694867625e694547763923bce671f2fe7672570516ace6eda729861be18446c3f0091c0c9393892daea1fd0eea402b33fffb515e072bd8d3446e1a23424d0c260875290998d3c09570a1c92f6e86435281e7f7408cef059092896367c4f05488c755bce31f680d5941b9f1fff6dc7f98b54184650a0137a4f1690d17dab1f9de87c189da3c36e274ad891f775ab9d93fabe2926ca02cb24cbc895099e0c6085bf807e525cab583d542ccec983d4862f3065e8db6ded05cb4193b450936fe0602813862c17d8f08d5451ae2858efcd4c788e544f90847fc543c634b854aac03d0dac07bec0efa6c3a015a64bbd4d777565779dd5f8769b8e911ffc14772b37e5036fe72d441edafeda5362fad2ec4018217c1a45e6aa414180112589f76387f3e4f71ea4e602c929084087a9eddf3f7992c3dc1b937e104639f80cab1374e2e6c241e6a1dd01269453413ad20afd9670439284bc2533d71c8747afd1080c9b82b38b9837ba162be114584b441c3e6c2a73a7d5df5f226abc857a020e65365bfee9113d373f8dfabc2d35615ab5d1b538043a7c9d2b562a53ab0fb00ba3aab2048e031da5ffe777e824247beca95afdbdd781d020bbd78c21b183a2f3947b3556293350f76f9c41fe58b708a26fb65d24904dadefdeb75a2d0013e98b10bd36813a2a744e1de932fb7f8401ff01ce2d9916a462a0fcdda7c49d993699e8beb683e173f053b3757ab9c85bc375bfb949a26c763adfe47d8bcba12eafc38e6c4bd9d31f7c25d97569396432db81c177e7822c458bd2695cf0b22ef26dd88466cfdff1b7f6bd5a91fb9d906dd42d4d320700cd170552f297a8ef5b307d51599014276cc2bb57ac6710e5f51551eb9e1a9883bf9324bc93a3da01e3ad6ca71f5d90548b6f9e21624dba19bed470405c1e02e2890bea175c836c764b507b1b9be5e9c81356a8fa7a1c03f5f25d78c250abcb740751f5e740b8de2cd9350941343f59c3e5b3ad82d700b980e1b4f441eef459a45db2b53c57334861fa79cc14cd73b76c9dd709e98a48596d98c6561102981971c46488de36dbb3ded24fd35e00db42cd72bfe168b11f787afddd4552394214bfd739f68c5810a7c12cfdac07692e0ebd8cf7da5317e31a895dfe709ac4cce6aba48938cc30fd18ef50e1271dcbc57731f0182b7eb056676e8a6e254aeeceb860cd552bb888ded1a5f4ed24bb4ef8a9ca6b1a0e72798ed842da2d79d748b759a92db672a1a56660bf25b55ecb5081d1c985a67515d22c6406b46565100370bc9fa88d97151b9de086f4423aed57da5cf0d147dd8715bbb77dfadeeded6d52234ae6929ebb6833ff770eeacd8e06cc942bd98de54387f77cd3fecaf8763bd56078fb232ff5d307909865916aa0b5314c9fa5abe84da25db478ef3a218c8c60294b20408a0ee2214cc863a9fea05a2ccfe4694c367c277d5a3bab881c8c549faa08db85ae9157424cad672cf9c61cfb66193a3f3701459ef87f14222c7793e38fb5183e1ed65cfbe83f662d18218083f2ceeb21f33778ef3b6e26943474d0bdfeb14955412ee0a0f7764f0c8c9c2f901891be6079060ae4f1efb7e18bfc40c22ee639ebd792c10b1a4c4b8244f69927ebb87c9a24456162796705826f5d8c5154956ed81ed82107e45eb41f80080fba4929598389bf3ccf5561bd03e994854212edb7e318926a8786ddb7aa1da51e3f650aa72441b397d23d335cd306841cc48d96e07ae883680b459ff4d4811bdeb8065d8a2321f9dd54aeeeb533564beb073e465bf824466181a72703f6f67096d8f74721cb17e34d7999ddc30f687f01f2405645f3d73f14a33838325bcf1a107c8d21a70a4e02d4fb48ab6e99a3e56784be29174cac4227d9e47279abf774198f11067b84bfe68b67738b0f34690a84122e9486b43d70a88f0e1168399daa3c544ea53cc16e82f8a450316b858ea0e28a3cc1f979243204dd2bf02f28aba2cc3d0d1e2aca29107a82f9941297ff3f75cd27bf0506f009c93843d5fa5d3ef1d6d8d0b1f8adf125fb350f875efe99718c8868a3c69a4b5ea5e7020c8f87a283f6885833b28162625bbe38232c68c8039c9bf9f95feae3cb4aaa647b86c880c404a3888ccc6a0da0b73ddb4fc8ac3d70940ed32ac3850db8a19350a37b72e60e367deabc7d3741aae0b7995376a338479f33f7c9a45a0146ebe9b65cf3175d920486b4d5ea34369bcdae2858b50eba513490b3d3162db2284d643f3bafc3d7d24fc5d2a69aa4a5aeee343e85ff3582fa6fc3acd0956816a3a3aa5bb3c93d0a289d4a998bcbee43aacbc748618265770f29a1928e68a1a1fe22f0d5885e50c97e7c547ac8b5a0ee4446e1291436bae105988c01fe4708f9ff2613b784dbfe6e02547b9fd7107b00349f4ec903121b94f06e955cebe279420993f3b6a8d9fb00c2066757e28ceb4cbe919b995766eb72ccacd0f5dfd9423c876b95a74470153d1402a3b3f82816878bc471d6ee4a509e25d174f1ef2e186a8ff15a781b4c84bbb814e3a5131a13b639acf24d733050ba5cc143e5b22333f4003874736e301c74145ee426011b197f8a7bbd0935ef96558e9f3a664993e69f4ed8673d5befa23427821b59f3ae037cdcb38dd9c7a1a77c2de334e86e9e476c753dc25275635f7fc3d80d5d4e32337a1b49ef16914d9f573480c4b7f7025939df5fcea4125ff86b077f028aa8cf8755509571bab5845ba9f032c281ad929e5aaa409bf8b04202c18b838a8df69246d5e535e045243f93c8e745b6f3142536dd33cb80d0f8489d66cca4c60eb1ff433effb3d9bc7d769adc9214089a516e59c01546e5050d1fb029737d0a9eba70ea2ebcba01b7343d9b5fd1e596305b9b78f4aebef9861faa79d57183e8c1549b564bcd1761597778cfbdec521bf57b723fa5dd787e8cd82963d7881768a0e368e35f0fde9f57cd1336a615029f36145ea85b2b3dd67a60ccd703ad3090f479a979d9cb07826608cc85008e5bd6192cf3605e3443efebbc9b27338d6440c29d90a79f240a31eab4b10b5a426bc1662bbd22758db791136c3b7cdf22ba07b33170ce540cc8d6ea726dcb165db281777dcc93d95e59a8d30c3003616df5ede016f47f7b1ea50f7bcf62fb791664de4528862cb2fb66b937e8a67b0418863f8269f2bd2239d7a8fe8ec2e11ae226c4cbd5551474d711c8846a0cca300b15e85bd12c65d90bacd7bf9e3dc1246b0b376f2f931a76a0e46db1143abc574b762138f3b838f2440f925b70d79b5dfd2d82bd35d710cf75338f61cd2d100b6990dbda70aa00765478676d513517a9c4d9b1b8e4b32d854546bf1a95f3f61781e45ceb1b90bde1383cd58e5b254fdf04ce3ca3a92edefeb89898a9c4c70c2448e399e74ea8474a03037dc52d31258665b4229a3ebb1be6bdee8cd5bcf27c8884ddeb61d2eed8412a0b9932c880440d93ec353fdec776b2f095d3f6e32102d3566e87a5396bf9921db96ec33c7d809a14021b4a19833388b21cc51196b54166e61a92314e632804dd309772e66d1dc531269aa60fde9d24491400870b3dd05cf571209adfea22d30b790c041d5e691f6e8ee6c3c21e320cbf88401a0d9e7d639bd28b7f897d96b8dde69090a4e2f3bef8a8e2553292157ce175b113524f1c0fde2a57b784a110baa65e3915c9beec136ebd0a57f07bbedf16882dbf3f9ad8c4cb82592b98fc1221db7d47c2c5d57555fbdb64ad3653d192ba81d94394454e30762ff4739cb137cafd93e93cf7b9c427c069897552d4cbb672d3bd02d97124d84b1991f65610ba59cf82d7b09a730d832630e05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
