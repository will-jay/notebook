<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f34092700734c427b16db49b8357a9306314467e17be4332389974f208acdb37449abf7bb3299c83c9fd5c02aa3b9728227a686df4ac236bf8dd3d25bf652b36a9c47a4a8e944a15aa472c066e74322627d15017d6a759b5c3473632157798d1405757ec4e6a256805cc7f2b69bb35429881285f33861ad3b3fa46669825a6fc6b8af7c8c653adafcf1e78d5f3021dc551b19d68bf91c28ee90d026cd2d4ff8ee33b2a76464199836d9948154a14713606f4ce420d632bbca22bcb4410b87941179488ecf75b4fdd431aa94f60d075ca42769aa415731216eb820fe9dd17ee7cffddd6da2b7d76b7280705bd18ee84d4082fdaf9dda803b4e8c030cc4be1640d46c592357d7404a0b33895c826f51d241b0d67d087f9bf83b958ceaa817068dbd589933ea94405a08a3b02a815ab8853426deed212c415538a281705002d60f6dc278ee47bdedabb0cede4b44fc0ea4c223ce43aa11983d457cc73b7e6e3059de5f7a9da819c16e226953fe1a629e8d04b73b5370fdf01ce1f9f1f310f87bf857274da1f30f1285ea47b80daaf66ea5c8e3808fbb6b04eb49f9844e52b1cb02047e19fe2579987edddc3a139aaaced4758d9129189e5698f92a3be68a56676331bffd5d69e59bd1b0920811e3109c4d715149cda32b9bddeb06411b2124f876724dc00903353579f58b9c6fe8cb22a6fa9d97afc43a66d0701111819fb41583b09bcf625149b108c6b87ff1e21de3febdca5c86b905d15628a008b76235bb74b47294fa4fa53fd7c4a1826c72e72c39d5a87505edbd253a0ccd3503ef17a445190bff925fe887e48a67083092a1b26335a970c8fb63575e30874ac131f1ed488749fb42ebac99ac4dbfc1511f61e8d131f3aeed2e033d113df47191b8fa818391a1ac6160fdee0b03b821f374897d1873a2d2ee610506d17b979830cea6d736cb785daaaf5381077d055e0a11247a4cc6f6468ff42f64c037030cab189de4ee5fa3835f81d947d57d3a478a13f19bbe46d35f7e97c38c004b13052528010a04f57e6f19f06d3305ba817f7e6a6e6b18753eb5b827ec07c16da4ea7888c3dea3356c9ece8af5ddff08023bb33ebe1fed882e4dffc9bc4447d10fb62e23043d1efd5423244989a90b51421f8169c1a93693fab0b30ae6192a65e25e1f11106ea6da5fd8a0453ffe20b6cb5707171e5904ad06c0207739ab48faeebff61bc3def456ff42a1beff4e0e26115310312d6fc7d30446718adc2d5234078b1683d24c0090b6a6fce23d10e5598f1619b7bfda77358de88a8601ced3e8afce1306ab14c909347f0ecf7e89d31fee82f6cddab9a0bb057485dfd5954486dbf5050e0b142020146207d0e71dfc9a955d79cefe37ef043aede1e3eb5e2ca9bde072047ac092bb293da6ee50eda9718c4aca57373c89436c8920851a4ee64cb21a92e1d72ee0adea6e1d2e3e9aadde799d200d4b33bf8a7f10ce19fd586b3825214620b9fcb536c19c7086fee8026b462550afe41c3240724305a8b2467cad1f7de40046bcd88571b2119f32e8978b43e74b755b195b3ddb0e439f542f277ee3a24c411235e3b515d24732d97d4c57a927db8b38ddcced099a2b3123a36eb97430dfa5cf41ef6c56b36d6fadfc5ea136eddda6f6c66f01e5e70bc72d00ac2625607ec08eddcc8a4aeac9842d19a9e8aa9102d92a67dd905b1470943a6e81a93bfc464e512bad5e2ae1741639003c5de06e06e929713c514ebe97c843b4138c5d94ae9186f1963ceed64ba1fd89b2f151cfd1392f0ba073cb9f1d5625f4a09a0828a7c0068a9687a6d8981b2e0be1e249a2c0d2a4288d91e3e665c70f428c945d9df74c851d24a2b70cf749b06c5c22660f6c210d4413de05a71052af892b0d59082381682e97959ae84b8ae520759318376717f30965642026416eb1b07f1b72c034c0cf74e8a4d953fdc41b95e4a3789e73ce6f8d6baf6ff306d0ff79364f0dd58b04b3ed40181201271f3e780f946e0da72cad129fbeb5fd60923b045804742858d4e2a9e06827b7daf2def16a51b94fe40a9e2b3a773e519fbbf6dc6e1a5ca260c21968b71baf8d180e75786099cb5afcfe4b2911a5620c4d4d1b99168f6522adc6c785564c577dca3c9a83ce07d06a0b403994fc028d99c96ca82c6e95283a17c3c44e19171fb77e7c2e77e0d9801062947d7244529ace940faca0070bdb8187598d5969bd53fe30cb72940de53d876ce21d6a0100874c482cd76a7ae558df4753bfab8f69643af4dece006d7fc119d0791bb26be3a348e90be472d669651461b5984260c0ca307213d49d4c2c55c52c41bd4ae738a46bfca216027910f3c41baa06089c6b87b3be1da5bcf6cbf06465e49360f68dadcb642be36e303a226ae2d5ec0e935668998d46a1ed16239a69e47238f270fa921533d4dd1bbd3fdfd187df7aabb0a57c068ec02afdd259518b3d08f254b0e1f09af670c88e8f408ac5b3ca21391fc5bff26d7a1a2e4c836486787beb3e2887a30a5d5455f52247fd7eaab4821defda01249a0289a51c89cf32dcab5be3a3cbf54aa8c760cf0f7d43419269623f99994254332f6978d282ee784c8c8a618adec001dbb0604a0a155612844e63f927d3eb2f425f9e5eb247b977250259cb745173e4789fcd840afbbdbffa34770a9d72316be0a43677bf37c926133642fc21fbb16d665687edf31fdb9c2d547fb5de6b998b64ba91aca599933af25a15597bf95719196bae354c82ab62acbe36582a8a31c6249952cd622538f1b87dd9ad3fbb74b3f461da9352eae6fa01b44a09338b5b6b3aac8cc73b10f6226f31ebf3376003d8f004e1cf25221d68df8c89b2dc72df949574af5f5c3027d89e7601a540caf0fcb8197e68f9a8eda3feaf75f2a860b18dfb7ae6fa276e254776261342005e3bc4acb1d0b37e1dd07d6198c0a842188ec210ef5091a2eba8a9e33d6e3ba6e8046b6b0f74eb2c28893a89da85e5e4bc440a06afeb437985988d81e809d5ec91de8340ee748706f6e216d465ab9a25588b4e220c22be0083cf4b8a34cf56ce71055f0f90d581eab95cf0de62939366d86cb0ec289d298836c0e6be44e87ebe5c3737dfd6054f057c2f03418cbf85e1b98bc1a64069b39a3feb9ed4c09e8902a6948720449209852f103730eabafd321eb8cc36b29e291d9e7626c0afce7ca7a288ed07bfb10bb27484404fa7d4a4232734d0c519fadcb2748b90fb2bbe38362efb2a6eb5fc15a45fbee5656b371eedfb7040efa08b9da04071a2cadbb951a5fd0e870527c37961bc791859e0ed5ec57073cd055ce0d00c7fb67d6302c90bdbb19fc8c516b8091c01ac2be4895d7690a4892b74a7c6ced871c62bf39abdafff2e9fd85efb418768adab22aae0bdc1469f476bb4bed79134edf18f12965d0b16eb97dea3bb70e84f664144d558af4e62d1c5f64b5e7079e0638b424487ff16d0f2e771afde0e9be5e91bd47e56e1943d33c3441f3a6eaafd3649cc0d2d29ad4980f410b92da1e9ff243bdabd77561f7cdf848e043df652c4496a31c90a5e0553c7d797af9692822df24d7282cacaa2a75540202f4d8ffc55e864fcb15697d73cf6c57792253eee4b441bfd81fc741833123b5642a0412e4408c2e2a1eab03ae31727f4d4f23d259b4629fd057b03eb3686646c50130c3cbde4922a5dfb0f20b92040356f6e3accc58be979c72cf0291b1e1e9989c3be9b5e9f64fc3a4dd9775ffe563d5dada80a1ab790744b85ae72529d9ac1176474e40eae3fbed2f26d89978eee042ab44e736d162b38e2159564f88fd9ff5a6e17c09ca828f8859d604fbb6f13353e55e44f84869cbda178ac07545adb401220911ddeea79358568e534789669f04272db4a92b32d960ed19addee4b16a7357c416bcc86f0febf57d932c47733996874a9af202f0d2aa5c5b88088eb10b85133f4e526431e58b5d5f941b52d7d1ff61a2fac28097c97959fc8e471ae2aa5b654aab7f6b5f4c6dfe73838587e2fa715e5dcab1ebae2585b4dc6ed1225f72d3dbf90f1f9907a9064b491e3573234d127808dc50f0af34500abd11b1b36a2a37063ffcb8091b48472c7c12b583ad3ec258a83c9d135bc5004d8339ce09ddc72ffebe66990666554f89d7af7ed1905a7ad1b240fa0da22e20c9c7c4c1e78777d4179a5fccfbc17fc9a53527dd298bf60a5c13227947278c630269feb97e1883cbe11516550d421c7b413e0813a60123a55fe97ce8bf79551e7ab3a96cd4f110448520cd9b753b4ab7837c2faf492bb0fe70a92d4dd7b1043d36837574c2de090b56fe8711878677cac3905f412ca9e078f5f940d6e79fafb6737c24efe0ee3074e57f4b604e73177fac71831e5be52c00dba5f0aa83124ebb27a48f6bc22f10b36daac954c27fe82fce61e35535b0e0067bf75e57adb0fe87b6a952c3af6c4aba298dbc09ac60bb559342c7305405b81999e3236df1f02017a0eb83e5b1086966f1f7e7441e104726b563a15d049551c7eae368b1da2a7c478f54d2c5ced7cfcd1fb51332fd48c2b03334cbbe5260e12f5a63323ca9e3e3de5a5afdf493f68a8c22129f4d34fee7ac7be3abb5186fa14220123d3bf5f8571ef37286514882bd2234fa9e5e0ef26b2b306a42e09c60447e7b33857485c854daaa0c57fc7bb2e05aa706eb1d823dbffcc48b6f809ade41cfe4b4bc1f0d7b0523d455ea09deb6ed9c9cefbc0ab6cfbd5c526ef3896dd041fa7d486aad2a36b330f4aa8720b41d7d58e19904f1c802f39d06caad99f68b807a91e09adf31d5a770003a4780c2170d727a239abcc2a0186349cbbbd126c88465aca4e93e16927891c21a399e91240b5d82c21779e5dc36c19a23731ff2de18525e1af9ff07c9b68b537f6b78577da3e4d07ff365944d353dcae5010294d48d1dfcd68ea2179294ea7a45b994e5275afb3d1d585db28b6b4ca23a5ed70821d2065d873b25728978cd3d362a2f7fc332cc9a02a79f3118d9093486e543399dc6e97a9c953a61028b48b1875dbde1ad8397668489bbf6b0c86c8c643fa4f0d28e43e6412fc6def34fc0d0b97e866a86bbcc708c7f24422976cc86f281c251fabcd4772ed0b78891a3c77301f4bad3445b173521365d478fa483fdb83e96ad3109b9e27084d4cde4b7570f7f11d022198065b14418da05449337efbbb1db7e604f2fa29c55b5b332ac5ebd9a300817d701cdebe37d4b082b68c91168dd3c56040af25ced4fe74088fb1af550f6e7b7900e854862e563ab4be975a0d260d57787378ba5566aa014092ae2908e65d2894f53d37374d908fac74d37e98f976e4501795210cd3b88de5d6f1caf924c85ef39194d2acceb01442946d2a51bfe6dfc188244457462b918f98a945c37770b345ddd7cf1c17f40ba7ea8217edb5c0c685a109587147625ff7ac06ad9022dd189991bd5b48af15d07114f9d572b95ca1208bc01e70be3cbe6c315efe973c8e58f8a5040b99b083b4382d00b52edb5d10a584699a3b9e28219253e5d719d0870c56342fefbf5dda271ba6284a110f294432953062c63620aca02a84ca9d7dad71e224aa803859cf2d4a5b0877f82c73f3ab1bc195af1bcb90e4466eeff79f640f31eec9bdb05f4ad58c5c68c7fc201594ed1344b9674acbaad7737540e0f38f68c0e75f728c2ac32d72c8d5b819402ef11f8bfb4d64afd77c8f7307cb7d98be7937dda0136b58869b6ec2b4d41ea1718feaa010b934923d61f286829fcef0a3938dc101bee19ad6c1418e00c019472f75356ac7848a2cce282539531fce62991436f4b2056432ed9d14fa02265d7772c430fe66ae61a6c3881595e745ed21ec9965b7e364435304fa35427e3568cedaf4d30ba46aef67a80d9e6c291201a7769b23b6959d79912a68ac04598e6447efa3cc295584698e5300b7c0a4516748a0c588a688127c9ce4bd8f8e906c44302551b6f79f820b673509241ac3a17e54e25fa1b2cd153b65b89bbf86cf3bc192d0f43a86168e86b96644d44df43b13f0c1b7cf9674208c2534a009728fa4dd7a6d5ae94a43448969e7d74e313e5933687c123a61c5da2a02d48fc3b2ce470909388b4a130dff39aeaa4dfa71dff39214ac6771b014d7cfb765ffe22f2001a1caaec9e87d932cdb0d38cbec19155178cc98864926a4faeef019c04af8e5153ba7234d43fb95e9ba5bba687ca791a6f55653f42f17094096fd39c79590534899391a8ae80cb222e7406587f11d5deb860d81da0e319c9a6e7bd85477ee3eca9c79858b3fc7e0aa91a3945dedffba9a15b1fbc783967d5f11c8a89f33f91656dd2b904b3197c3d55e2715fb09c630bd1294384f98334fe533ed39ede571dd3cccf1f6404b421343b4fed9012978e03c8687a4561599b1cefb81c34fc9791ede1a3b46a5f27eaedcb6151996587bf5a7e20410b8cf66c8ce57e1c808d6074a19eac9dae718af73612c0dc0aa370aac476630b6c8f8ae2c424523698bccffa7d66f45914b873971e188ff894cef37c524f199071d370d0d9fd98e224da024872dcd51d357e9f2897c536772287cb1d46f2162f6cc5dd991d4c3cdc79885072e48b8d5d6361f7bd722834957829689c70fcf48731670c89f46c0b90ff665b4dde23575366f3c43a6606addbbfa3bb25cb52ea1c3d20a83fbfae0dd3e9a734a1bca404268e917043d7bcac90b3b816dcbc9dbce03578d0bbcf159d4256e5ba03882655d9bbafe9eb16c3b917f6e6d6c81938197ebc6b1d8d99bde78db645ebfce84539aee6c899d3739fec77cca4db08615c52cbcf22a1c578e7c2abb7f32fe063c7518ae9c8154c8b9ef6601cb23ed1887f5c3540389f08d35f8b155af8245d473224839d101915020670930aff120e3dd8c4479b2b896af8c33e023be3240a040e49f7d65902f8d9ae2e798febb5d85b35c04b96124f94df93a5eca42b8a63a2edc83fcb36a25ffccf70239d67bb1326549147b165ea2c52201d1a22c1eb3da0e48eb477933d563fb1e9757170c2958f92948f56d02d360131616a358b22b2d6d909a1535b63fb33c37d3e21a19b3911976d4241a1b8e1fd9eb1c14d0647a64dd5123b62f3c1c74f1c8aa56699f63124d2a90fd3218f0c4d452592ac13f13938d66a41dd4c136d6f91be0a00615ec8186aa556f9ff73c1e0b01098f034f015c5754e95c82091b9a8e5ae4403e1f5a069529e2cb099aafc772a1ff6d9fcbd1abce0dd3b84438e15c627f48635f44307b67c23574f23df6e6605b494053eaa14d9d8b7ac145b111e83eca7fae5aa79b632c1a5e7c326f644688e20bf80e5ef94aa354e468821baf712b7558dd4ffcd6c7bfa21f58dda90cccbc76407578f9f3a41086b861e65bfb39896c863e87dc58e500cf5ce548596975747fd942b207af78ebf2c4d74d5c0b8f5b50ec435eec3db79033e3b49b1858476453b664167619dd1412d70836636a2e1e14e2930146f96eada2ff43f430def8260e7b3aad88d745e286539a67e55ca01e7e74fbacc935d0e400712f40f745bd542f2c28b7a59203f898e7fb184f61a067336cbeb260125b6de452bd5324ab4b14155a72146e4904496c8da946836e584af13766ad0bcc73137a33f1753b58e5fe6a347cb607f7f0e6b32294210decffac05c729096439cf85d740e8441dd5d2a96c60d5d88142cfe993d6d3dd71751b268403ca3b358a7e6782528234c3a5542ec66afa22feb96354c149870977c3b831a67d6649863a3ccd6cce10189eb275e1de3c2b208afaa7221efff385238e5ad18e8dab7282c8b9292884333b737fbe75f83fa4ed67fee1fd876389b67156e624d58672a4e652425b18558fb5f63e9a05cf7067771463aae9405bc42cd2e425d3b83ee974cdbc902972e42fcc3ac8e6890fcf21cb94a7d8e6aba7ae0638d9680c3dfb2754b15d015ed5863895b371ed6659eb0e6df8403be6721a6212796e0d7a619c4a7a8f3e8cc18d54c2ac7dd96c942001a6e66f085b73d8a6593a72879aac45a984526a88563db3ed6e677f5e45e96cd188594ef8bdfe2bc0b0f7223b4ad3373bc5e36402540608f1ce438749e2c774b01c01e282acbadeab8bc879993c0201c92e07a6785cc0cf2e3cb83ffc50cf2ecf647449254825a2f7ec344739d20c9e755646515bedc13c9cb7a7473a285d7f5f6047a2efd2916a9bf08b5174e56132cbd7314434d77d1045721cbd0913ee1c177142de46f9ee9e2ee0be25522dccab1d627e37c1c90e530f4d64e75103590d9d733770245b143a6464ca567ef41bdc753cd0176f9f68c475923d0e7713e4e523cea84dc3aada8a847413fb04bd51b4dec1d888fd653f8dbd171b24ad032737fe69d9b46f269a0964a147530a30ba769f96ec87f9233a85ffff1bdb9307b2e54d682b717ad3c60e618d709c59eab15f7646c2ba60b78c5b62f1ffe0e052087cef53caf45834b90085c14a64dac4792be4fc2fd57c4d5ce809066a47da68a1c0395acf56a8a5bf4d794118921a751bed6ca0035fdf12da04c6a46def61dbe74882ae6c257312ce95df596be88fbca462df7701c6baafd40779e42345f9caed02e6edad544231228d08565b874d41aea03ee7242772cb0444a76b4b4f95b3232703dcff3bf55e89700f0ec7ffb93827bda34b136ae7480e97e3911bb1b6a00e656207fda8de1bed8bd2bc6874f4a312437e98a0c3a2b8ebb6e0fd98f01f7d3b4e21efcbac641abf88d37439d001d0cfd4ecc9fa0a47ece1acbed4cf394bc9329af82b8e0c124144cd94bbfb5a0306945e704d9f2ad47d8f8251aaa960f75b9e0df64119eb03406c32a92cfb8fa05dbc300ecb1eb46182b3d09ceb5f57a23eda48da8c72fa5b4acc3f2d9d017e26e42b4f1936e6956098a622fc3e0c3c1275b8b4d1b4cefd8483cba3f9ab2510b439c2935fd3b5e1901186980f3afec103d342fa19deb7290c435b80626492bff053d79e5b87ebb6db38a63341f8eb66dbcdc57dc9f4f87d5b972b2578990c2a9fa53393c3574c3308bc9e0d39a1c9b3f819def151851ad90be7e5d82db07098be58846d127a0014303e4581d4dc4e9a0685085a32e73e8d9d2ef467514522bab07fa5b66597957485e63620d2486cb450b145e6f16cf36089b8000d4b789f91beb3939c40d803b516fc0c1c6b1b587d282eb33e349434db38b01408d64440d69ae97fc04bec54606bfb18498ca31db7228b02c88631d87b47943d64a49193f048162e3a9a11c6118746b1c8c120ddb843fffff640571974fa09b0eef9af7f4c815f8f5cd7cc6233823f6ba7815532a8dcd1f1e179249baddd23c54e387cc4d716b867e063a2b40bc7d7dbbf99639fce2b6feb9d2247513e9d1b35c961931f8063b5d853fe8235c3419b6650f678523357c8fab71acb5cc546b1ba77dd441d1768858811508e20683a68620026f86778da87d90a5434868c6aac4be70327dc2b2caabeaae2a345512b0358b7b3eed9b826b14c3a976e92aa4a9a82a0e26aff15ca333dde278e3678f9f48f76128325d3c63d79f94c27ab8c435169c07f291c2d9f1baa2d6b6bc4fbcfbbb7faf35d01227f62f08e6d545f6dcd11fa6c9dd38d7a63003644399df419e41685b7a29eeebde0b211bd41ffbd051d7329c068ed956048522a6c29361c7f80adb7a671d7984797cada41874a3799b927724b9d46653227e9a743902c344612455c1587aea935f8839356d3c2b41f938bfbc5ce26b49dd385f43d3c68ed9e6147e6b41166b7f5f4a7b3d17d66bb900da28882680a3a1e4a253140e1b3990e5e09705761700791feebff201906ff486f777bbba086e31967c4f2fbe5e5438e573447b3b3374c8687ba7cf0f5c8ec83acd0f2b6065a59a38e18dfaf781d526a3df539b910273fb7e26f35f99afba031223716ebb78359c57cda03632268dfa65c9b6c82c03ff9e318c8302a99db032a78f07bf89f2983c2b5283d65ca1d63b918dd6bfbe88866349505af0e4d1e5eff89d5e8c61739e11d3741dc42cc14859591eae4c09723ba949291073c19eef3abe4e3fff91845b78220a3fb32ff350b9a5bfb498cea2c882a9a4c5b17db5de60455bc9a65723cd88633fb813873c2888deb85a90035cd014fe2dad4a351fb497a79fcbab7ff5d9363142e2b45b8daed63c79e793dba9b5d034749dada41f5b0342a2d9bdd26afea683fad6ba0b64972181a0f0148e9f6e1fece7242f2fd909b624a914cfc620482210bf8341a34c93cff21a5789a51513d9383440b849c298ebe7f9690d7a88796334b26303ed1b7f529c5480a10965fa2c27f9f77f9fb7e99c29683713607115e28cb5cf874d12949d0d909da3551726d887b9b014c8e52cf5a222afba3e44a064092b83d64400d7610bf5ecfe6d5dad09efc09311435f350772d3b97af301537fe03c5b27968e3d158dcb5d44695546845b2b1ac9937a9374ce7bc4f8378d9e869e7d2dd0b9549df52f599e09f4a7f16d6373641c7c4a3114d24b34897c479137db353fd015f6fb1ac4a3185f1e94859cd66d35a46ba0ba9e32972b0f374409990f4c39af02ee45f4a17678a94fb8bfb2e5b756c08a5c8e720a86f175c08fb87eeee3f3221b0d106c00eff98d91a2dbe906fb26cefe32ef31060c75954314bbd7080f01b6591356df19e97c22ecc343a03ba8fb77e470c748948694cf9e510e064041bd0fad611262e54b025f403d60db80c64c6f3a2d6683304c28ece48d03f47feef449a46f67ab1b9076f29c7be58eccf982b6a4d043446602ec512be5a283d922984b871b8dd8f1af977abe16e6ee4c9a10b534bfa10921dabc687db1fcf215936339d94d4691f80006ed81baf1dbea47f9e1af1d3d7344395fd91061f19190a39a0b50ce93371fd38156f3de17ac70bc933ac6bdfaa475ad840f77219cd60edc73cb43ee146568dde24d87b77200db50f0e407484d806efc6c0434185642fb7f62f66d7070e7ed857f7c1790692a1f31a8ac364161261b7602b300cd082ec2fa505a4263a011f9f2ba5a839c06d13416ed52d78e6801221ceb6684b750cef76329c6a8a09541397d14aea3a297209005106a28df9f718559b9e730d34363a7968ea806d77a70105c254893fc001acfea0ce90f86c9811c0e87143a284f76a82e2df8b2924fdea3545f7e1c5917ce3f29287be25b9cbc63220ce78cc6f0f1b3241cc652e3bd11613cad24e8ffdc5e5cb2ae64a3e81b4f5d1f1692694fb15b294837bd4084e5e88d313c913977835e8ede80f97235ddf8c00a319afe0439aa60761104ea905b6f302ecfc12d97962041825ca5037c5bb5b01f16c07a17db8cf37836745f172366f5884c1a53e2a9816e2a02943eed18721d2dd84cecbe1596a7882fbc7a33e24bbb9cb4f5bbd7230ba553c99431966376330da8b82a815896f06164b2b0e3a08fed97e9c7f535af9fa1021b251717bfebac5df44e7626dbf0391512c2e89ed41f88ef472a5a9d158165e7fe050ce7c07f0418e82848a943f3e8441c0894ad7c455a37a87cb430a30ad692d95f94b7b737d3bd3c2952d458695347e6a867e20150f6bee2c813cebaea9b798f07bfe74121ea08c3996a8b9feac1f9e14bdabf5a4d77f09a7174cbafd9d6f818c0a3a3133b7142b748639bd38d2238dbdd633904551d7205ceff76e26a611403654608097851bb3a3ece9970b9e9fea2406c125d43b778245948f87bd3b797c4bb538e2a3e4b163e9be2e8d614b9279492889a9cb1829a63d2e14082b107da17717861c253efa5971445c8d97dacd291aec08878328e73de04788d39acc87e6d5cb5ee819290db93d700e3536dbcf63537933adbaa38a9fe92a762ffc2529e18d23a9066881e6492773fc52342978a8cbef5ee71bd3379aa4f0f4a54bd71272f9ad2047f6450fad2ab1366e01012c9d5363778df0120162fbd329c4ee9c33e0e8b9d27b9276bb98842a2d08a54a7c9ce8186b1224c5b491c8974d03c1d6c648fdecba163b12a9e9d6ac976c1cdf53e089e1d64847c40a9f27b025610cfbdeaba8955a6b839c43de667140f60e55d8269da47f43b3b76505981f0d52bc47182f75a8140f0307daa31c2b170f4c58f03945acafb6fe0cf410ccc9374016b9f150840df10f4bf841e9c8626d7fd66da6fbe083b7311b2f6375b1e8e1b460eb696d3b51aba503a336fbb0b8f8f0a6febffb933d877bdf68e8d3ad680e73fe91a31452ec287801ceff73b4c9757ea49513dc60366ca8439eb3c69d5920a5226505e503bca8e50e1f1aefd8b963789dd69a2456953f26669c52aebe3fff8e845d5d8a3bf88b4dd05e37c4194c6b906997d3645ac83910638a531a69cc93d9c7f4706d77e175b1ca10ba81433a8facb975c62705c4729333103cf6b2bdc748d6a99eaf17f48f6b26e466c3280dc739f884445413262371bbf1a96333eee1cb3d44615b46c80254b1f88df24c032df463a26298aa7d36bfef6dff23853a5298f2728605802823f31b3b410566fe9ae477ee25d188430b7294d4afe9d551a58a6786b4eb7ada52c156ca86851bebfec292aa977ee435483479898b91cca4aad9eeed11701a01e5efa04ebc0c58e6a847f0c4042830cc9b5e0a576001698bd907b76d435b005795a5e26644447ed6772b2cf7679629efb0b668012c58d1a07c79df17f579d76e13cd09422aeaa2ec1c15ef6dc1d7e365970a5004a49ff460944c20b5925a802cd80fe01728975ccebc5088251e7c2d3f5d69a974e30516371280739408e30367d468544220d52fc2ff2e12542b6c30744ef43fd3ca0d62e24247962ecb28b6730f4ebd38944c1f0cdb304f472940ab6feb40af3feb935592aa3392d5fec092df613866197f0a1e988cfc452dece3bd9ef7a476dcab29deace112041fe5472108f79f4fc681ff23f81abbbd72e89a9e7729678233c28832a3154b348db3c208659269fe11aa8895652d4c26d777ae69d5202615328f150c5c19d4caab3081f789c7d53ee79f653ab91a97fac2986783a0018e3470c9842520024a1e976beb80ea5f682f2c47697969c90c31c3051f9dad74927d5a518a73902abd7fe4a479d549bc201616281794370519992de66dc3b0a622736f2ee5cd4f88c4c73eef51c6a3d7c1eac40f0a44e1672920999334c520adb5686d6cfd4282dfadb22492d9991b48029443871e2ac115a3b983bc6ab6f3d2528d42d60127f50cbc28ebfabf0b55d108bee417d70dd34dd49b059b17337fa9c668f8e3efb59368feb307fcd2d93bf55d3498a45e0d22610f0d84243d2b5acd8275bf925744d3dbb4fc07fcbbae1159f01fbfacde9a359ae254f4593d0693d0a353241632f91f81887d93fd9ab3e4019fc7d92cd1a54f49b9071bf114bc49b19f2acd25c8b9d364c4644299df20da9ce157feb497f06d30b47b2fc8b573d55643683bad10fd42f48fd3d4e14c7e1f4a3181f8462f03a9065253b1be58e5a2b951a0d72f25ffcd18276d87a9142eb0e1c4a564c0fdb90aca326181c86ffea9c9ee2d66c598237a260dd83e0f50ec331b1aa97119fa07a0e12c66546560528fe7785fe7d71028121f799710989f434d0d55f4c403d2324f4c5f765d7493b6bc87097bb92d518a06ef9713aae03048c0c66034e96b597248e7a10015f242fb2da3bc30f430db2ec8c54f5b92c16d0bddfabdead4d2b0149b85a010a48e9bc877f36247e8c37f59656688e606b98133fb900f341648c5183a490ac863f67e46d164a428f157f1ac3e95fb7f08fe1223a6ab5b989979795e34dd9c21ca902e90f1e7d2ebe22caf23d830a190e58b50fe4827dcc5e42ac56867fdf9069f196626fc0fd3401cf3c7011516e70fada2e65cf6cd166cf30d24d6fe936667e13897e71ee52a21fa725797d293441fef26d643ddbd2e3a808224306c0e472435bfa9afbf74c65c22cf6c3f4bfc540d1badf93a4629fdf2260305011b0678fd470e44ec7995983767795756de410f33084891322363fe36ed7cb1e04ccfad565ec68c3a29fdab2e2e739decb749c744c33a28810ecbf45fa0fa4c0946d4843600af6e3af205330b0c41b8f8c37013ca7ec60bb1a295187c3a3dafd544d7d5e061f43706d1eb2568e025ba12e0216951b4e5c9ba46e79169688fd964dbcbc7075c472feb7fadcd8ca9d44738d53a8b37a26051358fa6c8f7e308fbe3862926ab7101c8676f1adf66ffe7e48df4c96958f700ef394999498cf1b6e1e4321b93670","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
