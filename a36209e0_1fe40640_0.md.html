<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"440b80ab5acc80f1fa1d7713aab6449e3ff3ecbd083bf14edf9262cbc88749fcc16553b908fff84e0be4cd9ee195b0218f453ecf22c728e6a199ce7fb6399191d7cf1cb46065d111e8fc6a5de10dcf53d71539c1a6ea89f2e4ea6221d33c7cd70717a4271842cb96f6e25d011212af7ba14f5bd98e8aac16519d369cbdcb3ad04b411f28d4e52f2730e26c2bca8033867bf8b4f1471717a62c4ec8f96977dc92ffcc381c18479db3effcc15251d69b622ad2872b179ab1ec8dab2d13dd02e45b00c133b1eb28feac3ac9c0f751ab62023281a7642787629b0e04d6958e75362407dab7a7a9a6199b75d22347debd5260e5706c5e7d1551c91e5574abbaec80e80ed890e0c2ac70bdbfef1ccd058fd6cf12dc9ff3a7b00dd7274d402fef69eb2e9811aa87a52fc5def6a40d4eea1f4d67d5bc30c45e069216f8997e274d52a1a8e2d4d512c10760e847803770e887f6f103d13ed323dcddbb5ec2b595ec9797f43a6a2ce50d32da1326358f2e721a75ff7fa90c29b53d4d2bb5686d9597f537d8a601d47c461d7cead4f434845d5f10468ee04c42808c196844625a16379cc8cd8ab20b22348073bb21cd4d545c66dd4e968d9948141ea78cf31c8d8e8eb166a71eaeeb332adfcced56c106428b7892c53b03bcc468efb31934f020ef8ea6ab2a5a27fef6bcad879f39c095ac4f85dbf0ba6dcc65da0afaa2a62f6190b6037b25095b67c8929dbb73929c4a5aaba53c259af7f1b351c59dec40248750457af8afce80a266d33a89dd9706248afd1e2b259367cd52a1f2882d971e04fc53b778c79cfaf122ccd625618a8d5bb9645d99f1f02378a78c2742a5cf31a966afd606da2d9c91f6c128fae1de74c8066974558a6a7fb4821a65b47ec4f12bd3825233ff8aaa52d1cf7ca99aa3ea1a4b3a9ecd8d0e3af4ee91d4ff91847704a4247da485947b66b713f1838d1a8096411116a45203cff76a8b2cefac15f826aa250449addb0dca29a722aeece45e93682993e4c58107b3eced20ca38ad3ce0158ab76ba14382d0ecf837b69daf4909222ab7d2aaad68ffae59216a8e0ba27214604fe7f519ac749be97232534f3ccfb7a0159f7b6b0dff0f81c72c14fd1c8673a04018d307bd8d356c331c8367dd087f074d28ed3625cd7b0b217d42851c929da58793d988b9fb4cc95df858322748a24cc8926a35c9219329d83a7c3c5bef08a0baf7da152741b3865aba09ac8afc5210a5851bce6ea8d83d8fa4ac919a24208dbf4cb14ec4a4a8bde923add9032dbfe2d8c525d8c39ae4af4f007b6f0a3cec273e9437cd364720475a50d79d12b06c56e2be036c0fcb05e5ad6c81d90942203c5ae698934a4320c75a1d076bc12014d64096c75893e1150f8378f8a9a3d22923e5ccc0ea3632be1c6ac08c1bce42d8546584f05736a84dc2f6af319f8f9e84121e47f886864972f5b89c8ed387519a729311073d08474f63f93183a01f44a63df4080bf98c41b7f519c4db5de4778f5a0590dea3651980d258d31c76860737069d56ee56ff4f246037fe40858f421a60e5ba868657cfe3cb23183996674fcd9557d3e914a9d87e3cc6a9d3cbddf25af5ac57c25f2760eeb2c349639d8f2d11cb2da76bd668586db6d8bd536cc996d58b086b2c6645e58ae76386ef14b8cc58bf118b1b6d267ebf1176b8053cab56c6c200dd0d3274bf2dbe84228fd1d3c5d9aebdd5bcf94fe344d89179464a8ccd4c8d5499d2f8d71f8d41d047946f0ae9e8192f4822a5664d681bab90fb0b2019a199a5c3532c1588ba3e0dc4c236dd1bbaaac105551a03e208bc6f38e3b8bd6f8a31611bb7b906d78461814da249dd9362b7dd9fd4f6c588aac01a0d06771d37f0161d5b632aecacfe4953f43d823df1a2d916615c96347cb702b14a629f300f19649077173e890506bec1cdadd1989ddc8d588caf2ac390168f1b4d4a7d195fa28b9eafe3707eec418cff96c91ae1230b69e7cc0870371551ace70a9809f40311419c2d37ed3fee20b5a8951ef325b0416cb0a660edfa559405989cf0624c6e6872b44134d79bab44f5e42ea70d4abbe6d4874bc78761e0f1270169089fe804c348ae77ecb6d722cd88cee1932cae9855f833b3b539d50747ae95a3a1afb7c37217d2256554839f4e487877d3bba476c7ed7d1ac0d060860f6a5d4242d29d65e4084fdee9a594ee636928f20a473aee95eaab4a9c1b57f821702d20f10c6cb954e108e2a30699c219e97c91fc57cdc52461f1e3532026bcd39c1d879050850683d56a31d33eaa90732693edb46379fe8a83fae76596d28f769b4460ad0d0620992119c3aeb175bf774d4634f272ebba5d635220182964fab4a1d6113748dcb29bd18350459cb1431832c8da0a8dba7501d19a092eea3e8bc73e2f00fc022beafa4c47292bb527e79f7edeb4e8bc7fd7c7622fedd06c48f350b1bae2c70327df0732b4e5fefe95c675e76ac5febcbcd3089848d3ca2808ee1cd9bb0721baa74e5fe84b1f35fd2ea8353da7c4bddb0932b7fde65159a0d90c9900952272f3906627fe7364c2a11498d4f51e1a5418095cbdccbb084bb98ccf9b0ebd656e3e17d87dc186c23a763700a3943efead1e9ff15507787b5a36dc9e6a80d25560711e506c9833e68bae3044f2f94b0fbdda0627b33255004c36ba0c124cc77e57c4fe745d98b10e7a203e92c3acfb917eb1bd1efdcea5ac57cb3e353ffc302b604222a0e34f8527e7387f6313602a16700609643ba6ccb3edd920140d56fc5ffbaa2b5849e02da60a2228a93d63c293b3165cb72c49d32159cc64d0eb4554e2d150939892e012b541f752d0d01f245ca738bf12c37819b4444b7b91ee9ff69a4926645ac3377ac03d6274eabd6d201a4eaabecc811e3fbf346b5050a523e0229d3f34cba67d8d2e7f9d0ccfd9f0f88b6f0a084af156e6d11b7b6115e769a149f98b1360bd7080ea9bc2d3566ec21564aa9440b1514ddc95cb97ea8c35b2d3333b9b0327a34f6017685f1425f9df81281ff5237b35b4ccbbb739ae7c102f4c106b9d284a52f9aac8aa80cf0ec8653b19d2995b1627ebc39c239738af3c1552efa6518b6d6ac58bbf0a6c05bb903184677c603f5cf92ee39b01a17bb25e7bf6146fbda875c3650c52a60583ca7c252ee55273b3e4132eb16420c0aa75ba0ff49f1526836e1266fffe9ffc95babb5e0e90d278a9a7daa25fc63b648d5fa8bbb1f9cdaaff7211228f64136a1cd764494953b7e0c4737c46b4cbb690e5f8ed705e083d5a6cb1b321c2e7690e3d38236acd6dbdad82b9488b7a71ceb71a9a3dfe95019d1edff751ca95914a93f38ebdd66032e214b22c551c3a740e7c4b62b448644bc8fb9d740852c9f622d2eb507798f9379f55b6432ad7ede70f294c9f13793ae2cd57ba1100cabcb6c615da9fffa9579628cd2b898a22df7a464a2590503112ba2bf68fefd853d1faa527f180b4ac95fc4283173a224c818e62b92eebb658bcd9856cdf4edaee392d33666696778dd61991ceb38d43eacfa49c23c7c9551cfe299321ffd4ce6bc3a2ebd540311687d1f9b009a7332695cef8fcc81c9fafdc212771253c6689fdb14cc448082e944ea019300071902e9c4949355ccecaff0026f2079fb225e0575cbca3b7afd67e73b0991ffc9df978a305afa6cc0ddf728a4dbf3de32868a6fe6460f8a8d342248e5682747ea120a87bb985a1b5c50ac452b8b3744a4180d38c3ffb2a7e670e27248d54ede5700bec9c5fc92531e98ff36f340fb8971d5bde384b11adb710551223a6df9df491e8aa5328bfe052de445d8824635be1537a95f085c3ab03e635e23cb2f045fa3410bcca87cf03019cee0eb73977006f4295e1762be05873e2dfcbb2e45a2d60c3771d3735a9185d323fb31e500e0ca33d0920f67c2eada003d1b2bc6aed56d3073f9ab628819aa20f0bd6ff9df40bd8280cae5ac1c6f629a0f246967917c2462ed77125498654122db2cab97a2d4ce53d17b5a1ad6c08c5d1a5fb4f0765729dc1a257168969a8a47be6eb8bbdc7f6e027842fb58908dcc42a07736d88608e6f874b160af2cffa02dceb1c22157e84769d1a9958bff911ad63d06131cd8ffb44d32136d8cd6762c23489f96279f134a7b3fa054aabcbb73964e85068b60e349fdf8a5cfec25b9f0b6e30533db60e502f89d7d13933205471a01fc776c12e052f970bb45ab416b648a94538bb508046370934233f6012855dc6344310fd35e2a8464a18b2566f650d0019332830ad0d2cd532ee1eeac14999def2828e075950441ee508e86a6ff5dfa35028f21dcbd236b2cebf5f33d63e7ebc438ca42c513e304f19c992446f3e2a495a9801456938292aef4fda6415a6d5cf802a338769499916f8242fa084b2a5bec3fd358d9daa9852bb4708b7998d9a00880e15ce6ba66a63b953317ec03842a0d78730d8551283851198166d36c7e82f0d506b2c46944d2cacdad4b28d6e208b4551bb1c7487ba3117c74dd632913a6440149c111877c301d8f1f9421f6b57c0303218abd1dc9c71672a9a8159426132dbbe0adcfefe124901dbb2c4196fc31e2735889919d2dd58d89c1b7061664133ab22c74789ec6ee8a7bd73e5b27d17697a58f7cb6709ce17c301fdbe8331c2dcf6f7ab208f23917a0c36af9d3350b2c506ec7068d893a9eb49db71d733f045051904001a21dd930eed2bc48287d51d3e2c6efb3e21f74e64674b92c7953e9775643bddbd33d497654a2d81ed7e758af3edd180eaf97456a0f1beab544ac8b037026ec75d0c4c007c7f9f773a46641fe6181e0df0d701d910733ae742a5d6890a77600a6d54efb5c8b8ae5507e11a0b21dbf5d31e0adabc64a579ef2408678ace30fbc4c9ca36fc57105e1b7ef73927e1216be08360976e79e3532812af76bd7ca3fa11aaabe757a10e96df71efae703dbdd0a3015b051b531043720951d94be8cedcb003319a588c14a417915f8ada8aa980e6f2fffa00eae36efcd231d0adc33ace1974f820c2726f2b56ba91936988b231c7847291f19f09a28371a6f11e244c7c3cae8ed0ed5878e3365d6943154674920bf833e9744d59396df23f2acf22ce251f09aa4868dabf2e2b02e47303526c2cc99c32651aec8e018d0f8284e7054372a7cc28e7bd73f2208908161a27f7706b34a46c837bc63251f2b2a84afff9e0e4be159f4ea98b12c6d91db67a948c9ab62e433b067905c8776dcbc92ec659984dedc13c0538528a6d474260c415e875c1c981e7af1aec776e21684ff640286e0fac75f0e64fdb569a486ea6e6b0759bb0f9606bb2d5da1040e92801cad4a1ed5ee7e74a6321e960a185cd8a0681ea5de2fbb815020be7318e66bcf25577e91ad2ebf3ec204223e6b6f65f2a507cec99313e26d963aed6742f5d626b8be081d79b97f353f3b51c899820804535cc07041afbe0ee9b7ca21bbb7809f5b31ef0e2b2f9e4e5f395e2d0bcd0231eee64e2009c40323c7c30825318db063f5cea15b0e48cae5e511d62337d0849b9ba02dbbd3ba31e779249f13af26f8f3079fc4b80c778d1fb7dcf1b2dd80f317b7e54e09295e076e95f0c70254f2cf6c412bf85b2bbdd655da312e55ddec6408fed30b7d1be5431c86c72b6700028f8b150b7d1b9b2d014a340012901e8bd87900e68e34fc83ff1f7ec38f04e7bb0442c6fb3f9582b7ed1df5fae87a304fc49fe4abcfb49b55521daff5026c81fa27e23c389e8940b1d6596c11262885a37b647e062c3e63f3ca4bcced62b6f01361c904aa27a859fad61b1071c56dc009e7c5509a391539ae66e914c8f5e6a5737e5b17f0356c925c89eb9e7829ea6ecbc03b77185c8932b92aa4c1bb9b214861cc04d7ee9ebc68ad1a6b8af7a6b9716e7c98604b5f223008b247eb4d4ad0c4195f5746946186d2f006f4b7805313af8b4604cde696f54d49406347c79b9f4247fe75096110daa2d6aec09962483a516c338c364349985dc98185834152c11f7a00c64abadf42355072734029cfe2ff9267eb0b96daf8ec3bcef5d0e4f454e23330c3cdadc7b46bc4bc553f8313638526ed6decb34b25c235ef9d0093c214ea7b12d20b218a19834f41994a5d912ba8dbc4a54b3eb9179c7654cf55fc3f761bf07a1d4914877149413317fe75fa53b8ea9fe3efc41f55b39ac78a69648fb0de6f1d94efbb411140831d28e943bd5cd04df95610e0bc838d80383fa12066764f05214f914becaabdcd0d45cba8e0ed04272a66b6b3d188a994b0c1e725d970213d2f62a375d3f6a12be29b69cc03b33c3c1cc99e4a6f9060f6b0a0ee7437042dde4fc09e923f5f19c9f1732ed785a784301625df799aac8bb48531ffe40ab827795dfe434c8d78b2e1e18fda751bcb00285aa8f926472a3ad83798262076d135217d061639d20bd59e4cb6b57bcb1e1d763accc60f7aadd1dce0a2f040e4d4f97e76bdf0de83a54c561920ab9a40bb4874f980ee26bcf2ba1bfa6ec8c600ab265da15b25834f30bc011928bb80748f8297433055188edba2cfee5a934a3a9508ea53147ac9fb148fc91dd1043e421d4396ce83282c40014d4f2519789c77c5cd046ba9229c1361979203065fdc64e345073983cc1ecb077f056a39472440569cfd2f92ed509948a3726012696431fc3d1e9d20c83da78712d5b3d62eeaa20bd56f96a7aaac8e81e932af83a1f533952c0b6f8596244b60c01871077e4800e54620c17f86a1ac41b22e116c92a1880675ecaf504bd77173aa303208415c88a208cbb6b591e2b0560207c83aca82a4e8e875784c4ba56871cb859ef6a621261ec66e5840a757f95a3989bfb0c9f3f4b07e7a6e5c9ff94bbc010eb31ced8241446e7a03bd0e24a6305acba187f7d864c8222aeea6168c8e10e330768e0e70f5646f93e69a470034e2811d9b788fe642f78cfb498965cb04b3bde1e5ac8a66e2260ce70e65f3b3c51f6eb7e7c93bb5cde7504cc1ea920ca706188f40a9f90b607bf54fb68de40893262221a7e57a5238b694e61024259db3ccb79c325baadb9793cd2f66f5a55c39a697cd88824a1cd84aded80a5a74c7a583c72ee8523eb01d79dcf3cbf884a6675b23db35c9cd74d9a8791985fcafa645b2f8e06ac9621ddab72a7bd11e1e813dfcec4dcc98300462f584c2cc9ede3852fb98459ecbaf71a48476147409060ff33ee42ff3f89e480149d9cbb92a3af41130df05a517a5bc60133646b22c554d4a9a1be6d82147e10924e7a34da7326ebad2bb9b0e9af8caa6d9db82a2c92e41994300cc08bc024dda2ea29d6c545f5f51e243af2951c909d9d6a088ef97e2ee6f6466dad318e93cd0b49b7628b0929d832cef637e5b14381915146bc6dab6e3fa2f901671aa47a25827f66181f2da4b4169cf73277cf598799170de8ddcb57baea1e58efd1862af3f0b76a8cebd1161ac4a7aa3e8dfbfe4bde1852cb8d028573c7180f4e000b6cc30f62da3181f615df1aa1cd97b1195276b61c8576e891cc4319659329590ecd3a1ffbc19ad6248f961b9ab1e80d5383cb3e1120df2dc4ef788003d0fbcb7c5cbcba71ee4aab1415c17701d3f20cf45b0279edf7de0da01776e1af4780ecee34ac8cb5ea078d1ad64b834be81cd1c03baf4301c6c241dfbfafb66a98ccb59c0727e6c3b42915d550deee452ce041a1424d965672f08f8192a2678856040755e4fae2def1c511e6c623293318308a2c4caab3e4a6792e927c4d06ce2ce6025016d4c12886fcbb36aadbdecdb38ce14865a6db673c5d2449bc1c7e9700278210966b2b2f096caeb169d25cb89abc30728b89fdcf4f7e7ee27ee25d1e1c8e9d9d096c7b01e1b673801bf36e38a081fbc68bad7a1f656cb482a0a33c4be8fb8e7c39aa94ec585ea4f871758afacc47ccd9f719be65683c3bd111e041d84b511b9737cc7bd815229f230d01bdb107994798a2a38dc275cd6418488490999a08e4e12d66e70139fb030658639abb04341ad148939e0254f2e54329053686db51dc3f69e347bedadc53cad1d186ff04ce98fd31bba1f2abcae5094145dc25cdc6288cf4a028d1d3c63e2e0ce4e9132e5982768747ab837fd5d8d6c76d7300aa26bde111fd5515b80f2e79d4e3864acf517a2d1eae1886850c2803d2260b19935a002d1c5181141bd30eb0d7ab718042e5305d51df87b2eab4f0961a47448a2e205edae8cf880e89b4b659cdda672bcb368e96e5d999cfaa0fb7d98b7edebe5ea8ca30e4eca53ddfabae42351a71c381b680f32e9ed739899469784dc1c0572a6e271fbcd44d026f03953efe935c3580d8830d54bf6ce7fa01e12c337e334c65137f6f813513c2d7ec896f9e520f72c8450119887b694c0632e99215e1c9b6573ca10c8f6e1c2645c2c7a69c8d8659ffed2c9e406e6653f1e0b0f75e329e09f199033faccc2d0bbacf64f7bc17d1be77bbe604acf7d90afd09f3a12124125d9be926f9b64594659a199397fd2bb3d00f1504f335050756e884ce41b28964fa1ed58d74aec1644ef05039d96ce07ca291f5f5c819df14817d10dbcf1891cf08ccb73cb2b7497e4f3973a9157126b3e6f718ded3d5ccf9afa67bd2271c6ae231b3f05418d4cb6a3e69c51847d54b0b6154b72e8d12334fd76cea256c64ce5b170103ca652af6357d69fa6a7123bfa281aba9e5676a5c3dc6d0a5be533d2afa4a527a22ba22fe1c38979399f17c02582246d5f97ad948989d59af75837c47afa81e309580843e137011a5a24dde3c544d3ab766758050e87afc35f516d668ff480e181a37ac5fc55821c2c376f0cf467a27ab118283dead38a36df94f98a038ec56241edc3b9e6d69430866c0f6befe0918689a7c0bffab8c03737f6d1e7af6b36a77554e5f1c2859c931e4cf915022a34a3ed4d076718b357f553137cd12312a228cc8f37c01e8658a84815a5a776bf3345e974a29b28d0adc16fee8a03ddec94f46f390a973296f02e03fce20a2cb2781ddf23569d8343096e5dd3c1b12a55536dd7d6161e7aaecdc2990c00f0d3884c70f4ac886bc9da80d79719373e2cc2de5c24fa79a4641d2b8bbad40c5026e4f0ce8c573558ceac139f019de271c589a5d87cab7cc818955d819e6f76d93d227e0f7ea74598675bf90bd9130796f3b5b3de041fa1e8206b4c8c3d5e91f6578351cb599e70be0a27a4e1d553c72ed4c2e3cc5905b38ffbf30808a8d45e93d096df63a8e98afc30ae75098441db56b5c2917a1870f70dc27abaf579fea3fc242d6d702cf5bf255f0239125f614864898cf893df67487ba20c3f19ca4f9ab6e4140679a256fa2abdc87a2924ac14956748612f97ea6597daeb59fa876c3524abb83e4affa6edc27e3c25a4581a734262e8d6db66a7dcd697bdb84d78495eed81b1d7da34e6cc8cf02a300976efad8a47a2ca44f07bdeb761ef53e28e43070844d2df45efdbe30d0feb9e802356bbe48e3b0e37c26fdae3529d2d64964c24804b7a3660b76a6207cd61a19c8458a74b410007217e0f9a998890d60547861240cf3cf3c8d4a8911dcc3e25a37e5df36ec720267085bf578e5693cf17bb8c75277c9e53f8353ab99e9d20c134f21c7255ad2f89a66b420b0a5bc075f35ad7464ad35d0d5a499b07f0e01a680d28ac99f3f559e0698376ce0211f7b262d02e8af41661dab88ca2ff62fe4b3f831c741ef7e4180d5aab4f10a4247bc48f622077d1f15c01f7da31ef104caa4ccdd71a9726311af933d8d87e3d532a8e66272ce1c2f1bd8bd18ed72adfb4c495dee5abe9cd482905f893ded9d7ab846e712b63f7a8033133dce54e0e350e7e507b95e559c719db3928577af9a73fa1843b89325fadd0797abb307bcc8dceb33428b2781b7f150e58bf33e4a4819ae3ec2f20602a82826ff439849706976b15fccdb9e626c7dbd3b85f65200798163cf39fdab3055af04749df0eccee93754e4d5ab1f58fd24c722da1a7b003e4e858481e56aa0dcf49721999c4725b947a9fea4b26c17eb9e6ef827737cf51dcec45fe90111c796f93e34a5ea9f6f62dadffdc087cd5ab521f82b29969621ced1bf3775417bebce981084748dae07f7397ad0e5ac79ae88d541792a5aaffbb9603a4710d078decf7cbba00edee9b98bfddaf664a12e636a4fb49637e4ccf7ec8120d33188ad359edcd8e6f12987338c471bec7222cab1185352d5ee114db243f45c8063f25609a68bded0bbf9edd50fd5ab412f40f92cb6bc690b3a6c850dee99acea35529df4bfc1afd2f15a32ae7f199e19295d0b4c31cbdf7ab442db7c18fab3dfe403b357861b4fe7c75a63ac700dfeb3075e461ceaa56e1dd4d24e529df4deea0703ebd8e846b5cb957ccdfd3585c4652e5f23ece88be513c76d0acaf9ca79491e3183e9cf2153a9b8f48b52fec108564510f15e53efac863ba0f74b8caf5a10a672c7d7e7c866c4a87bfb1febab7fe4e3bc9928a1f84c2d0eb4cfe8237bbcb79aab05a92e3302f258f92f32fb8ad4ea39a03e661962f6404168d3a5e862cf2a0138f0b2b020a4bfc98a24be308bdebe4ad346f2f29317944d890993d09b7d16fdfa3ee99693f03f5bba4e111540ce6b9bcbcbfd535031a4152587c5825e3ec716b67bfd63c9c82fc924c764c63e97a33e8d8bf7c299f646c3087c0e354130060a48a9c1a44d4912541d63c31ddcae6c00b7701bb7577d2a81f882d67b06976d9ed9af52a7f5ef3fda414f0c6b2eda2631bdc65eec0d7e8fbec6439e0af8633b9e8a49b44472a42ef0b627d5c512e0eb21ab11ac932ab1f57077b955b7151c93d9ac6de108ffe2e4fd818fabdfd7234ce21b03d22b7a086d4d3153040f651fd0f159af116eead059f42b05bc0a0fbcc4578fba361db3ce961ede93736aaacce6cb8949776dd431335aa5f21688042276c7be2cfd0fd04dcbaba839ff3bc7953caf54dfa0a5f19552c2c15f6105f5a5952361b514b9184f1801bfd89fac054faf21ddd08662950d6fc2a6d0b3e48a9693c9b68330c71658f02b685129beb8235eccf6449007e640fec045d7232ee858d0be0f0e653ed21041c9c52b758a4c8ec939014ef6480a56e8067d0cc2e7a50352feae30672c56bb59d951b001e120b9a6392d5237e9d8b2d2ba41051997d13a3fee244930f29a0d1714e24a80bfc91e61d9511e5d48f18dccc2a21fb3fac432a46c08dddacf7c6c32922793c9b024d66c31891e068e88e748587794e6a7407c64d53c2fb0a2aeff92a4f71db397c329afa20b7f7eb0318fa0cd9b68a40d1008c6b960b5f34a74570eb726be21ee9cd0dd520415e10851b5b65d01a8fc7dba498d6635b72c8c501713fc3ae9ce099ca3cb4909ea57f2103c42f0eedf76f3303a4d3a2cf0df441148a08f9e706af35d74fbb0ed97da620b6e3b0a9db24d4f3bc1af6a24f1e336bc76797af156303a74e4b0c058eeebf2f7acc35d703fe2e293bf37d6d3fc9823338e1afe8dcceddeefb1dbe8b6aaa6b023ce9fbe2cebc603aa54349d9a4152b5f9554666d77890b6dcfe28674bafffee2ed31eb497a81cfdc7c232ec9860e82a46e27ded6b357a600736f923d38872c22790bd8a647d075ccbdb751c058d28004c33dd1912084d0f2f22e2b5b8a72eee12069db7081d3f69642701649f7a46e99e6ce25e1bc45db207095c3c096077e9394247a7bf430ee5f7255d3bebbf2731a0e1bb1bb02bced818f80fdc93b0d2de6c10e23040a431027e8f94c074969715713d859282769fd9341e7616ca5e9ca1d45a62b0e02a4b3d962f6931a121a8247ba90f1a0fb7c303d5ad2c1e91e8a14a9aeeb0142feb0db7c0d40637473744f60287d2452826d9bf27608431b754779c1e5aaa4aea939ed86c7e099f364e31d57b6b212932799fccd89d422c2bb7f9e200b18619c255be723428645d811d95655607b93668fa93dc4e786e8c75097b9af68e154efedb0ad15d9ada2deeaae8066a2c7d69c8a08af9a657e450a002e5401df78c2eea63c70fa1b9d0a53b05b88e0959200d0e13f19236016c69ccee5c1dd4e25e89c43fefd218d262546291a386a3e122c6981de29193013c2595bea9e93520ab303f090d6543bb06d0876685a48bd090df72276848dffbc1ee7f0fca141f94aca675daf43066e865ecc4651bae3295e7a6e6c9194639a3ae87c14c7529ade48fd583dc7b644caf5c4328f1a0dbe609f04b763a42e503fe646158aec1afb208656d913ea95153063b7a64719a3d8366c9abf2be0c858f62a6e70bf6ab5738bfe9b893cb774fc0045374e06f4beea84701eb138d633961607a4d88dfcc9cca444db9b5cafe4a4c70a279af51a1be7b193793fa262e4867fe8b851fed886cb09c52531d9d7d40e7c6b1dfc87ade81cf2b4463956f779d37bf31a225ed793a29b086b994b7980f005eea61742d1f5412357a60b21e4269229727000ae1131dd9920dcfb21cb7b7530af2a0b474ab1c8ae28fcf8338c40c98160e309dfa15cd94059906c692b98cacc57cc2441d38482d06da21a6cc45a0356ad0a2be86479c60799022c1935198819c737d04791c090d690b0069e6c22e32179bfcb5df79b47d823e2fd4ab1ce6a59c1dd04f55ed842fc54d89973185ba85a623f9ce1b71325bb2c7dbe50a1ead331874db426ffe3ffe5c5a88178d5155375a95a9e09caccae9c96d635cdc548a2561cdf603fae647a1aad58f141600653d1f4fbd4fc23a0d59fb89cd66b5e3f8bd56e59a68081f3c387b2d3bce80aa446a4f2254fdd007f225aba821365e8286edfeda8f98e53b655ce886d94f316637fabe7b4c80ee1887c61c2eb92eb15b54606882c2724146c79b13b1eebe81a93fedf7ffedb129dc091a00e96f23327e346b0d0876874271f4cf9990292fd9f102f5ab01984a891f8ec4785a5b9b21983c74a2c88e074c579ca5ab58e623563cbe60a06e1c28252840ecd15393fe01bf30d3f4dff01434cb9ff2887f9050a7e779af4f17da322e945ad43b2623dd77f54cdddb42303cf06c5b61903560471e5991f2f7c6707731bbb9ef7d27cec3f338aa019efde507d738bddcfc956a94d7389e0f6caadce740b8d4018097bf1bdaf4530a676c364fe66f728678d80c0271c35578c55a9439753cc01af223cddaf4356fa79329e647bad0642b20b1e8aa321fbea853c3e83302f3441f6d9f310051741aad1a59627145be3e54de0eb9a440efe3880149859fcd27853e21917361824a3b8445595a64f4dd2c3998e70b2de2d175b92a8c4179ada8f4921951aa604581e2f72987c40a252c91c8b62936b73a5b366f93af5a551ffbfd2435891a1c81539843bcc938e99be4d6f4e370afc288bc285367b1028f4a9930dd99da67e51ab585634d00ff1eacac4d6c2bfb4e60cd02f44fd4ff41db91d06014a02d14c0998645b6fa91c475186439df360d7eb409a4b552512d2f1f3df553fd79f492d498854779787d51ae2f38ad0128c0ad5945eac8724ffa43aac61e94240734d5b634dfb6f4bde485bdf88e7c6a5d5af8f091e46239f2e3e7da8faccb248160bdd6d88a14c3b9b59b5c0d9c868fe3492db9a4cd6bfca1510118843ae355db303935f88cfac5a28761fe6e9e65ed0a032a90b87bec85ef4834c62d194b9a9eef0a197cbbc3c92f6edfe641682115f37e5bc641af9900653ee06a7537c5edc068747d941f94ee5f6f9b3565823344f2ae220716db47d380f27b397011f5e653018626d00605286bb3a97b83bf6eac1ef31f50326ecded1357c29ebc1c9ede3f0eec2a57be3f59c880a690c7c9acb2c647487bd89de6f92346e220ab3318b1ad5aecd7be6bb3541b3e5515ab85602112ce85750e0dc7a516a93608c77e5057df723dc9e21bf39328857ab7e541191e37e86c7be4999402914ed73a0420a1a9ed7b04aa6cd971e2b2a2360b86f3b0240c4e11e0fbf89e0292c1c9c5518b1256d46985e9fe9217ef4bad2d19e5fd343d5ca89a01a2885a32e71b01f8a08055ee9e1d15b9996d3bb81606bbf1fc74864a072be7265de62c3e2adb0fdcfbe8f8c3874065194135be1bc89b954763c2f3c3c97402fe849cc0d05350b6ccf5f2c81fc8307ca9d1a5296d7c0c93a091262819be697fbcc35e8699f2e6b3fc0a0c845d901b5e5e6a2448e50491a743e90f87ab93c6d002ea9b0e7a697d75239966bf406014fdb6f66d28f9e2ee5a5f1ca42fc778c32e2e9caaf9e4b02419a823d805545002eff533ce61fd89c8725fe852a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
