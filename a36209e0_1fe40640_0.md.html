<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ab38744ae3829329acf1076eac8a0435bb82f40f0e3f9cef4f726ecc73377cef47ee3305325dd2c3a2636b7cc9c8377a8660f074865aea30528fd61036eaeb04dd28f3c360615b717c50f46a4a3697e31ee78a4844a50edea8a0fd1f788e6697a28d83c7f0c6026768e8b740cd038e5778bd1435143b6ed069af5f3c35062e4939e3e3aea40dfd30a61bbd754d2eee1e4cc3428f254e33ac83e279a9d65d70f180c3d6b5e946bd61dffe8b9dada5de6bf6f45a5904de5850bd392a3f2713c4a8f08bf329f4088a900d81f6071e4666ab753a0e286c2b6a798a363b7f044798758ff311a61c9f61cc1b75154b4ec1ae0ab244cdde5cc40c8dd75a2c0e1707f9f0ce76d18a7b103724f1473631fc25e52dac4a3ce1beda5fbad47319d8af58c4269fe1f9e33c44f3503d922bbcfb4988900365f0e2981d44bfd4ffca71ce48a9cd43d50be5ad773c74f83af2475c9c693153c759e3182dd80b65af2fc3295c2e71e18762cfb98fb711f224f35a33f01a339e212f9133574c774900c549f30e3b0c70c3fe424beba27eb161423ed2b903c098bc8cb69ab1aa1d62759050492f3a5b68cd3e55e207133633429dd17c543949ceccbd74dcd6d5e2b5d86cc39f79b71dec3e9a0e56c95e4b95ba12dc86111e2a9800831f6b9581484c5b4403eb26d61d758196d37e1a0df36e0b655f38b0fd4d34734b99dee30cbdb6c239fef4cf497ab69bad053827e2e4284540f8a27c3b298a0b6c440fd0b1bba6e68ebde9c0a95cae3d40236c54a67c9a50a45633afdcadc864d86001f39a918c32a04064b3faa0da83c574b5ff29289b9953be02f2bdc9ea5371e5af69cebc1badf29ea38fec43be4af632313fb091c21e6e08270a4dc341b6b8fc4887ea76fd5e2cf5396e22bf8753cbc9a837b4e88e1f2a617592ddec2a0aa5a93a7f8c67c5bef66c34e72f2488f04d4fad37aa95b8e125626711962376a804fec00f03d91a2e39330b2bba6726c7d68000f5d5bb5bfa7b5290bc05a4438accd8f24f6c2aac3995ed78e81875869af7e76ae2db6e8b38d8c4ee5951dce80f165d15daee0b481d9ef3c218712fcd00ed0f9e60fceaac3c0f99f0a089b9603213fb98ffbff7b4d065ae0cac01469bcea63b71c54296bd987fcf36580ad7e94d58846572e049ebb8161bf49bde63a2be44eeb249a17fa097462e18ccb9296f0d5dce3e30b8d34c09c2abaeb79c7eac30177e8c4e49b241f820b36553a10afc5d19c91167d2d1d758488a3b0159168ac3546ef8be359c4281159046cc7b2ce9cb1a41df035855e6f1cf218b5437513f67e9c55176b74ae9a2fdc7d00fb6a87bb2d147cc20cfecbaecb0183b19edb2a55e20ea42b166891b45ab64c31ca52f7d6abdf19a35d42c65e1a0ee6f063e96757949fcfdc491d59e78c6124219433aed218c1fe5fd1a4efc136bb0eff5ec3ef638c73664e3ed9450e5b24b9b6ba00d3430dd9c12d36eb204de3fc0f1a0c544471e6ba465e906ca22b46f7c84a1df53a28132a152e22d32effb0f9d012a09e2a736efc43782ab5a52d754710a889d207c830393adbbde4bb2b73b06f1eb6c8a88c51b41d20e0c56e4141abd61551d1ecc9ed62a60ce62686418188349a563e9af84b34d4a82b07564071e33c90993cb21a5791706eb6d7ec0eabe8decfd1c2c78608a3e7a87c6f866515e6cc5d6b5429845710c74cbf220bda98afd8160e71d60d09db2700ef4d6843eb072ddcc3913ef1aa38fe76b261d2ce846ee1d0c3b42e321e49e453c259df783be77e37f9a41fea55ab7ad6dfceae6c53b27fa8eab96ab1931ede8f8764578589cfc0f670aed9170a2874853bbbbc03d584bae224a77b926f7d2a4f6fd14d1ba5d87768018ebae9092dbafe122bb1cf4fdd38966fc4a733046c4afc5c7da3f147b6c9c2a61272f53e1731993c2cf9587076968d141ee829c21a69bb503aa7dd71350e5d458d4c42322ec32e64b23445780401e5db3a5ad630e226ab15a3e16612402737e382057194b65b2becb4a0e4c5087ffb8030808e05439b824ca33bc875c333139c4af235fbbeb563635f2102a2f92e38e193022fdd6df90a389e6bac30aa3b2fa914d6fa8cff0a0d375e959724d55ac9452ae198710ac89d655c14c3dea1ea0c9b9caff8cfc24843ee38253265daf3cc368b8dbb6c124d7a124736645e63a26d6784ceb7191bd40b1b1850b0b0b337eb4638842df51f90e749900151630560a78fc6717979cf752dbf3e702259089f76f332ce8341ae618b75edf7d73c8ced00d37c4b8b46d72b2c47cc9cf7530b6c79c68cd3254f977354627b4f1abba65b3dcc2a8c4f57a360f8d8f510e8533f1d138713ff0cd52fa0196d0569db610dae1e96c3832442c7b407a0adb4fc6ed33a792fc6a6f6fd86e975bac4880e38f0a31521a71817c6c1a13396a7544d17ed848f5d9e1a553690b7dadeeab8a140858ae66861395bb840f86e41d99d86ad1989ba0ca901af1b261e28dc25119cae77e4dfa0c8a582e2aaf426bee9c5258ef6fc6f4185ef9665aac2245ebce3aa249601accff8316a12379f4ed59bbda54b3d67770202fe4fc0e014b8f70a313ad8f39a9c44f8b82c3727cbfa22155672e88f8b9a32e64e9021048460382b4177c49c13b4f10e7961d0958d85317ecdfb0f983ea024a4c45a0b6fb95b974437b69e86a6a0b011e245866e3db5b8fa8b194e68ea1e64b319af1995527bc667e0e749a46d35d2ecf10dbf7103885a9cbccc27e8eba3580a15dc7f8a0487d181f670b484df0dc706d981d1df37ca274d7a0033066d494d227aaa2b92fd75003660f98249ac1bb3d280e4f7f6f95fe148ee9f506c03ff1b5213da98bd8e324b14ab955299fea3296dbb3992ee5f78fe14aedba38be3f964c9512a7fd0fd6a29bdcdafe2bce36d61c196127b10e692fb53596c07362377a277c0a133d7a4cde13484aaad63f32b4a3a3f51eb212991b44bb4d44ca558ce6002c9511985478ff18cd647b0191560ab8139e9085a10488aed7aabe2c6b3a3fb54247f34d4f341f1803340c44cff54f05134c5268ba1cc57c3358024ec97abf92eeaccfe4e7365277f900d428ccef1894cc420b7d159fb4d7db4ae60716f2a8a016f45ca0f76a573a5afa6fa9311d082dfd0652b43418ee1273a2b93d25b78a18025e559ebce3d83d3cb5f6948ffbee503d5e8543013630f953e9abf6e910f3db6a0f8c2e21a01aeca5bc80eadcb1dbc51e2a8a2f18ff03e8e0a6a5d16109c852412d1b886de13294d954369d537b51b3ebdb8b0df7b9f902b141a49a571325c03a6222863a146d1966e1e3aa111b4c944744f90f6bcf2c9eacd58cfdaad91696dadc46cacd1f057c05719ccd521a79065db1fcbb7bd70cef562e33e3765a512b242cadbb8c63c4003488cdab411696c02994659130dbb3aae52df084202eb395a59721b16dd62fe692d12e8940de326fd6bcdc58fdf99d0fbbb7fb0d3854665e8509c9313f48c0d876bd4e24f1c626c814e27692df582f722c2ab20561e0f1ab069ef09f67d116890ecb49d20723e654fc00d7b87c38a748326ff99a0bcd5f9eaf8ca8a74b3e8daf0771bd1eb991cc5b8e6795a09134963a797be49da8acdb47c6e5253042ba86594bce885db1a3393a012b56c7d21ab6b68266db1431174916ef54fd282a9462a031f64365d93fbc03ff5f2c22019663e16ba7d50725f8348fa779686c64683af59c56eab0717741610ffd16ebc19cc3fb4e0d264b3444ec268b4a04a92a101e84895227417a64103c1971828577958bba4c16a0c4dbf2585fed79b4b788423a38486b9946bac1805239692da138d83dbb8fd090e98c7c6df42b484d7ec14802ec41b28933f296fe1378d55ada72c0f6b2e1e0426b1c50635d43ccf339717dda3ab7a153957b2fcd9af988cd3ceb4d0bb816af6d9218d84eb0715c2e99f8ccdec1f311a4b7c6664cb0a44ef1764f5e702101380001d24ad5933f30584f5036a4bccfb7d39bea2e6b9663a6cb5d90853321148b485107987995cae3fa8c38b567a5e4bacd9163d474de48dddf7041ebea08ab9372535b09156f72e027f40f4d37410e3ff932c4d3419630852b142b4553c6a21b9994a5455b51d619255c37ddd4f284ba293da804dca3b8326d39f7f622db9c9cbba131e72f0d96fb1d9ae9ea2e54e025ecdd11cf3c4ba91dbf53fbe3b77221c65bbd6947b4eda2f16a6d23e4eca154c8714f8d4a8fcb93d0ff52424f76b9f67ccbca42c603dc5f16d3db43853fc9fb79c96eb0c4d97f90c684bfa1d52f325da5654d86039d36a416dd72a146b36f6825b075c264ead0df77f2c2615652d66ea645957f2f7ba98a53731fdcd829b43abd0f178dae040fd75a685dd6cc394776a2a67f8e3bf5eb7a71d4a2587409a8411f75d61d16a019971eef9713f3d2ab9e5f3ef3848ef1e563ed9615b1a8f4a593bc1d088eeb5b855c4921f9ae0bf1154e0162eec1edd34afc3e2b63fc37b803144e267ac1314c925b8de86f2f4e2ad93199ed598fa4554bcaa066b933e95772ccb506e22ed6e799bc71ad67e4599ed5e41df7175b15ab99728d8d9e71efa27045fdfe69b58b6aa3e9b1fb6965bbaafa81465473a5a8431c6b0d17763c588659aeefe79381de6d404364dd7b19d66ee58e4743be03e306699154a55cc5d66f4e88931cdc1454f4f98e78611e1e2850b6e56c8c3325737507b6e3fc8b729ed02e865f893fe6d6a0bb81909ade42d81bd742d2143ab9fcab29ccf633f290949afbac2c3349d5270d35e71e3a2c78a283bbdd704456b22cb5349732f5edcdc5d339a23652b319092a449185202173a179f89565a153447199d7ba894d236038fcd6a4683ce1b3600cba48bf39d9a5f89a591dc71d671d3ba906450b6d95b1757f0d542c9c10ff7092f0cb852913fa92d1d0b0993ecc98780bfe1e9617cf8535ff54fe1e642ca8e8646489ca2156352e00745925570e4f43c3ae7e47bcc1c552e4ffdd4512033ab6df233abd0447f35ae3860327d632e42a9a8f7f859c94c2195d765588ca3c2030e1db8eac245a0831ac753e1dc4bdca2458d60301566f59b6fe114cb61591dba1eb742c2a108571c13ce47fad9426baa44d8a2b4eff3c1f2540668113ed282528af376d7bc7f760c03a48551befcd0303b62809b00e50938db6db0eda4e0bc3a479e9ebe2a9e317b55707709319e7d0befc4c3f503038f8e9c6ef2e622aa08928ce13ee7d481b7e79f4d2c6371e5bdb76dbc3b01ba5d126f33def82640d569787c72f9ca46205b1ea0060f702a9158f44403636d1a27fada2ac22a00d082fe110b3d593d4b939ba8868d58e669a5f8cd69488df1700ed56e549f3eab9f0c2466f3ee3a4023b8ff1c5cb8f4765a89e687b4068298a98d0c80d90fb54db6ef169132f0951a59e611dcfce1695cb7c2fc048e0854305f16197f86394b1ac4931c2a1d99018252fa418456fee607e20a1a4193736a102bc4b5fe849e4985e2a0f599bf3ec54298f2d1f82b1ac8be753863a5600ab9f07bd0c819b4c1ee114eb07d1e142b015f0e5918c3c30186616f54f659d9a0c6af58d586ce53bef568aa77dbcf0496274a73e1633a086d396f27a45af3414a3e8278501fae92dd6da571591adf3b41ca1badcab4c7aa63e59187a84f5bd8babd0d3bd01f5218daf49c6dd4a54abb99b03b511e7e1bbdc893f1e99c8c768a09eeef801f43beae96d74ad20223d5ea2c13312700f1b72afd105e85e3a0a1b69dbbc6ed11fb1a9cad8e2ecdbb643a842d3c176c2af09c55041ca043c96ad014152394e5640af2d0d1354b9f40e5eb7ad677e0e08978fe1e530aa4afefa2eec81f2331a4aee2dcf5cda61752403a425a7ad04b4de06c4a5216c82506ae78b4085bd1003fecf5a2b04b2dc4a6090fed6df5c4862acf7a4f3ea1d07cc2f7bdfa6bf1c9545c626442a7a84c73ed3ec6ac868b4ca2f6772b8dfb9c18a39e239109709a32dca23ae54567a0879d0ca2ff293d7741767a554b59d59f75b97f7f06a4f4dbce0c6a61ca0bf92968648b5797d9173ce22fa7e1a32a3bc717aceb26722ac1b322622593c50b716d457ed25626dbd29201cd78dc86e00239770bc2da7ccd920a98e59d95d415018a3b1fd3ebcdb32ef1bf37114ca870e818d30c99e9a3e538d5faa6ccdb37bf1a134a3241f25dee3a38eb498a3178636a7022e30c132083123bc721272340568ea35cf9b38192fb8ae1d54e918359f4e30718cb63f3869f3a516ad594a0ca6c902a6f53669388283c06b0517a866b154dfeb03aa8c555d1ba62d68ffb38e7324307c426b069f6cd22cf9eb4b5ffe8390bfc88ecec47f23b0ef8de6e859c578f24f8f90bd9b78a91fdc36abe013881329f42872d7410450776e8761de3d52b5f3a42dd0f3e9251c97d5d8a83238b8265812feb9b89053ae84decd6381e1fe630db62ba05f2277574107f8b1336f66a41d4c6678a2bfdaaabd971c298a446d9d717cd06438ea6f2269d184e87433ef7fa76266d2e7c3f9a682e987620871ee9bc164f5b96cddc29d316dfcce3fd15e8fe5021ce0a61a73ea3b879f5b9963383dd1745cac96529a2d3ed83205c3643e909d2ef9511f21e4af4933832f4511e2da068f70c93885c63ca26f8f3a000c7f21c910f649ba9003c02af9db9cf83ab24c717124c8a5dd3cd80f70db8d94fdee62d1602ebd50caaa4003161da15275b0fd876747f29486f53fc8b85018b8a8142e9050c3c283ba7f85ceb93d8e3e17336dc026bce5aee202459a3cda503ac419ed5b8a6b3d9029612f0a0375abfc0d201f6954de9561da0ea4c0d2661f8ea126a47e64f0307f7979e875646fb96d0a04493ed53c21b9a822283c802f7c6df0476f54de1522bd34ed657259b4be7ee5955d8c294ac0a19341bed7de98ad252be241c76448f31a48224e46a4815a05963f0655d134b11b83a25bb3d730ef0aefd7563e3f258deb85181fd5735e691908d56c81370fc9849b1c2db240d51220b8c9d267a9b54d94ddcebcdded0b3bebc1247438de62c1eb87d15d343152d1dab846ed5eab0763fe7c96bf290d687db87744967567a69f7e5b42843f37960007c0da7976e13c39eb662858b5febb8f2dd560494e3d425e5633a564640e2aae7a83eb38f5e3a1dfcb1b7ef06b65bafca70a29a4c3a0bffcc9cb80423b2b5520d1c9697f16d408ea3a07c18dbc256bf5eeebf4d718ae6208b976cbfc559493d8ac618ea6ae39826fa2a775312c9f0253c3e4078ca33d2ac81aca92213f84024d8d05cf083a0a14255b7d5761405473ba6329370532147f1aa6349a403577b3fd508ff1a91885cc4287244ab4227f66fee34b5d780f4784e9a1100fb238c817760f502ec532478c7aadac37aaf8ba6a2497f6097afb8627e2c8cf08e1851c990ce5639c6553b025ac91deaacca6ebe757e8b30a0ad45991e27ed9b09b2c826e9af7dbc2856064934f96594e1950207e4f154226d1d00b8c0668ff55b5d4fbb6993fe2b101c278e95a9a9a4c30c5344c064576f647cad67adbab888daf880d460e31c51439bc4d075d5a45defd24706cda29749f603804d8ab6d966d186a2aa90dbef92ff5e6732a24d851bd754980bc01d63b737b01aa1838ef87087750b092fd93f51753c90162e23852a6eabd749d0dcc3bcd0b5aea6aa0b5433cfec7f0aef947da4c780e037b08dd9e2d5fcb1d88427b102f239aa7c26225490be61ecac1866b6c8ba9973d1043a219a4f4c2e256c6831fd68f964eef4d4eb3c4df6e125156f0c0d4366c4603c0055b517f532a361f309d488c474598cb0eb270c1045bb2c69b48d12182c01a170c167e4c70d48962f06595a3d30c781a4377e0b0bc51d80e316bad60f6e673a2e09edcbbd43949790de35680bd1d20a7c48153ff4e82e84bb86b5f687f00815d17344eb1065d1917ac782b5376775ae27037d823d918fdcbedf9d6b8a8a0ce59f764c5b8585f9281c327b2265570e3a8b9d516451178b097c63cb5de71b6d520c3434345dc4d87b1ed35a136dc2afa70cede4e0d6c067d29dbdd6d2a862ec6418bc13cf37b6096d306be3da7f478ca0cf4e501d058576bcc849f1711eb19a5c77cfae140978ad9ab2c8f7ef995d4540da29477673dc5c24cff39b94f1ebdeaa34270b0181fcd93c940e46665238000f803e8f4dac1d609d8634e8ad54de914e9362d369cc0daa78339be5ef55490708b9f520609ec86dda14bedd87e083fe27122a5d39ccdb1fffbec06cc927760fae4bc4dbec42c11fd1f950a04d533d391a65529688d178ac1812b6348e35c04bdb8709029cb02e9d41df6ca2894cd68d9b1c91fa25606bd701b8db3063917be0c0fef86e98fb933a26cea28e31d6af961ecfaa2848b619a6b68e1574a7206c83b5be45ad54b07059362569671d8f71734392bb408d96bd3a4b3a97e41133e75243930dc079aeb13b12d58420d48cf7604d109d7b4297081438b39c2468e99aec08ae3886a74fb5c87eb004bfd24d41c94744bba0390ef53d5d3ad08dd825e744d1e2a033130d0c58670183f97a1ab0392d431649d00a64340960ffd4a363fcd2cbf02ca11de751bd0985fec880e16f50733efb70d4d38f849b6098059d69e72ed4e333e67e47e4d887e776eaa3adcf026db62fd668fd09ec9dfa4d4bbc2961606cb287183c14cea79d46566175ea5a0f0eb934ad9fad8a90686a3309519c0e5e1604b37b1012c82f625f864f02eea5701d2ce1f0beff52d9525fb48826a6a4eea2c2b7ea1296157c027aa675ad3e7937c5cdd5540e1b6d06792a2a028c292aaa73465fde3fed4f9163f8c0901be7ce83ac1f572f48a6afe1f2706e66dedc2dc163ad3c2885328f513c530c0179026eebdaaadb8af6427fa9c3201a329b41d832b2a10f35bec6a317e4d58f0bd141f415755aed6aa36ff076516718051ad0c18e0dd7cdf3f3a48905ce98027dae2df59f0a4e83144509634539e74572db7bc0d9fb2a93ac76c03c1b716162a6a188f76cde1bb5cf587937fafee30ef90df465464511bf99dcd6e16bf7e1a292fd28e78993b712e4cf3270503d95c42bfc4a5de14a71165254bc1505c7b41201ab505d832dc0463dcd10e80a2307727e1ef48e26fbc4d6ee8a11dd3d3fa5c6f981f65036cf25d7a1d8ba30392db7bdfe955e56e6b5021928bc8c8b35faa17300914cfb12c9b51659a88bf6acd9261dfcfd176fdd6a1284a7a8852dd6899ad0241e8fa805abd6d5ebdc85c5ab899454f5139e5db46492143fddab7f607dfa1fbef4c99dc864ee8e8478c679da47b85deb289cdd00fa8937aa4f649a593c8ab274df2bd2c97815689b7968f8529050e74664671ec9817dd90ea9411fa735b79066f1df0fbba30d4f7b12f16629bac18263c6c754f2073fe5b81f4dc357673cd912bbaf17be96e7309388b5aa0297e7db58f4dab169816bd0dcd0fb808157c59afaeb0a612765337c19906278f1731ed2753c3108443ab59d8693be3d1caea7ee8da56abeef7bf8f63ddde49ddc0a4338c570ea1fe426b32975ede7d5f2414a6d89ad399f905e433ae95225cbcf396b3b14c20b695e4a1347a57940b0442ab8b5ba005a0bbe503388b68831ba8241bfc754e631b350388af184597184dc0d4553e00241e67ac464c71ccfca63ebb215e6d06bc10db7a6b085f5c5d6ebe86b2d7d160115a6311d3fa10eb30647ece3b3b3a33417cd20935dbde915418822b1166eff4307d270212d660fc1da53558ecf1a3821ced34336bf568564030310d19b1ee6c9fb480827623f40001fc02497d9b93ff4b363d48cb051501ac022948b80a3868a1d972f179bcce0b320a6e18a2a42c9afa95efad5792f186ed5eeb0073117f4f80d2727ca9e27a5ada7d33b2f106ebcab8bc2bedf3fc9bc48d7a8417a3629ab4280438bfc7ba04517c3df014b9bf0f32680fcb32ed862e1a05801d150245baaf930bbe0faab37f5b86af320c50e69e568accee3745dcfc5be75ddccb84a08587a9bbd44e5e3f96d355c7aaddc1faf246c60e80d4673b1260ae8746f929d6e05edd4769c32f254c17b2e9e088dbbad3da0a2753fa3a5f3c7daaf9d90808b31c7cdc6a744960d0d78b02083629088d7b8c4263952dbf782210bedf60091fd65f9116d5a517049c6242421e369d04c7944abf48cde5c58634ea0e2c5ff29dbe39a0a673d9c7aa8f8053aa07961d9dda2fa353798d0b40da76adfb35c7f4af2fd3ea2378dcb3125438b14ada0e27dcdca8468c88002b9a36121fb1f11952dabd46433e673d733b89c104373fadf08544b41f00da4839686fa645ea3ceb8ad8a93f59e9539d3a87654dac4f387a7f1298a1abe2214e0200657cc7efd24a80ee64b2338c43520150b2e29e11fdb527dbe1275d08908476d1ae1b8e91cb1c7dc2b4d6982d97ee098230a0a23b70fd6d82b5d0a7b25112a4f008062d56ced0db751dadda14709954ac21182a991f29da4779fc8f5d726f0ca32e50d62641def90fd64fddb2398a831ccdabc37c58aff684e5751de47037e2247ae39e77576ef3d12d5ff5be7983b300103eaf9c8f30fe2f39ee522ee1fdbc3bc8f207241473c94f953f08efeda8e0b1232f264f913d59e5b2155db98b2c116b7aefd105888af29ea828817129030e7d435c156f82746798a91a35f0243c972b489abe6ae8fa04119e3a3984482e2d6a955782eab53a95ad125d6733c7a5e9265ed34ab181a8a946445ef9e32cdd6e2b8c1b93500fdb8b609165d220f8592fdd7f0280076da8d5abbdd98d33854c82b3d4e2cc382af3ed03abf13b78df9b01bc5f82a7568d8d9d530092b09abefbb9904bff646d1c5176c52271757c62bf631712419ad5a565978d3ab1be1b3c767ed77fcb641efd4c3d96befdf04995266bf0d68b030d29e81659bf7c76cdfaf96e087bafde5acefc94264fca1d3b63d4e1afc18d7c2a2f5e703bae786e0fd95f7b4ef12a273de34fdbd642194700518971c368915111632ffd9ef019160fe867f042cb845b30a0b029a8ce32727d9dfa12b4360917a186b9ce2f4b888271126d7a87ae134d42a532fc3cf4a55dabc11331575210aff9554513d604251aeefa67e7680558b3bbfd91ed5bbd988936fda77c25d3c2f087e956dc3799cc5e17326e90a308b781d2916963b96d5d0dca77e43de91942ae175ebb3bb4317d448ad23e1f2531f6edae570d45391126325f0013d3b41e680e72861273f2f90007d978fc29d84b9b0e135be329e418780653624d36d1664898bf0be417ebad5f520980c34fe232dfa052448c7cf9fc79967e5fb718f79796077300cc5073a8d0b61a09f3a6a5539eba41545ef38f841ebf4619362f3e8f941ff7daed2c6b68f9f6d57a72571c09f9f54fea240eec83d8d2017f884a07ce097040d157a62a57bc72be5a448f1b5b1dab296dc1029376a4a7b632f8bc1beeffbf0d6c7cb47b902df3aeb35566cdf79f4676c3bbac8a9083656c57c863f8db03c348ce1740dc53eb2bdd38dedb8a5bdb0b4739db872ce71a8976db260f0aff7bf9793aabb7154cfb5dcb09ac9eef4849a99b6bb5713acd3c04ada7a84e95f5f61dd0708873384a08f1d50824da8531a055b89800318a189379a0e041e99b78ae7cbb60196fc2186fb50cd8c217d7ea5726d2f3ff35bdf0568d0e52ec3fbf1e0c9c0ce7b24d14994155d0d176dac9cbb4896c960575ddc597e809045c7701f48b8fc07b514d3cb64b1b13b82661ed0493d7aa56bbc0529d08cd3ea51688329624d60846dcab723febaf43e00cc0c52b5d7b49625394747f57cc2f1feb2535d989763da3c6242bc572ab321a771bec0536162b4da15c8bdacbe67b4c84f3747a2ef793d90619198ee8bb465196a3eba3771ee57a2ee8fa1c73b7b8607dcfd1af7351a8ce50f255eaf2858717804cb99dc81fc4d298d18c69111dc154760e468327e2561a4921e73a9a5619cd2aaee4bd29266f7296ef0a7f03d0f18fe98886d78bee6054ecc090584b2dc143349ca6b990fc8515f436138f15195a9ca1a96cc0afe9c5f54e8a6a37c2549ba37486ad1bb29c0c8ff424743d5f983409ec74ee3e63ade66f060a599b9ae09168a7b121e07f859edbbcd7d86eb1a06aed23145e784ce9dad4b9092c6e005cda97c74230967e096ca9fef6a85a1ac2af56c5db38953c1ff2d184cf1fdb63e2578989058cd6cf18cffbd159456bd61dbfdcce1d3e4a36b2dcf209d746b2b4cd95f5d7e242482ec7f991d18a2f375801fea89c18804b190517b3b2b65963b1a1dd580072eacda14fe9f5a6c523c4a7703e37c23b3f3558757b3e02c8f14895a835de7154c08c778e50159f125615d319765efe15c0c69c3062fe7fa0f5fdd28f805f544fbc21ad4bffb5a6a87b29452aa7fd446b4624e9ad2c49900e86ab22515b49e87d9aa4ea148bdcf2807e033be0c5f74f0622631eddc21212a67c601ef30f18e2e841d93010fd2a09978c9094c1a9b07b55586337d4846fa2916d898ff773113871012069d3ce09615eaac2bb380973ef093d888ab0b84671008203ec8dfb57462c423c0559090be71a040d0abd2e92a7078eab0879ab1f9f40c4fe319907e908fbc00c4a3848a0a7fc289bd086b4a946ac2a4cbb57081afaee1deec0881c9761eee9886e5d264a111a131a8ff03717618433f06f105ebe8f8b86c2e1f044d72a731f64f565b3717fe5718ed1239fbca194e100a4151acc972861f78ef8076df6ce8eda77b334991dd33a0c5f0e60aa1fd42590a279d1066143502496dffcc0b9c2c27856136e09dad5cc05da00ee2f64fc2469f45ab9b091fae032389bcff8a5513ae00cad17a182932cdd195f0a363d4d5350fc7a1aafa6dce71a02612246d3eb219655f00328d24f631159889de802132495e199b26cea2fbd66314938148af68e5529aa86da3478ce9844d3d66952a235f4031284b80f956985b98b6a17b29a3f1b77d7e5173c3ccbd1d4c02acf0ba6df4e2e14662867fecec8fa00fd7093b45f58f813421be2dc6fec35130cd7619d52ba26e601ded78f34d2e17c0d9cb7e02de9534ee145f6199d53749e372680541eeb773af521f29a31173fe3df651932819b4568427067acf08c2da992ea842a4baf9709910753f48ff1181385cb5d04e8d68ee8145693a8ab1edc18546e54b8591b15eef24192e3b768659f8567fe107f3f387d59e0db90fd497240d3154bf4c5edc0a55c1ead62b82b282fc4b43cba4c3a8ca5308d33317301251054991d1e3819a813516742fd060cbda69b1ae1e724ce75e92d73ca4299f7dcf87195e242dd1ef5da49c073e8d197c059abd407ed1f609a794fe95d7bf133feb3e606214685eec132a044608b2099d87b7b4f7866fe602e7dffc6e8d30d82dc4c3c0ac1dccba7bdab1132555820e35284c7a0d3768de773a0df87f37ac688e1d0da193bcb6782a77f4e7b58bb268f549b137d58ada0909b62200ee0b829a24f48e1bafefe4a68f9902065a6ce182d89313eb1e79f517cdfd3cffe430d3a6710df2ff194bae5bcfa22a63233898ec550a90a4b974d757de74531931b8ee57ec8f8f5d812ecf09aa81e4538930185523d5ff0af8cd5ea726a0589720f42f2417af9b24b3c4e034b1055baa254e7fca50bde77b42148ca3803ddd342a4c2b4f92571419c6321cebdccd27b2d13292bd6b203f08068d0b63aaa6c5e8e9c4d54592eee5357d72927a6d6b6f8b04f9e695dca7d0979bdf90a7076d02cfc8c0a32b283b1f8ba771ae33f4ed8dfc3f3854110f46c0eb86a9ffde0ca726532f56fade2c30f86dca24758f58718e2194324abaeeef47fb36b15dd2d4f88f850dd938ceccce0582e3efeeb82ae44d62e8e48b5ad7240caa8af86af4db706abf22d6b21be19287e8a56443925dd5962a0b3d034a41e951bc21c3fd3a60b0ce7e0c01ba36eab47ad93e533939e80f3df652d383db4f0e2b4b7241942c101ba8bb17238c054e7200c5a51d8c000c97922a23d706b8a8cc0282a304e873ceef91e4be80aec2bfd081cbaf7b7cf1413cbc2a62f36af052b8e148f6bddfded60709281f469c9e4f783254c5a7a313fe6e5ff29c09aafe97cfb00ea3e06b43442a0164ee66418a9cffa2ff106617860bf9bb9529ef7b82f43a55bb4221d7b9768cecc972e2242d134198de1c3f42817742679b93794e747b94bc5451e5827c02c1383f3d50314047fe2d402d44b6553409a7acdc3517","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
