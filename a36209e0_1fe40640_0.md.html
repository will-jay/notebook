<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06599ea275bc88f0359fc8130be0952e97dd0c52f473185dd9b3865c4a11208abc8868d8df8a23548de6d788d030e15d2c21beafe27ca1a6bc848d350b14e2978551122472d32c372f0d1cd2762523518b282d5705429953367f0db906af8da5c778e870218a9ade8bcfaa11794da326b7e2ad9686750713b94a5b0262a77c46472cd4baa6e837f12385fab32273d678270cee6b202b6e04ab5b523e9687c264cb75cbfa9c603fd39581fbd9468f5b2dfc869c7c5ba28d9a7209d450eb2f9c2323f7ee185cd1ffb68fb6557cb6a7e79cd5bb3e108281906ee5c1114dc682f4fcace75d0c749b60002b3413f6c8b967475b5367a437fe9cedf797b284babf438417cf17dbad363f44a2fb4b7a47ddb4ac52086d53e6d33c762231d7e3f9a22095d594966906ed0272fb142784493c44f5c3447c9c4f3036d7ba9fb7de021216b72577cb5a4ae50f9ef5edbd1ff9d8e5eb0fc6f2f02a13e63534b7e3df92e955205eae2633954e4086087313c5698884322a56ca82ae5283a988cd5e8d96b29b61b473877d81d1a27ae949664f912fa4b5ab8a23a8b58dc2d338695cbd190a439fd51e0699364249de9f809dcead1474e601acd8e0b361e2c573c1770c0a806e2941d3a9c1d968db47ef2212f72be40d0bb9494ec4ae69dcce5aea0805e60b7e2291267f82d88daf1fa89052dbd01a0b012dabad395bebae106c84b60af4ff18388e633e52f5bb7186b10c77851f5e259fb51672bbf4d7be79d5c3953aad8220f53ce55fcfd93537065e8b0ca29f0256d2c536a53e40ca9649dfdf885439d6ec4c70acd1780557db6ea11107d3c55cdf3650203b322a3f0c86cd96b9baec6aac806bca4242f05b61fe9f7384d15da1ba10229f4a0c7b3bbb4d4a1293f2372c5d0af92a9449b343acf29bd867c9b01a9aa175999f7850b195aa75face66677b40cf83e3fbb44100d23d009a495b411bf22a39719fd4704366c6aac72ea11aae23137c9c1cd2fec5849c4c2819545602572aeaf3bc13e9e1c960eeb8623bbe510d66164f9bba5d2027eaa79f364f0bfccfa6f74ed8c4d183536ba1367f034f1a013981987e785c846f5d0c9f444e342e873cf501c6b3eab2aeee510fed03f9adf9dec72fdd47cf8c77247878c2ac66dd0cdf3abe7b5227cfbbc7cfcb21aeeb94aaba6bb45ac39fd54245a2528e5384382cfa8f39b644373e0281bdade37f958dd00c9c5e7248f210b151673f7275b6c79bc2be35d2cdf596a19472044db2e1ab0f2e37076c52b972090c88feefa529431972ebda459a123d9a106adfa5dffa6b7aec15c678d499b993fc061195736ed8805ad71979e5041edc1e29d3c6fffd8923408f966036414f608c77783546c790e3fc35fc1f91db3a1f3695570b7229ccb935728d3bba971e074442b2435e47017833a2bd0ddd5223df5968c195845271e1b58e5849f4233bc60b067f5386bee8f7ce73e14ff77be434c1779a8dfeb1ca3a2fe1896cb6ba8265a8abfac999d7fc1b355a1d08aa4b3265eff2b8acf51fa8e604c6c2cd5ac7223170f42df20111c23b470477ce434bb4f6e8d991df614303ee2976debc2fd30d6ba74b74ed3ce2a98d1281fb53ae00da79c78a3f672717c0cc9b06f070bf3c380a8e92a11d79ab1a8345a3d52c3b4e9af49f4bf7d3081c5239e82c096b409c302135b1ce63e7cce38f4e10be65ea15b7ed6464976418983280aafc4caf3820259b35f080f9f6b36e038a26f31dff92275691c1d23edb0dbe4de5c93c373ccddb570dce37200c8dbb39c66370c45fd881748ca83910d56695e02d22461734841e8f32fa69d43fb4fb29fe27f7969c1884e8e293f09034e2ec247cd741ef83871ef6992f6229dda80534f0f809fa7ede5356721dc3c6fc0de88a5ee8f8004f9bfd6f89cd96aceadce3d9024e127c61c5b7c57617cd08707e10fdf6e6a3a4d2c1b3d402544313c80ea49896de9616985bf936d5c1fef6b24ce31103b1e9ad1f2588ff7b0e2fac91ce168dcbb90037c894b2e3bf506b313f71075d1d3124a09851d3b22d13a7d9bb7652c0fefd139c9ba52f2e6a7c9e95d1618175fc92e50de85a06b07f95ebfcc5fa7d39ac13d6bf1cd7b3dfbb1e2db071fbe30924ffe6aac147a85b46972681671faed4ac1a7b82aae9ac5f634fbf4c7b7795f3807de3b3c1c4d5ddbbb2d8a2da579bb9626b56118a2e78ce40b96323eb4f1ab63839e41cb018ab4fde0a4bb25f1c09408a2fef294fe9659a37b93edb208a3b5fa21a5f09e9682011149cf0bf1de659ef1eb3f6cadd58c1458b834e4e81e481147bae979981bc39f0cd28ed6340498a61e730821482b8893122a09f70e0f011818117702523df6e5f5aad09b9f71619898ee3625356e1acfbbc136edf232c3bae315e6380f8e3ca66a35d039c466e176a012d3b162670d92cfb10cb3bf77d0e4e3fb9c23a90054d06e31a1f6d54d41f7317a210e015935d4e7e0808c380c3cf4513408b511a979550697744a5a84215f3ae0230832e26aee81e0473cadee46377ba7502a6b6d27e5133b002e9e03a788b9a5c80ea2c50921ca3e783a9d5c9e5f0dee6b71336f580e07e5a0e80258a6c50f14bffc6df889fc94e622ecce734e762a75f1384f08a757e0d5daa8bc1c14c173d14995abc71a6dcb52f8f1eaab92cddabc3568ba9d37cc53630f15e876ae6e5df23d2942288d7698f9220ccb33654dffca844c357885aa3fa43e223832456b770ea41330b8b66fdaa272cea65901be5c0043feda8ceeb9f18c3d26e2070f58a5574170748e63834b2d3917e64f1d28c615b91b98cf28a520dcc74c34e369361df60ef62679295ac2bd2644da058e9b1eecab673b5c849b920469951cb3cf9d7c1d01e7470839f1794277bd970f2abeabc89e8031d19ba1abb9f5927b1b9399d68499a6c6f761b1ca33fb5fce81666d098de5ce0236f3e71510993ca3c4469ff7d78acd1ef5757d6e34bc3e52504c63d08ce127b9dce33cbabf10c389d390171139876cc58d59c262d2bfc7d251554ca62052f9c33124dbd5b9c970df35b64d1a153cf761b055ec6ea0582f92e6cbd9872d6b067cea6c73fd9f552da9e25a4f39b1efc0fc10d0464d50206847f27e08c68002eaba0c5f5a48fcf19b9d8f599580eb5e4188c62140df703e3a2625dad14f0872c838f997ee223ee360f66755b3b60010c1299e70dc14f9736027c5e52f9cff7aee19da917381bba306dba40c3e2e2c6ac5c612232e7b743729f13dc543fad8b2416392f20e7e6c8f714a9a1ce661e35a5b3f129620adcec3446d640d4716f42d1ee818cedc876c57af8c5fb3691eb6be89e5cb2d09d2994467814a0ed73c86f231874eb55e9be4942734bf06656c4feb1a6621e1fc8153387a3bed1c7a719211688bae34f342dacb775b93fdee0d5f92f4bea6e8b88f88a584d67d113823628136eaf7eb30d046177f88e2b4e64b1e1454163b0e9c0cde33809f2f8d281f7059ff2b6666273d960886d3ecd02840295330918da3fe1acf0ee0de100706a7f6eb24bec50f708e5274d77e0f6c3bf94628c02e58284c0cb24883567584228d330b040ed7ee86068a8bdd8d1c57c93780a5900ba4e7e05188bf075e0d625db5f6593170cdf30ecf48cffde7f30f858de3d858ef66353da21b0f6f22bdcb31ce4c6fbee9f870b395194200a42798c4a2ef84b58611fe0240b260e41d903054e589927ac1a1909d9d29ad6c6b6b734b14921cace4e783dffdcf3dfe7b4246d347de6de6b08fd6e876ffeebb970807317b6b5d4a56fc9344ffeea860692c1f6c584ee52453b31ed30c42f712de2205e5f161dc054ca884f9e5a90dfc45923acf907cc4b692d02bbb73ec298e86105da940980aed511955335aa91f8d14ef0c7d6e3a003dc7bf9410bfa35e13f0240c14a9b9c070547a54ee4ad2e78a867a90e236d9bcb1e8ba69d2def5810da454191c57207cbba2c6694e765d64866d6fae6acaa018a1eafc6bbec95d0840f7c22ce34f9590618a69843f86626c386c6dcade7e3d95302577b7b98466c72b46a0305241b176873fb6a46b9fd8fae0c94554772ed854debdb9d37c48908ff699bdf3974e8cdcd691d67938849a58c2ece573416dd105340233a607e7e28c319401f682eaa0d75cf12bfcd0ad28891d8d8660934ae012852bd6380270025c69a5fa844d87a85ea54a13b5529e30033ee58eb6572a6795e3a1c0ab81f42b4e5f7685d33be03dad5671c352aa26cf1db9ff03967589c3420e81aba0ae164e421f27409de82f7954509d441e15ab6b5f8f7d3303f95827a79164c9f566c13804458b4f4adad19149a91e0fba982cf5abdb02cd3b7d234358aa7bd4e66820115596b442bf272d10073b9025fd4f1b5c37071473b08ea0a23acedcdd18a1b8e052dd514b97d76b4080eb29659ce960251b212a1c7f2bae9a77ce3082cbf1c7a231f7ce3c9d536bfb5eee4e929af3d490d9b02587cf02a623de1e9e0492608d115ad5c5266163b6bd0527a5e3cb3e3ff87dbab3a83e53f5dd9e567a4dd0d97d4e879c7cec6cd2695a7e8d91730cccdc22f2203e477b87bb8dddd1dc5edfcd039502ceb48448b8c025a1e7602057a6093d4d9728aee0332214e7415d5becde00d3bb0daf996ff2fa07e143e81314a2cf8fb84b509b674cbeec9dcb9a6f879ffcd8b4254feab28d9ccff9925e790222c5ee52f00e424834f1444b6cd11bae634e8731e64a10a04140d60e4b71c99f74a149c2ec094872a4e55be94597e5e46288b308b847b44085630657764b7eabd99a6d3e9a73fa1294f5bd47acc19aa619107b50e1b51d7fc3a6580fa943221f0e716e65dfe9b3e5ec308e52c0a394666ac0280620ce982982aaab5092c79fd56432a56f60f7987324e87524d2fa54450c3ca465c296a2f0ba8314297879034cf3615fc6568f83337ff8a6bf6636e47b1026a6b41cad7c3700ca35fb4b429db84f13a2b961165eaf56e2066637d81324d136b274d78323eac5b28a165e28f3f13b350df77173099b6003076177426daa42ba87125c79b42a5bcc67131c04513364c0b6b315359e91ffb6cd4b96a2bf9cc87e95dec4c4abd402dc07696fd1c815e1c4d501b6367a16b32a9df50dc26b5b55125681bc191da1c0e36b3a35b323f9f112b1a92562cdcfd49d47b9f6baf4d81500a70327577ea876519ad340ff85c10bb6ffdb4aeb7f874b8693fee258993e3daa11d9bd18af58b0f9a53727a97767aaa739ff7b014b03ba4415abc45e0abd675bdcc09c884a8f5cee7baa36d69fe35fc2f7b4a34faa90b5ce8b2da91dc163aadac0252ff2a7a62a4ed3f955833e71017b6077b76f0b178d3c346331a0fd699176578d4025717899188606f2e2cd467f49ba110d996227a9cd09cd50533223a8873b7078c0b353c7de75443f8665db3e76be10946fba963fb133c5c5dc477b6b9aa58f99034c367d105d65c3bb19ae6637109e1ad2535f1bead60824fbbc997e9991c1e2ff11c513cd7f0e20d782eb639efc0cfe00891695e3d713f2b065485567d8b2ea18321371851f08b321c3194e637b23c97b3e8a9436a769fad454d96248be43b78b13d19c96e9fcc21fa0939105f3b269374e0781efb4dcbf3eee309c8efab79580bda591a6c6a251ae5711437cd1524ae9b6acd2a698085795637446e487dff4734bb6f871d54bdf52bc635d2597b8570c2c49bdd361b821071aebd43628c4ec753c17347d81adf8fd3fd0622c9fcba99d1ea25e45a5915d85b858d7c43db641a129a701897d091488d78c040f5faab59376793739ebdb20bd872292378e424e7be07eccc71cd4e324b9301fb58dee0fad7c9df020129d42bbe390c04ba09e9219ce3b9c0a5b05702281aa0d43d457e22ed71effe3242d3119355c04ef2089a9f2a7da15abc4883c104e96fc8186cf428114db7732108c19a9dc4ac6a95f9f00e71dde4c41c00737f9d735bdba19d57292db90650ef97f1c53aad5c7abfc5d9103196105f8ddb08140f131c3e61dd4e9f0d77056a0304d3108e07ed70bd5b93a6f64a1808148c3eeab8ad436333e9c3b6f62c18f8dc935fd1cc942e7fe12c67caeb544147648a6402cb8dbbc2847b475fceef228bc62246c23ed808ff1e2c6b5cb0e9785cf6930081c62d3a6c004cc0b11761d744430fb2ba0d6d48a1182afea91051f0486f1fd35663e15250054dd2dd19c35c2bd05f547ed0e5fd2270806deca308cb07b38d1842e11702cafee7ae78772764676cce20a11716e9af87cc10d37d2c448ccba1ec44d3b45780c09efa5a0ac17a4b72e0bfc287f61e92efaf282ec35fd4b7be09fb5bded1ff331d62f3439791f0724d04530a2f44e64d49306b03f1c88c449ed7cb28e411fda8f77b757e141e9e6abdd059d2e709e61c4969f51e0f9fafed97228103d4dce74a115526ca3c05b32ced61d6d2e34165c6d6058ddedbc3595ec8dc99ec0935c863fe379f646f59145127da2531b5cab844d2f5e8cbe7daaecdc644dfd144e737f6fa3d5d1b40865fb829a34a7f2ed9a42bfb859080a82966f1644bf1115674edf07090cb72d5d952312ba445ec1b216cfdcc75fc96e45a9b6b818727138bb05a27306f6a8d1bb6dbf7cd2c812f3a6ab4bbcb58bb0502934995ea3dd1f285a1b22fd313b375ead1905ad88e2989d8484ef08edf9490f74fdeb8db92de9c771525c58f20ba9dc6cd79cbd2796cf15b42d72a44cdbf1dd4cffb362b9e4ffd5f296af817d0bfa29ad4213d2482cdb9f5ddb6eee9d819292b0858d7be5ec663941a98353afa66b079f36d6161bb87e84d037b827e79bd0f88dc809e7e821f044942723b2a96f8825fe81328c0f929fc85652bd2cd43765ac1c229463f8fa6daf1297018addf98699f8be7e9df628c22914e7a0558a483668712727b02a2d0ff08f9334d9d5d5e016767b10c49b7b3add08948270c22bb94f2a1c13e99a351b3a0d99209ce883df2a154402140845046afa53880d054ba5c6e38bd2c8e968dfb150c76a3037906f4b46c28cb906cc72a20de2c6a0de8172d9cebcea1db6a4ccf2fdbf7345f79ded302202635cb5695fc5230a5077c5346ab7f8a33c20b2def552d7a335976ef3b46a237f5b2d58e9ffda364e5feb37f5314f35443ac4cfc0dc4f6f58a96fa8d541557f1834f85365644b853cc3027711a38c0b3fa4e75b63b4c44810a094b4875a2a1f04105f8619ebe05cfe3b9511a01282f4e310c5bfb847940ae43ac44143dbed9953904384e20c52eec13bdeb806562719f59ac7649ee42f7ee08d8003e88fa1c18e5445d9c0914255bdf28dddc70ca424ffe420455397b781680dc1be81f5e2952e30579357ff97bc38f6360cb846de89c30479376428520c36aa6c9afb83e66a86bcbbfdf4a58e58114eab1dc0e28e31fb282be2327ad1a342f24dae462d98f78b83c8ea48281f1fb86a26a08f677cec090ffd3f669b1bedc710a38ad67d400636f5eaaf062fbf40d6365a9c91522996b0718650a92983a44bec05528cea6bea61bc31f549b9401818df00b6e945a24bf7b9096239a223b6281b8cea0ef9a894335c4ee8ba497764dd103e46f530769c88d62b2948784788c8ea8226e21765ea041fded76b1025f28305c45e057d6d1045d3b82698eb32267f0e9a8126dfdc3d004ac7834be1b602d88d355970203de834f4ca69d8302db3849bedb8004533c70d1b1e53c0aaa187d2539beb0190f085fb227526cd364257655be5caecf3d7922a7ed85bbf5e3b2e1d36de53f45ec43d973c3532a91dce8dba19ac7c6b7789c4ad759742452274406bcaa6c6facc551f9f3a0448431033b1570f4a4cdf88928ab48f7aad0b4b333d732172540c7b30fd5127be042d48f7e51776f6d604660b09bbc01b4e48e949eec2a69655dca17f92243488187e412e1ba062b1d5e15f10a5048951bd316e741f2ac30d6ffe90d7dfc385c2c1ca75ee046fb2c2f73a998ebe797b8998de65c2b624c882931e8186b1ff003fdb3e4bdc8a00f378ae1b0968d1ab2746ae4badebda32e2bd1b9ffb7032c958c1123f21c19da873f2d7e14ff852f73a85a67b741b4c1fad822337ae890cd71ed26d815afc11935f0e972398161d11599d173efb064f539dbcecd205dc1321ca98948fecbb6d22e876dc89fc88e82895b6c0eda8cbea2a955906639077cae847607fe2f091575268a5a82fc7163176ff6a2dac8d417902a3e249485981bc6c8c75230ba02c88dbe135fd61c2546e09ceff1fa12bca273565e26a682693768d1df3276a1c4ab01866fcd117b6033a8c8c57c20e7a15bc48c6d0dcb1007168b83fd594fcf0e4b0dad79675f09c37c15e7eebf80256f48e7506ac77407a8b1cccaf668f4d70909746a9f7e05dccae7f4e426c579bd8277fa38363bf959e90d9dc424380917ca56bee8917a3a2b7aedcf36a4e8f66e037662ca9d83548391c54bdfc0d73d6e1743a8cd7441a2b9abe3563bcd7b3dda0abcf27823032df40845be4ab8e1f9c742d7b4bb61b4f8fa0554aa1bd68f457c76b7169b0246c98d4759390bc9eb53f7e3b86a0ba590a99592c6e1d12e47b2347a89845220a71ffb0ca2d3d3be6344fbb7c21dca7837ad820543e588f47fd8f5a9d1bdc92dcd7f6f5593a203cb2439e26eae534489163d50f9038adf086371decd97ffc6030ff1d056b60ec56ecfbcbf4149cf837ab6df4180925bcbf80aa639d88cfcb00eae2098308a09eeb3f0667b23f8d5094d75ea050b3ac8dccfc39dc92e4d73501ff4770c542f740bf35ba7bc21a6e7520122fd7486ecc087d4107dbc4ffd32116111f43c5aa028cf35e2db08cd46001386de7b9447761c7c2c41bb391a727dd55c30b70196a9a28a4b0d9e857bf24a0872cef9733e641f6b66ac8bd56f77080724ce05b6fe8d1a43623b555703c2cf52ec95ff8f934165ff6bc9fbaa80043d5e8ba12609b6a8d29f34e9e7713317cd5124d4f4d6ac0450873a84ede5272e69b7085fb606ad870d2103285d3147ffa724280437cd2b1516d8adb066b48d0a4ff3bae804b3bf27c1dd16e20241d6e4f8f2274c98f77e665c23a321789e24ad724b76de7c7b0a2b99f121d22007e6e7c9edef2cc7c4aacd50f9cf7ec53d463e872c7a03661b9559a2134996827ba73f68971eb5c79ae5aa391a545da44884b46f68368fbeb865b3b9b014d0f519ea38e06cde8959ef1f0ab96ee26a1466b2e066eac8de9cf61afd356568b83ebd5970c87b5b70085faa6bd616d1390ffb05e5318871c2546fed07199be956c1d8c00f2ae58296e67da05b82d643ff93a3925030ff1bef6d5459561f9974e7a55255587e6fe676c7f3cbddc7fb3e388b2278d12fe125ae4727793418e15fecd28166a73ee86797102521f6bfac7df0dafea5d44b4627c65dce1667852377e4c7e620c5183cf5331e63fcd6da42ddbdfd3d3a3b83b045d952f8a7336d1ac3ea87632b30319e8663b4bef4baecc93a711ff02844936ab2b9956ba2d02d33fc66bef368eab1f836f15a1fa8414e1960cd3a5f67c6d948c8bb123923a31e9d93b5193dd99c85a9e684dcf2bf3d62091c75fda26d848df252f6c125a21738768392a700b11322301ea3530413789dbb9f792312171c45e1b250888a800662a0b350fa25139eab96ff0f350661ec19520980b9cfec6c0d0b009fc9e2f8f1eaf590d53180dabe75d07e952429b919a5a57789cc16cab1f9822ac7747abb48f1dd9b4bc896ffde0293a4f9910c011c96f0b50c1987845f20581385a9ab4bdf730f80b6005e36918219b390795209e94a1a48cfc6dbf11dde2921219302332d1d067f9bdd972c6721ccb1aca5e7dfe978b30136fcdba182a7f80a32c305f987819d441665836ec5e88f4cf4b71944c04aa501a584a35d13392e25b1fd46740461eaa10c161bc2f62c7bf2e9770df8ae7b15b2682409935dbed62cddb1950fd43c974bb5136bc219a9d1c1aeefec8d2bc51c2d8de0ed1c7679487e4d50bce3d48c07d0b7d48705fe870c996c32ccebecf926d9f71405fbae87ce3c30b82b7de1f2d4dee83c5a8ebe7e6504e783d6b592f69dfe638e9ffa28f218ee9f099caf7fbd8424f8cdf2d85e507846bdd210277a81b40f4d21020310db8626a2b914da535e761df30e18534a1d5af097361f753121aa65ace5c9b0e24482a58d658f46219653398d6c78a178d52691527b72c1ab6216499373a40b8aadbdd3af3ebca2af57d9cac9edbca738db3bf9ec461103ef8f0f8f799e7125b7b17abc300b137691ec5ce6163614844e7d44230b7f3c6600f906d9eaaebef542373ba0fae6217564776fd543ba41d3a054edab253cc57ba4e6587808a6bd61047abaec535c53104fbd0690e2b4f5988431cc46a21586b729bec91a97d40b2365e14c8d662e04e6fd34e7bf2406e5cd96d5e8a7b9db2c608997d8ba1768e937671c28da920605051b78553587fed821101409c82fca17763f52d9ad4015cf472919ba3e6df635be9d44cfa8cfd0b09fb39bcae9e833fc6cdb9c704b930b4e8f1ed9d854b6a635b88a0b25c9353e7421c51afdd2e49ac455c3c29d8022f8e4048762e63528379a6b1b42e76b79741932391e512be6bd314633dee64c7a8d1996aa72c7dd0f9b99e87a13e8db1b06d1263c70845ce0266b2259be8e2f9e77c1292a3961f9232ff4952ba4db9f1b66574a021472ff8e7b51cddb486071d4e814b68414d2bb0aaa26aac863c8afdbfba46f041f0258957274aa87087bfb6312289023e042c7f9cfd0632305b2a31bc62f1151f1b5c272081c8a6c52abf3a2919ab18ad8bd282615d5fac38b40cdd6e08f2549effacef06e52a582aaec35da20d13bff407e4612fd07cf14d400e42b47a79ad46f4bdda033a2dd08a0676f0c0fa7bad366830d43831d4ef4105d58a51a37b7bc2c506b6302c2d18c721e22574d9596f876ebe361123c5b42a7ddc8271dcf40cf33f34018b3dff39463c52b7ebd89201f8d186136b48987e0739203b81d0a0dc0aa1aed8902c34736b1b48bb85c4269f1975406de2a0d8f2a5eb4cd9dcfcc9badf091f22fd1577d3f9dd37c3da0a7612de05dbd08cc1fc31f4674747acb846ee28e7e6634895736b97e6a55a2d6d1109c8d6e98399b92d71391ecc4f426280c1b0c333a30c2f713a1f00901bdfb94193763ba6d43d4696cf756052bcbcb989798d33e4bd367c5cace86de2f943a973382d1d0e961a3b72e0483af45f38387bb21d009ff71a82d3ef8546f15e6f3cb06a5f72e911f21a43778edf3f14172890cc4c544a073496b79fc4f1de95f3b34e3937766cabcab91c73e4c78380579083af7f005579b348dcd89cccf1786f05621de9ba91372cbb1c52669298f5b010ca1a46500c3ec76d5400e7d3729e9ea3a410d49239d9f71337f5ab8de73efda9d1094cef86561129324fb108b811c98f8be3525fee96c9bbfedf86afc4db5553372f911fbd20b1d7e1cfe674fcee67432d53e2e4749c7dc962234a1f4fd83118ddc2de6a5329811dcaa9e97e7e397b4324b42a1c1d7211b216c3c171460f1976cb90c499acfde7bca55a876c7d02a0458ee2698b73c52df0f81ea515ca61004138ecd64d0fc6a1608ac45978bde46b92ac03eb4c641fbe9c9913bb9345c52a07e28b29b66ff1424bb89b147339d62314d7cf9a1144c698f7602b60c81ce69272edf580aedec00072c4f56802c9cd2d9af78c42e67300d1a1c10fce7e32c7d3cec23ebb4c90130a3221ba7ed6e1847a1b13cac0bf461ccac6658c9164b7f79b6ae2903564d749e279ab33f58e070e0bd7475d236ef26bc5f10e3e3a65d1f6bd01b014e9e360b18cbb1a3a89863f28df582e971bc9608069a3fe7646dd7b882da34327f1ba6034cddcb5618cd1b8fde6e453fd187fc22bb09ae70585ee486a10a86fa53b7576db4c29809e800b9986f6cf78c8cbe85bb17547444c7026d486d1397f5b009e77f17ff7df9eb9f79b420f640db06a4b27baaf6a17b1502c738a51030fe7e2bf5af5f5a4b800e36957ed3f946b1f0dc88ad47c9bfcc81a092cec99fd95468dc6dd2f103fc6ee312f3b4f6324e1fdb3694092c947d50f0c7594c9ab1ea652b2ccb35bf38e4e88749223907a1fe79b4f35ebb4ea0a3e4ba90b3cb60e2a0654fd9a740ecca931fe1201c45e29179530aa8ead57b458a40bff67bba43c8eec15a116786a3184741c1156530a254e1be3776a33cae9782c863fe6ee2f8e19422698e18c740d09b9082735ea2b5138ebe44ef5398c7bed7570c073ea25372d63305349d88a0f655fe2a02b1b0c8ec6e9edb556c593ea64afa8f45d6f3c24cb1829eb68772f5fc0e52059f21221c610f21e96b1dec4027d8fb72b62e97e5e397d0a1011b86de1960703f15df3d82404700768a41198f786d9b7e9589f6a517a40dcbdab8094c4e6911a9c7999295ece18478f7f97a888066d4b4fce7c26c08e4fe5dff8839ed5691a812798d6ba15c97a8e12e31d18d61251eb7746dc01d7fa6ace0f2fc62a2e253ffa49f25ad692102ce7ce2236db202f01961e4541ae19c8b57fab494a7a1d19fe679e7c49535ed2b339e164addb393e41ae518197c713563c9774ad1e46d6d96a943d03279437367a86981f1cc544df1a66791f1a98991db6f7ee5c0cc74cd8527d6dc0c2a517fa8957fe2a0cd7395df3e0ade39aea7ba3606073c1b4a6f6bb1afec9b15fdf0146eedd18a7b68b7360a9c4022ed3f3e88e4162f097e25f5825781064cfca9ec5210bc8d5bbac4966fa98e8e7b1019627390628b22a66f467911284f577fd36d7fcbe6b951423f2592efe3a7a35e3c645cfcb42513e2fbdabfd75731c366fb525e76b75c6f5ca9644d180c72198c8118828ca772dbf68c45a51ebcf8b342e2a635aa8f17e0e9e7c83ad626eee815adfa6bfe0a04bc573c7dec995a9955286b16f1573b09a1ea2045ab06ec124961c771f478eb859ec5c3ae848d3ac56660a85b1f17d4a9ed65c35990e565deb656822fa1c58aa97ce050bd51c30336373dc851635268e5f97a455e693905c3719bcda16a80464c93c2160ed2d6b9294f7e9cf762a8d7bd62fdeb2a76b6b6e5883898597425f9574e92251480669cb2fba82b6b39a1d5683337e15f9fa9154d50f9b1dac0eb4923ded3fce5461c26ef27b5bdae2c7b4b74c2ae7a2c2261d1f97ad7807b09a8dc43fa692ecf2b641ddb9d37a18a89f295c15fa65613057c2b011beaa28b415bbc93e08b29e85ab1a6f8ad55743b44ebd22275cdbf914745a334e638805359a2d0a9c3c27452c830ecf44c5b65c865aef0cc2153868687de8b6e2b1e8e3844ed9356519a6d3046de61979e18c81bde1165c7627fc5b7c73431d341f504e2380c548f7ff8027d8ed4e18b4c4700c635fc79b058a8649781d032b75003e627bee06a4c24d1ebfbcf11cdb70d6331c366764a54dbfa9393ebcad4850de6ac48a1a99ced253809b89c5372141af99ce4c362c2ee2a3063bdbaaf72702784b968d39f63bc820e4cf48ef37f984c6d1d7c0a31a19e9175f60ce1e2419500f58908e97463e8b4210fa4ea4b7da9355c4bb3c99d56a6bb104178b60876ec7907d753d79f603865f286d7c844926144513179ea771a61ec99c44aa0f8c6ebd3a93c5310f896d0f6009d19ee8103aa51bc287598680f69525e0c1d3f6322182bcee54a39102008197acd20bc9936e3f96f33e9c98550165bf2c773baa40e2e310adb38fe7c3abe0972cc35683f8c5403608156448b1bc277b720a88d1208b0357fd99970884faad6b6f8e5738a61532ad0b210ceba81dd5087497400bf1af0fc9489db40c97ff8aed2561ac56557ec50a68a27d2d4b509d9b283f6ee0ae93eb54bb341c83abe05349cd9d63d2bd830ad20a9748ffbb725b51b06bcbebe8e59163105ce6c0e49d16838b9f8bae346e30621e84018e58b66a2f6f87c680db5e39cdac652b20c794cae42bf80e0ee85204f098bc69c064346ee6bcc4c90b526e774df31d040dd83ba4e2881e4dd9710dbef2864f2505e4dceacbdad8bd4151c935abbb8c84080389d9dbac046c5a592a2dbd6572ed78b61a57ba30b0c9a2d912724605c1e25f9d85dd3b942251d306b42e6d3a4ac00f97e507f781d0b345c542f96588f74cfef552851cf9c31230f0c81841698a7e1bed456cceffb4729a49c32740128f5ee88047028652ecf295d667450ef52cc983055fa5fe46bede2f12c40b40b2e3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
