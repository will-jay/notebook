<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7413112b9f9bc0af17349ae30820d3ca35742ba67e0b65104916a854f10018e2febaaa26e6019a7e3ee632cb4ecec36766e9b717ba00ce2a67ddc33544bc74131557f0e1776a4fee5ed9ab219621552ba1cd0c845262b690e5adefd105d314a7b0fb2e08cee5eea63aee0e231815dce49ffce274f047ac5dedd4d742cae7a30e9922d5dee3277a26aa3f0e137a12b000a2eac938397264631e79a72d87454afff0f5b317d60012f8d7ff39d9be138bb01a076d584139c59507d8d2b5405ffc115105196f40fd62dc52ac6dd515dd2da08fac97394636f0d71ef12835f30d00273d83d7b31dced0a4dc10e11e81e27af9d510cf1f7c37549cc0324e67dfb9500c837db77defc43701e5d9de7568c4ac0e8da1f850675edafca62fbdeb95b643a2f77ecf63a3b2c1b4690ad2e3bb111145505fa5070a09f957fd519466ba199a04b6d57ab7a9d88a7dcc94d054b614c48a732a64025bd5e3881fcc05c09008c37f8ec40fb496d4be52bbc04b2bece6d892af4ae4f0d80ec55bb807a9e79b88977c200fd939e0bb819bccbefcb6a2bdfe1bf975c76c5e4bfe0e628deef9e97829671914ecde802dc6c421e75b6469a8d9fe911ef5a33900077fa1db1395cccb22dd0ffc5da95d37bf65be5e15b162c8e38ed8538661c9b375e6aa48146e0156d8b0d11e4591c5f834229436143ce66a07e69742081693a995c02ba3448326d2c1076af77587493d63751f722216533bc5edd9fd93a13381eb683ef3003b00fa32f7ffae361df88006e1f080ae173134f89e2686126eb1ce65c12444e9866ae155e3d3a405e7f82facb1d655e87ff9dd2472ebaa48f2348895c2d79b7bdef4cc9b228c8981ccf3b85b8a7ff7267de344dc371630076f7d52d813b518b5cc4bfaa1d434d4819eeaeef9629b6ece805068c853aff5f8ee172ec82b8a469d2cd34a80effb3d0a23b6b98c81dcf36f88c8d21c53de60d2e92fd6fa1c34fb683c5cb46de63c57c2e9287c03d3cc0bc058424e8f8bb5a6b745da14539d058ee0b293d4a2ae8793c97cb9c4e2ec6c0d05a98af28fccf37ac74db991ddf10e2601d69e0f7d37e9ee47bdf679206cca2bd040c6d9bd0c9440c09ebf805ca40155431439f13e617da14edda391a554921b574589f5eedfbd3341722098980983545c2bcf0c53d55884ab0c27b829475b98f1008611311f6a40f37ad3d41b43f792282b244897b84bd9ee9b6cec5b75097b845319a4deb304c6ac741913238d94b5fd71ccb16c4806faa3e4f971d607c6f4b4ad147fc5be2b9f3b2d76643cf78b6920a29b06f608169ef8d573d70caf7f0290a4b177a1ec51b78f25a2531392ef3b06c429d49381623fb7d27643ad35df4e48c45dc376093f0fd1755d54339407e85bde4c17966096e52ea86c30652e447377cf70440e3fdcb408c9fa4b6bbd906a224928a5268c9a6c30d59251f9a1217e42a796b2ae4465fdddad2fc14f4a82febf3041644764866f61adf28483bc9da578a68db6cc7ba3096c2dfa459f718f2b98c8b7c258caf78952267259d3d70ab6bbd7fa5edecb92ed30d7096e0635ac4a6e82325556a78a0f50bdaabbe4464b6cc9b856e3825b411626b480d0b86285b6f5ff73b39e3b719099c5bd77cb65d89669ef40465aa5576ba8102ce6d19e2b1dfe612c9e519339781e1f66db488e275f54056a073147a57bf4527ec0b24af6c04cff4adadce690247278ba23b8c7403e9f7dbb37fd41802d3eca4d76b96330c7e0db1ea76660fb1669765e4926d2c032815e3be892b63834980adaba51fcd8cf977caba63f188c3e3f0763e192be01f92f73d1498fa85c61dad2fd67376a6a9558e0b366b21114b62be9fc40335df81462b2a4eb8d1eb669f86acdeaceba63202d2c2f42563cc9bd88fd9e31cac13ed9329f718ec02c9f362fcb682ed81e4b88ee4887bf59a2fc239eb50debc6a1d5fba889d110431e2ead352ed6bf5aadb31ff5f1f6867ee37dd8a7abb569de299c9f5740e70183833767a572d0d33ebaaf798c3af03ab65fd0c8628b5dfdb7ee4f694610532234480331835712d87a296c207948a1d338faa63fe84609dff5762abafbc9f575ebcc8a3163dcf00c4a2eef946037ee24247463bd5c39c4149f0e9baecdd3f1144a60f155392cc2efc3f2725542db4093fd5a96e4a06cf08a98a83074cd08339c5ec31310cc17c671757452e1243f1913177fa4fcfa8748e82fe4537c9b6aeb3c5d6737958ba8e59afeaab9dc00eca8d1ef98601a273143fe2b4b814de9fedf568fb34db38b6be87b3aa376eac7242818892638287124ea44df51c6913f0ed0ea2196cc66a74050246c15f187e925bbe8490fd6810243ec00c7cacad25537d59522b7549de06796e68d77eae4e6408cb8f61aa83fb929a3517cccd38b0ed2ee0129821a9051e23b217d1d18bdb5eb9931b1d57b2f86eacd090b59c13fe144ab031ac6cf9c968c49da28f0254465f704080b00fc37061cd028433368529fba4864456b0c6998569bfc13a84eac66708697f142a4eece6914fbbec77ff5aa65b926a9369d35bad21c1c79b01a7a11a84819205453d57968c1da6791ac8aee48f8b5982c66918880c6a7f9989676f9925e35bd4c108f46175891bbbb63c655ed87625e3cdff4f45530be40916f1dfbc2077874168bde6bb0cef3d5a9d3712532eedba5953dd1eaaa8c4040169d21f74a342e0d4fd120d6d841955bf5d73c08ed7a561c6a7eb73805e47f4a0ec3e1256ee2372cd490b00baf732967fa16df937c16d459d6057515407ce019606b6158f56560de2f12ef0c89069273b50eaca39fddd07d7f7b9b4e9557df2b70ba8e86359005c0044540a0cb034779fc21d0f32dbadcbd6eb1ec35acabd8f4be6ee2dd38fa7bf84f193e5752d2c645f2310b194b2f9776671486bf0754232f59385afe96ee010bfaba757914a13493da602823c3c73623a9fa18e9107ab3df3ca22463141f4eb2e1c7dd23fdb70ab23b1ac2215e0173fc1e54f624a7983119dfd9a09b80b14b5b71d788a3f4f02897907869065358cf55f22788b32ab4d55997fd96e514f83a733d7893d245b9c23162ffd71acaee17d2a36b4260ad5223446718899b3419ac59751f6886dbfbea7189b42d6dceb9565fced6f8caa69f075789bbdc18c96bf43a07f90abacc02bdad64f4685887a8d8600722fa0f56916594dd629257d5b149967c3cdbfc170b771408622cd7120f23fd01995e099de1c31c80bf6860648e8be4495864993e633dcebcaf9b59a53a84a8ff7a1b5174e99fcaa2d97409148aba441e0c0589d33315ba4be6729e17b980ae9e1ca3457330f18a1806982890f546b3530b6f7c55b3c9f33e3410bc5b5f4d9cccd485830de384aab3e17627a532c6aab34c2883043a767f4188f88804fa7119304c514402402883617e4916404749b0ac1b7997508af83e9084c191b851db53087bed8e1660bc62476ac0d6fed0d20e2f277e919530f2ffccfdcdbdc3dce28789d4d17d1b3a47f4cace3ea25a2385850c4c1572ef109f193f0ca274b2b9ac2a1633fb858a0b3fbd64ab40084a5fe2c50cbdfaa4cbb7a76ee4944898dce74940f48bbceefc5e027b9b6a643478474ef001ac58f5a6b66c31a7b48969689d8fbddd8b08a13852e0a22f1bb7601c1ca6a8431b5e52f88bd100883d506cd252c37ffbaf647c981bfc666e51b3e7411f2c0ab28b020ffe38afccfe8fc2da9d988c9fd49dd976a528ad770c5061cd5bdc30feca65e52270d97e1b7b8b9b83d4d3ccf74e92bd3f884d095962f398521c0747a28ae4c840e78da0cd35ebc90143d7823b1ead6a10c865cb88f838eb9065ff5be21a12506afd9cc4895fcc2851a160729b8f9574bab80bc78e39212e2a56e72bd397bf6c28849aa5e16bc315d64c203b6bf38dd535158debcbfe16f7cf56e2f98cba8d3eb66bfef4a709f9644ee39a280cad7deee491681298040a0530758dcf54f41c98034441aa1f9f43bdb755a2f15509cdb18517bc1ebd3df42e022f8a442598c25ce0fe7946e31a9a4a12ac0b4e077502288df46967a126bc834555d4d56828ef5304eff8d8f5825334d2251a247a39e3cf48b7900150e0814dc371a23fd79bb3a4cd89f310acca32dfdfe0b03e5e879cd6171ecd03a14478328c189ddbb3b4bb2fa0352611df641f63fd3850f956c995021ec83189b33bde5fd5a4bb7c3815c776abcac40882c1b9502402a95bddf983b1bf5ac64d1efc0fbe1da18f95f870e9a3a168d73edd0c2975bfcca8e3da00536ef5366ccf243ae12d48c3e3f06dbc83bf422c4f2e375402d18f27399feb025780b444947643c516a32e2d884c7fa428156b2bdbd5894cf08927c4604cb84db916c2d371bc58135770ecb594d8010937dd608cc66c26994157783c04cf8c05d1d9e656f4ee54c6030e7bf6e6551260c29d68da0aa8e4fde23b92b25b4880bd703ef7204b9630e36bdf4782b50bbfba512f3394674b589392ae35badef98b40e7ebd79b8de6d9923c9d5e281b9d24cb435b68bc9cd6c37c04a441667474159821b71e612616bacf86ebb0643393b6d655d09a5beac18079ccdf9dadb6a7b420516a2d888392f30f4a7ebf443b4570fdbc54ea83cfc709d2d3ebd04e0c014915661f8887daed6ab97587060b03b67635d348d6f2056afe3d1da1112e7be4350ce097f09dcf0c6bd48c5aada42c35be6e3f3ea71626bcaa7e35c91d5c216bdd36340e06745bb4ef9897cd66114448dd57f0de116b1e96f3afb22989498f91f0f4a129182f15bd0175ce9fe4f5d16a41b47780fe2a107494121fb11da296b6022e9989197e6ac73346d263c092e667fc3d0ed158427aa77e1696f2a306ecbe6bf7a9d89ffc20d1e072824971c42ab7136652309f31499daeedbee176651717709d27ee5debcc67f8cfd6b14cd9ad8b72d4dcfd165742b1c9d2be0847de5f1c8b786f7349201ae01a1640f20c40c7a946a3fcd7155b3bc84b22dc39541fe6deb4e6f7a639f7f0d17dc9563d86acc79ff09b52e18b0d27dbf944f4401597ef021e74c4c36714bea437454acc5e3c12d6a501cca88f137aa845e1ca322741a451fe06ad347bbee66b6a1617e8a98e4c4429e39cae3ae867d3f26c7f97508acca436e61224667ea53bfa9f8bf90fea08a3ac5e9bc610e079160ea0dc1b780d5bd8794c9b0d5ef1fe44d9ac7e7628590a200a856d78ef0d6ce672bce9fdb3cf0d5642bddc62d973bdffa18e6305ad8c0e50dfe2bc3d9aa54b276020606d1c6be2608d9e7cc47e09cce7c785b736932697d81f794a299e4ed4dbc51ca72641e2001703e63407a4dfe9c9e95b5e51a2d6322bc9bda19a8317935cad6a02000f3bfa67cfb5e87b5b44365f5bf23181820c5be7f93f40a6f86ba99307e72f625c8770f87aef26026c65d115f5891d7f57422403830d7f58b8f40c9a03fc0bc2d58bd5e6b65446b5fe0bc01ce7ddfb0967d6e448fedc7c79779782bc98ae1aab48f185b85a56eb608ac7b8e644606d896930e3bf69c662af3eb43276a7dc9a8f3c5cde033f690698c6f5bc8c1e5d0236813ca7b6ef79c47a5df43832198cc59d5b31a61c478c3a7b8bad5cd6ee27f67ee4e2a9b906b2695518c4e5e4e9a400f0f82e6cffc6dd5204e823ae3713084815a68e42463680fe42a1658cb45f9ce67a5919ffe56b3d9c2851d173bfde5547bf0ade32e2ce765c3eedd26d09c4eca7279d89191642c8c452c6623af3d49636fc7b7f33357c0ef7a3566fbfb503169e5c6bea7fe366f53b84e58ed56d8890680d06d274592743701c52424f3710c6b975977e01203fb93ca3c9436e3f61fa30d1156b3f175fd22130fc619e3562f5dd3952afa3048e824b5d105f5271f81d71b822d963405967306f08b65fb58093c02f358f1389577b925f2c28389b4aa43022a4728fa707f866590d516865da0960d1cf2c69e41dd75ed0d689252ae17871b2a9d3cd2d4806ed78d58a2578b8c16b63c37cc57f35c5dc857baa8ac78059d6f0a8d90562b05883cc0dce886fed2c1d6587d12b01805f6f4a81327ba47ee5974adfa5898155ffbba1af010d6f0f3698eec5858faa3da251a08c43df8004e60426f9aab8a82d0498f7965e19bc0a7986116c56db681a44f195375ce28cd56f8161b9078a5188c2fb884ef8ff29aa40236a07e8d5fb27eda11f2327bb718c061bfc1b048d0c85f4762116092460c9af899dcf805e93b755ef9afaa2289bf90d3a7cedf46a025f5c00aa0310e70ed41da08edf9c3f0ac81f42e6874f2da2fb2f4d2f6df36855ebde9cb6a68bf61d388f8b8c3c2abcf1789438d248fe34916190f47329697f05d8e56e4c2309f796f7e7872e35c4de300424e2e086106ff5737b36fa28c9ef19e9cf6810f19feb60ebe5bc831533178eedb3c9711e069a09b680f298ff47e21b1e4b8210a9d841b7f717c04d9930b47c586dfd4a97120ba70bee8149797f3f169036ce89364c030684d09886ed1d3df920c1ee7af18bd6a0d0e803318b0d232ebe86a723c272c330af7770504838f7f68049458d47cfae4c76ba7c1eb46f83feb6ff4eb97a162ffb172e74f237b42dac39bb78557d9eda875f89e65988ac998b7df7f8e4aa92887692b067bf32b3d5cd056b029c55a76e8770b4456f4da8da392b5db8cda3641d79599cf1770be0bb43ce43812662ad467c7f9e9f375b1a9646c39a29eb22014b4d783fac7cf612f3356259d0129fe19c0572ec34dd58d3e86573ddd948271a1c7718ae3a2d5ba9180701fef166befdf36ec5f4b206129d73840bb59b0fb38fff2a2ae61e4a1e6fe4fe89b500388c40ad40de4a9712aa5d461a63082eccf180198006024d56e5230bb7f8017cec50b92ca99c0290eefc0da163ed88e774195eb4a6069ff48d41988a585bcebd02a31bfa6232edde4c989448811bf3fe0cf16ae224dabea03dccfeb5bbd6b423e8866844755709a90a027ce56cbc3a6652cd7bbc1d453fc967b838960e518b7e2a5e41c1df69ecb7151c6b044b1636029b7428896321509b63774a2f580e9320464b3d342467e799ad6b4156cf7a2f11aa16f72c19708f1cedbc8577fc969d7155b0c218fb844cc7c5badd8e941ffc9db5be816e838b602390544e31bffd559b724f010b7f93972ab5c32ffde5e7eb4e3169129b70511142aaa1a6c77b4a24c624fecbc380ccb6e1eb4c65064a120f704c1f553dbbc2adc112239fe1327132b4b63b0f8ad23865e3987bfd2551ba1d1fbfa11600c9e63d3d9563b3aacf9deff4ea31b15e40f3db8fcfdc46b9d03044cd406c263a8b3e7b25133f82f255ecf3bb5aa3473048ca372736128bb9f3ecf9cad0057a158e274b25d620d804dde7ae64d09e18e44ac76e9b7d24cd64328f6df00e11b87842c158e8f93fe9a62e0f0c542099551a34d2c200c5d568b9fee4bd21070115749130c0373152f07c232cc1a630f56c49fa578f6c99688248058c86154ce89a1d955f6fce6deda449089976bd740a5f0b5da54fb6e0ea4ddd728e30fa70894d79826a593486cc69dd722a874ae62e733d1b517f3e32e47b80c05a0ae3ac9410e679624ed4c42650ba01bddddc508f404d90456698542e1e55b0b6ab50aeed9b55cae0c1ab80a00b7b33cf927a4ae86b9269f41839f8b0babba59fa4af4f4f7f8904458809b6493787f1bc25d1e7c1a4b9c17a7307f59698e796f77d286c4b450a9509f3514b9d874b6e80341176e508015d65ad8683bc0a3a0884cac903377e9d3531e2ce618da59f186945e89e3e204a4be762c9169015cb6237483fe6b52658af3c455699bb7e7f809a809fff859176e837e5b2c9117b54e9f74fa5dfc9d691700312a947bcd31d4c273dff611d1b062983a7e40ed7ac5c4289f3ce84de54b788bb3643e7d704b008fbbdbdfa4b4a4c2dcf3a7611500f5847b3ac9f294ea068fdc92453c961a78ff8dcddee2cfc31dfcd546ec838aff4f1797c62dfd25248c9979288d149f07b9f9f3b8abc76745fc4b6dd742a91cdd9dfceceee423860f93ebc734f1bca4683206aabf4f2327a109614055447e83242af04869c836861b0ab0930f3590ab008b625803b053cdabba12cb193159a6e97c8d24d7606f6aa2c477dbd18e3ac6ea6668b35f1cde3c056994790933b23fc1a426d4d481c2ab4ab94fafed6cc8c4105c8288bb5de04e9c665b83822b7c1fda303ca7fd3a28494d64f2d762b323495b9d39a831c5d60cf86f0b793b2fc7e1e376856a86641a8d16cc969568d41fd3ab056cf474f4784fbe20519a2252c657ddac5a6f58d36375ce98f8b60d6e8abba12da38adbfee165b13ee3b00b7a1feee42543f048e2916691e8ca4dfdce71d28bbb3a89f25cb9ce60aab4cc251cefd1ca9b1a7b3ce591952bf2ac9d7f1f382b1a1576642abb6e1a1b7ad51e303d89d4503af4d298ae866f33d6af37e7f3be032b9cf80c11faeef4464644bb47dd465a9f72c2f52125ade16f0da19002d3b41525a7abc02eda5f0fcd3f3b37c698ac3e1bf224329990a55a1c8f24df7a0ff593b05b35a707af94edecc8bd86d721e848f6f9d41b94148970b983455af39d889ebc8e73f59d157fd7161e43d925d44ca26ffdac7a8788fa9faf29790739c69f87574cc22adf0a92f44c5a8f98e017a165fe910dd6072489d88cb3e9571b0e60c41a804d9ab3786dea76696a8345f67246b6df951b4f3224b63a996fc7a65457589993ec24a506aa6c98492e20a2a32ee5abbe61da7da272dc662ced977783dcb297907c8977433c986d206d7fdd6f2ead34e21af3c003b2a3c3c7420b1a3943ae84999f3b68e315911387202f5c2771c027932e3370095c587bcce9d7e3f0f8b884e464ad0015cafd132e2a3f59e77f369b3e78f09ab5ca9a4de9ff23e6e81102140137bbd19330679f7200a608c316640b2daa8b14930792d3916bd7476011c76df82f0a4394248e515087fbc8a0a88e46322da545504cf48c5877df7276d609c01d30eca69924b07ba5856dc841d936b76762b75fb60beac080c78b77dcc0d92dfab02c5a335a1631df6576f721348da2240b54f29f017de362bb5fd8ee4e7e199cf93a6750039ac6fbfe008effec77edd3d65d0320329815e6a70c24671575ca3071c163f1cf3115392cea356fe80ed0fbfa20f99b33a732746b566b02e9ee0d4325fccbb8b303241afc5046239fab32c9fcdf17d617fc87dcd2dc7495d80aae8f364e3baced7d309dacb65879bde37b816b4f639fe69d26826be38319047f7f72ac5279447800e0f2007f2a4a95650ba564b06b3f8b741c249889fc75cb5f296f54ff98d533368fa0f85555c6b7f924442570b6f3312d4c97fab49d0ead6f7e740c0d15c42c44d5d3b3042d4f0dc2bcde99b3a98c2b35afee150ac6eb385a8153c6eeb07fefa00ccb5f230c52108c2eb915c80bd23dd1273da8f3ee379c09bc72ad0d5292ecde519a579fed4859657a3ac3db3e24cfedd535566554275066f28a2965dacfbde7655409fa6360ca7ad7092f7d47079200fbb8f9b2a3a00cadfb15a878d50e65e1bd5d529d24efa3e393483be95f84b406475672f17475f3d3f7e592ac63f833eb160f96e2931875c5f8a43a20b619a8a925b69465c3777712e517e012baa8ed2ae3cc7cea68a7cfbd2babf3523fe7af3622222fc2fd89876494b8707a4cc8dbe8ff2671fe53cd5f414f84bf8f31ba1a9d5a0c41b8002c502a5f1d3d8356c981d70935cd2853fe38dad13fa69c407e6520279a7306e26b9751b087f117d417e3fa63abe7d771b42ca90b91b9e392af883bea3361290fb255cd4c6e96197a43c7fd799fd8425ee3612cc2ef069090051b1306dcaa349c7d1a5e9ecd6e7508368a9a7d06ff5ad9fe84420e09382596d8efc1050c097322f2941f3f8a296369689dc03023a81d07369b5faf7e073f829fda605e603784789f7e7e894255c63963618315f51a491aedba1344ea41c8a41591ccb15c0713664aa1459220c6d4b795a69817a7ec88f7afa7796f21be79599a3d60a8a0274fd230dfb1157ef8712bf967265f3233fa05747db9a92bb8375f6831d2089262f3d6a0473b34a15e42cb88dca76e285f54891d4e135a159ad020ff7cc57d1d77c42e71e409bd9d0a0b0fc1649078fcdb671c8698529fdf0a703217e33bf3cc52c8be83579f130b4534fe90ce8d2fb21e1f9b04f06918ed892a909bbf6a0ff446bfbd588862591cd0148423e92e4acde1cff8ee529d7e5ce415059a7e05cc66c827deeaa3ad1f052c8a23b8a5cd491f5b6ae8ecc1fd370d6e7fa1448ea1f916582269d8cdf512396c08391714f81a865b47f7606b7bbc3671244599edeb49712e463cc4b4c33b7f4dfaf6ed7ecdb73868acabc59679667a64c5f139136ef178c27825f1b89bd958363e4857e97c4c1f0cbc5e23a0db4117455026f9e61502b2dd20ccba36101c1a5aa4141711c852138c7eaa752b6386b5b544e40a07e45b7bdcb1c230733ba69a4b193ede4c10ef608ef942995e7696842bf3f5cd5ba6774a09963f012b8ad44766f8e9c0ab0b13eabe6ba100b737039c0dd7eb9f3bace4e032a1fe2e260f86a9a4b9bd45d484c008d7a69d6c7af066b0cdb3c258562796a56e9f489be65f0ae03f9f85c1751765275d2855dc9b776d5d3f151e12854e4bc874c42ec8e5723aa28977cd0b5131c0fc1c49ba52fe3254dfa8b196af0c3daa509167ef70bb91af93b28a258f2d1a5cb99291bc1e3753a01f23b7ffdfa07f9e0a6ad05499d396ea2a9c3fe7ce239cf34e0d8d2397a4c88afc4ab81f6589dcc3e7479c70350d2fada954cdee5ad507049d52e8ada78ae2a2506cb9213c8eb5b0adeefd1fc174549dd5b1f8970713022f51c1bf36e661311c656c9bded8725a61d817c4047e295799ad135dc3572c29f17ec178aefb9fb6f67dd7b6305a90cb1baaff253c90508b35bd114eba7f6f11867c360f061d19d7eac1fcdac11039b928a8f1f47e93f2f2720c68a9bf77504b062d9e1c8f580796fcec17dd7ffe34ce2cab8198f45a6cfbbf3b662ab4964c279879c7b20b832b9fe58e38e1785b185de74a237844ee20de3474f026dff63a1bb9b7d4146b932d47331f2dfb59a8dbbbadf6fa5060d042fb8e5989eaca2666e4555aaa68b36287c3847fd4e4195a2bd95cd388b2cedee973fec77dde5ed1a2befdaf40d88806ac782e5cd1b6954f6d02e09e9cc8d010a2c88edda00a2e736828549f4607fbe79564496c940117b75aad553f6f10014534f4831397b4ca4077524ecc9599f58e99245fa1b1cde3ab77ec32a1787ea37fad88e8e30f6fcfee380f8b7aaedc8af8448b1208871d1137bc1bf3ea5131cf227fb54dca22b56d9b6a7ca8a3ef9f8ad684ed9075b644cf6f820693c2e13a8f1bec8d0d66fe0ec235ae6c00b715132dc581dec7cc6d1ff37f356778ed74aec037e15dae03175152f839187becce811eeed3f22fb7ecf1493c1b0a89f6dfd12d5686a83af6b0811c696ff0d529291fac262c726a6187931eb88b91a7f714ebd922dd08ba5b6f19e6e96854842b09c733c257e9dcbd2ea8decb7b13f1360107a464c5dfbe01b25dc7a82af434b605f919d9509b6f88e99a047b239f0171992b16d98d4e3ddc922b4565dd2039d00272623cfab1f632556d3ceb974371292e267d94168ed4e05cff96a1a2b6f8e3149543d4857c5bd5c5cabe5dcb1989d701ab44785116607b1023cf23267d8653808ac58a8edc2674ad321d08e19c40c68c4121ebba0249b34fef028dffbc90472998589416b907b9fb0d1d696592b4105ba7043c8766ddf916105b8393395a7f82a3d1add4854246457e53f2228b4392a69f8ffd8ab41cd21ee375610ac8bf46b6f0653f63e89167dc0bda4849f3ff9f7d2bed1ea341a1210d5969a93211d66c0b07e625e3006f33b732df8f1a24164fe65bd14757580b7c98c064a84817853b913d3a88a01a28d55dfd2449ee5b94f172338f2f219f9c747d93161e3696a56ed400fbb4f37de8327cef041c2d751af7a0c27335ad4f7e3a1e43ca06950e237a3c68847e9aa515cd51659afa31d2c47c1021f1bc831a1d47ba7b0e634a191fb92ff82e8abccf6d03323c524dec3f09d80789f29aacc55b694ebb17a4258d0e5f8e2c57922d889d0a47838a3fbca7d0c9c3b952f473e2daf32fc78e869ed2a2c9d32f3f81cae0350cd4161163adbd696cca654065d88730ff812b3b90b1e86eb4edbf35fd36674fe4c1932e0b35c9eb46de473e49101bf5e781633c1608bfe922241e1a08b5b47da0f05388a3c6b89165eff27108ddf153f3e3da73f59146a7752972d81b3023133e9c1e1794820bd0f49718bf8b141c72a02329ba90bccbdff893983c2600a30aec5764a81b9cd57836edce9a579ee969a181fa0822e554217a9bc25f4c7cc5b2134feb9612c773889dde59eccd2455c317d026759c4a998811371cdebeedfa78a78cd4e1927fee897089ff639fc87a8944ab6f02e245c9493f6331d7d33ad818a0512b18070264612f1a71b217541eeaf74c4d0721d030ec5fbc4d817866cd1ef56996fddf48aae89a6efffc3183313cd8e5c05bddecba71cfd6c90983b2d19331a7e396294ef659f8d3f2b078481ea11752d888e96162f2274096cc621e20420c296a068f9a12133f32f7cf03cab1946e4a406eaf81445508b4da0453d2b2b7a5d8e5f2cf51daf1d23efe9e01d457efa80977e3959b2434da1b5bd14da297e58de4202e14e50cd6e4e49488efe50669349ae143c96fea0f5092b967813179cd2983d8fe4d9dcf42457a5d7726cd359d6b2a935a47d77f310d27ccb3b5628a73f703eb05d3150fdb605374b53341440ff4283163bfabee25d73a17de75aa63da01e6a197f36320c6ed8558107b9113d3beaec7e6ed71730b9cd2a05aa0c1d1c46e3d5407548d0dac4bbc9eb44fa003f478dec70e8c267c9994e3f13ab9fe97ad3448c5b4b51977314c5acf65ba6dd236fd6ed840b51454f8dab5ccf56de33f0bbe30b87c02f3508687213df08bc50a265d9806e3e1bb14914c4debf7e6aecc8a75761d4cafbcdd76a50a23721f9cf01e984655d441b9262e65ed03d1ecb8095bb3acfc7f2873c389b5f412b3034b6944e4ba6bb5ea6d9a846eea12b17be9fe28990bdaf809f45f3a8097c848290ee4ed17bea0d7271ae24fc09c3e760e0a8ba5adcd02a893351d844de2580c195f08f3cc9e28be679e2db8b8c612efd026b075f76035ed2f28d72313f5d289475d28c5d02816dac998338b5b4f33245f570dac4702bf16201ab57f69bd12b91ecf0d9c2265c6e7bbbc75c4e5d787d3b90ad13f50042549fec8394427aa9ee49de3f935f5357775433b65408576e5c177517c2051f9cfe7320fdc4a9c7bc1c3684b85fcd8614aeee0accab58718da804ca65266a57587ae3f80f0227770858a418b3ad258408ff5ef74d9609efa10a4600dd967e3b465316e4fced0c8666d77bc6823c6047cd4d283ba5e4c95dc8ca7d55c89e81d3bb63e3064a5421b331658705b8e1c9ef9f955320ae48c81b85d51926ec3fe3a43643a5df9693950cae177193e836ea6cfe8a54c528cfe19464bb45f61822125cc64fdfda7ae3119bddc3410ce94d20b5b159e95507bbc7a2998cd06dec4266b11eb05b5ba0b431c29962aabdd69a698a2cd4540cf44c2f50022d815bebb3d7779b52bcc36e0afb2a11c40847ce9ea20e09460c58c65c73f31c2f75111dad7a5b26009cf021fd082f2138285c8a0a225dc9c3d52698830e2a62e2474ddbb5f6f3a5d4048b1fc9fb7fd99db0bddcc8c72023107840bcaa0d2a0c1a3ce56716d239c39fa0223a5e04d76688a4e3a6e16b94eba3813a49a11aa6d67bb0e857e2bf96e345aa08d1cd176372cd97e3a4d4295ace439ce233fa70d1fd80699dc558f6f2e2e828466f41fbd06aee34b028230d130655d9265c3107e290e25323341bd6f36903e89a83424e32d5413ad4d4e6f8d47936b602737d09f80d13cc92da9e1b117a405fe7061ae8544b4f0e916194143cdf9a1fdb99c7c0d830a0cc43291c9112b5b27e4a51a1b5bdfb60d7a4acc673535e80d5014bc77f2d793a6f0a3ec2cd6af2de380d54c8196ade75f6ee823e1e087e8cf5f3f7cc7d400aadf218a29ec73f342ed2d849a5ba8c0dc188e3a2e225574d43b38766cf8bf29bea4ea09cf4a611903121aebe385970f5ad5a7d1baa98bf706b81","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
