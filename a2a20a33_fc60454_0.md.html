<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc87fb429e02be54646001762a9544471fd6a4355d1be5450094b147d4a2c7b66f3ab16171e89a3c252a88c4a276e1855480c98eda775417a968298a4269a37b1d100f7c9da2a364f6c6916bd78f1fbd5f16248efe9fc8081c405bb2089473f23a8452f3d3b80892ccd54264c21fb928cc24f9a79448d6c6e0e96b83b1832239bd9bea23f16214bd01ea7ded473abbb58a8fd26b7bc725c06f9fee1179d3983d1b8c2b1b60160b2b0cb626efe4adcd2c16e222d46a394f64caec50e3022bdb721f7b9253b81421c6ea7a73466b82fca16041bd8cfd40017cac16f3bfe9733d6005ad04013dd3920cf7935c81ecc92c23343dd7900a8a3733be5ee546cc3787a102557b672986c4505dda628944d124ab5af3ca9010d08b5514506fbe6fede6b2df898689690df79a17a070f35a37da77a8518878aeee4d915a5eb1d740e7d147b521e87ffaed6f054f6433c99df3daa75e4d5b15e00b4c8d201b2702db33d39566248f7e050a6ef07de7a5311ba3a0fea3d39c89ec8a3089452f1442f5af877e8fade81267139be3494f673653cb4d69268fd07e4ce1b53298e51950d6b720366abc7408ca31760a085c3acacd71854678798b0b87cb1d7bfaf8cefa8e0924b916c7e880215ad3e87a37c8d32122427463e7879706e6be5a6b88684da4911671c1dab57aaf90e17682ba5fa249ae8b97d5a59e74268691d656c0e6a469d371c1e32f6a9ac44db723335db2ebbba40665e4c8775af09e0a22df6d18879320db838abc5e0d7b7694ebb6b4f07698d689881b65a5ca166acb432e2e922f2ba2841b40cb705491bbee37cffc26fe8b46ba0655d0cedf1fcc7f89413b38ef6520f91a5e0dec640dc1a771d3fb7b9da0e7cc3daa28a89be0d2042fca572d06e7879bd65ef9cf00f9a634ca8559f449c815ec69e4c40feda0786124529b7bb59f8cc454f27f2be187f6f5d3226d0e93bf4a70b7016bdc03aa6465e2674e65226929c9fb343fe566b16d0a7d341ec6c16c0b56872f669ae27c37609b0d0452562de11b272cc7fb27f48393fac04b887dbc31654ad3480c67f199f79097d94c18ac4ba2396f8c5ede998fc906b4645fb2b75466daa634fd2e21276c6b3f5582492648b41ef9c52dd75b3e4cc78a4a2f3bc6d0c521f58061f4b8fd6ffd37bcf26d141b9f10e6d828b3bf7dff177f4314a7bd6932a0afe1969eaab780e297f33cfcc100c919e3dd49ea6894723dc55d1db173ecee712c39ac90057b0290f95e42e89f6804192d05a38682708ca0d5eaa96461526cb3f2a405b4873de7f29389c4824f2efa9b5d3b87531bbdd8f4c6485b45a5b28416285f474767c64cd4f4e112fc7af407ccd7b9aa7c092d419b04b6c30748b6f9933fac978479624f82a0ec1c925a81fdc6778383eb004e2f783fa4c2e72af9d7a96f8ba080eb48171510b657b987445f677234f30169c80def946f32aa2d5dd2b8c6093bc4060d843c8e6c25cd01fee9261f422a40c96bd5e3c2a10475b1083a4d04d38335866eb9bbf354bf53fd11898ec16d832c64497dc36c6f2cd8d0f44c53b841f95865e1e91d49a15b056b83c7786e24ea6dbd2254aa955140ebdeb65a6a00472fb0d6a338d9ac02318d2d169fc096f42b5ba1dd6cb880a4781e103d121c2e551ed12f2f5a41579622645a11cc35d2be0f7a225341e28d7ed9862aea5d405f73bd8cb461e670bbaa37bd14038e8caf2b732b79212102128b2e4d97ed1623b16b8d9ef6ef2df9d3d5cd069ec16a7e1132afcde44b26b25bec53505af6a47bb54b446fb87fc307da9c9e55d44e505c7d4edc8e2743e77ed0d9e9be8e7e67307b16925a046efd93c12cff92d657062658480665401f7625aea2b0ab35c6b1a996337257f1f44da53d24ed529fe03b95b0dc2f37b35c09cb586bb18f1fa83a7fa9ff494ecff77157079b02dbf5606809147fa88595c5475722f80ace76817fa64f68bed6486353083d58ecee078683204d47a283eccbc8cfdd89cdf1d15bd2deb67ec6f0840134a984e418284e80bfd8e5671f97b448d251e4d8c82dd7425a496366acbb384a439770609328e3ae41a50ad333052ccb9891c45a7a66e5b54720ea41134db6b0a594e4ed6a6bc15d88ae6e8fdc4d7a9e4dd8b8a8f87837ecf9314088bf10a01ad6bd0e0d3dcbad3fd43f02305da452590e079012b0ed6fd6e9cc5cfa02accf27545d06f3e6eae408480bc3effe0d5229ae25fce7298a2b0ec6b0e68121d79a583bb8beb0d9917098f01c6a728b0d2fd7ac5d7c30fe1c809f87c4f0b2a8f0c5a2288af09d84385cb6786eaa98739adafc0aa872a44ae43c0f889899f5ce42aa25b1fa448e4202af061cc6c4b6d2ebade64f65d3fdb4e29677642ca2881034c551fb6a0464d749d6cbb2e9a42c400343c5f0b92bdbd7e52d3e9d3a58bb2e1398d0b38e7a94dfd530375c1479470d64099bb03f03a907300b0af0d08b8da39a744734c69599750c92661b54809aefe56503e14f33c03c83cfb70e7dfb2952f95b1f6d99ea0f8870b0fcee35a28c9664c7d764b43ae315b85a291e08f7a54d3add535133e302abd51e74c6454a64135b03597c244993e440e6e102e56d26f83f8e6ef5ef694fbf890c8f97279e64e48d8e73a0367f7ccc8c5bbc0c11d995fad73c2cb5573beadbcde16088f24228623ab34312a59a4cd1ffbf10bab1fcd305c885f9391cb865fdfd9cce9f558295f415390ec55e9fc40a4cec37680cf0e6f571217c7ce874b89fcb4aab13bb20a158dfc215c56754b2ba4295f2d01713797f82ab40085c85a926f9dcd337eb0c812ef1b52610bef1ba8d76371274c19cb62e9210c9d3f3df5ebf7543784b4eb6ca25a90dc9b500597d01b9a55d5fc93c87876e39070580012760ad6cf29a8510ea0eb626c2c113914e0970494f47ca9b754526c9d3dcc3d2f67ef000e0fce944e4bcf68b4ef8b45603ad250776f7f26145c148924c39d2ac9fc94ce4f547e9324fe2f860b4000eeaf3fd02ef7faca639be5a0b110c79648f01d3b7278d4990343e0903990b9c8a49ef12fc1e6851f4ebf55a8e4f92c5d0311f6b1d843369272e875b949b6e955ad386ddee21ee406412240986c8c29c18301880fd7100b3259f84b4f3ba38ebd5568d68793a9a892eab7570dd07dbb822fa36e27fdefc293ac00f0c9eeb8ce3dcdb2fd963fc3e715f3d28443171a8ffeca26cb41413cc6bbe596f57f9190033877926517a165449670d3e1eb42969f12b780d3802244ba4e099c0c52fd20df56fa603926df10b499f7f8b21359a897df13ba9ea72c3b8868c8b5eda12a3a4941323b8481d7554fac0f51dbda267f619c1ea6db00d6b4499300b09c5624d4f53eff7fd403b62e263da07a85da96483f48cb8b294b0c6a6e61a5376160e64fe11fcfc9b29d37a2566bd1978561abfb30bd4475d7bc396624bf2463cedb197be98f8489e3990e76210ae3c0752ba002b76832e810a6345c8b2fb554d5ee7ed8ea3f48be198f1a2556c9cfe4359f2231f73ca58b4c0b284164bf4800c06156d729ac2a7a425e945587e77cf099395e64ed34a1e470d2abd8fb674f47a4b1df4427e5282a882023024693349b1571eb0414ae0885cfd02d45e0919801339407da56c939de86fac3c621e136e58cf866ca5f2203a2c0c563faaa112445a119b484376f25331fe73790f048dd478786c56b66301a507273999888fc923cfee2aae649d1ca3a3b925eb03dcb9809306b7240cdc45c4e9c82b156c54d9c3e93e2b34dd0894808e8ba8fb46d3721e934ef7f2cc55e85e999b220a321c9aff41f1e2710cec865d353e5df3a10ccd7808a3bb52c5598f20c25e59f387d3c6f42ffc545e9c0d03c302bc1f9d225593b3bc3d6e4e03ab02434fdc0092761c8481e352673940433e3d8ac9c15ff397b7462450dbf034aa78506b6106d58d1747ee952caf68eccc33e6f88445fccfefc51ea501fce41626e3dad8e0e618baccd067da89d9a8c286e158b780eb1ba34cc761c3be366173c5520ef296897caa9024466a106dfb401a9a745a87f0a1a871918485b0d32ef067afece63a18fad1914e929b144d575bcf2031af8372ef91e5a3115d6720be719461431eaa93153623d672150ee6295c54cfe0288362020a3328b6f22feb79ff65240943c07184e570bcd08b64f5c4eac5f2f63dd38c741052ac9e78e0efae5fea71247b73995ea5806d9d9c4f715ad4f08fa9a42ad25212ee9a9e660aa50f9c7c9c906d048f37c56c23f3889c4fc3e2df895bd4835021c71e629a247eb0a8df7bfed755623abf0740c829cf11892720805f11151c4748005b8382e86278ee2eec021ef1b9ec4606d39de4ce95526f6dc3b4cf66979f988d2276de640053e55fdcdb372cf79ef48b04bb3858518527b21fcc5072fd3863496a1378c1b3d74ddd53141ebbfb4177655800bbdd9d351b1c88e32a2790c6f3102e53d3283689ed54d184456b2391c39a1378674f1e17bf8dac20d5fc302cb2379873ba6553c1870accbb9a6dde483cfad7cc6552a9ed2ad99109d7f1fccfb082bbfed918d0fd087760cf9904d0826495a285240bd8eb97541dcf958d5f7db8bc6907dbf7a4126fba6f928746d0163b5a88eca2ecca0535e821737bf187bca445eebf982ab2cbcae92949f4aa264924bbdc6179404f7c128ceef05c09fefaf7fa201a975d00b93770b8831928ffb62534c5ae050621fd7a5ed3b1052ebc2b38787b9522ac185e6718355828b45c211b37acbd0331472663e6118aa2f09bd450b73fec74e17a85820f6ce41ee7c5ab4d23e02f6fc8183bf0a27c85d15d145861456255a11068a853569a9f8b4927cd863702bc03c1ff82be416604814117b863f28398e42876e457a25ebcc864074f082c352d5925e21ddc6d94a480cca9df6f4ef00258290b36e6c36b7b54ee5056c29844b999c3c86033bcdcecf72eb136a52e201621df8198d2f59b5579239bd6d6ff556e7501b87c924e20afb700a462e0c16395884878b5b8c07c8882313733e5e4f2f532a5ab609dce53991fd53ac0435499b5c929d3a3962c176b44f02e1c39a571bce07b7706a4d7d346e3de234db3dcbb53b84c7a49046d8f0d0506330e9eca75c60744707f4625e11f0ddca3701fc681d4ed0c0a2667bb637957971afec293bc4edc3c132213e8da4ebf9c4b147bf4af57dde0d0884a0d266eb7a44fc7c64de7b6fa992cba240a3d9e833af3c99b97d568d9a85dc8cdc37cc215280cc5f71b64db4a27955a027139156107ad723ff37bd5ba784f6e7e9e0653e28a853a1931464736dea44d990251b36d1c26a27fdcf83347597e38a31eed316353479ed71bde761337eadea89d41e8c8fc71b435da86f7dbf7c12b9946bc2a2ee8d5be95d411fb60304c6201ea5952386ac8dc467bd1a69195cd6af7c1006e6599d9bb7780eb533a888150d2d4fbeb9385301cda285ae11f24693450475af29b4cbb86e644a1e90a6fd6de254c7680b3c1348a0534c1945ac170a754c7786d346a79738047c55904bd4fbb57e57eaec506f047699000f4d22d8d7bcb76df37816286e8d4e362f31b63e4d4244a2a829f620b770c978d2a0ccee9d62cfc2367ae1540ee6e7559a636136c63a38a9cb75b41100538b03cf6d6202c239dcc7b30321b05916bed213a9d0a643591ddd2f3452c9f048087704ab2f7809fc85e2baedfc4c721c5ce0728b6d7b0e0e638eb12f22f9ee45f085ed998463d37661d66a7d805f3ba81534a39d7d989fce15d9e1a8e2adfa43360b55ebe3f7bcdbec5be0c659bb1ea88d81d5507885aa7af69a66ee34c11f5b5ef9f1811fd15252f01760833f5dbea5d97423f3602bb9059b6560f5ec21f79cb4b56b69240655797ed6021c1ad4f23dedfd0c6d9ccaa509dbfab5548b30a5e1bcf1cb7ffd9867643e6b1461da264ad0e53c1e5eee0858e28c5e32f0ed5f0f2ce9fe03e647b4cd17aabf9fff913a6f1a774d57df6ef8e725084ef6c9a82b4c6efdec9f858bab46db0a3adcd2abd445ea230a4f7a9a70a6501ccc62c89a8aa8db081e79e6ceb4c54d18a38fcc2c04f0eb2583e094b5d4f8a6712aedd67b2396ba95c427461d4e0ccff469da199b07332975e7b812e0d221e638f856089ba2c1550fb9d8d88b3e157f4587b7710b07f5a13f16ff5d7c3a286b06000c859debc118f04283938d2877f208c1ddfad073a3f3395035daabdd5a158141e86764876b8897f5218ae9307481205978e27f91a936ca086e9e0ca1140856bcc7d1ab6b656db59db972755336043c71a23d4784012abbbabf210d8cd725fa589f21ef10f612b7d5aa0422f1b071c9a4f9420b1b2a28f1ec0a29e407ce53bfcef28e563fb2ac8dd829106eb2794944a01027ddcad691fe821cdb9412da2b5b18de253049ea787b44c50081da634d229c4e06865d67c0ab77afa479ae1f804b3c524ab09c18f0738ac3c6d7d5902b751d27bbcf057d591884cb5bcccfe67961301b41b374ffe1b6286fe1ba6c76c1dd9adba365ff154d171c716b7d6437bc2575fb367e1317f58476f7699c90798bf20f1fab2f474b7cfc193ee4bffc4078bf58dbf42b2e16aab7893b0a73bdc285c7b622810cd7bbf1db941d216c78a81044a5138821531dc672c4e94bc4892f60e9003ce9989819645d4f8b9457c76526a2311021b025fe53abe56f6eca495771f3927690d8e7f7e936cb5c82aecd5561baf167c1993d28f9551d98850303e0a6b8bc4a331eb4f9df58744ac556dad411006c1866e9be96e576c8dbe418a757c9c94ed60f110a64b7b3785f4ee3cf675ac26345dd6b5626560b5907e9a54e9701ee845cfabe3702863595373a9dd11ebcae6ff4b7c3e7820babf300b538bb7f6b88cd4534f520d117b36e23d0c9bb3657f97f5cd0e35ded0916a130f9d54576f3393ae2a5207156d696c1e61c4f7061e02f2a9e4d83c946f3f9bda6aad844c5519c85d6df3ef8044ad1e5057400b98384a434d3663436b58ea8badf67f137a3a6c96aac11270894d3b8c975c65afb816a660f3296c552ed3ebee49ec9d480f258b94bfdba033af425b48a552ab227eeadf61b5f4d93543f0a8ae26881697704f3aadd455e2c9074286fc85b5131e47a4439048c8ecd45bc838ddc6e9360536f34a2822f2b890cfd790cea694016f49f42dfda2d5662ee65fef41b0ecdabc9e49ff5079f0338f36ef1ab2435301de605e35e3b073f4e78df2ff897d5de677aabb1445147d23178250e8baf70c392733a3d1db3b98aea382f218bc310a1b34ead89ec34d6120b96582d3839f15243afc188537d5b5c93a9b704ac5599dfeea045eec872bd79fac47b00adc1b592b623028b357c20d4ff2b078db356c8f4fb9b7673a4f1acdc92d2da26e08f274f51ee088deea007f2219ef925acce3550a686e5602d60039b473a9a01a2525ff4c93c243d4309415ffe9bece22e62085177569ef79a338106f405834ec6e81027ed489e7b4279d7356c5cb0c167290fe9c402477b3ebc575da4db63f2a4358bd93944d5e7b55fb8904d4b0c9c22cf6ec1f463d4dd17c5c9bede158ae8ea3032d16cd2e3046d327d0c16d32a8eb3e315b8fd382df8e5822536dd1c11bf52e219689d05535c377f4e4a726ae4a3919d13662917f8acffc69ce5acd11731089f972e82fc4fb6f47ea5de6d949853d0f7613035aafe7d3f2f803cbca2e94a735a27dc9fb1adc4eb63549e54ce3651ca4519df525d4fa8a26e1ad450df358e92f17f3c7da84653d28d395ab69269310a8f9756f8f54eb57bf802570a81e90552d7c21ecebe9024f67e34e5823148d5fa50cf276ef0ce01e321c9617b05147100f96b44e27122c6e83fb27f1dee2cd9fc9dde5fb8e44545f8d2aa1a33eff290ff4eea3512fa768da55c11c7293a6e2d8186d8e645342dcd7fc7fabea6399b90f144d8c57d19b23b69a18497582d923f921115b3baca8872eec7a6cd0978ba05a53c46e07d008823542b831eece4742c9c66682b99b8ba8e55e5d7f56bc3d28ffc5e3333d2a86a3a8465fc4a1adf765afd33ea09b14589fdc739f2915c0501b59e19c93d336fd14aa4125b11ceb989a04b401ef3dd5dfe4c84377691a3809ebf69ac534a1b8dba069585eb7af97ba14eb8b8d0746fe7367176a6330ba4eb0a6eb7edecbbe00455a0f4da2da30adbff8b628c4e9678ab578a3bb3731725b7936cb2beacec33b05e918d30d0300d928a9b35649034f2d6d3017cf1d233be36b96f74d49a58d29a3161ea2b02474c914b1ebb49b30d6efed5dc06f37cac39d2a08b964b657bd6fead693bdd30006eed26ad1a297d358a656e5c24d8c306b17b321cdc1f320af8b795a0f3778943e4020678200e479","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
