<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea529c65048aab582974e0070d6c3fe494a4bb226d57197e9e52256638e0563ab45b5b1ba4ec0d86deefdc589fdcc3f5dd8316e838aad9e9de32ef08b53fc4c7b2d899b004a127605a9f00975527fbd3d0e4b58a7e4d306c3a5d8753eb9a186837832b8ae6e9b85f37020d6f4abb04b878813c9e57312340f26387cde9da10d347b874cf22373358f24a63c8bd456eec0395e54e188ea2c6fcdbad9188b93589abc1f4e3c9e66ce0e8fba8a650e4ef93935f935192bb0f573e1eabc2090b8eafba148570c55f33197af495fa527bcec3379e12517a5afec89217442fdbab26b76f5f0794c5d7cc7029582d9e6b656133c3b9d2211e350c09b990d4152bf97cbc5a6be344c7a781c56564b5f07f15d5fce3099960e2e7da8fa3421467ea1b760be9069abd9d68a131c6ecede920de5ea012294c88771e6cf797633605bd1c119cd6147e38cc070c0090969466bd36fe06beaa8a3792fcbdfcaaaf06f94fa2f98395e1fee316d995bc95df4b1a55b7e007ce7f11bd303a3b5083ad99287eb1a186478b7fb0a792d0079e03614f761f31e272b487005bacd9650b2d253ed43150b4756cf45b85265c73e9bfc032212867e9b0cc2e1b5a26d66778bbd9ee19dc203f6d193b9bcccede0a8dd2848bfb567c26802ebc11687afaa20cb9aa65c448f00948a5922528050de5f8d5405b71b39cbf4f79e92932a044398d973152e70c8bce65b6152cec97fdce09cfe546b5e4c64d78556ae35a4107da8b3115af59ec3217d528c8319ba7740b7e229a8c1aecf955ab69a05b31bc942cee6d97a0593cd26cbedb3fb4778be1dbbe112c842786c94c518baf7afa723a20d9dc7a8f9a509edf1f84df154c4d8912c52a955c18c5428891ad459bd7e736adb08b36d48b6799450c988eaac80ad80e8ab4dac758b5d090a222c040c166cac070e8c1ed1114c61c29857d0ba31a2671c7a03fd57a886a8288c1e06f5255975f0cb2bccba7a3ea5193a0659a7b233eb4a04d792decd7d49245ab5a6fd4609d4ae2ce90486d6ee32ccb593747a405485c5e7a2164b8f7500fbc09e4f23dbade91a5e8cbf5bebd99ead3d14aeb6cd3e0b9d54b0b3522c6ccb30b9b386b874dac7ed252bd02d47ae96af0c3009a52c2ca9027622bc31e2380fbb5dfdea975e465982d8f8abd16a5dd724e8a64e0ab19f18d91d209164fa10e9ada66610a3027853c155cfebe5ba4ef0ade95ef5f92afe1a240e7b0127e8da099f34e2a52f1d77ca25f1f7c86bd3fe98e3d9b05112c3c7aa3f2d3224b9285e8c6d3594c20e7db17acb8a34197a09992f003c53e0e11e9306bcfd26c83e89583e19bc85bd01152963d4429d24cf034bc661564536464fff83325162aa935c33ca851b5f98e847fb4eea26a80e961b6d6ed113e003ed60d7d71c4346e42524033727e616503924d815de5b40aab1691b01a6b7eb26f7807f1b149a450cde9f8cd53fbf3b6860e02d36bd23c2c111d7cf026453556ecba8f7dd8f652555723d758286e35cfc704eb9fdb3c9a54f8df722e8f10e8aef9b7967f99fec03577a96bd3f6f29218f0e217c1fd24051366fac0f6e37e731288dc7daf74ec3fb94d771dde800d5407cd7ea0c9e19a43cbde425f81e034141a4dfb33d6012e1f553e79a9397d350724304040f4ca2171cde7e186ca7b79774d6603959b941c5b25554b53f0fc3ca24a86b59336ade36af5fda8063540eeb945186916505263a697c550d327866706929a3f79865260a0984be7663f73ee0299b19f9630a3b01dad659c2e70738ea32a963c6c5866f315e3f1381d5284f936977e807a97886cc7782ef6f9ab36d389227a8ccc298d66cf3284cb36a660993a2599ceaf1bfd42dec4e23462e4ba4c4665d05337343b18c63ec71b73b10c079cc9633e6f026f876f0301e211364519a58bfba420f3ac3bcf80bbdd12fdbcd9e7dcc36b9f36fd9bf4c7868b3a29565dff3cd7700499dd0cea9d4ef5775271ff874afb26015e4711fef55a958ac54371a160d1e7e4c38a55b9d40507c2b1c045bae1818cb8bb106bcf805a953729d6bdf521ea54f003de86c5535919cf46bc344f6c4d4f52ac96135873c91a073c29904b83a3da046879867178ec9c2b0bcd4a7eae92714559fa7ab1d758b41b45e9a96504254ee7f5919226446c7deb67f0997962b113723175500830b7493c1ae6905d3e4bd86f0a8f3d7b0ced6c8500abdd57b70fe73a2cce8d5220be81ff8ee4edcdce77d96a0fb43227a6231d623414bd6127fb404b97e9ef1dad19529695e698bd10d3c3a2568130fa2da26b6146ab52cf27ac9a0ad478304a68dc3c136d7f2c51a4a67d020ecaa98478ed3aae4c5000628e5fe95b3e64b40e8dca8cf652eec7e883f99a607d0d8006177b7e12f1c808510e1a7f11d787b632e6fa05897aba53600b989bf29f4505770aa73cb6405cb85adb83c42761f5d99cfb79bb5373bed20f433d9552280f5a6591bd9f9255b6e333b9b1fd66fe4dff1827a8d6a9c9f007f90793356dc07db74798e26d12c62389494dd6571527f89f3cdf9fd86e8225e0f6511107dd201e8e8d7aa12a08636fcf66365a1caea6b938e808dac25eaa0194e5960780f3f52e7acf80390d16e6e10b33705e394663c7d1c979952d6afad7e7d58949a6d5a062f490e63f8096e7817267869f6a73699f01c4d6822a7dfa7317479db57bafe17c199e14f42b6b0f9870ff21dc1d6c2c5b726817ed5cd8073125bfed3133ed66cbd6bdd65ba3b9071e8daab245e139adc059104cae9f05172fe915d2c6b2fbfc01032ee992814e8def8d57a6a3983769cdeddf901b5e516e2c91985ac1325bfc17fa6384e55563d23b2770bbe336d19efaa4ea2edccd4a8b2923d7d8581ec0b6c3abb53e83ca2831cedbd99a70c770a60aa5af8f4bae5bef3e3df91b1de26c6e22fac4ea996db62a19179cf392ac1583ee01dd8327e09a3a8d0480c6cf550e3fa6538e92fba0cc895083e5c6862bf0a319d68406b89e59e3825045525ae6ee13923263d71c861e534ccd52ff8c27aa27998358c99b0f0fb2d16acab8b136a96504f3c4a6f5b40859103f21ce69b9620af2b4b510017c9c49a2ac992f58b37420d7d27ea0cdbea38b35b214fd5b5a255e2cb6e9c122f1cdc83ab9073670ec2e5047ca1f9a5248e3965a81743760fed6335aa0c8d8040ddbe3dfdd0ced538af3905ee26642764175c6c24802e95e060d6e5067fba5ae64dcfd74f009764e7e9e1c881dea4d66a5226a61e593960982b762fc10e512a3f842a8b8dfbfd9697fba0f182b3b28b6beeb4083adb640ee826d6edbe40617a699a04e825e258016ccf6274ec4e92dcb38b81b37629032e912435e04559ef4d4a09d3624c35b09423926dda239331898dafaf00ac1e9a6c5183a3b4ba299ddd4430a1719b074e738f23d769b944c0a73910674fb55432b3b2d21079f07bff664a817e0eedfb7cee5a63e355da85b2aaf1acef6a69af5934281cdbeb3d787a857d68a83598e53e9748fe83583a933899d53016d89aa27ef2e3164a0a54909646d7183de94ad0bfd801f41a8ac2c3b12a55c14ee1756cef090bff1fee7f7f36dc25c7aeed89954db01b78189d4417d4d06e8ae82c744a9bcff00136b0d10cb97cb650fd73ad28a30e14ecba00130fd80ae70ad9732982fc331e45708acbabf8e71268bb0720fc9984cb245808ff2b351861a75c6372f627438fab2b63f4a24661c6f15ec46287ae780df99932cb85a9c0149bbfa905eca48ac45db5e3fb792d6fed99f5027027a9019dde1358d4a0527ab07f8c35ebef4925d17a6c732a9b766dc067e4acaf8f6494978ffdf1a26276693eb23eb3b0d5d80eacad03aaf9c56eb98ba7cab4df7d0b61984aea1ae1501188beedd482c820601d303fca3ce931477a0d78374ffab8899aad923460a38b80375641aabbe318e151c77b74a233b2af8821ed7f1904afaa45c8a3126155dea0795224c86ac7883d1cd0bd7ff16c04b7107a5ac9077cc2ae90bdbff6ee2ec215aee2dfa931f4aa6966d5a6a7b8e873775d082513f18cf43177a29ac98478b8d61850848fce0d0e6014bbd7cdea2f18af1fe462ba84c6b75cb98512571a21aed477b4cf528c8be1c3bd4a15dc98586ddb1ae05fca4b02d8898e83113a26fa03b23ca5212ef40be461881a6ef29026aee854f00250ee59826ec336ac3cd174a73f3fd02c9168ce87f3b500f2249237438a40997a8a07772ab35ccce15e21aca95a272e4f287aebc384da17fc8ea4b6e05369cd2ddc2e9ee72e3fca00d3c0d1222d447cf9a92220f07559aac9d7043f7a65596dc17812a7c116f6d5f286fc68bcd58468dfda0db629baee52b22ee164aeec22e168152475d133d38a22f01c4a4271116ff6b8f6d6ec78bf236a5474872b55786b475361595b486c0b7cc8b40947da4bc2f98d42be3aa33bcf6930f9a21794f7af603bdda36b7affae65673424967cfd03cb72d0c03867e81a3a3a113e800583acbedc280c0a85966edf881169dfd31e0e11951323e3106df1b68cf79127fca2b025a94afbee8983c2165767fdc398332d82f6bf89bd7024db84473e332dd2ca617f998fdbf54b17f542a854bae3f66b197afa91634899e7e2007524d55be6126e65137f4a13e84d4fd9bcffd750778404f1ffdeb6d01ce066c946140967ce60dad4b5771f387ca792725cce8144c530bb03177d46f9173e9de85424a9980726dc5ab96d2984c3ccb75241781ffe75c941ef727fdc914337b7e90e6e6b647a98daca5f5f1b815d1b71e4c04e8f7e8cfa850477ab5d0cf1320da8d5c7790bcf831774addc66bc5689dd68c96c8e73196ebf9bc50076fb6ebc7e332739cc77ad81fd310852b750f5c126503f7768bb67b8d4007b52aa9b8f26600c6e68389346fd439c259049f1388dc8c0a642c2269987c2a6f144853d9f5e72b7493baabd91c2721ca26b98857292abf18c2e8762b77c5cdb6f35888ee758960a8513f8210c8a8901236ddfdc186e12adc93c0656c67831eb70617c4e10a74f4fb40a0460e346011d066acc850d26392b091dc7348c5551ebea5ecf4a70fec3ef9371b560975b0b508e189aea1e51c5171fbd9df0582d8edf49d16499672747cc9c4c7bfb1e69fcb0b93beaaac566d9f9d531f2de7124fe9ac62b9072867801d4ffc5eb06fd558c5047c1cd588adc498cb3490997a9d4cda7ecbd7fb9de4704790fc5943cf6fd663fa9dfff97b77df57d312ebfd6fc36e1b5a9c992868fec3de0bbd5a774de8fcfd39d5d3a687cfe05a10d3b3f5135e365edd8b13ae987e1fe420a5af1383d887ed3e2b88a2c90aba2595f9beada530998a8a7c79508b56501556297b258aad3a70798d5ea50c97682f2a1efe0a7eb7546d07a4224606a2c0b9576228c4fb4db8c374c4678391a27713063d61bc6afd0dd7bf534cf8b04ea1b93dac68891c9987b75e5bcbdfb333d0532eed9bfcb26b87784f40fa0dfc57b6fcfaf8567f4577c4b78af3eddd23bd4663774726496df6b4d92bc3e63c158753c4de8ff4252580478bc16e6b1266286f52418897a786c1e28f876bd52d429cf2f33ade005079acf41e8a9a250c2ed16ebd474b6d57390d24917f6d987b01b50899a48da0085f1d42b8cd033c9622d4121de2b720ae5879b2351dd4f516a115f3bdf101a4206298f8356f9698cf49de2a3e82b84dc36b02b1cdcdde386a1f5b5dafd3c08a8ddeebbf4339b97cf5e201965657b02ff9c3795cf510624dc3c1407e586b5cb50261f552618608ce4db215893b57a2d0b141eb029f014e748a9c1c36d127749b641e0c46baaa1ce2633083520ec97895545fb1edbc19354725b26b718db3047d665aac4ea5a72a7004982f5da67834e4690500904884a5dab76bca65e4abdf9a4c71109bee2001c92dd868f79d12f5ba6bc50df1fbdabe4ed571a850dc940728cfbdfc6115fc7f0981d80093087920cbe0baaf0223b07f839c0a716780a5c3ae4599014df55de5b439b11d5cbcf90fe68e3b18bca1751a87fc5fc2591fb60f3e62998cde03a24a0095f0ac719d1555747003eee678cc3751180ef5b1f8521918900091ebf954a5f90264e96f3b292fd11724db738b5d3d3387ea17f072bdc2ec4afc2ab8ee0a7d7b71712abcdf7f63c6c9cb8cf692b50131e0f5c63fb9faf6fc9648b441795ce2f7f69db3151428d39e471de077db04800340ba5523a12a395aa214c53658a482112a53898e7b3e95526bcf7f4c212e58b267bedf23da99d0d27c28a3a15f561b9e5fc571e40a195b70e51a799695a48177e056b0dfc0bc4f266435b9f422a865f77f1c8a8c312fac1d4d20e6fc97ee8b8ea09719a051fb1a67a4df95a40ad6b32468379938abfe39511a3344163fdd450efe306062ac7bbca9a343e14cfd03b713e5f85c773e258163ba7a39d5cb4af553d90fd2bac98736b8c3c21d56bd84589ef1eaf286139d20cc502ee008b28ab93e348576cae3900c8ee2b1b996857aa4647980a98935e999fcd2f3a09bdadb93c166c4bead29be99b87dd70e059a82b0c394f7861a5845e3604eba012c37184c4185d1a1159999c0aaba7758c5b3fbc9527015ffa5101a725e8765f8a8e150ab58af330b08589d3cebad7a51e0ec90f0322112d9a3ef5e8a6a8dd2c3a9301a7dbc75017e05170f36f7489fdacf774be26a3522746cfe70b17e598c4e9b3faaed7da20024f647fc1332ef37c1ecd06d8daab87be7fb3a7d190a790ac551ecccf59c9afa88a3e4721949165f0c0ec13d4e475f18a0f093a748afe358762c650567af820ca59bc798d09c560c3e5769459f0e075ea50a9624c82f96f689202c19f49ae671b219829f04a5910f077bc55e9da26a4d46f814d2cbd68061e2e1bb54b49335db6b220849d0d17acdff639b2d62628add2f3148aca39aeb2ca4b6d1f67c218b93ad24c0e2ffbf39b01da56b69b1e6b5db61316cd389fb5aee10394a5dbd96a523efe7c0705975c6ced320d2a35268dda45bd4fc36542f3460b3fc613b977ee4525b49213cb76ad8f7462fc5f9251743b5076a90a37ada721966f7a373f79a5e077b635069c0554430e1652e1c2b830e91d24989407227fc78cf350de1e79a45b013e27bc23d079d277fb235426efebfa0529583783eac8d65b13ae7381e7b9d0d8c5885755eb827fc71c9db3e3b2ff527a0e994ee6e01802e26b6ef8a37fa266b60cee104bad020ee9d0989841b926c43f968aeb2d13c8839de24c8ed15e56daca7b96ac98d3d04befb7fc12447d5bffa364e0eb9a9ed2da9d62d604e71959d3c838e7bf975cceb494bd369882a9cb3392d4a91c2b0fae62da68414d423a9b7c0428c34df488cc1127b5483ef2c285aa4f4f5bd2c2aa7f5af5fbc17a3ae96c24dae42268c3ee94b7b09cfc2a21d21b30235d00b227010d1d2133f072a98fa399473575d3adecf176c4c4b6b352f80c5cd9d62f4a1f1a80254d195409d29852ba0c4f58e2538b8263a7f33905a1e3c32bdf9bfbe5ae4641f6c14c689ced2c9c61cc47b28ccf4bc3c20411e233be8930a3efb379266d221783e0e0d94d933d19294e1562dd9c2213adef2b0450d3271a84c99062decb837c1c283a9d7a7f5f80e1d53562e49375f5fce481c35feb57cfced2da618d19927abda0953a779881f9aea77e3aec4d42ac4fc4874bd86aca984737b1f7da7a21b73e8fc41e413760cbbc358e08c5c74105e22bfd04da96742624263cd4c283e5a02ae3721d7458d3d23fb5bd74975818412f2e5d1f5fb66142df94675400db3dd453d84aee52637e887cc37b442b781b46b19678ce2d51bac5005dcf9d10ff31b9bae9e89707c1ca703be8419019721fe7470399d2a1bb33187d3c2cca44a3bc4559a25e9af2cbfd1d702a6c93e7d38c7b716a05b1a2cf9ccc6adbaea6b6fdbf77f93f7c31cf99ab408b2edf14c4c0709777555ca959ac022a02a095f4ebf7ee518ddb95dbbf813cfc4b01077690bfa8464be2e7ed1d8cb74acc153cbf1f80870a417fbccf68a9113040718a8aa4eb063f1496e3abefd284b11950dbbc2050ee5cff8f433e9e93553e0f3dea1106a83835be7d8adb0b2913efadae01a18b818f4a9918a931576be10ab36b22b34af2730a3116ef020ecdf098e0c0145bad77bc757f1d6933bbcfcab9d5dfa2a7e15f53ffbd46f65703d022cb2ef76a956bc8aa1cc67980b228fa1ad6936f45ad45dfb480d08404ad97c4f06132a44ead668492914e2b9d7ee504a52f13be4375be113eda288f716e7171f05e08f041e87d1047d6c141729169ce7e11c19948bfa4a451616f0300b48553002e5dc5a54f5e852b6f853c3ee95b0011576e0c5f41e7e6a88f56c019d2a860f0f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
