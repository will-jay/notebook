<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9ea4a1f3a419791072ed4dd32887d33089fee6a196982f5be72845b33f4c161710e4a2505ca3d3e5f80b986170b35ef926f32290c6231a92fc6738279ef0e7649129ba924e0bf425ddb8ca009d744855de6ea0b92a17bc69c99e94f2ca6aa59839188e0d3d6e66b9789b0cd61bd55e9a4bd94b077a3dd56912c29d426e6999b3816158d81ef26698a29822ae308cd75241e5b46f60f4c7b19b53e25f01ddd205e43b38d2703283260e90c55af2859bee190c6433c06b13d15529c625f62eb7c62ef152b2f8437c783e20bbca1e6b7eb83f8abf01141d16dbe8310483d110491821e606ba2fdfa99f2ca929cf3042fc4b9f26f80b9e99f226ef5561e4a25151af2f2c3ad3be2f6ec6c0f3184caf79f05d13e1037d288d94e9719399d134244c44aea18af6266a718e1ed854b6b7566e55732f569de64b4c961b7f3b8e2918320a6c26ceee487e3eb2c2e6fb98192ae610ac1d1fb9b94ea20aa349a502c2301f6e969b2d67321ebbad98612e4428a9b258d8eefdde506e3b77cff9fb46113e71b9ca8f36699ca0252c9685bddcf573d40dd6fc2c9990e4953e284062f5dbd73e1276ba39f9df2fb0501165a94be72856c00e11eeec8af6e80be70f91b54ae8e0bb759a3f547378ac83f2e14361524c378f5f5b889a79eb4d22b344a624e48d2b4f20a57c35cec39a728176d8efe7c5b85923daa4039f04aa3fd93ff92bed7574bce06a1a633900364eeffb26df26a36a944052e2e7b7b2549f6c52a986618a151d68ee2f9071814b6e4f9dfb66d9cc53df255405ae3cae0fbdc4ad0e8891c9116f5eea4f7cf34e2a4bb4622b92ab8c19624185b775c71c9ed906153bcdd456e55ea646e271dc6c00079419283a3271a414f98560d3dbf0e3c91490a6ffd869b5d2a32a9011a9f93c9e308473a3e4fab329aaffa886918507b97cc2d77fd020b510a2341e300c1be05278a364c9f9abbec452e8f868c7fa2595440ed4b0deba99e7a402cd96bb0e5dfa85e0db38688fbff763d4765598b49d1410b6cef68f7c80840cf81d233a6f53580283ca8e1811e9e10df550131439dbf243189b24c1dbef4e0a35209f0b2b1d4cd17e9aa1a3aa52e79cd59a3675bf3ac7b5cb54fdb99063fa75833cb70d92ed5c46977e1e1e50a790dee0d70ec8eb5d07b207c5f68a4a989f1bc551ec7420ed654336691604551c84ac8aaa24b5b7dbfc93a743475d5646fb239466442c8152737fb6f68b9255fdc690f1730e937aa8ad58785651f39213814046f2e698237ef2773c70bb5bb043f36f7d2f975fa70684da6a6bd4cece33a5e21e764dc48cfa06adf1ea0689b045de342cf3cb3eca4998aec50ef69cff2ca870e7420627de6a27b878d3bccb68cbc678f1bbfd9a067b32755c6f2b1da11c0604fc0e92860a67f1a795146d510f374212f9e39b1f3bdf554c588fbab602a0132d271d7cb2c19572605687aa71efe8c09a6e686efe19160ed3eddb851d76a796d84b1d0dbf843c9fd3112a215422181de79c8e7c578474260ecf433963cde72d5355f1d4260885369010c44015f3ef9faeff0b8abba90568c7ace1f44f5b167600f8fa6f4dda0e950d3586738041fa5be6ccccbdd99880b6b633b3a2e53832f0294579d642224d5a523eb8e7ab8062e8effcd930c6df227c16f82faed3a180b2a0131ff6ae2ddf83108f65f4240392dd6381affec6f2667ffca4235b0deb309d151dd385c374f04dc73b17693b95fc48e8d9831062e2e366e3d8527907d73be4acf79dbb04d95d90ec0f4a2de0e0e58c58c5ccae30a8e1b744acefb98511c137e823f06acfc47c046d8ae1c57b25c2afb02656c699a094afaf6cdc6ec95cee66fb541c139793e2ca44560c49774267361a713c5373a1a31affa1fd077c7d122d6e6da55fd7b06781880c85cfe0d46c6db953feb1f53c457deee4489276d9ded473a410e14ada1f8dbad739017ca6c8334abb4f0d4b199cd78b613b2c67be915f27da7fb1094e6e17a046209f6c74c63d2efede936bb313037bcd34b37bec609f602f751cd6fd109b92b8434572af8732390c2576a75e47496a24f8f548f462ba57cbac75747a26a8264ec45193001aa3df52cab58ce0b7fe5bcf6503f0a364ecab39b58672170afb856c93ff7438f92d08148f06368eb6570e53adb6b39c447f0222e217cecb3522e68746acb72bb0d4037c821553ba8f9376f5c34570c66ac34f65c100b8d6e3559456bdfc7b0204ad66618ca048df50b68896666ff33dfa3b59d613f3b556ab640dd8d14b282129826c3e12dbca4caa4c9b6f114ca23f946622b8d93a5449c7fd1f86ebc8f4a9f97238a094db69da3720de4a7f2234a76ca8d63dc8c7215f66558dd0d350dd16e428b749d3a7fbeb64646bd7bed8f04832e5133a591c0418942ad249df9383bcdc01281cf8b073bdcbbedf03cf477cdbc0ec6d5d08a1948d54dd639e04dc2f51c15ad6c15d8ab4d843e8199859e3811b524ec230f4d07fdf7ca2dde1f1f1a0c1cad55d6388b0344db567fa344eea7e717df9a43d47a12f2d8ecf0cbc63483a936bf52c546e11ad18fecff6a643b1cb2a15124a6dfcf0422739fdc46a2a2d0dad828b01c0496c309129cf5feb6ff24bc503e5ea5a84847a215bd30a68637fd060deb34294591387594b66ec70fa59c6b6ed20f229955d1492759e6700b36e1934cd1a96a8bc16e85fb6f933efd1be4c5853b5ef5561853c4a31fd3a841ef5ed8c220038bd7e7fff55eb35d2faa5ff91c7427e473ad942a42e227a4b36619c23217d1fd23316ffb23bc3cd598987da6e313e85517dbed46d1aba1a482544dca1756bed0166fba964e173fe9fff23b5b94a07911cd8f2aacb3f3a9213be388a99c2df428e06d3379f58767e0557d773daad906f21d22eb2999c3555d942c597eab0c8a40db05befa608122da09f992901ee71acbe59ff7d539b049e02231938c17c7bae37ebbbbefcc263fd1819d39c0b4cd925bfa6b247a9a0ae339a56b370d4f84e423a776f39bfd14890827a75050d64801f7cb2f824ed0ec01919e56b488225c980e6f530e20bdca2cc1fb8c9af43f24c84fcb356962fdb3b1a78b453c5843a3723a4512193b36cf7ef97752b908734eb0740fcee4312665fad063583af629b460ebd1c365fd27d91a6ad996f62de592592f8886f4436adf035ad799dad8660c4e0de7ef1042f381cb1669fe0e0e7f163afbd8a5d77d8cf04d76e7304523af02ea704af05b85147cb0e409fa8acb86685921c8e5a4465c152f5539a8b4129806126baf0cb95a0ef797fad66e2ca7cfd8bf21d8b1173924a34c5de108aace13de45b4e39f6d62b03242eaeeedf1b4628430ad6fb136e04a8dc0140132898f2a30d9296e888831e0cacfcbe778bfc904fc43f1e2d913f9036eb02fff87da1f753f502db12c8b2c1df1b6feba39c7d40f7720caa6ca8b0b63476528077b5a6f4a0d2feeedfb946a3b60224a6797d8d591989e0105482105bb76f2b19ee9d516c3e061f7c4d6e7d370cab435aafab0b1602ca9adc67e91732d75e57e1a542c6f68ea1de47702fd53a256c847a79e7e574155ba6996c2aec7ba957f8dd2b32724570e570dcaa05a1d4b0e390774183718b9bce7a068882d284ff7b07dc35c2e404e04902eb6b2c6013e73f6863454f782b36f58a9d4669b50bcd5f8de857f1e3e2b997a006615085998182104a88061c342daea821e7104fff63efa6e17db9a989053c550a2b1b52e4508a71a9da13423b0f658b20b5a9e2af6d6ec638361725f5cf083c4b7e27d0b0cdddaea4647a3b4292aad9fe44403b31db8aaa81cc275795044e0e6fb0bcd422af2c10653740c8d9d911c3b8d3934fea6d0515ce24564725e51d0666f7a19f6d200ceb16b5aa4a1f96764322615c570f0acc7e725c542ec5e837269b829c19356eb00339db28256f67aced217af1568ee95e8389a8b33f4a47ec27fa2e2d8a53970fc24d0447eb90ce98050184ca5e3809a406cac2d10aee9235aa6f94d316fbbac1b246596cc8224fbe445c8dd845d6d55d6a6ceb7ec038ca1de938495b5b62f2437844ebbf83e50bec80f2dfac679d89d29994f93306f8ec28ab95782686fa466302cec8f79bd9e169eef38c325d6a05b3e690748a98ac13d7208058600564419b1154cd120f13678c18b954fb32d4831ce4f71139807894f5ece141289e688269a4c568eb0aff567759322cf43ff184e8c47ec52325e06c19cae741b77d344a51a4ed41cd163c2743166bda6551af57dbad373b4ab90e61a4442b02f16a4ba19230ea9cb391ed1f9b0b318e61cad67ab7ccc4b07d590624ae024bbc8c4fb554002467018e9d12937cd9dc7c686ca3a24228bea900665bba76b7abc8511b888672f873fa9d6b262af363657eb1dd054a0f42151c549e4dbb390d4f6fae50876332cead564f6f32d288d0c5a323ef1a9c608a3af6b29b15193e055fa02b1d5fbaecb91b6c2232118116fc63c624dff0d22f5398cde17a883c1b429ca310bbc21529eb144e5c01512510c945b41c5dbbba1a9c817ce8a20a1b9bfe1fbe58ee9e688bef982f34e2d373ed2611424f50f7a02be188ea3613a35e682941c7cc40a538c673125dd3e36ab20868d87d9609f5f2274479a026eda07fc933e8c0867edb51585f7c52f44256659673e0b70b977949974f07e96a7d54fd424e78a4635582bab06726579ede643a2bb52ce51d84e7ba18f38a36e6cb3d583a61372a96f5d46d9ea75445dc8d749fda2ad4801de9d87b4cc3f2f6d8cd3a9cc68b846abcd9e06f2453044b5f606898093da5053fc11507f22ce736a9b384f647542da31b2cafcc6ce7eed18fc9e964e9a66f9db6f236afe6a61833581522b389f3f6c98403f3c545c5b6359b5e71982e0b7b27fedf79f5cf4d6538663ecb1317261bde17b0c56711649dca7116bf68f88e1797c15120e0d6b58349515bb9184537a24a18299b4c0b5102fcf7b71cd859180699a13cc40d974e21f640da61a280e14f5ff423894b7f7dc7e7680cc525277f56acc0759a0293f0a0776972a34a0f8a6f6b30a38310ded1e7b3a26460fbf4be12d61845abe48bd45bd4c6ef3e8bf09fa096af919a5db71cc633334e91659339b2cfd26b53b1aeef46023fa749cec5950588d14ae549c03777542bfcb568f31a2bd335dd0b59f3507d9f27604ff0a5600d10b7055c8e474e849680ad3f7980fc099a5b6a5b8928bd9d892ec1a87c9a31cb1500e81e104dd739578cedfa5b27a36b0a6d491ea7e8f037b9c940a24847845d08fa5f65536fb694521683e96bbb16bbb6c20de73406f5dd1b0a00f8649ebb7b64d7a1fe48f978bc434b789360a3e2bdef1f958cce29556e7dca9b6a1206987ec7e928dba5ee962393e56487ae0351c168ea56b0168c0a208e16e5f60378502a97dd138980bc617732ed37d44d0057034b8a11de235127dfca5cda6d0bd25bf93a8f71dc4cb072aa0856f201188e7c1b94489e32f7e31d5703fbfdeb606ec5af208ef5df1ec84cd0826ba5dae74bbefab5abc4ee3aae8095e58c94fa08430eefe4612e02f167831a0abf30b81d132798793110a5eadd5f2649d460c189561b0b6375f2595d02661067e8411d09580ec00663eeeea1750a335c39dab888f8a38b9b27d7db7c7859eccb361e752cc90a2a402048a9797a80b5a3edf919dc6ae498d05d8e160c34e245220d0bc0ce15273884c3b4d2759282cb0b55b17b1091005f9cd184a7796f8b170e7036d72ece7f58fe136697d96b911da6adad10932541798659fd6d9773f0bba561f04f60aa1e2d41cdb9cd606e863c6c2ef10f53aad0c579a0477552e6b9e02b0520d97126d92831dac5c5c7275e20b339a70abbeb428df100625ced04bcdf2c4a8ca2a061fc28be2fec420dcdd5dc72bb44b9a384ac7f42e7d0fd3022cb3d7f66989552d92f2db0b0471704b9a03dd0581ecb4e05828eabe68e8e8a4c7024d30ce7aa486cf9ce2f0d19a35cceaef239e99f0ba67c66af4c22981f1d53d4479beec83cd86c66cc332cc5e8ff944412882dfddef1c63a1d8e3b364ac67341d9a18a7ddb10c72ace483c362ce6f9a11e93522a4b608d1f85718ec18110eba6ba133c8923d3a2efb67497ba2fd27df6eacf34a4e82e76e15f53e37011c4178b8580c3e072c65fb8b780a0d9956d821f2ac73e9af75e67f644e3f7c6e472e01d6199856571d2285077489c40469d3330a4546d8bc961ff806ba09d369e0bc9a13ac7ca8005da2f94559528d531f9a8f92d14c686d6c55bace257c7a18825403b03d1828cc496b09c21ca663687f4108f5da7a7a5fbf3e51abca284147f4da99356e9c95646f9a2a0e88d501a170f721124d955f317c63488bec2b0abf0c68078cd03be099620afcfc84dbf4a7b54c841b99c5ec6125cc0009ad6f772917722992d3eb510952da862d9813593f5bd4587cf3848584e133267f6ce888baaa59a865d25797ffcc8db5129bb37e4a49d8864cb187a1822fabd26974d09164c9d3f898faa29f1c8a08446fafe691dd692fbe66eb75bb0e21822882ee14d01bc317ca5f6b0434d80f226f6ed5826aa42a20c250897c9bf756089b54745c100a2f04790383c5b3ec8d050290c4a870f408af253568a0b2c69da1bfcb7edd03496ba07c52587f00c9ba65552b1ea288f25efc1c45be110ef22cb5c46ec73357ed92da25ac990583bd9f4853d93ceca92034c01c6bf6b40e73f42e442091346c7eafd5a1dfdab46922500b0e36191e54d45ebb614a624160ff330a3d505d63dd631ca881f9a40d5faf4a11f3c1a5dbaee2d5eadb7dc72fd27cf9e8d9b2cdd45324d92b9dc63ad374aa887be640d0b4f9890fe7a58dc8402ec52aba19de4143e8cb6435ac1ed01b575df03ea8fd41835d6f5ec73002cfc34ba45b4f18ce57c03b19eec8bd9b38f1ddcfc145fc930ecd7fc6daa9c976606edcb15bcfc1cd312dfe1f8a430baf0d3d500824cc8a5849ba327837b32e41fc875396630d100e0134f54171e1376d9e082f56d55571b04c76751f53fd679e8696bfd89d1bc47e1ddefa265f6adba4b88efde1d6c4ea2a136fd853316bf4092eacb2910e73e3f3b822c4db076d964b20c407b0724b5e8ae8daf079c5fa08dacc3521ed77d216f25011552b006f171974712d84cc857d1d4c816b03ec7515173d3440ff32a2f1b85dee66a3403ea4fdbec42e605845bf4c61afc5f3824a651d41cb32c7e76e0f90721ac22b9eceb13974d4546666dc28550135630b15f9d213f1eb0ef96caa5c1ac65012c6325f31f4ad739f52dfe25224795a15808abcaea733c19d430242b0883829fa6819929610130375b4ccca6ebdea60b22e364f4d7d563ab76b2b7766f629f69c002f65bd4d41e0eabd63702111d0222a721130548d069065805949f2a6f00c53aacd25b7a20ac1579ab11c6ad700e5cddd0f22637f903633c4da349edd7d17fd3d2cc6b11ffac9845bd794eaeeaed0b0429df7aceb8b6be06a12ac2eef82581a6768a759475d0ff436daad42bda7130cc2cdf4f43b62dfb2534f49a84b3d7b9ebfcb1ca7682d88cf9f7a243b82df7752b5d172c95a58cef851f9c294c8d921f0113919b2073652f7e3e4d0ae308d374f3622e3734e250b7c61409db583e437a83becfae963e80d499bb18f7ee8c8a9ba9652349601cf3c99c1ac368e73a4535dc403b432295b95590c688ae124eeb09bed7451820e6db163f431fd1fd69da79a19de22f2589f84ceea25d5fa50b2bde0c2a03088e3a14a2ffec6a098be167f5277db0def070bb81830dae69e9443c5f32461bc3447dbd1562acd2ab5597da89ccb73f6f83509d0152fc40f82a5ae41d07e046ddafe0999ba2825f9b7cdfce3db90af0c877ba8ef545d6a00b84ea238b718a99af9524f79ed52313d69cc3adebccb1ec2ee8ddad448a3751faeb727a584f72a340e2f52b00d6a6563dd1a007e42f12c50529210f697e94d02a12a149bc80ecc19871b5e0fe4704ba77b332f8fd5a2ead5d53a5e4fb54a88fd1d0f1b1875312dd9a0dcb70abd2a29cdf6cf4fd1a6f944a8cf329160cd7c13034b02da157325181ccbf9bd8a75058aed22861a525f3ac7b2043e61bdd102ba3348bdd139881eee27e83256734f40aa75b41181ef6743ad84d3ca7abd939341919b782c94e99bc18773cc803ce37bac723ad43a6439f1e2cb021e158c7442888aaf2ebf7d85b5ff3afd48efcc52d256db42c8b00ac1894c7cfa1986278523b9a69fd89ee55e5553f1fefe9f1b540e51194748b57a9f24ab3129cd947f1f348fc0398ce43196199f3d6ec682e3fb72d4e001e1e0c7e60de9a32b62851c467bb90be15e0e9c125c6fe8ad31bd53ef666069fd5f65d390e760f091504507da0652064fb0ce11f8295c04d2c18e20b3653923558f93319d918da171ab1aeab16667d30b5b1137cb365213573e32083067de6855e2e4d55fc7971ae8a83fe5402aa01666cd31a39e4676d2ec6a8af06c44696903c3d258667a32b9af38f75dae371e5eeb2e77a5efd93938203d6a6563072289c5331e2c17b70cd091a9c4f0971ccc76cf1ad7cc09456925a64e847f9ec99c216a240d6a92216a1d34051048ea79813213b415a1915f25912acd1bafcf66fe5e55e520a9aa9850d04381395e10c313a6d7f3bc693d60b6d1cf09ebd1cf0ddc4b7266c416e65c27466225b716bc95a9ed449111c9867a10787398f6f5d565ef6cdd1f94606832de31f2b69aa90646549d4953d3f2a04983922168ca47efde3c0ffbc434060af984c6fee6f840cece1e40fcc99705a86fe951558314c2a0674d9e6770352093a18de1f09bdf6cc325843096c70c2895c4ab943274f73b55762b66f3e9a0dd3220e153a42eb782adcc48d00615cddaca4f48ecc2d2e7c7a957eb28d0e3d74319d48cead79e6d78fea1d7a9d233decf51c69b2f6401570c3edff3f1f35ff7431ec9799936de4574c17bf77b489a504e8932dd348d65d65b4f0ba0b65ba5881b79ecc71617f2b0aa67df86128904987158d3f20cfb3a1da5f8d99271e294b57646559614c57983ec65d4ba6d15563da4b972b0a6ce2f5feaa5509c80bfebc59b71dc5b19cbe242df524ae4f2b34cecaf31b9a9ad733dce6d1e922ff699ee3c8111d9121e69e848d6c568154238d0e9f5faae437577703db8882522beefbf282a64bc37156d30f93a6259e4775b263946bdcd5d45adbafc0fd2c00dc3103d751e81a64e3edfe7f77670ef03a3cbf1871460e08638f931701cd71df9670c537dd8ce4e97ac746c6b04d7087e51dd85d5a094da96cc5b5dc06582501941a69ffcb726e03e56b945c805f20129f84a6e3ebb24e8ff9b9019c77ba1b85b225035e86d9a502b2ed1f017858024abca43242a129674043ce4ccd5b73783081685f3f5a58dd2263a5781427fe409e18f10dd0d265fd0befd67a7e39a025ef537dc5bb6440a4594aeb806b5c8c5150572978680cc97e8478df58479999d0b93835d9b7fe35efc4d8e2d474cb167d84a3654c34d5737b2ee91f5ae299597610b1af9cf0f4a12e50672c8e88832e6da04d8aa4c00a214fff8d34f439d13f5661223069d37e81cd029e31dcc6f62fae8e8dff9a3d1f215098ee9062897aca7a99bb175b3faa9fb4913ecc8d90f162206e73280711c35fbadfab3030583a83243ff1acf5337605c19c263e8b631571c89c03cabba2447832214a25a2be2d6a49325fb94215b8dcbd8134eb57a54c77b9656cac14f39220d82e0456d85269e24719c4e824c58ba9ee056f3a06b567308938511befd1ec332117d293e8aa3c07e7ccf850c73e6d1fb3932523803a88ecc88cdb87780712a9117b7e71daad866715517589d4296f894b3d1dfe41d512c09b186d6d62ad0fb87a6f013987ccc0b266f45c803d961c7b7ac825a0bb45dd9154bdf1d3401b6642cb8349e5936b762f027b8a1d274dab6c8e3949acf8cf244dc7f3c0d9af952ffaf642de4ab799b707c06db35e10df47c25ee16d82b44199d1b49f91e96d33638e1a46c9261327a16360eb12c78662aca88eb86e56c32a551cf2fddf983e8924b9ccbbaba1011c7fb6e1ddcfff93323d555eabf9e96d01f49f0a98c42783f3d9241126e065409487cc6b6e1768e6d7462ded258838f952b4529e76ca01c35232c7e40b42f69751f4bdb6118b05cfd835485ddcaed3bdd0a2652875e5e830b86a5a21e72fe048d77d45555d2b004253a37db7adeb462b40761489ba75977707e29a80e570b2d4d5d63ef0f23fead11d4e6466819543fdf8563af2afcea3845a9b4d7a08995b859ada4b0a34954182a0411dfad4966149296623eadcd0199c467cc8e07dc958d35aad2ddea3e1ecd9081a9390665c57ab0d87417d9d4a2ed46a4ae8ce769448c2a4248e2b18da196113466f396d5f967fc25588e14a654aabf2dbc76f5b28c2c97141aba19aab839073c262731debd1b0a7545134d01f7f2caedd682c7fd55c8bbb228519c6289a68a46f6813dbba226d50d013eda63140f7f116bce11e519852b0aabd86a934ffdb32bea5d5253b3504ac11620a54a97a3733dedd4674e9be2f69cc4f76249b358f0e59e461ccd71f38486cd006777ab54363ee586ffc7e69a096dee32073b4b1f003e050155c4b26205b01d699900c453979096d78792fa2c740aff37e6c47635c5d1b440e2e34aff797dd1c729311a5c74cca124239fe296718cf05d63476713fec0ede1276d8c8e07fbf8a8c91186095afb84720d02600e010e581f6f0aa6af10663133be65da1f154cb8e988fec53d75248e0bb58d120d12e0911d57a1592aeb2d24b6c417e37af03eef7ea05e46b473472af9b0306dc993ea92cc2046564fe8267f67e7fdc156567d14b99ad951605390c7150db92ead2031955967f49258fd822cd81a30ee3c7963e5330267277b8b242d8a2c58c26d0f078daeff420fbfdf42b19cd4bce3a82270c1e35bef135606ed293baaf70aeda47cc075701d2e481cb6478f6eccf5a52e128535c8f706e62dbea4dfc279ac41968779cf23e4ed45daff02dc70dcaa4384b4aa4431c5f7aab23a82af30319d6ecbc5a1b6666f181f8a8f3f7555ddc93700b60afbc668712f920365ceec1a7740c768d855df8fb06a29d803a5da9c1c1929901f45c6d83265b0ffedc8811e019a3ac6bfe43281d0417b87be2501900f680220556cb6da11e5ff943e5e7320c0ce61813ee3a13362ff82e34249104042462b03ecd04510a4d97305d3b68fc95024c02e22aac860753c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
