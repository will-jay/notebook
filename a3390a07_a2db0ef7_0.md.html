<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb909d37cc5492c3bb5b07cd7c4e275675a851621bf05cb73bebaa5f505d2630b6078de6b89e442b0a0505dcd0541fad2072d8bb96bda46895e0f5ec655f3bb252b2f35813c139369986350fec881c4ac01cc61ccce7f78a8654183604187a06ec512220538f26435b4a51316e818b0f2135e28b1c6a78ff63989347ea8a5aae0798699bae695c50144ca5798ae57456fd615cd67e121bc526580b8c99a5aec1775d3f34f515e0c0fb7044c3e6ccb967f51d440192bab177223aea2ba5f68c640b76e09d9ea835b06925858f10d554bc983241b5d4d1a8e92c0751b85f7aad65b962f239ad6f98ccf4ac17f2577c486f83d354e48b7647bbddd8aa47144eb65886f38798a4385dbd05b10a79d7df9637415a254cbb01d6a2c337f354e116ec538b81148329c7094e672867d7b1a7bf116fd85453ce0118955d3539fa200ba04e8c33a2d8cdce463511aa3510483f5bd063c71f8c222426a2c5231ef40bbcbc1a9bf027b1eadb37a42eb5659e3aad3b82ebee8915f0d2e7a0ec81c5bb3880c985a470939b83319affa558bc209fc9ba762a6eb32002a5b095e1013e37f2849ec30265ae988186a3a0c9c7182526cc9272c497dc59ffb8efa2b7bcd2c813f5686b5f4fbf7680b824e28b39b04baea9f84dd965154f40d32d5cb0d619218f75b1b276462f686592f02e11f095c2f36c6391c7d8d93cce3a853b016a5406a7a878d4147482257eda9548c90ffdc432d7921f74f8a9638c204b68b9b4bfbcc8de9de02596e506b468930864d6980ba5e179286af38d0d9961bf935a4410ca2eefdeb8a132328b20a255609fc110a959b3d1a99b64368acbcb4095d12aa39219d0c5e54577ab2b112cfd48c1f9cdf92969c0d5223e05346fdf6775b454f97676576e0fd5135a3c56b4bc53478a7496fc62effd9e85fbd37a0e883bf576b2749c06df9f259051771ffd6b69962facca79645ad6a35396d557127b22d43f5b47efc81b1d421343706581a7ca4a420290d6e8bee393875a31fe69b37c4735393a1e0f2cce93ea1dfff01b2a7e219eda780b30e218f2d56b3eecdb21ef19886603b3de53f0b61438e3d936fca526fd9be9444bc2b1446cb4e5340c5fe0fba61b7d9f2fff50fed4864e4f383279136e53eee4012bbd47586d64ca1cbd3643a2a468ce70c8fa61250b168fb25e079a08607bed7e09e78acaebe7fa67c0d4e89e84c55143d3d3f1a81b1e451900e87843082a00b1f601a0c1802f4446b397c1280c0fc57a8b04a4cc5ba08eee8757cb9179d62b998e7b17e4618f2df4cd82cb767e233c7a9c366b5a67e26cf6f86ac328afae594a56f8922a98383e0cae3947d30a11e7cc21e85e8a988816b6e57631daaf2878b96a1fd918eaeb391b1a1aba1ddee0aef6bb4ef492d009000320dc597f709908131ef1b6d59d96c1f26b934b17308d24fe17afb975c8bbcaa988fa27b3f048a088a56569109c643918082f3ec080bfcfa0ecea38566ba568a66e3bc422ab74c4121a378c6b7dc56ba0c9204f5b170c06ed3978dcd75f7b0b843995612302049375d8985e794bb9e9cdc58dc2b2cd7f76c6475a612cb0b5ed659446e5ce888782149d6c2535c18d9a5ac9d340b5bdf1aaf9f70bf7fee5dfa0f0783c490c06ba5ca6ade2c3a80f7a0a017c38dae78080f1f207015f199a3c084d77fabcdd8698b0b2b6743dc6b454c16c01de9f2c5e8f1f12386611c87a0bb9d78d4158fef9587f56737c40fdf7b7694c4cea67a6e114470cd988b62903f4674ed2a2628cc21c2f0783140b8d44a87977ec7b9ba92dcab71cc94f983d18dc7a93610c47255d8583c91d0257a085b9c5ea5c5cab197b3eb8466c160b31210d6349e6569dde16d6e195f8ec086d226ae4fad1c9db802c682f1a6840d4b341a5779335849b56f507641008124cb04f6c7e492a12ca121d0c4bbd62d48baef37cbfa3aee54b2a8c5ae997b7e47f5e43c710244e5df20f681055e0c1268deeeb61291bca9a398c996bf145e372628bda8aa6caeca7ca714c423896b28c310301396414868e87d356a461048b2c1db3e4626f2c13122d837490fdc0fdaeda872443cc027d874e528860d1a8eddcecd761da1b1d9c45cc0111dccc45f761f8eab14aacd33581b0354291e4df2dcd0e95d0f8adc240ac11eea5ed85110a2cad6a2a18cade1d5172cdc200b34cf9d3982f2550bb5a6f0974f5c9a2fc30c30eaaeb0e9e460324d542b75e597498029dc4d5724273cbb566a126ea58e60d7d0975354c9bf8cdfd9bf13b5a799fa8e267abac1c55517b819050b5bcb163a0f6d91658f370b2f87bdfbde54be4609f1dd661529b0e40c9dbe4d24d57be76c87110ffc130c743616e6e3aa63b0c005a00d55f15eb9e8e12400869f4484278afcf87cb118d4b6fb564a76d61d08afe2f8ffaaf08fd7087b89390ab448c61860f73b134d290231b932473a5425db4e2e83fa5d69a393008a2e2fd93689f62343a3df8148596fae16326ca36874b14986deadbf3462fccb66385d8d2339a79982c687fabcc91376b4622fd8081bf1128d9f815fbda26cd1061f80365de3c8180dc10119a450a52e348f716e259c50fd296a9499e975e05357cf1e7ee02a998a1adaa8d792855fbaac7783dc0f7389c87ff2be04f23a7d0ee8bf47a0da49a8287c971c0e4c1d7f978e15df260b5b79a4caa7444b36a10569428cc96236b5c0ffb29270ed4e3b038ed4631a796fdce6082cac605718ef3f1c91c884899bfc45228d184f31f96053801a2668a5c76b4cedfe9c4404cf71eee709dee650377bc551efa1f8481002d295edad3657ee5b30d865fa1f49a474a18d3f4cf6960149714d60f2ba2359799ac19fccfd1eaed17391a808f32a93e16e8fa9d20748d39e03791f1122119787b79524b1c66b9c10451a13aaf53fe961712a8e56d606c6ab5b09cb04ad26bae822d4030c9faf421914102f1c8680803294806b6e630bd500b8f8c895515bc336b4781c7b1acb52c07f3e349cae78dab4fd78bf97102d4a64ed115d52d1028b66c042b3a7db9793962200190706abf198870fbab77edd22a74628aa2e047b24ea8275194df2badfb881fc4c9919e9136255224948e91e51903e205ceb106e1bc6dda0215053de8a2195c7f60a67d11fc7d7f1a3d54c79553ad7eac39268f2cc79e3c7c3cb0770d10d6167d4c5555cd1d5411e268aed40d36ebefb0f47f8771cfd392c57432e1927563e7ae48e086edf7b37dc0e7bb91d5c8778c076f18e659d2d762b20272385775744b46b119d259bdd263e30473da37ee80b2392c600d5c5b0d3886654d36a28f3bec5afacf85c6bf5f65a61e91a5bf98c50c019c97b0cc10d7302f29604854b8693a435b8a70253e40b59ed6a47ee77db048d5b56c2a909822ad9d2b39fb39411e2ab7c8f70d5a27c7344f74a0eae2053f623c818bcf00fc2b872615cdcf8b96f9339ae85931ec779213c9a9c76bbe6ead396c50f465b3d0bf264b1e5621352ece454e3f732fc1b7d5f938e0702d361f423a14e94f6ce4c23b46eab633846a428210e98dec3812e002eff07df0e6b659208359737771a181f460b29910f6020ae175824086e429719daf6c68bbb97d4369e8da8f623b10e04f7db6058a088fad9aad2ed2880c3a9bccb308fb4539115ac201837988925e0587e7201ebd8e312eab643b7db1d1951be358d91ad3c7a06833037e204477c9e6fc255dbc2216a2e423d36c963383bbbbf13c26874dbc9a26eb007c39f1be3c6f70c9c476c834e780b323883fc027873e604ea55f1f341dd7126514ef5edd233b6ff1990ef45b882a3a5ffcd20170cef345d81dc3ccbd4b977e5f0d314318c785d53811a0141f58cdd9d1b412c39b553612f5ea714ac962af19d0235b49dd986dc4551c17abf26bc6faa00306182ad65aae5d260077e046b97ad4f0a45916aaab0d598fb895c71c06abc304ce07da5b0b04661075e82f689d86dcbea977059b365093ee67c01654e05ac201df9379709a5b1ce65279c002dd39048cd99de2ee6eeee9ba70507571e3cb12cf32ecd797b4dc2559ee74f1b96122ed4f50b924d4d0c769e6cf0bf632aa6aec705a5bb84b99336b589c4bc95c2ea75a40ffdd95ea65675dc4e48194f457643468e55f84686f4b0acda7bc4a3e6c9d2a210a82cd93ffc57d7d82b88f090a666c2e2b72e34e03dcb413f7d56359b6cd6ddda52c22a171276c6e78fa6b5d27c7171f90afd4faa5635ebc2320823d06302aa6fff0f017c18c17df306f8a200ff1ef7ece93cba3fe26010c615b47d70d817e6f02270a0d43b616bc80677261ed6533716e8b77bfb8cf34c196f2bc311c9e11b176a017e9d5f4b50ecb872add55067daca6ee5d1ef5329974f469a8b6cba6a065f204c80d2a9a9118e6b460886b194c0821272f3f41f56c7fff965a004121f610b25546bc53e696260142729bc9dafa0ee325581d0ebe398592c0c12076496c09b523ac174097d237f3974320b92aaa4b02e1efb1e38718bbf19197ac6c3d581dc1ef3eb30d520ea7bc3c893dd830d69a3806423f13a1cc01ae2698be85d17f4669677d3231d3ff4e41308e7da07f0a1f55271fc556d67be038496ab2a052b35fc357acb200d73b1dcef7c8cb2619b127eb3bb2dd42175efb9e160948f54773fb870f652ff361f8ccbffa9dc4c2f4cc09bd8dd5f96ec8aa48a02a33970ba451043ddfd7e77e3a948a903a67678e47d69291d6b4b724ae5905684f1159ca0f95c7d4da58c5e707361488b3dd8293b8a88d7644679379d20e9a294e3adda72298fbc122cfbce5634d0f44c9f8cfae81e5018505ec334437fb6bb139b4b7e71416e847adc8f8e036153d688fe7e9bd9a88cdcef0055cbe6a28709b5048d7dae590e4e916a32789743d73a82fa696b217a35529f8073e65a231a0e0d97d62db36aea1e9572f303d53a23de9a5eb2a8c715e923879385fd8743631c7886d7cead6f284c2e1a4f49703a3e13d71da55fa60e167c59da7a56ee2fe6b75a5e9ebe9e793bff324b840a51a67fcaf5ef6350827e9621afd8547a9780d89b20db4ffeb8f84d1810d6f13891e0f6c15feab61e9a770132ea4b383709745a73d84b619376b459e314e17d96694a4d802653d6954c656d0719a0e6f447520a6ebf569f31de714380afeac46fe53248baf1c1b9444d63409c769e332512bc9bfe59494c5ad64ddd98722b293986f6acbf4c36391bf8ce436b8bfefeaa4c48f81ddbdd526c6e48b4f0744471e93b63b59afccf2c9975a72da0956679fc5cb61375ad69aa7eb7279ed50b66abc32641ab6b5b393e9355561229d7f50d1dd5efdf6b855d520172a12355f13fa76ed96c4c440a1a34831b5177b52a89b9c16f967f5ee45549e3a17330f56e5faab5de291b970ce8c8fd75d27bb665a1890ab3cf9961451da651c11623ed61b9b6960439010f641a054fd59a35be84d854046a7e2a98469c294d6d9262128b04beefbd872f67127f926d39cd9e5208c335f006b32aee011169d4f003d1309987f93fad0076eb08845b1c675e82d01023e3c4be41babafc7185b7d9c916c4da837c6f99a88954ae17204d2cc98708f8ac313991d2721df247226b4bad6d61c5b272b935cc6bf6c184bab03a968e2c84f85c02d06baee709b825073c8ffb9d3b9b3388241bc6ecfadb85a9921b3ad6a19a4b882673f46a71eeb4d2a6dd01d37d5623a7000ed563dd53c7f58794c6b023db98151620e14fa2b8eefa291f4016c5b594551b42cee376f7c1ead5bc1225631429ffb5d7f0a83ab31ab780f5ba76f999571c3986746f3f5f662d811b93d380a01d3948dad8eb8d61fdb363c1d2ee10de4c55325ebd8832ef576a06f45741bbecbf0a06ba8a4a0745f546494f0088c4e4b0b351c7e4d681b80f9346ce3039478ce66d9e78959d6ca4e5ce76a3919e8e49bd341ac050bcbea2a997753c37d1184d51fb06c60eb9a4a537b5e743023e9fd80be9f90a7383288cd9582042d09b38a95c411dbcd285a4d7df30152e5179f78ea60b318eac4dcec8926daca0770ebc6876284d1c309b0b52d11d15ffe46912ecc7820b10f97b901eb2f6c8af2caa75df274f7dc0ff7528fc5b6b0c1e7d195a358a74fe6134c11f39856ff7442f56a39bd1eb4e6641ce77ad4329b527cc869cbb6405bbe80991ac719e5e3a977bedc143f1c40849feeef97a3567787bb74eee7e7c4a9c51f0340978e534edae78014de5aabee66803f8d38416c655a1fe4d86664bb573d06b43bebb0c64afc8923ae4851f2535f68526b22a37be980f3fecaafaf8f3eda8717e8b3545e411fd654ee56252a16b42a9c101e2a12dae552879d01f3bd3a99ddb57c5c62acdc6549faf99e0839f87a7e9340c73e6e75a44b2ee3e2b542b610e4eb54228063e656a7b9ce0b86a8ef183be2e2232ba6c6e0fecebf86a3e193527d2c29fc8c8c5c6c404202a46d478065fe915b12eba628965a1f56d9371ed4b49de73ce9d7152a81ca0d75bafa9bfcadb999b4909f063f463d5a1748d85d6095fe31076b3ad3ad9079b002e6113b11269474fd601d54e520d9cfd1c47333bfd650b3221b58613817c106e750d24e0569fcec46b574a8993c8f35d790413e164c131e1e22f3f8b76993bcc204b26d9d2b73cdda38ab281985c511194464a4768faaf64203c73725f5b5936f5a8205b3ba30c4723cbc41c132cb24678a624efb72b6bcfe33737ce33371dcb6f87c672ab8bf049229f36ea362d1b708e597d58bdede44aaac4750d5c1a00c198c5bc725071be93167ea0033d3fc94a448fce40566234263c4dccdefe3f20857ed4e1b838b7a4d85641b5603c50988d553d93882e50ae705095f5e3a919a397e8bfa2cc7b2bf607754f9280a9e58693071518bbdd518661433dbe65e55976cc1960a64c61cd40ae4baca118fbe555ceb4f7e39ce069b4334986c72eacb2f9f396777256e23ab7fd60d5d4c170e10c1a8ae1b81282b5789113118db982bf280cb7f7bd3d8d6d3155fa659087bbf55bc8998ee46c4cddb3208d8977a5985d006fea3063da4a9890772f33eeceec092fee87382b416bfb3b2755381505030ddf53cabb6097a72599ed73395a37f54317c67879dc659f2897d31e709ad2852704baa60ba2192f86b0bd03d41de6b4142e927f34046dbb56c73f499633a39306cfa7c710c3d6375ea9ba5f90b8296279414c98255139589aa31a51195b1f3047197a359e37de904f6e3de93a77fa2da125040bd4bea0c17a4464f38579f5ba7d4b9cc181593a12ca89a7543bc29226c257f8bae397f04af6943d5de8c0a320eb4bd6ccbb1bba00b3f46d9c69dcaa2b21fdbe196afb6689a65889dc31bafebcc421f1cf7d2dcfec70e8b294615db2d3738ca1c04c1c7696b2e8e780484e1f7d53f87e06a7a5025ab37f895afabef5a9c70603d17bf5731c47363a9680fd396d8977c511eef99770b4af8f6f01e92fb13ed682d55d1e85c1e794073311e372bf1036e3f1d2b1ec6a2cd2bf5e2213ccf1c16eaae97a26115fec8ab3dac93eda20855ce4837a67f44e796fc3acc21d563e1ab1e0ea655f3a1625925edf2f9c9aed6b86e6372592fd3bdc6b49ad7bdd774f8a3a935bce1d4266abc41f83fc96212a6de1086af8f4772a8d03f2d8239b6fb0cd90c50bd69c189db092ad58345f27d0f8f91f0b16a8f881990b50afc8bc4055c2df8aeb9062af5e2f784334abe3fdf23b8c2418eb1df244bf82898e96eaa56a74683b1c787ff5caf65aef4689bb6ed2597f6d6cfeb7c37ce6c1c2934848babdfe90e2a90967d553fec0e56572f41db5b2c18f2e464cfb55bf9bd168cb046d02e630bb22cb42e613fc8f76185616c7acabc3bc5811c30d2ba9181e9c0ca9b845ea8b8ddce4b30e32ecd1cb7bd235ef10b7de3091d5ccb01186658e39df1b4f155ce4c87a8bb60aae7c47bab25265c39414e281de42ddbaa4a75fce9ee1ad9e540cb442366775b3914e6cdffe612728e51e2408d5e316e221dd9ae03f57e49cb9e1a662f2776e9f703b0b22d81b115ee287a5089d12367c47fea5fa7b334db1430d56a788e4f4958d450a0fe177248ec0b3dd1fbcff957b429f13fe978bca15c5801e7ac36f65e130285b81b3111870c23a2610313d8647a0fc5107a2e41257a32dc7ca317d9ce12c6f82dcbad52ff3d23d4965ba6605a26ee877c9cf4c938de8a4c8df06de22ffe584a4d41de744e9b5406de5054c963bc587b104bb7b1cf56eb364b3dfe7562d37e14d260aa796c07d6ea7f52e5e99f3a78b9d71554a5c42348763d1cadb982cf866cad2eb38dd2eccbdbf7bac2dd2abf7ade1daece0af5e2e50ea62858ce42db9b37670ef50216042fa2661af84c54316fa05299238fe024fd8f9deeb1ae4c420df4c9c49906e224743f2aff84f20d25f9c8719dcd23266197ecd0905808cee07f8167580cdbec8e380af03ce11250a00f95b10be899b730fc2ded90fc9201f07c28befca808d6fa7db69d5db5cfaca6939e33981f8e51f80413bb19a246b67a75f791867f36fb0c80a9c3307e59caae286b5e7961fea40706591a7c6115cbef32f6c2759c2531eade2f5bc1df74bad86e25bc00a7d213acf52502394b94e2d0cc23242dae093d3ec9dedcb172107d98cf90b9c3af52d66ecc1b48c5cd6fa39d50660ec51a522d7b37d179f4ed22687572a61470f951433e24114115d073bdb7c51a0d440dcb73000517f64bb5b106aa9a4a5c22a87c6fa21ffd55c44a188074bc3944570a0fa236888683c0d05e5fb97a644d5df18b0a827025496d1c531025ff86bc1eaa69effa39cc2f6a522ce7970bf7f704932b77f240ab8bedbc82a36b1b97f9e610b5371a9295d27310a837cbbe06dcf3ee05c54da2a241ec2a418f8ddbd90484969964aefa8b26031e4ad37268821b9743917f1100025fd11f5872d5645b811be979314107c7de4b285233eda39eeae7972cac6e471bebc439ecdaf74c63d84789cb1e821e29029f43b2fd9d302cd7c7dcdca500e766a2dc7ca9ffc54d125bba38afad8c655afd3b611db170d55ba260d83709ba4b79e290421c239406618ca8cf1e6b9ca23bee827515bd2c77f7f4fc01ebfba7079d3fe34743e10c5dea5ce4806f38de7cfbfe3a21afd62719a90fe81cf5a2379974069367ef33c8c05d0f27cd960f0c9b4226ac4f4de257f5814c97b9668cf67d2f7b72e63fc6bb43f1b95c16fbfcc7b5114f11ae863436ef45c236807a9372a4df3f855875c430787a0a2ed06ac604ebbcc9c7c5dc68964d34c7c3e96234df6aa027dcca273506a9eb944d53cb8917c794028003fd43320ecb86396ecdb47cba6d559c36740ac23a3b95d54985d28c8329193cac53c195d1c3627745515d815f1324e4f5542dcee1681ca74a952b82c4530d0aada7b984cbacefbcff08c8c5d2176a8046a0e11a73c59d18016ffe078b76cc13b3d80f23eca5ba9c66ebd8598befe1cb5b9b3cab7653ad6f8e6b5e029548dbf3dfcdebae8ac80b75d255e82c4b845ca0a7edcf317870fccc18c0bc025da827b8d739c8343d110b201eab1dead2d03bf16d6087a64eb64d2a80bdc2e2f5a47bf0c44dd724a5f066510dadfb42d802608c6a847828233a9bd04066dd960916baec1ef6512faeb6edee87f69f7e03184ca37ca834726540540fa7be24ea300ac10566ddca05147fa43ac87d51ca765ae1b3108ff7255518e8c69d507171380ad24fa7b839e4fc20ed3d3351d38b339f59969b8d33c28ac93f86fab3ff0005229f70f1e2d4360aa1d1de94b9c875379d1f125dba85f20977fc3ad952422ee9c28a793b36e86a566fbf8b9ce747767231153482af4dd6be1d7f8e2c327a2d6e08cbf12ab27bab887be37b52c3a81d8496faf18a99d8899293780a72da84148958b85fb27de04effc8b9aae8c441d53e9b70936a8610ad8d9c163c49d01585fad4da32bc0563fb40d9e976f45435ef8399834820da783f0abe61633f51aac39082f10472f35fe69fe379df6b7c197acfb200754290386fcad8ca21949daf97b797d112970ef1f2d50b6032d4c4f5b92c9d5fd80796bc8ccb0931abcc26022efef3263f5cf65cbd5068eb8e698c9d179a4aeccef70b2962da56f9dbbf886c5a57584f07377126c67a92ec85010c6664dd138fa219d6e31cc371dfdad25b68077e7e3bb6a8fb08d3ced850c974ea85c0f82d956305defa1ba209e2bcaafe5bf077a7f3983023990f92058bbaab7d184e4f8bf06ef39a80dcaeca099c710bb4d5202dce6cf812c3025b50bf3e715a9d27f58723c3688d9161324ff40da42c3df92bd458fa0bd9781d54cf603de86953ad56e33251d2bc2adb204e998bc08f4c6bcbb3fd28e7dd8120e002729818a6022889e596fb6a9e21b3658712c26c56e2c3c8c2e9e0e44d0a85544349087e64bde095d1171770c72cf08f563d19b3879ce9e6715041d62ed3e5f735b475805daba42ce2aac08532c9f04c0fd148fad80c0b3d72f3d4306e387cbd9b9369d3d9060830583f72e89aa90e4d1628f719cd1dee099ea74966e5065ee1df72b531e4766ef86fbc459126da0cbef9aa74096f68b70fc93ee6a7113f4d89a689862a642509da6f21386a50fa9c48bd6c07adeab2e9a1264a7dfb05b5133b24a79d7be4595f4c10b9b9a13be4da5b1a7283db04a3c8008f78dfafaf1a67029b7a52986c60c16293a133a330751d6c484d4a8bcefea459f18a21dd2aec7a44bcac345ffd72147897ba89b1c9f06fb13f357e395f013a91abd81ec4b55fa0b230560c059ade7b5de3048c488848dc06ed5b5de7f1642683550c8abc5b0ca518f5213903f4179c001504702b3901406f3fed7165fcf5bbfe57f88e2545d4206adf3cf4ca7f7ec7c580c292e5b1887eadcc94fddafd00bde807269ab33367baf0eef0a560acd190b59d8f1c287f0e53981a7d7609915456269d02e06791144bbba45ae522ef67b32252de5b000fcf45c12a2ae3495866a6ac15d29494d69f8ac4baf5b421ff4b3d93c0ea84cb5755b8bac5c27fb9ba36d371fe7abb47870978619b0de1212087c0e27266df6893eb0dac195bc261d6f28f9c4bf487127addb6c05bae2766dd286fc2754fbfcb9d59a7e9fd19055f90c37de48526242236b7ef910a779a361879b6a51600bbb22e8ef77cee9d93626118af3d4a142a39d4c37b05469dc7903c3b2c148ca1a7390c2baeebe276997488ca1ba1fa77d3e622d065f44eb686c2442aedc507af46a6fb1e078ab597e5cfb830b25da26f48f521","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
