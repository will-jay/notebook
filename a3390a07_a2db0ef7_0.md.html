<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fa3d1f697a733c305ffcb37c4757e83fed0ac7969e3d5b0e9fd12a073dd7deb239eef535d791e81cf21d41ec352067e0819332df94320f49c25d3ffd8e872bc74c7f93b57000021c4b5f92442a4c902b82164a665621aa484ea7bfba85f3195ec3144f912de3c1b8be8f09436b1551439c40a57cb3cc1bae883c8b8304322e6c831e2c219c7205b6d3e07e71e98cb1da0701893e454334a3f7ff00b80add21bde4f58e68537f7ca36a39068eaff355c468f01596a84277b9ede2a652b0b9ee8b6084f46a23fc06752498085311d2b4f35e59fa7878fddc4ca445a1dd0b0a6c2b0b6bb465b1ee563fe23f356709db436af4ac04e3d81da04dc2adad57351102e2099814ea540994959864c842355443f9f303def9cd21a1a91a7b1b10425cfc6679ee040235bd2c8a86cb8c4c8208caabafa9a11ed3a1d42cf8b48fef7d187443f0f8f0935c791f9b5378b26193af3862f35e166a2a5ecc6bfb0e62a09bee1212ae9a65847224bc41744bd9cde99cae4e3ee36dbe1a4165e12b97e98f69d3e7d5fa2421cb5cc438ddc4f27a1ac747329e3f63f9f45bae6b1d0ddfe1dd06dcd90758bf296c203595a15c299f5c2a8922eda2171eb193180ecf8fb675a0d6df40a9cbc5ada0c9bdbcb9f168ddd0fe03bfc4a97e71734533980eeef2209f6c8dcb0c4c1d73f0723650f6c0629b9ed912ff5b620f32dac89a7ed34e02e21df007a7c7d3b72fbbeed45b7c0b3c76b53a43995ed10b7d85332736182ac2344ab10feaa61d74ae6c5d45896c59882485cef8a211b2aa576cedcf5f61b41949679a9795d263f406d7a35d51b382de3bf576f022e0c6e0997a912d39c98e205ebc3602d71edfa2798d105af9d0b0e244533b6100ffede69c4da8aadb31ed0b1e24807f9afba7c0bd584aa1d464618b1d676d4229cde13f623adbe9b7321ae5eee4a7d0c3c3af0588c816c402cca0136ff7c1e0fad60741ee17342e2fd8c020699961337a5fb3cea0ffa9aed082700403546964b557926a0afa5018d76394a7d9565606b032dfc2d24be351632f3224b2e817c1d430bbbf0605d3fcbb14658a4cf2e308f8bc41f952c0cb833cd576fc40390d09aded410a03bd694701811e637bc835c31db20e5370cb48d326ac9ddf5d1a5d3efc277a1f278a33ff819233f8b1428cac206a95f179c0e6676f981021df29b5ff91d957e4ce2393721bc72ad521f172626bc32a6ea3b68dd7cbb79eb203afc43a4862cdfd08240bd78409a7a6ab2476991408cddfb44dd4f31e644d9dd99e0e22a51bffb1f533652afba81856b2876b67780de96756a1f68916f36e6e11dac3a1353edcb40498db8b0f8688811f39a6cb2377278f5b0aee7309c0b1c0c04e5711a6670b0d1c2ec566f7e4bf62e2df793b12fca81959c5f8033e34c7cd3ddbdf78fa6bd2679fa56ed77a1f594410dc41283abc01c6f331b56cc9af6b830766b386fe1e76c8dc7928a3d79f3ccc99e4374a0644817e79552c000dbfc55f46366fbb2e0a8df6ce5d2f0975aa0d7ef3cdb9d9ee4f98b0b8dfaf771b6b0e81c4a5f16f1fae473f2fb7ab70b22d5a2024f5bf339f794a71fc2618993fa3f90631306fc170c98837ac8b28b3b170361f6433b6e63905f4f7f8715b582913ccfb2854271fdac29e310aba17d94e8667efd9ec134944250e10507af896ef876efa35221bc849e20f463207c3f226804c642f41b6558c695df371a05e8a05b22e68d9012171dd9286496070ddf9662a8242d0b90ed20e2cd684f9e32d5e983c4bbac49cb4b8a221f55925dc6e21369aa6307605a0d8208602d5eabaa7cf93efd11d26c8df62754e87cfc9d3019d7dea87e623291c962464cb0a1159898ad1523fc820d27988212aa9c64daae1df0b7b47d78aac1a56b17a0b5777c546e26491ba450b125ea2cb42cac42f7d785f92146d31cdf8c657ec46df63683e375858a5e10aebb17b8fa6c5043ba5b64f3d107255a17207906bf41c55cafd71934198fdc20b5c1670d2c57a6c5f7b08cde77348589db435a5ab0cbe4475c6580d135cd68236482c874ee281e205e37c2d684b7411e99dd12da2f780abf2fac94d4372930f80c804759ea2ea547cb72837a4fa67e7a015d67833b4a22fabb3098ff92cab50d37577c78f6afac706b46a7a272f186da291921e675973146bc1a19c3673eba0f198fbfa5d24904a86e8e4c142b65b0bfcdc7fd5e9b3d034c3ac43c4b6b125e752c8ece64dd28c05175968f9b38a642032cf4c9d06525a2685255756622bea4b1ff5e5b8914ccc8120ea3743711c82bd645e53c25fc88c04e54e764427b096d685068594af342b46a883891cf7ebe274d8989ee35f0e4b00a37a84615dcf72dee9f76460cdf2a8b2c81810a5d0a9c0b3b9697af92f4f68cb90e8306af70ca2611732f27d579ca251b4c7fdcac33e3382dbf36b103fafe08fa60660e5486c3ffba6633132e43a8009675482925d4134642ad0341634b7c96d47600a16b7dcae4818ed6940c2b232ecead0fb805c1c51f86ee8063e15169ba92229a02992342cb26a63d4ebad07e31707510d03892f326e3a52613e675e93d86facfa300ab861e26259cd910682ac5b97ede67f39b5682702d5f241fd490245c46970eeb9730f21b2a8cfba7abc0c66e1b6c5c993009e21dac2fc1f25b95a595839a181aa62bde85bdb97f6042f1e41cf062a8c3b34c5735496eca12b0566ed7d452d4b5b9f22a4bd4747b51df962211a7eb475b7aff029546d4c6fc04552ba4273e073f2105485dc19af5b80c9ed5c8ac87d3bee9e82a77625c7dfb0de0c5dbbf0f84dd371dd2dabd299a311bb0be1e86fc49e06ae08d8316e316be4a2a7faf4cfb0863e02443da5fe2cdccca436633a7fcbfd1c1ecc180b0955af0438d67880ee2c24780b05b1c440ef7ef9984e7b952d3754eddbf3f6f784ba57343dfb5d175f278dd537c5d20447bc11bd2dbe4de0e1171ac9a0ce021d426f537df2a5443ccef339d343fec5d3dd0715c5ae0b9e6dc59da58ec2659c09235d471ce797cdd06711b90beefe1a2f297daa242f394d5452b29ff2894c91f9c719911e246f875b2a62dbb34b4ccc0d81327ea81804cea8660f738c722d7297baeec814b98264da21daddcd1506e50add0ffce4b4c1bc05c44b00280b57480c979074418a63bba64595cd1ffbff69f569b549fb2373a663049bd3af75503b30441cede43fe4bdc5e7555468767f067a90b36ee67ab9b6ac5d6bb5d501406ab0646a44c763365ec805ebd0bdd1263dea24d1d682f1aae5a0d33b53a9af1ac4432efd89a328b7eb89bc743fa2c6e8e9304dea257f9caba5c95afa2927cb4722a56ece02a5ffad1f832e2a7332e2b0493fe54ce2e1e9c89587ba533dafcee915d50425e0e2e6ede297a95acf1c705500ed7511866c38db4ba40581bdd02f747e93f09fdda59da57ce5bccc4c6c4ddb777852b33e8dbe85e6ab4ec5de4fcaca6bd917dbc50cd24dd09b43901a948ad69063e56c5db36eb51d8ae486bc7dea0d82df91a25bf5cfe4c301ce1d11904f828b42e47a40d1c03bab89237f1711456fd698ce928ac10a87a2bec7f92614d8bea3eeed255d142de9f4d2fb4e172264db44036231819023b6a2950df7f38a8dbab5f214e8b5756d12fcb11359b11c8bf80977056223a7710fd84f1e9bf0f4679f19fdeee3d6ed499402297ae00ba5d62d13c1a8a591c362d0432fb180c9cd787c4f7ceb08d57ad683d6ffdd63f812f2b6834b22443b1c292aa1fca1495f33332f131a460e83600b1660e2950d08fe67ab85ac74e61f01257f0efaa635d8248275f8837bf5c83484e0ec0974a01b282a68f02de5f0d40e64d6e4a7b811e06eb6645cd28766639f9f4ea2a0d63834433f802ad0c075400c0f90b987f140b0d3072a9ebf626b62b5b3ced0f91747bf104a71a03d2cc6e74adb59ae2d08fe3c40a74b5cf0ee13321a38e156fefe248a3afcf4a36dbe4adac7689c6fa70cea09cabdb5cd23efff2cd10b3bdd74e417fedb9cbaaa5db170ac4542d0424881f784ef376e2ec6a8f040c1950e112cc980eab7d637df35ac478c9bc9d361382ce8280dfe3e19c6f712dfde857e956c8da739ab964266edb5b82cb71ea1bb44cdbd6362b5cf8c0627406fc335d1f2c4e57188a96756c998777747e519af8fcb5adbc674840a75b4ecf1d2e652bcf0c1c28143a7f4e1da3087443e628b3b48fccf21edfb03069596a380c728d9d67006a2b24d1eb7f054d08fe12ab766b500307982269ecacb3598924e1f2abacfabd683ef6032b4afce893cdf60bead7fe7f9a608b566edb8126b3b88cce6233ed045ad8ea5815c0f3201e358bb441376b6e2ceac536e0041082d2e6964517d330753b4a4fc7abb4c75b1a870be1a46a9747bc63764e6b1db68be4ace3ef1b09db4146494b48412c4a8d9528e7f38d12eabfd5bbd856e1fd24ef986952db415f331a4d39926de293cd1b159c5f20eba1d290a7b97a9fbd96671c1e77f86c5c541194d603f930b194b882b18053eb8658aa75186568dea71ed295363a38b8dbadcdc292b4b7f0d21a4c5f6d2a16a17af6db6dc87ca3f1cc6edfb668eca6832fe61a64a1008418ef98be8796d1535b61cec99479e0de1076fa8ae5deb81420212268d88f005123aee23d60de0b651f48c12cc677678c05b3f88ef07668468044b8b80dbed3172dd35cc5bf4883a169071a8a56240280a2e5cce75363e0f60c6afbfa2371cedef2f032aefe646ca4c2b4dde6a9135d30a8a894ebd9fc7999ebb13da38eeb7ac9114d693f207b74e219bb0bbb1f05fe2963545bdd03e16d3794dd4243f707bbd613af21a1fb686dfd887011228218d3734670aafe2d9c18f06b3abc9152ca639eb395fa4527cb9a5154efad77a9c069edbe336b25171e796180f2740d8738d6b4381747eecdfa1a0667287c9e603a59dc2b20ccdefa87148c2b5fc8b781c58755fbd87675d1ca04c123fa06927634400dd7fe3880b871665ea8c1c3b9097bd153f87f16c42c1c3e83269cc653623557a6ea4264d1dc401eb916a096a83c39e2201ab104df98379f54ab0a50e38e5aa5e65fcf3adabcd68a9b7ff4c372bb2347590321ab45518737a7d969681c169cfa3145089bb6813fc94acca4162eb8f44be24215056acec0d888581d31add44a3fd0a99bea5b8110ba50b11ed9298e5525b7918ac98931210364f9d1f760470bb37efa1575137587f28460e75101ba1ff7d6ba7487218090d941c953dcfa1af653ac77e564c762ef36ea946884c50878ad069bb4b9a9f426965d19687c55d18719ea3f59efad248e50d2e8bfbc965781c491ede9a1bc681c6739defe7321b47dba41d456ae1429f35e2a994727d8748230d5604f66035012a8697d721c377ff752ad7cdd582bcdc173477ea5021f0c9d5d47f9be77c8799c5ed63f37ad5d1f611710660b26d36f2aa2a944545d8e4fbad132988af27e9d75fd254d48ce8413f99f89805c1c226836e4a6e5e01d51fdfbbec82c740fb5cc9bb788b0fff1cc5f89ab790b137107bc6ccca31b38ab6330bf7622fe8e4d7aa2e1c5e0cd306643faebbf389b91cbc313ea35962f08f1e8078c3f9ac718fc74e56a5a7f2e818e9a73a3260ffb9575edde3dc857a7ca1bb4c838754208d1479f26b0bde324af571d13886e831d4add200cc34c5f8ac1506f33504a837ce1d43580ab89c7be52c41875003266317d4a8686bba064352999a3dff16b565bb3074bb4c2160966f4d50b356291355b723e692300242da05357889510f98ec7564d0322565b82a3ea5e31afc7e2f05ce61af437789a1335aefa391a846e49989c9ef9d7f2f14ff9f25ba2ddc439db7ba35e9027c2e2b0aac25904ce61908d9c30f5d3a6fd824f780c93ff3692f28ae5e5d992ebb1562df078be6772d44a7f4b24185481015b8bc07349f2a5eaeaab91995da6835c1950ece54d47e0b7fec4aff46e1c50407dafa686f4818099d404b49fe83c2bc2004e7312cd1bcfbbffc1a8282ae72ecf2a195ca4d1e417c3ea8f3a8cfa455e522e13b4736f31334d881cb0678eee340013c0e35f7a448cccd76262caac20d0b1c0ce3f6ac3c29c5895f5922c15c90ee8128c356ece6fb4eb9ab7253737de3b127b5756f0fa7877d43d0dd5778f6c70f0c313436b43ae9a6525661c0c7599c8a7ee6ed2b12b371041a700de81d326a44a2a7a90c8f1007117bca54dfe0ea8c02e8a823e4b653af6d68411bacb0267f54e5315afaa93ae64b489e3d793073c31520c446ffcb12599e00f9d34e0d42d99d50cb096ae7c5accb7e5ac935c15f0140a150d70883629cdd3e2bea898a64e7f8a100c7f26ceec9c5fc74ae6204d9370320501b3a81b78732f37f6230db0da9c6bb1ccb78c0bd5cdffe67916ee5436cb0eaf32d65c2b91f5f82d3ab01ac49a9c2da63c3d83264484f0ba6548a016d8c24ea089d45da8100539d22aa2dc663bba6f1daf260918c55626279a599c9eb718355f83b6c889d13b2a47a6b9dea1db5045c785f364edf8524f61e94b2fb7f8d7c78b6f8f718a0ab12d422250fb19368b1c40a731770fc44f41445ae3d9a76b10ccffd1138f2878af7b3ba3118be58e13db34a95dc2b1d8ddea34f67c0a5a354936add163a1b516888806263eb300ca25f5a176f1af328de1b5dadb9dd9391ff61433af4ec4ea5f0f605e2cc285c25f25e8ed389c908032ed8449028ab64f50189ea16fc88e3a43d4990379d9f8952c09290d8131fcd4c03fe1d042b802c79cc133e9b342f80e90e06aa361f5440008a9c0ad62ead69f143ead31884c4c12dae8962d02d2cb35b485cdea33fb159a1ca7f77e30f9f859b43026bb5e694bf7a58a3302faca6f1fb28998e05f848060de6fb8af866b11649b010dedebb38a531764bad9c0826091230be347650bc2e031ed7c7c77772e90dfabd17f48ad05ca58c833e3ca196f68c21cde570a0195a2c2bf542aa5e296854010b978d89793e79c4293e8b631c7978be3c34b38d2f9fbf06d7d82f0841074d519688f1d3e5237e9eb127572b12fa7d9ac1518e463b4f6a423fbbe32c62cab4c4b0cb4780386ab5a9eaf8bc700bcb11b50f9c7efb5e61b331ebecd3bb5d511c89bfd8ef7fccbc145653f7fc56247c93e5a79572834794872ff22ea1234e1d0ed27f6d2658ba616fc27360df4c68d66d95178bd74c94d4a7548dad389293e0c74a8d8404246e91e07396686dff817b4bb786c8070ba614e0082d7eb2db8dbf7eb8d93640e889b268f672e18f8f8fb045424457932bfbbd2b3d9390c8bbd6835bfcf9cb048e11f4c619057b79b89d8b95f423981bcfd80d2c17c97e759e48777b9d5bb24d48ba6dc7af40584037866b9ef898a5f589f795e60d5fe7a4874ceead7f18d60326dbe846d97cfdeb261239975ab6624cd1ab28d1b356cf750b84b70e71b5acc7c9ea30cf789a3ca87806d35635e5feb2696d9c05c5b6bac11b2b85e513758f60726c0fd4a74ef9df1865a929c93ec8394a9e86004c209140f31d20f28fe0e5fa9a7cc5b9b494b814514e5c7dc64e97b03f8344f1b495aa6a764110b27d0609d44260dc815074d845cfcdd00877d1bdc7fceb760cc4c01d83e44afb5dcdcbaa78f29404e7052149463bb44329b68af2bfb7e79e776ae2deb746373368918d5eb6bf3a6d5e4602081c850bbd867e611e66ad60bdda87025cc7cfbf82f162ef02978c9c7ba2edcab5e4e4b30888d620416966506dff3cad3cb097ff6d424df661b44f70c31772910307c8f766574ac55765dc76c305426a80533719b9e2a1297e92021c229fe22287da1bb52be144461db7a720cf7717a027583480d4687c17f507e339099a8adb0cf3865c9674b7a5e8e7b297749a66a85d9efad3dd6003459a0633c9e384d0e96331f29ab454b1407c06f78c7adedc1302bab3866bd7cceaf14379e9802800230ae1390b2350cdd0801b4c9654458786f1a6f79712c49ac286b2d1b756624025c58debde2b49ce554e0ead799d4651492cb05be1c31be6caede634690b74dda5764084b0eb315addd295f89314a3d26b7361fbaa756f87fc184fd7cf5618c9bb70678adc73849b86024998ad7df8f0f6318feb1f252f82827fa505fa5778be1cf21108f3576d048d181a4bf7a9711790379e13685f726d948222e6415189f484b2508daca23277ee1287895fc8a76afe1778ab42db84c9a27bc6e45daa212a38629bd7de439e70f5ea75da5917d8c04c6360a11b88bc2dafe84aae5a0982111865cfebb32864b963525f609c2d814599da045625aea1e465f3099e8cea7f4f74ab04908abe7f93df8cd2c1a7b2cbf4b0c84f7a676caf3c62035f809d91906ae05c43343e0ceb587c94e958a21038708af2a77513645b0c762991ae8130c6caab39f382219485a3a3e1cbb7ad3dd51be253a62950025d5dfd38cdd1df285d044a55db5846f170c7e9235e5d7c7f47b728ae096e1bd2ebe166afad20a58e236a046890cad75e41d0a38790b995ba401710bd09ffc7d913c9716925b63d355cb3bf15d6f3865fe1716bffb17e28c66beca4e08cd294654d8db61473c6082925207b6a7b2565cd0dcc84c861a448035ff8b4a6fd2cecc4ed2f5f5664b3f3cbbba701a6664596bd5fc0bc97216727460aa1f4111cf8a359b556356431198015384eb7a5e410aafec5b6507d8850489f500895e9039c3c926bb0a97bc602ff5447a67389a683b07116f22c96c62bb6c6d911cce4d3114d96a63cf2bc309605b2d82ee2b6f17ff5b924faf4f85c62a71b4077f686a28ace662b0cd6b3019346c6a85f9750a474f493618e4a862f4d1d1913c8f1b3ea0d49699399c80bdf714e188c74fa5f1c92d1a63f9ab66f99de2f103124269c3269108906a4854c189cf57c99ed729b9147725e54fbe162e44d9ea10c8fa501940f860dcaa2fec889785f09621c416a9c91326709516fcecb69a886620ab00c5df75c30bc6ca49559f1a8fd1396dea4b8a48dd2590d0b65ef0dc28934596804d71cda557930ece6cbbc86173abf6b00f5340bb5dcca01572be1db1c9d0e61f96a3c6fa9d0dc9aa7ad9787df7fbdec0fc794962415559641aa6423af23cfbbabcd47f9eaa0cf6276e95fe16ff904be5cb35eb37f296d46063808f696a16a6eaef6fe9f774597cb71b3997ddffda52f4e3568fc160f9cf07a2f253e799dcb0311bd9565da6def42ef90f392d5dd1f4aff45df93a8cf3f15c3607f8e2992ed892a15b26ddd6107a77a188055afab1b18b5569edf14806f0ab88d6beb6be942eb853dd7439d52415b6dec8bbebd7c2722844f6b76c3f11b36aa3ea2b6e371ce8a650abb760bf71e35e5f7607c96a90ec5ddbbd96a40c598a98d53b55de6a031f213857597b23e1723033b106453580dcdc3854fc611226e72681b9a5204af2e3453a55bc0c7422f76e3fdec955ea3f14c71e040cf24bbc33354b7465f81190173cf4efe06c535ac8e9f1568dbd6f9d2887acf741b1730e1ac5dea3047be32074060df01967d0533bf05798af5f5b10d73f1fcf742a466864981e0de0df8130bdf5544cde1dff6f3ae6313cbd6344b2f158fdb45302744dfa85570c3e055c8c72d22f67381d946039c155ef046be85e1d0c5f9535e087d43d0edd454336603d62dd4caf510452de4469e39b59393ab62a01a16038c876e23c3979acadf1b5724b3477fde91f2571dbfc0316db702361bf89ea9f9829484ae1fb6e2db0cc6eee00570d85d88791a362f30c6f11639db6d698b3c37a3e8537618fdf566932cd6140b7465631a045c137cb0faf2dcdc60a4da5a5d7fc8d3165018f4def9b1590666eec85c040ce88715e4440f4516faee7622fe1bb54272bbaeab19f6d2f463623c56ba22f81bae42782fa85107e681d2b0d842dc77d716e4c2ce8030e135d1717b770eb7e8fb414ddfdc255650eb8687378a35805b3596eb9496dfeaf8454180cc219f944afc2191b5b4d0515e5518841c13bce7c5cafe910b0f2db86a2ff1f659dca03c87eaa9b570c2fb91f8fc5d13600d583f06c84a0895efe4e36a8b09061fcc7b54bda2cfbc9ba8b0fa5fce7ce39bca3f36741e0681e380e3e813ab6d4697fc56b69b7dfa93854d70b9eebf27f4f86cc0fc6de45759584e3d13698e81764145caf9f0ca608e433cc7f8fa39bd954c295133b4e08f5b260f7896ce1d1a3d94fffd779ca669ff8c78a6a4eff015631dd58122315cd7198265845a126d800ceecf1d9d0c5ec689cfa559b410fe042cbd35ceac020c6b3636bc0f93d54c7a31fd53ec4a9f75af24b006162cd27cec12ee0f80766b8e940cb58ecc3dfc22d523ef9331ff33d55d5c98baa8b22b9fe92474856eac7976381c612f1d22ba6394ba3a1c9b298496831ad538e6757d3e1754ffe9ddc7b5c06ebefa67e55ed32cebcc18d35afa39d6fdcbf3d1e4c8d6ccb38cc7cc6c97d1318ffe29d57b780530bd6cb9cab3ac0e146e8af1c4db63696168e33e96df115e72f7c80ea485313c3ab7c7d4b34e4e9b3916bad858d55886e647c21253801f8c7ab04eddc80311f8450e1a0acb51496bb673df7702058e9429558218752b860e1335da5c2eced621df6b297d73274550e42f6aabebc2881ff15f86fd4156c9ea2ed37a55ce27b4ff34fa44915e3095405d4c449ed2a6bbc54ba798c8e718a1ca5414f1ea22fd0ec18d40c56dfe5644da94a47f4b8724d44c74afbe2f022fa0914e0eff53ee073604f486d087d89aaaf5b31c11be9ab11cfeea891ef616a6aec543066a0c9d4ad812898cb2f65bf1f244f2499f7c9f16c18184af62998e44439d5212ff107950f751915658b51cd0c7f2482136d13d672cb95485016a2b8305b225db16629274549b873ea99b470e67da6666911c79176d639521dd011d50fb389522ec8fbe5c2ceffa9ee2c2b5422e3cc94ef520de6ba343fd032130c748b9fcc3240bf8090a70b33c2913243c9e93bedd1486c6c565cd30f28df65691388e07e30f2e241f9d1845d0890a565fd3813f998e93b2ed88c8730148eb03f2ed7633ffd8179659136535b1a0e22832ef88d774ba1fe64326e8a2b8e8ae651b360b06cab511e735446299b13d49fa899e9539f0af368a5e7343b8aa2600c2192f3813a65c238cd00161929aee68011ff2fa22ff2196ad599df0f765fd371d73d88782b3a8c016827988a7ac11bab65d630cef2f5a0b09dab62364ca64ffbe0a74e1cd59ad154b2acf5b4420c4bf43b96a99c038bcc77f12b174606a0c654391d07b828d200","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
