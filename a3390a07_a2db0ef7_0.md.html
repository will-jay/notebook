<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9fdc3b7d46c5cbb984952e1203ec00784f874ebca7d05e6e90d1bf6d048c650eb2d67504cbf5e7fcca8e229ce722eca041397f4d8ffa042f51535351e787c6f06608ddd09400be5e80a4946a766d4cf898a5d2fd2d515824e2712ee5c6064d931075e7240dc56b1df3b6f258c07768c009a718e762f4342d9574356d13758b0514bca21b27535052be7bc77606db55a8d372c5bba362a8b51a9768599b171fcc5daddc7e7e66dbfc9150a46f150c825389487cf9b4e59a368b2f3e1e4b2aec5f86bc9a011eb23047fc709e8cbf3044229e73c2e16a09bef84585f2611db7ee4aadb96fe7d4039d395f68018f37b08b9946c904024e1cb062201deba89d5c235b1a5c502d3d1624f53550428af5399191e388a232ed226db6a7fbb5810058c9571f466b103eed4bd86c407574ef09e446535f5afb2f8b736edbf47429e74e0f2abc32ee95508c818b9a9a29abc0a470a7a3b91306285efacf40ed373bfec95481f3a0cea5e7bd7d8649eeffc2147ca176cc252ea3b7ac949fb3fef8e567f24c7606a419532768151d72bf5d3437d9bac93632845bfdb2a651809d18a72a05d7fdd3b3fad8ffed860aaffe7a4c8caa82b29acd6b3c66adeb2a740da09703a81d563154769927ea478eb3afbf544f6a8dc62a02e07da488b08ff10a64a034030189f5641de2cb2f8834324a1b74eecf33bc3736dde0f0626f4f9287bfb37e6731fe431d23ed3feedc7dc2f57d5524ff50b4aa9007dbdf9f336dece25fb2ef284c5965d5e497f3a05165f6c45b14dbe3f8ec20f7b6ab55152170e04017db53a233d58810cc5621c60197324e8ccae46ae55a70ca3d923b9d3cc2158d6b042abebe368ac59e2df442bce802a758c0eb472b1d8626135850cdd0a24f30b3b11f30d2956989b2bc8a5a0f4051dc0e0181e4757d3caa5f91c7dc8ab8dd34fbf3f36db576de15bed9cb8e68d62d1c8299ca2b18873fde8e4a98767820a2cb035fc8f7734b314893e13258214264a25d079c7181aa570b42df19a67babbdd94ef6101e24e6e4763e3d7d5db7c0e26ea7ab5e15a06491f5f2173f6944e2b51f49bfdd3f201c890db97a039407cb2f6c2bdd4dc4751e642b635a53d7f5af420adb208d0dbcc41b8d2c48bba20d171d59da3d770f1f16d589c8b5e1bf4b21b5d6d77078c58b70c24d84a702268d088b57f786e21ce78e0f45882b19aabfde8a7a46ad4449ee29bb3a8c8c745a287f06389cf6bac76630d5fd82fa07cbf50a4f5568d5fc97099673af127eb493caabe95ed4b9bb15b4b10f4ebffd95ae570dca2c37d08ef0c6b1689ac2b1e506a45696ccbeed5e6923904e475aa6884488f45d883bb8a70611bcd92f01ab13abb558335ce0815561cf23d4f368486fae1466f3b0509f9010bfc2945d3d60a24153e2292d36aae92da680393ed54874e867d05ac76bfae85c5cf4ec8dbb94b7dc2ff43fcfa9439638df5e4bd8c7bed88a3ad9706cb9c316b3ad4b79ccd3e5f0a7c1c6e048a6e893b105517da49cdfb52d0d568e1fa0da4ec3525f575ea9a8bd32a7ba66229e141053b3783d48917dd80b500d8e1199875b85ba729af6304ad0555383f077944286fff7e23ed0d43d64dfc3db8f5b7c2c3bfe5a89aa79c73a7dc39e2424e34257f631501b0ddccfe1c47ac2d2d9f6eb50a0ca7b7fecfc1170b3d124647d2dd66b040a92070be07158ac003c49d3adc75a6c20dca9378eadf67753bd454b7ab0c46e3bb9abe326432f9fa0c4c6a21821e029ec399226f77e15e95fdbbc7ac5169e3baf16fffa80d1a8e15f3cfc97b5691de07c49b8b4d42033e4326030748a6b009e678bde652df3f90f7d46a7095f67ed4c29eae47c5fb3d2a8595e1622aefb45567b968f5997d28919f4e39b4aea0ea53eba185d7b69c0def6b649f4f841b0a90c69dacaa2fa4518fbc041ba978a69e77119cd47acfebd5991999851dd14fa9f10c9a9270da70b3c11e656fb605c066e5d869e74d073795f2a508601c44fa637a940befad62b4ff3d0f49123e5117cb7510af94756ace77a23f4f6f4fa9de0b82ad72d5a7749069b8fe4217592788575dd7ca9d210d6ac46cf8e9412a598d296f8337c0994a9c388681a3b20d65e9750825ad36c1cc3b251a226d9168a02b9df277ae92d0af284940ca3783a964ddde3bbcd02a7c3db2e819fec0d04877b972fa1c0934b4ab4467fa59e4894486c928c8f10e21eee610d22c5347247983efe7f42e7c98130c47c6e85deb0718203b6b1e7deb18406a0a4d1c9aaf251b92edf2cdfdff6e54dd51d4b4fc909597d815c87def57881ef4dc230a447f3139a93410a5991b9778c89f50f265c65e90654178bcec4585f9d3a2f8f8e6659d5d71c984be0ac571e65de72e4a73c9889db806e69fdda9dabef14e246dfedc13c3bc5c724d93eb611a618c95b672ae69f6f5750c76be58227d54cea64ee6afadadf82e8c2c5e57b7e709fccfbe9fe473692f1b783a6337cb104a470d45e93591571c5f13ec9c0616823c6d31cda16ec5fe7a8a43ba95b9f7784c5931ee0771400de8b787f6342406a68d8cb2bdc0b3490def979949a791a591660e3eda920454134e72d7251f7dcf887690f66c9d67ad1056a4e77e19d355e30fbf5965caee1c251254b1b2b96daff8d03d3dddee6e64c6fb203bd3e5037b1c2bc5141e7a46dfae7dfcbe3d1a047329931da712e960656a92f7e5335e768ee6dcf6698df3cbcfe78ea3d638884ece905f02d99cea696a67d48902053fbcda37734c3d94683e34a6b1e3a07f6f5464c7218745367ab5af06599cf37168b8d7b24acc198bda1d5252e89897693e5302dbf81d60346b67bde2fa2330698a0b7f2f63d8877b7e626b4f800ccb2e2c02bc497ad94177c27a2bd40da02218422d8a71eb2bf9649ca77462832ac747b2a934a97a7f5947de6036b5f8b6ab50b322d3103130e2e0cbeb2a886da0c4c44fe259557c7c7d29445f983ac83c5904de18b39abf6db1a12b6a4b4193bc60024a59be5c208447473e8e21f63d680b1edb92c2c248b56cfcfe12da1f9d8df8a5677bd566366b29792bd67df3e0587c346f222664d16df599c09a3c603585aef1e89ef3c4af5c0bce9468bf963bd29c4dd104b8241560b4633e62830bf2158a9c0387158bf1b7734969d3972dc1984b04e9a344d4d0cc6f45c310fa7d22d76b9ca37e39c899c7c7694a212da877baaadaf774b948aa8f9b3af6b36c56c338063c805d0789b145c7c466077494b8ef16c38cd7af3ee690d7ac31a63cafdc1983f8e6b25c2980592865fc2585fba243307ae2c737d8bdcf61da8dfbb4b1283587a4e30874773d893a0210088215b063d96f6133099ff8558e674a928f4a84bc5b0d60b3850db17534c40c1df88e6594cc03942521627be0534a76054c6ecd64fa5e85215048526c9983609b31a87566b2cba2dbb18b642fbabb4cf98e76625856ea1786408564159c194ca4dec39fcf360829ceededc8f80b79d5e60b1c3fc3081e9dfe4efc5df0a85afda8b7a5ea4e496d165a2db5777023dd9a7f7cacdbd0f0940bea21e54abe9e676a0802264d0ac77b3a029412499e874f23fd186ba1cf8a3f5695786a970912cd472451297b819279f60572121e2a96a98d722b6ca7fbf24039a5e701528e69ef6f493b8003088ff0b8aef007d37b4ab9b598affc8fa002f2554c25e685162fd7cd0fa59df944744520ca02c5c3074b5b45d92cc76b09b0dffd60336f2e1616e67e7beb3c762d1c9470ecc6554fa1d6f71b3061ddeddc9efbc9b63c498d74fa8aca50e93e47e244fb0d2a403f034929e44f2e338c6f1c9ef7d3d8c2f944f8c8b7db96cda9cd5ce52b6b5696a0b9a1b8d75b0c63a1668dfd3100b28a323dbdc1f240adf71e51fed98d5dc8e93b1fde98b775a152585934768128ad6fd578666d427d2e87becdf67be6231a0e6cadb4a2b30df9ef472735b96f1db18c4e52d5d5716b3842ddd5ff557ecc9dd58db1b74c6217ca91670c7681fb6026f9b5f6b6fc8042b9afce86154f40ab6c831b649e74c0a3ae1b0ae231e82665abe740cbf064f8019ed80edd3258a25ea416939eb80fa84f627a2b6124f5982a384dea78eb5d52f781257ce98176090de20b016fc18363b613f6aca28b3d426a192098a1b503ba0725a741ecc100a6238e7548759c501917dffb26f3d75fe6b3be64167b33106f0ea7a28c6b9e8a0cee32b20001dc942ad663582ed27036f573f116ace6c8940a8e9cfc2a3f24493f639e3c0667dc3c3e846c20f5b58a36374fea1e3123db25aae9108461f97d64f7a917d73e8d9c84cecc032f974880384c7fc3d0a3da34ec48fecc5ca4b3dad7cbd46a358634c825babe77df0ed9fbd622524c23485a4a3a36ac87bcb04c1761956dc1ce45fa01d1d286e804b223b80b456247c0c78353a38153e59685d50b3a41eb7e28267d30acafc5aabdc4db45712edb558076faae5feeee3fb970c552d3a32d5bb98aaeacb6e40a040d3f7e95f43d1135e60fc2f1ec4885a5ab406b5f0e31037b4af1235ab0f8aede20503324a54be5b254819e8adc398e92402410dc52a1864fc56bb604a828b05ab9469e44961725143890d97852c8eba72243bbce73001c34cf85e9ff02b124656784727f78391eafe050075d789abe584168b736c4c8ccb76012f32478b7d85b7640aeb464a5d7aa45c343bdeb60f8583f3d2573508e7de7f61c41dee3bba4dae191c8528b2fbb9557789eab560e3cbffe2f712166e3f58e089cf7a3d6eb96bcd251b11c18d2e106a9d671862664a939a0a8ff4d40f77669d8f14ed9b658ec6df1a10f97ef1794a2fdbec503a888ac233825d715c9cf2abb02f81562dbf628f359fd9110cd832bbbaf84083508e038993bdd600c3127c26243cbc47653ec9e2e6412a5469f3aa90c83713099f38d4c34634e99a02be990b099141532a7acd630213d0a5f3eca709b82600b9dbad7f31268016c79761040f1af1be8ae87fa459d5b624412f1d53c4952601d307ab4ee5cdb3a7a74dc54531817c8b8b2eef2bd59a268f1ef7071f1a21a968c68618d2648adb16ba881964638e5c3f4fe73bee8f01275b510c35b578fd4dce33487a6c5619290997b930ff87ec101fbb6e3077a793711c49f1ee5db8d48aee9206c89a81d35ef8acc1fe251dabf7484fb9c598ac2ae3a30952bc9560f5c5e3f0248734efc010d7bc418623a6af5c84864d7716eda2e01af2d64642b4c2b02077a1930eb020e14e30724c9a41aae4c11f8be267ca27227345c66367459316db3abeda5808e365a94d191d2caed90e4643fd1405ecd88cb14ebdede33e5e4c056f589f6f1e231541e6c322807284c7fc965c56146eb5c639fe9d45fdabee2bd80f13d6514da600ab0219b827e0695ccc897a8938e867c7313582f59efcee29597eb3160770dc1f5ed4449473753623d585ba3a543a164bb76fb9bfd8d12c71d4a9c03cee0637e82a675473b21d74bd41b08e7b6e6a4807ef7a7e58ae41e7a84d52414ef8ffb6c687fcdae95b2e38846b1547a83df72bad139d5cded3fa832962cc17763ae1281b13176b63b97536c352c72588464f7373fb8cef25219575506fdd2c11f793b806aa0bd9f07eed9ae469a2f07afaaabb2fd50e6ecc51daa1526c031f609c27d618ecf52fb2746fa8e9b4235fbe520731e6c0af461e10fc006c2436882c43d71d8685ff01cecab4e50c8d2a0b6efb2b4fb7b36fa3d50706dea632612ed8c9670802abb74d871fff8f2d5cb544c37c31fc09e0dfd2383dcb0cdfa4247e02f0d9aa521df806234aa04226f9996ce46c0e58653672b2f861d9f92ad7f933e0f6fea9cbf378aec70c88e0a5f8a9ac42b28f853274172112f26272d2aea5ae851318fcd4b8ac8f36c9827093ad3c7f7e84b4f8753549df3d7f83083984b79cf1c52354f34c3ae8447046b971724eaec5aad0bfd186addc0c134df6a3e84f776d299d8c019cedcba930b441aa1f26c396630914541ab8b3161e595dc3ef6e195d306b7e9c4b8153f6c4ae744baad15ee9ccd6fe5bd874cc2fb7b23c526a69b548bd4b8a2eb902be68e8665314e658b617d4d6207ee7be2f1e4535aca60243de836fa1583216a045e87d19da65444fa7ec88986ecace0110edf2e9646bd6cf1e1654592cf7faeb744b3d4fbc55ece2641ca5d4007cd9a1c9e6693584e3fd712dcdd901fadc506086c37a1cc0bd0e35add81457369593ba361582b0e80d2014a8c1614b565f24fc2057ba5f6b5f83272800818e344e1eb0a5704b3e4709b6863296693ea7700df5ec3d483922cda7c15b26388ce48d1adf357fbd046a0c503b8505104db3a8a9ace00481dad8219bd9db5ae642003b2f71e265a6552cf76a46d55b0b5be3bd4a6aba4f403a5dd7a190fc5a5a844c1ddad0a4ce0b5451d489bf01c213316d0bdcbc2684a50e27b71106c3c6ccad3e093447af1dccf6b9c9182a4404a2b1b69d8b52fbffb472544675132a1edfd80e5350feddad031173fb2be177e6cc83fe1d5fb5f59899e61d3afe0160620b28bba201a7118ab336071359ece3a2a41207dec962d550a0830c5a4baf76e63a05bebeb715a5a1811905d8270331b6426f671fd37687f805aed1e8ddff0c67ecb61f9486803908a1b69418bb66f43e708fb855a7c8ec2d661329b7bbd3f21f42764221a7471c79027dc108aa059ab12b77385ced69d5e5037aceb20e7c3c252447c1f94298832e4d53ef9378eab3215dbc4ab1e6f92dbebb9daff37ee71619ed599ff38d9cc19e222edd15a2f06e1861613bd2fcecc7bd25f35bcef0c03703fdbf42fb6407eecf0dd440288c0657d5acace3e7f34173c9e8e6ff9340a18b7ec1e91c47ce00c71c97b3480af1174b7e0e87a6404fc625a3a171d9996b3fe8858e2a6700e58fccd9de014c281e518a9720c854bd32e85afcde94c96cba4cf6ee921447564e7a910f51791beceed7f36337ebe27c64877a80e09a83a6ac42da494bf45ebff3d8388d316fcaa7887e1eba0ed3fcf15584675ae39a284b61121f4e52406184f85a06981bfe27216d74d219c65caad66ca38f58a6e08e7bebac5bedbdff8f053b960e28a67eea97813ae65acbbb59b62edd6973cb68a133075d490e31ae5fbce26b0fba730bfe2d0f1234d879213d83fd17630325d1ec1bdb9e796784806b72410f8832373feb4bd00ab9d1f749d539db69f91e7aff8128ee3e6dfc6d2bb7cb25681d52a875ff598e7bcb376788b5b1ac81303fd2a88d3e51e72bafb7fde79d1323fb0adf8ba7cb742bb8ec35fdeb964a3c9fc67bbf84243078193ce90444c9b82765ee336a775f9f30903b39064670e44870cac4171836ab19535882b028f6157af098461801d1b7febc6cdc953aef4fa34d1091dc6305f0b058d057d4814565ee5f0c04ac8283054f38cda019377248d21347ce3becef77a8b37f1dd0d495f3c7dc1f485a72358ab67a312ba51f97b9fd56d97ca024ba7e548948904c6bfb473558b4a9687e1e9e21e93ddc9811ef137c78d0116970392ec3aeda8e094a445b179dfd54a767ba33e9c06828c3fc61274b194620993086465c38455d67de6377786d3bccf076ce5bb860108e80f45a88dcb677ef5bb401b6360511a59e85629bfa5f07f66ac37bb8b1664dec900f40a6dffe9a6b43bf11a4c0c861fd873035e1716ce5a6f1056c45ca0ea126446983c74c326433141ae21103b237187045970a2eb43806473f04bbe6210793cde05c681c313d76fc96bc13124cc9a44b291ad59ca06348baf080838c04f24fb7fcd53b8ebbbe74ccbb389c8ea178ff856ff2107301e241986a2373c9490fe72f0d8dc27aa418c0e6669a4b199c64985aaee455718a45f9a7e76e389c46cdebbdc3b4edef12c1afb84e2011d8872b13d90a32f91c38856b589e01565777d611389639e8e878c7321a933238945461563b4a6e76c3581737c766aea25cff5bd06265bf2ae86309d470d7225e69adee7bfd717a2cce06bedfe73e5843841a7bd196685ff093096eaec2a8cc1f59dc444012058ab37ea0d66e7e1ba3499ab0c71c838b15bc81e6b28d82b59e90c62346b41784899403d1b73d5fec7f52166844198e7baf806cbcc9ec591636173040b849693f272505a8868d47e2351b46b7de3f77ede47d7c5168c3e013c13a301609601a788ad4d3c33deb4d9d9a677dc16174307385b3da25d9896dcbb3faf4301a770a3beafed22131eeeeaf46d2ab5fed3b9e4eb7040e4d8b7ce3d2d49a20d468265eb6e416f43c6c0241dd4221a44e72b85e90b90d84e955c4035a099e1d2b9dc22b1c593c9f708d9568b6288aebfe157370fe19be82ff1ad47318112b74fe56e557da8d0b0fb3d060cf5291a5cb80968474ddb04ce975557faf9e34c19e5e9b66a226ac4386bc91712e9aca04553713b0aa720c3a49a5e9db9b61592d0965df2bd8b51b73d371804f5486331e82ff99cb6a44f336d182d4d81f664e6e5f797e7ebcdf835dd475e27df96a4b3197a682976834036d1f6cb8c096e5eb2677064b1ac99b5a0af917d8be2a9fd2818ffbc4a12e14aaa76c0d5a0853eb78f26f323fd530e2e153cad66dd19e957470016c6b45581824e2ea164597cdfc25a9f0bc97d98e198a493dd9de2cc26b9cd69943fd525cbc5d87ea568db255eee1db1ae2ea7630296ef057214c34b7382bdd0e3bd5a2c5ba73b13190a75ddae7d8fc6f489555615d45d80c9ca0bfb84c8686521a27815c5261196c4fc9c47bc57769bca580a42dabe7d8dc916ced035e4d053ea792dc211d8ce7f753aa271d8718237aeb4385eac3450357ca5051dc94eeec11de97766e1027fca0074127c4557cd74fe759bb69e69e3f6f103ed1507e5850ef8ac75d682a1d9a3989544af2078768fcbb66e5409a0aa43889a0d171afc83267f722f94b407302bb02ac17ccf5d515a0813ca7af85c2ca85d3ebcb061eb1ff3929f395eff988cb2490e528837f9378cfb01ae4570127f0566c08ddce7827462826bd347840ab641eb7f203227c91c4d54239d68db09299146edcfb52c6c00b8132c6f2919b64742260e67eac8e17ba7cfe545f3a46df58bcddf46f7c8e505e8f1f1850a55e013d476e46603eff51531618481f57b24ea098dafdd333a235133713052bdabf86c6bbe7784366aebd43fbf7b9ae21d912b3d29800c3bfefbb60920a0346948ec77b7cb6fe479c4d0554e154f88e5e0c50e90e0d4ec2601177e56282bb772900838e912c5e949a180e20464ac745124532b2a7e906ce4faed755ee317f773e8c689acca8c7b171e78416f9843a30d6f13fdc017695a509fbf186b5acf47604eb63859c77a445816eee64b670872b83bdd9d97eacd8e12ae2676351b7c2bce720c1a0d3fc5bf94c2e4419fbbf67efdccec14661ed39b697e2951c95ac2e4e8676739be8a27995f9e97c68508dd4b75d73a02b2d4c064f6d1fa4e7c00d7964baff8c3d88952a4f99e8937f25c0821c0484e1f28204fcbdd239d4612478122588440def6050eff53896dcd20d400e35ef4a9f1e5211e8c13df11729e1bacbfce6890eadb894b77da5bdfb9818e66c00c185686eb4871c24fdacf23665c6851fe651a96466224ee41622b850fd7fd86fc9b2969d61af19fea63a6a3da14f55097e17663a8bc479a0c11671f28bf6105004cfd1cb2608c804e268538c3f9c72d7e821b1971444dce28d9f7fd8868499848a9b887d95b96d75161731fc0e4011178fe017e61f4fddfe7ec1af82d165229a74858a313e6178b40f722a1da0eec0efe4354de5594f87ca1f2711d258c3bb903c54cc4c78bae4c7f653e6f6d7fdb643404175450b052ead815e6da3a6a8d12a1ba5157989e3652859bd35b65941fbf46557f1857ab3590c8077830366b1cc8f1d7153d98e15fd7960bfdc1754c44515dcf284adb67654bcdf52378227b0d29f2faa65e99fe82c92042b804015d47d8c95ea4458c4d9a117b7e5b7fce5c4b96b8af27c7fb5f5b8a02792a1fc97c1f4c90c2c123ea9aac110f6fd965ef1a2e489086f0f6f7063901989ee4b08f7e43f4ade6e6733d71e72e62c9409132ce4636e3d7a729ede8292329d0875345c2247854e198294cd3ab5a35fa585d6df98c1492ee0317cb7db26e448007eb3ffd8a224dea97ed3237d8d05ec5b54db6fb969422384684a350384e2d68315dab64eba0ba0ee23a1415d3e10457d02c6ec8e4419a5912fbdf4c22d96d65c58389b774b4fc14123ce795c9920c3a1fe60fe3926c30c4b207976e9204c85602cb8721a63d09669dddb439097c80c330d652785a279514140269fd03f007406598bf677a991882af5b625f48a190b7ffa8d85a47dc6b82348d96243a2c90459b1a16148098da3ab0b09a689286dc9df2f9912749afebf9019c3c1aa5f8fef33b8074106c68d81c064a3c2762a29d695bc9eef66a864dc33a74d9941beac85d7e82da7f0d4070a85df057cd41bec9072b3a41d89b60d5268273937559044630be42d027b87b489454b1457e006032cbb9f82c10095a53d41b5a130e81a607151259d0384195591b0c454b1068852db65e72ca1897098b4656c774306a89ae96d3de910347ba0ea34a2a6e0703534b6bd97b883ca14d128e69f98d6ec18635ead31e37c654addb2ba817679acb543a131e1c5d108a4a3f1da9419aa9fbb477a57a21c23b0b1e4867472a82708f374077bb45867997b558a0925ef7ee13d1ecfbf619689c48dde73376512c2467d8c1ff00e7481d484606038c01bfcb30abce945b30c140af76f0dfa278041cc62b6bd070a60c5487e6c35ace4bc794649b5bfba2a3d4848a4345f6bb72a5673edbbbc09982844542e5f49f499b5f270b9b862d8f1ffc688826bd4f272128fb198af3dbe99a62fc2fcb55496a3689ea5114406fa5fcdb9aae58332d0e37c1eda9c80d3903c585e9fa0fe71ee54a69df9ad63b4a75503590f248f9dceec07d4e3b83d24c5c92ac98b32f232ea8b45bb170cee28201fbd950c6a513dfb55c03d33d6d7be0dcfa01abc68698a9162be6445024aff68f2bfaf60cbac272ec6e2d59cfea9dbcbe54d543a966217087689fea2933eb00eed61bee3fd1bf9a0cf8e3a9c078a1d1282635995350cd163a05a97f907206620f66ed36be89727f801d8592628c0f8c2550b26421b3fc122df4a7b45d31355f8f8dff80d7da48ad40a6f03914010d484ca79dc52d5c3854cb64318f482a09571a27e6ee0da9b48d6a26bed930f105ff5bddf5fead363fb26489f85ec0fcf0378e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
