<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e5b485ac563808caa9c64d5727f3d3be60a9165bdd058a875b2d43b50204c4169f0e1de127cc80e54105bb6828e997e5b6794abdebaff451845a6a1b45762a3af63203b362eb9bebcf23d0051f9e5d43d479af896704d5de2d2b1cef04ba14cdbe0d6d611cb30e81d829baea6bea0a5005058ea2bd9be40ff5a758e108de960af0b9ce0f85d46f510a7fc969da6c3d7a256eac5c417dbf8da1f8da3bdf37d537d6b8aceb282b4aba8fdc0477802793423b6b32bfe4ae2282b5bdbe01ba532082f1e24d7e49c05faf337278e3c38f2f162a38eb65f43b674db8b89a9dfc6af4ce0d72a896ae46926aee36e89362b89a59113bd5454b914aee8e93db40ddca0606b3b2f7d50d25b5948286793e01fdc908cdfed60f55e5d1e024669dc556a8cc35a7fe59d52d1fdc377f657cb34e8da912634da12b64c66ca1444b647bf0e29b6c96d73ce69c357c49fe7acf57706a846aaf6bd9e452bb8ecb8cf52fc51de70f3dff4bb8be38682cc5fa47bb5e6bcd1f66362d0d817d41d5fcc4191e70e121d8ed4d04f55fe61d0f90f87145a94abe6379e12031775cb0ef60b44f3a6bf31fafd6061ce94de13dd67c9e5c1d42be0bffba9218f4f8c1ec9766c04af265b56d2f9fa694a48680ec7f70086d5229fc6a005324eff3d738ee6c3774b951491d47822008a78bd7c446d62c1028235296ad7d588621037c51710f9b19e748ad23502810be77b1bd4a9c29b7a5e044beca04b719a02dd26c29e4bd39afc525c9fdb7b4c1b03ab8f0738c993340dc411d82de84814f25ddfa773d4bd75967757cfd7dec490591a73b502be4b264fa8a59493996ab180d475d1ac999c6dd1478586eff72d96c9f8743962aea124cc67d3250e1d0e5f84bc0aaf892361777c5b23686f699f0f61d532eb9907f628c7a97d74571c400f4f276eb16733d30294916029497bf68a8d8674e498ef51220daf9fb09458bff91a5c9d2a312ba10323f736337542e7c55b71f78b26c2f004e932cf39593c53fc27434a5435f4fa8333db7117831b16731e8606a71d4e01b86a7ae9cfd5c82bfb84432de2486852de06e70ea0eaa64453558f40acbf32619f1aa2ee24374c600125652e4e3497115c8b52da7149ca32022dcdd001a32ec48d194e02c0c64a2658f2c280cc7fd4f9911620ae1d1c1746f831556b34885501035142dc11b37a3ac08106b1a840ade6d4b74ac62ae8efaae3e47ae21353137db8dd8cb7cf17acd120b1cef01789d9e8f4d47c2c6ab1a6907142f7381d8e9d09b61b423eb763ded1d67c956bafacc4a137ce9b714caa05efbfe33cbb5165c112d8dae2559366523e42f83e3b614016a307b2a4590e4fc5569fc9040dcabc61e504c5852fedecd0fdd2038ace27d1192f6a4801d5622264895b401797ac2b0f94a8787fa7c470bc5a36697328daebe901358b0032378fb1bc556deca5856f5ef6c08365701c366126a62e4843d6ae347b7b65c4883396f1f1e90c95f94879df4ad964767cbc69c4c37a3ef25a24583604db7d468f9e4252ae461cbfa460ca19d825d18fd98a9e4d2ab0c2cca6b3a4a598dc0dc411cc60c07fa705cb4948ce36af96f07b420624c84f9fc7e02f34bb9b4f66464ff3d6e85f2e81d6152485804ec441286396b33e36315e7ee778515d8bb26c284d4d631ee614e1b366f4d8da13b368f7203f4ef57a38cbb6533a7c8260371005bb21d06cc0ce91caa1dc6e4c7526174b2ef2db22dffeb32788cd5882faa659c9fdbff1599a360f590f26ce20e3edb56c1ea16f66a293b8edf8db742ca5259c27f07ad57dfe61ddad05cf7c9fe6861b08af04f4f23fbd72a2e06f7c01aa40f9aa33efab7875719d0c2efb69a29eb4647d135917596e178ea041a40a4ca8fffb7722db24c0d0b14149d30f76c57caf06d745ee6b137786433c7082a551b240a05dc7ca78b24898692e8b2941745c74e81c7573bfaa4f7a4ed3c8f079547365e2976e7c03f43c400289a2a173c6c474d633fd784dc6de0655d3866423f590a340db86abd08fb044b36522d7ee0aaf0cd58729c5995a56696c58018c6db685a2c3401eb7e4c064d2d9bd0641bf94354407d604e18d3af512b71d8f0481f2b328bc3ccc7038e6cee034e3b6bae2b31eaebd875ce9de5dec57ba7930bb1221c28f6de71b77f0ff78c6427666d3f6cc5cc67ed75f33cf74e97ab39de1c9376d1f49bf3a906385489ec55046ff71b7cddf64bdebc39e59286a2ca441352658ae79f309be7a3fe7ca52568a4405dfd46a2dee293cfd635cdd9b40f900346e550d304321b9b7573b994e668d6e79e134a7000947817e5ae9bb5cef483cdbfceb494ec586ce89cca125dce72d088fb77f5f8407678798103eca145aaaf42d9834986fe5b532864c77be250bb3cc2777044e25399e1b5f8f47d65c9b1f781c638d2a154bbe645a345f23c16969bbe9e3403d3b1cf425136b71e781973d6702e616455d99f64713cc580d0f066897fd0ea40ea731728d7ccc0c8ec356fad0085d09b68bbb1412ba978927925c276633d1dddfd03bcb6c4f4dc838383c27703bc63b8d18c6cc9e22dc08876df3713c4a4e3fd94cb2769659da94f6dcf3ebedebab4aef24c0accf00625c65cca2868fae0825e89737e64e96470e7b43e29a024a9cbdf5ec9c1d04c485721405a5b8c02c1b9d67df3c95014614b212c893156ae1a1315125bd848676607598a4b541948e82825d38a99c192e3ff6416e043347ab7d5386967199d1760ce77796b924e18225eefb8e4b1647410778af59e8865bc4bb81289db3c9c5aaf598b723bea2ede78e465a73351afe79d0cb9125754e9e31acfd03b75cb83496945d8be4c219cf1ff5faba89eb4aff29ff9dfb34bfd09f54c1d107bbd47b5d3096791e94d3fd752d1e099374b207f326fdf69edd28bd9ba8a2c516e2d4d08e9bf2b7248a44758ca601cb80db1aa8cb673e108fc67bd23ae067bb19720dabd27c23671428bbefb67d8573e04cb823eaa2faad5b92e7235e9220648fba915dacff3e6151e45023eee8248b54536f43154e03749ebc4500013ebd75e509af158f8509d1c8d02757fc12598eeeb48348f7760605e79cfca6d0931a61e49d2ccdccaa7f96ef8acb731c5f7ec2ee8fa684cf4c82ddf9306550f9dc582816402a655abcdab7f0b6e1c4de0335bd0ec44ffe4e5b35c367a8ebc7f33c7113db9deb10de2516f7174656693ee023ae7bb97ce29cc568e4a62fa71a9d76b4fe599216e8d92aec4ac9440509197b645080054a3205f9896585cd2b1973c6c52896b268a5219794ce589601b03fb6f0f5598b321670ac6e830ff59e57d2f2078c9b0e00ca2cd04291ffff3692c5d9ca39fe62e15e429d1a1b0dda4d8e39de47c98c56b6af2f483a01e0967b9a4e560cb26eda6b0a9a1b398900d52b38b28fe10c7750391ff56aafae492a1cf9ba5a520e5b7df7b7ecb38ec429482668dd2e445cd22dd496f5912e21c6bcd11e986667f82f06b97753e05831e42a4ddac03ed5181188cd6c1639bbb10076a7081ae48ce5b0f9efc76162286551de0b04b0585e7816c72febf5e0a00ea4c6151108bd08e264f0b0ee0c8095e5d7c51d4e98323bf19055000f9fd5f4e4546b87b9ba927a9b799cfa34e8e3269f20c6541fa2e63bd9ad2b6f3d72f40366f8e131be9da872ef1eee1b1b3ae17bf3e2f9e98917da07c552cc3cebb23d6157900b7ce6f3db19a53500c15f1e79553c323119f5fa7affb00b6988cffda7e95824d83968777bb6fd8ff1ee39002acc3be12f18dcbad6b4f30c090fcc52ca319f8633acb59101eb67f31eb147ec3450df0ba368767aef5c3dc77af65303ad048b65ac1b5466dc4937ce3137aba4ead6bd61f27ae69dfc04a9a997e39580c4b31cebc37d94d44ad7c9199a5fd53ff6025971d6c0c2eb86c27b1f1daad72c52f5b7d02bf7a68b8094ef7c3a0e07ca64dcfac04e28e86efeafc08f6ba42cf30722caebb9200fd861682c6e9b4a273190fd84012d97d9b57b5615a2b3cbbcfead551062c0cceedfb0873ed2b1e7d27288038f70d235cb10aef8fa7db28c35d5953124d99cf2dd748381e026d5fd7062c17d6b4c30991ad9f002c29d9a3a3d48fb171f4a94757627e95a14c426dec9397a960add74b5e5d4a55da5e3f9db80f2c8315805a83b90c88f9b6fa33497cd0085b7b7252ff400838c8d04c489243e76aa770ea2cc9550cd10bf287e59edb2fa6c3b52b0b44d1f9ffcc1dc1ecdd4132f3db7081e3aa1ada75b305cceb387d2c7a807015767fdc47d6ab8d9be0ec857ec42abe4c80ed1326696c5546df2c07bfbfec02905f646acb2360e88dd24a6bd09966d9ef198a46b4f210c2328ae13351cb545369d2137232c09f48d97dd5d675dc67862cbeab1c26e363345ed6d68cedc5ee7129c31f3434fd130b21c129d2e3662ac3b7bb2a1b4b2ce73f5ef8d47cd63566b77e5ee081985968ed46b3e8da4aa57dd85f0e778f97d9f1172cc2cf30c1568169bd5c28823424b6555844899fde6e7734f7568ded01e12f3a8eefa1856f91c5ff7f13402c94cecc27d4f866109e112a83150749c75d2ff110e5720def8462a2c129749c7ed995295bf1e1afbbf8633195ca5d53e5bdbef679ccafee572b34c1a1efff444c09c52e9bef6b3789814a096db8877497cc4a14ecd671970faad90a4c9fab9666b4575b7c537dcb1abd51a79c3b3ea820aa1259b5f796acb87be37adbd52edd59efbffd0f0e37c80bef8466d4e58537962987e9ec89024aa8611378fd178821b0b2fdcde92ad47c104e43345a2291b865646324467369f9056d390556a6b65e0470a166af767aa347ebe1430cdff34eebd24fbe33dcf05c64ca14cedd1ba0eac3e6d1c6c5ee97e32ef3396e80b0510fd5b072a36fdae9c4d5031982187d9ebc9d83a4835adff57755615e04625b5582cb742a1f08746c54e751ace3a6e553eec13f10ed9cb8d8a6150ee97bd2b09c6c409e2d41166aa913e86348ee080df875fc19d0b2fa8e0a4076227fa21f15c80dac604b1d8dda584812e8328b20896cfa9c1f26bb9113ea6eb9aee9009391f6d1dfebae821920e620a7b67b3f808c08f5ddfa789b2b35ab2b89d234589ee9ac257cf7a31a0a0679772b0e620c5952f30cf656758cbe0d2b609d7f05c9c940f9a9a85374ecd4786eef514b0777e088cb2eaadddfcbd2a1b882c809f254489bf1b957250df5d61bfe49f6d736d67e4f9aaec94447e3d86dc138a981897f57115cb50230ffaa68924a0241d92a1e36ef9af534567e292f29a92d6a1af7d8150ce9ad60e05a9a564b3141bdfd5680a0f2488c2a41750d2287954447d43abbb7a9026719e565b53fe72d274758139df17fe622962e3cf839f8c6265dd4cc133a3f31a1a586d61a0f3b6cca780cd8d293ff36aad26a6f90f587943614c97f0e8380f9faa860348bc171f1bdf33a02d6bf92422e1cdb0de71722680bddf24af7497b5dfb999f850bc2c682f63754c238ee10cbab3d349ad81deb79a9ab90d39b3d7b2e7febc9b044d5a5ec31b7a71ef97799944a5b3846c9eaa7c10b0fe8293c6c65b0fee1f30be582f1334bc8666163953917a2c577fae914edf6a5958977e01da6e4d036ceb37cd6911c2c0cbe158dd99037c418941d3a12538048c58aab1d1b29c15423eb2d8c183607ee9b1f65591c23799246417884103596f1070345cb895c1483d6b5dd05dbf6cd64352778f9563c08f9be84519e7ba359abc5c8e7599411876f3db5dad6567291f79a652d3b30f025721a4474a8e4ac4daee1c9d889977ef47812099e61e2e10192f90379ac45623d8c062c235855b2335fe9a97b5cd525778f38108f9a07fe6adfd63fb798ef504dff87faab0c926bb880008914d8bb9a5be9c5e8c96319142165c66b16db497f7860e1e44d9eedd9086030676c1d0925f2c286318915eed1e220e501b44b2f1e6d7cb8128f59399bd93ceee76bf831c19f07d01ae58338367dfa80f913babcef9e06b402daadc847e633ee80c85d259593fb10676b268aaff76cc431a2e97e1b3e49b7a76669f92d1a4f2128e29002a91cf1ad005a4968429dd5a5b4b962bd15013ecb04c333fa62e641e51b600f121d992d5327f753ab9206384df7236b4eae63e7cd9293aba667c2c1d4b0b14e98b35e45ac0577037e0d27fd3c1edab0898d45d4e68e1352071a06363d263bda3f1415105c4d11f46fd1a130edacddec37101bfd97d47c94c0ecb23025a08bd2842d3c0ba88cfc2e0fba198e3ee5fc0bbfa8a7cbefe0e9639b7351c9cd966db1b9aee02b57eb86f77954060553c7035f2fa362e49d3aa12c8599ecbda8a5231b6bede9fea7eec4ed598fc533b3869e3f193abb422e7a1925365567f9d089a8a88fc643d05872668ec035fcc4e73ebdf488fb50cbb8d7dfe2908327178c1f23509fdcea3ebbc66efc93e7acad9654cd30bdeb662026c74d2c47152cee040254d305799b574ae855f8c777c856c9eb1363c0ebd146aae72d8d1f12edd4429385c838481166e0d62af4010cb29ca1a1e8a9a40cd6f363435c43f33ecd1acf25929abba03d1c2483dec192410f6be611171a7abbba7db5568cb88dc3a1d8ed942b4bc30ca14ec85c4329781f109b87dcfc8868b669e62c1997969e585bb5a152ae67219f0d43a85e5699e254a458b958823b4d394ce2aac5993909310003b9d1f7657d6d0355d6d80817d6cb8dfe71d31213622e26b4e20950be04af046876f45ee896d1473aa3cfa383b35237cc54b8007275d3baf3e266bd49d8de7b5910595fa1a858ddccdb666d9ce8c5a3bf11a269dee2645db2c146b541989c21ad79facaf982299083ba3341a6ae13c59071730f402ee98d3ded06bcd8de54b862e89b90ff67558148f15d5fc080df38e10cbd338d4d7760c0fb29808bd0faa45dbe33e469ba8bb1a358f81c646c5a4972c160a10597910f1113f20c92aa2f11f2f03c15ec69eabef79dfe808acad1017191a94e17b6cfae2dfb53dd31bb5e380cf8115096b330a47f53fcde604f07c1c5c291a9111792a02d8278af88ed0482b8cb8ecb41f87922dde20477e9854a14eece8fd5668445afb4459306287c96ea2249104d697823fab3f875beb6683515c6e7bceb311b3563c558354363033860cbe9eb13655c9cf67aff37609e2ed091e7ef52db0c0801c23cd123c4ed2d677ae44a4f9f115e1ca44f8e059c7212c6512d5d866710d04387325d5c08eb2e2ea7098a992e7fc32a9f636131c311fa270bea11ecf20f48feb58a66a27333e4f01ddc885c11e2e972de2cbd9d5bace9950d40381f7c78be7c68956f53eeb241c7d3677446b247cfe93b7e5c73f0cf85dd46f13efa32d05f90d1368d1e51a60f2edac4b142c53646845249c226c82d1c72812b6d44f02cb700d81c21cf6ca953237b49333005eb296d683f9c8c4639cee33e26bc69d6d80fc6b63a3f2f29ddf7aea8494202a2c98f4b5d3f37a93c3131436e3dd99d0ab240c2b3517e159ea92da2d1894a44287c1125808d4aa487c5dc71f0d47d38cfb2da56750bf82886b1fc04dba0ac624c05473960726e2371d94dacede42cda31951d7e237a5d0df127efea43ca2ca7badfd86e0749ecfbb77143d15bde0059b6cfa3b261b2ecfb08c66f6c15d6dbc1efdeec821cc840e7281f064af52322291f54df7abeaf1332b554b354a07a264583dccf433965883e53e27b69200c1239088e7a2c119b9b20b5e78f18d8df65d75f4aa1148476981fc34bf3274a8875b5c40a5b7140ac2bdd37765624f57bce52f1f8a7a2198b36aadffc78ce683254b57c97e67073109be67203691f84409dad4fb320edb215d4a73eb43fc74d2887b670d978f97aac40ad351c5fd9bd624d3b5895251c6bc26ec1753dba542fedf21e1b4434bc53e94e9f87235bfd483df28a6b5d5918f631511ec99803f79e23343bfb78f900f322b16fa90ffcecb508b5db8ff94506bea4ab6d81670c576fbb03def825d6804c1c74906d85290e3fb3842dc2b49d6d3000fb66e7e2d5487590e70a78b6095d90cedcab44e72c10cf89beb0fa66a8ede693fc55e498dca5f118c88d9c459a0cde9c72274cefd1c311a7f3bc17ac6f2260cbd7761eb66bda52a5785d36c1ec403447dfe146ebed97edda6e89c0fa73448a427980e6b92db03423d1bf52a9edbda7dcdd563759bc404c4d76aa22871533cc79d158e48cfa4c2852e66a07c0c1aa9a4a8300529243777f2ba683d03c7dcdc0790350dcf594ebbd03982b04578d079c8cb96cecf0c742b1d0a89de427b62ad631ab9bde228ee816c67ec286b82a1e368c69f3421a838de184599715f03cef791c3d72d87c1c3be1d79ca19e7ef959e72dc41d436f8d7007047a0b5f1637b177a2e3296d89d6823920c902d841b3d14b959304839d27e151c3e7157afa860748e602d6017205f8131387b2f4e171b2f58dbddf0e5ba0350b45687597a23590511197353c7a62262aeb7eb50dd8bffe542fe32fa69664f8153a768007b58528a07426686d3a122a85c253f569717fb428eac5cf97efae0e97e162e30fe1f5cda640d085035c6f1374180c64378498b7c788ba2cd575f4570f0c359df026a66c45884b9aa7d908afe4b68b9c6fcd8e62f25f22cd52dc704b62229ae03f8c13f5da6723fe1b19590ecc51f04cee0d556a7701006bb03e5b1fa721c9b6e86291c8354bc8283a887c17fe4c4abfb224b5a05d228db3c16bcf1fc989305369b9f74d85222eeb02297599847b4ffcd500ea7bb9170f4a04651929d70a0f0e36652178bfc8fde653fde582c3169ba1e36bb26e9db41b7af73c00d96a0d199b31d790fa29868e1df3b14a4c539984c41ce76445532932d80eb0232b32eaf37745909810ef79701fa1b9c3b52c13863542e54863303c1355aa8bc42fa34e1772d25d689c893bd80d3dbab109685b877405a1a68b8480198f21f8698ff32ade70dcc524eef5b58390cededb5f1724a37730bdfcb0d129864d47a128595af0f0cfbb14580c578b7de5fc27ac4e279e3020c655c65a6cc8894dfed6bda1666019a9a4c3c3f66a83eca764deafa1abda3c2da0c942ce936e920d0c240ecafc2d651eef01bd13207611eefab00bbf1037b313bf9a5295453bef3b4b331420d4d29706c26fd7843327552ada88df9865fc0aa6eef88ef48ce5dd137de0cf845b46becf97bfe1c4147648afe3a18fe13e34e70acfc064962cf1c332e72cc4ae4453349985b6d8a30aec4361d15d2791bc5325275a8efb4d061cca1d7e0bc0a29fa43423da72c2ada11f484f891fd9e4f782790e7fa4fe0a33d10a4af01c7b23359ccf010904aabcfb52254c617443f0a9446f251c2b323c7ccf2ff9ca78da30bfee7076b59cffa0e0d267c5fcf3f0edf1db9f799677c036226edbd00b0fa207da770b55352f76a8a9056ead9184b474e61df5f1797afe0dd057f397b1d105cd2814a4275582015d141619cef60acc86ab0d4009cbb9ad1388ae3e7308a398a86fdc7e7c96c8626770ca3223d44459b2c695f3d904d15baf463a6500aa1faab543ee43f26f2bd1f4e5d8920e1ed00e2abebf5c40d709b48d097f16ac6592395db9c999264b4989d9375bbe6bf6f7f2b60b6892a074d9004a3617c5b9283ae733df8b09b47037d1891f30aa71ab8732433ad8fb684fd18483d43a75d0a486a909f1b8f9417acfbaad9cd91d5776214457d7446479240575fd475c9cb2d518b64b2094ffe7ab915f80ea77050bd0dfcc5940adde61b392fb4999e2f88357b3583f53c5de6e70ba95d25c090a226c3e3b8196e1c5ed35ac6fbb75eb13dc0156dcfc185b0e75d7c40572d5ca4ab32ecfe42d802c0800d4f437157d621c45642472494444686b7c957c6487bf8a2a9497c659d04a21798c243559ceb7b69416052b6ea11f2bcee7bce33bd8a7b174846ba5d0d54b9a1a8455c1754ccf3e43aea96c80426f35cc3277c222d0efd5b5914a910ad6deffd4c988b5462c3d2ac84dbe5b40182a14df323dd645bcfa52ba68f999311c8391fba1d4eff16f1514441e33ae1a05cf4b82d3aa30742c129816ae8e22a8140cd24e18d78345d0c14640c8523c3959f235193851cb825b4e42c36f1e4bd7e280c97da2d81635d046841e5e8a5c656cb655c60febf6dd9475e7cdc0f6795e155da6fcfe0d0d713c1591db694b6ecbbb0696637742b3fb363da824bc367dbac164788773ca97bf5570acb50d5972d9775e597df07f2e421c22523aa7d6f52aeb2cef04c94c6f0d5984fcdb2a0ca586b06f5ada8544f6b77eb0ec8025223e6194cf7136e030591803bd53e628df0eff54c42d4469018866e79f921cfb09da6087e72cf975db7e76bc0c5e71cd5fdba3bd98aa5ba0250c2b0df27ff3cee4660efe320ff3bd643d117f5f63bcca31ebb14e3e83a4718d30eace3d6d828ed2a8241e1fb1ec33dbaf4fe01b68739f1a503ed1490cdf60dba6875a22088c38019275b525b6d76c2b9706431077e09c88f8a36ff3ea4b14c2834a3c70a5295b4a8398c4fa43a657a074ce232e457f82901fff9f8e840d4f693c7f698ea7256d37326ce98f57afd15e1f6760c4a8e260f14ff1b734186000bab6b4e33fa816944918127a1569a763885e37d6df2aa2839239504daf5d501b847c53c8937031c04f60f9d0b8bc6b50e18c10606cf951aa56a7b211fd2f37f45abce37569b967754f4ad17fe4f79b0c39535bd799798e8b5fa41d8f58d17733cf80d397d8a4942e6c49357c59ede9ee30fe05665f10127bd2738c1a6e2365fe7107f9101301ef66b3124edc53e8104ee17febb06984f3d4886d17c8d53cc53f6fb305a19ec8482b6a6d2850249024f30eea909ead3ff079263689ad5df1963034b5d9a3934e1ba2946cbb808e731a11b5c3b1bcb51b1e75ccc89ca4ac928d74044eb31e6b0bd6203ee7b4591eca1c7f81db15a8b5b50aa69d9ff09b2b4529752a27c26311629181f5d77d4a398e00770bbf881416ef0de2b8c4ab06718b292d3b8f0ce1936cfb21b2b44ea51f9a7c3a40fb1f7537ab6a0552c46347c25d4ce20586817fe5bc625290e12597d5d67b7847387709cffc201545717c2535ab5218b9151bc5481dfc27b46d38e5f17df5fde64207b9c1efc31a0d9e53d9441c2994c32066c8bc5c8626cca360ba3e28b05d1581499e88bab2b65810b5870ae2e672f37fbfe6deb1f8b2e28439ad59d087fdb676be57651eca4c3867a76957678df35a80570845548dd8c8a642037bc1c841f4cd5f320b98fbe94ed514acb6a074ce197b430c6f24f241960cf60a41b2ddb1490129fcb4d70e8a1cc71cb8429374928c6932b3a31807b08cc546a7ab2609f6c841f3e7a9dcbcf7433ffa8cd97ba44d24ad9a5b3a8cf62e8b4aa91159a21836a2200c5478562eb6627f26b41522a9fccea55687fadb6fa90e62397fd12f45b53e80b4595548a42f1f19bba2709e2190840055de6f7acf357e592ca66e3dcc5c8d7fef218a71988749bac6d2d79fd46d960cd212b15938eab2fdec03a155d63fe8f1b0f93e17033b37b34761d60a0c47093bc91831d13504177851b45d1870c0d512de9b2acdd299e993f10ba4fc0f95ce34b93ba8445ae6e2d0718e05281a31a25caf8bbe1a26d9c46cedc5d74277e3b58238b979a1bd79c6ab56c58ffd08895bc370747228cef1f9c5df9095edf1b14fe732fbab985aed0be19f4a7f63df37fbf3e581ddad068c86eb46dcdd7cd2733b908a3319871a54470d7d860e28ec331b62158f4019e2df39baef4f4a74280e61f41e735126850ee85270fe2c8d09ec420561d0601b42241fd786d248d2e851a7a3c89f917a1751a8c469ffc4731d956da8bc698a8926bb710be23a61fda0dd98e2aa48aa87d9776e2983a773f5185074d7bf98c3651c4c1eaff1cc3e984e2588d1a126189a65dea2746bdacb92d9dab23eeb34cb019f7ff18ec6353a6fe9464483160287450701aa50419c8a67a63a7e6d6b52b048ed2bb18a24885fd9e091c417fa6f1036cd0a91712d7ab5d549b9ecd82b3632f10c4482f1685a577cb7e2d451e8d0cea1dc5fb36420ecea756027035d16da9196a1deac81c7082c4c5a4b01f150deb2479345ba3c5ffe41bec044d5385e6db91697f839e8f6300b77e5c0a3cda75bb4814d00a035a5cfa7adf4aadfac4593439dcd6aeefd1c18827dc0fd16301528129bcafd57421c211ebb848e423429ff1463f33e07284a1478ead6ea774c8e909cab6e924eaac446a463e942a3077ecf2fbf496edd06dd306c9b74e27b30b8adcf6e07570a5d2b814d567376c8bce2a1fc090ac00792da6ff44cf15ece8c8b6bf217da3a315b5f143cf6ee5446b464edf97994a110dbb4979c0ee2659f3c0f6c9c628aa1695c40f8daa4d132d7a9b4d5770502ecce1522cea868731fd0ce62d380bd5ba8c9799e73038694fd765967c6c64461d97f653a26ae5f7ee978fd66dc2c509dc0a698908b8a122a0f01794380262ea701b6b9dfd21fa5e58c0f6fcf9b44dea3e896a331ccd23e5e9f4c59d335d9afd8ca8076324e06f0121bf9a321d28f75a2ba2b1a141289f7bd5000ef139956784e639f60d151416aaf375293924f57e901a2ad4bb867e067f8b72d7a2d2703818c9e06433cfa278b63ee5f64dcb082d2d87a2302d367fe5edbc7d8fb6a5d220035ae4bf9054211968344a03218910411c1fd4fccf5435af265d8fc272ce84a7c7ede96daed2551f1f6bb7a2c79e172b5a23804358f7132fe40c5d57d64616cf5d6197b3495a56d5fae870dfca151e88e4b323b189fb71a4673ea691fe8db475d34ce8de8f51dd5e45372d8e3e0b4b8641c1623f54b617e1f90ff9c4aad2720553421c4e35ddf289634758770a4140a7aa7a50e49ec580840f505223007fc7943747e6c0577e4c29dd2db68dbfc613323bb1de097825b5c0a9df1d53568c5657a674b21053566398e017c8fb9b6ab9f81dbb9509cdb049aff1641978dadcde6bbd39756475436ddbf2520cd9b48430378596ca8e86a7455bad5747976d87a94762cb944536e46f6f967aff2c82bb2d3d162f51c65d2cfa9b1b8dd11e2abb526551cd6d1f259250c8e20d59a0ae805828dd01a9fcf6c3524d782bb33e341f320198d659edd462b9600d9d2d02fe0da7baa990dff54cce217cf5e40b0fd8a66226f887116508b7687fe0f60c81925afa100253e8340adb1c735f9699cc35b42e8590ca34082f13007f279a888bfcc1bca42620a497b0e3db9d3f1343763d2a32b37c60004ef88c1622155264ddf0a703ea950ce0c7d1d775212885180e19cc35ceeb4ccbd82be4025dde1290a51e5d56fa29810657e0b719bdd8646fe0a12fdf7beefc2150642626d9083ba67c5a9de8d972d5fd56668ea3a9541e9d66cbe09c640aabfbe3e319f575d59eb50a864a663f6e7f92c87b2bb47ae1c80f031ef6606ac0e4d9f2498d179789f684761ee89f6bd9f416655e34e608508efa3d72cc6da14f18f7df9d99f8229d4ad02cffc98fa52b0918664d88f0a89f0c80c102adb74afc1f6d53452e6515e14183bee3c96cd518f9ecc85368a29f1ab3c487cf6fdb97f05f24fbe777dd283933bf9238fdaeaa0ae35260f3365320a278bbfc2d1adae100243f5992ab4258696739206c484526f814897e456cc5c626add8a36fd6faf61c25aacc90f5c82a9d99e96e3327d758160e7797a0be4b7b8e89be9cb990ad21f4c779d2cbdd9c540b4c59518ffa3e91a38047450611e03e2a6934ee972c78396ac1775264116e70fb878b6222492a0ac6c597ab45e119ad7b2e4040c143014404a8f04da32aad124ea361681b98feae1a028f3e111ff607b74519ad4e60315b1a8e78bdc27000ad688b4bd786a4965ebc2aed6b3d9fbdb8b8fec4a2c2ff180fdf7d768cbfbd1891efc283185de1b2c877c379ae566add7a80b97cf2bfb86abcc091628527f83ea52f9e7540a21be52493180ae66f97a742f7c1f3790ec8c4783f36ed0d099eb55493a80b7dd8d8db3d9420bdeacf584767adf952420711e17394dac843f02aade2156396df3611d89b9377e5b4c3b8b471530058f77a1c6b71cc9cff3415199d8853a5b0ded464cf54449c86d79702a52ea6c7ef0e7e03c0278d6787a69ac2624cc98839ec2bb1898717c2ec781ef764526dbde53bb6e6c858a79c96699c9e657be059a786eb1c4ed95bf267352d557eca555a2cf87abfee1de101a3d6ecd98312b1fab6a3969cad8599a78a45802073b9737c1df1660fd2052286805865dc1add704616f9410a8370ec121db4d5033da33f89a02f39e0f83ef7d3c3c087ab85115d551c1e7c556f68f6a6ef3e222bb067365f3bd6b792e922c25a1d33fcc462e988469e5b1321fe2012555f6248a3b318d75298ac3393f579545b03fc5966933220f97d6f3de826f35e5896a36fd3d2f81e97532d0a7471a31470722c33b16321696849996dc54b5f88051525b53d183eb7f3bcc7bcc5aedf11dc35f7a0fd5e1edfa57661bd197b96236f4b39b8033d0ce5cd14a40f3822ba805b8d145eb18b9b9df9adb273d7f2de03b0f459f3008eaf89a33e3f9fee6179e784ad8773314d46fbd169abecc01991cc01b20e83ae71bbbeecce4fb4c2c740a070b803141368e7fcc9952d26199a2b8104fc1e00356abb92b393ab974b1a64f97c43466cf9be83a7223555636b6cf90060d5b6e9c7efbdd7e833da95e5f2b09b67eff25ba958a49499da5e0d74c384dc37c1cfb203c57a128116463be3db0e92c28513ca9ef3f0d0d7969a881882f2df0d4c95f0020c6e49504b936d5f2d3d78af404f4129af6b98f2aedfab31a18b09b8ef6c636da63521a2da976886768fceb3104cf76b8ce855201b50bde86fd42d4c0db1ba8cb07ac621b01a87482c7e72c0cc391fb1c8321c7372a83d99bc68951c9c1bb2977e1aea69bfa1fcdc06f9d494cd29a4cd369c6842a9c14d7d4f4595565893d24b2215ea8f32c46cacb83a4070fc7063e817a426d05b179365fbc481d89a2d995818b7bf06ede323a06d14b24e387f6b005a5a8137ab9c9f438d5e3a6d40d08bfd759f25199f48465c1174c9c97fc861cb5688ebd1ec1171443d625c21ccc5356a461c7cd956e3c957ae81f59da63c06359a863fd02bcd59c2edae86b209489c50b243faea62277bc8ddc3bce7441ed11e4f7c9dff79df52143c82ac38d1222700efd15700852d7f5b70a855ff61e12bb5d32868ff8932063c760670ebbc1b118efdda6fcf536ed8f89895f33df1d71f7b1daa5c072b1fb77857e5f0de73135547a573d005b73b32e6c9b98fbe459ba2d6c76bf2aae9ec8a925f40d1bfb0b931967db72be68bdf0c0b0015b987659812b42ef8653d69494773bed775dac672c38f60cd18055cf14c73ed05e4cb2bcefa632ec8ae8b7fe2534032beb140fbb67ca1ffdd846346699b6aadd49df82d679d15c91095e75299b02f34729b0f2d069e036a038bc16cfd2a10f00bea76525478bc549e30e3c7623beb6f125c4aa7832d45aee38d7a35d027cc33c7f0700a466a185edb40a63ffbdc004615ad9526fc68bdf7cfd3c9b9a7e2fe52922208c3a1ee987e43dc60bae961be8791250bfe8c659b4b59349ba3b7e4b5be35605f072688594626ef966b5b570c76b1564d58c942e636428e923d3bb5a74c5d63a5db033f44350b4939cb9dcd962f86a22877314e1ce69f879334456cb9f536a6435b2347980d4eb98fe44dde62b145754c226e0bff6344d0127dbf9acf52366f874a07b5b9dcc52ee5b0db4f5a4aca4bbfc9473ea94ee81f866c43669c1f75c2a1dca6331029e577ba6111d9dde0f80411d85b4e164729e8d4f90ebddb0afe700c15e447d46cddfbb56ccd269dd3dc20f794f827668822dc248d6a5647158f13cd19789a5ab87445b3406ccc97b55e0c34be544d229f304880adffebf8eb354289ca2c4aed14f04002d807dff990b4dab3e1259b5307da0f5be358c29de0f94c27d8b467e4875415693e862c5ad2e431b876d4e3e01892ce3354c38aca0112e7841f69b493dd14cf97fad54677bb6490ff033e484f5b9b5bc1258ba0d91ff64260af01bbcf1b2aafe1c6eeafc69926c5b23859f34877521bdfa8d934878d474b9d100777f0e5bd64bfa5e7bd2dc68585012e61017df47ca38fae0ec781390e1b4b4fb79904d99b03e5d2c3ffc42eccd2ab47a3f861bd034dbea4ca7db6fe1e5fbcb5c3905a078b88f8c318386ef539657b76a6c6c405266ebd550b2171238e328d5c1ae5776f2da8c52ad065d382ca5ccbdc13ac0126bc4bab48568e4c7526126c65286e3aa78422d4a08fa15d759cc87f4c2c9080ebdadc077f5477890aee61ea15bf615ed718f1dfe21c91335e8753f8765056865b42bbc5058efe17b503c2f82ea85ab11121a3d8f5e21bab8ac4f614339b49c45818da28ec488398e9e7e1e8f36ba0fee19b985564de13155a317ddf939fb29eab3ca5aac4ff17418f55ba7df5dcfa3ae83f2d59f9f7c7cd71d006755498ccfc79ddaa804f3d099b84af34aa78642e51581ebecfa079cfd35605bad3aef597df8d60699ac04ec70a3551f7c2dd8135f977ac05442aefca2e4561824ef48a4ea68f685f3be70711f01490f8d81e4825901aae3088f0131ec7b64155e505cd10db40e0f9e250ab45a625fa35555877275ffc57c7959af34356b1dd21c0959ef8717dafe2a6448793ae0707b3165d21e5fa2a4a841c3fb72a89f69581fa499842e5ff9af516b96578db3b25cd273bd03a2b9388c895cc4625423e69700d493d50fdf208c0f98456d56be359465dd37f0f4a8071b3177ca520a4b424adcca82218d6f633c77ec0258cdbf2e4624129555f398b45bcacca3eebc0feccf61ee8407edd1fbcf459f02fb913e5e6be295185f8d70da4e74ef0f8d9844916336a48e6b58654f51da3a737992302b717e91c35254fef0c2e0e8b26d34416333f9bfb7467d6b208b00d106da2e685492786c76adc2a90542bd8a75d286c770d6a66336147e8ca729cfb36129fc56e5b7a7b215b90540003c6cd7b7f800ca00c51d856f7efd09f32e132066ed91aa7da78c24fa7f5091fb5798fb9643ad039f7126fb4b84d02a69602636f6cd44bed78ca191029b4445de193a9d99e4605cd25e10ede6b3e23500973997dc3ee7f85d97b045ba92972177bb2a221036a50daf149d7bfe6a1786047fa6b82715c0fd2dbb1fa77f72f4ee14be2b7329743d35ec0451460048ae20f1922f0a6b2dad4900e9b708881b93d84532833f800ecb059b13c930b959f05db6187852fd1d0300257ed50a25f6424f19caaf226cd117378f6d34783796c56dd2ba5ed4b83aab040738b49731f554ac078274da0829e36162c6e3afbdb0ea1f1084f1d12352a4229855e003ce561caf4defe296c901bbd7cb390d8d8106e9043aaa8698386c379beb90cabb15228ee2b3e34c2c428c92a6f3c8c0d30aac05b3c82f6d52ccad3cdd3dce9b13be7641aca7a0f86ad38c73dce8af7962b5250bdb8ee966e84483337b84f64f4f28802681bc348209cb0118bd0ebde2fa71a67a4cf2ae090622f34d341d22619370559855abd5527ac80b12d02ac5495e2d27654fdb565e99e64a241d71e21e213df1c75222e362577929f628bb610bad055f3cf2113b53554cbde7b14f2b1513ddcd16d0474dc3f480ed265afbd39338b90af4723c210f96001d941f41ce1a400bb15491ce62f298209cb68f4fb87e13f4f5a002de793e557b9468034c523bc9f8310c266379aa66b8a98935693e7146dfbcc32fad7fb02aaaba125d21dc01960cc3dfaaad9d4acb101a427646e9619487cef0d4b30473cdf40f3e66d6ffbe6d1ebe2f8f1d02457edea05c4a1bb697882737420b9bac4a12412968bec7425297d6e8629005ebd7079ab7b1c35f558f11929f4f834ba0f749b5b6f886d0308cff4f66ff0f6f81a9a3bf13308e0ebb6e83d6221adff117c0c6d15f18d08770f161001338526da87421cb3bc14a72eb867c94ee9e10a797e108a7633e67b511e7130bc5c6612ad50b3f4f673789249540c490bf7754e76ad5369f3809bcafa50a1e87703280878512e0166a801d533c0a5fc13303028e28062eade957395718f6589a8e58338d39254bb06a6319f36746484cb91d428057b5c978d28bb8e53c8ba628910e2305e2d4ff11ecbbcc7f57a7305dd1cc79ad866abf7c03023072c4512fc9f36267f5b24ab3e3b0abf94034c31e37ae2d31a50b59187ac17555c45eda105983339998d7ab3fd024c1beafbf56b1e6bc82976c42074169d063134ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
