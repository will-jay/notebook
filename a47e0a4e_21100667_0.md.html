<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b29428130c1f712e6b692875c21fe00678e51812fa64997b47fdf3ffb1715bd84292f8cf26189e2d08dac969b57635bb414de97037b7fd322c8dcebaf51a9f75283771ea559781ac2b20713e43f7740b509af7d4fc6bee082e67c88b0eebab8eb66b45ab9681e9b2654c0e54ca0cfca2907ec2413ca6ce06f111f3ab754870b95d43446e2b88a78370efdc750fac4462fc9f10eb90e72fd5c465fc36a52b6068f45244d13a2e87600e839854ad8a4d4f1410e925f49aea80eb6a15c6c76abb97d8567996ca9a9f44306ec7c8ab937e792969f4372602ddde9bec7d53c8c75e4100dd12e9cc8a289812ac12d3f58e31111a7ae257dcbe4e7478116a293431d5974e983eb9c45f63c105454685c993481a31a30e42654607631223271f23ba2aca4988cbc3a0a9b815fc31e5385f5cd35a9fb2908030be0fe4b3ab1d1ad3cdb3d417db1d94a96fe474b8ccc1fc8edfcb3f01787bf35b2271b10845553345cb0b9de45f225ce1a9ac0b86eec0cdcb021a8bb70d5f08f6e51b6f95af461b45e73d6537d5ff2cb4c94a3f354ae28442abb15cfe7e49b03241248ed8ccd64d81e5631707d3de72a951df6505e34f4de13dc504327b2b7c73d9e74baf49cefbba714e561474bf379dfc0c1d74ae3146952720b516a07b903abc72a02356497269da4cc1e690759e938edc34aa000163f03c0086c5881adc0ea7073055cc4e44404ad782cf0e68b463163243c8a57067589446dab0040f0dd1c0b61e393431a5f174be7b3ab264bf3d1c69d2581ea31686c660de78664b20a7dadabb90541d10b456de3791b540a18ee353193dd49336604061f2154d11fa838840e408d680554bf3ba7834ac44fa0ab73e6d9b6f1ea013604dae6ab7c510ea1930ba0a4025fb54c03d8dbf33f67f9e4ef830b64bef88f2ed3031a51ed27a247592b8b58b75b52eb375cbcc58df58767fad7251e0ee1ea90f0e5a973d4a972668153179352b653cc5c1be6b2885517ce96bf08a0362b4ce5247a5a28c39683423317b9009f66c00ac014dd4c45c66f687f4a90695b4d39432d0b6b8e9e44b3ff747d09157bc7243328e461f551e34927fb9c72da80564ff397a2d23f65aa6db5ba38f8a59d86cd1dc3bd21b31b817ac1da9e2e7d674acf162714bbf0a828fe3a718f3f27e800d0c6623e66e01ce17d5f825235d1d391dfbcfd7cb55e1f3773598a7b6aa75ecb12b3986d39fcf6bb5ca61d96fce4cd0e0382bf1a6a03ce3887b07a2dee3d0ec83eca1f57c862e3b677f8edf9a7a253ada4666e2d09b66b68c793dfdd1110e5b3eb67066c5306053db1178349d0a4689a2d1d9ec2afce9f43ee46e91df2f7a4a915ea6bbc773ec1e631cc72233989e965b8ad27c2b0bf886c9970f3e18e16002c678df85e68f870294f1f84a4b88361112f3a2c6a2d5962f959e59f4b997f5f4893d0be19345c758679b08c16038c3810aef7839f3c29f65ac2c8a4d6e206b08206d71091dcdb0894c90a619d95684c81f0ff9087b80983cd5253ee78f43f9b5734ee68ac7a59a888b665a9f9e1182400bc4c8698d195173c0fa11be1e19ac267a23208ae4407eb9eba42c777ab78cb0eeea41859bb10bf675e6e634e068d4829c23008f1d6fdb8af57a814f408f9db06309c9d72940f845cd5188450d7f4b224284878fa0ead56ad5a177340d2e87e05157dbc0811bee00f8ceeabd752928ebb70a7fa4c569443ebeab89312b1b85595c11d12f93953d002066643e7f5421afe17083b75aa6ead6b1723080050333fa04615282ef6d28e68461fa27756438c5f45a3664d8213551d6ce9917e36bd5e23cdba92c530eef7b17e53e2dc6758247198a8ded306b9ba14461032ad8eac6f69b763eb74a35c6a0100e90481438ac1c3674617d92b04704074e6090a1a140b32f9956aacde9798361c5cf2c32cc1938b71736c0dbed2b9378c9f261f0b68a88c32c4e1bc002b7a24df1bddc6cb4ea1834426dde9a9f8ab35bf6f3936489176c4d70f801f8c9c404e36298f4a0ccd0fb50a481f401e9fe8b754cce21e213675bdf9d7be652b21cfd12588d1f585641acd1dcc6bcafa58ba83e28afdbdefa7e22dcd41a2f60297f6540eaa9f29c3ef6794c40da3f0843246bc7c1ab606ba20cf5f7967c38a7d330e090a91ec91c4d34b13174c5dbfe15de7afcc9251bd77c7a0a7a3a3e8a0500a3081be1c5279e4bf81ef1d8e6c988f5ff7eab02330a3ed157e0b6c249502c64f2f9728b46ed15ea157e07cc29be2db8e4ff9285858b93463663fecbb8d50ede5f618dd691023a3d3ef36793bd2a123d936909bf7a11987665ccef8a198f5144fc9918c8550b1303f4d146c2e4cfc09036e5a8c93b462a4e8147cc5fdac52da5c4c93a17c79de9dd53525412b2dbbe98e8c65a0014e2c2e6ae8120067474c075339fe90d9389bc1cbe801e13356e20e873af2d3817e93dfb4cb9b70d871099cb04b0d2d56763c85917ac5885a71306b6aae83b7221ce584393cf5201567abb41bc4ec825691561eeeb36e7723fdbd8df78d8abd0e409ac0f4c159f021804e138ee914c7369adef7543771ea6c21fec7f4a2e8e7fc356dd76d072faf2b2ecef97c610019658dc71c51c795d3cd456842eda7e11d5d860babd2f827486d43c5c7a3211caa621cb13b1010f2bc84d139f9b7c3b09de544258acbf2c1d67d4a584e24843c4467cb9c4f606c15ce196d6933bd8fac35f31c0bb5637c2c5615e41a5d576febb7e4649e17d5ae9d4aeb20f9175a56b2201ccfb6ddace5faee4bc5cd541595f210a1a33b9e4634e60ffc1bd5946c36bbcaf5ef114e20793e6cd6e4fd8d8721bbd5846a30f3208d93bb9085df9e959d6b6c434a7618179f32f0347b167f58774dc2442450d5d3818c360889b2c43722e0effa3f8af208dacfc52c4f937e23b9b0b1b11740fe2a538840f7efba399f928542dcb240d1c046789f4ab5e4132b26af1a9e8154750bfba027402bddc990e2b3b080aa9b466d0667274e09793e40c001516d574b4a873f0229fab9815d90eb54619d306d01d105bfc7dd127092114b58094fcf7c574904e8daa4b0d63de1652a523eb1c366c63442caf1b8985d759a5832d2b33a8345d5dd50b2d6725ba8ff98e4c506d1acfe626d76f6e1bd25883340544e874cabbde72ac027b503f5ac1d433c7a857b965f867ff26bc0f3bf6618773912e5bfc463f262019eada416eabc941752129787977874ea451be0d88461a6793889570ad0c8bdabcf7e6cdfd890c03e55f7b8ccb192cc832c1204281489f7412a2a4bea3e3e3629bad58c9b851a99a78e038c445e0bf5d323422c4c3cb892150fee78b8860dc34686fdc354d93c8589eaba229e9b6051efb2f26e421917939afc0770882450e1380fbcddaad6506b8abb76d7328d97fb2dbe74f94d2c50aa85925d0a93a4428602f56bf1c5c5408e502dc1747084d488bf01b70a91d1ff998b9ede167c6625f8d3cd0c9aa9b9ee0534fda6192cacc33fcde0ec9d21d9509d2e3297331d99bd4c39c97d08be147e4bf24b7100aaaa7daeb419e4d464a49e6fda33954255df9a607247338fad5cb9949aac1aee75df51b8d677549927be807e52821e4baa2e701c42320fe9bd181dbf804472f339948131ea58e1c8936c443861bd894f2dfd8dc590b967474a516714bdb69829139d90da25826330a69c4cd83eda06d2aecf6b5e37b4ba39f404e1cbfa3111f9f52c7d5f50281a60bfb8f0310fb7dd83bef6880d828a7bd46b7243f2db71b9c904eb9c1328008d909e32e3f0900d4220359d9dc9d06f53fb74c39b7da0ae95e5188fa5e31c35d34b1e4168f8e06ecc1239f18a0795d759573756a5816fea9b18e8ef050f2f1acce77816cf4ca61b6e2df5a1594deda3ce57b8753a5fc1adb9129c442ee2a2479c65f8db7d4e0d01aa8120c5d175ded15df35c3ce8d72cd048016b803e16b7918727989bc49af30f3cefa30212c8697656cb0acd79743400912953a440e64841b3cce5c7413af82121d4f98006dc1ac1f4dc6180a48348ae854571833664fab14beebcdfec0f067c4d710a1bd99b23120411ef6c30853789d17e55cab0f1815523cefd8d4086a6ea83fd90d4da1dc81c028de31d8a2642b2805c11d55e660b53766c7d2baba35479c5d889657032cd87c57c4373a23083021039968b7969d5100cdcda95ae8f0786c00df2be0eb70cd41650569a6b1941c37f94cdbb0ab001e8e05417a12cfa3603b80c8161c8fe0d9e0bc1f19a9d5826ef91b37ad609436f16dea95206f48b0483c6efdd0cf61991375016048f98238a817ec46c58c6ea36854a95d836ee0e4561b17f587009c7a509e5351e798b78206aedc6eaaf3042370684192459bcdde5ed92dcbde89ad98e561a16e1127961167417a674e20482f0b0281abb24da5a74023759451197aaa197f7e2d136dc35fc10b3fb1effb5e11596094d0f5d189323bbd1a3c08846289aa6d843301fbdeab3620951ded5211e2934fd97b01bb78b25d1ed7556cb805fd5b6bf1f0352d252118abe7040fc6cd393e18a85fcc4f2643361546f285d33ef055ead2e75c8c7d981e87955e9f8d890ef9ded9a73a88f90bfa059b15125adb708bc316d11eb0b67a425d5fa97227b1b7f4b27063af73bef489e056c9e4c9bae203a5e59607b8318f8afa1081df521597f72fb586b60c611ceca9b9726df46a5374fbb6ca88799dd89be314ed8e24cd743056e5ca207e9e46cc82926f75fea82103056dcc51a0370e17e34a0456e13faebd0be65843fdb260043a2e266847a1b84fa6bef7844f535b27475de5cea26f2ce164edb107f1d94eb28a4e2e17a29b1d7c290afa6e1aa5ef5aa9ed49189b67168efddb7a589f820637be6de43c78a7caf336a772520c0bf7ccc2bbceac224f4fb626239b8bc0a8e35d073854873277028e647ef5ee18909cf6bcc20b38e384544c42f907a4be084402a82b05fdcb50a28da2d9cfaaa1a325958c8b39b1e1a212d5f980a8fb33b2952535f6ea2465ac06424b579ccd57115b3969c6771d8edbd95139e986215cb7466bebd11a7e2d20c8bcb75481b940506dea4d02e9c1326e731fd0fc433e8022d9cd4ff3460f30fe1053a8be624e0636c9048d124d79b64691253fd6237252e7ca9be09d7e6f96e76eacfa303a3b7fecc98d8050d80dc1695649f03600a7e57d3a11451b2110436b11b296377770b08b00c41da047682991c2741d906889c8db39c64097dad5f16938053183a4fc1ca714d1904c171e70d14e29cb430beaf2c930b3dbdb219e07a98635c68d1292ee4eb1212cf5c230f23b1a5d8271ccada4ddbeb2fa797570039da49ef8c3a74a2ce04b644c3d624161080c0adbffcc6ae1fc2455887b4b6ddb27da6b4981615821f1438a09ef36e2c4fe02ffd1eb4c0710e40d52222f7530ade5d44e71cb028835663f64b415009bde8f0726a69a372f426bf30a50fa648a8ae63553f293bbd6c97fc47738ec7622398c5877a613de66d0094db08fd44fd318c0f3c309d71625801cebdd715756d7a0701fa4fd5b342ba2613389c5e1a464dbc0885ceee29b8b1c698b3474c613126a0eeb3e0b1b99b859940f4deddd29be14d28d4845f03c6683382135558b6986aaca2f73a5e2af9c72097af5dc91f30d9966d144c80ac96b4420e900483cf916ff70bc272d2ff97505025601c0d62bfeb2c68bdfa1ea0d73fd1385165ba1e373e558a5955cc6009a4109ceb7b7a4a08bdd0178c195c6c229a105a0e78307e926f7f6197fb93b2a5fcde17c7a01e7cc4b891b8aa243bd133000b66e0375580ac3c5327bb9a5c9b09cacbbcb5920866f011dbb9922cb614816bfa4efd85f5a92ea9c89ea531f1258f8a78b8868071efa951382cd78fdda35df20220514f9f838b7acb7b907f95662f2f8600f378540bf9bca472568805bb94649a724717d56ca0c5fed5bc4c74a27cea841fc2ee2dc800f73030ed8e31f0cef15f3b5e30b15ac96af7f3495826ebca93e8722a99d8ea68253253ef14e128ce9a250e4e095712e6c4546b0935696c6834bae62bae90b73ed3c2cc7ea2b09e39063a7c695d8c9a86cca903db1cd460f23e2a0d60636a8f748ea5fd0d3fa96cef9402d34d5854ab8e4d73e0d81897631f7ec74fe8d0d93d085818b5f0a2257313546ea56d743e92cac0d8c78b149ef3e656674d117fbf0c187970f1f69338990d9e0d1eacee6fcb311beeb9b7b6f9d7edf2a101ffea197c179e8de65b8aa7c67b6369d011e82dfd0030c8482e4ba5ef6b341a80444f61f8236034b4000a38b87da875c1ca9ffca9f319a7b5a955208143f406ea745fa4771b647b0a6bb58c4ec313d615d5d96c1cee4a6803695c6841dc11f4ed251a598446fc03182b9ed9fcca624e5f8b393c2d3b3a14dcec71caee00902115b94dcfa8814830f24eba10fd0b3c9efa863668ce7052ffa30f8cc99db00190ac5595051fbbe3eab7e1af0712bac49413117a0b8ada6ce0b369673ae51dc904b7ecc49aaf48f30cdd98518da639a45de4fda9e5d893ff240b5610a6651a1faddcea6e4edea9422b3e875fcbe76a59a06793a8ffa6614cf98e2007c4c9b111df7755854c269be0eddf4fe40d88e9ecf938e757e5942ed560d8c9cc7b1b86b2edbc282b170033e5eb9a2e299fc54e975f42a39d30a724d5ac87000d6138ae85fb373f11bc71c3da14c4478ec99aa1f135f3f840cceb4691c418be81fadbc2b49f12514e7d821a68b3183a64191d6ebfd6a2e43786ea209546b24ef0e9d980c084f8e5b2935e24e7003064aa19f0deca0d5d282edde35018f521ea81bcacf82b4ada3b49763d56414231a4e46782c3fd9f4d5a280edbcb2cc92edc98dbbc7633818a163bd4159c0b472fa9686d702dabe2063820ab778a7847109e84797191bef46c3d568c015ee4e7e3274dfd57310ebdf05b4b56436ba5f48e160ba5098b3af428a89a38f247875ab6f404c2f6b959536204b15b30f8dc5403fbd6b8d883e69937a9e22be4cc91a1811b8917438909693f78fdd720b92b65461cf6741f2cd01e1c32a89a6845649d70c9f65940891ecb3a77f4db81aca11ff667ed60e90f89ef8e79e2d38f03f60f55f3fd8e877c6cb0cd5834ccd26ad93fe906a9d0b698a350ba82d1c0077773da9d02f406f8986a9add44c244f4650d42c100a86d5df594b397b92f7855d7a05fe8b5b8a2918aa6153bc0e19a4d158fafddde1636194994b277f1ebec2b44b3d47e033db770bf4921e04abe81342adf6f064f366668ee41902d68cf03282b612cee4d97fd491edf5c8d26ed064fcc15cd4667fa66f8df90e28d3f19beacb6c4c71f7a20b90501f18db320cb260da34152c8a6af9c89bdbc4c1b67bf361e3ad51e5400be4b33142f4e5063d9fb06112f452eefcda46fe08eca986ed59d390de0ccc1870b48bbcb09a9cffc24f4bcdbe7e7bc8ee183cc9e49bd87b2a6d49587052f825be56dc1e8f488cf54eba1c2447575a1dc31a5b2d3a7656f6b06761f251dacc187557f6f024beb438d29ddb34c53164e2d9a7d1fcfdfa2cd0938928010c521e546f249fbc10eae18cbc9dd87c442fe67b8b27bd8af47f0fc12820c7cebfd24a755048fa4ec1078c96a29363c3b89c9c37bd1a0915fa767710639f748cb2a7405aa846601515eca76150a3a371aae1cb4e38b1c7d0ffe8ddee2d82d6589747a4031239620329c8eb26ca58c17ddf6a64f8d9f9e7023b77bb8cf4b69e08c18ea08165d6ed921cc24a37101afa72bfc4f259717a84310cf6026bc0f0ef1979497664ca2c40610a0040d7bf138fff8e4a19749a6d6d924e8223b6d63cc42b371e3a004aea8a8fd47d1e2eeef1ab860edd090dde6a14e70248c738af060829b74d4223e5917ead31536f1c6b0f94cd33a46b6051ba0ecd63bb7adbdcaa77e25c27e7607190bfe5525640921be5d7b8257bc4876b676bc4179419d90423e7649b585637d26f789f4d26e2ad490950e88a3c796dfac59189d36319de8c5e866d30b3565169f71b45fa36b2c9b430b51b956148c931e6bb3bac733fcbdc5b8157828caf912489e20ca96e1eb8e5c4c7aca11fff6dac4e72f7eda539706fcc1750dd118ed667df1a668773d798774f13b48615d1634e58a471a791f1a2d68716e1d066a88b5c30d1fcdf56a159e63524db36b61a7c16eb4205fcb9b8d4f3a5a17349cf18967bf9499004632edf2d5647666c810d1edeb76597b162910e13575bb372aafdcf7a29b4e4ec80109580707628e51e29de4aac9b97b10d645ad0012431d3dc5a149aea10bcc70407ecf330a079aa5a1a1e645b02cd9221a1e4b4bfa3043c3e8a58abac70e5a1ad55464261e984d5fc6a3bcb0fe7d451c712cd87ad2dcc74855d24f5023599e35c41b08576870c5821a031ea35f8dbad65d0825009e487b69a79e341730761e80d4429d9199382d92a69b2732924a0f4e60048466d9ff0a45cf8a607df863befdb69682ed9fd8034268a75dee97ae3343093323c43fd305abe83b37fd206961ee77bed4560d7c807408a443598d124fe80aa80e3b088317aa0d55da5c74be94bbd8d64de8ef51c6667abbe1a51b1518d664b838da6222b81c201563e3cbdee3487ee448d1559641e774aab8dd1dff943ee82a6858960c8f77c41abcf5ece7593f1aa726cf04c64cde54d21a57c11a2855e14f9f8742e24f2aac8199208c9bbf21c469b20a13c648cb1f7fdb73ef40a4b4a0c7cb44b30e97ee5e6cc40549cc13a2854919d6109dc94803ced14caded537fa7cce3b121635db188f985f9517c0f29782bad3cdebb6fb698bb1733b05e12575b73186ab4c18aef520af2b0f4b6d31301a483316a65d2530693b0fb17c0cca66f4c361c6eacf8b0e1e4f03eb155f02efd0666dba526caebe064f23b4cf05e217db70814c6fa553060a70074f26b48cd4522b4496d17c5df3f5c84b8e6d3f04071b84320310b3d66451cdd7cfe8c19fdc1395f329dd4d25c5b4a124eb6bd66a504033c65f8017ebb46a00a73a1dd84e8f9e3453df8fb5ebb8e46e137c7c230c3b5f09c1890028342483a12933fa9840b52f4e43ad37ff2855702a63f3d607c2251952d9a441990855268ce98ccf0dd7125bf43c015a149b0869a7e1400a5ec6161c889b6e0093c3681b1263a164ee7bfbb4247958f76c21c714e3bf8b07eb009d9f50fed4505aef740fe739751f859f6722a3677b0bcd6f623230ba07432e1e30c143c105e6e686e97863b9ccbbe3a0557e697813ecfaa37303f13559cc2335759843fd0c567977066654f943b916e06e08492befb28c15d0d41f0387a0876cee69d7e86925f6212afdeebd8050be341d580aac5656053bf852c4e524b2d09473b03f00c7063d81c7f55853480a07babb8a64261e1389539b62f32b21a5bc12334a0887ad3692fcde1c6d6444c56d7b8445e6940437f17da4e78a1623a2b1a61d1f45f50b831d1165c94b82acb00668ddea9649ff2b0808784edddf406afd0538f3929f9ee2094ee64c30eaab548f920926e082901ffbbc1886c4099e5484ed9e61c8cf287d095a2d1cffa2c7fec88b164dcc644772462de6d967727f6904023f06cd3f5ee04f67f3abb09a3c0ce78a038df1fb7b8010a6c87ccdaf8fd2e6342eb0a08f293c95d79a1ea2f4ed839b8cb7d9590b230ebb7fdbfc672304538331c5eb68a448847c4c5dd613b912829f1b241bf0cefb8207733158d5823f2d67e35a4feba5335dcb07a208b7cdc959bac45b1146ea42d08b1d6801d6aba067175ed8b3a5b49f06392e287a46bd9599c77b4fb0164a78a82c56d8f741264557aefe4865e5f7e6966ccde31e59b1db4e6f10cfedc0cdd6208486e461b1e28412eb338f7e905cdfa09f76eaf4a18d48162b718ca1dde3a7bbc895ed21580a8150bdfc8903e65736761d723fdc32a1e58a96b664c37b2d28d54db8009041284c2afbf1ea54d91825f715dd24844d40aa2c98ea2229e94d969c8d9c4d40fc6a0e2bda6dcf5375505278c7ee4ffc293d90b823b7a8dfd48972a3c7be1829c942629a66ab3c356ecb21f8fc735aceccc90e9964bbaa2296c7dd96354cfdffd176e067ee352fa358b7a39dfeb672e9cc2d7cd758e1002d47de8130bdedd91c967b1e227f152ab99b7d57a4b76ea8c1a74e3e08a4910aab5b63fc9a5c1672308ae07063b259ea1a649f18bf6fbe6f7c732a93b139dd32d81b7234839b743a602232fde38cb86bec997a4a7fc40a687bf277ee77d762890ca34df1c5ec9c45ffc44b405c39c8f70ad070fcefaa9cc0e461d1cfd615715088b0048a47527c834e9761004919967f393a64aae24e28959b2619b28245e2db2ab0060829548b4acaa8a9225aad2aa768ee3d18341d5b750dcce0fa28ac1318e7eca70dcbe729d5c827cd90ed6b0a3cc64dcda09428252f4d0311e11df8bf08ece6458e6187ffdb45b576cbb938d406efbf90d03ee97660b5118e45ae7c0287dd6b1ae1f05da0d985e66717418d12e441888d7fc28ec4bac985f8eb0b2606f35fbe33842febeb1b13127af707a70733e9d5e3ef5a9e996f2b1bf3198e0a8baf2df050ef368a002c4c13fa5f464e792c87c49d60e2c76b87006182e615b7cfcb8a99de80599bdfc9ffd65850533507e014ae867585e1b93b14243f5bf2655800c54aaa69b9538fb24bdb412bc4d205d30ddc2d53d26118d9e1a4600347f906e0abedaa1a7e6156bc872bde5b3b423d50a58588d7b699a23218c4e6010c9bd8c36d130647bcd2f3a952da3d47018c5d1fd64b687fc833bab76a9b61ac0bb47ff68e4c7899eb038714375cbe8f5766d3bec69c9d9bdbc81cf594356c8f32a41c80c372515c187b08bbbd4c452b3855e537b2dd1db07342071f0a4c658d5df875dac35ae2f8918b248344b0694a919b2669b2fc1b5ce3b7011098fedae54f0183bea4a4f6f343446c03a8987a96aaea605f41a39116fb8b7dd4e2ad23310c13c5cfa7daaf0d36988ddd5dd66d025f5345d72f0b552469625f8e41829137de56e1a33daccaf1c1e053bfd6f55e66eb196e8834afb4f562014d96742ff76791aad91ae269803da7942876c71577faab77117d5214a8e27b51aaf2779a03494f82b7b4f334ea684c77ae0c52e126054e75b08d11903e8e7521550d17ffd8d0e7b170a0b74a40f6315f36f083f76c5c16299f02eaba50ad7e238f948b1c752805ddb2dabddddcfa78ba5807efd4481a172fbecf6a18dff825078b945e86034d8f11c113c527613fe87e8687286cb66156bc71b5731124fc8af5946636a33117439e3cbc9ecce34f1a2f90c6b9add07911011b009197bd07516e34b8820dc3512d944e136f662c3711cf471e4b13f2e6b47dac3ce7999bc09492497d68d97777db93f4945f3bd33eead0dbe9a36c17af15a7c415268d28c67b3557fb77604a25be9da253479d8a3dbeac5c6ac20aa580a56e9353e4875923e4cc1cdd91146266b56fa8e8dac8c9509abe2570e0860bdd63755d1597b67f8b1f1c426af6ab67f6e1365bf856da13f28b5f77d7d8e9ac860b7e2e7bbdc07de1cc8ab111230fcaed98acd67243be5e18b38e361fb5212a68e65915881fbc7befeaf2e69750d6b101007d6c607eb54f865c6218d8c0004da28626ae15a26945bb59479b999fe3bda1674ceeba1d305eb6f0b980c274dcdfacf87728817a68c4bd65422fc718eba0206d8564ee2152a6783b0f0d4056b0c81c988e5335a23c168232f1ea477bc99f5f33f7585d1098f88add7dd47780759ce6add13d5c71146972d985d867ee7bc740eac2813d6001e65af1254763caaaf3b95aa718662ca5f34f8a04bcc50bdc722c0f7d868db9fed14dc848c1bdd41ff340f7efae7d16b9bde505c7132bd37e79a142cc43e683110283ba21052718a44f6abbf0647646da5d8c49c8f2f63da47de1c44cd5e15c856c238584d1d9070b2b1897ea7be5cd493860895bdcdc3616dd1ec613559dbc44ab232a5142b860b23f7bb3f3a3e0ab2525461ac59de616bd6f375a01e3f0a667ddce8ce8d5a14d1f19ea7d5ec2bccf938238df9a0b1e48d07ae535bb117610a9b897f4447ca28f0f4507064c34f33190596c899b1d4d484b73b8eae8289ae3ec05535e47213012877f104c7b1d5696fb8610d33a3acf7bd0f9487b0e85e4ad478151ca7946b55cd4cb80274227460fa39379b34f736077a11e2d4140e8b6e2d6e58a29f23f8e0dd7cd6d1c5b556c73ed3c58ec7fa17876a1978ad2f8cbcc9625322948932f17f6aabae5ce45e2304e0743920b9cc0f305bfd2b904de1b921f310863813288e41f983f87d704b489ed74393d074820aad53341b4889ffbecb8898fb4f3d8649ccb59ec44b3aaf946f39461885a85c21cba8888a06f409b646eb6c8f2f079c5de11f51f37505011635ea1f6e6090021b3d367851d141fabff01708ef4cc7cc3cc0f828cc4bf4cdff0bc8464333288cf21031f379dba24ae6733facb39fca20b2521431a8285aa88529f7a57b2925646ac6bf599c41dcba29544258ec0d32c50f856a1d8ceef49d75fe7770391b7b9aa5f02f27eabf54aa3aee75ef553ea2b4a95ccd13e86d750a01f861fed729c1ff51d7b0862d94e515e16ec229cb33ae74127345e6fd014e4be1299a18001b2913f45c7f6ef551cd6bd311023a22201b4a29ad0dd74594d9c08cca30bf50f2b1f2f54fa65d3b1c80c8f942ca6e20500f926f82bea6033804b60faa0359ec0b8aca74bd62fd6b3eadfac5314dd908e88a708e1f5d95af662176d906229f87ca5e1c4c403b95d7c3e22bde34ec731508dd846e729284602a83a9d63462bf2289cf8b4cd736ce41096167c2f10d97edf264ca1885d723cd9f0cdb03ecd84d827100735f517d07da7dcafaa08ebc1290c7be6952284492ad4bc8ce20e8935a8f6ebe1f43d4a537db2aca2908f6d5dc135376bd80724a944d7599997ff902800a9228d5ca360a9d8deea50a2b6f9221411793517399d1333ee4c33fe8dcdf6d8eb18fe05d892a70898a4382295addf9501a02e722eef6ff892ba743467283367f69daab72eb99b94a08dec6ceb7814cf8686306ebf8001aa60fbd85a91ac90da245a26f4ea02874905e6dfe91e23edc3e47081ee0751d47fdd3cf0bbcaa3fddc12e29ef9c4e1c5629c920f4a3819dfb2a96319cb32a5c42847b42e48bb28ae8717025246a1c32c060bb42c83c52e91e20885728f72666accf5c6237712def8565e6427f256bf01403d17568478477e8da6760cea999e6ad23ba7ad1bb4a8d59fc69d1b3ffe36f56ce1365b1a01c769e9c4831a36252f6874dfe2e89101fed3035c7fccbe8884d5e18e75ef913b10f451e1b6d005bcfb0201c74d4dc05f7434aab10b1e4b814b233d46c5dde8369e8433f1684c00a2a0672980bf0351702aca42468dd3a4c1e3eec29195f2995170412254ebf7745264147c29559959b50cab1ff32b68917256f03a0c5eff8b3646bd80a7f7fe71540463b72635e9029bb3be937ce7821bd62b69e38701319f3dd17caa179a4a5197cbdea15f276f31361db7ab6584df27c1dd6e74bda8f1d4db99777c080c3eacc519f73b50e6a24527264b109d2ad2c61271b9651064a603e8f93dc9aa92d6a93e05e8207cfdb2241ca57c221b917c1b90655cf292ec4c9708bd20d43f31d9c7d801095bfbe21458d91d4ade15a53c9c145f89d83cd63ab0ef229c32312f1f3b0ec686100befb1912346f4f5fe2c39fc96badd2a668a0e4ad33781c4bbd604c371e3df26fdeff37c5a4f23f6dd411d85917179ff474e15823d9370f6ceee050bb213300eed4381d64c4fa87949b17738cc13878f7aa726cc2f05fe3a9aa8f84b1ac045ad15ff1e5dd5eea1b14e4d82e8c56403256ae7332001b366a6cf799175df7bcd8d741dcd9ad19a750c2d0c2f89418c1bdbf3bfdc9c045d81f851b98c5ddcfea339d0e0d45fedee6e557aa2e13e17410ace27711e1415462b8bf918a518b0f6680d1209b3a44ed181ca341a2d4c71dfa61c150ac0ed0da17b06015abeb18146a6a6f0581dca3e6f03f5645244c08323807a1dcbe3d3068e7dabea9cb2bdd11bde7b2ba43ebec16fc8c96b95cb4cd91d4bf4238700e2f81ad65011cc5fad11a182b37e124f382258b597a60cbf505b32629401c3b2549d83902e3abcd5c088ef29ea73e6d8eecde8bc2773cd87f110b217b246a9ff7c8d0634485d3cc2098c9eeb8e7db844eca692c07c6e908b628d01fd7bcaea95b787df41d437d4799d3915e518d33805ededbe3845104d2d8a143d9b55fed1a04edfd7ad8c618d2235c61abf33001ede2828af36170c1713c7a889ccf4ca50ccf2eae2314f2546e67a896399407fad09f6b8d5070c75e64e1a2e378b8bb3e17ed9841e4d8271c9580fc113c3fa3199563221b303a6df813786d63d87316f7ff13489d33296d5e8ae7cc1863a369a251940d54496d3cf876dedaf1e50ba1c413c2bd093a6a645b0818a60e2608c4c026544b22a38f010e16a00656a426d4c197061891998a3ee0fd1e2feea88df838d151aee89048e925a41aa97375c019561a02f470ccd71aae2ceb2a0c8502bf5d0a7778879019b66fa1ab91d4270b1c777d522f0a18e3c0e61cd49dd8d5c23aaebc377851d6f1f5d9ba61261bee049f79a44f6e19fc510bfb2993d897609fcf5eee4384bc1c7598a7d4f49cc0a81d826f14abd62f5986d094ffe4a073a345618e703f9409fb00b55841c17ade52392e6587dff76999f8919776475f8962ec3b70b000201d740dd0e0151581dd75f24a43376ea3d96b037d9d55b61159dbc97de98ee463acf57f567448d23cf5685e3a0c056c5e7d0c78f25ef14ceeac24838fe526e421f6d296935d34ccca33936918827bd20c9e6cef4b88eeb7317d45dd92c07dedfdaa96697920b54f1ede90e9a548f9ae3623d6ab8cbc5c8091c91481ba8feddc410a4a0f720bd9a36c6af529634f8c3e8a9f2ea84574e0fedd831e22e1c79da6c957a57cfa7d67c8c4907a93ecdb4a39aaef4eab26b30d410d110ad2b2ffcfd6d3228e9840afd90c1089c5dbf8779509e6de5be5722f80566a78ccf26f5321945c5150329569d5f1375cff992049865606850801d750970f8d022d9869b3f0683efb16d94086a27d31d4e16f6f75b194b0ed7c6579d4e1854bf877c43e2a4a200525079b5aa0a5aad9bac53444c01a4020662568f1eea87ff9361affcc8ad241730712f28db94f5a7eadff108e6dcf650cd42decf292a54027a40a45e8ffbcd99d5fd4e7a66458e623bdbd7bce9a81ffe1d6c5da73b177eea941b8cc01c732c8bf66f9dce2148b340087871a941a88a7c6e8a3e2424361739ac1023f662554d01b242decf554691d03224326140cd240f26949cb4b547106ab86c3e61249a556b2ed3243168d0d91c91e731b45181d6b0a7f94c8878e221baf1bcbc40e755a4d37fec81b7c948901260b78dac7a98eda38b91969373332ee4c45a6669b14eeda805154d742b10a949d11cf1a3651a5376c4eebb16fe8841bdae0e45d80ec186a9faa67193d4b9816790f03f00737ff9e207f1c38f1024930d34a12dea7be3c0fb16dd8dd85c6197466b30b8e37efdd3d44808d954f7a1b58febb676b8e3d4a0d74a1469573d47ad08d52fd62b2f8bb9388063bd4751ca5b11f1e448d6cb089fd6f14229cc634ece7091810aa047fc1c125725e52610440f41f5478d03eba752f4604eeb8f1bc2c0828e8c6bf19972b3137b4deabab9eb294cac6452183c6c3584d54b953f27cde4b6ca1578d5405a3b2930ceef808c248843d58f49a3f017e7a64924bb18ba361ace2357ffb443bd62668c536e51b94a8531e76560f1eb3cb848fe2660ea2f8200124c802919768eabacebc41d0796a7c39b46f6cda05b6148de861a9d18f4a618b2130efe5770c1a47f0ff9a9520383a58544c23a906067ce7a91fdd93efc01a8aa38bc167e750681b3d8426ae4b69b9f33b33a80f3df6eaf8e70915abfa4a417fee712b591fbc0cd9cd1348265b422c3c44ad46fa5071c00fd1103a6c137abcf4299013f9ee72c77fdcc591050ece907f4ef5ed8e8d9d78652fcbff20246b14679be9fe569db404ec9ed261d7ad882b4a01b481d35940972127b099e8fe0562ff4eb45a9f83af1c58a824abb369c775b7c9dea454786c02ba00bf2269635d6998ed86dd3581ddbaecf65ed067aad7498589593656d9326050dc418e8a1672f929934ba37bef3b694d2d12a5b863e70c0392f525a73ca8f96277178da61e5d73ad00df23653cd7156dfb8bef182868dbaa57e524936a7faac7e26d3695851b0b194a98fd14cd06e12046dbc8f692d47527184bd4c53a4f4d022059ff7c84a7249620b5944390575129e86a47c0651797173a139f0dc822b68846b64a17a12bec2699baa775faa03f9d03999e39feddfe04ed9d2f5f92110180cc92fef246d959625ab40ddd376f43618f2e50a273e232f9e7bb64307c204d36d3e9815d350fe5e431abab821762c3573e93ef13044b3a1c0ca4b2f6b88c02ce95a611da184855495bda8e03a8d2271f34dda98e53d8a5089e54675631565e10aa42fbc5180298991dd2a7f259923c39a17fd1dffe7a002e29101d58066a3b4ab71d0ee3de4b6ecabee7ce2456171eb0ea2e5d8ceaf1eb06ac48373fb1d19eeb260191dd8352dba1e2976cde3da95c083cef4de1e1ae5ab3227bc65d5f7dbeb5517b16015d8761206d2b81c5936fd5966700ca382887c5cc8e94927be481d9f93f1b7dea1e90a7c0d70f71205f95ac1a2c6b9002fcb6cba12794f03a2a8f39319c8a57ffbe98ba6f90fc1ed8b64a3c692f8acab84199b4ba1668074793a7dd8912926ae53c43323ff7333ef5a7bd605c60ece04823c63e5f732fc09c6a357a1ec7e116faf9514148129f142a9e525887bc3a220fe5f6166918d1333685a082299a861bcfe99c9e6f26c8f284d8f5b0b8b5cb1f01f2d326a4e578f3eb7a557f1bda3144914c5006310600c6aa2b7c95f75dade44e4a623943fba0f6382947156bf334d83de6547da095590266b26d1c42dc9df783dc97d89f96c07852f7e7480bd0cfa92639c7f0c3623e7779d86b6ec760da1d7a954552176ffa646d1c50fc65e00d07b0caa258a7e7228931d9ef8a9ce600ea36a9cfdf512f23649bcfa230986cac02ac2aaf6e14a125895450eae879a56ae94807b5e68e8fb8792d7a5c3442da2e24fc591a74fb824f86b2ecefbdf5a42345bca83318f9c6f4248e897aea0532a2ebba052abc65ad188b8a1d46844335b313304c2def61ddbd604fbc61d672a2eec647efd9de369757edc7504cdc85adf5e9de36747631278bc2ae8010365da4d34b84c8577656a8c11556b3af3b696b3e1a0e7149f76ec066655c05e3630ec330783a45f2b5ffd22482d370823e52fde57b26ddfc7453808384826f0be1e4cbeda52aa21daca43484ad4b982ca4c43384cb9e72f374511c417ccce06ab850d73b9c58ffd568829ee8f414816de97ce6a2c20e3d5e016d1f5c528c38d24043c2c8b57f44c7b760ac4579bbea20110d3b0ae39d8b8f63b2f6fd3cde1c37bc3b2e28f09bf90ce4704d75345fcf01bca52ecf92eea6a449774b367fa5cc92b0043a909a6eba4972b281585a827d01ba1bc17ad631793ada0c62f61f0c6a76686b2a7b0a4146186384060b76b9f7ab7612ec0cef264f68805daa23095c5a46d47ec67ada47aa597be8cbd68864ff7a600bd7d40e9cc51c9e0bde9672eb8555e7a66c5dfe6406703de8f4869ca1d1ceb21d4decc6954186d26a507c0494c83cba9e7a77c58fe200fccfa2d21dce2d8205066bb02ae206617fc6b4989f0075caf0a98e99a5b66163d0181d9446703db0271855b71d4094dd9cd0de5424b886dc8b1df6b589da4a59b5964d0dce4c4d34c1139125d6560b179653db8d1f3fcd191cc03eafa86532ca442dd1e78ed240b3a28dc21f1166e2c80d571216e57837212e92716faaa4ad763abffaa8d25a5602dad7f335ccf78da26b8c69e2c96ff8f849376fdb9e5115ecd2a49ec98e1152a1251f75d01854ae7e1296dea6d91bbb6c96ca873ceb5bfb4c4b9553e187a39b391fc5e0a177aef8d586ff6c88a351c736d945585d96309640e0f8e69a59e5cfe3ff1ef124dc78c5fb9e4f0ce62fdd583218055a32c4c8f66d6797e699ab138e9fb8758ce6bd9966bb859110fffbdcc345efa61d7d76372276a549aee3d9ed9b56ebb8fa81ae346cff17536ac81f6042e3b6ebe42103977fbd0a7a6225fe825011b5968fe6d9ce3b3a50a1434fcae5c6cf4bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
