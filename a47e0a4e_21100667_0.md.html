<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fc9cbbdd9c6e5c438b2fc8653bbe1c3ea44d2efa6d3532060b58f83d525a0e42fdd8e8835f74a8c2346770e62e8f5058f0b99fad9fc06752e2f26cf8ba07ef83793a77c5bd85aa0346b72cbd6704a64f0c3e313766e019bf6ab50a2b2bf794285c7216c00bb11fd1f8edfac0d68c16337ad6ae4101a56803828b9e5207f5c85ca003ce8d51517a42a0ee7c7e09eb771c2b2eaba0e9b3996a118492399cd19a56c815b59452b6a37e4851e874261ac555a113a890bda64d549dfe3af0c8e3d52e2ba191e7fd00a292627d7f1ac7f95c9268b336b21de42e853710006f300ab0807d7a0ab644cc076e4ab133fdc5fe46e88bb33ef903d0be0f4f30c3e73fb953cdca287443fe609c22df39aca0fdac83ce941381c1553838ac8e759f3815b9d2186fae54759ee4fdc8a39ff0d83bc8455a92cdba05121e7e3731b1d0b40ca24e17d1aed55f41ae8de035039f1020e60fdd247194460e88bbebe4162fca7cef4e57b5b64d34c308d3d08c67193ce04af6c345fd8db0fdc70f8847cc24e93a493e4f92b9f2bae85c85ff21c0b884c7423bab855b8990f03babc2fdadd0c29b68d6c9474dc2b2b47b5568bfccb32b772d9730306dd58ceb4b8911d9e7a20ea19d3745a563e2b97de41f3b919c146dd65cf9e5c3bd24f3a6f6e2f9d55f822c1fb0198f55ec3dfedc6ba3fda94cb3480a1bdaf1c17b29c04e28183f3a984b54e2acf14c90bca96681190e0c85fa21f594b42c4f7ac6ff9ac0d20ec00966e122df61a49d2c13b0277d93c8a0c6b85c5dc1d4037c08e5cde39a364c290f56a457f7e26b3a7508f6f4089068d57929323b826c3f1f6a6ec6afc84f9413429e9bbc115d033666d566f4fa8aaab945a2c37afad4fe7fb2b98260964428daf526b509fa9602274b5384eaeb4b5c7f42bf775d1b8ccca458181b67aeaf8a4ebe7de981f2814eb18ef9a5641951947b417d636f551ba873297837f2f21ac169d9e35bcd6b1f3629dd3e2d69b608a06e0fd81ce72075ed5499149732864f66b3f519bc2b839ee572c26791f57fb28c6d4eec7673af876941d3b6c43f4293bbfe6002c0c5e260d6f2fda4c4fca50e26d717d73ae82fb47ec3e087a6d07aa7b3405f02b7ce7c79dbb6419881851df41c9bd441e9a9f58464d78447011f95411d5a8a2b276b9204b73da5d52230485d7c4c27f9563dbf4ff4f094949efef01aae44f7d08f369ebd750e7594957860e85c062aa1c8c89c895e91bd60d5815b614cfb4deeebdb40e8869c2aff68e9831151ed5e4e23a91cf207b4808c837a65001592498f00c97a78c27cd73ecbf2c288528aa534f1652edb4723d6d7aa881c868f92eb3689c28d854d730affa2cbb60667a1af25ee5216d3720f75715bd48999abfec5a1c99390b589b6c690d7e50dc1a47a09b9f143783e73801404ee179455ee1a11bf66790c1dcfe30bc9db1c2db38a64f452005fa37739f9b1f7c953f08a0759b7afcf30d2ce4b16cd77e0b199c4025b7ea0be0d5da566aaca7fbfa4c7145b3699655a7fa2da1e656775f4c1bb87446e603147502f027c4725eac2384fa9742d9fb50cbc3ac9b5d552794c496d090505568f035e36b11c8fe003c5857b3e45668420eb8c11033e93126496f7f4cd2316313292f758289020e03577836cef7756a24c97595d618215e930390d957562374c5a720fa08e724167fd1a3b0f3984d8c1d8a3a0cf10b19574f0f55e14d58da9dd3ceda2551258bcca2d686e4dff1f9c9923545218de1630d104e3bd863441b634c1126a80ef817a8919b99b6e8533e375c9437d71d59a046170bdb5ac83bf9076d81cb55a3d8d98ae9a17a1b7acb4b3608e7adabd81a330f53799eb933c04d5e089a5ae3e318656255abc654460ef48a30d6e69169fad76bcce1f58c576b737c3d203a32ad05f2095a6f030c7ed0cd29dbc9047e2c38550e54874587644238487c234ff178d8f4351c4648da18d6a051234577de641fb47f1896664b64ac0e8f2cbc32a917cefc6e2ecaff2d569313205027d775000da1e9e99705da1fde31d4227fdab99f5827441d4ab1879efa2e05604261b0a87aed6cbff4585a9845129d17fd364e0f8e7a9de92f901f2beafb1fb20fbb08f7f9c59536349edb7961d2a8faa28e5fd03cbb67c3c08416f4eb58e16edf23bb04616406119ede19e2837a400b37f98986d117073ad2312719e9c4cacf6e89a7bfde82aa870240ac6a6fab38c8f1e7a114bedc0bb0023b1d6fef1d6bee7e6a9c66b111eb0a6ae2c289b58c947a3deb1fe92fb8663cbdfc23741444f8a5e927e2730d195fa588cbafdafccb5e19a86fc3baa750bd8e7ccc9108ed706a333ab1ca40b157d72eb4c47309fde71e827cc852f47bc6a416129346fc25c10c8f23ba5f8a9e25131febe6d5dbf2c47b6e76fa5d6bbff876e8474526c932d903f55f047f3eeb88499b8c3b819775f4b70565191d6803ca7f61aa1e00e73c653d75db6879c8419c98ef494dcae6cfd1e67cd95d3778acb68e55f08b75126427d757a28d75c778337a9a10a5b86177017debd9690f44e7ce3ad3e9b28e3ec2fe8ff5e1dcc91b0591a13309b2cc51bea69ffd0fb3c55d6d166484870c7e4ce60e5b52b50ab896349e8303c91121882f18ecb2337cab5f301eb9b933a6646eb176cd046695188bfc8dfc4cfaae7ef553c4c61baaa299373b98a2161e40e739742e06da9a5f20fbd64af500219cdcfff246d0443e5812abefa57caadee30da9035ff482b28e822558d59d8e5a3921207e08d78aa393b8d8ba284e2b42b990e0ed3d3d7b3e11bced7deea33a00f5aab8a754f2bcad781b858f03943090a981a31adce47cb3fc2540b256262d39d6f1e2eb6889dab5d1af9046a5fdaf5f8138ac71e1f792e29d41684aed2e9faf174f8c134cab1dc39f152fccc5e7fee312955ebc10960650d4f601df77814a65cd53ba56c492c3fce1103a7dfd89e54fa65b4c89ab71f761c218f508b588bd6c283c6f7ebc7a4c8cd6c637c0b06af55570b167881cd2f527d10dae1ec94b03a308ebfe5c29249d5f0af26cec4608c9c55baf9a348fda6eafe85be74ee818ff99940ea0da0b2b33885edf497ee527c9fc9a58da84e23af3ed1e099e3cecfc3a3653a12e20068598a177e068f6ff5fd32b53d0c876b5c03e5a4214691d754634ffe4851f23cef59663368cc3f6abb80a4941bef912baaae0e71479396350411e47f8bd54fd7d1fce0c5dc3996ae7981877a2f64da35a4ee5b1e54ab3a4a8536635ea05db67301bc36bde76634f1d8166a0e7f544f0218e6f1a7434da28ab28b631874c796cc99bec63639937eb94be67b1393b36d51792066a7830fb6e62a9fad6df6a48ae93b411a8e2ceb6b667cb076ae9f61e4515b6f1e16298d0a952b59d50044a36fdaa618c367ce3f48642244ab807d39fb6e92157f989245423813b48f69090423cef9f255655003cf69b9f6da8136174a1fac61b8b68805b1e2103852642dacce69c6c3c6f38486f798a9da3c2edd73b125e86321eeba6b332033496f8689e8cdc5c8f9f51a44e6010eea7170ed6eb77a66954f11040f3a4021d294c376e2b08ae5c1252940b801fa7b6f50fe554c826ab74642c781fb823d0f29d40d39dfb13e7bb7bab3a5ca91f639e8a9cc77a6428bab356e0afca7d62fce2ca79718a9b844a24af20791d8522d8c86a06a5657274aaa22fa070322afdbdd494f2dc46ac15b7bffe1155cad9a3caafeca35044e508485ef2d719c3f86c631b77f1efbab15155038c00dd7de84425e83330705ee6441afba419bd8041bed832aee979c32642d4d31c24ca353e96292fb57c7866f7e751f132445e7c0c99601d71f76ab887110b2f8f2e31d7a81ff41e5f57c690886fa75c9eee5424ac0a3d7c037622e7fd7e5e0aae6d1c7cff8eae8e95e79f1c17c8e261ad661a5fbc5deae6dd3602faab8b637a788f81161d0bebdaceaba0df7f129ea61224477647c9f7443cedb439b292675aa115ea7e5d3b3bd1fce475cefcaca8b9f60697d9dce55f91ec57fa007e3711430d28dc1afd05bf01496e6f11167ebd18dedfbc77f0c280e88629eb7754956f0d01d276324293ff3ccf916f3956cb6bc90d333c91109e6cb17a900981576461760c5925f6c52fa99ed41da358da4c00547c841807582f6379364a8eea379f68c5f78d45c071382c23f6c896e0481f9d8ca69c0abccfddcdefa986bfef68eef62e9d98833b29a37a7f458aa1d88e4ee6742035c389e9387734b500b3343e8991f3019c809c33431d6a61a4d6627d94a4aa70a1eabb9844603137be48023d5b94cc24b33807e673e0695244df6f8e749231614b04885d9dc56e261551bad13ce61ca6cbbc6d472548a8506f037a3c740269d28cb444a6f9d0bf948c52c76bd2a6588e606398949a1dce3d2c6a094396f81600e75dc114b7c85c5bf04822160707a0b7333d3386b849640a2dc914c9836020638b743a48b3ca3aa92a564b0a2bf8af1fd28796f1bdec6d97176fd229cd44cdd6aed5b8cffea5d5cbfb04c0aa408fb61ef068d119b759777b7d2bf2d16897a567fc03077dfbc9684fe4e1330d9e78369a405a5167910eeef32edda06a710f2ab1afcfaacd959ff5070fedfbdd620381fca0b2e64f5e8aa7617890715026e06237e54f15989d8ea6eb1eac6d3d9d1ff8109c7e6f9b8ec959ba5f77f1bae4a47e5458bd0fdc014127479c2ac3d2f0582e35831ec13c23af180fabe8f8deebf0f19a755b4cccd0ad77cdb05f5d2466ed86cba9a0dd8876a26e3a2eca5d9d3026b442362c62c41734863fd823837f73463bd6b60f9f6d8f71b7978bbd32c1d06559cf7038bedea3bc47b9cdf0197cfcacfd3cf982a4008fba409ac19c8b9699dddb38dcf73f0b3509f49d7eedf8bf6e85001bf59df3d7465f8f0fde6160a4910172f88842fb8b3b290085c69949adfd3f28df06e4d558335419aaa7492872de666d23e5e4faa1431563474d54ab9bf7694fcf7755bdc2d0aa314fe68b37efb141607ed33f3ad5201b75f29f1a055fd5024f48257a3d8c8302f37cf08906a2678794cd0058e012d3d55a6c9c97f1f3e0eb620eaef4c99be63ff9daaeab83c69aedcafc26fa9c60d48bf696d952793117b23e08971e472726c9a69085d99776d51e0e018d27db6e9de485de2260397c7221338af6a7d5a9c48c86732b35547270792acff3f261585cac9d1284ecc3b782863a8ce7244a242407ea820c6e58da0a24e64e93d054b2e4afafb4b5c11a7b56f65b3803a3d3d847be8167855a4058bb82dd96225b7efd2b7259858635964cb12e034bb7ca6a80ba62a197d65f814cefa0942c307a5e16919428559430e949a851521465f1c1be89b5cac4ea0bfadc9ce16d4baaf1e282c84b79cbd28d2ec7185b3fbfd738dbc3af198489ba7de54a285a25ed3dfb5048e02cd0b906025562198bd89f5544d4a037ba70f11c4bf072249ef6f010c7c1959eb338b92056b9047a8f1779a0cef7ff38c95704bbe20a230ea43c14cf4579fa693ebc30808caedda341bafc80901f1624f4b025339424410cb20ded506844abcd9892348b87776dff4b32f1ae7418a735beb1e3b7885370aa60dc7456cab911cd4d5aeb372be96f4aac1535b916c200d608db5db00465fb3f3d6262cbfa604371a06721fdeadd4c277e0d0345fcdd235e2bd6ccedf64ab5c1b50ac9856757a108c4e8e35d0c3609f5a5592dcef863ba53aa03d18c05f6f1241ae8b68aa10e24d366e5cc734b7342549001c0b287f3ca385e5506861a7f2ae634d22e014767b8e5e43118fc7cf6ef6d9a3efb4019e3f12c1a42a3a4d804c0bd4d4a9607ab1cc3f5ecb427a06ebbc27255f2c85fd778e0e0f3ae7f059249490eeb50f8048586ecdef53367a5ab54e06b63edf6c4a2a39ebf67351e27ac32b614091e23e4ab5c6e0e3780de58685274ba06fc3f4ef6fa92680515617be31b50b7a9bd1eb1b3088ab5efb8b13828130ff3eff4c9a8239599cad1e51d4a77514ecd236638435275c67f0944dcbc9a397a323d4d6d412c8de6e3a6479772841555ff21ba56d38f61620b1c70b3f1f78af1584b4bf5252b5066466c6bf5fb4f87c93f498aaccd576ed6df04b2abc01b748cd8686b9d73f8ca3c8c257b5ad328017a258ad85cbc4805ea07419a6ff2882276645ef3b4765745054ae60e0e0189ab479277ded5def55790aca5324194e9e2e585bf7a4e50ae0aec69996df4f6ee9d23009dccdb6bf33bf9e2b1c46dd049aaf3b021d93e631e993f73c38f613cd83483c29b693584ac62505ea58d52908e2dd9e1b5eeda127e0a8e90bfabfe426d1627878da7fcd20af3c9451dc225b869ea7dc61798609580b6c5ed639c0a5894a86ebf36642581becf90c3e40325a2d9f1dc10cb8a2330e01eaa03ba977d837c678498dcc14f737563b54a5afcb8bd48a0e44b2a20c6bdc20febb1aadfbcceceefd2d5774c5f4f30b9c5b70ad9156d5c0a3f5050b4db7f54d575c606ab2c57413318cfc9c22a572d7f5566fd466e29ee5bab936fe52309894ecefb889a51bb62fde643c638e1442b539971271ee6405bd6813032fbb2169e4322669dda37f0ff77773528cb6f42b0630bb306fa9288e0aed8fb18f9221973a7ba0490dbdfdb893b052eceac0917f4575f8b4632c94e8ab445562aa99ee4804de3de5774772d3dbf50b744922f1d658d92d817f552ad2dd040b7760f2e508553456cfb78fb14203409d2a5f9562d2ecf7b5f23581e5ea051da4b8854502149cdc7cb985d14179204747e8ac6e8bc46513191027a69e107f63d4ae7538ff690c9ea07dccb36f1a0e715aea1f053d8df93c4f16cb7160ed0682452bb26b569f25b6ac29c79b246af761d10b74118e6a205d78d761128f760ac438c1c10cac4bb9117bbc38f59a6733c557b91eb497a0f029bd4690141f733cfd2dd030cad7142113af7c370514d90294fb2ce924fdf0b7f2834cdcb0ee0b18b34eb17c8dde480df147cfc8c7baa25ea578f8e2b44d747dd83009683e4722c23de81880aceacf21ceabd0ec22ef1a35eaae3d47fc505fd2353a0b387164a87b063c99851ea3c3b9e7e205e39b05cb0cbe37cd360cf6e1afaee26888807d671d8abcf68600f7d1bf7ffa7307440fef3d56e87db677ed37be9411e8961f61beadb94e0a9033f7a26c3b8d8ff202264dd35a6a3070a16dbb7f6a87577aa6ac7e48ec72f127777ad9e851a4a155d58d24d51aa73a16591a2ccc551e127297c5f53928a00679387c3497bf048519e12958e300f510855fb4da148a32ecf06c05e732084c51d76f8da154e59c771c7839241b713c4bcc851c078e8b1b5e4b81d3dab4dc72c504715a504e1fbacbfe9e094af43a36ad840d536d05f06d22148af8893f3d832022863941731a273372c7421f5e2e26b3ed2a7494b96467824b6913674c8ce59b2f2f07dfe6068d13908a5ecb39c6993c17a26d866b0c0a26afebdb97bfab7a6e244293d369d50e33d37bc73b4ec675d17efe4a1e63b88682d5d7125384666e15db036fb061b553659150edf25ed5fada0d9f20038651c06e51be3a29664f1ae6fd5933d4f332793bcf5125edd523de89eee00453e462e81d30dda9162ef84eb2d28f9ed436621c7156cac8f984fd1aa38244e5fea955601ee5506a20ba783c47fe35606c7ddfdc6a1614f47b2fcd29779cd98414f5e77564b5f69f3b925294a25bdebfd48a32d62bdd820484f76013c15c5015039cc082ab2889d9724fb863a6f7f472ac09ef7ed432930dcc238af27897f4ec879747c6f777d11da4111d3095066e4575da6fc29d0538b0d9c5c0b5966b02c41b908ba6b9adc8c5bc63fa4e35771a59bb0c8e64c9b2cdd25096b0d870fa695d5d390b15f69c48e22b4af4408318f03ae4c702ca7047855e28f74fb819db5ded3d720af433babfb427af4ec77318f3086cac1eb23236e5b144478f098c381578d6f0ab988bc88d090aefc7a01596ad018cc8445c5812f8667dec6a2ceb46074dc1ed88a503eb5db33ae0fa2823c5c92986d6952990c4479058f7f0d42635e8c4ee714c9e0f0ea0fe010d92a3647ec6f467b1a7e30f712a0f8df7ab619b783b8f968338e47f452975c55e19cfb206da3b60bbe8c1b0e7ec2b4082105262ae9922486e96108592438fd6fa410a6010783457a8b3703a560eb6a93bccc615b72b78465050fdc6492c1f751721e3e9dd80e90e2575f5e9050698c1e18e10c08e6e252f83c44921635b4430d75cbc4424574648f35917843e26182872fa0bc18286d672c0790ffa89f459f1277d68d3e58cc462bf346c2a00ea0a253dc00bedb52e243e9fe1486fd6e6e801368472b38987eaefd698827091a02fcc142f6232997dd565355f73412ed5d10b71a81b0a41d9f40d26da8fd110e1d1873a81ad673a7fbc39e8431c8af0d652da2554e875ff3825c2a22850b549d0ed3d6ec91eae6512c9b1a23d545224b23ded92b99bc6737102511bd106a091d12b6f468b9a11bea9d269532661445bae7f897dff4ac0b7147de0d6754cf87854feb0ec4b5683d616f23c8ddd1270271df4b57d2fd0f0eaa3aa718a0433878c2423f8e8a3f6f3c83bcb0ca564dcedb44adfacf26f38fcae7b633333f94189b522f5e2b51119b14739b114e05b05bf5b585eb8e5db5375d161daaf4f92a878cc9a9ed3a4cd5d216f11c91931455b22bbadaf7806985a7c42257edbf7cd150607ec9a0b312eab548392ce063a6269a6b4e64983daef4e51f664026bec1354dcd4de91887b85ef9f3af83966b681131c6ed51eef90ff663cc06af9a5bf3d5989f5d47d374365186842a3f84694431dddc7fc26a46609e1325d102dc26924829b2ceea3cc60003bcc4afbb7a21ef6d75f8eb0f48883adc00cfebd384426f685c24e74d28276c0df4c300eacb8269dcca31d46d3f201e1c460d2fb7e4cfb652f8923d94e4e4c8cf3d8f457be55b5c49a071b3aeee97cbfb9a61bf96081a6448f9cbe6a064a4b6d06547fb61ea8743bc11bf5cb81e62cc8071861b890e3c11f1730be697348bd0f7d67346ad5f79dda5510116575c5f8297cdbc844e62f2db79dcd6ecfc517c7709917a1aed1b95bcb0f626be2ccb1edd198d77b8f2322af848f65d65025601b544dab1589ddce558b65b4db62371d380e1e6f58ad2bb382471c7a01605066fcad1e23133f581738b62893d14ea81aa23c729b67bd3e9ca8ad35409986a9217ac30267bda802c63076ca48280ff1a36c3b34060eea2108f8b5532d083439f84871a7c4459e2f446db1adbe7ffc1a12e0be60344aea8ae005390917f07a0ae27173d5d66a1371e9fe78b76ca80ba28e4f885622f8973841d37f285c2ed4db9ee379b6d6e4c4d00af02c541b05547e48e13e01d4d0c5900f3f13a09b5eb21e6c9194da2d2fb761ca0bba439b5b31eb4a33a1352e8dbeaad9c7f875f36e9489f44f6b703c2bdac3a87a97028aa37cf4b34d259fadb15d516c721c5417a434cd87903ca73bc58a23285270406df2846b84ac560076669d57ee5afd97b6b00008fb50b28b0a01c310f10eca9ccdce728c18bbb169b7fdb94f637bc08797bb77a570888e29ad63aff2d36ac61df8c3f204bec5db1a055db70e974ce0a1df14c89e592e356c61ebfc950c2210955335902678e3fc94f97e01d7201c800d9026ab8bd38d57641dedfbe2f07d6b44e591bc8bb1939aa9c03a933775956c3bbca62d07e7b2dcbb6a4c37aa829077174b43720a27a14ac1f61f172f7a680ae33f05c63b07a4a89c40a5fdd7fe5da8198865f411e322e04516d249488fb96c9b180c46869619b8cedf39f1c7cd4523384653b865202923df462bb0f5be568f97133a95c9473e63ef338fcb7565c60fa1473721867faf15872f7f8cfbb6301e6935cbcf54daf13deb4de5935bc1246c091ed3155d60e435df80c6df6260d12b3e1e077a5c1409057aa8770c550560f72d87ddd88aa547e21e609011bc5bae03577a387f071e8a881d072cbf3795b501d337173228fe58de11a851ee6172b10ca6c00d9e4877d53279ac1f2684d71e76434d664cb946ad528e6b489edfd233930304242207f7aa5a8bcf895fec85c4de141d69553ce3bb80f1997dc7a374f45a6a8058cffecf0ea5ffcb491e89a36473faa8dc330da76b017ca69d624dd4d663414d520a2a24d1141273614f9f7fefb922dc14d60bb8bba1b3ccfeeee828fbc0a6fc2d5598e6d2d5786d472a2c692fb442ded5cd13a3f22814789e994131e7a6e617457b0682fd9269db0759fc3995672a89507f8841f3a87db045b749640d4041b07351a14642fc1ba5a9e57761cad7c0b5eff67b3fe260583b22dc0069b2fc4d3f3490fbef37b81dc41bab3786ab28d54799b1d370689942db251e72a6304ad3e53a15985678a0ac5564a9824e6f95efb6ec9c641179472f48a2df75872d88114d12912e0e38d269d2d90458428794c098a9020df5c6a4e514461f649494e04919ba1bf75656c287fcded75e5759b00e763c333192c2a9a3e2de45fb523069480d0b8d7e425a549a149a5b08aaf70420eb1042c3312cc74c8620671ab84c6727528dffc348eb1dad394c283ff10754204237307835e2131542697d6fd23f3a7d3a91e667dbe5032560ce271b6400a5bb8037d5968dd39bb6490b5f8bbf8562a0a17fcaae41a968d6f88180b8e6d371ef5d6bc0af93dd4f83898242cfb439554985161db912d43cc1cea438ce3a5e944cb52b2b26eb57e40fcab6e27d060cc213e8b61449e8cb0b4aa4ea0d763196a1e22eb90a7d79276dfbff2ab2ccae4ac0a5796d3322a4aaebf52f9828669e5484e099f0635ede9afe9943e36f65bf0e4427b7a2cba519dbde7a4de3be205acdbca126e63eb784ac72154ca92cb8d43206cc378f01ec9c1ad6ef145d808571d4cf58328636a0aa3332cc063cd664b84bc6f985fe0305b14e73b4ea85ccc89a0e12b8bc30561a5b403bb6a16bc43ed9e9d46beac13a276f2987e0dc184adc7f661c5e02f0af98e45ade63dd83e06ba6dfddd322e1c1b92eab0bd8848e11f89f9a02d09a9f94578c30e9b6008474b2bdd1a1bcdb6ffb6a7b179a90b9ffa295534da29a814f85b4c3bcae943bab9f6d0d50b7cf9efca89ffa23daa5abd3f5445dbbced562e84f1f0d3e6adabf1824d8b5e017aa5051a6528339f72a6fee541623a431073e0e10d93c2cc2684c02827bdb916a93525e6127e8b1d069d02f6de2740815bf0991071bbead9c8f38c1df47778981f97fb325e2f8c63c2276094249a33bb0fd1680e654249d8ccd302baba3810c5b51f98fa435d6c1dd63f2853a044c02e21450ba9a36f51cc39c661f6c120f2e22f5942695470b621d513b70b2c37abc00bb2c807ce5d98f47c5de78dcefc654a1e75a224273763ce2f9a0e7bc4ced4b60f31ad66ba5a668082b0ec1b4f1c7648ebf7f05ac5c9e61500519845c9a0c90edc9a20bed85fb7c9bb7ecf30a2c77bc6250daa18ecd90dd5268ccb2c8a21c3bb754337478909d8ba8c21e2012cb19d09892cdbdf3f1c9e607a1c909f5ae105d14e543ce76c4c7091a525ee728baff0ecdf1e5b08fe4ba531bca14dd13ab956afc73d1e2778b1301f2f635966dccfe1df972d565a223997a1e36c1b17cb472317d742dc7275802d42a5a0207f3ed22d0abc79e568ab42fa680bf62d03b50ee6d608b665ce3f2c4bbb9bceb2d0bd85b18ff3b3e2e312ffce5b981238d91bd00321120d45f7c0fc9f60fc7f2384be6e51899dc5d29a89c958f5346f1e5fac2a6d9b84a3b6d699cfe6cd0c442462def6c01368de1c3ba66d8d9f9150511d121d24e244d84da8ce81f634032a6be539d72212c91753b47ce1ace9dfdc5e1dd58cd162acfeea1d63ddcb33f78a1ac58e94c010fdeddb4327baba204be5590aac8885e16d69615aa0e987e92a542c1b9556507177b5ab692a88b16a120d5fef1d9547f01d86fe13f54c858177892a6ef80d1579e6679e816ee0ff348c85d24853a9ed0a93de89f5e5748fdfc6724a5c428f408094eabe8a252dca845edf967d2d905ad0d6d479a5daf88ed986f3caa0c4fb4d5b34d6d971bea3bceb1124c3aed838556cadbc7e58fc1ade4281611ec43ad1951190cb7adcd5857b1d22116efbdb168bb154debc3e7e2a8694656934a756f31aeae069e63793ded173f2ee3a1570b91e6f0bd62a772c8978b48f9fe591948ee6359d1026e8d0480cfe9540f418fa29ddc7f40045e89f95de82b283eef2e260c407443535636477b78ca9e8382d0f3a2d2440dbd63f02a43818e58491c5aa2774292e5652b28ea8e40db1dfabdc436886c356b2570166ce283c9ece843a1586874812d8e530cbc7078d13374eef23ade1d4fe6a41398587588a10046958622024d2a66e23424a316d9ff386d9d997ff329bed244c197aa0511bac96dea297e9fae0a319989479e6687f4dd4a03fff645d9a5634ddb40ec386e441d898c80f68ca6a89f60bb80b3db04036ef216adc96262125a846f7b77ada3b037f5443e2c8ffa20c9b819ba5857c5a2e5cad1573eaf2bcd835abae080a756696b70e7fc49d7e40edab84248af7e7aa3d49fc3f5798b62c849e502b90ce8357b5896e2e1cefc19bf8e6592a817b2c8770085e851819c6619cb94edf9ebe4305880c0df3f625e2854d11120b6278d971478ad2818a0635b12b916c8562bda4a4b8fb2c85caf979a8fd9b2956e77569a450ee3b008e671227acd0b0b36f538cecb8e1189e2cb6cc56f281756e72ea98d5f1bad724d0fa217f9600bd8cc19f191e48c4c1c65efc9ddd8f91321df8ca338c53079d9e57d003252a779c22b76281667f38e958586ebf28df8849a13b6f73e4ad9c30ef6e67b53f3446b1787ee5f529d64c597365a1766fac23a967e738b42b55d5b75590db8529a4970964a14e61e1aafc7339ec907c913be626213f181917a816d888de6bd8bdde217ded796164decc3fc2550daf1101a6c1701c083e8b6d4f7558a445a9b665bdaf97fbe4afd58fb5c8b664560389aa57c055c0b3b8d6286660ed7de599e1a4a4fb3456b1b6ee928b37042f07eede07edabcc80ed56384cb847dd86bcd10808af366da4846b70915d29946193493309a4aca038deb7469731e1eee82ceba07df2aeb3187b601b9920786af723f63ed1fe9bfa6327498b6a4e518d06a1a2abef054959e212cd99a5fe0792ec524e8edc4a53aa72fb2206677a8ccd1ce5ce825b0bde0e3d6777e759ba73943b87e4dc5d417077a0ca5a1e40f2e2bbf5abe28fbcbf3e88eac26325972eaa8375b0b9743be7a72936f98d1ed1d42f8586b68d665c641f9ac3b393c195a6a3c830d79734646773658d5de1e83c0088e6597e78fee3aed7405cee32dfdfc7b0aeae51239b4bf944252218590225822202e1753347afd975e98af2ff869b6f89c14365b7979066eeee8d2366ad734c19fe10cc1aa436c312d5ea5275c3e8196683b6a5b1a02bd14e3889ff1c608d38d991765b7fb965b5fd088b648a1d3f800297b678d7ea2b65f54ac55e023bc1278ca07642d923894d70d53b36b4281248e26c1df82019df82527e73a4af6d0f781f6e3a61b0a548265b5919fe8438e33fee4b0cc6c80aba2e6314c7d363154ef7e71c9028ecc68484c62175ecd249a1d50fa7892ee0c3bf641de5423c2d7b4530ebd17ad231ed7d1cb61a3e086fec119df8d9d63696c70ee8279ed97ad184277e44e967304176e0de527b8e34e1726a86f6dcdfa93aa0be1dd9482022eb8500439c122c7518545d79b32f0a1ef7b44110628ceb6dca82b21d25c2116b307889a32eca732635a6be9b3cac43890fb4e1a6332d18ac346c91760f13f2a17f5cdd30c3b14db03758bfd40231ae11ffc25be7b4c33e9e8f77528a3f410c0098124a466303231de99174201ab7daedda0d3ef696d4383b0d656b37b126d6d26f2e9d9d69969216d777fad43dbb9159aa230a0d3465f5e53cff624861bb715b40715a434051732ba6931514e73bc65992254d7042976040f3d5a088b6345ac4c3898bc6aa6ce3c0f7e5f5454ef9303a86ce0acef75c9e3d677fc2a8b8ee55c0bf0e506ca468528c3824ead9d20210803cd6ec2f06285e1ad8810ed6a88374c40ac525b014f4aa7dfad1063414c1a7feeac7d5053ff60f8b8863ff19cda12c49b175518c775a8f6d70b3420f9fb57f18190100ab56f5bcdbb3205392329c9e4f4ecee5c97c08c3a410a026e5e543403e31554b4c1060513731746320fcb3eb50512c2e647eacd4fa97716cf033c6d935e75cc4d309b01ecfe094c08206004e38a487533cfe588c17aaa2b5d3b67f0a92afa49be0cca0d20b41a6d4dc49276133abb5e274b7797380aa5c5317d08e560332d402d16833ca391fe781eda05877d5bac26b16df86603660a880dda7a5d7b4fd31064a0cd26207a6e9f0e0f34636c2d4a1c4fb0ad70ce8143f54640310b3aa2159ae287f5fdfbf949e56a61b096609317d84992efbfea67c1d30698d11d2136a9e6f182a315008396ccbad062e73a011ca2cde0dfebce1d769eb11465926a318e23586f418790322bd62fd75431a4e571ac78a97071f3e9e9dfa020add0cf22953e5eb4a8bcf35ade46a4f0d1995f37e296868617add3c2b67982bad0ddc9ca9b2647fc285b9763705136821c51609036d468dfe8d43b9941e86bce93ea3f32e37097ad832fc54d33320be011497a7f373709919ea28ff12b2871374b1cda3e8363fd2a790eff20e067365e79bcd782ac3163e7b5158039b843052dc6e2044fafde158043ec00dabc7da3160be4dfb1053c9920a94fd1ff99d89eb2db4dcb1df06b7c25dac848700e04c845367ee5c08621135cf78958d61356325de5553d239e91c871e6138d794bc1884d7e58af365db5f60275fe4d0335c6bb72ffcfe7fbfb685bf6d57962fb79a65db66e4a27c3ad0620aec92f60603fc54121740ba70164ff997a5dad33acacdb9d2f442ae2543318d4e3fe408294358d4545425edfd379ee25b659ac3de6468ffb9ce4214326c683452ee1be3116c8ac72aeeb6d352d003dbaef185d6a4ed60a77e4682edd1225f4e9142d55d0533191f6465678965a99eac1abafcca927de873ee5f8854a85b5b719309c0f3431b212e53cb99bfe34a1fd5a0f6d853ecbc7ba0060550d0477ddd39fb575593a61a4c55601b50980061ec2717472be214de88dbb25617a8f7391ed4a7e217699c0ed419bfbd588e3312939d555a56f549f9fe3cec2f460c02306fbc12855b6c2c616edfd8db286f799b487ffc73c9acce20dce953b9eba3ca6ca056d4dde4185e78ad9cd6b67794f84bb29123ff54ac7b465117ab8bdf593189365c6500df869a7b89458aa53bcb63d8345586ed87bbac4e3bfb2c2d1ea48f972975bf8f3f62ca3c42f0ecd919beb64016cce7a7fb8c7f65a82344a45e81eef070d3321ddf9b150a092cc884356cc65938760fde63c1caf3c507bebea67255f6fad974beeeecfe0a3a5691801da584ce5d1f249e260cf60858a3f2c45e750b9ec2838c245f2432b5733c42d043f53b763a3ca09f665bfe86f75a35060a1f4d5598f5a26349f5ea4ee973be02ac89e9430b960a1d2434691fdabe95be8f20e664bde8726d9f61b11c0082248cb6bba551e9c22665ab5825ebd799cd132be1291574bb62c190765c9ae8ef8968b6d1649196e2652a7a37ea7e525b4fee04a11644780a21a432f7cd314b9119fcdf2bf4d9b84423c53e1bf0706cae63145884499b4aab51dcd4c32fdc354420ed934b19108f7a40037998fc90ca6b7fcf39dfb54c90a5b5e15dd2dbcea3b208a1d1a71a29960aad20d7da310d74996f570fb81da458cbcb6bad8fb16d45a2e9f05a2e6b743411990983abb6c07b22e2f1dd31311e877bd611060bb781b792d1aed2847184297e5860fade4cfa8a4f3141f77cf172d31428852f27324290cdb805f15d316939cffd44fc7cea7cb1428f6425488e7380590de324c3d60c28f5f82d83a0241a723d47c7aed8fa5f14d54612cb1f719f6e6d1bd4e0c4aa0b147f22b3428ea2eef03eae96f1d90e0272df8df9bbba8e0c1b9c96ad0318ea2a1899aee6af71b49a209bb5c3349237cf1acbc2b78690523c911618a4c8ba496048235f812efb12da5d99d5e7ee80dc921d4eebe02bde8863bc248ba528f347f8e7b9787ecd470daef41aace0836803052ee99d6a9ec9287b76005b4d18a935fa98d26b4abaab2bba7cbac15303df50b708560b190e7e08c48ccb71869c0b0e96f0bb8aa3786ca58d6873caa1aa0925f3961aa7404223e1284e7c1ccce74a8d2162b83dbc0fde287f2892166a14773379c7b20b39381b538d8b3956e8592338953edf9795068f68a689736f61134568fc2913d15529404f378a4e597645877bd4d5e1e4033ccff33479da939a55cf0307004d151df5788b53c1b1f70488c9be642634377103a4434793a05aa04f4550d774ec50c55ee069baf8da0c66fa2c052342a6341012f5a7319dbc7c2a97c2572fc93e1e2b0c9b26bbd27369553491a0cdde22f403fce857b563fd3a0614a2393d13fd02a679349996bfaaf39a0b5b17d35e13808f68afa318aa0d769884b9e89468bb5e09c7db766d7168f4a2ffb18cf406edcfa8239b0b7e7de9a6ded75e7f59dc9a08fb07639f0f9b5f767a09813b08a3ec807a09498ddc6b893224c3895b8fb89917e65775a529027fdf6f814c0185568433e3b0fcc4abf2b7acf6fa8d96f1302b16eca6b9c631e2dcf748035594e649a12774c2132fb9c40f958bb7ee0a66f9ebcc5c99942b78e399658e536759f90701e3d2088fd64724add6dc809437691a6e5e745fec4ee67f2b25917338b865a34b4ab2eb48f8f30d57b62f9d9ede22fbc3e3e7ad69273bca3f01ac78d8403adee382ca31dc5eb6d1f55dc81807584ee26080c38ee0d90123f515cfb450e23910d0309e525cbf9a12fa13dbe570b4d9457d4da84ca94baa05b2475c052f28405873e9661647c5179a44354f99df3f48e3d969815b8c0fb90382bb37d7f112d673d91f11bc3e79023804493a0ba60775bd150df6abb3c52544f5ee011a80d0b1bc6e3c568c94db50903cf916d7a245fc8aa427a6f4c7358ba8dd437f8e47b0b430b75a9bb00877cddf087ffa0c57c69fd5cd815878e768f41380180c654b19da16085db112df803799df24ba913f8e0ce0ee761e2eda7822d55271e30a04db38145027ff134af0c9785c89c3139f841523813ad3f2a4021b57dd54def4727583db890af3a9dc6a72d5d87abf70c63f80eeeb1e2c152d80e43b7cea49d77c4a0c08d63b5314d98927914999d75d60db0d38fae79a4e4293fa86ac72d1c5362b7fc2bf4024815809b4df89d3b4bf28eda68638dd1ff51a1dce2d86faac03f1f7bfd1a3f78e12cdeac3d093d443f5e3d8bb6d92dbbbdd7af0027365d439bef2413c114d60f3ccddeeb0ffee13c52b1465aa74ccccf8cba19928dbbaa6d2d3ba3f7379d3d251f4eda8f1417c80190b9731e96e992e9dc42e52f328616183716aa8075f3edc44047cb457d14a1216596a2545c02cf234062d78b56456535e8fdff2a897c3805b61606498dad308988edce08e89ef55f094ecdad93d4b66834233cdb29d3f8bcf7615b6a3c10de89086a962dba3ef7cbf4ba98a17f75ef13429a29c52cf4cac69492c79b7e5f4f8207ab027e2a026e227092b65c506d22db6f8e0ed7d1de8beb6254d93b5f5bd546074a1f75807e5d0d2cad03ece8615153a198115e4f0abe0d144bbb38ce45953f7bee80162a0b07819d072a632f8ea3589de753bf98a68166c43a24e324483bbb3057c6df9e3bd2be66688f2792e9b01827f56ee30e0a59166958cf0110a342de71e88c042a167a7c3855bb36882d8931f633de620ac93f65cadfc86773e3982ef454d56b489f8a306d4aea887282ab1f038fc4f6d3eb269ffcba323582f8a8eed151516bf0b5ada284b01fc46112907363a7cef55c560b2ac7f271c50f7cf12b7b4e4ece4401e4ed857ed2fabcee8cb02b05c6f0fe68daa05620213f08e05b86d488c95ba2bc3cc3ec224c3b26bb09f81e8b6e19db8e60c13b9f6eaf92ca81aa4c5e50ac0221167a6b75e8dc35c76cc06f8eeb22a544c47b8d7f195a29b381de123e2d79efdf65b3555932656f7dd63c7f2f8ee4b05cd1ae2ce2bf8dcf1beb17eaed0677092181c07970def8a64052013a92bcffab14cc179232550e7969982e7a11c234ef62956ddf93e5c4da1a0281382c0e3e383ea03113a16401c95b1f19548e1785d99a19654a24c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
