<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"661812ee52ff2e453a044d635ee6df874bc2ddd49cd4bf21500b0fa1ecca7121ebce6b3c5d6f1b1abe625eabd6b9055a9ae9deaac457b38ac980f74695a776cec890c1c1ea3ad5e5decea12c3822d4bdbe5c4355d28b01ef49ca751a229c388c38f74d6473aa3cd34a9b446955d39d429b4b73490f3825ec6635d861af429a38ac3cf4cc472465f0ae6a8e2aa497667235e936a5664f246b048127164b0ee689d9f72a027df937224ea755fbd7d4966f4e429e65c2a3dc1e236cbdd03d977b2d6d206a41aaab021315a1037c9a4b86c5dd4f1d419342c80e0ee6a3f929d0042ca2a3f7b71382a98dfb825d8ff23acc5029cc85f1b83b8415fe48a4b2631a787e45d4b3cd7b287664c556ebb8edde83e2f7143803535c512a87a10280dcaf072c0beabac0c25af3df3182dbfb0c3a17c57d5202fa9353eb2d31d2223ae9f1e97e44b2c1a351fef7424c35fc1a8f7fba8eef028c41c746668571c336ed390fe0b46610daa192a19e6b770b0dbafdddd647914b5446d37869a80f933c7c51f5af5590b503aa689533d394735f73850ba351053abf05eab31267cdc4391ffced009e4da4b6507ecaa47b8b267bc4059022e47da5f3a93bd81810c8b9057fc5396640b1e2e96333f71d4059de538fca48cb0cfb5356b7e3721be018015233619ff3a8dfc4c7936347cd80564cb2df1f84a945c306413677922a123e7b7cfa229e48f9831592d18c794902194590581829c8e366f7108b7ca2726aa6b40ace765c3a23410b0f79da683fd4c52f529c8a7d2ea6a9e8796b27bf8bce022c7d0693ce0fb6bdef45243cbd333dee781f467a488ff42595b392465842fe2c9137953c35da88bfbfd655c6290a958ac2284f2eec37940aba187a7ed28bd574c7b40e611a0efc875383cd0e3500033721bc6d75dac03b2c6a729bb40d3b92f8ee7009d59a6a5dc69ae73837c52366154613c65f5f4ba644fe1816415340999d3ede1f1651867ff3f85f2a898c41537551994f72af14c749ce2f943cf4e3ede5ca8b37249da44205b0c7038df3fb1b3e576911383f894b1f3389b8428dc6e4911d0557a36802f1a0170e626d987e1972d864ad0bb35f72d8cc2b66f883d6744c6dba9b1bcb8623109969657fa59faeb1508073ffc886d54b66b830e5f50b149f3973bd29947e297943c125019d24c407e04bc6db70e2c9e9adae4abe9602f2c1f9814f438991c2085a22774d268d80f7720ccfd7d090a03ccf649da0017fe565be702089e6754fc289a9cb2aac6224205a539d56cf902ebd3fd139c2e127fe8c4a78c4a962f0f6249e01d27813508b4e7bce7ce4e5202b8b5e8740bd501b8291d14454c6810eb089aa00f296c63791847020e729ae1331db89b1a2d239a40986da9755d819a57c9283d6eee55c4b19fc94699c10793272f4a351e7ca0ad6d763da5de36d98545b4c47466b94f4571ca67229d937f02ec37c23d4ddc743c11685f6d4e6c034c5ef744873ff9a26b96805f763d518d510d2c8cf28ed10ec6db61ec263fba551ef522820d459fa5dad9b2fa2050e058ae7e8b932a94a9a5050d95658aeafc065186de9abd95f8e22413b76bd731c87d1d816d3b6ee5aa6e9b8e9ffbd9dd2361352f4567990b84109076d68ea62cc97f52c3b26480f2240b61a0e31c066509ababdc3ebc552165ebd724219fe6c5021e3bdb84ff42bc417cf1188a1d4024dcac81bc64048b60f5ee7770e178e098747880b955e9fc26252ec0eb5be8bf4c0e9719be9d9d5375b4d000f6db509b2f86339968bdbedfa61b3a13b64d837c40ded2081dd53878d561bc06f591e9c16244b21b7f6c8fd7621e345a8a01c7e81eb2c7fab0f7bbc94c18029c09f55db9ee09605dc3d96c9ef6357b63cc3b0f042088181b6bad8012fc0b0001166258233f3aba25eab183df9e8f582b6da2c7fd975a2797e8033aede98273587a86318462476c6d365300946968e8ec968cc25fdeb05ff8712a363deb40374902be9f75771e4e586d1380f60d224cb5559f312512e8d816335ae1a03ffd74527d8c0433dd6bb53d9d1196b9049cfd9253a792871dfdcfce65086126e726b3d07946658103f44d9edc41c53b0ede55c406ebab0161d1cfe4ade8eeaf6dea6280df3810ebf1986100128d5bcf58fc6dc8eee4d84794e02d6a74687b3ce88cea757ac2d7552c9554c2ed4b86a52dc4b4949e4bdc73ff7ff9836898b54a30a85205b069f19e1a2dc72229f592fb7a3df653bfa93ba0f61b97f563ccccb01d0978c73b264a05caf77bccef506c83c7f97408d7ef88049a09664df7f9b3e24a2b87d6a4d1ae296a12fa7556f1271f09a5992746954dfb0c37c3253676b592b66b7cd6d6c42c68379102afea062d62e70f62e3bf276510342962ea2e89615e69e5a6e6f4e18c7e6325dcd613026109a315b1ad7f2b3f33622a4fcd514e9bc389d5ac0952a670b90c6c4d208a15da3d4acbe9b862c66e899c6e916dc6aac47eaa95f98b55adbe76948ad9ba3fe9b8c8d0a025c0ba45e2a370002e944687927d0f0fa8103b13507fe7f3d58e0d53356e4a369a22145095aa3ef01466e970ac51b18e27e6f99149d00490a901c2408c11e89c44f21fd6006d9d809eeae49f083ec2bc9d0a3a1a04a4a882d870d8f09a8a14c0b95fc7f6b47c1534c3fd70c5099dc9c7fa0996c757cc7e6f3be69e32bb46bebe14d01303866b9ceff83df1d5ad93961e1b3884e3f23817bc6e735c3a549fc2f2e0d74b17deb88c3956509ccb01578cc90555f801bb2639b0fe58b61e98f2a1af25bb7314bb86ef9da26abdab8ec391d98cc71201c5e4da04b86ab3004a2a940bdfec5e12cbb654dba0ad1bff3eef198d704a82807f5bc4ce6145911cb73bfe1f243164175231c8a85ff7e619561fc6e12a101b543479b58801e73dd88d6dddef285a9b3961a1f386ab853312f420cde204b35f5e8ebf246cd3e4c0083b807c83681f844df6143192a12ecf313894d3fd5ce22f5864b28c7fdc8afbd8cab991e3d64f6640303e41c047337ed359999599a8321c5dde83a7a76f336459fe165ca0a188a66755a0f06e1f7c72cc579ccb152f5b3ea92371b2e0ea0a994fb82c375e8762165fd2a2b68693654f58eb9068c0bba22853b3103fc266add5ef0070b0473576c48c5203aa32201f35b7c543a4d7f9885911c190c294e6f56c5c4b752da5f1ae2591f6aeeb225acb665a862d1e8ddd58a7db2d8fc53dc5be3c9a480b8fdc98220d19928ed0284016a3b1c0a95f43d9db439a3e01e774375dab672b16b6d3d21f1756ad2145d63849d8abddd1b4cf3bb961ac5bb17f8d0dc884914d0e19b65583110dcfdba74da7b5560f13aa5fb4996bb0bfeaabe73e394ffb5770c21e379ce00c97ae564869dd85b17dc69421215a03c6e3d85fe698c4c5e35e7558653db4df64be8950a736c5686c5fa90beefae2867803d49d611ce65e8057fc3d92450048e97c0dbe8142447735170076abe5e8b2057d680bb3298a7df179a570b004a2b0e75ab494b598929ee313ac1cfe9ecdd5c58afa7930952232e1d30992835ff8823573a8f6959eec502e2f1811c12f8765c7284e9b8e5893ce8d952f1eaa590bc6625b26004ed0101200e9032a78abf1230e263fa97995769d0d5c1668d01d0afeb1789eeda371eecc35ff8accf1a49513b30c9647c281d17a770b6ed54d1cef50eff726d04d8f630d7f5829ed4de7f88b1c07846210ed79d1665df263928b4ad498481036bbd5c49628cc1f50e458d0ead76519fe5bbdc2c5f6e9de29fb5389f9ad9675a114f3ab447f5e8b18a2dfcdb5d50804340afdf7dd395c9a42af1d500926b6656728c379a8daa80c70635197018f3c5913b035c8d12ed1fd8c6c491bc8f9284cbe040e57c58dfba1171aa5773a7af47dfe48c6c1e5d74cfd702604756303cfcca971eeee64752fe2de79712738b73f0d1a94f9576b71c33c93ebeadc01e76a5d2c35a0de7e163bd15330e126715feb7d3e1de1f7ef23fefc409f7ec3c2d71c1594f48d660a3b3e5b89dbf7ec5db407b92e48379c45f5207784cee3638e9f54c26d81c1b4e11c0b38a39436920cea23c3b8ccfa0a93b97c8a8e646d04c2410b9b8db9320b87a173a0a6cb5975cbcb3467602438e0855e34f2b4c6aefb6fc01fd73ae7ba98294123c552f4808b361274abb7d04d5c3e72de33fa4aae67189d1c367b1d60acf36ca92c083f4044d75e111311c5997fd9c2e1a5180d6e5fbdf50329ed74c89bccc4fb530f2a01c07e4fa4fda54e3d1d927d97af2ccd7dd8061a5301466d091a3a35d3c934e7c6d672192e566e8307acb880c5b69ff4e9895175289cb7f454118921d53c06935d066cbeb9c51636d5a5ec7813fa0cb89b97d0f59d6ff0c835eb43028f268cf9d3483d8108690b472911d1799cb8427be63ba62cdc80ddc3ed116d536754b13b4782061c10d16dfcdf5ef7d9b44ed08a02d3b4a6a8196b21822fe6d9fc2be6d364135215c72b74fc9dfd36fd0ca7fdc672d50e1a0582c61ef3a006f1a6763e77fabad4929be751a303faf470cbb77a0045dae5cf2a9c15f0f11e7f58652a2cf00c3eeabd734a3d3ed54e84b3349cc9de8303537f87ca1221d64e9a6f21d9f47f896c4ded31be78d26f2b9f928eba0a2db24a53fdbff59ca72216ea5b2c36193671c5e8de5fa4f50e325a9e1eca10665fb039cec29b6d20bd80413dc83685a4405405c320135f48c4d98dca4b3616c395aa68d72b8dba2d7e39641213ac8ed946736fd53aeac8a9b44fda62518647b603d086c28d7019ba8e3266b8f6cc334ee33a8ef358ba1dcb198d84ab14c1a753a2dc9d9adf77218bd4d05147c757984b1efe007c2b4498f8f6cd132c345b3d040d9fd7600e6f8c45801589aed9f52fb077faceb2afd2d93575c9d8cc4459595ec24cccef35588f6ed055142ae5b59efc50a41e15224638b9bfe9b4e4195b08d4d77e31f70fa74895eed312f2eac5296515532a3a8eb2a9ab01569421e85617348f4f4e6231201d249ca02d9813bcaa857734d16ae2cc5aa5e9b8ba85f40cc62bc5303fa697e89f89eb900768239415266c528b56f81b6f1b2db9cc10e442165e7f37658116e443666757a9db67d1cf8f0a75686cc451df652b1177be7650218beca87e7f0971eae42758893bae4245903af12976c028ea5640c441616d97c62a2eab6120271022d1429c94435807339ad9d885cad0386e8b6355181ae5cb6d83663e44b353be998fdf4f2cb151e8329c0350a2a9359970b9a8db30665743c5dda7fc394f0e0dd4ae9faf041a0182c57e0326e90caf9670a2dfc2f21fc215a8fc0c4f80c8e7f23dc531766c1e078af149db46d46846553844d934798f167b17aa23388080d20ec9ee3e1c32889256b65e3256770b1ec49a416367300ea21dcd19c9c54785000678277ad797468018cf58c5c76d8a09c8c8cc5df76e23c04d038a7b4723339801b9a00482de8a63d5e25dd7c5f5a282669dbcec44a0564de436e9f6707b74893fa98f9ca94279e127565489dc6b5d95064fd98a1dade104f620deaf47e9e334a29e4da061da45b2351e92ce296804ca2bad38192b4b0a7dfb3a087ebad09507f73b4fc6ae6bff5491ce23b723662a4562ecb112ceaf788d9fc6e8bc46bd1177e507332e2e474581da9a2f9038cd6bc723e34053627020c319110e6af0366daa9a4958c26d7e4027238266355113a57af2ca8171194d5ac9c028cf9999219eaa409b391d34da31f4e0eb615788b1be271ecac9532003cf74775794b5aad7ed79d2c828208476902d8b5a0b89abc3a4bf05f5ef1c9da37a466238f64a20f0d1d038a63edb86c193a199079de8c8f95b1cc146cbf7178a00a07bba0af89c78e8ced1311ed5ca98a46e7e48b05f5e987c482100e7bf988f7c8bd2cf67aa7531824d3dcb4a1ad56db7b359b26a4beca39817aa4146e72007a8fa395f90e6086555b419c51e879e8c90f71e33004804df67eb37f6e81853e84db28670910e18f7c3f7412cfb9cbfe54a39fc4e1c7a0349e21536e94ce231cd4d15d75edaab0a846da08da8f2c47b7eb5679b85f5b02d0cf5a24918baf72b5107fa1023dbe922cc6544e80d6ac75f4767ce9a769f745ff58f6ef00c82583c1e86bc548253cb5d81ac21c7f30c66d537e49010346dab6136cb8b8cd181bb897e346d0f83a034b205e6f6a6f6305894251a001d7623c54f8d3ca660bb2322e55156712e0e821e106101550afea505fc17449e4f560ab3943f8c5e974b0fce4c3c303eb5054c0090213f853581485c9c4ec9b10aec29d10e83c8f25c2559376cbfb5857ddd406bd436a896c0b494296bc4f6ecead970564311911b1160abd33329414cd6f1a768381455cede9c148c18b693c3813d8c659f7c2ae37c73c50c8de09bdb7fe0ccfb348b8471c616948d770199c7fd426070289a76f96b85639a5c2d4712a9bb0ac207202dbd202fcc6321c7988e70cdb3c9bec9e487b79f22539d85452db144bacfdca9d7c9e5c0f0fcb899ed51200464b7b0343376c0d0c806648cfb48088b666eb5bdaad2271ff25bb3ff4d5c11ed3ea3a7b2235e7c4f5298d0212bf707ba96cfce6565f69f7aa327d3752835d6c5f7af43cae15f6e24ec72c9ec940a3f277e59edbf2c3a4d0d33fcf042c0116add19313da492ac82ff9e58abcddf9d20ff606c3629132177c29eb2cf7e06ce53e43859e83a240f170e5f591e2ba6b83e4f8a44435c401433bdb059312908041dca64e1391225b53e1a11987707d77054aaed9fadb5e7593432cb1d7e4e05211843d26a2c6a53765efaec15fd602c82739a08e78df276abc4bdb16cc3a0eb31bf762614c37685d53dab94f8807dad901ef0d1b8cfff4e1e5ab574b0fbd0953e6edad4bfe71da0646566d9758b0bfe7c44a57224b41e57349c4a61434f31a70c1259b1569a9c38d0562d4726bc4f96b680e8f2e16ecc66e7c7a099ddc27068fc41b565373e64b61ca38f89518b1b0ca510345d268aa1715e1a5760f4ed5693a0a61f81b4bab64dc01474ee9fcbcbb33e96b1ac21a2ff81aa7230d3f652e500a61d1df4f7af29bcd1995adfae140c30d91899c78d643ab16001856c354883f072ce077a116884d2fe6300179ec209f1e5a29c10d4765d831b73b962da9dbbb34a1a2a9995c196c8f22476ca5589b95b1d6a66f7e3a8f763f94e0f96e8f9a7738f0faf43eed2e88a62977b97911e2570a77e9e4392d1c03a49bff7113a09e94a0689122078df6ac28dcddccb1d2a7fe2d8c4b8ff636b8405d4782fbdd06aaf0a495a8c9954fd1994178fdc327fb0a91125d8c3a959e05895a2815e4e3b3e0d10353e77dbbef90366232723836cf5b7f0b2d183b9033157427431c8a4bac7db65bb97bcb26d67141ea81cf98d7bb577eec5b16459006e96e321a35152a7c04471e349cf8b01f521a1c88ad28aff7f3f9a9beeb7b481f6696ceb330bdfe66d0f9bf8b2267b6fc5358ff0bcff46d8924bf399f234974bb8e67355172e719aaa92ec6b8f364108e3673149fa041241deed90881a8733019b3a546f1156c8ccb7d56a25637170b4242abc951bbe28b5b0bf3e79527115df36392b54a471b0a18a54af0f87fe129d45485901eb186c802c0c30b17b0188e27c17fe2a180a72d6213618aa20000cc04646ef762d04fd039ea296fe7a1ab5bf433516aa76b27278200c695b9fc8f1e14f4f55cc2ab7363bcbc5da3a02ff923602bdf3f09d0d132d375e1e9beb78f7d6afeba43a4dccfb505436330c27be713fc1b196a83995f57d82a243f363540ea2ce73b9374d2838918c67cf34439b7289e06aea8832da5f73eb0dbc5e9964a50f4c7b304e15e5ac1b5c73b45ba7f0007e78de222fce420966c6e02a92f515ee3523deb45f5c8bdee60e1e0d8312aac7941e85d556deda4c6bc49256625ba06aa7211f633bf3d18288aeba8e2377a20ee79f95f3685c1c8942fdca3512cf6e7b78639c033bde39b26030ed1c4995af8cc50fd4008afad1f83247a80d85fb5b3102bee1dde6f3f9a47bec83ede3c0b8c7e42378f7d0eea09406fab52d70b043c39dc8b1d23fb16aec63f9288bb349f1e960983a5da2cfe7034fcb23b090919481413a6c00b44bf3c72563e8ad817f836a3e8ff70dfc70abc872accfb8ca22f41198fd92277ea27b791c9f2b7be5ac587e64452af0d64d37a80f474615843c0fa4e05e41b524ffd14fa92b705bf32a3cfe6459c2b422e4bd615895940468586c8a663aae940cbb8b815ee81aa7c33094ab4561dbb5f521eae48ada1eedeb0b1e8684114c11eb81534e6d7e51f74863905edf06f8d9d8a08e5e95a902b6eee64554305c8ca05ad980647bbf93f9ef83d8a501ff639333bafc4201b173155f2b095634f72cb8c0a3e57a03a64790d4925e5a0d7680f905338009060f742fcf01e6e7c46d2a25865c98d8c12cce04436841f7b5d48bb625353b50449bae5d5f089a3aa99113a41fabefa8904ed25e60a722c49a1d5d4b9643ceb7e09255a236a1862e0219ac15d49e6143d97d7b78d7d2ec628f18c634e55b60bd3f5b33fa9cb3e3a8ddcbcde5c2a28d3e9870c5810ebead83b857f8aa4abc61b4e4ab5bd2d48a4c31f7e1749fc37a2c36ffd73535e43b812a322095b667f78d24c1fa0d5a9a92ce25961fd340358ea84bab3ce2829c7807740009d5182cd6cdb1852a88d41252fd1e2151e5edc81eddc8c8e07162c8f57f7216de92535bdccc57b8dc30ac588486475b01e29a9f0a1d03b67d85b10336b7a4082687557ab0114e902a58a40b6211def1f612166794df98ad1601526b243e1d39ff0b33af95a2c9762e8a6c0991139ce26e5b2ac4228595bf594a1bf920cc9a3919f690a24767f2509f80b48cb7cbff0241f51aca35deb5ee7f0eb661693a40ff501b0d3743d1afa9fc2a1486ffd54fc04b5d4c957a399c23ccb8b1d9682a92add7c20046534b221e3e7f658c4cb277e0b88c93e6ae72581346966a5a4ff3a1d97f39c5bd90ff34cc96be2b33ca0e08491298eb073c2af28fc556e32c907898982728ecf067facc176d37bb14364d0d3b406f3449b7049b8b8fb7c5243381a7e7bcccd6ffdf40e8be1f0258e531889b82b22f25056e1600770bc77624125fe5571591527696735c1343d21079fb5d4719b1b879b17e758f25da94649b93c241624baa325d9f0b2b5c492ef097deaee139c8a4c915d13ff977d076080289dec4673dd36d28a806210f6a8e4df763a3247d5f72b2e47978b4dfb89e22015a93160ac2bc40873b122473062e3ce8db4258e8ea3fefa4cf5345e647411b3f93eaf5a365211855e5cda597925dda65c774f92a39fb3a710326aa080f8d95ffaeee222ebc11a800c3d978290074eb0d61120f0ccaf6795a0a196830b2dfff975e4f2116edbec38cc460474a9f27e3ec34f4d935fc70044c22aa0f2b781b71834d0885a04a124c057ecb5a1b6074cceeb1b41af74cdbc7c09cc82a6ff61b935112b3346bfa1e35eea4b43563684b6a8ad2fcc4476a9ae51238d267451552f7b44f92bca3d8a07d895ab4a3f62463ec167f58e19bc3b80e4388cfdc5bf7dbe95abfef9968153c9eeedde7626d0feda25056c1d9c148473832ebea9948b577c46f399fc15b15ae630574d293dfe624b01113416f63a23be4619f4d6e3f95a37871c52edb962866e9445ea5d2fa3a39047bda5debea7a703818419a62955ecaf3d43dfe449d59642ec67ad53388a428e75adc4be704f7ddcc86c7e4bca01dbf97fec83cf952bdbb416d06daa01d9212ff6a5289cffa302e5a944ff3ee5d21ce491ceaa7a0f49a4636d1b8038fecc0064015f4be9486a06595c6137076e175225296df2f61fe847d408546736c45c02b6187550cfc0e381b1ebf4c400e3823df97fb0c878fe50f87baae80a26628308fcf3708a1f83c8610b294938fd883a69bf7944015fef7f0bc7f653871e1ff06a488f35bd13ce27fb66f54116ab87658c77e17d5dd655c9fea9d088eb7a3637428282a263ae23b7c2dbcddff935577366ddb797078246702494648dac7b0ab007faa91b7accb55b9a69c1311f63c75f512ab13d21cfbe4065d67fadf5cf529576df354a0d52e43995c7a9d6b8741bc78fcfebe8b8e8580a6c5b889ddb77455991f36de20302f615e6a514e2285554e88cc8931556435fcad9a030aa50ea52f3f30272d667228db224cd00a6b3dfd88db4018865be40485ea2d56b8f47df4d91835e380edbb1b77b689f9c858bb8916042320d94d8b8e39770e4872979079b54720e026dc1f4a3949e79545f0f7ce0f05275454d170bee0031f9515997b36be3e77b69fb6cf77211cf377a7d21bd90856916440153c938de52b94e8a933bb2b8d9a9b255934503d6e70e90c3fd9ee024955bcdfc26ffd628129dd77a712eb75183eceaff101f8adb44f10720ea04e7a7655e69963e7ae271080497a0a3b7dd9f102853c58250ae59e84b0dd0880e51e89d2b549db5a4af13f5d4ddfb2456ed87f8219e460f2d9aadf2c7a4698cba809c9f07cc3656bcb612622054292fc0e63075c60ee06f8808a830c3ff73cf157a31a879a6f631570476deb93940c993533ee41fca55e224a69d3f2eb3e59388d72342793df251a2ea9121e1caa4db7cb1f1d4eafa9b22a2ee9c7d3b01ec8b11dfc5ba527adf7c1752bcd489727e6dc0cb34ad72a52d19b61fe161a5aa4687ea83ef2e0bc2d850dc3548b895df5dc576a37de59974d61b0afa62a1255cf49ff86052e43b8be6f8c6011130e6648c291d0a73147abf9ae0d45830863f9434f01a9b788fe90cfb66fbdc670f7cba9eead41fa39510a80c2d93698f2ecb903ad0b1a9cdb6476971cd4d1b1926e1989eb0c6d38d6c3d4a7b487ef1e16c9bba3983df6df98fb9585b0a9e970aea089387fa3172059caed9561b36d2e467035ea6b0ba44e75f924ff9b95837ec7156d3a52bb977a097cb129e57cb151e2162681d9c57ab89eb01e2991fa5dc177542b1591908b5d9579752048454b361bb13b8cd4452f0e456c8a71dff85254931c0c29a0ff21d74b5a61eaba39ebf1b429a2c61d2c76a38200270c40eebef36b6ab1ea05e5de487c8028e342ad92e8c486f328db1bd71a47dba6124ae4032a463dcc0c46322b642245a6935512cf769b85a0a485e1d8a1302cc55f5734d87773181412f65ddc0d6f20674543b419db614a97f5e45ea197ed9b48c518202cbc4f2501c3bd4f1f58157bc58e41685687d073a31cb5496a72efa10bc12ee8313b929b931c3bcd2c96c001be64445000e20db3477144e4e3dca39ebff779fdfafd38b5bb477be87b25b7b5ffddc955de0e7be8888e586e3e0efb535e802a8babf78ecb2d619b9b7125a2a8074fe4d26f5ed54ef557f31925f09cabbd3b6197c2f23d63126131539e879ccccaca09da93f215333d7ef71cadaf82b616a53c2764ca5015b387e159e4c5f615f42da0b7cf5a408432e8cfe2e49b79e0eeca86cc86965c8a180cdcc111e00fe49f7f0f9254a32b7f2957b1341121c6962807d68bddd7da6d606db1e376ba5cf7b5bbe9cda39da251927633e3232ae2c4868f3ca16bb6bd099d1ba41693fee04a25643ab59fba266f0628dbf00a94cdf3b0332c862cebbfb148d21915b84de24cc1398d5a8344696865ecf8d29cf7bad817f5441e966bb855a1c02dfc2d9aadec65a76a2345818e4b0ee48b97293e25a0410c09a37a9581800191d85d2b2da50b2190704636393bbbd636898e58e5078be598134e1b2435b42ef5e07a5b9d609e5d08f80ac1071b2584651f06cfc6363d2db89fa89a8923de0984dc5751d360b038d425d3f549be4e79270a7e3f39b56077547b51f3dcac3f001091f07dd6f5081cc1529b28adb1e46e525cc37a8b4d3196cc5030cbbf24e7cdf3426bea1ea5ade1f56c0b1bf45cb7f7211cb457f7e2f0c5ca36ce2ebebfe46a408fab53932c1a599b89e9d5e263133c92ad8753487912bf58802a38e9083d176bcf28d6cc75b319334b36694c7a3f466045cb9439a61ecdb3dcf4518033a0fbd2f2a83136bb15c4d76c5a0a991be541a0c2c81465719a5f61420281ef95e49225cea0f29d0783ffe242a76774d6d80aed1530b2a874b116f610fdd1566fb0de06ea06615dbe53abeb86c68090bcd83da54df27c3731f83b0dbee6df89a60da6066cfacd63c76dad900c44506a7f8641baf9210cc24f8c190f6536a30a30050dbc3c9c97c53c1913999ac440313d42fa48cff07922360b257fac072d79d50f09eb99b5092eb556433c35444b82251dbb8a4b899c6a70e66aef41343b51a1b91f473ef7c814ccfc93cfd3dd46af9b4123a5ea8609ef053a2d1c898b7df5fcf00ec9703f3515ea959639d11ac5bfb970412fd836e339ab5b71b560df4309a886d091cfddf9100ea54b46328d208db1422f6154d0aed6261b8c9232070c262f3b96559d96c30028c480ef455edc33f03cbdde9e7cf505bdee2309ba710a42fd5e3848a9928825f17db6252b122f55cc02836f176901a012b181d028cbdb8654cbed935f6ed567c82a6cd7d327c39c6666e0e272e1fa7cebd0d8e57608cdfc8f63ea55a4981f4ac30d741e9f1f7cade53f6c18ec533e5cf73bc58c787bdd7b1532003924bd5942ef31e6481a17a126c7d91ddfb732532511b8d610ed13f8d1d11af599a78e0f94ea60a1daf95d03040d62697dc64acf4a80170bff6718e15579175611785ac36fdabf43f1dbff1bf41f3014997f0f96512b123e4bd664535fac56c534b00dd4f53dd10811f91578d40b3065831d2cebb7b1ca043b99c44e7313b075da09ed82d197ae6236eb8356b26da53bf567dcc72583b1062eee12e82b594adb1e672af76eb92b16ec8a21ae6729d3dfabb68f2b5ef811c15caf0cd27fab3eb6b0410c8985f306fe204b420ac2f03eb1883effa9a7fac2adb3d39ec97556a674eb7f36c717a6a0607bde04de0ac13dbdc46a756c8346e1cc03c54e0be221aa491fc58ea00d6ccc16b73647e29f2fec7dfd8fdcd8057844c6d24fe2c5cf58254b78e224986db1cdc4858d3dec5b7594a9c84d8020c88f9a3d10f8763e49942ba7319b879b2d5bc3cd4a425d7b19d487a8a7bb7d72e1305fe780dbd68335beb0285274e855e376aecf440d0567880fdadbc5d7a0ac1df2e8ca626d59d43aefa7d848b596b413e9cf35682b106fcd3e78c277b85579be4a5937c5d39d71586499d9b1e3345fca1bb0f994a29bac3059006305781f4ac09b029d44a7d0925d03f20d20e00283ef47b10e8ab20a65cecb809a36c999a987addce576bafa5055493b04b24ad1631c8b3a414433a9d1932520d2498ce02c6692c80f82cf692b0f89738e79d66d380da097223dcbd69e3201f81bed3cbae907ca286ba301ae89900fbc596daad9e794c1b594677f816e3be466d26ee644bbceb7fbb44b6f3e6a33a2ac89dd2d5ac008ee99ed7cd71fd55a694c89647a7764e8054de7d4540aab7908b67d72d3e07cd5bcf7fb710c132a6d1b62ee8b6d1adcb4313b503db7e469e4a13b53db090ca4bab576b804945bc736d4cba87642568ec082a3a6a692ea57fd3c8a5cb30b0e9260a1a21e2c8eac10cb46208a39c6d13f38fa9cc89eb2bedc33e8fa6a1cf6274d1dd899e5b489ee9f302f825372fe3831e83f3d6ec4545eadd20521ca0166e586f7fc8a958d841ea44c35b3f90764b4efba4ec933aec577fa1745efa334831a316b99176e9a1e70624204a8ee06e334ddd3a0bf269f76a6267cbfe5ceb8ce53fb1acd3e945955c375afa7f081a99a1bd499a5bbea0e747cf11266283e3dee137b43f9a56390cff68e45c5ef6e95c7fc428a1a20776ce104907c3a424f931dd24957b6c3cf0474806cbab74b3a40e66cd76d07bef7a65f44f7f49f2c7aecb4869bbfe68ae81af9ce8051e4ae8520e7c5f266de2b2e5cd197c7b2c7aa67d687d9cd500935d625ef40c65ab1ec6b766d8916d9fdba3d2f4c6d9232906d1a8916aa75af4fb8d684a9e887c009e3a717c79f9da376c77b1c884b929ccc6c6fa7b8b4fc4ca4c63da8abf8e866c4ce50141ebb981a92d245876899b511248b66b312912e30784bd4d2e9cc27640ab1b80c2c657d18ff22c776298e3204e2c74e3db43f285a3224bbf8cff2d6111a82038f206087f49d8b78946f8bbba72f054186758d51195eb5c1382e8bb1b5a51842b3de45f2dc4f116c5959c875780be416b87e0f81422cb4c5e38ad6374ad3ebfd7a966002f164988689dfe63356aecd577d59088894295a762f01780d43a2a0ed1319a9f5d721024141e5a940aa7af8762ae5e7dc78735ee1d35955cba9c388353757ce1d73c670863a215f80e4429d7ec75bc52f815b8189186db21351c6a724d11d5e30dd7a66db37b0a1c07179fc9e5b4ecde552f406c5a94dfa15fb3b2f46bbeda6b523a988a05013cec169cc4218c05db868a6ae33b5bb2406f4f91f10aa1b84a77eb28c558a25b21b56883d93d2013c7d415bb4b627013c5d2b22cc5f942b4ebbd4180653657f10da7137422c5dd562a771a90d812138a1fae6f6b6552cba7da69f44bbe2079b1827cfed913b44e30ab77b4a721f623c23b6f5b1049adf81da9adef5417f22acdf3b328661a508f47f98747ec576ce7136089e7cea4da6a8d79b2173931a6a1eb919e25c43007adf251060d8c1500afa614312ff1f4a95176c92d65bcda04bab370ecf52c189e1f16ce75de22a2e1792508eb576c057931ad13c12174f24c65f8dfa3e12209805714ee53c644f638b99cd1285266da7d9580fee3cafab4bbfd7b1b0826fe782ca2db70f30d25984986fed7e8e931b79f62d593ae819e2557fbc8491b9aacfdc17009287c6b01f7304a9a84da833ed92629e175e53652b0e1614c578ee27798b7a5232f6a63d72d5c065a3985614eafe1660e3064705a0ce6cc737ca68434c0ab468321ea6a2f8347e3df40d9f0113e4f035dc3137c2a0f7cb05886d752aa29ef80a5ac7c2d81fe1682ceef523839c2f8ee74706f79c47d6a18bdfab1cfe4ec15fb01ecf5e42ae64f3a2b787ea20b08b426ab760e4aa93480dcb4a012836568031a7eef63e179068d7673edbf99662531853765c8cfa2cda7f9bbd632f017ad13b29594eeb0d79896469ffa29aa14a6ff249e292ced745b448df2d0f8aa2cf51e29ee4ccca042e37767b1660971b0e89e0eef3625fe810654fd37f38b90eff632dc35cfa64f7c776bb00cc01c3a7d12a57021423cc185634210fad4216ada2ae1bf02bd9110c37ab7630ec1630b3ee1d50919568f4c4e8ccb6740628b17398a94eb5526c1f19911d992a4783f119721c6f5f763dcf76aa47f901a6ca50ff74714297d4380f26aa10914dab2aa706c85dade27cd9543b04bb658a172e7224d1e958395f664c5b702a92e4723524837bbbc959c8c326212144152d9f1097b103274685cb5e24160e6a27fe68afa0fbf11ca852d20068dfb67482d430a30e528a2a6aca7793378817ec2ce15b0aa233dfee2426cc47fd9a53925a0be60bb631365e28e0156a100d4699d52156b34c40f273562f60cdc73abd6e65c3081297d1f156a3ad6d4459c57309f901181d70134e9ba0ffd748eabfbe741272b3f2cfce446e940bd3a4bf988f1ea02f96955de03a13df1808cce92663d4c252f9256ff13ddf0b4410769687724d0758eb30c9cd39fc1c4c8e682c1e207e5996f14573429a336a40e041608d4b87fa6ba8958e4a247b730a8077fac31be1f4e5fafb93e3ffcc0c2cce0c527f31778a095893e0f663277ac6d2ae0d7e4e884a1e590b7e4d81b0f4eaffe9225f45c9ac6465f2e7ca6ce49217c7450c3a1f24519ca0c4fe76907772095f71262470b406b4b102b43c44eae21090e75cbcfd3c336647135133ba770ce003a1b06d85cdd7db41f5936b75a200b349ed3a4bfca62feb11cd8dfe6a0993fb46952e5d58353d6a016053b48e7d4098ec81f9980494320c5c55b843fcc180dfee098404cdc13057bb4f4ff3de8b5d426af39e8e0f94427e5084c2ee2cd8adb609cc1513ec2e9e2dc51fab4641e639556f11aaf91f05d9a1891316826da005bc919b33cfdf1bac6da32b9cb65560007a3bc9f80e7d28de9dfd3e9408e67b51cfd26330b7bb18d769c4285ac243c2e17740037da2e625ff651c985620ae0d4634974a21bccc79c78a16dbfb8ac99b1a4f7ba85608bc90bfd260585b367385738bc83ade0f87d0b3d4463a5efbac05e27596543436d4d6b601c272761ce175ad398656e3bf4c6c2a514e530f32462834a1d1fa71a8ef26b49202a2206c4ffa25504417078fb5a2341b9bc425717180f65ecc515151461cbe090e321c8823a18eed5952511fcea54ef4b8c4cf1fe8d947562e84c1fbd36e602ba864f1f5d1953cb1c0a092554868e2e2666a83fd3c6f840d8d7447eac876c6230f09ea7bdc08fdaa4b0e8e33b922166ff204c5752ffc3c12f8d2b231138c0723bacb05eae05cc35411da7a09db76b5856015ae5d39f21ba89fedca8f60f4ae19e4f3fd294826b516df0df2c424e989836a692aaff88fcaa83fb582dc29e356471dc6c9e98c5ca8ee7c3ff920f88ab7769c030a44d93d048a4d6110380450d076db30f1e33f770c0402da6a2bfbd6a2fdabe934a875d25798d758ca411474704fa9424459dcc43b361573e4b6e0534c95c1885f69c326186d5d0c052576915dadea067c7a6e3fffa3c3c3d5b4ba13c033518e55ffdd116000d8178308497552ebd6f0986f30dad247c0717dcdc43b43af12ee52a6ef18f4e33e6e06570ee4fc49f48b211ebfd83331bb3cbcdec85415fe5899fd9ec7320952975829dfcaf3ab18ec1f46a27b359c753c954362b53a41cd5d2eb0b5f50e0085e8413c9ba0e98cdfbdedafa096ec0af9c557401fde074399e248b1f1b8beb0cae84c1a419f09e138fb6f9fd0389b9067f8f87e2f5dabaf644181b07d6bd81a16ecd91704828dadcae2212bb178bc5932293b8093e8a52fbe58713c35f3f2a43b9e6d72b37ede16ccdab196ee9bc4bfda9be6b94852745c942afa5edbc60575e318b26abe86879c461e98d10a090bc8bc4d672c97a2c54a19c21e0cef62b982daf8089cfe76e429c0321badbcc582dbe615c29c2cb710f1dbcd09d89f9cd6ca9a321fdebdf6ee79ddea9d91aed172a17942f3db5ab181a5354aed30f2bcc9d03926400a13cf74dd0ceeb1be13e7b5296f05826a69592cab72601a08cfd909c41c0ddf9086ee443a6b376f5bb28d7e371c10adb9eb4bc988d19ce05b8c28d01ff661cc899435db659f88baab4f9f4c41be7426df78ff65cd2b9e4f2ef6d2e4af995289b3dd3198733e411b3badc6a0c571fa6d17c5d4a71f3782c516eea003c2266262326671cd0da1b36253ea08789fc41009adb74a6a16fd8b8257be31ea6a92127c93ab2fa4507ff90a12dacec8b4b02b15da740b69e9e94dfe748185880a66bd5e6e5d7dd2388580a073ec4dd10d86157d2a7ed888ab74a22eddc47305fbb7dbbeb199847ea47072c726d638a7d9bb21e965f4c72f636990c50b6ed6b7efea13450e180cf575b2584b8d82aa29471b96bd12361ed6c5db0b60f5a05aa653ebf93db02540730c0eab272636ec70e4d03fdf3f9269c45f65c5ae5b2b339a4253dfc9c1a26a30e18111153675103781b777d4074f613e7b5d11789c8299966eb82a62ac472c08dee387acba259a4be650b0a859f01f9f07ce0338383400ddbf6e4062d25f0d28962e3cf87b78bacbee8ac5626e1b3c1b10628a7e0a86235f64c8a9a27edfbf249b79d2bacc0aa547b29ebaf5e83dc774bb1be16c0c8e5161284e180a83472a64a5ee4f4a7e82ac316c338d83905814a5dc0cffe372bfbac4805e0261041c358f983c679318141313c146b76bbf2c01c426d1c690ea57b4baeb8c7ac8a4a2975a8ced03e4262d6289d01b7a240e31533cd3c497b6f4b9bb4349f20ea0c9b8a73249133cadb88565615e3a950a837d287e176112a06cac876af05988e1a0b061844d7640d1f580e909981a487928aecc6f90885957b53891b9cf07551bbcb2b485f5ae470589163ddf209a2d7b1e6067bc2d7c1307eb20ed1b9bc0e9d79be5c5d135da1dce139320395eb60925cc108ddcaa4b425d6464c99e33ef0cdedb0c10a5a10bfd76b040eeb36fd6a3f50885b5fdb8387045381fe0838bce132f0842ca92bd8b1c844c603ffd63fc53c01b20d846cc430a492da7c186a57f2e8b193b97af0d1b3351fd538b24b0d6f44a871fc8c10d8033c7f5f76cc0a90306b1eef5507ace451","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
