<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f3440e911b1b3584243b9e90379a0c1b2b0e4006d299862ce792b25e3143b033b611f60c60f6871dd4a6fb716ccd656cc0f58536d392badc078741def9cb6e0f989f7a1d6580bf71002324820d18476fb560b72db509491e9ad278cfa5133f0d52f877cc11630d5aeadd5dddebe53ce9ab3bd6d96a991c47f4f8b83b4f65cf29aa3b12969263438bc1e867a758a9e440178a4d9176825ea115e57bac301a7865b3c5258b404ed678260d41ae6800e71ab5fc6d949c596f58634ed7fb24d2da6b417c5a3081dd46732ae28d5aebb24c691875f519fb183ff20fe52e19d7850ec37e8bd7f2b66952c216842e5f8d7d81325c7c5c07caf069b1c75994c8af2892a1e36b66c781d2c9e75f922e2018aa5404e4548b6c479ce83b0c7b98029335b256214fc322a35ee250d973cd2aab4aa65ce4def584cbab5b2b78bce8addcbfa0c38b04cd0126cecf584fccd9b9d092ab5924d1fddad2e9c8c3ecc651053df99f15875976caf3a02b7be59da9e0fe5b23d83c29abb9ab160801fa23c60a405c51de1f6d868d5aaf03f4f0dd998555ca12a6d1d8f0e553bc2b3a11f8b06fd5954299ec5312be74cc3ccc40f4936cfa318306027990322cda6734ab15576ba45b3a1b01f5ff0812f1fa9255b338722d29ac33a1558341d0fad7901f9449a04f91a8ea3c84321f371f7315585567f115e40de5f069cf7864c1d24c8b29a37c40eb868ab1a7b47dc47c4cf421f4a563677ce2c34636449e2a3983ed7e0ae931a7ca833e35c89456e643cab30f9d703b990469bc1ae83e9d5f05d0fed3e7b84d73714f939ef731cd3ce12b3e67063cc37731e7271d4ae377424f6d95d1ba87f5eccbbfd0408ac41f340206a38356e804074e109e2af056a114da780633b824a75a12277a14a9c7d77c2e50d9bc96e630795a1a6b3937c56de00f80d4046e8a46907e58092a61da7f6b3568f9a0d695adf5d8b0a67757561ee81bf561f8e9570c200fbe03e7bb54d82f26a11f06753598103e6e970ede0f897eb3675c0a3109d18f374ab90414f32c92d15d33f2252c755e1fbe0c2aa270a30fa2e4a83117a52fc5b78253dbe8111a99f739257b5f0e499d915597cbcaf1657582ae3065df787d03d39cb9675dceab520716698b6951ec064fa1bc95ce888b6df0d6604cc4c028522c40b696b571cd75e1f7b6df348464f5d0d9c694152bb0348e637b89023ed1aa3290ed5d901d63a2d9f2da9b7f8e4e103ea5d406ca455a634712c494d2e7f1734fb4a84556f0fabd22754007a2205373bcfc50fc90aed5159d53a94a29cfe2ed407fe0a6fd154ac835986cea3ab42ac0bb71101c525f7dc7d6488be8420822f9a076a07d458d02c0624a8d305d713878cbb4175e17db972ddb40ab322e61940c329a11bf62784821f3139b7a32f098055b06c83baad4c11ab79fa53372105db9275ec388660295465cd1cc7e8d2832a268a11e22572c186b8322cbfb892164c179fdc1e9d31fa182d4e32adf078ad50481c17ad1e03e8dfe40aa1cfe4cfe35da6505e6358618184dfec93a2898748218d84b4943878e8070ae5718c27f227b84260312277ad588d8c8612e892af38121e1683518923c13a0c4dd8fba1b25bfc4f7f599f6222840f250508918bf77489908c3aa3d9e844652d94cae0586edff685b94ff20648596529e46fca6c426580cbb917d47323fc4c29ee9f5493f7177868fcf5c890e5e15e97eb9c8887d0d2ba7ae74fd7d43ca71d9e6975a69df11e8245996bf4a5190030c8dd7edb1819b42f814a9ed575e66a4547cd249b82820aa6fb248571f903d8dbb7bed83d46b96e7109d3d7efa7482ccab1e23e43f750997fa50a746c28cc562ba914eabdb5e24efe65df0a6b32410a236dc13147b1405c3ca91045fdd0d651749d5df032e3c0db44319496962f98c15f7c95b294bb2ba447ec687a4715f0446e647999e6f004390ab5147349a63f98a97580eb6a4c5b758f321270d2973adeb142c923e19dd41f1260eac8d7f9cbe7096082dd385ac1d2fd66ba580d29906e24e77174a67dbb85408443be4f7101067c6f008054bef0837a186b3033362a0768f4a0aa1aae0a1c1586a57593e7414f5f3ba46af6080826782c55445f11337c0a40d3059569c793335efad7f8ec00692677fd4d59aade451025efdab1bc0e216db2ff70c27290d1b62f5d07b98727827975140961f97dc27136104cf04da4a9ae73a3e304bf6aa0a621be8c2dfc66c415e1fcefff027e5510e5d495889bc70e333b5bbcfdeae7ba48c0faf4987e960b1700952657e78f50fa4b0de393c190b59c6abbbdbb75c09f29e479d8ee46e15fb871f061b257ba3465d6270e220a67e44165b4e85250aad4de3430ec76e07895965302e9936d0704bcd08db3d9b63d0dfcafe7d4b6b9ac93a5287222d3fec8b6884ea6f1067a752d0215b2c8d8775d71fbfca8cc93571e1b80ecf26f9bb6802d0174c14555b084fd8925399f2a62903d57f8dbebbeb6fbc78d7a61a7d7f2c3bf761c5d2997bbcf5296ee9ebe14107f41e7bc299d637391bb2ca9600af463da963bd26a7df3b8d42e3bffa109149c137afc9f7371a84144059eb59dfbe66f73a830c88f717a2f88dd61179c56363630afb6f09908b772e042547d36d2b3ad62d4462009f7f1b4a86474fdcf3e86d3e43a676a1cdd8456c40637698ea7ff1d5d249c4c519a3f85a32c6540acc2066a6417366e1c06cb1246e03b8425719a7b537708b9caaf2acf9354b63343eaa16d9812f07bbf81a229b7d9b596cfd6e7f7b6b7ce793948ff3fcb93451bf87908d60b40d7cc8c496c62c7f8b6ae2e5e32f5a1526a77a9005e62440e3330f499afbc0687c016e33c090b759e19579f5cb95f95e57a238851386460d812e5a70ff382e9ba009a2fec107c510e824972722eb1fdb215a2227f6e1fd85ab54bd259ca3a5be63b45f8d4c79a8f2a3e1943100f64e44df2b0dcb01768927cdb194252c06b517a53dedbeebc994d748dfd44e53c58f47545d71cc629530337ee39fe790df392e922c5a0a052214ef34228f9b19b788fac21e9d54455ea9d9a739ac7b9f82c1dad9d0c27f866f7cfa1b78197e9719d32aff24e4cda38a942515d51cbc30c317616e4a2ae41692097efebe42287976a8d578e463e41fa8c1ad988718ee673890eb6fad827f4e56d2b7993e9d8d2ab4d9dc3cfc8237ecc135f078954ce6e83f50024299726983efce4b8d38abc4e8f0f8096be95ff7b756cbfa484017ff36fdf307f6380be51d30c4caa501c3597be9c80b2cc42dd0d10a0122d71bb8960c204a7294b510f7b3be5fbba994b9766acbc3c8b0a603ba8613181c855dfedeb74a0cbef2204f840c300a324d7f862d36b2b8061240ad256936a96f1166a625cc51ae8e088663d284eea07bb35f3c937cbf26d8dae7c1ec8537d15683bdd9e7d8a06ef0a890e9a68e3af00cc595c6641529f1d0f9953b04e8c568fcd3ab2ddf2f4190cfd467f8773ece8970126be26d85b7939ce2c1afd335a085ae0486b2df2a43211c04eb0344af5d30848127b0108e8bf56497083a1f3a52fcfe1d0b2ebbfc26ee4dc28de1b1a184366df2e0bf0d5d11fb612bc4cdc92e577bc098c8b6f746e63aa2f17dc5f510071bc569f8a4e34575add10a21f42bfad7b36d19a55c9528aaa241d746bb8370ee8000930f132e399ecbbcd77b6e7859257ad24b64fd200d03d7b5f2b05cd370f14430b6bb9f7133cfa6a2fac7c3ad8bca983e1f38be63c88c2c8c06b55f5551198c68b43027d9dcd7bbed748418a04f1825181021cc8b4aeaacca52e1cf8c149fe94fc976f96563edb85bd900124111afdef46e91a3eda0cf9cf86166839879ff034a7c14dac4ea151125180e04c821437576d06cd8990d56c82d85c20146880d2f17460172195f8a526778bc13c5ba4c79044a9062e62c0efd7510e0d33c69fe26ba166891e4abd56efbf55574dda7223942d4bbf6786fb5213c37060ffd1a91e963207614ee71963d7fee5ddb30f5f7f08c0fcd4bbf3b1cc095366611df879262a2f9a116e67b9a5527966b2e46448d57a446296f2d16904a25b80b406fd8fca8ed736ff5bbc3b7dedd06146d11f8d40ae2ec86e897226930b4b11aca196b6b4c88c4d04804ff0bc6b0b357fa3cb316b75e1371df95aa57da7d793557e8fecfde442c26466ba92c640944c2a46497b3440c38f32773c365e82b7e32620fe16feaa1c46d7fdc431caabd43e0608455d3b924ce7d9d305290cdff7901151f6b165c76fe339e87960cb09ba77deda3b1cb723c4c12250449fa0f047e7d84b53803c59d449faf43c3fb654a311c1340e91c4d7089f6686ea1e93af7139eafa94565416bd1937ac858a2ee475e08ba020597806a559490b93067f3240b8b4a9dfa39077611a370877315965d5798e38a51bfce5607a2df80d8e29d4d3dd0fe0c291ef68bd84bab9b878ad0c35db9a9596c80ec7876e3b052056ae66167780dee99853d446f60a8b96fe3199b001d518e82b01737dd45741991aec787a3d2ec1138ff602c50562622bc01d3f4fe723871161c3f9ae983137c5123c70e862e4a33615f61785bcf72adecdd3870974f105b78f98eb29b2c714cb8d3cc1ead5a88e8fdbfbd9855897a469222fa2ca2b2cd32325a87d91adc29c567da5584bd7d3001fb35b70413fca8a01493b77c14d9d63e6542f575bb6826ad4542fdfd648ad948971631b0421f07137ca350acd9790d315229a06ac5351529c2db4af9e248e6b608c041b891159af9ff0404d660a357fdaf4498de95ce2d0fcb1c8a81dd94fa7cdae285a4333a55735f96493574d96203e82f0297300a42c82a9b11e7e36e47b4359d6d1d288731c3c85ec673d0d346960ecb0141bb81132f34ad5c9928571e39dba74b057308177043fd252a967fbebaf7d27353f712009b3f5f6eeae4cd57100757aa982710dacab08dbaf8d8b3fbcebf336a7c2ea5b3e7221e977b074f2a479d2b79a5ee3f6ac680b9f35e7dfc891128b900b711cc78f1c74eb4660e5e0d7c01316e2987b84b75e5811c5125522a1a92887fd0bd9773bb6619aff6e2f68dca7247f7a27d020ecef1c16849ae4df5954e7ee540e6d04401cb22d9d1555e5b3ca1d909cb7c4a6d8289d31c5c99c0489565d57c92d48909d24eeeff018894bdce2ae9159fd16381a2a19fda88bbca5612913485b266d7b7847bf311acfe006bf79656445a42b2f25166e59663d9534e3e5b25f8761fda327e32aa42f1851d98e52a713babed6c1cf04124f709110fa1a61f038892ae44c0db9ef74bffd3fee36430a547434dd66bfeedaca5cd0a2af5c25bd09c8d672008b5d868aa5840d515b16472024188f877fb6ea47fa17bf63c895e464dc3a1a85c6aefea26e4c0cefc070b07a3111bae94016cd2df2ea45d2c94a58ee1d4fb153f79184500825bd7bfaf3bc42c783cd9694b28173129466a0b11a0776d9bdc7319d11bc33a6367a65cbedf8edf2b2612d6eaaef77651994946e8993e45b717444f0e3ced697f2ae5bf1ca936a8d8732b26e4ab2c99ff4f14f76ec361963f3167cdb97977374dd11916a1765e09b05ee706b50ed646593439bb16c2161a997cbdd926717e52d05a0a48439c2d64f600abfb6565f55e8bf000a31fb0f2e5b2c9ccc7c15216e52ef9c8669b48ad56d95e93022d37288b8fd5a5b5a5f821a0f97730bde02aa154b5debdd5f3d30debc0cb407d72a63d792eb195db7e66afa54e4798775da2a9ba814a749564ea74cc64a01136797464bfcd811ac5c8f44b8a69aaee477b8e6fa2ce1eed67e173f5ae9aa5564cf966f19b5f807acc058e55c1154e6fe695a694a9e3021234bb67f5575ab21c63b8dae907c2c698a776583efe966b836cd3433a5fd7435519a517bff91c151f96d48cf7e142af66188b37b0c9eabae092787a916b5b49eeedbf4fbc8980944d176bfc3a26cf1882182bab544e71d233ce06d5440e8a7b5aefec683d32fcf41205ff62ce5c0e34bab089828f27f2252147b3968624355f5ccb4816fdd277b5211be83df8f535a37d584e10317238e3f263487731f47a9b74943526181810f413c4e41ea6650d5bf37ccede9e09731a23bc5b936dc6d32bc60c62bfbd2a769133d0372884d5998d8f868b78e6def55b77c80bc8bd8554d1ac120fab0b2fc6a9a9901099e9fe9a1c6cd8f3da3fe598121664fc3c7a64dd8115db42d568868512cbcd2d05bf4d778adf0add9a38a254b446c0ab6f1e97c945bd67c4860f4dc24b6aae32e78f0137b1c47d60c542badfd5edccbd92e2950bb759a2143530a2f530ced9881fbaef0529bb1f2192094845cd049039ac6d4bc2539f3b81d9d1890164897c273650c2604d1b8588f81631df2778f4443e47edfb9a45e4eb451d1a7e3a8a89238f4b38f8ece3d6946afee28f1e247b749f7daf2a4f855d193903e6b32b86df01798c32f81b247eed9e28935af593100da6b70ad63d11f9d82f68b1ff343a11d70ab1b2356b0209ea4ff8068e52c4805e67790f6618757e4469f351efa5d90d9e38cacb00f7f43e12dce003cf09d46d9c3d22387bc8c5438a0b6e45928c88f3df77f85ed41ca49fc6710a02297dca386d0a52c0180089e8e4374e0349ace379ba015d51b39f634358c08ba00e3e1cf070b9ccaca25ccea7e610cc73ae4b39c1f5e28adf80e4704c7f0e3888874dee6bd5200134722b50c638206f36f4b5eebf2d7474a1be6388f2b26d0c317c4b01175406fa4737db9f4789a4f842acd2d4c087000335113b6a495d86af60cf71bdb2b00c666948a0e346c584966b345f3bdd24ceadc5ce42fe589ddc17482c68e2cc16f04650173b424c810421a3752d3dada941b4f1b427ca15252ff5b59bf002c035a46c0852b966d7aa6b9239c468b3f8d307c0fbf1213670d3a8d6d82c334db59dd37e5c924a80975e71021cf8313e1af3170496ae3f9ec81f2a04ee51811f30df17d87a300c732578480c83d099b7a1075b621ac54c002361f1bf55d964a32fe7ab6321e0bd311e6bf0abd69a9db1b286af5f6c4c21b9e646e6afe71393e52d667cb22c9ad2f47ca70f9a923026ce26dcebf0ed8fad4e53b1b7925a2ebeea87877ac1a7d55232ed82d66b8fc0deffee125b1ebcd6c101e8b660a7d4cc27136fe705e80d9a1218152113b3a19bf615211908ee2b9d204408121c8387a42062d1219182fdeeabe3f89b15446ccab44afc9e0b116a718d3b7601665c66b461cd67217955c3fb0229a777396635cd0ff39844e088a13f4a975f62cf90add63065aaff54828272915ff1fad79a9597b1fec3e9b34a1198734ce083fa37428599b72ca14013897f90a98085d5820863a58d03c358831f377e13b3607dab9bef7847fdd4f4f98747872c44a2d6838131ef20416d053d864b8e323aee4e4130cddc5ef5976454ee9c64eb5f5205bbe98ecc1ebb33262b6bf8e07685d2ab1d937966add90edf4331fc507feac02d6767730ac152baf31949cdc4a277eccacb1761b670605728b99cb9783d81917fa092ca88e3989871d2a862001fdf01c98bd4351de53a5a2be2c2992a94d1a250c734a6800906b68b9dd0ab6cc9f02d6b77026843afad236c8c8dd44ecd311a3763953c8af95c3dc43923f01e6a19f9e0b773f9989905c707cc6ead598dae6854bfb7f3b63ba10a5f0824427f1e1e3452251c49654046091ecb31ce7bb17008e57901d360a049a2aee3250a8ce8306a417b2c7adbc9a0926341a7a10819be559cef1766e7279e6f9cffcf0b21365f0e50c466e5b05377f6b93d891d72146f505f2286f6d1c161a604f7e02b487ac77fa4380334aa831a63d9e5a7a125c4b4639a8a72d2d32621e89288b992ec35a1a9714fd25f6ea420e6fd2db879cf87fc05eafc4a5a1a4b59f56df756bd4048e69b4fc31486d0ed9fabf3bf405bae57684776e483707c7763e012b9bbce745bfd6ed1996539e8d70572d1398fc59fc93e04cd5c6bdc30af0bc398a2f72c1b5c0165d89f45356bf348b418b12f77c3ec1f2dc9c7293b715ab92fe97eb829f5e933f063b0b60f96d59d6e30595ba2cc714abd2ca90099e276aa8424d4e3621f735a2b13cd748b6c7c1e54ac40e872a1a5741483fccf2196663432e9c3404cc86e666f51d913bb524f512b91728dcaad809a19b1a1bc10d66be7d1745dc447f35a2dd86178d62f637ae2562ca30d5b1d44f0c66672a6ff92ff2e741e1dc77537e1721763ff2ba50d822c6e2815ff5ac49cb37fb3ef75151c7d8801b2c70945b7ec1c86cc35cdd259dd1a8665dc582cf25e5ae3b9feb9b92296e05db8abdb66ddb97d4cc3772b966344b800b8856f3e9658a74c95d35d26256c9c00535791f53d778e88da19ec257792eedb033adaf3b807a5ac450dbc62df11efa6f7ce45f8d44c1a1f3ecd5c2c063c1fa42ae67559d2b8f814e4ee090e17e98088ac81283b1e904b1b1c4bd166232c33b5f116bb3920c474935600c08d0bf9f8969884ef8e119a81eabd15a48cc96d4142f279a2d34a4113e3177c7a453ee945bc3ab786533462b488c0adf3898a75fb93d916e20c0509c6596a41e1b4ea5b11f1b07a1a180ffaf543bc26edfae613a0d4824cbefa69886e6cf8f05a2375132d05aefd89b0f0b4a8cb25e15b3889baaf206c4db0078f28b6a299ace364f4157b36291482538a510a9e83570a533eb2d5df2e65591aa6bb1f249b03e2b43aa76f02e4e8c22ba95f305a80e41760c92cbfe63b0464b8b5f6db67bcbaa4e4b6b2027c4219081fa34ab52423e2b21d2e348fbfc0fad23ef1db2859c8a0636c5aba50cd2128fe46f0027aba38a2faf127506ca046e0df4e2458fb61bd4ced87ff20ebc33ef268226dc1684e84b8af122327987da7a2f335bcbff0d682332094a57bca5e81bb58bf6bbb666edec9c3469b023bd374a80a5b6664b88f0861dcc85c3200fb26191d836229223005570942433ae182a5c9a3aa7c9f02bc6f4c345e577af82a20a6b90b39273fc2997c95e8f3aab46674dceaffc265dd57cf0c2e45c6e349e206508a657e0a9dfb6a5a99b496161fcb8ba36919362a70bde693ab83bf125794c47927285fc95fffbccf66d482300d41aecdabe820025130b0d9cd7e5c13fb9adc8b6e32151cfacf08fdf86179dc367d2847ef2373367e7b3c2273958593ffeded792d87d080865a3a9d6cb12c513f0aa97c68f117dc69357360394e8bc69462c04d626a5b61c24478d79239d9c16ffa8f11ef534e241c54236cbc3473f708f88c855b643e818b632d97172dec6c8464bcdf2fc7c0443f979310a15ae64a2b1cd833acc9edf53b726f82cb18822190bd5ec01180526872b095f530ce614c45a2fa6a52aa9e793b36017810656dd001d4a6950a4ca8114c0f0cc55107f0513fb4385aab7bbadd1bb4940ebbdecb156c770df48da9aae23becc9d71a385d8ffbac4af379f2d38e666fad7952508db2308211d0dc25bb00c6509158a6fd2ddec10f2b59df5cf5c7bbeaa09b09758ba5005594d49a9c5a88f5c95e35ea46ce92be40dca52eb687547d0fe3e6ba4f66b827d08ea2c17d124a49a802089f74248025d6d601b8d5e2f39c941039550d7627f7089829afb65a4cfbcc81f8c2d2c22760a893ad9051ea87143e481fd238fddf2a4613dea7db056e6c64831300f3e4fb869754d2bebd59c73eec44a5facec53a4817f9af38902e09e3d9dae5f8936adec2ffb0d5aa45f3632f8d49f39e99f99b5f2769690ec7dbe61108aef77ed0844568750f475fa7df79f0bc7050d3c408f4cb0dff95c4e943fef905a9e27074ab9566bda7b941b061a8e65c8445ae6abfb3bb450aa1d7ca42d8acb3f558376cd9d9c2f837a0533fdfd745390e607c39dc577ee31831fac3e4d70dd4c36af3c8a8f4507ba5bb8242e7ee51f751f60de4a3828edca91343294a1c59b885b984c5e2fc4dd3d47d384f93f332c54dc31f1f35f5a18f68a201f7ea8fffe7242ac76562a15e9eaa445b7dfb691fcddbc060108d5760515362ea916f7567d891cd61c377e4f61f52c2e1481fbf7925d1a16fd25d719a620171b876bcc32d405b958913c002150c5ba7c12842557f89e4012a01904da3e030eab3a34ff481cb256b12ae474e36dd4ab497b698dac3c31b6e10cac1884162d978841ae890cd24bba17775444d970e22a3fcea894d1c9c2d152d51f1c4e53ab18f74fc7063371d66d3fba0ecdb1c80a3683fd562dfc3e9c26ca53e6563483cd8005f931268d78d2d4388c3085b9ede7ee97f57207a074bb6759a3e6e496149621506e5740f4060d5bb77ece650c32e8327cfdad6e952481eb006ef906784f8dc9fbf483d7f88beef2f7113b1678e6e909cc28a8454c74abdeb34a02b45afcffbd84896505c823cc0611ea0d1e6ffabf1ceb09cef86090d8d21fb98e9ade048abd6f239cf84f72752e264b45f113ee0110e07f91c8cd3c22bb2769f908d8d6dc85263e4f1ea89eb604c4afceb19e301a2ee390997ff69ee13850f5db63f4c1bc27661ee8b0981ad353a52509c4454619ee430e837e5922d4391418c2ef5771e906367b4311e76e12b7f47789bff3e2c09d55e8681951e8fa7b15bdde88c274204c7a0cfd4aaf203a4159b39d0302f6dfc40d2252d4d23e1e9e4d2e54cfbba9f742114582fb05355cd24a57e2e463223f232f9d0c6ffedba12af886ee03b9197ac874076ec824963b7f50ae410ecf4ae9eadfeb1ee4ee8fa808a445f39cde22e7d831d2e89c3fab6fcf30bb863ecc0f59812114dbb106f3781ffeb7f89bf78a71add402079e39b0ac4819a49a21b5fcc948fdde03b2d7fb20cb28dd9f5de5727ad52f32a5baee954063686555daf766216bfba8f7514d8709e4e4c0c7e3c8cfe03f5b171e28e6d735292aae6b557c2e174097fb313dd3d0929acec6bdc8c1040508321d866e7f959e45db3cc9b444e34118444452aa332ddb2ba28dcddcbc03823c929ed91eb5f3531859544891d74743d9280fefd3d477fadbded802987e9ab4d57d90acbe81a16ccef2863c693df61bc9b5bd3543ff1649b6bb57e325ecabfba5e468c2a1c69f8eebb9b8eaf7da11524de59c775db85041d38d066bf5c0d9534cb43f6276862cdcb274cff24770efb5983e847d38891e28fb86c37af4e47cb5a0fbacf50b9b58263573e13c14ff17e38b06e9eb69e6d4402831f9aa1ca535f4c34333c135e054778544c9bdc2224ad90c3b80598c67277db054a2d980bb5dad2c16520821db863a98f158e4a00123f9d827caeb13f13101565f64855df112fa5b9ad6b279ec7af8e6d1d8d2aa6acc1f524bba5cd37ed1c518c4372ba66ab05eea5ff98953a0d211f3d9054a050df26f55a35ba67bc3e9fd0133fb72ee63f7c4a60957e285c3f39f174903008303b385f45e28e0e57bc6c460075ac77f0989d35b58bde23b528c99fef62cda50d639abe133a940a6424e85d15cbba607ab186947c95d41a401296e9b2e7c6eff0a0ccfcf5bd760edb22ced6553a1125644908a115c32d4c46d8f54759ee2f468726c68ac496ca3414f21bb8711abfb755248d3c54769f1d5ec0d4b76a1361cc220e1863989585927a922dfd717e066a2b8e84c0fd4fe941e7a87a0b9ad55ec5061d109ecc8c28aef9cf68b8990f7784ed269b1950c1366fafe3f0c418362d91f22fa0bc87e53f19e572af4d687796de0722eed690075e1eb5abad37fcf5bf39cbeef2b014db247d46c2eec1feae98fe37d001be31b69807b91047853beaecaff5aae36555183a0f2f30db7b197b1df951d17799b9b706205cd172bd2fd7e7bf879d439d22e5e9849f5166f04b2f73b6a6e9f2e5c2bd99462b5a2404b3424d10a04a9b90fb503ee38a13ea6111faa2ca3ff380466ed9a2e7bf478348410c9e71a6ca8f76db0ad4bf12bd1dd57a6f537f3f3670dd4c2f1f937925cb3380d5e4db4890176d2ea460f8a8488316f3aa8a1158986f3d348d53befe930aff7ca57bcd1fd6769b5726327e2a909136a3f980cd5cfc4cd674732265d12073c1eb6c3b29459637c26706631710491398182ec69d97122dd3a711e560bd45036da8b706db3b8994a7d6af9f5e347a365d4743460225549a895f2c79f97e958583cf60da8aced495b52c9645f340ca8b385f0703818bf31a22b7941e5a3fca646c1f9ebfb2b0e35cf92c6eb7aeddf17c74f0599433490c1bdf79279c9a3f270afc826dffec40383c021970e9322051d6cb62afdc03c2fd45d8053fca67f8ff4b745d9efeaf75942e15a3b39b6317db295d7b635d5b3f0d3d8a69e2716f942aea3acd8539e9e3e019ff7607ec43bec6e91dde5d61405bbf177af531507e2c35b7276b4999a2d1c6f38ace1f344e39e8990d47c984c5246e200ca89273b4fdb206d167668691e698fa51fe61e06d9a4c7af3a6212c74d48d3fde3ac0b33252faeb32d47bb26932db44aa2703ab6314865cdc0ef73135d2785f0ef1a3b00111b1167d1601f28bffc8a3704cf31f98d2f206f828237801a2e4c464245b93adb4e8afe11485f02935ef0e4f56e883973a5490deec5df06a153703d0acaf2e8d5d834bd705684c6d4afb278bdc60699bf3f005e6f5ffe16c417b79c4a6a38f48a5165b6d5e1cab54c7bc7bdaf621d1b06f86968b3a25c3bc182c6b9cb5d2e623f891970aed3bd38d12d8884f38c889883fefaea09d5d4fdbf8a372004cbe6163254bcd1f60b5d7c056cdffafc7169235551c6429f8925228102864fbac8d928ed4de32bc4a94632056cc3d464951cacd5d1c3ac15967087e4d1b2a0629e4c420e91e795b2092dfdfe81b548c630314e22bb302b564da774dc5db1bcd21e5acb5c2a38704a7d3a124f6bce2f48e4818f18e3133749aed0aa189ae4f8f1c53ec3e9da66bb8ad93e4544254aeafc9764788118f0711958b7b52e7bf75bf4a45c8f672dd8a3c4048ac5051517bb25deca62ca89bdedede26f0ed99bc9e762f2ba4cb1fc2496e46df9be91056f90a55094581980cfc0df4b335d996f51451b5e0ce122085be6ccaa0f489a937f05e3766b3e354cba02387da234312d84f148cb4aaea4f5ca7768e9ba3bc15aa32576f0bead3d265f5e0091c67f5d18cb9f81e515cd6ff973956753e44d847917be53abb6345db051e156d66f54d594d2d0206e4734e462946a9f5fee71b23024f77272cccb9e83a2ded06372d81f184f8ae73045f38cca69cfb458478f190d80038dc9ca9d77bf11d4413aa3c87ca1d7670968ed0a5dc32f94afe0fab0427807c8323d6804592a2c03466012f0523950aa776926a86fc9cf0186cd01cdd62d436ca54bdef4275a3106b4bf78c873c91ac21aebb4c01e3644cf103347ab8f62b7757672bdc6a26179057596cc84a34792d9f767c22e7f198313e97d32af8246597db6f0676bce2cf025442daf6b38e23fb733b9df9954e615644e51486e5b9d4695afa0ee7e56d286ac4eb8c0f85cfbd78f18a4cd59995d92410642fa09b090e1bd306a02b6de7ffecf10b54f766393228fc4add3b105678e8a06d70d56e0477c1fd72acd1fa72261386fc0d124b5d71575c81f803f0b6285765033f958c197afe522ebe0e04fb4c75faab41c023f3ebf859bd24e1390312698ea609906cfc838131193af7d16ad8f090802b1193083c9e76ca2bda1ae424c7ea7c57dd6af7727031d0759d30e3386022e115019ca9ff5a06cfcbf6a05975c9bb9c6a36434b34d14d48092ae44cc927dfcb0323947ecb54226be4d20f13a95e93680fd0d3219945595b9655208c251a8d14a326708c1cb74f3aefb262da29e8d070bd16c11fefca5c64e6e039d900019d9e0f57e8857c185ebac92b887331f851ce588f3d321300461b101cfff847677f1fb45ab74bf6bda51e98910903028f19dbcbdf00fd790b542d5929e47edf3bbf07dc1c84a5b34f57500903d02979b484c2d9b8cf91c06a54cacf43427977888470ef88e11da96c7148bb82504e57a98a729f476014b2215c6d9a7e62eb78e272f485f407c937ef4af032b0d2c2dc671a3238542f278bcb7b07ac3960cb2213cc4c7c0577225e85680e4ae637b3425757956e71bb9ad7a8b64de9e054187a78a5e0136431f52108667339aac10f3bbe98d9dc5524a7fec1e8c4eff35632de0d9e9f647f9f4b2321c6bd88be74729fb4b1a1b462ee0f5f10eb17b3edbf7108875fb1453aec541c84b12c563282b5bb41e51c2d38316f02cec02cec46b3f4d4a3787a850f4bc1bfab01170a5a13340eb2f09d811073ba8b53d04a8cfea3b07d475cf1450fcc65b6ebf3cd044c3dd98e763aa8efe04a6467f3d4240aca29d7d75f48addd6f9c0a8e9f54f93dee90e6344f9e120fabc26b8d976dad9e988d6143ee110c4d7ae957ec3b6b209cb0193285f2fe57cf54e780756f8323805712750aa5eb76a0fa500d29062e67dd9a413c7b1eaf9db45724567e4c5620878429bb9fe0c9ae8ab3b1822e522cd5cbe9501cae167eb790d3749b7eba4da28072bdbb87ea3567904f04911a14ed73a474463de2af0d92d513737d643b5530f9c5b109b165859803e72a816d645941c2b4666b17dd0f82db4b6a626b1eb1b5ecd4425da47fdc03826395a81695bbb1aca52e61dc5b839332117093fdc6119d920146cef6000b5af299c4604b48b18dc720420e183164505fdf9bcd1376aaf63c89ee6017516d68abaa7285695d0f01331e8b7b8517ab0abad5fdbe1871ee280b3e0aecdf3c561678da7af5e1ef0b6a3a357ac279dd7504b0937a730ffb6777d48fadf68ecf485281e6037163b6bdcb90dee4c37d9934c2d6c16a2f58516643bf9ebc5441ff46958c1050552563d45d2f9f6d671b0d54e784c1b684e892560798e1830095211b583f0de446d2ec8d4b7b8189a8059216d36eae579bfa247778ca1c15c71404bd18a52921e17fd610fb15465fa931ea2ecf99869393e601fe355434b5dde11bd9435863497a22e7e5276dccb03ea6499986e221c9e58337868fc1a79c24dce134940946f910eb6acec39a98caf3cd483588f622e90fbadbe35652938be8b308b647e85a8a008a95c1cd68079f075e41164682f829ccde07babfd7338c4d9d6ff88b18e06648a82eca0fe76397b8bae30a0b3ccfd2a6ac4caab5ee55402c7fd7e05f5333a3f8cc30d47b9ba456f8962a70260cdbda45d03736532b91840f1f4e8c7001f79deada0bfd7ef99d24a071a855f4593973aff55cb6b5ee7c45ecd6e65e6acfa47cf4136eaec67c6eb3ac7d4f8c0b8f29424ae4ef67bc56e6fc68381fc934738ac63bb2471fb06c1cac08fb3fc7366792dabd6924bfdd0547594b904869b02b83bdc77f7a2e8ace51043a6cae61e1bed78fefaf792e4c205923210bcdc5f599eae45d684b12f30724d50c1c6793185ff150fd17a6697373699c2fbe73cb527cded1326bda44e6de8db4bba23c53d32ccf0c6e95cb16c59b97482425a2d9b33f2d9117059d98d8b8936fb48ceb45d45727cc4326dde4334301df64e02dab509190bea9740041ffaaf627f2c8ec075b1b33ae8716cd54e40cf676871f728a35d553320499faa9050bd6ebc48e42fd2b9cf5cbde9a6e0fed232e30745c71341c517a68b62dc5d918d708980db33c74c4724db67ade830b87c14f318a45bb8b4a98b7eb52c1ecacd3b93e96d8c30b90940f09d7aeb0a6d0797af8353894960c5acb98fd2396e3fd0ccde2e34cc624435405b505a8651d63ed4419a72975a07d73d23027e8920335e9ddb661f682280a07cc6411209e1304a274ab4f01c46ae90c26381b92cbb7fe8a2a28d817c8ff828e49393d127e7b36f08fc8cea125ea5daff894cceb9bd84c14193550ca3edaa3541df5f25f3f4c36abdf9b511d076196abf03797b08c3f891ba2f4e525d63300d4d7047cca7c573ff906f0e08d791b67f6886361e552dd6c34c04bd636689175d7fa7428bb9611543a2291a3be40d7393ba3495b96347bde981d1faa63b44548a6c36bbc881f10e7ae71b80ae6e89bdbc447c3be75e64dfe96c826b30027a51511828a441d7d468162dd78cfe32e2ef84ea2df66da1ca9e4518158945ffd1ed53d0430c073c7efe38047c51b1d244bc3ecf0dbbb63f41e7ffb899c04c02c6c7f29c44ca30720e684a2165804484143a0a04750b910d0ffd9f03210c5a02f83285b3073644095e587603005f5e803ff5c3509b49590cfd4d41272463a54b7a93f195486a2a7bc7c4e601c1a01931af0980fcd1d634a8599925e74eb092383d9a615415223aab053b87251b9a4ff67602400d6470b0878bfc67b9a96a4d1e3c24383247d0495110e172793d119fef771d00ff77994a0e3e889a578e7fff4ed8e68fca81a98fd2ce7ec12d3e91e446d5bb6b32be217337795e9347488b81fd2afe7058d646736063c73905f692cfbcaa4e8e1239992b0b9986b7bdc9ac05cd7bf01d2c097763dd68ae24fae62a8f51f7c387f6ada07f6269818c65299ea1a2b12dfd9a44aee6183fe7c62e7f8d3e8f3da583c3fa3a471307c9a2264247d891d2dd334caf4bc901ee67ef2fd6cab2d551a83ba5c4960f59ae46bd67d505b056a1846dab955ff487941be276d0774375bc075ce39f04da2904640956f5b109657aceb738976c3437c2ad137d1bd55d44318828b6518f4ef9b0448b26fce91ea942d97b981ec52bb0eb41c5ea0c2c586ec39c157123d43d24ecc8060ef4f66aadc7f6019516822688f3a93cf4023fcf8b8b4168fc5ed4f3efcf3ad729bde2c1838456f23e4bd077ced90e08acac049843e8cecc27b1e44819b39330733907cb8d4a8a274168e9fa6eb1ba800abb5c02b604a76ef9eb6267571009dee242390d610fa860dbc860afc2036996f670d33f40df5cc93af3e05cd41bae0f163d22d3c3289937190fe0a56ca043ae0d4c230b2bee7d67b0791b916af3b8025b84c38bc56a30f1b57597b9a1b83c8456f78901d5753b2dddbd76c70585237ed8ec0f98039ee7d2485b063a34d97171e17281fbee0c0d6dca74501b6e8230886d4b5d8cf11db9cbd766c1b60d9915f8238fd8acbd91dec6b20269332869425a1f6cd8a0a7fea46971e649b286b194f619e43689c09f3445602adbbe581f5e317bb1dfbefac5b1217665de163174f753891df4b009f9a273a55b6c5f6ece572c10b50c4f8e2b5e1e5e309e2e0fea09f617799a8492b789f90b3906bcbe80eb4855e43436247ec1b9acf078729e857c25ddcc6b7b2e61a2ea857301f1d2ae7b953f9d36deeb35f0c9c140b15a639ade07a1797766316c42e8891eac5a4b304db7731a0ff52aa0d3e156d03d0bb6eef81d6d24e3093f83bcdd86d07fb70b03f5b709bd90ae07ee3933608b74391d6c95670339dcf6a6e9ee38c753bf77f56534b2348b60a89d755b93737462047694c544fe8a00f9998a072a3b28fbfc8f55470d0ce4e3483965089ffc14757f038c5ae91e640721fcabcb1eb6b1d2ca6f1f7b9e0318ef93dee5f89b25e75bb37e123af046a138f4164da8795d44ce21ca7c0e060ea8303ff5149735da9238341c192e2b63cb3b57886e171abcb11cfb7caaa6317ef71eaf7e21fa49c4599609e8e85233e4cb62bd8dae715bd645edf8671449472d300591c077e453ab419c8055f63d06fe8069440d596bd69888588e4779fef712da2ada76b241f44af1e8e99847df487d7bb848151ae838f5d142f47f2ab2f94d605ded9b7ffd6c0751c4d23dc45a7780bc3a35cec8d153b671eec4187f5edbd8a9e53ea8d2548043261d9a039408de4a168cef80ec1bb1369f8839255d03d771a0b5ce6294dabd01cf46e9c65718430ebbc6cc3defe6419f5807075060f67def9dcf867c9cb1066917e3ae09563f11a8419ac7f74528a7d2ecde6ec38a346eaec3b2f19150810b09c09e4f31f1943cd9ce7cb558fbf41ee111d8b385f77d119d81cd3fdfc5bfb2d4903b4f99d649ea4a69f0120db7c2e916a3cb285e889eb3ea95a42668ec2f15a3c1aaf81447957629c3b022df18fe4098aeb532978e2a2b0ff4f66cf6789f213efcac9ae39e3a4a9cee2257b4661ee5081446681e9030d9844114040845c78070fee4fd511133a6d6a89a1799033e6fce36917bcd502a17cee54f94f9938e5f95c3ad02d3197c976c6cfd7bf605c0bb6e9c0d015ee0f126e66e04af6b4c14675c67e894f7995caa2a4ed9e7ff7dbadce075eb065352b61087ea1b4137a0ddc2ce06eeac1d043feba14d28331986a1219414d89ab475c6ed180d363c2f0584e371907bea294aa0c1e2a0671f72423e8a6008899dbd4257a8f22b6066276c703a7f3968f3ce6b26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
