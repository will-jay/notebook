<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5070d02097833b46dc940929993cc225ab45c08a9fa4efb557200f244974186fac5ede352d3a4b6f6cfdc6e26195f1bf7b420fadd236f49f5571a398c3fc3459b4d68a7b96a215d4040dd501b6c1591838a4fbfddf7f41e32ba3504f02017dd6451b17c946d4b924007e0712e5541a4cf1d667b2ebee1eb9fcffa69c069d03579425425d76577c51a61811a5fb2ab8ead16cfa2e4df3a0b4622e7f7796269e99d235fa3b45396563f1de4d3a4a8ee3c5b08f2050092f5cf6315d27abffbac9cb4c6ce93915e7b29590cfa2d83e9c05c1bdee4ea7d99c18321a8978beebfd85b27f3e33072a1f4f1fceb1c931d06820a70579f8f2cc2d9867f64bc8a59585c1932fbf2d1a66789d3792d696061243b139aab09e8351083ef2753b3b191dccd2b48376468da9b2579d9dc44850634aaa5f439fc03d6b52f54f3261ee619f86d3dbc0de4617b1c72be2342ff4e5f43d6d1ad92172469acd40dff17a5bbfd0d7c75f3d2aea225949d78433747bff9af71a376515705d9423f330a331583b34909495dbf6b52d8bba1c1889b2122f3785791f8f175076214a3af7d4212745b1dc1c5550d3fca7f2feeab6e1b303a7d16c75f8b9181ed7663ace832312baa663566ab795fb9804a076b06622324cdfabe67c290ae328275b9251a99297c80cfc04125a4a66bbbfb37af64645b79cb1b55a2bce736234239fed77ca186aae8a173111e83da1d59bc37ea67f3f8b7859031597e6c5ae9a3bc1437d66899287c93b883264b39ce12e63c40f944990780b3d3b6ef7d80dff53e0aa1bfd689f7e5f233a85580f6c7aba6f5e06c87ba97e02b91e7149404aab942f1cecd8f155e0bdeb6f7e43227a47a896b95b9ff1a3bd5e548420c760759431a6d0c4628b6a4172cf9fc5e7da3ee68eaa26459bef428f969ba3960bc533dfb06e481f089a8610896305cff965a3cd2f4a02dbed901e7e2dc5c49321298d6f438c41bd32fbbea4634497325c1452bf5cfa4c0790a875245e452fa94f3bed109c3867503367a7ea6932fd321ad31eabad905de4fcfce8bc2e3ac9fabd955a23f4cb06ecfef178c1a83bad790e358e6d18e6beb4c8ee4ce876d0da4da3faba8922ba234d578d1305830d2d15ae45c135c91cb28d54b653f7ac5091b4505779a73ef06138599ac1ec71a39e99f486e10e6aa7f87208630f7fd6f8a8957ccbfaf2b57807c79b1029ad12e48673361305a73df268850528905c8f6a7d2414d0d3b2af07f219e2b6794adaf98b9821d4f74793f91633a79fa31972c1053213e21e10f2cd62cc8d2894040c3b88c4171be996df3d69759ca6336c9bfd5c0c32f397a4610fcb609e052f2f75011d1ced805a0e098f9701f29098f3a05584c4f7c03531209804839ea36e2e7f53dab05908151281384260c260fc8cb4d0c09f9a99097cf4b3821dfd8c4cbc0bc6e3610acc4d0de2b9e9827572d909a0d2fb96978d42b689059a770859517622f25c2507d68abcc83b9068f05a350dad5a4693fcd36d8f3b741099d7589445700d83e7ccb0687f1e48bbd7fa743bd3b2d4852987d431d674ac767eb24e2c2c93166b0b5c9398611e0266b1c2816a7933179d79cf802c904eaa77c17b1c64fdbec2e8f3d570f4d0ede2cfe5228249fe66e558779de1ce05fe0ffa836ecddac0a6036afec935f02c2c9df248b391cb34479b4246db0798e5de33633d7fab8fcc624ff066cdea9b659c5249e7b68ce2a7bf6ba2822f9868d22bd47fbb105b354f8987a8bf56ca8ef6bfdbc53eee9ce01c07daf42c30ad49e9f30a5d558ad9538842aac58318895240cf6f73934eeca00d67051b9d051d467f60ff21776b9418b96052fa5334f3fad1dbc10db8b13a82599e82f1f1cfac81d25519b43edafb2ddab999f2c01d45b7e2e7f8bfb6496cf69ee6c9c9106bbf8b208e53fcf95dfb63494a94c3ccd9f24824a3e5d121584dfa7f26c9461f20276d9f77c12623f40ec1541d49f79bba463b231926b4902cdf6bb0ecb1e95cd5bd7e2dc1f8f1777d21e7ea86f80492be7ffc0fa119fda12701906606b541eafd212c2fb2ac4748cdb02ef4d2156030ee3461d2b49ba0f1da7c8c1041c62ffeb5746e18ecc4b288bf40a3eb73c81f9d2414f22cf7318e732ee50d614cdac992362725d4352ea61f461bddb73024d49fd5bb82f9b931784197bee374e8b7a41013020225e8d9ec065774fc161f5f838def2d6bb5eef0db53d1dfdb62859b6b2737918f1aaf22bcfef5206d2dc680085255ad099ff88ac95a831744d03a95448449c32ff219041b93dcd7ee8b829e6557e016d055e5ce34a1beb794cffc8e1fe8903a84b355f2f83c55c08689b99136cc5815b0ea3625fc525fc58b8f71034793825fc90523fc3ff63d0521bf6d21e67c8fc7202a091b09a7b269011ee17e59168acda585a0cce12cdf0c6a48a8faf5a326b7a38aa231a66c476b3c73da001dac40c5ae2c4ea1b91afbc7dcf8e5009e0992cd3b6db880875602404cfaa18e3c028371818a07c340324aae318b4c79c715ed393df1c9db1968cd19f8c28e371b9fe9844ba6c4884cd6c19e13786ea2a219856ce78e10d58fe21f256ef47681e8de3d27ae319f00a4438d242632f69ca38e2edc8d0ce45151d1f22a1a8aa0bf2780a2043bd00822b503725e3712a4eaaf82c93a077b71d43ee4d7e91e37f5b8ced898c3093f6424302fb6e86ef9b6cfbb9e02e8400954f419251f92d470c1f4c4372a561a0bd69907bf829b65d97acfa2defd8b8b74c2602b28cfcd0c7d0bc4a318b347f30a8a8d5c90b9b55d7ed1fb7ff124e987bbd4de40fbde2b8e132d67a382bfaa0676ded0d4f6d572387db57324c2ab2d9d6bed6230d9cf59d6c704d2d2fb3188e188ac2ead19bdda3047b1c581b2caca0cbe586b9c60a1922975d4e03f2ec458feb6494904a5a6b14b8ec2bb8ce504362833c41d4e3cbe126e8928fe3de3d0b3a374073992edb1adaf0b4c2eb986233c1f101475218a5e93e259fa3e67c5c3334272850f2c6bd9f90e884a04a25ad2cd3936be40227103df5a1cb4cd3f58a9fe7928fab38517ed4c01cf578ae16bc75ca4a034dc74ae206ac95c2b4b13d633076e095f593438dc5cf4142e752bd5df965a9bf0e3f9d97d50cc9579946b0ad1bbac1efdeac15be5ad2a898eefe3b4fc5446327f4e1d237a94763e52f2f79ed50209c35d8f3a605135fdd6222937e2c29051a2281a9044a1e2433d1b5943a07b2c7081e2c3461368ea0a17ea68b2799e4ac52ff44e20548e79723d563a08528202739c3377c0ba7023d5f11c4db6cd9d4497302a97bcde969b2c2c4888fd4e52dbbcb489a0791da2ab6e6c4cdf5914523e3f6f4b2f645ed1efa7257a38bc568090e2992823671b6f91775802e68d98cf5ec29656057198b7d0653500c69e6fa8ed655922dfb0d3d4c79e75bfc380d2e495592e2b0c997f37dcc6d73ce022e9943faca079567d3d93d135e122ad351b613b15febf60443da75e2d9634a244084bad30a602ec807ea29e8901b0c4c2fa0b6f27820dc5b5147e08b17df5750e87bfe108d7e18ddd5d6b9c8cb3fa787caaf3e95e893ff780e13afd339d752dc7d0c5f035e246b8cc90a7b825208d965222aa87c3f6c150e18263bbced98fedf01cdedc7916d826350eabdd9455c6ee48a528f6e3d88e3d0f4f0b1e5017524d1d505df637af20920c41f4b73aac83aa4c80092837b8f74189765592f4121ecd8f13816811d0eaec085f5ce5552343854b3e418fd20fc66556cd5a48b583936c31611f9b50b20cbd5f3e78967c7dfa76bcd6060156865dca78a97e20f3e1b766f1718296300629540ab01812de7d06219f4beaf05103514b9197dfd0aae100e79c5fe05059ab26c6e8dd65f1f1ea1645210e60fd8419fb3bc7f187c891d85a36fad0ba887ddcbf491eeb8ecbadb2d894d099876fa486818ac5f9d6dd9091f1da25f03303b92d51aa98654dd3d01ffd436cc91a7c65e909f66146e753712c3e13cdbda995b140b178c2c60780462e710f67d866dbb6a79c42baffa712a4963a7808dc0cfc76dc8e82f064a6b72688c26ce8be847e4c607578de2ace93423bab31efe99796c4d2f1a4361c2d045c4c7ae08259761fd368e1af40cc91ebab8bf72ec49932a1d4a3374b6f6f61f9cce43d8f436e7965af1e124ca2d1d442007487be39b25879326cab4b88dc38e56201e095c39416322d70e01b0563870da211bb679345277be313f57c0de915c7eee9241e57429604cc80214e04a9b8e14b20fba0a57edae1f8a50c85877fdbce331043207e789c18d5f5d85b5cd93dee6f1deae0173ebca73e6c307fb37913cefa00f14a9191985d03f5e0d51d6ac2ed8d5863742d4d0f63f3da6454535817b90f87eb506dc78e7c3b5a8ee8f6dbb74fcff5ab73d55d53b9652ede345e0e928dcd3e00383b0d0bbee1b07a569b98e02ddcedb6411b646663521650dbefee2334c183f6b3d9f417e7ee5dca342ae9b5a9d6d41aad2a210e51007ee34d2d44bdcfeeaebeebbe0d9a4980b04095c14c3628e2e0a703f3e6394f8a7b2a98a5595ef42f762751eeec9d22256c2e13dac9c739be35ecff45cd76be811ff95dd01f2def71458b16dc307a5fc57093bc16fbba084392cd08b1624e338720128ee268ed37e3208b169654db35713b4758bdb066acc4a479b5c81cc1688086d8cfc110db36bc7464698c8065f23567f595ac85d9381d3e05ea0e245e3ea46a02eeb8825b0236935fe46a5bccfaa4db5180aa5f44a71d0d58492de47fa99ef577fccef06159ce9742bb6711ca92980cd7c692aa875bb6e0fbea375495b6b95e311aa8556a02999eec0f68213ed8b7c194f592a919ecd154f9a480f72133f2ae369d0a6f81c760b59f783464d65abaf368b0648c30e312971d204a89de93723cd19e22db1773a2b153f84759d9945cad53cd5a29b656daa2be77d35fa1f13ebbed16f2a8a6997d777f78a3bb45bf31dfbb582e11e6f8cbd5da098098d75f23e2562ab53146eeefd9b7ac2241f73f512e107449a2e874beb021cfe227ac55a3787bd278176e771fef04b260da402af1c3d28cc55cb409be9c345fd81a381fdbbf346d89eb737bacedab493a9e8b506afa1d2c93975e387e59c8627955702e72dd7c01b089cb7f73774ee8f4c423c6b2d5d07b12188f181dbfa9ab590b0e70d7e6374ccf86bbf56016cc4e49165df970c8a6f6bf699c248cf9fabfc3306de51c8aebea8e2224ca343e1f0c59aa793e1f26d5b8354816f61e85bd6429bb24f41fb36d1b29394fc8f324a16339d6437377089992f1e3496a188009438bec0b746c93a4a26881499fa84a37187e6b911243b91ed72df41bf8f0c360e408513d34feb4e697a86421080584c626505708b7b05d1de45b3d52eaf83a147422d9955e37fda3ca8384ff6af56f354cf56e632b5a2a9af62244766003d6af790a6abae5d1357c456dc9bd1b05a64f5e722cea410b0810d7803fb2505bc4b80e140772d4979be0146ab45d31643b5bb8c807ea03196e8fe9d2a4a4ce5079e5d927a1b365ca37cdd0bea7aa721034fc65de404fb4a4f9b2a61efbb671fd4247042de49a04ce701b8c6611aca40ada21089ed14cfcf5afb9edc4263f24ede606487f7249f9fd85218c01220315788d7963808287ab7d455d0799acecd117f5b857da70b79a8789eeaa1ff86efe4d710c0fb41746dc46caec84579c379ef8393e8367a63c958b8726a1b2153d939919ce4101a7c62be56d4098a4d195d9c6a0beca4753dea72fd3a5c01228581133ddeb49703888a838982c75ace08d2c6a0826696c0569d1e88790d876e17834aac5169a4f14650bd0a1b4028cea3f5b88b7a81ee5e622510a86f9ebaadc0712bff5842f467818e971fc523cb2dc6e6611d9f8119d500f80d69e8e897a5f4874da7662b6caba26bd2097459ca72f4cbd3503fde94e4151ba25c4d3860ea0c64bf336810027f55cf06347a7357259c636a898573ee65c03dd0f1319da1864200468136de5fe555fa034e8cad68e73cd9dee86acfea00fbbe0a489e1745328a0ed2d99fd58d0640e0a528308d06f404508b423e837e03bd1f059fadd970278cfa9c1d6b4f4e5c53025a08de96b8ecfd7cacc91934cc1779afaabc2ce28965ed7aef057a99b8f88bcc777664d9a82df58e948693f96f8565b881c6a13e8ce4c5b56730afab8e14646a1c12d5e0d064a017b48a929f5df00e03bd169d10dd27a87c20bc3114a5b6093de23371acb22f67eece689a22f17b3b22ef6f79145ae30b300e8d1fb530feef3ebed95b8fdc5fcc4602494bd07a5a5537d00714a9fd04ecbb0783c7a4632d35966858ccf44d2b0f931c778b780bb82c076cb4dd995eade1113cf83c8f7d4bb1268fb4ed13aa39a1040ae1f5db20e756a5b9eac2fdbfe1fec5b23564e0cb8966124218e545a7dfadb68c3e68a6866273176838043c98f1b75003ef1e7a10c344452436e295ed9773c750244cac2bef297657c49b9c653e6071bdaac22a8b6bf0ba761ac8ff8d966445a32923ccf0ec569a384f3dfab3904a795e0260d4069702856ee635a3054ba4ec7b3795b7c28ab3c3a768351a61bb98d7a25fbc3847f0d55c44c40e11d14aae9ae4adf40c4cf7ba46c4ce2a7bb201aa33f16adf5829f0d98b5bb606c43beaf1fca9cc5d30c547a4c2f504040d5d68b699d53aa86a23e77a04a52dede6fe55e5caa6bff65b94a8da578c6fbfe0feb583beeeb783f56e71c1a5388efc0e270e38589df6deee749ad6e631b2c237a1f22e51e38a5f19c447f59e3eb26c4120939eab7c9d7885b1573730b06dc0a33e93bd4526ae615198067413457db990a597765b2d056125152c374389187217da54d755c00477783fa4754120118dff776070650595830c75482cf60326bda9df775c1731634893e9224cde51a241545251dfbfaa1335e4c6fad6e3caf875d216d0979d74c93e4ed3de9575b914ef2bb87cde9fb43c6dc8e341e14e3aa1ecf45a22d2c0746a86e6fd2e6e7ae30d2fdaeb5b9af6b34283c22e4f63ca452a5234c9574a907409c7715d3dc1703acecd87ebc11c2587553d904333054f1945683dbe8725a37ea045d492bbf0575047207a88eb3fc3ea67dd2cddeb3a6892eb7ce47233960505eaa991b209ff900e7fa33c6aa97f7f0c2cf95a11b3dc4607b7c2bbac27b82713cc5e61c99f8f2333875a77be509c650d728940939bb6f28bbff0a1f4d792b665a33f52719139323223cffb126243bff3f1ac2bbda83086298246a8fc224994ad27d925abeffc4f66e2d527e68a204d71b04494ec58afd1120f99a22ee15b4e395bb07e5d903e7b50931695ebfa85c28282a75cc326ae4657718c429b822a057c51daf778443988d243ee6ad7ca8a0ce0bf1706b264e4ec4d416dda82c4940f4676544779195327cbd6c540c5d7f1efe2e9dc26e29781c774b065582bfb92605fbad957b7d4a6877f8f9d7b3cb3394a3737d9aef7999856df0314f296046c1c29d4be21b29e0f1ccc46162a2cf60c6a67a629d22023c4d38e205cef319c90a87b2ba99b2c97ce2837b66b35f46ef92a8d13927c316ba6794b32393369af7d5e21a209e908e5e297c0e50ac8ecc7cd0b680f208518aaf9d21d07925ed8228fa08e353d93437ea4c8c1030c36b3dc43fb51db5daa880fd72c7d7bb8e3fbf891756f321663abdbb835a99c51a1a79175762d93a46391edfdb51deb1e4feca63dd2ff326c09ff619e0900593d74383900306335540caa135fc91bd67d8fd7abf3f795e65ef41b848a7eb2bbff4c94bb362858b747b4854962a1997e13ecad4248532e6b95a18e8dba4229f3a7766c011ea90bf06130d728854598f3906d168df9e65dc98e44802d28e710584e346621236c5d5363495449f42debf50ceb3fcc88d23772066de57e0383ce1fd2cb718bda540944bb75fd0c9d42d9c2cc4f24df91378a4ac80982520b39a228ca8812044bf1446f5d5f702e63e0c68afbffaea0d4b8dc336431e8b39d074e1b0a664f60bad329c63d3e9f7f75fe10b0f4dea05ad64d68deabd74e205f0b738bf891d1f24ff6d70aa9f7f559a0925860ba2e039b284e3f80a5bc3f7559f0995ad648df3bbd20366ed54f6faa8107a77c7e96bf4be4892b2cf04a1546d8bff0d302658e98698bd8de6cba3e7f85bac02c74a23bfa479c6d7a7ca539474ac101eb698bc59253ba64fb154f5374a9c82d743dcd8ff6548c2c3910b4499b82b22cb2e1df65e61d85bd35b1160d0258434238e17da4b82a5e3c37ebe3609dae2b6cb05571e84de400e040bc49a468ad72897ccadb1f10661f923c37dab8f1ea388a5d500f14686f595837d3454b661c8226fafdcef651bceecbaa03dbed91d658678e0c2d49723026c672e82b2c90a66bfb2159409228d16ba3350ffbe7ae3e11596e3a73d61f7879412f3025534709280cbd6bba4de816466d95bdc11cb1ad7a15e3e38c2472d602875db9c9c669a74b20089bd8ed201c397045f9ecb3a704da14fbd95ac700189cddcd37e8622a4cd929517aea2a127f149c64fe3e60598d5be7cabea68121f1ddff3bcff1ce383112b6904e0f6ab526faadbbc8067364ac8d452e8d3d5fd37caea57ae0d18d774017f5cf2cb88c2008911e3051227e5077e4d948089b7e299d3d6e5d14f6edcc38be0c94103ca3cff4f6c5e5fcb102dae3ced726fdc3682a1d191edb6a9226b89e4cc58fcecb491b1acdcfa800bf777d76f8b975ea02101e98b5f7613a822305fcb8ce022de55711e527dacd5f45a10a96a79d8ddfc3f33c954722652c1117233ea6d7031a3a4d696a8a6fb07a60ba54dc7bbd84ea2a83cd57f0923c3d72eb14f81a195863d8caa4de261922bed015b94028148d93292025dae2b39e9625154b06fe093ead1046a58b67a3321a76be37684e4c6427a175f070904877a8f588fa271d145907309a6bf841466b520ce0f38bc1429cd280b2b76ffeac9390f2728546e1a32cdbb04f5c20900db0b9869f99a9f0bec7b4aeef7541a47a6ada901f5d52fe5ab447fddb0129e1dd6839108cf5806daf8e3580298f627a52715f1eb690624aac8958e84bb36c20623e168a9c72e55d05b480ce6c163da8678cff661d81ab426894cd86157ee7571421f06c23495e09427f89dab905b45c47525554a68749f088dec36cb1b176a88bc4ba54a0f8a38591e538c12a529ddd2d8ab02abcc513e181a4b4362942aadd3e6048997d0f1119232597a800b77ea1f519686751e1548eed27adf624c1bd581413b7c008c2246fd286ebc6384c7d090d4ad8214472dac93fa7719240239f31b617145a3a8ed81cae969f7e99ab3bc868f8bd1d97b10e4fb31671507f792f1643f9c156ffd30f1749d5908926b2819f477cbd866e703ef4c5e0745f6a9535a2f18ebfcb650e101457d2ecdd9d3ff48cb5be0e477c6da6cd63cf76573708f24868a78dd3a707ffadf1583a4b2380fd4faa80baadb2f0597e517ffd6dbf0c946323a1efa4dba2b854e578db7de842f5062b03ea4063541547b66fea4cbf6f1c2ad5f58701a4bb708ab781aca7428c0a587b4d33f7216828d1f61fcf5e73cc4671c304631b5b96946df01dc72410627e5f3aef266d10cb88ee3de1afb6ccd8ff79a39276821934fd724b72dd55b35a90b160e63ba546e68d6b8cb4aca97f559bf5ef8392ee500fda57109f3a25113468672303f2db211963243183f26a849ca5dad08f687ce2b1f27fd2a10066cc2bc03e69d0cbde68ca0d9d34c6a3270c1205bfab86bbe0e7d7bad09b43c107c10e9f19688e78843601a0150b8b03ee5e774b7dc6bddf6ac5a26809e6da6c9dd024e7beb7ed0fbdcef2693e1a391e63b63df753c71ac8dd1d51477fbb4190d8e2255504e93a410e2b127a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
