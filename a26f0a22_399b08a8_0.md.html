<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89cbf9b79647ca1e0243b718490e1855ca28874b57bf5be4fd51d97bbec33f71b3deded01cc8318d8869b6bfb4a6feb6e52fba80f0d4bec6066d7365bbea7e222325658458958dd4cbc07e7893f2af417493e77fff0b184d57348d3a2c36529e1d8a86c5b2ad5936669df8441be9e325391e55765b470ced110ca644aa9684efcaa774dc34af0cc8951263b25ec60afc74f4f3c2e71afb28caf1ad08db2c8b65b28b0874c61b77b0209374842d8373f44a7c951f12a5aed09d6dee3c307a340887f54c00877f49b2f971f82dd7c177d986416896ec38609cb6fe484154c5e933bcb46679ace6631b49eb830486164ed0ff421919d58123665d0acd3105c2a5838803fdeeeb79480460bab486db114e43d955c40fc146fd807c727740b86a44614504571033c1eda61b3b0f6e548b5800bb1762146e07a83f8de8be4a9b1f78eb00b13479522df6411460f267cdba4200ad62429edd0f399b26706fd401b35140b12b20e9dfb601020d81f386e32f5da8f74f627cd33200104d13625053d9774e800dc470479a4a24cc99c04a0850a47e0060224b58c0fc45124bdf050ed6cd34b2f34258fd06dc0a8bbe9bbdbda71e2ce6dcbc65636565be636db4e2e1dc664103a98851907f6528805360e3dbd0dd83aed8f88a4aaead641b0b1ca569e195c85ec8e1b54baa113b9a6cbabf95bf6e398fcd1de16a94330dc8981ce90080d8944010d234a7fe35d90c4b78f161fcb44fc346353c0fd4000c2825d8d034ed67ab89736341e27cfc6694c49a1d7af454931750f5af22ff7fdae4adee6886c326700b09410e0aa4d1788eb8bebea69babe2f48d3b8c9b59eaa9520364d7670c3f1ca766cba2bc1038b61eed3521db5f1d1bf87a7f61665a6f5c9413a5f9da25babd5bb4d384abcf8fa3d6e6f2b078ba27521c218adf7dd06698243636154fbfe7e6120fc75574ec375bc0c4796c2794a6ce73203bd14b6572a99bf58c77b5d1182586280353a9dd720c1420bf9ba8fa9af29a9f81c39d48a0d3465b5a6554f07561e35f7623b80edea466d41c445bd40dd9e90c3ac7b18f83c19303522e282f9baf5eb4bc6e3041dcf279a7d400458a621372878fdcdb328d3e4dc1d8d13e2a253f5449b60eed49f0cab39794c13d2f702d7618d7c402edd0c07547fc1a0d4acec86ca1b985c18727654f804f7a0c1c756a5b826d98919fbd21935cf4307cd051495c2d431a22d2fb3ad286993c634b26dceec91652e1c2724083ef2f133b44d6042a5a61fdd3924f1b43de683a3879c4b729e6656bdcf1e30d897a80799cc1ab9c8c3e347124f0dcee682cc11b2a14378d2cd4988a7e73abdbc8b1db5b228b8ad6a7d20fb513ffc9febe67d599a7d0ba705e7e8a3b63506f450e75590f63decec04332a62fc19cdabba1c5ca5b7528f73f2fa6b3944cf2a81607af96c7556adfd29df34569f7517f1da0b8fce4671b5052ee20e0f9def94e3e51abb9d8d1d308806a27a8859bee09de518672ee21d8fc7f07e6e29e2cfa9539cc89c85559eab2b87d0df1cf7c7106fd45ef356b434163c342376447daf5aa6f028db5db313a8e5b6c62a3de0ee1a452f49229f445a1a57b21ce52ce1b96c7215fef934c4f0acb94038fd9bfe8007dfc67338ff4972a791a4b035444c7d5f5b845a8393fbfa5a47d856c7af1cf04373ee5752441f43329691dd50c23f4f50fbc7c62e34ffa425d34865009eb8e28f4579783e078682f03297879d872479d1e46ff6bc5a1d9ff7c01f1f313ed6e461894adfb7ed8cee4e304f34bfe1e25482d9cf36885d8382c89aa2f2bd5a348f45f58df9d6ca70d2f41a44eb2265d8a98f039ee5c937829a3e428235a67225b20a260512d457e17e8beb254c712c2ca98bdc85fb8b7fea93ee186629df1387ba3109e29b671dc34af57459188275da1378f068f083952dd52b1609a9f819ea58f8e8587453661c1824f21089bbf0a17aed11a2de1fc2d435e70a148bb5052df07b2b91ac4ab520fe546ac19e41c88fcea01b5e61b2b7d56f54417b5b7ad60d48b55a7ce2323c73a092f7dfb90a9f503a8611d36b159af43dd263bb3e8ee7877990c2af66353ee518ced8110607579c47f4765b75a06494ecb60bcb958c8975f808a7de558780a92c993c6fdbb97efc71bab1cbf55d87cba921b1c83edeb479d984da14a5b625dbe6ae5fb7ac7e479c8dc3540bdfeb12f4628cb0f82962328018448333ced3c9d8642c551088289deca904a8e9839c1318c19d480a039f95a3e1ca8630d7e7751e063ec1685b2344f6762c1e90ac7318d4c93e5ba1ef95a1c6e8ef5448651a1778aa6722038e33332a6bc5c3798b34b36461fae7fb87e1960eecf0ba939c8f36c189d353b076e20b5e34ef5923f0c26cf5984d2697d485766b84d7159e6551ab992df3bc6086ecfa043bf26f78cbf3523860dbaa95338230957218cd7f610897e3537c3f5bf6ee26052a4e4c5a39804f82b345511612c494a478281b29152ecbe31261bb3e59dec487e9adf9998d38f8255850f9c29107034d7a0f84ef3327a4dced1f16f9252e2800eafce3f1da8b3fe02c79fa3a52fedccd03843ea5a0c09d1b817a7d86399ed471416952be9438d280175a1b66147918d30b5448b412e54a9f53e88b81d47460ea1f66c71b43737804be4a58021aa158248616d9d5e9aba6222eed7568af5dc9368509bb29aea729569e101d4f63b2fbfac20f3024e7bd2ee1fc99d3ae4ff1ff2e18468a8cd749a2e628d6d403f93d7994c03dc296911c2d317563ac4f7ae6303d29b0324a2b357aa0ec6e9e356ac813b25486d9ffd9fe1e90aafa0072d49a26fa2ee7bb23a7804cb299090af7c50305c2211c1e92f118cc369ebbe8e49956f718320937fea282156c0ca1291496fc98508b6d4bda72a005d15c2aa4c866c0607d92862a8a489a73499dfe8281768222933780f44523476b48541b756b8ffa677fb2872203e801544c5f047c4bbbfcabde2417019624123af32c2fbad9aa86861f041509ed0ca1d7d28eb4cce2b748e13101f47a20b5a61cfff1a8a13636390ffb5b693bfededda39c508b1f8d9d662493e78ab3aad210e065e71eba724d1327acafd2e5f4848f9b6828438542e4e89c5e33e954c827c12d26b7907ab65819e62a3992dd9b7eda1845bc23e389eef6fe5882292ce53ef94391c4d4bd402ac5b28119ebaaa79c8972d40d9dc54c0c01ab489043be979adcf4c497cd55a17ce2aa742091be2c6fa2fd409729c5eea381c082af3c1e17f583ce96a5b6163438b33a8868e24560fcbc6d075c84145acda6bb484d9156f51f18180a8b49b7d6e7f09c296a36c01a16d0d5cee6e67f303a0afff6cc8caddb8497001fb862686600813f5d61d0977702556ac9cdd2e96df49b2ed0d486abc3ee899566d35408f5436f699ca5e41a6da6498b853f8264bac0a73ac2d7fa9458b4224e92ed59c27a01d716b29febfbffa9f89ce5af3f4c34e90e3ff0d2ba6bfa8a0809f6746c048e6795c6d471fd3ec6ccf5950a492c4a1e54103cc96bc028cfeb1f730fda774f23cc64e4e831545cfce32c9fd90a3af6e09f75117cae3441c8e3fa4e0cc7d8ec2660d018f2ca673f22a8560429d6b121844e5377558c21bfb772d15ea705567d08ce4fc34f1029c7b5a62fc24a8bb652694629105e5aba11838e109c7513416fe2431c14546ed01cdf89910f535bd7d80ab5468e1ccc1254cad9c8089db0cd90f4a4234c4b0c6302a88e473ee99214881e836b6d3803a95447147888b5ef6384f2260dbf1b6b7b0996e4a80c656f3b5b4ccfe0281fbf8d32d39a859a6e4059fe2188ff3b7ce76eebb3a996ac28a538ac195ee7f9a9b6ff99e2a49e80fe95a90fd9e072be4c616181197fe15d83823b4fdc46b52500488344096104264c4a13ab10b4732f94522ed8902745eebab90d1e9a0e7768723f3cd37fde04ed2424d8fc5d8e28aa8495d4cdeec0af403f89461afbeb8ae8eaaeee97f9dd9e5e6f01a2eba7993d41269694b1695b25857c39e66fa65addc93996c573b6bf4996d05ef529148b661d97015c45b4cb3a25afa4ea13f6535b0ec86192e34683492f6e2c030664db6660b3de0e535e754fd15a26d3b5c7039c817a75fbab969ae11554402aa46b6942e3a2dbf0ac8b313e6a68bb7388450200c5df9e7eb11490c5f2914569fd94280c0a763c7f4c7e367b6e2925682b4c0e742df9ad82f28b38b5700746caaac9b5a343507c8ac35efb67ab1396466ba6761206f6b4fcf9a709731ffdeb4ccc63d9414f62602e3b7f3e0944565a969879c0ad4e48af1b06a0988c4e37488382fa4b82c02eb5da0f8866176d0af1a2888f009e8e935d27c5caa417e10ae5bc5f2fe448eb703d8078d6ef7b8949db650736e7ade05bed07abf642d0899a616148b054591ee254fe4c54482ff682cb931f0518b8616442e18a4ed52cb567b0f46072f8e1d8ad9e72b25d6c351a845685baa656df541bf37eedeb5e28a12671820c55f63c7e709bfe08c6ed3243004804880ae32fb29b694b84ab60637a45a8565c805bdd139f8b6f80b4de4842fbe97f3c19d1f4fefb04821160bce67aeb35ca116060b356fe77ea878a2fdbbc00ae6e446a33d0f73499a6eab37b19cc2796f36918080d366abd5bdd3c8751114b078f01f681e83133235715c0a483d25cefa50d89c144fe08d3d9f8ed96fb2467da3a2ff7fa30ef453500ca3dccf6057e2461645098a5b61319314b443e1ad1e0f77bef61dac53a4ef9302b537f5f37c0541a5939655418cdfa1397d10d23c8c3473f389bdf83dee49101ae1ede809874d8a0904a5f4943113b8f5baddc8b0432901af21bedd4c9fa82c56c194c928ade076c2d381f8e3d7af448da0bd03d4b95e2870e87ccdbfb6615923f3f1187cbc3ae063d5b02ec498a94bdc4a6e58832d21b037974c20f67cec5cde9b1a0c25c01f56e58015eb8bc502e8afb0c38f02cd13c05d609b84e9e44c166bf5bcb2d18aff5040058bb2416493546df4f8416c1ce11dc132e068b31e10ecc74deb56eec78735a1e8feac2f03c9164dfb40e3bde730bcb093e5e1a41f5d67090ce745ed67222f667d6bed60ce08e8a7726f0debc7f9e0b159f4b98e474048f2a97ebbe790d6bd9c0e59801f73ea4318c31e4d505ce83f40b8994f938cdcd05f485839007a7667dbba54bcb8f8b3be266c239175eeebeaa6ba0901399cc64200c890c2f8e5e964b67993676ddb29bb73e91ddab142048c869f7ce07e0ce9649fe4897ef43eaabd6b1a61eda0a8681127b1a1609da374ce689e8c6293f44343b847e2930b7a0a88c6a6f93cee064932c385d8156600152612c598994ef8b4f1f9170198f06c2546257a3ef7d2196a08ad7f50c30ccd6c136021692599d689320b09640795f45b4547adf69a97359ca1326ba084d6f315506371943267b4660d465939a6b689645def595613cf5ea96c8c36c6d15e88e7733a63e4f468bff8b5cba0051ceca4a10ab14aa9713a56bf2d33e930f9fb264ac01926729e8907e8ed279a50a85427e899dd58bee4f5c5dcbf2b893d511c32c20b0c34f8693abf8d910ea09b970e92b5b01269755ec2f6421438d2619bec258814a51a9c211651141a10b1daaa5edd4146d69cae0613937dda58d5555a70c56ce8cca00c6fba2dace17319681c6547793b293cc439588157940b6fb5e17f0ccc333a95738b1fc4a79d45889c184806ad0c412e1373bf9b58f773682a2bc5fbbedaa204bb79ec13cb4bb4026f1872928e056f53cd48ab36aa81be19d0878f7be80dcc5b606e68d80dd8afd50743cd88c4d2365942782d59519b653df96593da62514e5c245fbed39b2e9059f89fb11b3f6d938e98df69ebe339712fa9d94838e5dcdcb8cbbf81436d0daee30412033178fec96cbd3e1356ea61fb023eff1a71288f41fa7fb2c82db592f9f37f7dd4e65f1bf347cd79e9b42843db62d157aa7aa18428c9592fe34c4ec91a05877ad040c56f1b38a2c57099219597e601a4691b6c8fe88fee7bf724e02a889fd30150a2a722069770083448632b7d7f0b73a77ccf6be488a05c3b3a134440d33c931867b5048f9daa44b950314971bc57c4a8af2d5c7c71fd72d75377ec342dadbce4ada49f884d1bffcce48024cc09ddc4c2bcae076a3fa78cf065c8e9ef633133a9c505d28672f329b7638de23bcc20e0317012f79edfe0157f2816fd7c4f73d9d3c4fdee2781058ebc9da6f4ec8c77b86a95a7a0b8e5b0dcc3970465f76212f1b5f03f171c1eea60b7112fcae505526953189d12da86639292a114531c343b53205665899437afa5e4f7cb0eaf6da246a5eb06b118ed6128b0782d00e1cdfd49d9c9ce61be2ffcf60230039099c8874f6050258be11b35773ac5f0c301103f2dd052b85888ce256ddb48df2815889bca0052c03ea859b9f936e1e89980fd40e6c00f8299d5858863fa5e388b55d19ae99366225e3c5d22599d79cba74324b9dc7a54431eee88dbc782760d60e72cf285aa62e2d00a0398618a85016dcc6cef86ce0188b4ce9e1cc3c588ecafa2c70f11d71683f68a96253af09b70c58855db9dfeec607295421d5987625ed859198eb60d13f7cd2ba4dff8cc2f082a0e99ee3e767cbe99427629d545972d8bb3724b947f82220573b3b02935992ad3706fc4696f886573d3f752c3d87a9bc54d3196d3d09d44b144868fee5e1c0909e60e05c31aaab48b1e85f1ca00d64e192c9d2845375636ef4713718c404453a6aa6d4dab585eabb9c73042e6d68a2b4702e41526f57ea1577f86693f07d78a2d2be4f6f84a8887a5a04e1452cde70bcd78dd88dc9810f691545a32f9c92a04c486e53c103ee2f4dc5aa615feec53bdd43649f992d8d8056ebfbf2fc932ba4316f88340763a0aee03fb686edee7d18398ffa561e0a54e8cc1a49497e4c2aa3a5b2ae25eef407b693b760c4d824b411078fedb66c516937d0b1bd6f2a005f7eceae77ef78f8d6ba353757734f0db4449ed3a5f6c8db12431f6c083c4c1b7b20932d12252d36e1084c9e5767a2254071f7fad6729bf506f25560af2771930dd24a7a218f4a6da1c2e8d93a3e719adc6cec9c0e7e69e07437c4ee8eafee0a99881dbf493206c319551b6845c7bc8652763f38626a27412da2b14d8fde688ceb5b00c80a72f7cddb33c0e41d104b5b470de04583760cee4d743b6666ab926cdebb1288bc3703b1e0fd0f927994ed926a66f02b533610d573f1f035d8df039e026c20a3a6653dafff74f823c54300f634251161915700402285432e38e496f6fd3358c1a39fea597f050d0c34b4c80698dd2d98cad95b35cb130437230075eb41dbff4141e0793b8173eeb7368beef367fcc340a2ca3ffc8d029532bfcffc48698eb197fc14f05a15e9974901457f28df4ef7bc1b79b9ac14d0d73db64935d45e7ed3139aa4263a5e28a0af1c08d723e7627e63eed516f3330ad3863a79e11144327c60f6a352e5c82755556d6b6186900462a0a62226b7096081323abde60747b87fdee8714d089530000ca7a5f067f9fe85ee9a1e339fb9330c9ab9f8466bb1c39fb6936aed0785652cf8404492923389dd840a50d145437c3564731800ef5b799ff84b565994886336dbb3dbdad5943a7809ad9a5c76d4bd255b8d6540423bddea418cc3b5de21dd18c7d100d80431d2f0fc37a8b49e2d8faeaefb71df74b98c275e913ac12729ddbe9d10a092eb7004f617f478f192466ba63a37612118ef143523726e41734978e784d55273fe787b5092ac05f17292bbcfe19667be45253b7a9a671d8a45b681faf1edc7a8e65fd83266eafab5554010d8c4acf08834eb5f946e0f59e987ad2e22c76b5f288b3e95d609f0988a15301cd2c466b51cb7621abba1cc65e391cd192b238d82fb6588682a5449f1fad9bf47f80bc406d154814d3a5bdada850144963e00c5c6f593a466e9114f1b2491f4e077639ff997350899062574a88b47d24949df2cc61618d7662f6695bf690f4b4b3b4e2f5c7f37d85a8d2b4b962a66d41582c0fdf9cd2e4015b6175275b35789bfe8ead6b84adefc9b5befd83d9e1822b69adb9e6bd4848c111f5aec1d34a77c19421810976bd9a7e6aebb5b4a80b161635c75eff4cc5625a5283b872ced24444092f07eacf1ac5eed40c9289b9d0d1140d2c240e1dd55fc2b4b1dcc32ea9a03fa95c32e1813106b67f5a965c6ec236b38e232332b2627fb69f83abf7b5e8ee1a6cbcd4d00f90c4de55337e25b0368c0b90d39fa69747a250b9bead4fb08003e5b3bc41fdd92fdf952373921ef222dca159f6442ea304e5911731cb56cb768a84c3132251a73175170870e73cc5ce55cf463d9b60b16829751d2c4fa99b8a14efd3f8e1ff07a130008755fe4e61b902bc0ca3f5f39b97e51def90edba2e67d06cd127d4bb5bafb1f1fef410d9030fca1004d340770a8e4056e97c8e68bb334e2d8f02ca22689f468043f42fe933447046485a1fdd57711d37b568cdc752eded26eb9d857df69488498ac1f58c43831729e46a0f73119d179411e42ce034ded072a59d54baed6e24559257ced7de6fd3afad54a2fae9e9daebea40f70647f84b313b644735a408991b0d01ff350b735c7663e7d8e10067641cfc0fa92a1ccce7e8d6d4e1545b425b47dd1542ceea5937cc0bfdd74639d701857e5f1be55dc5dd37e9e4197e74cd14b4eb51f2b71618231c1a7227d0d666f569d54167099cdba58e7da562468766be9b31b57df180c4ae932b1f6ef89b3bfe61fb00a5a5f683e81e161fcc8df1a51694e8e0d60bbf27c9af54a50f0def239d84a92fb5d94033c9945cf072caa7f5e94dbceed3bffef5ae2bfdf7fd533ca76a43d81db3967faf8fb8e1e9333fcdc3dcf5d52ce5875bfbc4990b7b9563fb10c02e397e5e623ad8de9562d00a10bb6a87428ca0c4adb273f8013e89e1f2d9bf8ead75185bea9b708c79b18d0640596211b980f197aa865dce5b5a877ed4835cb408affe32e812140b14d43f677cc6a7b2b32efcde55007323d19faae36d7a3c9502affd2dd09c59f9c3bae3eb4260362278122f35e4528565a8e5fe7cbad0222948b8ae8a5993285c39287a8934a5d9ebbd27de69da0ef1c021288d2a64bb655ade67149b868f8b822e47c4e9d1b9e1b843d8c14ccb051ca06dd03766d7a2ad9613209c9ed50847031ff5cccf183d8951e15106a4d32f3977ecf6c3be2284079edb210343331740d2f0f3fe0bb874eed439662ec7f752aad0bdaf90d6855427059295fcf9343aed9c99e2e29cd41c8c346c9689e7149a879622d9be8e3ed872b495cd5d6a1f9d3415655ec16327433d7c991603b791f9cb7301ab64ce38a67d91b6b7ee6020626891f9c72e926a6b126546fb2e47e645557e5c9e65dfea75ff43155027ba31bbaa00ef122dddbb19f2780445db1c344c4d031a2fc232d9fe53e3c941f7f348da955229e3133e61b9d0169fcd58e4ebe3ff629096ebc4998273266e5db8a9fc77f39161dda17a0be6597aaabe6b459eb277860f94aa2663e29a03007449d9e79b9621d3a1ef359bacdb1ea9252f850b4dea0744de66ae7552683a7ec9146c8bb3919a41185883047e5b28986dbd62625b7803a38f444e8236cbe814d31b93e7239f04ea39bda69f73c9bca61c883a1defda53ba63902405eeeca065685e1da2d55a7d3ddad2566f02d4bb9c51feb239f0acba40321da700aa62c259ff71fd7e38f4e6e8b79a9c9525ac77530c2a8bf83804b84e920372189ed1b32a3153b9957dba01f9b9b07e10eddcdab07fbc679bf4dfb4c2fe7566e6fa8aa2fcaabea541c535e4c2a7cb887c02db47847601c1d109c844bbe12b826eb2770b8d502a19fe757c7395b8e1c22a9008f35b438ac10ac1931c481b89a015","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
