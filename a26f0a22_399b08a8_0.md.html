<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04417c53ad93121ef1cefe1c826055fba17480d4d76c48a40bef12ca1c96529b0e6610b7c341df7e58a661ecad22c5efd226cee78f09e5e83257876c19c99944f79ab1b6ce6ae1a4f0f404c6fa92d9b0d8e99c4432b21ce41a7f6c2efecf78857dd9d04af694d1bdeaff9fa233e63d1cfe0aad67f921848cf73147046b99a791acb8498c1b8702f07c0d8b4e2d6a7cd1482709e15fa53e37240186910b1a63beee6b50a6b33acec7284f9fa0631ca9c54889be8666a866231e162c6783f4550fe120359ec377078743554e37602db8eac3a583eb22fb74c04d4b303072975985439314a2f76e5366280f9e26eae5da0aa4c0f10f801f573c65ebee91c66de1c42e2b99482009baf998d73318ea3da9e33281e0395c357b8293d329018d98e919c0cc3a7bba583300b488b6bf003c39a253920c59cc66c6a4048bca543fa71a40f9c2d537b62f4738520c567c720a13ef532a5adec72f6e8c8994cf98e7f63f329ea5b038d67413bab1032d4819d34ab786d0df245b736da4699e537e31beb66e7ec2bb05de352f16e791be2bfaf24999e130374ea037293bd58e673619b4eb34702d346f4bcf61275780f57a6443c0215f18f695f1753a4c3a8f589038aaca77bae2d4ff1094e2546595adf8014b312cba9b421bf47810b8289680e89fe35f141e84f4d461a4356d777f1dfb9877f0a60a29f9a8d6f147a5b0023bc4defdc38bbd0960e2c2843e8dbe4762179583f417ceba4e5e0fe3f99a53c526dd97f9a74c34cf5fa1fad780762f4145f8d22d333884aa421847cdfacc9e881283e4b571424c79a5256529aef557a6416a8842142949055fb83c74411ab83d0c0bd3eb4a469ce24bdf9e3e5b34f614880da4659479deeec248fb06b1bf7872c501f756798d70d43e7223fe8b363c5169b7b2b79d6e78fc6cfdf83090d66281ad03993a57b9b4747e7f6a19239ac83cd32cb7407c482122290402c3833f3af673c8926bc84b9a65e55134e7f402eddc0f0c6b330bdec1d31a9e498ee12c88fe5b52aa8487bee7aa529ed10c53c938d7a14ce86431eb34c357f34446604e72be029f5265397b78c7437c4f8851e7edbbe4ad45cf300dd2e894eacd6a9eca5f4bd74b093d90d155c4cc80118043647b25bbaeb33fe32720cfb129f6c82daacd024f4894ffc3d818c91481052616d1c8a145cf9274be9722fdbbd702e0529f561b22bfa3ab00f4e94ba82ce1778a115b185b5ff4f12dda6fc27dcb03e360d65645d6cdfc73f862850bcec07ceac177e284e9130c86da9260ffff7c874247c53ca2737e5761371df2e50d62aa6f40fd9f543cff58705099df4247427124ddd65a90881295086aa8694ce1ead96705f23865f3cd717bbf63a7bab0009da09aaaf1d92b98e11d2665168dca63297e92b281bcb3bab3b2cda100ebcbf1d5cc4802c583cd6497739a4eec027946c62e2630e65220f08b40605410a3d65ec2ab795476873e43571e58c5b2b2e1a9eeaff538e3488036858b81503487d6426d353ea57954e6801a16e4bba340af6987d9131ee2caee771d242b35b848fb72706dbc692a160abf9ddccc0fe7cf8556c18f91d38660a2744d333cf8aa0a5b817e68e47498cda42a009441407ae7b65deea34e6bec8004356048446257df0d45beed90413f0dd3796ee95e34e055791058b9a454a747d75de441e82cf01b4146c63d9e1e7078ef398b44cb8b3caf60a05d68ed68088989dc322c2b4808bcd0b51e726ebed659dc3931d4db6ba2340cadeca4c4eaa7511a7cd1c6a596b7906f2e76d888f97e7ba6850b61c992c18adb0b758ab4e39f4d0e04cea2107a9e9882cac1a04d18a09606f8e683c71c84b6cbe10268648e10bc10078151c7852f4c8b42723d2fa5c8bece3a2881735923af1ab7e4d91ed5064543039e9ecbca2955422aab1196111128329fe606ca230f9eca7d1d6cbb04a42a54a831841e68903a7c8a9c54a728b9dae7b8e56772455c5f843abd49bc5d1b555d4ca771aabd08f231b352d23d9a0516c8a6429b7ff70b3ff5fe4682862bbdef1d652cea5242222659dd867904ded379c17df0842d8a846b66ac61f922f3e23732fbc3f3f488d6b96e6306cce0377448a74303dedb4ef026b5e94ac5346535181c16437f5b9ae8a72d934948f8c6ae3b8677e794896bc2d07d71def81d651a04480811525afd4eb6a15096c54a41bcd6c36c9c3ed6c93ab23bad18e956efb12340e178b0feb28ab15bd34a5877ce46631802b7f1f404c322eb3ac9788fb68017ddb4818322c0f938bb81deb4c08d21dbbb3410dd299e5378c6e1e9af69dce94e30bf03dd02741a46c11e4bd87a7e2fa7de7f6e048fe52476745fe21dffe3023311115d2e3634e49ecf10f43286c4cd05189dc787eefaa6173e44e97c4ba5b2a976f8a27219fff385bdf3e89347f3fc26cf789c902b1a536a885f603b42a39d14f257c9d17d9352858ccda675bab5654178c3bb91ff110521cf8bc7101b22cad038f85be33ece618a7b6a0f0045191e468cc0c57e016cc84a9ccf6003476e2630bb8f71026ccb229fe439c7a522a37920e32e3c57b958a447c049c084e0168b8e470ee8de8e6163625aa850e1e6be833fc0687dcb0555bda348e16bd53afef63c3e2b0c6f34999d3e2052c1c57b0b50a826112a538fe4463c9b178d871a95e74b8e5678dbea0dcbd32d79d3a83010bd970cf231361c19892d10ae1e75d081c7c333fd8a4968043310fc0683359049eab2a8460cbb60c57dc06aadd10ddca93b89eccf4767e9f534b908fcf9449c0cd09a80cd4ef27d1c509e0c85c00dfc30d3a056f04839c942d3e2cce71d9400076a54b5b4ed5c0dce61a855d89b02611d4f45f213966c656560d7c91b637e5cd78e939515282849c9fb651d3ad92e257aa2dc7c4802e1ca5bbbd1ef8a13c381629f1cbc6a11020b90def70ae65217ebd396253815ac7f52ab25dbf08c13485415a83142df68184d0564d9e3e8a9ce3219af247fc8edc0bb21f0ed0e57bbdf57ce803085986893fee721d0dca4a4d1790fe194ac2cad8f7d48f6930f8d873cc21ca4292fb5272c29fffbeab4d3bd0152a39813d7e93bd779df735d7bfaf08d33af76aeb079427f7a8023f1ec91f38eae9eb13bf4effa129761473d6abd657c1e7b7230898b29bf0f2f171c9d6e0cbd283de74268cbec83f81e7fe2ef011c3bcb5d36748f6cab8a37a7740f6f3f38791802e0989bfbd21dd59aaeaf4b2dc214e608f01615a9c9c21907fb93bacbbaaad480c8f8ac4f94c49514607e9c2b8d4652ac1f8e25b7c8784e8b3fdacef933461014c1bed6c2aee772b5828250fd35af43f706af3764516cad7a9b263a5484d2e98a020f80332a8e60956a22e38373bc02662c609b84d97b129271e0adf6756ade29600c9e0b8255d59581838b5663698c2070eb431abc0e98bda46e8aa525f0932b48ac7a9fc4591e25af77a98485039dda0ee1bf2d4577674c21633599a5d54aabab3e0ac9e2e2520429068c4c7c315273e47e5c7dd3fae06107cf230214e2b296ae3cb9098ede066da91f8a229b86d5b9c79cbbbbbc4ed1c48a3311970012d1be6c29def5b519e14fdc8305d97e9114e738355be90edf58e30c71f44440aedd04e14284350b6ea5a351fd9d1cc338713d6684173bf402f1f14656bf14f59c8d301a8db8a86fcb1a686d20ae3b05f8a414f8f5f315ef69e40d1d6edf3888ab6328d7fe737ac732e7832c49781a656d6aebc8f379f033595e8c8c5b1dffb775872b65fb91a2dd33bc1769b5429bc0cb5a95875e31f895512d6495982b4b5fdd0e8cecfe25d040c465ef42299fbe3b872fe92b4d8cf54bd5182fa5f305ed28e61185949215acdcc749e230162e8936e640ad44aaa84f46e03ed251ab64c199fc2b9c42e65dbe4bcdebd5f08d80b4d9d554ee3033c7f17649a6c30061cbab079341841e7471caadd4e7f11ddbf3d971150730b5763c26c90ff7a99b6356001bb51a0ec01e5c7f4142c4c56eacff9588e8b6bcdf6b09baed4ca803753f954a20f01c69d0a1f4b7bcd1d5d60e9539d5a5d85d5ece443cff84f14422f5fb3ab0d6e201083fd1f70eb38a89d54271458b93700639c58d90dd2ff6d6fe0bf0a3c743fdbf4afaa4f25df9ff6e46426daa5bb92300b62cf63e90080d8010732dbdecac1c0b2e4bcb7e5a40afb4811dd96d85bcecd62633aa00eed21918dfbe0953c5651fe29c74ac8575a149fd05b0e5201c75c2ba97ef5ad1d3d35bb1a0834c0bd7167919d409872720457e80bfdc94dac49fb874c248b14f5355d2907e41fc41562aef7788348f2ab782a21699c4a14e584bb1a515e0702e5d338fe3db13c458f3fd727a7d3452955d76d7a87349957a3b84ce97ee1ee2aa7a2e4aab03ce875899a03c9076969ae63d976b365b17f84665921528c528a5128405e2554ff1173026bb7a3a5732aa53286fde01985f37db6e373a6991899d2dbfb299a320d342f91ba80735b775bb1ce34f9cb667309d8a0384e8cedb61d052fd30cdafe09e7ed09f0819ebf542409e96ed5d3e8c2c22274e9dadc7a3942866d445df04f3e0eede85ab1e6c26a1150fa836b8b23143d8daef002e803f16e725c56fd71c6675cb9cda60b68f50f11c3d97074c7b69c84bf1599767e446bcbab1c7d8445d1966f6a3f721e9f820f414aae7541000df65336517e8aa380caab0b3d793fee07943e2f59346a0c836f0fc17ab3bfb593faae338605a9d048202ac7c991884c45712ce020b73b25d96f34bcf6d3716064a46888b31d2bd2f6643b28ca697d508e12ad594a4616f09b40cedb7064f4534fde1362bfb892b5b04da6b7dc6b67d75ab2927fe805c8418a64f14cec74a8ef48aef27d5c7c9580b37ea2fe6ded9d715b9daa685ad0e74038a9b4fe0e01bfd3dee1246346a0ce1bf388b53bc5c6a51bc495e60cbd9d5f2478f79e64fe8a53fb7b1f37eff83ab280067d8b1a834a1b94ed0581bc3c825cebd4ee455cd0e296f0eb0c486c26ddfac6bd66b625aadc317e9031df640876f75dbb61b729e17ec8a8debdf7fc79a12ed91239e50a02b3752842c16b5bc5416dbb66875dfbe3c4f35285836d690378205d2e94b276daa8e0e7fa4fa7f708d0a5a1f66baff877aa383c9b9192e88074ed5f5e63ebb6ee729964c9632b49dfc1b97d5e3c288de5eb75c61af343bc0997001bd948893a95512f54b4129e2abfd550e8cd6d65876d8a9862c3138e0b7b6847e52fcec29a9e09f775670cf67ee010ab81fab810c869ca742ccdbdd95a2d9cb97d799acb06ea4cbfcc524d1cc5671b6fed22a1d77c171f0e45fcea6ec88d45de90725c2533bfbd4da2d15063cabe495d63b5f0a3eb7bd8c606ab8f3257193ab60709c95ea1364144583d1e7d4dda32ac490a333785d4d19a1f273072b4fb3617fa41c96fa2ea8cdf95b31a40e0bdb7b8932f982c7f16a508edbcacd473807b1751fe50bd4cf851677aa185c54e2ab1c5a7b2da7587d9bcebc04b6c7085cd477eecae6f042e6877624d5a7826e2489c5309e0b361ae6f540e9b3cd43b54f6bbbd58fe81c4fdfa716025067a77a9ebff6c219cb4f3b7acf58c58ba65548d13c4b4abb9e1727f9399f50bb44a9891668899f58f8f26af4423434d2274c263e4941076e757594d3001782d75c65653c0af5e03115ff39d09540781df74f3a07341bd8c9b3ff57f073f5ae22d2bc326bb16e085b2fb88fad86a36c68bf5ad094afe1412f2f732e87c332a148ebd71503b8d995f9faa737e2c4aa2af362fe81d1f333079d90426cd2a76ca2fc29c5cb2b2eb73fbbfccfc6bffe158f763570f0146573699368e6a0dcda830807e1a4a6820ba0f3534447cd11ff645dc78d2c7e0c941507c7fa3aa1c9528570bae9a75e20f2b216d9c792bc8e514c5a670b92a1f99079e24c03919093dfdf18725e8683318218a26a79f8b03fd27c1742c2de8dbfa35b46df67be3cf29fd83021018e66da40a7bdf45b6e6b33237801efcb2e0361f848bbbeab8847a31101177bb140b55e09a80972175688d2bdae0ab27b2c84b9e89f4490acd914d0d39409b6431df731c38be5f785ee9491d493f258fc911e7a77e9629ba8aee0aa00e529df9712b027cedf102882fee447a5b4e99ef31058f7acb2c7296cbc02e8e7ab55fb491d83b2a1ca48dece3169c9e1ebfe33900b92f0a216598138322e8e78fe020b41487dc858741155c88b313b4cbd1bd29af173b6a17f6f1979bc8a1120811b460404306da237abc36d4e24b40806fcf4272f76e4c7fa40d7d8ef461499584c6ca6e64218ea7ef5b71f66d05f59355040cc8e29c1e838e028f97ec3c9f73692bc1c2c06436a23f0f2b9da27d2011e74c8f225777bf9266376f51a8cd6e6ec23294e00dd4af7fa96e022f7f58e4cdb71688e9878b380a0d5050cbacba1ce245fe6348856234d99a5730cca9d47d080dcd9f572791ea05e55f5ab72de76658518856eb2975f4ad11c4719c08297f1c596f2fcc90d5ea372d5d93b70adaecb60368ff49be67603b9365f1c4986493bd0f50560682a66b399f2d2c3aca4740bf1d13a6b9f19859038d79ba39fd406c9dbc357cfc5f6b547187e36ded42383911200ec4c9381e8c066d98593af526717a0d44835311425b351615fc85da46bc391a9d98534c7974d2057d6e8cfb766d1cd4dab1b1f60bfc6c26c6490cffd3158451aa2bbd20a6fe7beb50e585ee274be2a10a49c160cca937de255edaba591b6a2756a9723c9a0cd721a8c3bddfb9237c83c798afcdbc5bfc0bac73f12bd5a1d55d66021b1c459ed99cd62e3e79b4a6cabc9701a47144b4f7deab9d057a94cc459a180fdbe95f618a68b3a0fa8a6c63921cbad9f8d1ac85c3573895ea0cfc44baa2c1f1afcb2246899290ebee218f1e5c74208a89c5d33e65a932e8a57ee3ca43d4b95083955607e78761bf84b0c45136a3b6b0336dd531742f2dd4a74c2aacadaaf4fd538f41f6bf9b3531408441af11aa4552fdc732650e651bdd0d0ec023d5ec86101a5458b0268c440319d6b2fa0b259447058ee5cf5fe3e184db35e1810f1f397d92b75ead965b32a4b97d4d62ebd9fe6f6832e77bede83bf22844bd2c9b9f5b0e192f61a9c05cd605472d6a406c4ce80c12a2af510669658c103930857e2e41176844f83bed9ad70efdb9818c22ef4f09f01a4f0e430631c9aa426501c3ea74ba6bb4f45ea37e754088caea22e7935c5979802c555e3f2fb7b5fa81c80e02725d9c6db47202df9b2019177824b3f38bb24776a07f3c852db2f8e99095af94e6d6c5ac770af6c7f4960237232bbdb9f018b35a420d362719029d680e6dd08c97f1943a694e2ac6d599113454a0ae399ffbc7b9ab0e8a2bad754b2d7e64d3ba1b5e0b9c9086011caf72ae4fe557bc00f5bc304e9678490544b102ac80a13a816db7e399bbe2e2d0c9f2e4d66bbc3eeb6a10dea830ad90b507a7eb7eb50e2e7f947268dd7a1092bf73f728a50c06bc95dba450134da6605276c7ab4d92d1be3610d8126b5db84aaa18db429c362a2f68828fe1f8314d350a985f7f0b99af9aeee801b95e5956502714708834fc20774b0dd54b1d6c5edc280a0795e6cd2d29b521f0d45747e330e011f10d50fcfef271914e7630d9f90077d94b153fede1c2fb1598703e647cb89e31dfafa740f44b8d144ae5ee77a765f51d090f192c9b128413d63702ac294fc75ff55e51d8c34cb4c4ceaecefcd4ec28f8d0b46a959bdc7eb3a271e79c7d2e19d0961367b44fa72aec3f60ac004ebaf57a7027a8bbb0e13626cc4e73cf2244f17b128820f941387e2a3d717c068130e50c1e8fa17a9047923d13c9c36e1fa4f4f53487abdb1d74ed42e5d142d05c365abb3dcbad102d5285efe811c1f814f0c94c74cacf5ebaee8fdc71264bc0e8064c32a2e33a7b9a4ed5ff27c9bf4ec60715c30efe52a4b36a6d3a0e9b7b5cc479d4fca7bed2955383803fb5e338ca6e6089253012c65b9386921c035bb292004da31313f4e9cb0afda612bea7bc6d02f15489ee916cd3316af8ae243be0617e380ebff9b73560e40eec0d5a12f43b264d1de6eecc7f588b2c61c886f92daaa92770335646d76e9fd898a5d017a1a6736c364ab1ee81bfd1594abbcaddcebc56f0cd3f238625d9656b6ed3976467a54cfcf05ada41c48b39947d46b6a3fa868e87e4dce2e2e3192ec2f6fcca351ca22d40b4deea56d0d0399867999190e011025f314b694a2f29f365b9fcf65fd66b3f711b9a2d36f6a7dfa495503e8676706f332a384fd4a8328e60d88501cd3d7c2ab8e241449776fbffac7f2716a82199a971dd51aed631b4b8bbb9154c9fe5b9fa600d48c5300506ad29a390aac3c7bed480819515bdda94f52dfc1192fb316b7c24d5d2551834242490515666178e8a98f160df0f1b794112ce23cd15bfddb72a7b4451f4bc792a6de09e935fabaa6665bfd147d86531acc1c506eb10a021d21afab58641cad1c9e264b84cc03dead1f16f527df4d9498d3546c828f68df476e5004d6b317534648bedb08b32341a93ae52b6e649d0baf63c37c4cb378c5c388758bf2552b0d52fde27b98d22e6ba114c1655b7763cf664df8e28c0dd7a1a5a84dc497ac347045abe9723ce9ae81753367083b72a0cda6eba8ce5c812dbca7055ab9f66129b1b364522a2f439845eee40882959c1e4488492ca7c16cbe7963fbe8b30de227135f1cddd71f7bd4adc3c68b709e2accb5e89b9ac37f3bdd8f6e491a672a36a59b98cb863b27903915bef168972f60ffbea2bb5f385078f633b90174a0b4399e96cdb7d9fb2c46b5035c2d4cf99fed47e1588b24b5a99cca7358256ba4ab2e2607fdba0fc3f122120b5e524ef467309fe74cad02c4cf06e421b09109dd5c39c2c83544dad77df25bd88669f55340793edf5b4bf368ee7de1ff00182fd0a376cef71f2690356714a9e1f82589fb92e56ebda205f49f689940a0262cc72a654bba8080c3e839e9b7dfc0b45ba7fccc24987bcf6271f5f29c25eb540a227674e8cfc6b12f3637995ffecce3e48c2d9fc9fa968aada7b00e1b9c0f4f95dc5b8c0ed6b9e65c6eaa52a9d1400a9d64705ddd0f614d1fe2adb642f7b8541b2c5166f4f4315b53e37cd0a9323523d1801256067f8c01e46cef55d77e7c192026583149be69608e91f6e89b8d42fe0307a772b20ac06a092ea945061556f30e9b08743855c2af9f71517d796784cc4dca0fe9e704edd16628a7330a99d5f3e0d8822061341eed329af8cf8d01d34c1294b97c09759284910b955a4f9036ad2b8cbdeb8d9c44e479d73b76f96137a5fa5be9a4aedb1945158fd632856810e0585ed378fc526f8730abf9120287334dda25974413d08a8d509c743808db3158241841e03541c22b5bbcfb2d7a80741fafeb3690b6376533a1c7bd98a12a962c6ff90b850674cfb2af2a1ba6d61ba6f9d58968fd164108bef5db3682eeb71355e146ed16583908f626ff2f2687cf0188b95b312539f1427f3b75e93948985b21b4893dd59fb7065697aff8907512ab00435980762651415e935d4ee778e80c5f22d8566696a6e9c40afeda0716f1988e1f1ed2807dc504ecb35fc9d8586c876e32c48915088319977b76260fb764ae5539fd012b2c1e1e177c4208bea40b86b24bb4d6c2d83c43203b70b968756838ff1eda4f8502c28295756b6d02b342ecb3b0980ea26fddb0e64dec7bb1849186ead64d2397dc91883d43e8990276dc24756ba49ea83ce0a9b07ac97f3fecf04b2929e43ada737dc9e09871feb91303c76deac9c753ced249fa295224318c5a111155dc8bef2336f4cead11b2db530264db1afe049fa9ee8c80eee4f404ab6cb5720da365c65acb23fff3ba688a490de25d20325c6760e8aa37cd7f2a37ff59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
