<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dafae849f97c239e450fe2ce4c8215d1942ad7d7502cb88d4e077af80f46172a6af78ac5d613e6903690218664fc20d47ea6b8069200cdc9c54347bd336a8c58d3ffa3b61da1a87d97c399c65c132269247d5981025aece92c61a5cf5017876e9b6dc34ef09b449090d886d799ae7a137afba982660364e58e9d24604603087deaf7b286e0a4a33118cd8c7824c050e8eda19ab89d408928038c06fd86c77ec56d001472186513513d5b66ee67c4d8c05d622d93ca12d33376835fd23b504555e2273ab3826452839610744b05e13c16078b94d3d152637d29d646bd97c7cda3acb0bfe8be01003980e1e1614a4a078a7ab17b4be873dc78e355a91d4328f5818b4008276ddaf00d1e8715bc5c7851f01cc384a544bc575cd929eb2e01e2f9a5680050f2767ff5bf4107de8762059cfc9a41637bf32c134a89fdbe8121bb3f81260ef8617e1ed83da4dc90892e3fef55df0c51f0a80a9cbd6cdb4222e7fedb1dfebadf80a419eb79862b37a852e09c1ac02889dac0006b3294845f25dba4cbd4ff88546564b6f3cab0392f8d053d853db5e2504bdbcb2c1b01bfd9c1fb32aa4c1f6a2d2049c473d308aabd8025c7c9d5d45440f955b8a0b08ed2b4a047869d231993d9b27ff63aab8877f67e4aa26658f5645e8d9bb56a8138a368701a9b30f7d085c1bb25d1408c7f63212e0a0f7f79661ef5e1a24d5fe4b9ac7868a51b73dead8da4c3eade2aa8c17aee5c703ad30d7e4f1a9a854049e7a2cced2f03b90f5c342d533666c17d4685374dcf4495fd78afab9f0b3862c2ddcbbe27ffd942ee373ef93fe1c1890a61b589af96dd298e381dbec402893ce4f45eb45266d06030c1f93ca760a37b964e568005b45805d2ce20fc0bb3daa965c830f9da8a97c0eb9d7db52abbddc9710d34ed5bea253a207ece2d422cd984499d75a28a0efbc825dde9cafab4718dff7add332cf8ef03867acb16f9172a7bd524610917eb42e568daa832d7ae9adc28499eba9856a05db9a3c34363fc9157d734f8e50c048963ef55d7e4668954f0add3b18251a11e1c0d5b7b7e4b724c122493eb9c7893aee854fe6dce3d58abec80b269a9d322dcbd6384a65f585838ac6225d027e1f6e3a263ac5006e9a7462834980141a9dfdb0f8be7414fcf745961ca8211ce25171daaf6968271737ecbaf164c890b9cf359abbd5774c1a38495f1a85209bba36044695864260667d966672f028f26d6fbaeb34e375a6ca1b339ff9191238263c6459304d3f6061dc988bc93faa5d7958ad73bbde2dd6d95ed85b3abf6635c69b6c99d87750a6ca5447bb1d6639ffcad512e69fa82bca525bf7e0240e66b263594fe97b2188120b0a5a8248de002a6bc2fdadd1489785b1de68d247e9c1c5c6828919af935d966bc2fcb368e4e73822cd75fd4774319fe6a894ed583665564b3acda1f824d91904a9f308d95acc3105df2899b504d25f789d2de0464f1522ce08fb24473a48cb0005b4f196fe25e801bad2b402ce8ae5d53717f9f9293152059b479854e23a037955f8c40eea8ae192efe02d2ef0134aa0c2592f351c8300fce2ed175b15e16682cf32eaf35aa3836634a330c33eb89a288e3e69e95d47cb245eea2a6fb6cb4cfd61e7df2c31e78232b018359bd28e7db51d55dd8a3a32d47875c08b8a029292d1ee4119720b8cb848c9bf98b254177187fe17c3bb72c79c78bdcb6b9d097ff9441378b680389a7cc42fc4120942ed4f4a7cf6b575bd1f48b34781faf49026a9ca33937252e0cc8bf2020d5f8f18fbad2f046e828036aaac2d70b9632e289f6feaa78fca2686803aa8a2f6b786594b073a28d0e03a7d0bf1830a7d1b8dc224a1d615aa89f390054611dfaf212f58c46f6560974c0121ffd836ba3cd7b500747c7670df83a04c75bc1780b381694c003140bca8c1c37241a06d6f2cf740fd98b362acd8f42d992f13d51596ef00ca37563b48e3447f2a816a4f8f101cf94bffc8c92a934202996148bc2dd7074dc4a8d8062e673296bdbfab2da37dca05fa4027a0f19e2cfdd1f0c146dfdca38745d86a8481495de58bf2a9a8ea1c4ecfa6cc7e9a98d58894f3ed5f3e4343b6ac060b575c5a028f26635cfba3dac18d233014316d7679e9df4126af3a98e8c5e9ebac1e329a1406825eb6e5d36a9254bea1a9585f68b86224b9cefa081fc25ad0d53dcfdffac2b6cc4dc11fb8373a95d8dbb3e43f79bfce0ae393645dde9b43e9d2035fee5263e70cde0eb1ca5ea84e8f0cd1b79fdf99f1f25b55992a172552778adbaed4614c25324a4368367a9101258cba5da750d3e4b7d2363e0fdf3930250ed5278f36c75c95c6f43b3b7bbf9b1e8a190dce688ac153a96e85deb569461533ddeea187a6493bc74bff763742a59f0713bb1747d617e902e5c5d108399d4f04c5a769fbecb6572c22015cd0d3165ff3054a60f51d4939c9dee9dd5243be0a29f9f2ff19a3827dfedac96fd4a0c42caf3446cd8babbffb5a846ceece8696b6c7e170f1563c58a11d96a9fdc076aa3abbcd969df287f5e3e9c3ebeecd926589bd3a2930b1bd56273b26efcb889ba20f9f3a261e4aec94deea41167eb1133bca22b5b498bef3ee14d104d67ee6a210395b151805edc12d7bd902e07b6e36a08ad7e0192967543ce7a34145c8585229c200b86b88309a233e5d3b1e37e845521e313ee692339554897ebb89ba7a16297ea693c1b905dbe5eab78128f0eaeedf40d700ba0f6a501efced6f99ee7fa3e204969243778b96d6d25800565739b7b15b5dd68bdfa3a7a0b4ac594a7662a92feb34a2eb7ae8d7799777fd498660055a6557a2f2873ad52ade6562af4a83b04a688f7d50a6a042f7fe5a206343b2dd023cf828fda2e872684fb7bc8f4349baa9d8ac5315a9ab7b495368c22578788bb242b7998dcd6f03a8d974f8a203ab0b9e11adfaf484c1ad3d3ce38f3140a32d704a2e07d71ae381287aa6aa23f1f53d81f56a5c45adc62bc88f508e55f2be9658190cab1960d2b4cc84e1ce0519008d5cbcb814f07a10e49e99741f970cdffff087e02eac06f945e2c8b8a403f0b3c47cc36a56a3a881dc9f6a9f4fa22328183b336e6bc917387466d7db0f299fc76b7ad45ad7500a925e10e2059b75d74955f2e11b724b387c05f09d8caf894863092232d21c5b07c803696f88b0e07d4015585564fce87965abc2a0a75b5797bcf67eb7931c4669e15cf7375271190b7d408c558296e65868d0e22e3be3a63cbee98fbd4951742a1a1d1822aa7e7391fc57a95bd9774086b1af1be47a50667760d2bd4fbfd78df359a3c7256ab7159854cca1cf2d678e07c9473a531cb62039c071671f2ca0ec76a5cfa5bbce6d7a3623bc591809b2d72ea05d6ebdd920b7c700324bf07df7f69d1dd1b11a4cb1a4c3d772c4333f0b3cde4a8a85ed09c229d873d5c305a0c1b42871574c79c4b451b37d69685dbdc0949154547b3d3b4c421d4138162f7c77176aee4d11a7f149096b5252ba866e142262a82a18520ce118b298a465a2349e62c9e648399726d1c9e6508a55a61050bc43187d9d2c3fe150b521e08206a276db52935e40d6c56f92f10b7bd6d062cd4a3f405d9b09b30e6783a230b55842d19b07ac1baf0cb9289b65bf844f9e1439d9f82479dc45d3355dc10e122da4c219b0f9c4a402f51e5d6cad1f12bbbae87a0d1de9f774034f1ca26e9ca484217693f725fbeba27a30a3ea0e6f0e0cd0ce76a7ec6799182d4a8de841c8e76209ae856236b3d85370b0fb6940490bc54b30d07bc771ef9e2251f9e091e13739e1b4ceb7f33b5c9476d3fe8c7a44ae54f4f4e6a7252161dcad3e08323785aec910e3a29b833ce7c79b965f7dc21bf484a4e1e2fe33fb9558635f6271498405c735afb8b010e4f6e1b997ac407415f8d8e8af10e854836cb51d6ac140aa43ed8071f360999aa12b4ea0edba6ad0cbbf510820cd26185401935ebf5fb9cb425252837fe5d7c8183314e5cee6b74dfeeb74c9b09cb77f2616a78d1cbf32ed7e6c6fe2ca428778ee7c50ec60cbc44c3e977d0e75bdca729dfc4dd235b0c0588819883b1a485b8d891feed0d79eb507a33da6d959d362c956293eb0faa7a60653370afcdf28a624e3c4d9c27edf9056118d7211e9d275dd652bf3c4566bf319e1e4aa65be33e9712f9545b8fa03b66d3bce7877e290ed937ed00bf202193cd4f4df76585078b5b4acba09c52b63d22e36557d95fd75bce48fdda55747c63c224ec60a9f9674fb05a8d65bd7b34f2a0041593428b452f0c80a6728e9d178525fc9cc8ddbc5109cef882d87d990a54d881d414d5505d9c2a43410cb3087412f067e56a853e72ade856a1ec17cb223651d0e9dc4e3520d765521421e6cda80a89d51318fb1d22f0af660a6d587f0a9d8a70164bf833170301d7d29dfba2872527b7c1e39735d8dd6bbeab0f80deb509e99beb551e1b163afb151d44830daab3461de2334144df4c60c548adfddd01b924bfb5f29a6e14e6005fc05fa7f4f5d59f386aa8cc952deaded98e2c0cc6d85c3fe468703b948b394f1b527b43654f15461341a5b0d7008afd90485d8b985b98f599ac12e995f935788e662d2ef098bf04688053ad4a9a8bc53afa1a4a818894d6524243b91948bd8eead0c8a5378988839752eb1472c5020f935575a66dfa05ebc7272938bee1ba949ecab0d338e46d13c297541fc89d60324e46e546f2ce2979dbcd7e07f3b01716b5ed776b719acb22c2dba6ae420a8aa42ede87dd94e1d647d52478bdecb7971da34531b2f096588663f3cea8abef01c031bb44a402bb72e39ebf54b843c02391782960f12b7b2e179a4ac34885a2cb5aad926b9f30a17f1edfd7830dcce1518ffbac43a5b6347690abb56dc6c251f1dcc3d2315bd75ecb4a499c2860fadd37ad40bbfe2aa6c92df420b3f8440b024e887dd2a4f0b52ce7d9e11a20087951de3abffc0faa1d94820b32406497de56dbec04f6afe27204e13ecc21d5660d1f25696f1f710ada63d9d479ec0535f3afb9afdeea3c4f06ec75315346c3cb95d642fb20dd2e31741b3bc708285e0ddc6fe6f5f7664df93aab41ef585cbb9ad9e172b30253908a6c15733e343e339446dce26f7a968a84a02bb0b01f56d711ada2e1a1a424d02963debf70f5ceba0d9a1a28a4d64400150970815c836b7da2fc777053be0f5ad7711b77125bcf997a97b7197c0261bea3444d4247ffbe814627d4ee8f01f79d59101fb6db29c53d61eda3853bbac782ae32f16059426ca13d02a2aa17790f3afc2fcae536d1d0cfaddd6158433a7dd3efb2db6c3a10b5a6a8fea3f159ab0bd9c0d9ac23bda33b6e4f95b9dba4cb010054ccfe142da17b7ca43cc0d42aa8194bb32ee7a1781e310a9d4751ea015446fce80e7685db0e370e075a9842df9137df4b8789c3cf7d7f8e59aee535a45358b76b71080481b34c259bf5df4434df255a9e4f638e3f7203ce81a0919e025f01e2d80b2b3c87cf8e2bbd85daf6e370acf3eca68e105db61a54bcf54a24f84e07e4d453860398be3fb1a4b2c1ad5fd06cf34bb078dbfe6e37667ef9530ade83d7bb3f4a8cb9c2f2f5d42a7ffa27b68947ba2078771b2edf9d0ce2979d86c8928d80a3f673d12a9a222a92355a44f1bf87d09a07f904cfb4f448c76427b6d5bbcee99212c14e025f9e0ca029421abed1654f0f08bd58f130acd040e58d4e3290821ece1b8f0e5c99b003f5ea5b9d308c6e9f0350875707b354b7a732e710d23a9b63071c7a618d40134dff826405d800c228447c0d277ae6f88a784de116d71bb180d3149c223c7d24aae7bf76557f45a772f04d2f6988238ba7650854b3810eba5ab3e64667ad58b630b6e00538cbc3946184834360bed12007ba0a29b1c83cbd5cba96f3adbdea54fe67d579618578782aa255d213bb6862abb5a7a4fa6cae3ce11db6b964bb30c319362e85dbf0778edc3b09f218905e4a4675050fe121b07b9bec7edd4c249e8c34ca794a82dbd6d1e57b2573ecde858fe565e566b1bf7150c183c4397feacef29c527bdc91b6b68bb195026e0879e10b0184fbdc2057cc1f88c396fb0c0a73512c2d2cd055efae19e1d0a1e44f5cf9f35f6310995cb538c094744a083ffa86c42cc50b53f85b566430b275128f231f1d650d9b692418ae6287548278b03b5fcf0f522921d19b8ced82ab365a258f0cca2fde5a1b3a5bb5070b8b2fd3a07681926b9cf5c6e26feddd5b96e223dd66c2727cf9fb1e8f9013aefb386d26e9f846c06a272345158d00cf64bc96dc4466465f396e0d817a0d16839c5e1e7ddeba05dbc9e302b064ac3867b770100f0cb7eca90d15b5e82927684a6734126198e17b0682787f5faa1840f2da08f3c48da0421a5e91bfc83bca2bd371a19663aee9aa2f72563bab3c9df7f4a85eba8654a1b456aa091459359ab18183115e62fd83ddb7d46ba1a5d66d835d5b674ce79e8e2c80086547c9d74cbac8690362a62a33040750a915c7082384fe414c7641b86fc6f8ee42902fb24e85c9ddfdaf5582aa6ed244ebf318f4100dafb3b299a57288285fc7b958ec38fbcb2cbb0ee1314afc113d72c2c47aedf96e18da854f8ee1ae6bfd088867158f8979b95fc83f51d884b67a52e954f576bd452bd4468d2c2768e8309103e5a21c262beb1ee9fc698d95e0135b49ce9f8fbb738525a26971a47afd1bca9976f8aa1fd0e9397489f7b5c650db12600a1b054557dd37bfe4f4d163081cd0a7ed4760db39c62f968b0287510bf4103aeb80ef51e59992848784954059b621ee9f64dbfd1f253317bb91b72d136676fd452b60936280ac34493efd8d245939808453122506a4c86bfe9bea1db5c96a7710581a1aabfa553f2a9a64c1637c8997a5d9d2bd52c1ea2beda96d8214fef7c53c4ff79896bce878a8bce382a07f7a54bec14f2179d7e2e5898427b5eff7011505163663cd478cb313aab01fd613660e16e340da7b9680b69343187efd219c5edfdc3de5f1522d300703eb24d5c7d3fa47186c14bff2782949942db3ff75a5c666ba9db8fdb40fdbe8f6133a0cece4949f56082137836e6f286eb48d5a0405cc1cab54a09cac18161a67bdbdf294ef251c04cfb2e90e3e07498bc9ce5e3d46d564536a3f2fafbf397447895717eb28727849b681d58acbace84d0abe34e397b53c95f767c958a4c9aa23fb6010bf1c131dd31772f0fe55a8b94e77b3ac9f01eb7954706583f7a873607bdc02e4e93669f4eb1d7a84b23958a8f7fa018be17ddbf18bb8c1af50ae09a5a4cb88dd5f5be7acc538ffc6e02e4d0eb0048e155aa41cfaa15e304216c80af262edb56e524e137e404652b9d5b4fd2d3f301b3d190558fbc83f6570173690c6b9bb2788953653586e1d4d3b26907b3421b9c8c25ffe6abf6f93a687d6518f7dbcd80a80251e0ae6736e87959ce9ddc85483bafb63a3cb273519177dc56aceee897067e4975821e10346590f4ba44a26345e643b1f25a7a7075e7c7bd3bc44ab30fb4945961572320cff5e0f4b441a11ed6401ddb8c36947deae11f0c7b510e1dbfa2378ddfadadda2e46bba2c468a68ebafeb432e860e5c36c727cdc212ade9da1eb8e8e1966c1f996f2544f7aeb528042f728ebb3fa674569f43261c98e1fec53c4671e73d6eb0686122d9502f64ad9789d45ca636d04dd2f0193a63520d2bed2660d68db079958033ad7efe4c652ad379968d8d8a74c933821d88cfb6bc061e1831bea4cb8e3aaeec8700ff70776f6bebf4bc80d59bafc530d9aff27bbb026348d9e0de9d9575021f7587de188635dd35b5ad98d789fd1ea7fc21a68ba1094f93ff877fd8f35d3eb82bcbf9a15f05e50cfc2cb7631ffbf40ccc88fd46c06fb1ef26b30917860511b5cc7dacb2c1233fcba2745aeceb1f6fea2784ecce4dd418737141bd2cb8bc872f9d9bcd58e0c3090f88a6c8bd6908cda3b4e46b106174003cf031f5d97e9dcf396c690858a0f379f5de62bdeedaae8ff7e991fc7be63a1cc09eac676c17f979bb112359e0af58020a9881cefc2afbd96484a332ce6794cb588bfd790f8fe1739db88464c1d8bda51197b1d97c1831aef67b399e5dda770e993219c4e1bb9f7745fec38a599e613f7ba5ccf34cbda628675d239a7aea0700b5da7b1952ff022f0ca37b495f7d6f3c292642e9509720f37f512f0e1dba983d20f10072b3855306c91fc2401ab2130321b609be84cf0a3875e213fc9864ee4c86214619439af054940e3c5562db6776415c30d69dadf8a7224fe5037724009ed86d83b82fa16625d122a2883efe08c1364e3ad0f10fde66f20e63d92293447caa3d5133caad7cb65c32b2034230490c39de5f647ddd771ea08ac4e2c81f710499098a54fb077f8a8be0c2901dc6e45842303df183e6b5cff5887686732d164fd2348d47caf37f79cd991de4c3bf8e9a51f7b6f51cd85cf9cfc83a401198ccb026227f733d0e87ef4e62860422cabe668cd8b1b53dd70da1035c6ec55aff7f25415ed51e1a4a9b2140422e3d1b7c4aa9172cd991bb2aea72fecf458adb5c649533976c708f38ab07dd8a9d770f5ebd26566fd2332d23a2e16961944b60c2bd4015688c59cf24117a6177ea550a83ebe61af3efa6156685b4d1f00b3d2eaf7ab9d8e0fead72a3984dad8d994b42ff8de32efbc0e7a02fa368da6bcfd0dd2d4d76aa330bd81c382f9560c5c7510120462d1cbfedc2c923644d4174cf5107ee6c04c4d31469da7c3b569ac86521816623bc690d8e3f872c7703b3438bb51be8dc3cb852f514a1f001c95de9fa1915932aa97869923018d61f03dba65258c195dca70089cb6e584f81ae12327200a6540329d42d11d6d4f930b83ee0530bec0f267148c698d5cae900ec301b7245d338e2b7a9f2ec5bcb68910afcc219534ef7db8fbf7e515e03e708dbd11bd7ce6a761d9a499af0abc169f4ea55285d3f61d2febf421c8874b45616a9c5c2b4f069eccadeb3ad24f342fcf8b598fcfea02d8ceb2ac8fbc08d4727f64b94201300c0f74a8428ad43aeb6e55b7f2500390b7dcb721eee13a4cf97a8cb877c6527728bd5ed6ae3db97f7228cfe661798b575750370465f4efb351c384e1d5b8464e3163d3c0316710c19dc70a7a360667455f4aeb02b16c6981eb9de06e20524c0daa20da8d9cfef89dba87cc58220834adcf4ee96cbd0c62063755d0324726d7fea88a2bde6d1a228cdd3c6049ded6370220466149aee1706eeae16f9ac9f5d23111e0904310fc26b40dba5bd7ad6f1fe3c1624fc21fe47205534d308ec147c37fa56b3a3adf4f2ed34973c444c94736a7a2e363fda29e919396b8206cc985469460ae74a72509037dee7666c0a83465e3c5558d8f344dc551c42853ff34baf39928078fe4972c74b6e25369ba549b2cbdebbd628f4b9060dc9920808e8e5684a26532999b5e6b77d358628920d5d30ae98cbb83ed2eb1355b16bb9e1d75301201d8667271d04fbc6337c0828eb79459b42ddec5774bcdc4838e3f2f7f8d2de537ab2c9b902cf18ecff3b1dd99d0e7257552e9f8a3ee64e8068bdc928cc0023e7111c11d51176f17750609697ae5aff135b27f3cc5c98cb8f6e9cd814fb3d8de2c8f04913ee31da75eaa25c2f57483439dc2fd1d5d92f101dd1ac71c9d35713d6112dd42e673a556e827fe540e98f1f68b9fd1faa4d7cad61d9c79bcab5a1b1014fda79ea7155c0f24e51d8b154394c01c4914eeda074fe5e69c52b87d946c587b65915d5c72b8c3332b41fe33d64f4a1d9c1fb6addd04d13430e52b2bae28f394d3d73f7f8e5fff585bdc9ba86b19664f3c9ec916826c107b0b43da215be69bbc12b00f1938f108313b1ac71bf22c2f1461a1d0076554523e43341c209657d37b77014915171c6cc73a514edb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
