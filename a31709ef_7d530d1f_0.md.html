<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f004b02e20e03730eff4c617ec2811dd3d5cda7b56d699038af2633f212dfb92b39a5f4d64f2c0fbb7c133f400f8642785864cb76398fed53f13d51c36e1613333123e10e93b1800964eaf9848e87b3e13bb62243b96103ae5902bdb425d6cc0add44c1e3dfc418cfa5b0b5e539db521f0caac74af42c07bf6760117ddd16d7a799906bf13aaee5b69db4932d47cb2f9cd664cee0a64148c0f6c420aaef71f15a72967232d0bf00bd27c99fb2297121a2e4f5b3e28352647ab4f08a7b8685b8f10dc1e303273da5ea1c937cb1a4f380f800c6c87700dac670da579a4c85b32a074c0af0f085bcda652db44125a8e3a650459bd2453c001baea7d6b175169a6f54346e613d1ee0ae34dd562764fc393b6ae35c7cdcc6ad621fb446f1165bbc0fcd17750072f8e9d192cc60688eeba1d88082c5ed614c6e53e8764ac1525346febcdc74842b8aea324059504f87633d0dcbe10917f457b1f9072355ab57dc137bac8f8131f99cb385731cdf525ed6009e72c3c8d8f613f93792bc90847662f447c5a69adfe9e2fb26fec9e78abd97476e27f92da8ddf417dd2e65d7e4fe4f219cbe2d83cb3b03dbd64369ba1b4678334260eab9a184626a043b3d382f19af0934156b1ca08a3f45338dc22f793e5c8425575861da9ae722351a4c0c32f15cb1edb64bcd73570fdafab1ac72ee5f2170de5504aa0aeaf134396931bd311f172acfa3ecbe7e7171cc6fc4e8f994e8a80e4b03107f0f75de6a1cac647d4ede0d5180130510320e5f0849fec5ea215e0e364bc198ab3c13f186b94b3cd4fe91a336985efe8ec5c069aa9e8bbbe09227bc77678b814720f181ad5d27a9554259180d3d9811662a9d478736cfbe2f233bb7b2d573e2f84f7553421357e59a84804f203443bdde949a470dfec487ab81c5b4edb675e12df503fa3680cd36f887963f761fbe4868f1adbc8ac82e6da56f5f4e32e0cca7b0d475fefa200cf570413f44b5664bc68050d935ef550c13b8b99129c15f92a9a0d8b50d2b61faf48c099994ae49cc1d39098d2e62044a83b7c360d6c56c750b334909c1339e98c562209c302c14fbd87c75d9c45f1769acced1e62db77f4d6a4dcb8c892a5e08640d2af21caa082b3ed67629196f71d236b3ffcf8df25df1029336411d31f10fab6f1357f3dcf91253e533d1fd549e8078109ef761be7c14511d6d91e64ae59a2a68007f7ce0e90e69dde80b3dffc3e546327ac5a1217207ef82108d813ea14cb160d7a02f546b28ea7d493542eb38b3dac84f13756f2c6b1b61d252cd526fd2a55e3d3f321ebb87420cd3dd0a1ed47c4f6b4af398b7c3b4fdc0ec397adf22a87b79345255baed8e5cc476ee2ea5f7b903adaf78d6547874e50da8318c3aea68240827a61e865243d3a7c152857cc0e87c3e6b56f4a66719c3df80631bd9e6bb3ffe7d7899d3241996c1d22ca1a665ed81fbbd23101a215cf5a4e83caaada442d5d412fd861791a40a0ab24d9204a6285ca92e52a4384c6ddbbc8d83be004109a515904bad29f33a3e5322bcfbf7c30a0bbec1569332ba51ffb5fb84297ce173dc662beee08e68c0cff57ce42691e88022151cb6128b317453379d7afb4556635495bb87f794bd0cb9bbf00c4772f3db96bbe0ff6e2d278e7eb54995e1a5b4446c05ef01e498e9e67f9f386a73748c3c6be03fa351fe0c01245ac9c5a2bb53f770a4e0f76bfed1bb94771f62fb1e210892000bbad5893341b57b79b690f15320f64114655ad26cb72c35786e0721943ec944f264feb982e27b9edf7a15dde93a55523c56d7b8c6627adbb1bbb50824de81587f204619aecc7b101b53609f0c12cd5eada6c94d04fa4b0571afb5200d53358b8db4d1add840348acbb77411e034c6872f33222425812aaf2c0188441a9a02ea042c4c56402c3859a048299dea340be5e3ee63fd23d6ba36df4c78eb7b93c155ce4786c6fc7b93f7a0999d8f519d03a0a41c6c91edcf418181e4d149619cd9475388276373a2c9d61a1d132b5ebf25c2502fd3934f251b66e5d86a4773714c963de5af53a7590f2c98df0aaaa62e71a754c3e71e3ae7bae4f08b0b8626f13c3162fb9318bac8bb0a70aac7b9b541e465d9450491ada4be6a6c6a7151f9e968303e37ec3404186012a2dfe370a4c637969d9e70087bc0fd2951fd8177744b1d2a7be70731b4b1c0a44f96ed1c60564173d503db282f01d26b46f0db5677f4ff1d7c0301ae91b9f34e7cb8133fc4786df8f07934a53813cccd5ceae86fd52ee9ce6fee0b80fd2f480c06667c13bad03d473d161e3fbca39c2347feb4bbb3a3cee642b4d12d5973d5a8d866222b2347c761bd98b87016f1dfb5049f4a6a4b551b8e450558f86908ccf38e00cbd07a064bd09d069643edf21005e3f6c1f245c9acea6e4a5c9342d43698264ccc448e4aa81f4e32cd3ebba5a21183e30abf79eecd6c6f7d5616743c1de808e2c877e5852b68b331165b0bd04523511d651e1cfe31fd14ab41c71aa24383714687df43e6fa10a8ea72564e6368f9137ba049746828640ea667adb6b6c061a165d248e00c1a9a852b9cf9a98ef886b56d9cafb734180b1cac28affc0b062238c14314aafecb1b4acc5cd8fcf09e60d38496efc4fc1b34c5c9512f882e6c05ffce7f90820278d71b2a96e7c1351fe24f205a4f09d259b0bba03b1c38939b07e913c6b722dd72db9cf0a56da4d4cce16732dc531d84fb91a732797204b35488ecad38267fcf8f479f7b7f6fefbd4943f83127bb506743196797e7572d05f876cc986fb5b43b753afcf0a1ab00fba949f44bd92500ac06edb9c9254861db8289dbccf56a4f8425c814478ccf82c31675771120a11da23661d3ee3fbcabfaf9a76c490a0ba0f5dcdc94f4ecd4ea48035e380e9204edb19291a6eab70d533a299539765a09472dcced297ee479b81ac247c8c6825bdc9f316b883f2cfc5f190bb8d24b7f7288e62c0fa9b5a1038c88415a53c46a569a0e44e9365b24617529dcd4e053899da2c9e07cb2149beed0557b2019f42d758b94778342b661c45b6a66693ed16e625392f579d689e6a3a35cccf99e78d0127b4179933260b03d80c6413a32130280b12fff09d5cdea68072cb420e3d680ec8244e9507858a29fe89ff3fc534b381a208b76ee4aba939f6b2cc808aad7c07396807b847867ed8c33090720fd133649e40886ed2939f92240feca7bfcfcfd992f8ab2f7fcb13651f498ca7821dec36834d8d5206c78b2bbe45276626f49a927bf973ff780632999bcad7ca898b985f4c731489e01d96a465c76b62452b088018adda926cbb862703cc73b43896aee55b36805ba2ddd90b03eddfe6fffb9fa171922754123d423f0ce1155a424a512a0a9540232fd337268b4001e75f761c496a06ee454da825af160cdeddbe6d4e391a6b13cda97a671a0d54296ed4fe6d8a629486eea58eefb02da7d21998da846cecb00cd9bbaabcca835a24cf8ae714e8f04b3d30088f5679f42d227eb4610949f21f9dd053ffdcaaa985a651138cc786dcc351ce006a7c1d9cd64ace3d6fd7740ab267a355a97f770d3b3983f96afdc9fab8775530efa998d67a22a10ab104e19708183e6599f3ff7d34e217fa3824067ceeb67d659961bbc8e12ebc59d525263dda76dd64fa7824c62e2aef5a985819c45648826ca2d8bbf68dd3b3fbd5aa5506be7786becdfa4ff81cf8c858bc3635e1fe673426314190c3442cc0b0663e3a627a5a4d0253eb44525d5d3ad9fdebf4aa873f7dce1b5933b36d981a55745556a599e2c90cad88cfd7e5eb767d520dad3dc3aa7d01ad76e9d765ada3c57444cc64a60fca82d6dd5ef7691f62ba9dfee866b3f16d78aa70ff3c3d49a78630814ee10bd86e1d1f49a8b5913320b8c2781a70ce4ceb51c8d654a4a2f9f5f37ce70e1b680ddb1f9c47da8248487a6fd6825f6c12d3342dc3b28b82eeb2f33f943c90ab97212fc4807ae1055432968cbf1057781b9c8cf61a7ddfd41811af600311448f1bb2c9ae5ff6d6ceebfe81ee0fb54448339e88ba57d047a3806d72e5b2c1c7cf0e3ec2e7c667044a1bbbab41fc3fb2d68b29ec8a2fc1dbfd5ff4100171ac32b544be4e8bd0c0a2e65cd554a701bde9e00371b201a530cc2e5c20634fd2ab45f140d0fdc43994b6ae944dbae58861f578da10c7232fda8d729053688021d90e539766e9006aff334f3b2cbbf609ba84e66b72ff201ae0d8d72eaddbcda8838cd99265cb27a145ff4506a4379d33f92bb90474796945799f5c77f3b782e2d9cf4317db25718b330ea7097b221892e1241afec0db3e8e60b9e6140a186d0c13f2bdb688de8b01010484c42c4ec6ec4720b50b6ce13b03f294a308a81ff3fae39eff312a325e9d8e33c5a4b11bb303f192ed81431d05006e050fb210dbe406eaf65b86904dc2a54d3717e95556b546bc94563961e4039241590eac6f50840510adf30bc3c5a02e94c2b07826ca35de15a4c3fe135def0cf6407aa86f1994e7e7e76d808582ecae338dc779783256a75988f10d424ddb2f9448212764fa29b57e5e0c02cbeef4830ed4596ff11863b9fe8f82f89523c9da0cbed5a284ba93969d240341d19c341e26f473c6e65d09ffabf6fc024e876fbd3d8bcc79c3d94f44c1eab0e4c9a3faa1cde76db92cc748e1db6db3de531bb22142816deff1eacbbe945a6e79ae8eafb0c311c1f04c7c461790b52df02cbcc2cc6a6f3902ebdb38bc3d6efb82e0691fa39d6d8a7cffaa3a91287c0fa21c02c717c99f22ea560916fecfac394fdcf124333ce2b6aaa9c244d76e26617775d32a8a1f48d352b48adb4d1222297c6d6282b1cfbb81dba999469893e69eb2016f93407fe354d4f623533ff080de88e32d27c4e7d8ae7b30303ce72cede6b5871afdcf2f468e0fb07e78b905d57ed69b3aa7c2d0b110197c107b7944c27e7a8c4e067612b01aa44599e8bc85daa3ed2e4cfa22a1c8ebbe3adbcaa976a71875f2f11b130d2426a79dc35815eb885956e1d2f50308efc521fe24fa7e9e39a4f1e20eb19110183cf992bfeb99e01cf9e63054ec91781032c4c6ea9b9cc30b7e30b151a5dc752ed3a850f1a1c41f972877099a4dcd7dcf23e406c36c06e0c6e6b550b43b67c2a49c749e3b672dc1783529f0437808dfc9990d1b5a5f7b16aa2ef41bfa273cf91586041446df4c614d4050be6f4dff92a9770e8f45a18d37b483ff452840db74ee89fc9837c7262bbdc840a31b771e33d80de9ad3604a73812d323870428cb55de58655d7d7ef52757566da1b5e96ab407b467a0e14cfd9e143f16188a68ec64b05151962d43af1862d13035772c849046b34b94e3cc42079ccda211bbd322185c99bd94316e4f71e743392aac987cda1a442a15824976031cd56dedb66d45eb80c0523fc187cc8657b8b963c54bd29b5612a6312e5988d7df2c4869717e2d0e00e4e60d525aac2365c39b860fe801d2488783ba9412fb4bab87550f7385ceba3af4c669d7b22f5dc37141923e34e7f56ef7a8ecc774d53a43964739d7a51a244d8452d98d36a670e4bd70879a1284781f05a85ac64451b72be4c331c067b4a4bc70b14f55083ce5d069a0a3dd653690da5ceb39519524a18451c52c3fa1576e0797be6dddd26e78a0015cb6906938a87067a65359aea3b8bb6ad986023455af328e24941434fddc9d346b62093d0de6ddcd4ebbef5a26cb93b9a641f77439cab0af8bf17b68224620eb11f2fdff9bceaac9fd12892f356211b4b7ad9e7ac808453a25f4f6d758a52c8623064753bc73bd0dfa357316b94b7874fcf0105b0e4aaca5f7d1a1a86bc97630c31ccc5d657be52cd9655d8022e4784fd54a890e611bd8dc433971743ae1b9f5244666c1483b982e36d0e22ee0b5397839c282a3a34fc3c3eeae29ad5110d843121d4ac805041c2db7f5cbbd22ab6f70fe0ee07ad963920bab241f7304bd372bd77892fcc370a08c2b662c41bd017324aed815a122fd7d3b59969e68f32506017de7d3b93deebfa32444be1ac9f10abd824c826fb1f20fc33ae96a9312f23c0e2756d5e7071c7e567626b8231be72ffc3cb5dce05944c996c19b19aa1808e7f6bf2863e5722821a0a3b3599e78a208aa8eb382d42c52f4cbd2384d49523e0e904b97c169c953554fbaa4d373d36364b4ecfa440e6757bd256e1dbef748a89251ad510976743558acc3a5bf8d7f94b1b4771105590a2574e39a0fad0cc8cefd314c4caecf95069f4d0cda18c0f3f20c5766a4015be8ab8814d412c47743a87696f3d1be52c206ab8c3faba375d669c8f9e29df767928fc2ee52de849d4fe4a66feb41d6f86d5d0135f1fa23f884c551165c7f8ea450e89dc1076650a427958b505cdd66fec75fbe53382adf4b03d9c50d542017bac5c04b962b4f501f7442d13c96195138a5693af9b68747a26bd57669cf2b934b0b25e992823c2a5e5003c9060ce86d0c63aa96d4616143fd786ba3269bb585fa2471d1417ff9b3fc83ad26bfd7295ba380dd47719ad51949a20705ac5926c8e6fa18b990813add5d06edd0042da4316ca32fca908bfc6fc546ff0e9f1f0025a3de9a5220b8f08de3dce2b78cd499b108d5d2f45c5b397ee7bf23a18f7dda43059a60fee492c1ff2508aa2d71b2518e1ae51a49442e5b0d21722b59c3c5cae2f79ce34ec3da5d1aeefec98911e45e62353e05b8b85606c19d8a7c9c3536e3b9fc1b69ee87db6c6a13ec4689c95d42d07905927bcdc4b0abd56aee5fca5231ab470af2af25df893f4fa000935755a596d2aeffbadd417c28d42fd657702e1c2bbb3f861004cf437329e157acffd42f91eae486b0cd809d6f06f193f4fa6c6ac738bd4febcfeafc03b47292237b9d87713c0f6518484694db0f7f902eddb0f0b901c756487098eb4f90fca38e5488c7a3da2c746920039d64efd1e66e9a9e05d7b586552de51e877f6e1f6d5a51357936c5d5fe3ce9a8ec7614cde2a3c5d3b35a6e3ca3363752720b8dd5fabb831e02907e80118f5985bfa115d59fe3e2502f0e1958f9db26dea9d11e1cc03206937f69e535e82429efccfdc3bc0c20cc57990c6311cc9acfc7069939a9b60664c47c5027cf8492a01941daa17f85db80a3c0016a91069d9bcadb978c3b64435f54adfa28a125ed50303b0e65140c702d70a59270deab5542e502b873a8dceae20326cd8ac6b044792f110cbce7a370cd2535b7ccf1c81f37925686a2364d51f9fe59f9963c8d1c39d00ed524f1ac9f15ca529508ab9c3574e175598e6d17466dbdb7039abe37f9a78bdff839befcd0ec07cce4ca960ad4fe3bf624f87bc70a6703cccd9ea4fb0fa78858d981aaa5dbddaadf29cfeb282cd9181ca8ace2c1f92486127f82d4c1a3bdbbe07f12180e01a8893370bbae6b9c7716fb59d12ef86d4a2d57ea5ea9863e2acc20db14b6797678f4a50b105854dd5120141841fee7499d138be4d367afeb2be53114abdb6612786166c0bf582c7807fb91cf2d7a79f5ccbf37715963299ef9c313871b8dc79e983db304f060806fc1c260d1c7c4f163436f0a5c7f50d16800be9249e1fccb15e2cdaad4c7d726d84dbdcd3c6c36225153f346a9dda2d5e2a887e95e664b19f96b17b4e435173286e830c74d9e70a2c56c5c95d14be21b1f0ebb64ddaf7d10682ad6d4c03fa68c5b799c5b99f9ab6cc70a5a873125903adedacf0c83200f298ad50a1e6f086e53621f9fa098a246eb75478dc5a1929449d8a705ffd04b2d0dc9ee8adf28d45a55d5297624808c301cdb897ee3c8cd794d44b50b64e1d7fe3438eb1b44498d8a97883d2ddf7447eba454019e0dffc1f4c76ff6d6730ae4d3586b6dd8456c5d70bb0d0acbab0c83f5a048ce9a8e28d7d23c05535c82f1b8b0e3021c8b85ce779f90b98008767e1bea3abf175cadc91fdb03c61bc3ca145f6cfbf0ebc9c20d4a5b7e5a2b89cdce930ffad4c8db60138de0f6636ea33118e20fd14ecaaae6ab2eaf5e8226c6811d67368b983d3895e6f6bbffca09c0b4ca397523a2d4cc4c3d4b750dec3b08629d413b33280e10e18175eee4aa9d1e0791d962c0af64a45e58b752a9f90cfec1dc60ab0c181ea4d4cfe01366b5ec2cab6499e97148aeada25df9bd031a3b2dc56d3cdef755cb6c88a853099cbe7552b947cef9addb7cd9c57bd956391e7e83f35f031cbaff8c0e74da09378d11fa20fff37e110447a6878096893c6bf1f7c2e70db073393eaffdd7d15bc9417e2a04ac6e56b8cbf0a2d19585b6893b59b681be600d1fb9d1e40eaa5e34f9922dd06ac39e374689f48031df5bfc086cd41553c5b4b8267ba3c80d7ce17abcee9314b7529ac9a4c66211b17a815637d261cca4825b61666e33f8ff58c34d08f2158996f8e4835bdf5353ec62d3233b3d86433fd56a490646010c0eb7c6ebe997e74b904f628db1abb3265b193d84ad4a82e508c7242a8bf3800fa524bf6df75a48b6bc440fa6ad8c94a393a29c197e8a54dcba6a68c5ccf56b30c7b311e522454742fcfcf095d134bdbbe8130832c1467b13278541cd83dcfc39ffb5adab622cbeadde75fa00f1bed81de60e09ddf24f9485781ce2a49da55362c2f9cd8c80daf14a40f61d6ce734c82014b4bd39751f3f1f334644c7e81d4ab6df05379d42a8676b7d318073d7d6667b1713745c4983cf42a6771610d7877a65ab10ecc902a7cb0a6639115e477ae5e4c0e273e45343ba3925957d4e0102ece03d282412f649c9c53273b327e3218629361b5509e0f1a65267bd568e07862460c23a5085093a7dbdcc86a27b76285da138ebbef7a9ebb72ef20ff2765e911ae6737d082d1ff43c6cfcfec320a34f7e6b13be213f4b465c05dd936b773f7a8a20301ff005a5cf67f0e4ea0e9aa4f6382471c2f30d0d220ad61b8ef1fefcdf047ba69070c7bb6e29baabd71e273de96a3ba0403c2dfcaac8adb87ae5375c49b53190b2d42e278f4d643f7708fb89e7c972df5e6b709c966c37cca47fcda0027620886ad8a004073e4c9bc6ef7b0c059bf4a76366ef5fa787bf3e5c42095dc28ac5dc2d775c18bc5ef8aee15047d4ec9c69c341e7253cd83defe11fd81a923a36664357318bc1f7e7efb6d731ac1e836d65f177717841a1679695cf2b3fcd0c572293632558d578a6345013ee5d36b08a1f24a24d607fbb36bbf9a358eb963fcb6f9306b960972b577927a4d4f6e83b4e2f275e6788cd704d5f6b1fbc2b5642f6c7493704f9908de3fc0e1156f0c82af1e1690dcb57c00f29c236fc1f3c44248890cecf2424ebe742d4e66c5322a7e451a442f9a149e26e5699c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
