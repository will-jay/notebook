<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4ed07dd16d59a6d83e68b9e139a372d42ad665bc3e290a260050de1ef1aea085e93f9c0d1ff6c0c21b65b72ae565123562fd6e328219935ae95e2e95fc2abb75978580ba2047a8b0f5fcbeaf4f0824b7f6db7f2201b2487f53f4c8dd43ef897db8bbe4dbcb6c30119b184e0666804e4549b75b1f7e582048d377ed1fa4522ff30483f79a44b288d0d505bc679d06b761db24b2721afe79fb633734fb37d004bcc988b7dc4e8409016d3bc495ee159fcf0839287d81c92b70be37a9dbb8ace6a4d6c67ebcb3a26a7b8c2f65b6aea5c5b7eae13712c7ac73d664a1dc2ddbfecdf5684ec52472f9a5ab858b08180e7a80e6293ce2fe2103f18ab85fea4a68635020abf318e61a29fdc2f1b82e3831c7fe85776830e7841e01e2cb1489780fcc57d2271b483aaceccf2636442703115b063e63afda1903e6934603d75302771675e659ee35825a84773535eb16c69fd791aab85e16c30313ad68b6c792e98f6ac793e4e871ba3c373520bb85812bc6eadf0bc72ba8ffd24ba88136bd2fe9eeb4a2e366359eaf6aa9d78afed7654a324345eaed01f6676daf9601a75f829b03ff0719ec12f72e7541e448548e539c1cda639834bf24c34b61a8bc39e1776e000e6c633748e138c0f98a85ea3f2b7767b80b52554c26c6be404128b9e6046531ee9578681b50fec486f39c01fe74109e707cdcc298402605f3b36d955c2cfc50f57dcd92ca4b562445856d1ea636bda90334cd17a420df16277e949ff9d845e75123c66cdcc6c7b190153e37c812e6d236b44e2871ba6948558d35a86e286f746708289dc3fffcf856234dea1d5c5d114f6de385e04089b1737ef820743e701dc42706fbd5f7220ec9c4f27e128bed180454443d1b00cec3eda349c66c4ae5d2c920254ee9d2b4d8ba4ceac2bf38df32030d9afe57a863cbeb855c5cae26e960a86d925872c3f2e2628049ef97d87dac42f8f234150ca4b0fa4038d56834637db0eac8849e3a4ed69a807571d5ab75d62396c628e1a845099bd830f80f4c233927fa8aac1f259e1e2da3c7c65afc52d1975d3d6abac328e7cf0f090943dbab6e8472470e162934e228cb7dc6690ff038b10d177028166218b9f6bf86c565266149a0aa389989c3d93a6f8fd01819ea056c5878e63bdbedd784dcd01db9766205cdc85c3788d71e24f37679d5f38a564ae97c28147be8a712d3753f82082195fb1f05da471244478b58861a76f9756ba67bf175d6e624d021af7c72db04ac739696521df053b0ac6c532af2a71849c727d7a4fd9b479815366345fad9d0a7720618cd3064173e4c235b0c06cd4ffa52a18aecb9bc3782bc53cfc2c10303c4435200b0743d10e89e04658fee1bc0c96296013e8e0abbf10f018b5bdb519cb19f871206722ca01d341e606260ff3f3a7c4b65292596b501d6731a670115069b9799ce74995b4b1be22b9ae4d0e53913f198c90325fcb0a43d065087ea1b39662e54a2d8f7c074d6cbdd3041ac61b3dc28a9c1d01e52922d236908aa86b33f2f9b8a469c215e479cbc8b4232c3bb6b32fe59bfe08f279f1d3d45b231c2fa554b3cb8624c7d127f9f94755ba3abb1dcf8b3c7d4267d7d264cb71d332d722c408d7d1697ac51bcdd0486fa7d857ecbeb9dd09b744a1602475e2935ced0667867c70f7d11b3831d4326c9c44368aa0dfcdc4675e11fb4b089c0aa885bc663453ed955d1c637add9f5c12e71fd2b50aec6f2a2253a613373c5b2fa748bb12a0ae6137c97f55f1ff9f1018a30533888e38fe9f4f2a70586806e222f327a976b6b363814506a0d5c4040065406a126fb523bfaccb4b5b72533ade0cae016061db67cf429eef2ae9834ca5100db21491cfc0afad83fe9f05268f4271dac5a29eff8a16489d9aba892e8098e07c23c6b334136b27023df16cb8bb185e8ccdb20220ee3f054d46b54b777237fea3941b8c2217a6cd7ef9bb0c35d476f647fb605647d31710db665e340bd31b39de453ff7e19b40447366477091d6379acff87d8b32a54e83f4f4dce6789818c504a0633dd0a41cc3a7e91c3ea676fdff35cf60ac0b1230a76ca4a7be267d672e44eb5c2788dc146eb57628b765e2dcd8f476bd41a16041b8886d51eac0f6ee63f730c6e3931ed15f3ce931e106f424c7971b2713c64feb279cb37fe09825277a4cea7665dccb080fb841449590d0d44831d65fdec23d9d259d30ef7521f489249aa70a6e1af1fb795d64c54bf5367227dc179863e385246fdbd78779d71de2b511d7694551cc8bf06f0b6cb8812a56d53146c7f322cb07d70653356dafd7eecaa7266ca49181e2a2a8533017ec45c18bf3b305f25bc189c484ae7105296e096943654c8750394d05828fa2d2ad23c0b3925688a2eefea843ec568c87ebaa24655b9884d1fdbd8915fdbc05b546002b4b9f369ed26ac41be4edcb9caf2d36ee1e274534980d0389e3bbc62691b6a705ff1fb1a336d5c5f1ba1f8a0d15e97934d341380625b7ae4bd42e1b078628ed8a1c60f065ce4b060da6959017f171cb0369a00ffae4b406830de3f15caa7bbdb898f5da1cfdcc0471fa68af3bee06744e00091cb45cf368ba5252a54e542cb868d75ec75931717ad79c4506d7ab74f66824436617fad3cea1c083fe676805ec7b622d2518f18935f29cc2b63523063537f027d194fc3052e2c8e6f748c21d2c517bd48be3e1df5fbf3bac219036d8240e9661100b92c02f40458ddaf9b6004c6b4dca035fabb2602d35463bdc403b6b56ea505c35758a8a78c17d3292e7770b034cb2d7f76ed7eb23009b30e5fc711ecb90e812aadb1c047270cf857941ce9fb1a389ce0b64ad6d30ce3468099ecca5d4184a5e3b5888dd180e494a2ca6292db8220f71a2299c7514c48c2c90d89e045bea3189ec1a9f1d25fb361a99c9d1d8eb323750418072a91009595836d7629caff509e427c35f51151d7f27cac5eb8bce6b9bee15445cc61d59c6680259ab1f111e699d5b04ee7837fa5633658e52f255c442e6c69bea347ef3012db87f6ed72aa839399a1095b51330c709b201cf14421b6f9c76e937d256f85b3d9e836bc0dc7b557c2b392634be0bdf5509338c7c2ae2e3e337536eb28c578a814be83faeae07948f01f71faab6aae2646ca40976fc242de94f0062191e288c5c4d80dd6e5b30188ddbb1159c05d17ddf400024a096665d2ab74d42d926df4fc921f18697e1f81ce556127852ae1345216acd6fe64d4062438d1a8d50059224d383e5f3b8baf72a153735d31fbc291c4f2f28e32c2af716d1a98c15c86b680bf5bd2d566ae48c650e73ffa8ce1a6ab35ac58bdce5b4332bcad1070aebd7ba40c50bf0294ca11b4b7d76b43fd75b3c4e5dd12f560ca324c82ec2799a930806ee1121d277305b01ba42ab9b7903b8e02cfe890590cebe18f28210eb16fcf762260b5187896f677c58b1fe65efd7125deee9419bc804e392f678de2bbbe3f8eab9ecf305dee1bcd2d7702d801df8d710eccad6e9262a53f3028cfd76dbe2babc6b633d4a31829c8fb3ee153436e8e57b4fef00f980943e2584872b215706ab4bd336ab416a5761aea29f169a7f0a651fcd23574d109d6667c4b2c945641e6317597d8fa5d8c07534cf92cb4c9354a00816c57f5377e73b99ea3b08b4727e9842be4dc655abc1cc1455cbd9986ad9ede1aa6b057e050c568a4a05183e228f71656795f16b5ff47d194d3f6fcb412975704b4cdd0842d67465383ebb39c1d066c473872cd7712159e507e32264e450eb0075129fecd415e3f6ef4088311ff39891e952318669a03bad083c04b5b9ca3e515931bceb8639014bfeca3adbde8e828979859da18a63d5835d8a2c93b060085b89c1628d0705ce55a2dfee0537cfa8420fdcb24e7def9a59730a5750551a37d9cd702a7c067b9b66945f3a49315e27d7805707d53d9608b8d1203ae84cf10352a12be7435e13fcbf1943040439b24a83c5f3ab0f5b16f1e9176c3644bf859a2cf5159327c7b81d64498e22419d6dfff356fe2e16839e8311247380eb0986eda5feceee82265248749c8240fe9bc53ac8427794b7cea8f76150c9055fa0cc023a87367d561a6300fdc4e3905a3d0a677f4de21b582f1ddadbc9c94c24088047fbf90c6a87816465fdbdee5300bd8304996ed6cf785e84b7f15cb75b208ae55a6df36992070ad250a62d539703c4a28b505e3a8e85bf386036769b9a10a11cb5ee647e142da6e947c0064d1b2ddf6bf63250d1444a7705d9172816ab6e87b8a673aee028fd00c7122cc09d3f7a7016eed5e54e3c00345c332b9a4c9d63ab90939a6279ec14628d98682ead5a9c0782c27e7dad8a8c0f242a8f7a163fc9ba84ba7acca349a62c3645af8b40c902243be41c4cba1677776ecdf52df6cc69afa97e804d9818cb6e199592124d1af17f39a35dff4a919ba08297d46469bb64983a315b49db18de2d20bfc62f34593646b4a5af161003c34e0da9d6cb13a09b56219887ff1d8fea8346774c5d53f0ff34ff084d5bdd72baa16f62e3ce9650c6cd03ed931f1a3a3069810d7d0b1ebcaa6076cf3a5a139e4597268d9733656ad35b0a78e7b9624cfeb23bd9a43752daa2ee46e03df6ccc2ae47417ac0df0db89a7ae27fc20c7d9077ffb03406c9730c18427e2de675635aeb0239daabf0e390ba14a4e4b39b9c95aaeb552a7018fef05ee5f01efbfa135330ad99f3d049c1c4457a1348716aea02d6eac6510f367b6a9e767a828f280c95057730c47486142a9d8ef8df3ec73dd97f8bd44377d2633af5d151f6c6c46732c2d97d2b9935c688880825fa5eb9b3f40f16aa954e89cd60f17c1b8076bcf90586f2ca62cc6070e52f40dd9647acb91f83595c7b9663eaa8cba69fa9ae37acd73317b9d0908ff940b44600b348a405eaa34a04c788084e79b6c32af83360cc6cfc78afeacd92c88568aae7747da7e46c5d228f5cd628f9952a4d74cda5c50fcb24893ada5a9bc2542300273e395042ceeddea78f4244888e9d3cac82039530bccde9375d79df19e8eb75373a080dadd9b5b106c0f82ffc12ec5574c1fa8b787eb3ad21063948fd4ff2a2bd08832d7a6e1bc7342cfc0f9cf6732a6e8ef542880400d526bcabc9f907306101769e232c050b33c0dedca46bb1d0a54cdf7a5e014c49079a1dd86250a2b20f8da5a65c0eeaa340b6c1e4378e68aa49fa17990a9cd291d21dfec0ae4bb4f336267dc7c45c2bbd59ce8739238b5da6cc0fd8ed5e8a7555a54ec8a734f536be2a3d2b02aaa199f0db44438e3181072850eb475782979d3ce71eba34682b87d9d1cd3ec02bc570890748962a8d8c261410c0457da1c02fc77878e8f8cacea50216de3a6e9a1f4960206929b8eafeacc5cfe3991317b19a387bb92b404635eee18ec7f7a411ace5bceb8d5339c4598757e83a6f1f391583f690cccccf22c4ef02eeeb353649d489709ee1d3e6f83798f66492fc2cf9962242aa1ddc5a9c581d92f690654aeff56d0ad7ee052b95ee09453f12ee06688bdd7001427d613a90ccf4b6acb04f59c3179b58754fe8d4905d239922af05619fb5761734a8f979b7dd71105bf9cd11f082d5058b995b824798fdc6faebc63b46f9139ef32bec2d5d77e37dc60edd7f6f0aade73c313c31f0432e01a3f894d62722b6deba99ec10347f22d92121bc111cf756c7078dad8040bf1d0c3f8216265ae223f9f16682eff024ca61ea0d02688345a884776ee8c1b32381aa0bb2c2b6b842c66ceadd2ebf1089c844f73d92eed4115a275090e2a7e2f7cd379d7369b3d122bee846c8daf15d6d078d5f4cb72bf182551bb68c4a5ce0c5b33af0d3c487e0d86468c5d84009788f811012c33a6852641c63b700c293d55c795d7687a9fbe12869c3b4e271cdb418382b2c179aa612043d7ddf4d2badd15b58c26dafb49960dc5c06fac2a87f8dca1504a4ea64404ac053409241e3e85312a4298359278b7a42279a2e283b9027ece6f5b81b555494b6be324b83eb52445a5861a21d4d2d12d13e74763e0f42a816aae3539852710c4027ae1900cfd05b2c4f2c6c0298f9dd0e9b6103b77d7b348489ab91611d53ac5bfd2977531d1aebe378c32212c6d5fb9db686ff0345359643a8c2775428178f9de9eca13a6006bcaa398fa6d5863ff184dd9ce9a90957fb1b399b3cec026c4a921bc56fea8d410bce13956dcfe321a8fbd5dea0a699a2c0ba59e10fc2c922803b6d3007e5e28370fd851a51bec04a06959f0ca70f0bbd543d4b2d557c942186c5263fe2e98ed1086ced053a2b54e8ef1d130cfa89fab512cea496f8355e556cd60eb8f372f490f3b2a540a5c00ca9e1a21321f2b4b64f6e6ba925049160aa97e88ddb4ef55185201624a3131c132375012e4dc336f7a5a2394277089627e2d4a7673d56b27bc8d6d0312d5049ebe590939e0c6094d552526ff66031d19d08c39a858ae41ab98082f907e2a4ecc5f8478476965b5ac0488d67f3a6703cab854f6306cd452198368b0ee0203a4d1bfb8c309b7b9a7c0c34aa8ff726a876e298497040b6cb7e1d60bb379e89b9f60a499636baf0ac7b9853cfb7f334b6987ee24ad20750753bf1cf50b909c5a909c785fb22d4745b6ba4a673cba1627b64bf73c33503fccd2174339ceea335f5db7d92a09eedc8fc7fe462c43b73cbde073a99d389a514b9938796abef948361e6ed4b02fa8585118ade5779ce86e18a3328cb3a85ef6c105a5cb85909432c399a5ee00031acee8e828874eddcbdcc1f61b042f6c8c9e2d8ba59074b98b337d02ab931ee333292dda4dcd6d0592bb6c35feacc8ce98be34c28a1d1164d3836ce046f69aae058f45bdc92edd42afe84418e6e8fe3f8ac51624f722e33b79293ce954ebad639656d7fa7a3e1edf8f7f8d0ce9ad4c7cebbfcb5782b29d435a12764dbfbf2e7908097e633aae6751f7129daa2ddf1d9c72b7ae23be34e4e7982d0d2536add23348f1742b32fd601b91337d66b6cc8d71071850f10202ced8951157a6c0f515884ea0806a1418068088d1d869b0437631aec0c0241d054efcb58ca1346ed31027dc7ef78cdb4d07c8406b562766f07edacf0edd8328a8694effeefa68aea49251446d8304d23be2592757412906aeaf4c4ab6977155ef46f3622c6e80ee93006c6da3d2d4e2c37cf45d4733b7fdb966b94ddaa95d749e9dee286a91ac00e3707bcf8fbb61f9304efdb997c4d9dc9d40ab6d3d10facb0d173d2dcb0a2c2a5507d297302f6bc78772735a14e0dc770a9236c19c1d605452cb09c67ba180d55db87beb6107bfd6ab536b089ac3b344dae0ec64eb75ea4b6ff5e0002ac890528fb58fdd5c0db7e8d206111c2712f9cd46a8e9f676777bace045c5c71723c1767451509c735deb5808af47a60c5d34c7f11c55b955698479f66849c5bccbaee4385cd0a38b53b2cf68b56ed814c0989955645fd3daa8185b7da15bfb1e0aa3b1d1dc9fa02077c13cfdea484f479da10fefcf320cc4321b508ff436034fa6d778e73adc888528b0616f52f29799317972e45157d696628072c7af09d6831414cb8b55e7b8a865974a7e31b1a6e7ae01a9ffd1a1ce3d907e593c413a37f3ba96737fe97ac30d969c7e0b2cec1b6e3c9413fe0b078af2b4c31332e3e1f3f3b7aed4a4393cd35d1b9bcd6bea91e7546842f24d64f1f1f01c85fcd53d72508062c9b9c670c2795a55cc1aca33f4beb43425a5e70268d065a6b19305b2112a77754f3e04996d453000fc1d00c07953882bc54f54848a59bd097a304876f89dc79bdb705fda7a55a9c11684793ed965d2824ca1a61ba1ef8c9b6042934e1f9580316dac56c628af1ee0b9db6e26f8bb190a1e9db2d45e4e7dc490520fddb0c75d9b499b3e574d9f581dbe6dbd4e1303164b4e7027b234d019d8b4894770fd47aecdfbd493a0a3acb33a0436bfd909a32eafb0893bb17e664af7703f83b47aa39df07d9b193f80fcf2f8e7df99e5db32fa848372201a37522d032e38d9115375507480fdaea550f855e3053e0c82bd174976029ba5f23876f3d19371ca82eb61e2831aa92755ab8ab4b1458b792659a7c3f4cdc6b13297b7103cb095d83a0ee2a65054c2d19850e42835502d52e2604110a900bea3ea09178fa7a1f06041198b2a8c0b88b9258a86c9860d3aa90d00627ec54508cc7e9b8e19899caefc6854a93aadb216bccca8c0381e45b044624c1fe9888d08d7d9e51edf91ba288abad10c3a109d615df96ef2a29ee23db7b67dc7176f69806e3e612b42719d658249e3081d072b3bec8accc0f984ce0fac9bcaf5b7cf4806ff0de898b364ae70165fbdf33c76d13b5807d109c7223ba57662a8a71e2b81824ca5f5148b8d27bbc06f368d14a39fe3ff9865ff5329f8d8ab50b8967fd7f005b67b872a36c5dd23bb350484a0a1ae156387e6b5e689cc78061bb86eb0552b1408db6ef3bfbb38b8bc774e854caae5b5a7f7f873127537fcf4d8ea042c2d06266a7f219c0d3203a533fe20bb4adc9b012400b1683c0c5a9c6f88e07179b61e739a2b6c4b6cc357dfa12f010c22b5b72763097dc7c1382bc24adaf2884da4fc865f3a923eabefd830a9b699da7f6130cc37bcbb39e0d73addebdef57119f3ad3c06943ea55c7b7a3574b6da64c1609d3d14533c8e5b7410b79bbe7ab98017f047ac96b370cac0d85d55b36da3015251a7eaf45670babc18257567655e085cbd7b7c0cfdcbb92212f1c15dd3ef3fab3da8226d24081ccf35838c6ebd76f9678cb467048f25af336bd488a553199b0800ce24f101a7bae082524598e389f5f23f0c459f2b928f0f9d9ffc50ca0b043672c5a7e8f9866a60122388c9c9925b2d88b5754c419b5100243fadbeb3b921d4056db2bf0f2a5fcbb207b20e7ea2cc4a3ed742c0f822fa2f7eff4543cd24d063f2bc83843da283a2547d649d42eb6b03b569174f0eb2d2c8545be056e70dc11e991ab5d23ac995e0c0c355779b21f1802f269a23c3a21150e5fecd20ebfe481ea224a58e6dc7f088eaf26490e0d0234c10b95fe229639dc6f83b04647f9b4c5e053c582ed05dbed53a8f53ab1a9f6516eb7c3c0a109d76746ff7bebb92d6945681e757d88b180a516c8ee3127a31c6e3da99458dbe861b2bd7e23a2fb783d8cba4b6336b8972a86883b1e91494b7f96fbdaaa7851db8376932ec6cfc3b0a259c98f670baa7fc410a6922b78a0a2c3b38139966a4bcf892a934300d447d0c76024496eb036162fa6e8d0d4f7cea014de09b97cb6c49aea22064db2b94c3b6a955f029385c9b8b080749433ddc39601a78d6d4339a5c8e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
