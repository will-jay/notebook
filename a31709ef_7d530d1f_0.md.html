<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78ec1d57c5d25efea1ebf8dda854df6fcb1e969f35bd05ff0f2a70b9855b99784e880182539c093a08f128b62d1e82467044e1c311c9b8061581b83131f563aa27113524ecdb607da1b7d913df8d1772a4985e6c9e798aa02ee6c955d983823cc12a83351c3fc0ef0acf069da94e217c3971fc53919594977759009ee8ba5519926eca3b96bc84ea001315e7770b14ffe5fb390628d2b2e033c8bccc69872639699b147e3b9c4a53fe7361b0fa961504dd9cc0ca3233cebd2af0cde49632b265ad18fc93823fe156c6c8d9a7f858ab0563d2adb2c2a135bf9be09bd18e83818103f021eeecb9586fc514a2d41c125683847511314826fb6e69bde123ac9a003ba699016a106d652f0eef2f7c2237a9e844bcf98d419f36266e2f369dc4cdfaeb14b340f2019e38135c09f8a2b223a15f5d3ccd9f179645854a058e71c65f07fe9d1d3aff695ad2501c29e8fd11e8f0ed95ceaa02d47dabad4dced44b99021d04c97bb1e3aa4831ce2e82c302e5299c0a707cad1c600424a507a5ff5d80cb6cca7c17ab9e16348808d0027254f365888ac385579208074ccb363e75af0a69a83a6251578a44c3521851db8d7bf874a46be88267f81e69f9549bb23238e5cd0eecef3bce8cdb28dc769f46a994d0eafa896c3c1840540b6d2501d9a21f04c7818770254c05d826d84539dddb4fcd34d2f63a1c69c329e76e35b260e7920c7aa7263d9863bbfae919e33e9a3d4c2f06c3bad70731fb48e5b46cc7d81e30cb9b8f7557e980cff3a0cbec4f62ad93c2158d8621e9fa89fdefee1762b8b3c080b54efb006ef89f82a69b771dfdf96a452d6a35d4ef5545a658f61395cf1480b62206a6940f58f543cff0695f910458020e4d37491db3e72e179ae55652860410714204fafda38def59a0fb67fb6ad6e05957801f8c0fdc2ea8658aeb3e11dbfc4ddd862652a5a8c0a3a42b1ced17b93573a27efe833ebbbd4400c08da2c91b479b93aefe14c41c7e2efd302bb9a7d48d69e8615a7390fba6e6f820143d83cf6678f9ec8c1c10c08150cce4ccfecf2940e173dddf9a0b97cceebd5e8a93a96a65c8b1a69b3a3f9c67065318cdb7b6916b76987189a7ab0dd6d0b9ef2c8f4d24224e238e4a9b38d62cf55fdd6687f1e2f1bddfc7a5a043e559078c2d94d8121db3b75dc22b71ce930b8eedc164da27a6f96275ab75c12c4cccefd7e034c9da80e73a942bb6dffcaff7161cbc19a21d7b68237e78594cf85ef24195692f08d08c58a24b2419b0d89fe9bb7e87e36120a379968d3ff87a262781e39a94009daf5211e0806bd8fb35c527da5d3b00861632491e31ac980ef25d193aef54884d2f793a9ad2377b64bd9ba6e20f8cf449013571aad43cf0408ec512660a7bb759f0a36aa5012894bc3393d7e3ec9d4ec2cc5c0ce5f730212a10f284d6aaca4bfcd9fb954e91b7a943484c841aeb288dec38c182cc7eeee390ba2054d08068326ca6519791ae1d9fbf707ea0c7a37cb87d22e6c5a16f38b896381d2e9a7f9459f6e6b0e5ac6b0c44b596d099361733551ad618fc5f164eb6b996e7b47ec485c8cb248ea1628eaeb9a9413fb9bcb3d8b4b646ba8f955ff6a76f0726b6e78eebd4b2935cbde8b926b1dd27d1d532c0b72efa27dcff80876471b19b1653e1722f68a37f85d6c05fd7f8ab41d80c6721b5698667852a78f16210689dc87c2ddcbbcbef73afeb6bc28a81e563fc6bafd0bda329d77d9d87a91c660e498c184c5e2f9d6a8de72d019b962a9f2683c3da40be93b0a26f64c8fb863cf2725ee27c7102bc789b939f24bc68178360fa322cb37f84ca27579b78e401c8a37c08681e41c9effb069947c8036ce23879d7cae66ab6bdf505a4dc217476e3587ba348caeeb122ffc20ce5f99b0c535a55a87d5e3ce77a602ce769d7402710fc90eac4142e47d8ee94c7ac2786c120c8b6847545556449a7d80110bbd4ec65c318f38c46328da066ed88e36d16241829d45a66d2be9a6c4b8f08fff3f6476a57e4f7257b2f186fb77ac534895e24718d6b829b90bca1cf55c731cee6e9737924e930d176073b138555f4bb7de4aa7b72e8b9c356466aa45fbd53c57fd05489a98dc059ce5bb9678f53cd483598286f0187ddfd688e3ed3d0721db26a4f8f258a47059995c6e66311efca8eb012d2989e4bd5b7a9d689381880d92569e72abdf39baa4edc77f32396722d4980d9edeae5a01cc99f35db3638ac6e7c9308e77ace31a3a4e8b41f7ae9f5f5184fb3bbeed431b3e3aef5bcbc93131691739f41b6accbecb4392937e67328e38aa0ec9e613b360c023276934ba32b2698f9a68506e6d768d47861644de675e1b83bd74444505c9bc16b491c465da6bf036b3262dc7e37900896d1b56fe051dcbdd2fdc24beeed32472074e3b5c2633cf8234a685c9e3a1076ec8c6fa08f6e2a2c5c4e9e7b4c71bd4d67883cb21d3a7959d577fdc0e7ff4d5294a4953eccec1f11572a8b77bc32550d268937b336e5454d245d837c15787e1f93ed76a3d985b440e8bff307684fa2e4125ad0fb3d0b4804c5291172470de39f8592e5092d320eb0693a805b1b2cdc75592f84f3b637ff48783c04cc8d660013b3f249dead15042e567c7235d259a112c429dcd971cb74bf4495d6509a03ed6ac484ba1a062fdd67d7ca05516f46ccf052a8eca633afbb093bf52d3457fc48765ea350468d3f5ac4337fb6ebc51403e2b697e4b6f24996a36ee6be651bf8a47833c63a3623e4ff3fbd5665eb723dc586c628b22781e65ddd992da95f0b54d91c508139113d14f47a8a9ae93ec712d773c1ffb568e9ffae571a4c8adf6749157890a9b6bdd6254dced96aeb673e19336a8a16a9f3bd03e8c0ecd75704a83a93e1c58e11314992156b70d67a641eb4f9acd19618b00b0888abd29dbd6b8b4dbfd50de5f4f605953751cde368e7fdc0de5016dba3dd7d5077073903cc6ac83f9406f98c246ebb17b1c1292322b49577ba30d4b2ce68253ac010d77ee7fa8435685270581dadc188aa4c42780f6579da6f50a509fc035a05e83f97998f7c5af73c67066765780766c9d6b1ff4356f442eb1f0c87c7a3893fac93b43f64fafc9f6d3fe5bfda3b1f1ba4a1d75ad804097c63a7da66179f1606e3a71ff00a43043c80831805b67b560d637050ceb1035730eb5c1a7b3d7c35c9d052e9d4f86d639bbd2d9242c6989462414e4605a159437636187727db9c507134a8f0ab46ed8c22cdc654aa0b13ca247b9d19c181de77c5f8b0180503c3175715291017ed46bc8f1a2b3082ace25be94d7c2485e28ba24789261271477ea1de144d554a5b563bcddd2791a19825c09ef357f65c1bcc9f894e776feafdbb3ed24bfdab50945e0023ace1183c51f44d0a46e33aff1a38ecb5af1fc6cd1989d3aaea714cdd5007c018daf4f915c3cf8aa887bb1fdfb6d03651b32cecb51eb3421ac17744e05dd688b289f5b2d7fd41982fb7e224801f2de7d3e38b2913d4cffe2c7eacb3b7253d234715284d8c1d5432f86eb092b6f37e5657c84d2b1aac48bdffe368a76a16601bc6ac61891ae6c12904b6c6875ec5da753285dc9a9a12de1236750634320426c86cdc1068b0a05987986c4660ccecd93eba6c59243ee467a15f8c9913908e5d4b49121e27973c010e70140781e1e3912f9970276af4228f7ff0297506a444489f3bd077be1ed27200aa43151cfddafbd3d658f4d6615760a891ab9e18e020726b31e522fd88ccf26dec857360dd3e2bb0ed5df5317a848423ed5aa80e16727a68553059a89bc511c5b14ee22c50bf2ab69bde7e5a8ca3bbc5e8b0dce56738956803f55b5cdc366138375741efb80715b0f1a44011d1509babd9267edb59fb92581ed0f47260423b28997900653d46ec0a57cd6e32efd044ecebd8cf975ea6cf7cdaf8057aa8dcc3ac7651ec426d1bfd46b6520fb835a53ebd59db658670e149e8e3356740167e14d1ba73de720804aa8603d97872a334079badc89c1cef6369bb171a61622df116d701d8fcc1ac0ad4794af0d5ba0caa4177a1acd71ea276fed282276a92699131a9c35158e508afb526b53c9e00b19bceb8b5afdfa7656fb52786e0d14f07038bd26da590adaa04ddff9202db3c8b8595bc964e51a0fc370fcd388294e59a871bcbb7fa4533b9bc835c1733b9ead4b28fc0b47f806260ee6e7935f55e7106bd414a1d31c206bcb79d0e3ca06c34ffb3978ed65c6af0787e4aa2ed33e73c83cfb262b5379c6e333ec3d44a0abf1bd4db10e64a00c8432f62d95a7bfefce447dc91458c8a163287947c39aae232213c6a8638af9afdbf95aa6abe9aeb665a305d2457f0859630b42baa45a60c1c81b0b33a261958d4d144288665e224b040ec1c0149472368c28de675372751ec61156162201bd370c9631f37f92253c36d53468c76794472d43934186b66f937b09b4a474e618af2662fddf34d4d7847c815f41d9ddf9d2fe7138bb773b5d7c61944011d6a749305c7704dfd12cf785d6bd3310961ea9e05bb7ba185f158fae39793b31c4d320d348b1105e0c28096fdaa3ff070cef4ff4d10e92594f8d5d20be62613dafb8fee26a5c5a5952a93338b8c3de5f19cdde48339c78ea4e6a745855dcd073d7d021973a1209856fb8b6fb300aeb3958d99c43dd3f7aa0d546783f88ef6741824fd47f6941b3b3864f4648db02b0b1e94b252e27c834d5041be0c27c0f592c7b77bcade6ecf4ac3d8c3e6a494c4df86bc88e7365e243efe32e7e3d023616138e635cae7bd28558b03db72f3a8828c7e1998ef4c9f74a2a486f2841a23d875e203d622a7b344a45dcfaadb8ba1a20fcc47de0fab9f3054e3ad2c3a96126212ea793e40d29838fad6a27af988f36cf71d163bfecc4839c90a6810a1d72cc190ed8558802253b099871267bbe669c4602e49d596a2607bd85301883f98ae9ebd2a92c09f828be36fe444694fa3e62d3af2e515e543898f4d21c272821ca1d065b841b9e2c5baf9e8b3be108c719aee428a76fe79ee4121969c904e813c3a7695bcdfde28611b9c295d1e91555b796b1de94904a91e2fdc1eec7cfe083bce6021f28652fc7b3cd18242489f4d7eedc01fb61ee6605709d610964be1617199894f285fb3d802eb9519019163409ef9c00ec71ff0210fc151f30a612bc90691169f9c4caa0173668777de324200ca113e838ed1ed177a9bf3de5e3cb137133056787b519000573e0a673bb95acb7cc68faf9f2c479d9d900f8ec87f88b8dfa1a72a5563b239a8f32700858f0cd1e90678278336fae6d48b204d106b4cac880181c5e09fd135f9c025ded7a60a70700a773b5a3b217efd94cf42762f93bcd42a9ad33e86f35d364a7d3fe6f89988d741da94df3d18bf678244360fef16cc8bbbf0d88cef389a877b2d23c52ee107425751b4acf961c47abda4a7a9f1b7ffa1d9af303f55e1cb0613378fe8c5d909690a4b9f52f410a5ce2c33961f8ee9a55971e133ca78ff34bbfda93ada7093b33096ec3e9ad13ea4bdfdebd5c5d84f32ea4c6416933df5cb77d288700de99f1c90c9f8c227fa1b58a4eb4f3f6f371662e7f693b98d96159906a451f4feafa1771f405d6eff667565b7182b19a0d3d3d568c31c10e50153d8d8e7bc75eee41e5625ed700c53c0e4193f963330f1139af0547b50fa33e3a6bb19d119b28a9f716b1d3b9fc9cbb501e7a0f71413ca72ff4db411c6abecd673f76546a475fe1fd5c935b5b153eb81ab41b4ef93d692bf7ec7f0c1fa049125cc8e065be03bc71f3a487a04193ade87547d28542d0fddb28203a3b7d2abd4f4809355cf0da9ce9e4028af8e3be25910209ccb0f7f635e2a73875211f07070d60d65ac21fb37be60d022b76e5a82b0772994a92aeed399ac8128deb9f9b940c7ce531e0c7066b6926c318c6c36fc38e199cb24ee58dd90424a47f794464aeaad342ee09262a92d6b5c1e4fbc4943e2fb8e52fb7a5337a81ae47404189ce7fbe30d9dc7227e2b81d44630acdd794c47f26a487456a9565cad393fadeea6a339f08e8107adf1297f038349e6052ae8560851e0dd48f5e32f7fa174a146d76785b7576df58b865227f7b091b54440ffc221ab52ef591fa95d25f9d0b3c9e85d8caa82c2ce981befc54b5609d726ac072dbae59f03fd905d6e722fa459d1fdbee79063a83b32e0b99b1a43ae4963b0897479074a3b4d7764629b420726974df7da33d92d91068bd52298195a84057994f2cbbfe3dd2730e7c2e00c77541f91125c5e8628e22fe4a742a12706958723f5f976f171ae65e6b18bfb498edc4cbeb67d0afd4d9e3bae68cbe06751fc8f15a0b79a79abbb2a5fe1ad7ce1800a35e51f4d13e7cb2c812d1ccfaab737676dbbd4ef916456ecc5df57322884b5b0de3e131f166ff0a76715906a03944acef2d3949e5e119a1f0239319d5f70fd62c6e63ba2a88b78b9b2b220d6ab8cf7aefcf696ff7f3efdbf2494768c906b3acbc425bf02e174f084f93c2ee3b21f683c338e93852fe9d3be6da1213d99d8fe1834cac905ddd0b6763dbe8c5449e7ae8c1a1f146c9e9edaba4967a5ace2fb20bfa8866a27e82db7878320e73313b767d89bdcaaa7bbfa705c2f2373af0290eebf9c557dc5f2fdea72948d0418e84ce1efe07020ef2aabaf25e1ebb7c34b4a6ffc669b48e72f168e0cc1ad904c79d3296fa5503c40dd6fea9966ce3759a69e47b4a48e00114a8c4aa0843badf2624b8ba32ea8b5a77f5f767faa8d741e3df34470c604f2d7d50797a0cdcbbbd526d86fe96b6de7b3ea628bc1a7ac756c1d95b9111ad6e31016ca8dccb66234556f6bbd7dae047fba328ebf86bd5053415438bff0670c33d61aabf5949e40b34b55d0598fd9e245761651f1442fdb00756586c61e4179fc466023007165bbb12278e37d2fdb41664185ab75699df4aef05991f90bd6b1b6efcbcc32c01894e03b860841a87837d8d132ea1866412afef091ab9e6ca8b5ce175276a12de0acf357453236c4950dbaa7ee3e910995d584fbc86b460c47a70d07854bdd49f9280f773960400b8e84c9e3be200c1ae5f5af646df365a6e9f5fae0b25d0ec14f8eb160bfd1c6cf12fcf242806fb19de92abf41bab8d0d9b4317a3a4cf5c2c1c3d8e79a9cc8ce6a418e57319a73ed7caf680197c6cacbd2f07da8b5d5d74913b218ab82f05ad020d680394fa536b2d6647dbe5dbe08c9eb209e1181a607574d1cab093f6b912da975b31add40a2004129d93d666c71ccedb0c9a1cdcae620e84258a7fee77bafdd061e028c0fc1016c1cd6787b1c952acdfd8a29f95da32b6f36e14d92e0d7c7449e1f5ab4f577256e00299cc1db148a286498350438bab0586008c070a1cd413ff8db00b722d035c47361d51acf3fd28662a3f34ca2b1ed35b764bac5e7d2eb94eeadea981e3877f107a7d32d494273eace89eb296bf4a66306a2ddb54c0f982d6ed8a6d66c077e72e0867ff336e75ee37751994a07d7d675802cc99a822a9a3526ce818d579e053ea0af86fa4c0ecaac4c169c450fd6705269be7cade8a133c17e453664df0023c5bb2b2c323c2291a4ec2d247a858ceac60b6cad48d6af1348dd9ebd861202f468cd17e03705149b0485038b66e47e782be65ef7405110b1676d6f9eddf0826230ef3aa089176a95b4a3a758018d4298af37ae3d052d867d1b3b2ef38ad1c2d391c3e560c2ae0abcaaba09f7e7d98b731fb24320fa75cea775c5aba5092d83e95dc572c9e94724d462c6d488e3df86986097105be9e4cda914e7138afc0f855123d6b4d609aa743b29f3d8d2fc0af59460673065e459e993b4c28c76cf6781c0fc11db57355c6835be4ee090742d7ee5fabdaea80b679eab6633012eccc28a2ddd68b92ce05fd2a74cc3fa686dbe2b76e0627df6eb2b5039601d706d671b24fedbb2e7fc906aaffd18da5d6995497c99c572f3e9ebc42bd49e42325769a102c1d48547062d206ab49449b2ba83c28127c0ba096d9a80f88b3b01c24603321bfbc957cca28cf1eecee9445daa00e5ca322aabc1dc101a3c624a1c81d61acb52aafe2a66ef8a02424f24a5b982146e8c57024b3d9d329241fe11ab8e9756962c8c4bbfae3872de7b6c20151484aab6188383e6960629de302e4743c75e6f444f04610bbb574e7ba76de941b8b2c05d26f69180240c25ea8285f4771eb88170ee89cabe8bafe021416ace8f97087c4439c9fa52896f13824188eacf69bc3f12cee535705e123c7036945aec3f1d43cba4212e547f628450911eada5ef624e43fb887df9cf30a705b11aaff5cd50c8da9c5ac53faa0b23959ce7f10a34f43849d5ea3b3cc32c8aa8c9fb1cd8d44a634c954dcc6e15db4f251edb8e6887ad143d0028e41ba56819eb6895fc3e01d85be371d344c916b66de4996562a734ebf1aa4f05a308f3f9a6a511fa46c43b683dea6aa2d63c6406a6c44e05e5f850f488ca7286cce8cbab8480933f30abfc283a3cb3e8a6614f51c813481382a3cc9ed7e5a646fe5a2bb56c8dd4a5fc49a08660f6a06c6ba8abc3d778bfca11ad8e9477d032e6678b3520421d2204d5c7caa1eec16c2684b998a50c3339bb291505882aa1dd31e7b5c77b3c526961d24aed3f5694cde4153a269c97bd2ba2bbfc7bcae598f6a1d5b58b81d881faa4ce5b6099b06fa3954cf8ac133e0e08490a91ad1ae439b95ca964b1f273ebbb8680f0106679303a1c49f50f1a0595e7e7ccdb1148201b11495a846d6864b79665f96294da575dee47110985b33c8099248c8b520405ac22785ac3fe862e7a8417ea474b804b780ed6e7128889f435399f2cb863437741f0601991ee25a4dcc0d812dc0e4c91a4ed9128df2a288b8d5ea2b5f8721293cb5b5bfbb76e6d761dacee9891228444b6d856c55d146348a24b6cfcb70ea36d16a457312e0d907254c65f4339fc7af0f17ea5ac5ecc7019ebf5366a2666183a17f410c8b16ed07934c6424fbec5cee416cb91f414c92af28b3b5e54607597426168a5481bfab6157349416a5ecbb7a0ee6b6ac38f1e24cdf0062a18bc65a40db42a61372a61f1d5a1af5351d59bafc73bf419e59fb9446a8e9fc6a988403dabd9a61a338b5453804896389eb354d408aba87acdc9afc2c5e9bbf4936331c42bb7638df2ae1389a4089ef569ed970ffd07821dbe7edf972139c7bbc00ad47d8689164151017f94f9280f240e92bf31485476f6a98b76171ce580ad849042f1cc6d62d2c3899f47039e73dbada1243b2108d06f10bc56c5879ba8071d5fdc53c81cf6a152221b09a05d379f34a14fc85599b34f8ff49c72","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
