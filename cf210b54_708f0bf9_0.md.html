<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0f2e00f1d1180711f74d7be766366a251d9a09e3d441c2a6b26ec059c2c868f0c32650dcd50b1d33650a097da41223c4115b358242a7da9d0178b97e02d0bdf2554b343145981c4b138fd4d57866bbcdfaf76e40091b8bfe2858b8acd6a74f498905a158aa79710faaecd4da975112b879784ab5da4d7d529efe993224808a379f49bb699286620b25b2ee3fcb76ab0b2249f3c4bd0e5a3cb6e46269dfccb2c103961bb83745fceb7e4176c8c5791329985877ca10fe8d04720849995c8e714f592a7727f5e31f5a1ccd1dd2aa6555cd3a17787e789e5fd45b36b17d133521c4b503a369c98b380c6f4e9bc712711ab314731a13ea4942ba9082d91a2e1c09b478544d97cda3d7370d9c14a740fe927f3089992cedf3255ce3b64a191aff8206132c52003448324d2194682dc118953b77feb0f10cf25feb12c5375c52824f5ad2273b967f425b6bd3f8d100db47dbeea5a4181fa0f148ba229b3f538bb1b8ef62d299ad569c29866e3fec2e90c2893d812c75513afcd34252a2a60026676ed7ae0113d3adbcd14e22ea7443e7f8466a1402dfce6bde23c1eb839b39ec93091f1d396aae8c4e95c84eb605a6ecb56063c06d8f46b64b618c01188a010d100ef03518f1ea93e6ea5871a41abf92879112d44ab1df0a8f0519687e6edf46684f3d894cef2dc97f913dd488383847a1ab5608f6a4b2764f2ac292a1da1fb8acdea8219f408d95590eca48df06907ef2a2369236c83e5df2e4059895972873390d2d235896205dad63305b02f334d36775ca65cf769376ad7aa5b1f717b6bb307a52945403f28af62b8d35995428fc058bc7292291f8fb7b95519f6197523013b094cdea508eded82af35d0b9fa1ce5c28dd42fc3b2e41f9b548df1d823c165ae93d7da335d4b3011f4b4d92eca837468f954f8e28e4e29c7822dc18a0e85d98764f23392e8c7004491710fdf1fddd0efa0605dd2c53c8d93ac293ff540e58a1eb0d3c5aa85a368540f3631ac15b05bed86ad8d0bb3c30bc19986bdb1d139f964bf6fb4abd219aaacf72cce66aa58b80a1f4cde4f1ce41f4ffe3402179824b9929164eec05815623933fb3628806aff5adb440b4736d7815d03a178df55c1ff2575a00177fc041f72f2ccb828cdc642651df3c12634e2fa852b2ca768d0ecf17b4f0a47584b28221808d1032f6b9aa7674fffc158071e02453bebe67754e067070e305f64817c2a51d9e5b1de849700287582c8c86f3f45a92d70082daaede43846e06da9c5bf2ad2a955c7ea7503b03c8832e5e5ac34e1a20d59aee53bc522ae218cc906150ba651a43ff9a31a82b199fa5841a329935f45d9b1dd4e8d9393b4fd6aa7a9554632c987afbfb10e7d6f53afb073a9a3a6a8a8f9bf476d4cb4809f634a6d172fe3d35fde51351df013b0d0b12c697fc6f21c805e52b25f6e4a46d2651c4dde1bf7704e92186f646fc1a8c55ff0213a87f2eb83fba9e9d8558d1a28f804f7aeb52fe406ce9bc638b7851de94d0167839676fdfef33da2b11186163683577bf72de3041a901524e1e045c62bdce2f2c82dc5d84358c3c04696b317056d2599688b088017b6ebfa9de17ae09fe6eed00e640e71b2b778905b4dbcefc9e8343e74d67f1ffcc2142a32633d2c6f2e4e0469d15065fcb2a0c1a1f8911e99705ff5795bf4e4d0b5b769d8d62aa36081c71790ce87a1f40106cff920950c00c6a0298777cdbcf7190bc0416e6b62bc03064ce6c4552c59d2971e22465bf49cd091dddec3356b22081ace10649f7607da2f836ad42b20aadeb9f0ce562ad652bba388880eeb57ed5920d2308308f890767d9ed2131c63f8b457c55933eefd3e909424998e67eddca22f0c8dbbd18699c388ed77e19db680cf211e141970adcd60259a0355a3009a28c6e31dec15ddb462299e52d65bb64542c33d4c0751021c547d5eb9131243284fa4217fcc5a78ae98d7957c25a0da3d4526a9afb9cf7a6ac185a860b5c087951e75d317f905fe3e9f55f970a694443e6696f0dc0f6148d152ba1a0d3c9e7f909301387636298d93c3980162ec881620471f0e345496a2df2cd39f244214263b1ae4d0568090fa3a54570c861384ed56dcb43376d162aeacc71d665027bd4fe00584a5ff2abb816af6ed2af6e63d00608244350d099d7453445c16e6a2b3d961779a456fa03bd3a025211b2a976f93e08c0f247db5f6a8ad6191aa47d13ec5e72d66b956806fde4b0f7964cd2de383394b62f0b8c1e89117aa1643ba3e4ac6a67a8608c57717fbf95430f9ef8fd2422f5c97fb1af7b4523c924bb22d486f539470bff755c958ffd452f057654b2cbabfeecafb8ec02095fc76cdb4707c3cd8516652501d374485b48f247e3a36dda7c02333dfae1f4aec61d73b42c4c238dfe1396c7eef4c3e8952804b12f64634ef683162e0654541fd4625a9f8d552259744d540164bcd9bfecc45ac5ab8b2d665327814d2c1c96a9d7e6405f2cdec3f8963ade2f3651dfec2cd8b675e748d825481d480dc99b3d72b9c3b21f8b31be9142173f413861ef8265fc818f25eb2fc96c1dd53c96f9e2773b24f1701576b50dc6951d08ff4b09fcf85cf572adec21b3305b3797297d5531f39b9cbf301834f1724d0db9a1b0616362250915bd3e5624d5d19d67f282906addddb879ac9d9f48d0275b808612da5c2449b4eae504b9613dcc9115244e646aadd071a4b753c3710d0c56eed3d9c14e6974256875e62a919e84ff33d94e2b7bf8ce2f5064e6d2d69c9371ba702e0af9fe8e261f330130d6c174bc82be0bbd3124839c3a4d9cb8600df22af24c934ba523012f7a6a54770b53fb82638d855fc0bcf09fd25ca956751f6951eebd68a20e8597481fdc56cb20296e4f3b1c21e19955ead2e0913fa1c0022bdb4cee19b3cce3e92ba257ae371a0dd2385314718cd8cc5002a83698a7018d020c2ecfbbc634d153c15ff620f2d291c88881499a8758531e3e0512a2260dae4d71beaa4663cefb4c93592dbfd8aee7f53de76a0b4c1cab7ef376b97ae6aa05bc0699590e00f2c89012cb5c53a39cdfdf1d0dc4df8eaf68ec792684d249c4f3fdf635d9f7455f2cac4a53ad7847acd983226a1c4e10c910344d3be73cb95aa87bac3ae70c7fa1dac92f4298233734debb3375b1e007288f929b3dd303b304f9db420688f738b85818048829c74bd827e99a195c3b2ffab00d151eb0d46e0916f4999dd104260510dbda5112936cc99e64110205ac48ee8d8cc3af4b3052dc78318852bbb8c1b30a383ccf548144dd9b4ac7f18c47846af6f0d3fe3d35511e74047b4481be9914a3a387ab3ef744abda10e9e38054abf6939057f41df8cc32ff92f6396a3c2fb79c800849623b150bc1067d477f306586ebe7d41f845a0b4ccdf2e366d58a2f7687c12dd855d39887a0c7344a34115430bd52308b15c4409348b6783ee73886e2dbf7df8d59dcc6e4a1302b4ba2b7ab4126a0ba3b17423293f5d947453a3a201af10d872967d7c5d2a8dca6da4310bb2e0a5f7c9decd429f040424b2cb778ad930f65522703734dfdb19e37e86ed8ed38ba418ff05efcf11abc293666e31deb345665fd32cfa15cf34226dd751a98f34be767b5fea1d75fd87f1058aa0dbdd2cfa81494d05c4d969df9f270ed42e11810be7eb81bf177ec0d727735a93e50a78d671d705f0b4ad6d2d9ee389d4cf544e65179b9b96d94874a0740fa6279a5a33f3e7bffe2f27d964c4e08abbbef10117aa350cf485c6a078a097ef36bf0f8a54b2a15b1d3f3406acf8cba1adacdc105f2441c49cc16d418bd0ee10064ac9fc043836cf878e35867c5350bc4ddf8119d33d01f1ee0c5555ac7e173eac135511896c2b3cff32229c092920e522ca9c54243fa9966ebd8f7dedcb5ebef74f439de7b3bf5818a1efb1c1dab9bf030d070a56fd75d201b0d3ecc486633f1662a0cbfce763aee66b62174489b3477aedccceb6072715369e83c33f125e11838a6d6987706c8139c7fb4ec46cafdd6b89177e19d0f650203035d85ffc94ae264d73ae89071a1c3e1d896ef5de2862acd82dc6984cf950413ad9d5d16f14911266ea485b1e28a3e3b02ad36579f28263c586065351d726ec56c6088061c5d0a3add5b3b382483f2aae9f16fa9bd48e67240ce765fee04e8f43e0b07bfa52297eb79cf3ddaae833d0e1dca6447395547d668f12daea8d11fcf81530ab743cad1f0e397c40550355d184686f133e74df72fcb6d379d58a3f4589da457564bc63e87a221ef761c8218521706d4e3c0d897ee9cb3e87f2d67df2821ddb991ff3a6fce2f74a8a528a22dee0b987a4dd0a12dbdd9de80a66807098bc0e0617d092e9c5c366466fb94643e6937622f3dea569e75cf71c519c67ca6d2c34a007bfcb8321b2743b64a1a7902352ce3b7e24fe47bd69b252f63ed7075d256c8c700ac910183658661e149357c9e27242a379e7ba5bf7ea10c5011dfe018428868e1abb0de95d95fc81c849124e8a7c5fd7a4fe78307c28b33c118fe49563c92073e422c4c95523f9b3543c03d4b649eb1367dd84bcf3299d5b2bcea1fce9d191e715c3837ffee9e674fcb8eb625e5299f4736bd84e11d06b741f2eeaa106266da7cb32c77693208ab25049fb39e6827c488b9a02034c478453e040c9944c8eea9818bd11ca55f3f63699e7b6dd2303f44f15ade9449a1f28b9adb0a6a4cf81860c4e6060c5f70a575a22aaf7c5d82f8b7f306ac23ff82a86a85c69d0a19fddef33a45434cd0d4b044a0b62267ec8008aa082dfcd46b3cd06d5bb4fe37503257aafc5236498a898f9940747425af28897d84cdd3744f7c521c112ba4fad3b87eaf899d4aeade2ece2c5df4dad092260b08f2f5f2e7657aee973f54d6339cebf9c4218c4101d08f6d9f4eb8497718d623f195923ea64f347c92443cfbed1b9fd7681dec2e93a3efe5a84762ac932dc6a5a33e6107bed572b80db99c8f050f1be2a0b3ace50f025a122b313aa700dfda96cac8d36f3aacc8b7704bb22c698f9ab263c8ab7697672b4b1bddba982bc13c1bbc8eb82a29b6d8467196689de8ed73454b2a896e9fd8a5dca6f220b73878461425daecc7a6384def4ff666771e9bf4f0a073ed85e47f17e7095600ecbdab8a042bb013ee5d239a524147bafd8034f302ed935e6fec20c650a967aa0d23237eb23b6c7c336fad15862d4cdf3eac1cb5f0d4b4d0a92a90da100c8057b783af752004cfeaf3a1de8272fc7552c657f2562848e54ceda38c9ba0598ed82cc79021f0d54c8a9e1ceeeec16c3fa12aea1633393896664c1d8838e853c15ce28524ea340ea669e7596ce7ca73cefe288f453c8a5838b5a1800dd351c71418060328706c7fe61193e9bfd1d21f6036fb8ba69bfd76ead090e642fb42995a5b94592d8a86ac234e6a3cd56bb217f3f0451a414cb52b29cb04c92fbfca22a3a57aed83e9bfa58a6161126b8f4e03f8d5c50a48202d0b3a9edfa6b0220e993b76039a7d8b757d214474e5131560be61da3355f9562b9cedb52c13b1aad9c46ceab804d4bb44b02e885e395c025e4b46fa81d1e100468161cd7d8c055bc2febf90809e3376d95798636b48dce47bb54d65a552ce32d933403a79a2c1ed877edfa7931b686e543762f5c1c02be17e4f0da9717696b84370e62ed2d4f5a91d2341096c6515ee04c14d6ff1ae1774e3dcca25cc8200c714b260d09bdb214ddf3a8ee7cf94980bee0cd2817f7b84cc6d34c7c5c953c161e96fd89b292a30d639334f346cc2c67d401e2a67a2ec243638cef1d280db8ad8fdb42b2adcffb8ec2152b9f687e4c6f75d23d7e4bdc00c59d6482009f3db2d1fcf0ebaf697b3fc2b904fab23e50d0be0792cbe5ebedc77139d501b3ad86d2dd817e29ef2d8d403ef67f4ec76ee08bdfade0286de4050ca6f81ab08651c1fd609c28a7984aa8c971d23d31cdb1d160f47e91ab6014528fdb58c3016cf72d3bff406190b5581e750ee4b42168427444868bcfb2bb1c2baa685bf6e0c7323a3f44bdf560e9f740d333c3a7bd0e2cd7a14568c6e273f9dac3b10d2083a6341fd665c927bf8494f9e2b91458a0beaa16c089159c6fbe5e39f3864cf69defc0a5177104f0fb6df7b1f9f5b291d6b94f4f3c4406d8bb2c4d1432de82d1fc84489db9659c402c83d27ed6f949106c21c199dde512cf67eaf838cfa991ddaf903fd0e8c40cf6de094167315dc748882c410d3a9fdfa784d2fe91b5307f75efd163a18ff0656d578e8624e08730afe56f3b448b7cdfb1c7b58edc82bbf04d473b2d3d3d1151e3cd87abbb384f0f1cf0420e73e2fd2a700b325200af144ec8e86219fa41482073fc4749a52c03862ae230e75abb8b3643a9aab78cda132f959ebd7480bbb61d1df0170366729597ea82badb1688401d9abd17399d2060afb62f7cc2fe09aa5977c9f25e3d8931d026571bc68959b8e59a7a2bcf0b10526707c90b8676195cb4fd703bd538ff5826043024c06543f3e24953059a37d307d8711ec292ca5199148065ae043f75c52454afa8b58baa7849cf3a96fd1bd1987bf797793485e787c3d6ccd7a7c9c2aff5b8da46203a31f4306769738b099bb99eb241b7c713abdb3fc9d957df940fbfa7325ccb18dc8d03f4619c474a3fa8b9990f6fc852644daec5cfccbd86a08218da1c6172b640b88ce14b2a6058ed6f6d6169781995d5d7cfabc1b06189c7d377688ebebb72c4815015577e02a0ecfd675f4da0dff5c2b217c61c16b7eec3de52613538cd3465ba09b8fb7bf336e83a810038220ef6e57174ad5980866534377c7a9cd986c483dedcb9dc45ad13ebb1c7ac3d199d5aab1d1891173aa43e2c4bc5dce3d5e41219ec5e773765572421e997c46c74ffda0617b823a2ad1c9e8599945f69fd52b1e1a53083e3da227a9da194c566788e4f6a9e1e8ded99352af3f91f636ce3a8345e3932ceeebc31956bb9e5cc4538813802869efefd5d18c515c4d90d0accca69180efdeda974b4c80d8302540b5f524d1f6401763d6e6aa566edf0600e55b36852e9f1bbff2dae9cf3431b7c287cb5f7a33928b73e43d0265b2239df63eed7a04334d94586c4e9b817e928c9820265d94d21b5dbcf807aed3d761689619e24e07ffa40cb1dc99015bcc7f96921c8e0f3ca5cedea56bac40f3e8f8bb862196fb9e6854b96d0a5100d9ecf97efb584e422217fff208ed54634f245d204bc96d1ff35e9408b0fcf066bda2163d7791e19972df4275de1b08e990e20c2708e321730e990671353eb11e6f606e727417b179ecfe0ef9482a4f08520cc078ca5412f0ef4e2cb56783251cbb1324e22933e520f4d4906f66c61a2b79ea9d2e93d4de58ff68badb86753e4b19538ee4aeeaba2c419d33c6ed64875e9e535cf04d66465c37ac3ed9924092c0a0a2aa68427dc63e72432e73b9329a405c74252217ff0dc0526a4aeae11845ad6d2c7c6c393573ab8bc0006a307855dc20867e864f4a5603b5ccf031d7e95155a174df7e21b436c3d621edb1db7f819b0e2e29444a590ccc3a2f12bdc3c712863ac89f67007159c33ea96295d4ec30957c9fe776f295cd0fc18e0d1c4a31eaed37a9f5b51f4593246c7dbe7e9a68ebf0380700ff11cd6dc120d1a978933d762db5ee860ee3d30da3933905e16d4fa67a8436568ca41b50a10560a5041623c9781a0aa366f3f38e382d7ded5c0f1515001dde0ff5a139952debed628511935d2f934a89cdc3c5b22d6fa7b97bc3169083854a715602c8bd1256c6307c2c62723b78590bb6d67f8301866ae7f6714dfcb9239b856afd200e4775b8ba4269416cf640ce2fb236aa6d1c1c8dfcc567e4b43917928e8cfc00412e810722a69cdddd376c838e7b911c3ade148373ffb3fb73c1c2981cd51a294186ce254977d053209071805a22d148e4a840d53a9e117e15956b9bf5d72b453fe78ca81c4b4a7fbc6f21600c17ee52f25122c4d872262ba6ef93f56e63dda047dea8843bd70119d2dafd025f463429495f8c8396646dd79941f4115654d8cd2cde3b29a2c87761f8eff6858600763054b3d6353f301de1fc58acf6f32a9cf5acd63191f2e1bd8231992a979f9932e462ad58b47ea64800e41d896e0839eab2a33767353f037efdb94dcd2d7a2e63dd8fe8d0b42526bf7f8c53ce39809fb9bd8a49e739cd70c5f4738fd36f1167a96e09a04b253c4694909df5d8780a3f06cfb4616e761e25da5368bc5a3ff565aebece8e3547a20dae1b79858055c292654f5cf0c931300c180f77b3cf06b7e8ea32e9e4cd11cc1d72f1fdc0c5c7db7fdf8bce437d8c84f6ef238117b92487cb0e5a18ea32e7744b2c07619ea72afa045b63b99bb754f5781745e2e563d4976cfeeac33277a3b2301a681f8670a4830272cc0ce67489a8f73d8aad05250be8ed886a8b83b925b7c223751e49b82eac8fcde46390cc844bde79b8fabe6a545812ae5ac2c234485bd3e44a55f1207c00302aeb27efe13fe5fda29e3ec9099aa87ca12b66a30d47abd415e70492765b7e899732a4b70dd031a51b62d7b141a43aa558f6419054581ffc7b624d45edf33703f5e95be0bbcff860e1040f96c899409a973cd9799dd7c2d7b3b43acb831cc0cf5f87ca0d402752de1abcf375745ada3bfa579e7db0e364a47efb0b6f7bd1d6f24e8510436a227552e72f40172f9fb2bf9afd09a747b93ef5e3bb75a89cc20e97914d93120b64dcf48313f26fab5f453909d42de22668f18a479ab49a985e166dfee00fc331acb63fe8922ccdc8bfef0a2ce928963ebcbb6c6292ad49b84f5ee024117976772244b6bf828d0e1e983396a20c7025a565c425a1ecf2dfd500e874f7310655e6fbc31c577caaa8b289b60e8a79f5efa353b9234bf341c0cf494683ac143f01989a842b0de99e7ade0d7043fc1aa2fec0811ddcfa497d0a5b57f33f2c6121105f417ba1bbad64d6d690c7eb37af821c07995d8ec07b316c3a9ec53c542c3afc83988f072bf74e6dceeec0df10f4c128a40bc07c79a2ed3e8f706c209f44e1ce8e253e56755c847dce9414a8c92f80b7e20ce5714b4eb6cd443807049a0f4b62a22a10d799ee39d3c726771f0d3abfe559d1bf5eab09dd4486970e7aaf1f2de421d51b950e850f634a7d8ae6470eb298a99bdbfc42faaa454b65ecb4660eef6efb6cfe81cbe92a5459bd5c8dd7cb567416e502bdc7b850e4f2294c70f50f8ce4ce09547697cc555dea0e34020a9d129835064ad86409d41e430fbb5116fa6b83b6702fd87a02a4b3f1a1f901ca10883d79f1473bb7cdeb501991951015fb814d95ba7996ea2c75c04357afc3bc4c310bcbd6692292dcee758db470258b574bad0e0e336ecaf18e86f6a1300aebf81a9db9cf3a5fae0dbd39763b23f9682f510076e21564665ada8e4be94b86f01487a1c37000dc2e93860c770a6306ea5bfb3b854618e8aa7be35eee64808af52da01bb1e1604d61169e607ebcc55540c8665277c21f2be0d511f68360082eec70c39972a12dcd0227899f8e8bf92cb3b19a7e9e9611a3388fc29c28a4e41d3bf0533d9d8d35d9ad2bc8f93e682fd57075f84d48918d5e66053359248d00e1c1ab620e2aff3621da5d40a5c95042c0462a301b84eedff4bcc03974b31e9e69748f76158169f1b26a62cc4550a5d7f8c0f7b2170966b6a81359b1ad7d3caf1cd5918fe41b053fae8dc04fdd0edf3f300d4a109b9839a6354f108ff59ba1263ee20b1d1925c18aa9ebbc7daa0ca3c007a580412ea6b1868986f355eb26256403c7eb8b2577d8a010ee56842d3d129002d093dccb12be3ca5b2e648390192ee41fc99cfb34d0bc43ab5a37d5517cf014bb7f33a38da023bc5c2ac3a769f015b629c16cadb051c0529da62923be7e561c3de349b8ba22f0506f3a371ce1e1e8c0d8193cff75e3d8f01484b1594c4332b8e71da51334fd96c7d13ade206a41af34aebf74c873c47bc63e929e186d49428406c2737315f388251de9248670d203c9a739ef7999749358e81e3f3d904c9764eec9a3e5365ef08a869697b16404559853930176a56ed520f0396de36b23cd25f06b7d2814d3e99ca8463325472ec1044316157072a41540c97c0bca6ad74cbc073fb0259287df111e10ddc580c272014a3cce84a72781895df2f806f91b9f3c489f8c4817bf1889831f9fda40a463000125f40f4ca27d6e347d5c28833476b1fec3bb52bdc78685fbb4291cd6a1aa0254557e38026dae751374b99ea5ada14a9a5342520fa504092182df3ef523e7824233e90354507fbd29a38cbf386ab7aef1e53c5abd4e0cb41d196f4d5bb24cade4eeaca9689f5d9145b21535a94cc2b91041ebbfc76b680ce00fbc48cd4c3c9297403a2e262b34b7227ddb456b6878a19bd444f1ce109fb9f1e1d467496d84eba7619c346a77a3ade839fcbe52ade6f6471385b570185c821abf89ee0cc11af7ea9eaee44cb2b6c2f4a924cf39b42864fd0637988204fab672a85de9af0a48356d087ee571c281003fe4aeb613e594d59384cdd25d8689004af7cbac4db690696eb0a1dca05f1342fd8de2d5c5286ff4f0ec82cb6186ce05548f36ee0fb72d2fd2474c84da7d4d3f3be409d50d898a2c532fd22424eafa06e1ff06ca927916573ddc407abb043f38e8073226039a53db3bd9f039886a6348e58a07820e8008b92d7a742ff50430425fc363585cc6a92337b49f61e3e12d4ed364496e4dc1a218f3dc083e9fafeeb58cc7bf4390c4794fb3971e7572a676441ef3c74c53204d1e2217861502b755e8973f084a824ac8a2e26b7096022db15a4fe3e601b377d04438f120f3ac45190ec3bbb1a72a91d4489a0c001baed847949b13066d2bdff2ad8f00fbc0d87402b841d970a96021976d0a1e07f1569e296c504e67d5d8e66ea141911d7ab872bc6621870e1094b88eb2c3d0459f6e6bc8e529140207e0d2bebc482e3ae46d9e734132be1489c9eff9f77e960ad50480054bab5598cb23463b83d1a956a8dac0e480001e5b9b5a5c93b3ac8a6761d014f50247f66e49b01b4e76a41dfb948456cc107103ab86dd0fe9dd6c464e695b99e2d435e3094b72330e0d99a2af2ae05ad5ee6d80dcf4c6e3ef19572084f13325b284262a7ef40b21b2dc9f13afb0429d95c31463d86d27e1486b5032928a379bd84b738838888d92bfb22d3f030279594883ac301cc3cec1d0ebcdcd8e943977251a7b69a7f45716452c59d4376cdd67086aeebacc7780bf6a776a1b7fd9d8688a3b284bc89a5bee02de7634ab643144369c2cadc6c437547d4ec33f71dd355ec95aa2134fdd547616a70fad521d8a183ba55e7bc83a083817ae2f8c5949a5798d8bac01f903324cca68bbcc62604c22b477003248923fd9b30ba01dbfd0fca50c32d5eb152b2ea7d178dfe6dc99bc757f2ba38c0e8b77cf212aa04f83491820a068e83f17d035200e0bff0d3654a8c9055aa232dfecd26a02eba1468ec96ea2fe3152af9783670f32f1562dccc4e5a84b10222db81328308d81e83aa1d9693be22f6701910c892cc65dc41d6973a7143d28fef59edf4dcf0e6e996c075b13abebb0dbec4806fac70897110af6cfe3eda79f9fb638280c09fd0915bb2edcfcf6112fd2341bfc648670d6196dd50c34a7f7b615789e409ff7d8692c1d41cf9f1448115705d2d7682c477463f6bae956b80d7f29cd839ff89f4486bcf6b2bed5ae39576efa04861473d565bc0109eefb2c25091a21a37a5057f42db99c1ff90f4bcad18c26113d388a04d3769e403f67afe37b5870d8ed95bfdb2d1c91e2d5d447bb182495aa6c0e193c67bb067a7de0418bd349f4f07e53c57406d3762712d1ede5f19f2849052376ab1ee0019fbf15b802e86557f8b3b5ef93d065a467e6320e95a0246593116d2c1f87dbe867390663f0862fe4a5ce82f4c0d6c1fbf12e32793b311f89446700aeab5160c10842bdb13ed2b63daae8d4a1a16f3ec43cb2a7a72a0e07effb5adb5ffd106b6ef290d160c9c71dfa1d7ea82667c713e0ace7288e599bce56df15a3a264179dde92056c2b954d645321763339b8400c67d2b4f8185c85707507908b352a1d6ef3065e981c5245b1457e581f11b79857a99e674edad42430d7559ed0a248d6f57d3239f48ff1452eaf735fad018035f2930ddfe2bff80c29a166c0d447e1a4c931a856c0244259b3f2c79445dc064cf65466851d8a29c704a778521fcfd6336883c394cabaf7afa007d46b43986731cbd66f35feaaed629edf0d9b99e4005372e094c9d33c214511dd81e03e218c87ede2db20bdf9b9418cc2037b084a01a8d13f3ba487b90cfb4bbbbf27934a68683c6556a211ca2c129fc4d5c6f7d6c5105d92bf5e1c9053ebc9788717665e96d9cb77241fbbefd3215398febed2136af323b22439e08e08222a8d6f4b8e330f2fbb7f773f4b025b8beb71871a3de49480a1b7e2cb1c801f31c802e8b839eeb095ef4e1f8bf35e29fad3549ebc0becc1d306de28af6db6d27b62995786ce6f838286d9e4300ef7215bae617ac9c5d4951513ac1106d39ec57cff7b022e5ac160be96ba9682c936c6a650db5014b38e87bbb92d9f94795b9174cc29f7c21a3f63fd8e46e924327c485f41fae95ce01db3d9bbbcc5948f2717f704ac56717a75bde03adb6caa766859d2e7edd8e208dedd23d680d076d12b7d1e8fb0605d134b277913d7e899ca1c847b1cf2569d1cd09b5aa16480ef7c4d3a78c1b9cd46a2e33971f5d2aaaea0d1d772734f62e7757ab2c2b4f53227f08ac8af0ab87795ef78052565fb930c0bf57e0cd1f417d03f5ca4f1c727c28844829030934fa16ad0e298b3dfbe8dc6044a926fc5de9db84d0a568662052afd48d2a3baf82c552ee5361f8814e1d42caba3176fd5c99b0e206b496cc314d80e92545b1d1fca1ac3205dca412a3cad63c4894a388e4672da39f539f2870e8968bcaf7402ca06bb91f5f9df653c5415765ec0cdc70b80cfdfbc405a0d3ab3db50c8383abc98c4793031482097a43c18c79f31629f7c15db7d1ed0df9caf12bdcbbab01d00d6e8f5c6cc18aa32a46fe2c8d6214cba148d54fc1c385bed0446704b924bd1ada382b957d0a52a4701ecae62d4fcb1a5f40a109e81223f7d0d49b03cd67fc57b42bcd2020162203c95c7ef22cf9b4a98c0b79b347f471723858157bf21425922ccc8e68026fc2d6a841255af8cb2e7a08f6d192644789067bb6e231f70032354406aab186b1acf4075b160272200b21aeb03e392255731e6049e1f0d0eed238d20b29b7462cf390388d1bba82b01ed764cf03ad0a0b1b7f6c7ea30deb036c428924446c29a354864c1ecf372801c7d41ac5bd7517f85cdfead25e043de99b11bb2b51155a54143a47ca3b10e2125817395092a2d5635890709255f8d117417d5bc50adb805d15a045cdd10404b29018c00fc397439987fcc8b58fcae11ccb59569b96f7f040196e0f499191c1d7552778db48c7b3dc816726e701b9f90d76e2cf267a5654335af06ed7f38789d46413015ddb2a67a1ecf26fc2bd2799df5359a14acc1d05f2336bd81ac5af2e81f44535c118fd55b7ff76eaa0252192ed817d83ae224a3835793d6b124a1cae9a9aad9af60f26b24972c6acae278d350cf32e76bd95167864f975972a4c58e4f74944ed37cdfec95590032a50dc0828c97261f104d946d6371eab56409d22b53778fc48493f704de218eb6d19d682152db936699b8dbdd8f987a0650868b42f58ba0f314a58e872ceb52c421cada01c553158139bcbb57c0e1f48b48836aae4a455e6cfa23c03da0d8ca2893e543305a7109e0588e3abd10c983fc7b5bb920bb1b80d8887c961ecf53db76f525be5da0ef907a2b1e0861b97177a7a4ba58fcecaa10bdca730e3d3c13dc93e7fcee79d925aa2c139303a16a38d7bd0b40a5ef3c9828a2c95d5f06cdaf8c1651bd80fb89625d73942ce27edf4a54ecc36912fff1f24b04488e5a392194295a8d10e8947bc31301b7520c6015a1e7b227611d545b89339dedf9917911d619b1fa350fe8079a3b98246b85b0136598da7b608ee0ee78e8b924190bbaac6eb7c50d65d75ca9cd4d79e5024cb45b57d989fd62350aaf792c30ce47ce4120b7ce307d2561a931971f550ff1287399a77a43568704f84e85c24c1e95ca262a7cb21fbbd93b396bfa6cc0e0f70ae476dfbb88ab19b65060d1deda300a9be9b928ecd47fc4846c025be0cd4f02e40a36b31ee516aeb1b0d3508ec5f98788ad762f7f312dc69c12a34a26755612039bf72eb30ba59e070847111b593c1d196b2e05cb49fbe8e4ef0c968e8f149c9c71d440bccbf52ea645e66794aa3fdd854273f0ad4f2c9c91a5f217d7c3238db33bc4d327c7f28fa13890b9e746ca42cf415a863949870b89bbaa8f1e168f2180e4b0985306e81a53df9312353da42e2e18c4574c5ef7c6b15d2c4cd87f3b76d3b92fa857446bc60b5e25e6057edc65841d89f03d96a962166c60236b95e6470a5f0f2d2c72d3c0609510d58dfe32a1101a6de692bea5a5e553de6d8d313d0392e3d36dbaf2f95b4c3342d4929d78992df426f36359bd9ec4c1caed849e1a9b129ee111403526274971590601d6c692095a9535788fd60e29696126be4841b47b6fad8e8618258c75eab2637ab8a52ea327cd1cdfbdec95c02ab4201b43831792925501899333be7407d5da3cc56b29cf284647f9aeadb38e509e86c24e9c9db10222e5483f8e69886f1f03162a9ee38c00b664247b182f46064db197e8b5d72259225d682b88ffb179a90742571ef65663c797b89acf930c60361b3caf170d25d47f89d78b451401028c21a862ac9b0a15e5e5ebbce02fc94940aaed338d23050685f53bd1350689b93030f840c76e200affc6dbbd4b677624fec4e3d0deda38bd0af09df729183c80060eb158d239c7c0d64a4026dd767ae59a5a74647a03c108a9b84ca2c79288bbc795fa091c5095ed2721877709ae02d6fbdf314ef6fb6473178c5f638d330cc5f54f7ad06325a1dd0cfe1e3ddb6551de5fa88b4c058f241324193febf0b6bd08981fbbc8de93bf53a249f02819d1d6bb58941ddfa24d38257a8a16041b428131b0a1816aca9f7e580664f53d95eaedfa6ea30b600bd6009b03ca705301673be87c6fe298784877c8b66c654025ed1c3879d2c42bb937b31667e9f15d0f3adbb5eec0dff9a1cc0141313ab5760ff375afd6f8ac4a369cf63b374d8148af53c0ba7766875eacb29829d13e1e55c66ed5d06f58f822bb5ea106b215c8c2e363df58ba4afc9e35b32fb0446014253b57f55b29d8a9cdeb8595821dbc4b44a1011cf054a980e72dd16833286690297cca161c21913b4a42ab4dc4851e355bb7e0f45eade7952ca1b2fb241f1f6b5f53e70586720c9cae5aae28461d112c309706d9a3fb76d098e1916e9b98f5076423c7792776f332d1175d6e915a53fb0c1cc96469bda2ea657d95fe9e836992e9620cd01a76a3d1341ecf6fd06277f0c2b32ff89216c7097d3991e4acacfb12afb3e072dcaf8e5151692f74c08837dfcec4cce70cd43435811b99ed63d75ca65adb2770ddfff72b019c4aa61daa155d975b17c65f036b61821601016e407d7f863bbd9e927e392da3e971b13e86e62c220dcaa6d34f53bb1bce35a797889f7ca2d11c19f7d0b5b78d5ad1504bd98793b925bc3256a3840781e76d992ce11cf03bca478d86a9f7e58b2f72c94ab5602e58883f603a544544aa4105948fb7ffc46ee9da7e39e2d1e205f18b6e01ce49a36d6965c55c6a8b345decf8057daf5a5a97726bf3de6ae718766fef654c8714064bd51ac267b64ad9436ffe1c92b66b61ab9522b385f3443115940faa8968a68b97007eda375dada9237151b319d031b1c4fe81a55b4db785e9e013cbfdcb910ee0b2a16b44f282b50a03a6080fc438a3cb3c6b6fefd8f135de0e73fa16d12cf0b2cf175d6ec50d4f2bb78ae43901cf449723e7972ba22abc538f8a8ae931e8b57c3573755a270f3afdcab0ea14cc611c26dc892861504c6e7533a147b91ee62cfd237744f07f677ec5a9d75c332471e76e2d280ef1c3b30e3792805c011fb148faeff568817638a4415a731197825809d2d8fc8b25665a99db5b2fd0f78bc15fbf0648a009a0490fe445ba8032c6ba45c40d10578f9755b1dcef955ac53084520ea92af9a89864056dc67d658be8f7d133297833a664f991d8ce773335f011c06beceaba6fe09d24642c75877251535879a2043ad95fbc6b8f2d1d2120548ffe95f73d6f4880aaeedf0365f5a741b4982e8b0c1b31f64f581c61edb876d0810f6b65929b5e933ec04c0cf51fcb90da33898bbc25ee4367d1f781d370cd160cc10aed8f72ad6efaecbd0f7849b6a3082a114da35842e8e96e00f30f90ce32ec56d970f36e2513b72914513481443db920df6625d9738dc8a188904edb74bf4265e4a99510983a47ca8b4ed6eb85ad37d003caf31c47d0bede66fc0d469f109a4d8d9a22f3d322965b0681de300bc99522ae4d185eb48a87ae33ab94d66b54ce529a5d9e9ef59eae75ffbbbb51e6fc091362563e17af8de2c8cd982b110774897d7995b202c9113f2b649e7278a672905f84771cf8d1a082cabfc711137381ef50563f99ae718614adb5b361279f19fed2e3dcc203d761960eabbe65037dac5ad57cd5311521af795f85c32cc03a7aada81f31a6ed858553001d7b32778990f3e490b3f5eb2ae0473e9d4b0bee940d0969ec4610911c62d079ff906fd3ca71a09586ed5dd103ce452483299ad80116558c33363a90b2d2f3570b14e602c7a4d812b8730397c4261ef4024601039a62bde0b33fe09c209837226cdc5f57dca14da0f7e290084daf1aaa16f8fd2eecd7e562e1cd33d979b87b38b30709f8f813499db350ee764fab83f3ec5c73d65cfcd2d49ef9b1ad70b81e6ed9f11bd5ff796b82486201b5f2147214405b4ca3a33f1ab94cb09230e0c6a8f3e87110300e62b0760830797e83c77627d8c21a312b34bc3a82d6d0cd958b6afdcc20078c0139a7cf9be48593bcb8b2399a7172aa91afd23bcd6a540893a7627ab1c8de3cd6443cf5a40aabc531327ba73eee493b27da6e2bad4a2fcbba5018","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
