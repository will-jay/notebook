<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e22909e0fc998cea0ac818260ab33773b65346d21f2ad7a149b82bc416a7e79480d8cc39a9c055cb4ab1648e422aec6519a06e928c1950d1ec4c9eeaa5b4dec265dbb54dce37de774e4bbbd0ca4d77d8d70f9b765e501fadde12090b807530294154116d2fffe0990593c9df3b612c268b465166acebe973bda60baa4a20d4a1904c9172a990813b3d776377881baa3d4daa27bbf884b3644db8344c1f00fd39ca77d4f7d0d59a45d36cad612c6d96b3e51b6b5b4cfa062d3d833c117327daf936a7abe1f80048f05e6de42bf08a20cddd984e651f1b2587b7f8b1af5433fd5e3058abbd82f86ffaf5d3980e13feb11c97a1a8a705c863f784360b24b39316f26ccff2a7d6789edaef816ecb3cf4dcaae365d08bf63839792fb30c37d1934d02ed0533ffecfe3fa31aa54647f6ebe2f77003377c556dd30b69241adde82054a4752a8735198bb2f735e91d561c82416c69f664d9f6dde76eef912895e750d99bf974fd7e778e693345fcda239b432e33bd7a76308ab7a7b685657cba58faeda76167d7385026fb7df6d6d44995320f2fef17d7ac40da32db300ba0f47a4d54974b0b96e84709bddf7b0de7415ae2d631e213752f6beda055b2f6fe0330cbea6a089442895e0d6e7aac3c38a0d84c333c3013bbdb74fd8da060c90e971f321d084159a03110433988a51dd8b4d6569fbc7b583db940f3d96720749acb3ea843bcb3a9fe6e12f8a94c5e3056610d32ec9ba84fdb681a7d6825fb477b9388536182d79573c9f490bb743d992457678aa7a22da8f6f01137c61b477a0d04e648424dc411de9ccdb860b0e611579d2529cad12950d1bf76f9e6b01a7682ebcbaf90db80961b48f46edeb73cf98cb1e4a5461ded4ce24ee266ec30481b11d1a32b7522d170811de5d55a5fab9b3f0a914858f6ed3dd23a0423b035d261292f7c41ce689fd129ff50db8a8074c25e240a0ed731daa9523210e7a065552ac485bd26dc6609e76791b961826e4b34e0eba66f5cff924df9f437aa5e6a16181a5db680ef1cad8208969aaeacfe7b7ecfa87ae49124ef27a93caa01ce654f91ed4b932912b7b1edf2210bab46c06cab208ac7d7c64f4307b35e37d928b107b25bd8bb597e380c6449fae08eff2538210a8ab97a5f565a2f347713edf37243ae14a06b2c208ec20d2540c9baff1bad7552b98372f208e817e0b0244d9d0f6a763a2e4fb462962011cec061178023e8f1522f87c286da68ea9481966d969dddbffb0572b531d55b6f15af1df89736e46b620821fd4deb47fb907cafc298257a49ceae101624fd2c2cc6c0d3f926c7f3272ee3a526be0c83bc5a76b9d28d234b88aa5a379aab184b08b4883d2d1d54eb296be01a1930819c658340bba27a160ec61632323982928f2a7d9dd1c27ce7b1e4d8d427ae05720be6725e0dc450cf632cca26256e893e97ee7e246be84d0f6ce51e27a88f4e2a058bdfadb74cfcfff30e10dd07a5a049ea7640f6c292b6c1359e181476dcef2a22180fbd0b9f28c8a756c5216b9b0c25b70a498a75fd3aeb3e87d20beec641f39f99a5a8c325bd02f4938766ca89549580cfa02c5303320fe0972f07654b9086a20ccc3dc5ac43aa5804daa01a1abd476c446d7a14c6d1dbbbd84c4e540242233abdfdce8b6b6762ecdf465dd4f9fec0b7b46933f23fc3064d6db8c6e930fdc4821dcbae20592984d4314d60c2f4e7d9867c672230b5eba8d70d43d8f9b9ef3e3f878b2d54e7e769fb8bec92740e1574240339e2c08961f08bd2c28e8779a05e563b8afac66b90a6e2867aa46b05f73b493fbb24c174163a96c5f8410d1d46cc46bf54a56cd176d4447e013bca14c0149cdfdf7bff4f0663bacd4a037ad6f077e4935f9ed159748f8b5881582c3d1c8eb1772eee4324231f303776f0593aecbfa5655e4ae85b04ac09d97a04ff0e8a7600b035a7f9faf765d26f29031ceeae30b525fbfbc093743bd87ac5d310dd9ae388dc9c8a2d103790dcf53e40a2cc083440a35eafba41906728407165b6ad819719facdd17585ea4fc381c90ec1ce59d78339866d258759ae27368aae551bf5d4dd333b8814d78bdc9d655f5152b6aa6a5e6448d5c35d08a4267a0a2a43234ca9ca7e3c577ecdc77dca556265991d797848cffd8741ae23f3ea7e4d8aa21ebd63544273361607a94fd48bfd63d57d73742e02885b5a2a504d97695d084d83ae1d5301060be484041cf65f90256885da2b47a1596c2c0de2691478a9e5ae2b67809a82a1d3f68beb0f35da425e46fcf9a2a78882013289f17777ce522075b6a9694ce9dc8aeb8dfac4ece5122eeff7eff599c25df552376147e7d309f4a7d4b2d7671689a4bbdce2cbd47f5fc27b1f5a0c53ff078a8ad36722f2567eee3958bb1cd1c31fa25da98f4bfd82af95598d64c629a91ddd816042f5bd8c8b5e3eae8f1676e1a33dcea37b1ad88f756e8ec6e09ccfdb442c1bb1df7f3c260f332a8c76108e8bfb711bba8ba23203049bcddc4efbdd14af66cb3c0e95de52c781e82cce0f0449e84ac6014ee2ba59910ad34e96c2a91ba5fdfe8e63a7e922b38bb028e7d3ffff13a19bd1382baf2975ee2dbe52d65645c75e81d699c27b3273235770ea5dcc821c8634e92a947d58604657c868f54aa3c6a1d2be45fbd9ea4aeff4e8d337a90c1cae994d23d7c7ab704eb9cc0261b70acc82d20e62a72f04faff6e4d62e04bbf78f944c94e593e458f8aca99d3891026282a486a8b0d0b4fe496c95c289090908b886a299de2c5f8152283138f9c3e189a9311ada0f6f055f547a8e977b0d3e683d77df7ebf20b4f626b0f7b94c2c5f3344801e2f6828af39e7e09d31e6f8d00f532e16c8e55b3152646d5f11556ecc623a300617d6644a87e01873213dee3076733c923308ed4ccaa26e389b5fb30f213d33170c91c492b83ef2965d2669a345026929601e771ec9c6eef8c3ed4c2edb34e6f8ea45819680197d5938794aecdc2e8780a0fbbb9f5e608dbbfdf6e51aee4664a480acc04b5066ad1c07c1d07afe82362ab0c3f4c567b0f6c75812dcb06efe858e318b31ab872b4aec584431746def8d4c1980d1fbe534a4366a12405a2e6fdcdf14f304d32375f9d6499bf353e077bc3772f77114d2985320c614caacd3a619dd2beb25596bec1e5db3b87fd3e36f48a5816ee4f25a019923d94a2a1b57821f31970edf12707fd4c5b0fca02933bd67046d31da9eff55cc44c222931303b695d72674ca22297e92f3a4f99aaad6170f95879bae17141d4652e57c9869b287135d0a21c704cd534f7b3f510f778180b3778416d654ffca401d59ee7fb0091a10dcb2eaf06367f3316b614ba2bb44f177bdb1c295b89826973ba15ba2dca2207d3c02049f51ddc92af651e2fbf1fd8989cbb72bab7145513b596be7d18683e7eb870ae8603063ff80fcce2176a999238c4cef7f2c41605a8dc06ad2a472c059602120cc9e2bc0854714957d2653664be9b3f3c1a6296fa672028b6c1178b3ddcbe5ca6382242f2544b465263a7df4e451885d65f02c0935848d17be8fa8d15500ab6cb098183c0762980e4e585427152b8578295948496f471b77f1262f07958e1744baea53616b081d9ac4aee58d36157249b70f8d07088fe4dc38a0131d0f6c13b79f8a2ef2546a3a7687f741f45413b9b96138dd4657b02d08e1c33407dcc65946dbb908375f9764d1699766c5dcb301480a0d48873bb05a6e29c93def255345b8fcb5d1876405aa395d9bf1d386d4e7fcefbd72b2f89aafb4259b031574f4a8320068e47ad6a7ce12aa22a89180e2bd1a22523346feb6afa9c486ffc5f41597431335f042844b8b21919214a20ec7080932916a28947a814f2429457b32707361dd7c5e0db5e777426b9d5cb64b58d8cd248e57a7d6880329343ba7cf80a8b482aef4bc840172b372bf85d9e397f5f359823fae71e2fc496da67d59c4c15cbb8ff1d43fa85eee9dfe887a895a845532e85eb6f125b3659c86f3b0ba34f59dc290744002026b79feb868571e19c66b2e42baadef25ddbaedd69903b2769f8a58111fe6d6484ce11b334dda7cdcf7fa4a9fda2cb7656687959b1169c05ea69b9a98d0e861f5d7987663c6716654decd17c83b97336cb4350db21f294284b1b7de019423372cc384bfc821a4a1fbc401b32fc628ba10d09fec9d1ea588f651ee6f91cb2f3ef15c210b9d16837d190185af804b72cd7f171077bf7b29165dc7d7ec85b31e9042424cbd9b4418af53d0f9b56170606b5b6b179b9230427299499b756c0776bfb48cfd2034b305d508f138a947f58d9b503f880274a081340b36612de0a8982cb8171368da68effd7927041c2d76e426ec605f99373834fbe4a06503dc074ec824bc2524234993942fbc5530820c600c8bf824a486d076b53229a0d57241dc713d621837ce34150c8ffccc8b5596d5ed56e6526a9f95301d35eb8baa4042c714336ab6b3af64e9c3736f90505fe26ac406d0737f1a6795c79156c93d27d70028154df375200fa17d329817fe261f48957b870e444a67c926ec58c60dfd04dec6605fe5f5d0849c845fb5bb9c89604769570c6a490e56786a0a8c89b2013f6b73a175e7cb33bf279ede711b54568c33eed0d0b2fcc0e5c56040efc579eaf1c35f1f851570620791998b22d587f8d2cef9f2095f02de503eff13a7cc267a04423e36c2dd1d3c9bfc757c8db12f101be652dcce0bfe7b0081cf28a9c911e02fa2b59e3435dd1e41319789e7224a86d8dd8f5ffb7790a873d35cac2abbb4eb566ed97c60eb647e9b7c42d9e2115e2bae848e6ac07c72ca435215a4309c10e4bde95c7e454cc63c15dce67b6afd8353888d22e60fc7c8fb7b6bf0925bfa781bf752b99e360630ddaf2811be2669a20608e74bc84e058ca268c811de36bb00a4c825b3db9b2956561978927bab18e88dafee9ef67c0592c408dbc531e5d6c682d9690cb6245cd55ee7bd5b16e7945665b1b6e4123775799f305a1c491429a536681aeca1d3ba32a34f8f937b19172c99cf95c6310b36876966fb8cea21c641bd71be260ef90723554def776b88426dfe56b44e07e8f6a9bcf456dcfe57805dcd12cac6a2968373ab2a3dbe645c1ce6e56c0487402a4140215d030c381ebb388f2a8d0015bcb113c183f2ad8d693f60c62eccb95d911407e44ad99ca5fbee37990ab45245926831e45744d862fc1efb9d5a14927a8651254f3eda03e73b86a9ba05e7ae0c8f396de4167e4b81285a0a212a0bba2f5d7fc4d601e0d3c5598215a20ecab149831e6726aa6e252f29ea0452ef658ef2a4189e7e8bbe757bd701432d49bd6bebee7b9271833cc8254f9ffb9c53270eb6e759126468a432bf6265899779b2aa1b2fb33993c3385a8f80052dabcafa0534075cf7f3b5f3c9542662551933cb55ddac812672300862529158192a69302497ebd12341ffc68aac2fe8922e750192ea68cfc8279c9ae3d80c2ace382a88f46ea3cff8c3e195742ef5140ad2d240accef4f7e497b16705fa165220cfa204f756705d022d374eda7d44b38ce321cb593fb71b68bcbb89ac94dd5493d2d29711a5d3a59b9aafec5d3d43b4f0804128986c97067192d60fe5a8f597b2856b3d82abc51586f7e8d4d1df49b00c8291e3817301bf155fd04a6dc3251bf858165fc6450c5ae67399a8763936a75c53ddd8dda824bf3b2393fe2d348c3030ae0f60bb668cd1beca637babe041ec472d3a2dcbf6c8113d5353876925e3512e441280f84283ea3d907d772d46c2a7b3ef080bf8c51c94d9918031173ba241a2e479a3056694133c6b1b870e9b538080f0ea2f2f0fcb65018c1ed836df51d1dcfc28b339800ef3a114a634e86cd7c98ec1321805b0b7a71c27c384a79659eea1910d989b1150375b2a232c6c60b4b7de89332ff78f345b4b4e392baeb9b06c06f59521f558ce7fea34f9e9118ff1edb8ad0f251073499cccc9e887265838299a5cbb94e585c9ca21243d8c3dca3098816c218b2ce758a927853c6d976acc88ed5f5d02861c61b70ea96ec59f18abca431700102630b7dc1ab86bb4ecc8b766a062f159627a2f13dd18a26010b9f03db6031893eb4173897ee4e9d361b4f60b8f050531d91193394f1eef0b41591ecd270fc859873deaae993f67e392ff5ee2e9a2cc091ef49ccd4d49e7ab2acb7d18357af9fc04e39b8e5f3f3375e44960822fcad7e5c13c20e691164af2674a981cb8b96448f603533926beccb751f1879d7922240497aa70dbf6307d2653f86486eab558ee4fa2ec85f71e1ad6e955c68cfdebcb6e00526eb3a85d0a8f9b38318a919a1dabdcb3fc938b904bd9106e3553d74bf09da24b196e32a6b55734ec45f9eef87146e8a05e91e2eae40469298eed2697baabcddd1f7fa3c57faee3b75dd983658d881a7b1dff20d90d6eac7c8799cfcbcbb49ae7d2e71af7799cc5dad14a86cbaf4a653b8decc9748ca120d22314753d579c3fe4304a1201edf72374c8df41fbdf81932e7d7f1faf4549f3cd5e4ac483edbec62279ac69f9bd8aff16117b612b494cf0f6431a902fcfa1bf65748550c69de9c675d4c32c287d30186b6153a291632ede9b985bfc2400984c2c557a22ff27b0e567a1b387c5ed449fa44c9f70e9ef18460d8e69cd175a8621f95929ad95b635b98b937123d7e46ca4548531d8eecafd108f40b1fd28d37e6c96b4f9bee368743396317c47b7446994a7eb1d5f8eba0f2d5659ba713f6f962050c7f66edccbf5c1480f979e675d45a73afb28a4e7ae701fc6211dfb8c4c231adc934de5e7557decdca3e833c629fa804cf6f8d7a642e6ceb30f3961343638cc77daf28c07025f6bceeebcf2523e99aaacda5f652443803087a4292be56156144183f3d4bcbf96a9ca555ef985dedc2a6b57494f04f9dc58a45dc2c496dc62a3339937a54d8602d5e11993ac71c8ba5621127068e9f75f61c328b8af1bdc6bf18d740515fa3382ba40f7fd1f8e5b5d6c1ede3dca3395c3200311028c26b06c759d55ca6515410ab0944f5d107d78a442e61de123001c3a575beba9d2d8f5886aec5a2534417beda1a7922439eaa54b2adc9b65da2e0c334dec3450dea7868231fec50401cc9aca4e7d4dba157db79a85e513ae3f20685f8602670a777e761b4780fc91252048c7a3cd61c8858037d473d0267cb1b37cbd7b685ea9a8024365bf9eb1e44d1846455caec360135c955376d8507608abfdcc6da72d64b2e6eaf2d02fb0672a30bdb6b37da2319843f9e9c2a749fa20fb8f08be3a4f9c770d861dde3b06b49ae58c7f72be29648febabefd60dc3eaac1222163006ae5efdb77b4f469c7dd63ba6a9d4ca775a1bcc125f831947b44096024887c4999876505865d91d23409572cba88e8961dd8314ae77fe7722de0e298741b139717c890b8b292e52c8887e63517f95acd7e6e93eb52122ca3556f8032763033288821192438bf271f6e4c51e17d03740f17aa449a6e4f72495efb31d43cfb096863bc1ebc6a8a755731f8ac42bd71c902ca8ab0feaafa2fbab0cea2e5d7afd120ba01e80da433b71b2cd84f672e0de916029dc0a3f0f4f4f2c288115fa86acf84543936ee2416f8d21d4d2f08f214761cad852fc2f24ed93d3fbd3568eddec59d14025c8a8cbd000c93a77dbfac70e5e1f69879f8ff4671a9e3a79fcfc729dc453fa5c4b8efe0e5591080605848d7b826107bcd06a7d4b2e3f96c0ec4d025f6f50b35e176976fcc708aca05f4d64de8d5f7b617fb9dbd0c9f1287e88e75bc57de14d176d75e3e1b5258612f90f1ad1d75b4dcfb15a165b10205917b3812732106ca3462f0fd3528d63ebc8f475627da599facbc5865ab8752941b1a004bea69d2a0ad5a3cc25e4e96a1add7274fecf13193feff5b3651d87088e531d8d190548c4623068e9cfdeae0f288cb284a4ede97e41e4c25c81c1266dd3e3343ceef289180ba61c1a407e44cfc1d0fa8ad3a899bbc86eb40bf0c3c3f8f311ed769dd81517abe9af4deb8c6a99c073079d8d7e5509e30ca8b38aae5efd6f7e2aea67c3b73d35d131553b4159ddc40156ac2672948c020faab289055b01806ccf2f925ffb9612ac2819602cf4fdad3a43c355ce0dffef54db3d64f5e634df1b59a5b4aaca7f369f976bf8087a8ec85907b6d08d9fe95117405241a7019003ccd948b5c2758507d8fe7d5e93e52eb56084b5a24c669826a3f943b56923d47b064304dd4c99a241545e32573a99701a6b6adf0e7ed48c0068f94fd2f7cb1a4e246e4522f901c1a907b50efb8302b6d9abf3353b564ea3f0dca44cbfffa8b97da89c396b5654cdf744e25bef1d32ef15282306b072cf1abd6c5a6998d640c59a68a3c10742a65518f937ac5f39b09d41321fe8684a2128697ebe9a7bc22ecfed7cf106b80f3c65661cda2dbe005d80049b57c7e349285749568a21362d44e7b3fa6e462d6268489899e22323d79195086d025b312a1729afdb86ecdaade2b1f828b02e88ef6046924518f6e6ddad893de98f9b65dfb81380dbe6a14ad293afdcf077832eae825dead8f495f178d1f005bc20fe8ac437b8680891eef00052a6252dca83f58c928fa479c801653df0860067560d07290c25a97924a35ae33493bb4326bf51e0567ae1222f82391be94d49ea55147656573f2ce8aa2aa1e697cde92b85aaa67ae6a89c25b3b2a62632553699b24459eba9f946e1bae0d449380684163e352be1a60a1cbf94b4152ffaffd76da749b10207b1fde8d8af1fe657eaf4836db60b42bfd63673856c6a98deb3012faf22610bdc8c81001ee7a96e3578ceac8cb5b1e5411371088df41e38f0167f675b638b0af376725b89157be120bd914c449ba110e7ba8e94c7f9fc092d0ae51bbdd52a0124ea3ec8fa799353ea89ea56df0bc21ecf02c3e44a2bed67a0bbb539e8011ea1ebd74bea4d0d2d5bd2b2b5d6c2fcbc94714f5d6c84ac7285790ab0cffffdbf07123435a8381e5a0aef10ad1d160d8bff83df282b637bea5660b2d72117bce3c4da1df2028a3bea71881064ec2bfcbbbc2253510f45fe0bce1f564b574e7cb63a27c6be6b76977424939cd98ccef71b5a5aad82a81b5a3b6286782d57cd335a45cbb6abfb546ae6b5adde276df25d918c09c4cb616935cb8fedfe8fad13d54d3d9570b7a26aafdef255c954deefddf7f791a03035735b5ad4067bf8a41aef9f1335c2451295c44f5edc2de31b130cd356e94204025400a03a86d84906867d67e71716fed3cce483a04f17235ebec27ac51a2c4d1bd1391fe1b620a11dc850ac0b64e25d65df6de1d84eb0fc78126aa4c4724b09f62d3af3ffeb3225048d572a0b1f2cdefc16505d59b91d4db2d3bdb52de65b1962a4180c7ed1fe24e25c673d0c1a5416c4cb3595301dc536efdd4ebb735002f5024606e61f00e679eef36780bfd9233ba81ac8c53172931ad6dff79b89a79501fa8372b20bd9eb77da7643e712dfa71cf82a0c72cd35deec33407303d63900b09825a6aa9d43ce451a0913fc39bfb6b0123db60891a75555704d247d39a4dd0a5aa0196e759ea3a49e08cb78c0f8d080cb7f6120ab36e7d816bf02c25edc8dccb266111a0486873b18669d92c72db25e98b058254618e243128b5b8ba47c6e1c19c1e7b7ebfd193c8ca59195d42379de4ef8fea6ce267d06c552c3ae33f537fd421f5f25e40cd0f8cc7c1cd623bfc81b279aef8738b137b411e4a913d6e946fe45b7afca4a030d2d8f8f573dd8c9a4e263588d5ce65cb32e0406d84a1a6301f1480b42700ce4943b1c106337bfa362cb50b8f97b4739c94b3cffc929fc4d6ed2f0d710f0c7b5e612e6ace9590c39c26be17d824d356da5c4d05d0c6ecd605bc44857a77813d5619ea289a86c827bdd1252cb8672486867544ddc189f11d9e19b64d9fa1464c321043a788da60a771c3f5fe1c5c6916ff40694ad0bb4d0068d75016d4c938ecff7398226647fe841f8beabf1634c71566f734d916f672adb9ab94aedfa0c77ac3edfc638f0f519f9054f94aeb55e07d5187d0a42a5de2b1891dd0143c1579ed447558809942e48328a8cdb826c5ca6b1bac9234571251261155ec25e2f350c99fb0f03b70df59b6a71635cd54bc24bb2d01fd2744db8a457dce60706fc03112a7177d900f754f4ea2bb54a542a95eaeb042576776971cf6de3957bb843e3f8ff37d185df8e7ca468fa361199ac9c8a7cea50ed42d5076ad6af742a4d5479021c73e33d31b01cfec6695368ddf4d9212fd4239f78e20114d591bd28e5423d291a8a500a7ee5371cefe8d44aca14593a4cb47ecfbe5bbd3ef977a885da731a66ff5d0da7fd47d1391f4866c8ae0d76bdb49abdfc5dbeb08f9071ebce6e7ea57916e18bd09828cb1c36c58f8cd209185034b1344b39a50f29ccb7faebebff2528aad207a533905ddce07d9e4c8a2b0eeb469bda0297f59afea9feffcd224f36eaf58dd4bbfd200e61306b00a62a3d3bf2adfb4bf6d88001c774b5ce1252faddbc462926344c4fed2a36fd1a33f08a051923bf40e02d7abecf254b1525395edce6e64adc242b530e9f79941894ada7ebb3c71daab341c881844b39026167b4696ac279a95c7433130930651eb08f5e6e9bc6cc8473e560388de63f62d6f0f039162ae28954822ae04e9beb3c6c6a2316f796eb3a05729640c9b4a1ca85601fe278f741098c895dbfe1500bcd7bea6684477844a04efd72c323f666e350a75384145c03a24d84acbee289b88a962cf93c58bfe8e244258f7f119472256ab220f2694aeb709b9b0552a82351032cf0e2ded500fcc0b5ca56a0eac5e7bb101ecf79736552f43c01b447117c0a0da2b7af8d1f9c20eb353a45cac3335fd9d0093b703b9499609c0acb1366586f42a1fe2c89774998cbdd866750976623a1456ea0d7f95aeab7d5e8f3754f5e210bdeef71ce94c70b8c33a13dc996dd513a50c9446d5241f3caea6f875758a28be65d3e96da2595ae44c208909da1ddebd0e77b3698ca71182187bd0a1af45506a6defea90700a39df87d34e6ef321738f4687186f8c9fb04fa5032d8251895786e41b988cf991c98bbc8d7e0af664a02b1ad1b359cbe049c7eec8528f440d3010e52a800a650a6e7e3260ecc451b3e73de97965c9b926347d50b24be295524a28c34538bf580689ccfb00e8dbc11687896cf6ac5bc71343488c90e07f24e66e8a5f3dcc0731e370beb0dba86d4828c40bb8563399b8b64fb1af51f0d0d5384ec81f101235b69b5fe569e87c0a9b857ecbc2dd7d431c4817b48404c8892d07d097dbdce9941217ce49453046716e207adcc88d5b8e521510a4ad2c0ba6d8e5f70611cb23acbd2743da42ac18ad14bd011580ac9a0afcbee162aeb33fff3917e90b014d6e806ac13d820e747f03fee8053e6442ad213ef01cbdb85dcf55f99942a62a47aaa9f3b01e52db8e9d190e804b8fb6727dce1501fa91c6ef3a0a8a0ba659ae26f673fbe627e235417544f88d8b1ceb5b39450e19e313e225df31076cb49308a241b2e59ae184b31a081a08a8ae65f31438fa9ce4d9c2b2eaf54fb48cdd7a468b01b71546f562a905d3b03f064ff7bf749c8d03879f252c2916d59bfcfc4e5d560fcf5595e316eec09f8f84f4543d9760a44d7cae41b4191867b8444c70d128673b71fb13696bead8245b1f070091ce329159885d80f62c09bcb313194848c83ff214b2b0f05dc6a8d6a4f96745674bc254223bfc430a4c11fcdf51d502fe3f856da973ea132d15bcecb04ec70428a771eb9c6cf4247c9e83f1cd2c8486c78d8b4ba105085426f27ac351bb244d253132053a0fda78758313ff11d720456e70690987e65247f76ed327429177faf62fcab6426c355e8e1764c70e5b36167c67598a1aa5251359e76f73e8e3d2ac9d06b7a96bc179187f46124920552347f54a521f720d1675ee08b6a54257b82c4a0f822e79238ada01d5ef0ee274b8db190a06a1d2c6a4877bda824a8e92f4bf7d5f4414a49b35239e5b0f7b240380918b7b679dc097653a4a87ec5872bc01214dc152fbed372954c81c4c6f598a595d894bb916407798727b8ba586762417209a1d7948a827dfed32923fb2ab377f80e0288ef0d605b4202aab7f9a4f2b35cf71caff132dfb6592bea71dc19a5190bcacfa5817d585fbaaaa71f649b79f9adaa057185270ba4adf89fab9e68644bf75808706cedaa02eb33b1878ba1c0f6f0a96ecf32fb45a0f160307555bca4dc1d5f94048bd69a79da81a911acbc0dd1944f54febe87bfc58a56c9d782b7a5051dce498e5433c44b7217fa60d71a80f69a38e7f0ccc9439527111c3a0025149f284de315e0396d751e2d7c5a3a1db03a0498bbf29fbaae4b20978bb16fb705620218291b0adeddcc170aa77e14e7c1dd0f71f860c95b1f614f0268b603290fd5f2a3a3c72ec86879b1dfc08a231b2d5189612bd48b30190b6b9b8d0dde1fe94d3baca8cf8806376c39d7cdc4e93e29345699aa5875ed888a30dbde2f99ce310fed89b5ff4d88f5fa2fc5cb62af74c46fe50ba0d40a32dde9423ba9849ff68c9b69865e9bd6b41454f5b24d4a6e527d2c5a13806a2e98be775ce03e3a2101ad34488e1c37f323d6f86e85e6a80255a2a074e45799c7a242cbc26d83d2321cd294482d99f5181444fa9b387e6a7a0a92b2d305776c7291320dde1059cc9ec9ae2fbba9640c88b0e398025c7ad50c3744e5cc9949e64dac3c103f3708af3f61405bc66a0dd6aabbbf0b0187c4c8f6679babc3e5c205392e8e73081bcd8ecb56ce645aca46a8e1cdcfc26f56b119eb95a8d309d0101c23612ee3b5e53480c7e7f069da4645fdf75fa60897d68322e183d44a5f8b592f3d59e2ff9f62f2013fb9d7c34cfc802deaeaad5c27386ab9eca9401e64e830f945d2c274a266f6d4a414e5f1c3f1cac159d680524594102f9b4e3948e2bd6ca77ae5d78371092d078c4062d1cc5f332bed292b6cefe8c10fc1b5b1ca1b25492fbd6c203eee14f11d24549a8c9f81e05d2ecc1341983c8cd2aea6360471ecba46881cd9754ad2aee2ef39d621a3c733b0f3f6eac0200e75c8d263db66cf22d579fc37a523acf31cd6b5f961946ef5d2351736df23bb00e5436552c3e44dfdaa15f88eeabf1908cd2d0f235e4173768edb9fc2bcf8ae053a301d3ff943ca7317a37aae3e1d40d39264d04518dcab9767e0b33190fe7534b21a619c1818af7b969ac34c12b2e0fca2fe0486b02832d6ca4561e2f776dc3aa50e285948e6e4a2a0b5133b542ffe928db015736831500d79a1e9ce4933c4d0367f348cf111400c430a0947d42e992547ed24194a329dd9d8b9bd54400d851075d63f055692cbbfb2e920ce2de1fbdc4899b79f29fefeffe82e4b1de8e053f9dcb9a2055a2845d026841dfcad2c06a258c92ebc7f11b4a10a65df45a966de74f07d33438501d28486bf8ae0598f8f89665770b9eaaecee5d8bf0ddb7dc92927e3393fe12b109a567d024865495c75b2cf8fea8a231a7c69b03f086147a662a8ae8ac94795655f4f53581c54cd19a60ed0b6ad6a8094adc249a970fbd4295ed5c3efbedb2d585b395a76cda4da0032bf0182ef2ed5981e7d25196819d041289eec06fb045c921b60fbe6abc342ea496655f40d0fbc8b109b540cb7c371de92f53b1ebfdc0843a62d26acf664cd5df213a06fff41d4f4e66f7b99e8a9bfdf29c1222d7cbeade3c86a13ab1472862a678d3e45f5efe46e32f047ba841bd145e8c5ab8a9c1293e6747061544555b0ffc95431116012068259bc822b8b2a8494d9dda4ee647ad1f46c51c8607bdb9b3b2e8433608132f612236f579ae1c601aba6cd1151bc0ab1f7d8a074f4c1acf418cab0273f3649c56218b0383cb31222c98c4370f175c24ad9057187ad9b1f4909765feff5e61a140196ed89159607cc060194124b7fc712556f035c4aefe55a58d139b975d72aace9fcba0cf3cdfbdd57fd71a7db155da9c4ba9a9fccc39222d05a8d410056edb5fb279e865b476515a352bdaf754b4dc03900e1e1c50d09923311ac780b29f6c957c76caff89e3e4f4c165cd2ec94b6d1bca956bdbb2dda40a98118802ce0a913e6432701ef027bd82e5c2c516851c6525b670734e7519f4f897162b125abc780450424342a8b95b24180767ca1f80c68b214b68ff90ca49df10c7919d0ac180310e98894afa73063e82a308ab7b2d1d7620b04b25a9f705649cb55a5bcb8d834d7b3a106d902f482a00905c9b88ae21e279cebe107174bce91eabf4ef4279402e740c104355f265992fe260c7463879fd59c7837e9bec5e9a05bbf88c1e9edc2563e32ccbc79778a814caa1a9f33f5603e753ed345db7329196f556b0e91b2e9e12e3a62016cb7b93a295986ae66940688a2b7b8a00cef5a2a295fce657c2985bc65c6223ed219d9178d106a9b383d52f4e4d8eb923fd367f2fb1cc88b0684457ec01248636305013bb051efc3c4ad90f18ba3e0e17e73420f37c7790d553b8c380b205070a8a38bc11b31e60ae4b1a0afcdfe982bceb8c7fa4cf6f45bd96041d4c93707966a5a452b8666064b720fd8f63f4fb01cc1965bfe006bb1fe268712330fc168ba672144e60b6af2a1500e2fb0dfdadee306158ef6977afe4e782cfacb8858a85759bf2ac81b107132b969b0d2e9dbff5730c31caacc7c7a7c1afbec290674069bbf68865505a6572298c5f39c6b6214bf2c99ee2b4caa64430122735730e8e3d8ca29678e95d547722b3eacf94da5449304f14a02e0112cad8576f5c48eceb6f1dcea49027c9399ee17f81f370c42da69c5cf2b5fc48e6f1610dc00dc12c3e3ae2615472db956fb93945cb183a299af8b342c8d862b0c0caae2be0986693a36b8fb7d73bed19b2da0d93e8b391bc29daa32a583bf79b56c8be3df65f744886ecd7f082e213c719fe55fd0848064d9297ad60afd88bb64e317a2cd9ed401cba9ca604bbccd5d6d674f02a71380b207e18dc00dfe5a8b7d8e0d12004e154ceab515e67ff1d324fb6a2680aa8cefcc4d0bf9287f1cd6f7655cfa3808f32fb1e36daf154f8153a2bef9609ff45e1adef730d8744b3c6d7648b72fb830b5400d08eeceffbedafa6cc722f136021884812a446c346ae6791fc057336628fa3273764bd0fd5bcbcb7041550ac3bbe8ea25d3296ce1209d49e19f0bd2e15e0d946338d61911705fdc1497b775bd0707f0781bb37b709e821b5ccab938732a61f78720e94db805a5e83b4d6816843460280990578e87f00cb5c4af56426f78f507e7d25797a3b5fe5fe2fa190733a53ea637f623d6dedac6a163415e92c3e1e71340f58ec676e75f472024b175fa78c1ca085abf3e3d81692172a4ab175d707d1ec44e27112f34acbcbe5805aea0a758a0862b216ab01b36ffcf544d18e27e35bee8116251aec723f9c9115da20a2fbc452e052c6e69ad845bf7518a6f4547d83e9655a3f81e5e169b6367ed8d13da139f32d80a28c29cb9827280b52c0912c337d682f71d785e6c56964489cf32b4c19c1e77ebb2b405829fe0fde7c15a21cd5dc18b9ed1d70900ee78d4d5f91fe99508b7c49431cd094480d2ffc257e2cc2e41079c3e2a35482ae5802e470aa7f5efc779d5c36546dcd9c14bffb61473d71c4b6708aaeb18b243cbd6dadda3430e5b8bcf64c57fdba5d560a92b2bb94ed47e798ae792d384f98483141d3c269970ef815f6ce72b84ce4b8b18d9f529eeed86f3f2b25440f68612dbf244af5994e88cd9995602ea90342bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
