<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da8935baf8e87fc80506ecc3c16bcef6f31ed98f87b1bce49985e512b0868c8504a988f2ddcbc0d792a950571b28a4a3ced39e0bfab43e49f5dad8193a92cdeaffcc2c8faa45494c0ee99cdf1c44a2204d0f1d3a3f10928cc6f2b9d7fe870aa55034e360de86b7cc7b2d1c38c14b05fa3df4e6cd8804336f07ad5cfa9be4908d33f0d9dc3684687e856b96422a6ac52a8c65773884c1761886d0276bdcd3eafb47dc9df2fa736cb6071dd6826d24fafa5eb8f7c360d18ce8474ba1484a789fc20e104c53b9aba6111285120e96f28e497a1aad665ff63123002a7ef9bd5009162fc7463bbf3ef33ae281d2a7529dad5fa8b0fc50694f8c0ac2eee79e013da3a47abf3a8f6c29f3da34911b35542140bd44107cd261561185c8adcaa2c3672d630d655bac285d5cac81492f048b1462abb6de01dabbaa613bdc79c5a8440f2601f292c366b295fd57c8b04ab1e43e186e312299189159e39f4f1131e05b412225ac782f28ab6c98f7ad5bd9acc69d590e207704dfc4f67ad6597d90fbd6656694c8689c115345cc26d166ef8814a93d2d76cc83241f3bf9371503782ae147a828b766e663a8ddf8ced3529afd1254637938236624948281f9cdde5f1ce00ae4120dfafd9b43528185c27c6755b96683f23effbd5635adbb2472fbc14f991259e02035a65da7a4e12d3cf7ed5545e8ff46a629e724cd06077a38eae38e030f696ca219d43aae585153df17e40a138b7cb80a5234d73866c5b440901f614dd6dad045adc7ec8e891ea5468da4e8bab8e1cf2abba077f014cf639c1b2a3d33caf78b4144c9e639bdeb3198009b49b861e2cc08a09bb23094a824a9761644fa2bcf902371a59a21ecbda3733a9ecc0e35bdb9215518b19639168a37dec11397014145e90ade4d88e40ebf6038e7074e1be4202cbf5b934b850699eaf4763a1f21c3b84c058446611f2076c4149d43e91abfbab527d985d3d9bf2b083b89d6e264cbd99016484ad05f9d4646be4b603ed253eb675d24d1fb8c64455f5d9949d82c02b7a40b88906c7789e845cda5d7ea579ec825f3244eeac69d04e9b9d09e9409d8ea27897b053e436127fc354e314febe18266dbb505c4de5141baa7fa2432681fc12b9b243d8451072b51f8f27dffe4397d959b2984039439dfa6a21c57cb03e3601db06bc9ad14bacb28efc2297bc41d8859f052a5bdf691de2cab296d939bfa8fd2358441ab6d37a19c42b6371eb9e0d08c06d33d5890b7107623bea222fd64a0405141287501282ecccf10c319a0694d32cd43ea1a32c2d3546be8327d2695d77d43ad86c1db64665b001400eac483685a0333dc4b1b4112df8a803a13bba31be3af95a1524f7c31b16491e63cc95ddf3055fc68b8bcead3236e854b51d910d176572ef3d7b991c33cd6f99b236890ba87ffa345800a2c6ef41704ccd6cb90a8615745c21d2b6bb049c05da0b9cf57fa6d0763b4f6e41ae45e285b6b8d7cc0037d1e27ecdd5e7a92e79eba0e40f0db2ce72a48f992af531853edeb8b28058d6e2df7578c7285285aae3696ea088de4fb7aa2bb3618f62f52dd91d8496cdaa7621d5843204780c0d3f7d37e70cd8ffe8319d424065199c8469ca63d10923d1993e7006a4ae3c1cc8e169a6da5d5dbd04195f130854f6df099a2d7e5221bc861992ae92d2b1f352962543b0f072705ee6c727a97e74f1d983dafeeb95d9800764767ee5f2fb83c8c368c1e45041603f50b458d052354777ed73b6cd6fd139e5900004d4148aa5d8f59170e4520dd28f2b2eb81f7a2ba8ef00db97400a38fc59ea7b1c21848e1187c2c710398f3f834929011630d352e0346ab3d96a74e9a52845ec9f0d44aeb2ea50de28b7bb90af754b564c086e59a4b029b6ce0f8da430243459e29a9aa6f6d0df0e1045e7366bfedde8ea53a8e647e04b3e5a2d9a4d586f175944e98a5a10b39bf53de1bad8e71c04606dcf19ad957b1c937e46075703bb6164f75258510bb9e0ef14b06a2cc224982eb2f5bcd5a9f870de28f6dc45b38f9687af39f9cdf0b976ad1e120a692956b15ebf3601f352aa75bc1e64d52a050df726fa306105e8a28537b63c4d2f0e9c8dc1b65b7f3d2c302ccfc2b92a7c2c47d975b939c5afc33ab6d99067545838d158e9d687e8592c756d0e5ee6fd335b3e0d65ea5389dffef26d5f634c70a72b48ebf43ae1bc869987b0e5dd45a7c4a98c9840a8197513203d9b592bacdec7c9d8bb81a70b17e5d93dd99dcb47e1b9d88934142cdbda7679543489bf7a9fcf5cc8594174b0da69076d708d11a31d0484e5a27ddb5bbb5326665f05538e441314ed6273a2419d0f504f851807f814f0746afdbd682ca4aca2d2a0cae697a7fa31f57a5b5e43756e6ad27d8742b76a702ae40b542aebed002ca140aeae1be9c577cc6500c9b44a827ecaadab8e1288935bbbf885ff3115c180bc3e093acf8a0b470862124c9208114ff963c0b0477497bc0d073b61977f2ce5619764365e74fd6b7d2ffaf3dd95fb7bd0b574d151c8f5abca9d2195696610ebda3043a560c25b61fbcba914f59277abdc455a908b779aec154c6c40f18db4fa35291e1dda14ff641b4a418538e1c7aa2dbe26be9cbecb540ac13815d8559ec25b7ed4f893d951df5e7d0ab890cc04b6e5862b16072c2fff379d52a78d439dd3262a166026ad2a627c67cb926bcb1a57291fb30c1044698c447aaacb528ff6b63bea132c0550888c0a2b145e5418952e0f00432cf76cca32c384363423c1082c5576b0fcac6758aabb975784e4ae24f62e07a0093b00eb7f503ecf92e195360bc718f8467f6b426bc0cdbee5ceead74d2cc2cb457995fd2bf7dc376580783c5349996a04adc78ba972e7a6d73163217a57b2b0e3ae24add87b967e47ff890efa14a7c92864506c6cd260fb5c779f43d8a68fb3e5772e15fb2942193f3092e13db413b5e83ef8850ba72f5ba33dd761cac7ba987666e154307e09ef219d0a5258301c167cc437260cbb6ad267f9e80f490eea8b195d6f886c0d8aff38dc064c55c279927cd30694f1633cef6db80eef68e91cbcd46c73dde54b0b09272625129864f24669778ad23ded87ee739166957f827548edaee8f9d47f8e153538b2a4c2c8d30101dad17a1d9cdba0553b5599b910f7cfb735ced7287cd0d70b00c472375c7b4b17098be20befefcf015b2b3a223b7f6d5c0a29a03d3962eaff6ef86f5e2ac5298fbe72e212bd7f952e29f5a72e963be1c431efa04d6421f87ec1aa97c9d15ea88a788b92498c9d5bedd8e03e0bd53a2cbd170cda7ba28dcef247e8b662f643f49094998c260906f3511355de17456f83a639f9078ff5af0c6f08cc59adacb05e387ea974213cc676146d65680cc82f3e13752e34e3320fe5706ec591947cc59004d77dd85b01140f59f09ac82121e3decdd0978e9129c1c5474b9e1afe643a8be9995d48eba6bebb9bba38d33a1c8d8976262aab91e98734cddcddcbf74a625beb076b7c762a2b807f98e464bedc13715d415dcf1e978421d94d215bb200ccafa1b30e8fed1d9dcde92370fc4ecf73aabf806f6987f274e81992a58056fc331fef8dd96f410c1d39fbf3fbcf9805b6cccc52dd6090c798bb4aa2f1ee579b2decc3123d6f16c3646d97001d460632e5d92cf2fac5c20061bfdb73a8e0528822870f02cc52021ea7619e7320683d29e11c35da91f42791a8ba97800832a59fa636723ffc6bccd633cc595e09af61c9ae04784d37eb0399c4be0b009aa6cc82816d38a2e9145acb64c885e8ea9ba797c64501f1727a7767ddf97dc3e2e094bb2f02cf34658824ce9055f6c7d5cbecc3d1d86ee21bdeecea4f3ba6c3bd06b0bf9bf52258f2ee2c3ad55e5708179b6408c3c82ae127871f91fbe05065038e27015db4ec43b62b812727a04c76f40e049025d519c81d7bb8d1bd6cd1b07e3b2e27b673643dbeeb0461d2c55f582c5e216f88842bde4c936a3175132acf82f3942424fda2af1e7e51930b2bd309044465a5e36553488324deda0f055f8e8ce1fe8669077a0c14dad14c467d5f9d17559d4729f3b975319fc2259da5d18831e94ff8437252606f8011f3e28bf515ceb0a938bdcb02f981ef8e2a4e647efb93b36fe5ec22191439b778f97abbf75dec75a0055cc5d45230937737903b16c17f05d8810f4f61327deb878cd056ecc9a32aac642eab7ab1d8dbf13e3fcac921840b9d9d04cd5a75fef48b33b6eca17f7a2c738dcd86b5e882d1fb353320e4337d292b55ecc95d43e9111143b61709cf630021bb525dac12c27e2f961172590e34bd6f092108caf6d03465c9e5b168d513b6853376e4ec0029121b95ec34ca4f4ade75b6e8fa6b554bbd49650843a9a55ceddd4fa0c8b027088f93a398ccb81e2f6200bf1ca9b6b503bbe1ae52e3264fabf458f2f52bdab470179ed54443fbae48ecb79760402d27c45a8115d9915e48178801e07fcc7a5dc3aab2f0c8361adbdfca450443f8afb80cbd56ed287d3e52884a68bc2aa86f45674e20e371699d1fc601a1d8dd0193c994f53f44f23ada74209f328cb542c81934b00c68800b86a564ebc1d4e76543f781f9986f9c540780e7dd6ad25731871b73b7058c9ef00d936f2e353c969cfe770708df376cafd6d4d017a1695148a28e31eb480365adf6a8cd0753aaeb496f7aebb63028788ee7cda88b7d1a3aa6ba34d3fd9a0fc93a9fe47f646f1d953de7abb87d8e23675b2fca1265a2d7ec4ab1998caca7e2cb494c028915d5208accc9da023ee471c7abc8eed2ee0a2d2b229aea43ecb7a5715bb3a41e2a9f1dab03b5dbb0a234fa75caf2517555125384759050b6e53f2c42efd360159c8bd70e4c03bc808fae71ad666ba1516e2c2d133728e0904a274e719c7ef317a408ed50506edf6d331aadc6d6ba6a1ec84f136e26c67519f352856e6ab1331d143fb62b2301890a39e75d696544769f7b4fdba24f18235165c3728c9f4501bf6a226e03e7095569944a5e23b706361322941f813a82c8b1af4dc95b2452724948d9a1776391c3ca23d636455f250c6f88a524fca5030bf0a9b86dbc6b4ba253f1ff2b5d55a7d8d496b8b8a9585cf952513b91c9f2789d435d083adedfbc057f5ff24b8fedd7bf357deaeffcc7c1e1198c12959e9567f347d971a5f313b6ebca72477259ea2c5119d3830c9573dfb1fbd41f71aa2d15c583e5f4ff7bd0c4c8149f85b3e6556e18710d633db6a21d56096bcec509c84a087a5031a0fb86b80263c767090c7b39efa5f56d3d3846782795dcc196da920c5e27f560569f133b20dff643cb86d003d791dab3c7ce1b0755732cc4c85b75a452cdf18c414b4ff71548664e2c904c1d13e62c0d0522745acd1e94c78838e987cc6c201e0a292136c09b6c338c7ca6e6996b7f51ea038715c06474afa1ffb3e6d25842c60bdb48d779244b1db0850977f2041c4bee1233865b3d3918296ab736332a8383dc319705f90a099ef5203cda07525256fe7344fe0f7a34f8ec7e4ba7c15229bfb193853a8df1900365de9d8907c5da39941e337e7e9425e9b43f6297f9bddb3ce9fab408cb7c4314456d6a4ca22f02fc859d4a78393658a61e7b367ab75218a008e002cbb080e73eb0f90edb660ce02803044afe7c07f7002d35740fb183733f6fabf9fceb370fc16b3776acd78085f081671ae3879e4acd53d4cb94909523c085486414e837266982a3f33ace952c4860347a08680d47a49f8018c042fdbf6b097cd91066273ce20486183f70d8c75334728e2ca3a5dc67d1834ba3a3fcabc9be3b86c907ae5d29861803601b405fe135be1fd54c07885f87fb428b8e7608841ccbece762ad8e437f41e66d15285f1700691e3f2717a67d042d61bc049ae12f906726b2cc96ac61a7aa6a5a45a58b6e13be58580c9c397aa7e39817d8d9f4652d6d766a6fcb160a57e4a6dc3294f8b96c6f43255601aa35bd3700ba697267f16ddde0b07fb22a548e0ece3629f249bd95a3637d845cf90930635450fefe497a0466bc9a985a4d5e323c7aa098e38ce3a59f635bd2033e2156f546d12a9c992228e96bc9bac5d363202c427e83923e68a43f2289ce6360a5e9ceddf3bec4d33cd179f9cd70f760b0426974d742520fc7fa255fbc612797b4050100a5356b3bb8ab1a9bc5d3db7f89d0768c130eba5dc26d684a03b491f95fb6bf7f65d3f04c85606984d7779958d1f81020364f5947d5e7f2ee38b25f37d69c4494b26434d6a4d99c9fee80354bb8eddd2fee3045b3921ab75fe8cb519fe64a94ad48a23e17ea9610e61aa1587ff31837d04e450f2cb7b16c21fe0dbfbe1ac8c5fb06e3f64378a61d4777d44981cf0af12edc363bc25d19c5ca1b3fa97ed2cabafc93cec6f8412d927fdbf162182d2257d3bb75f4517a08b23eaaa454c6ef403f10690bb487f66523dafe1b610f3d43499af3b1c8f32954210cbc976ddfd3a171054103316821fa8d849a817798a5517e6efd456214d5853689ca32a99b89039b9a9679f3fa401a3a747b207724ac963192a317989ad4b6469c57d55ab2e29e15e02c5050630bee654a1a4343496726114ba8686aa2fed626cf92f76093bb0a72d88f8a90f3e8ced2e9047b062409689b096ffa6f9371b08b5ae0ee9a094c07081b05191a237698c6dfedbb47e7ef4698c8771f9e9ebc01e1058df8cc57ebc0184c16f01f388b83b6c71964238f0bea8b1c0448f1c7c75deb3bf29a65ee6abb279882905dbbae4054a4d2478c50a594bcefb3bbf11691b9bd7ea9049e198707213d18f37f038dce0d7305d93f66630a5e7e4a22252bbd322caefcf4079b469218273794353905294cd0839fe6e928f560560b1b90ec5c2c9a6320be35ece2060b9172da379fd3f1fffdbd61fc7711b259392f2c2f6e0688e0858ae02b81b5968b805dacfcf195d518b0ba2bb55467e0085f1bd445e6456ed7b7a57eb93edd36071e649b85dd17e5ada4f8d05b0472ad40a2df8f0dbcbe96a4efb589b57cca375a5e47b17eb24239f4dc994b693dc25fed7e77dfd0b131d126bfe10f431c19eeaff20bae88d23d73f23f9a987cdc817457d9d510fd7d44d286a03650018635b9ddc082ec3be68ecc8f66c7810e155de5f29e078249fce62dd452e6826e8743f5556da02477f692883e14d81f21d116d8e5f7a8b3ea103aebedab2dcaf1e6594cdcc542a58dfde3f5152d3cde87e9924b564520a957a2ecde22b4c7c6c8c36b473fd02f79340114765f99dcfad08a9a92f14b7bcacee9d66617577d89dac58b9413002215a83ce0ba00a5b099c0ef72b01ecade0997f2f901fdd7ff0c4460ca88ce64fe5239e1860a9c9e5b5b47348630d2d137ba816920edf716126b7f245bdeecf0277403d584ab4c9a7bee5f3bc5e1ae20f3666bed2bad51b91875a10a37428f2fdf3b905b15ef915930c761d6b9e4621e452377daf41364f13da3e42d1a3196c30f51507d6af68ca0eec5a5cb27efb84754b1584469dea8781ac13e6d3f8000b887b329c0991764c17c94d82641661b7d9209ba45941a44af4f2f11a0fbb8a57263ea6787c25d421f607b1130ff4ee26450ddbf189f191140df09f0af01e278743463818e96528efbd84eee9114ccdc3be3bbbf84ec99a5cc2b3d2f321c2c2a0e062ad7af4aef003b9821fa97f96839699feefe5fd697708dd4d3472c64a8d71d0bc3b13731ee0e95bbefd03d3b76e970625a8e80f1da7fc89b084db7ceea88afbdb7df8dd810fd8455ccbd83d406b6a8d74eb84bbe12341eab22e10d110a5957dc088c13e10728dcd28570ac970ff6657b57ce06521216cd97b27fde3edd2cbc7b421f747d5fa24d2db2dc66de04cfc66480f58d0b7c7450e69f8fd8c145e0fdce62e8fdec26551037660994c59da85cfec00cb9af770fd34df4e4d12d2913a6d341a65816a1340ba0114e7556f653508d511d317a7bfe70df4d6fadcaf6f58619672168947bf95e2495f854d2c8889099d9e05b6ae480da3bb28298ea1abe440b0b29eb2d7201d12146e5e1b2be022ca210e771c33fb74b5777a6a7a49726fb3bf2bea3ece033ea2355e25386ec03767191fbe53020e2dfbdc044e0dd61f2c8ede8f12457f9a292c36fda93759c5842dd8320b455b07da83ada7778d5ab86c8ea95dd16b70c5a08d8cc060fe85e172ed27397fcfdc67ba2b9536a65ffe38395e73d8a11fe897a09e232b809a0edc301933f1c51406e452aa190d55be480db605172ebb20b1e66e3d0130f1d00a27644fe9f934b18941e56af8f05bd9bbaa53c15f339ac6da833a026f1a4798bb6c18d9406263e84f817cdf4eb6781aa336814e06ddb4c7f890d2dd14cef0bfdb345d9e5e2637845f269b396affcfc27f0d5388c0bdc5ac31e9eef50b03b1a779d8a49a2866a7f811a9c04862073fd63b51bfb3efecf40f1c1420703a1e067b0f8514e5488fab2aa44737650f5c226e1340228e10fb7b0b908e1c574206d023b58f3b4f12102340ac80c37b4827e2e872281bee93ee87eadea141de5156dccc5832b14f815051978956a5ce1d939dd949672ea435c5ac706268bc20a3f8b9ea7dafdd02474f47623334cf5c3e053644c6086e929ee5d09397b63eb97bf11edc7dfa15eb91dc998d33efb9109999062dec54952003f42f966d072598baee8e4e020993b4c78efd2ebaecd305fdc58c5e02e8a7db1b874fdd156b46259c507066cb2c7b763db1c7cceb94c476834b02af1ab8ab09e1ba032e377d73f486002a0ad626da80a14c8ccaaa1416c17f5f70ccb33e3a1fb4e8238bdd900c682aa43f23f6cff46d96bf405c5220ea73332f8ae43478d8365f28c6a17c52b4324fae609909d0d1b4e583e784cc38c4021db25484e9e995daa636d3da8bdc0f6d82f49e96f8f5f23300532ae008a970fbe36cf3d8e388aa4b4b6a76c243a71f3586c9ec6f5f002066255b10aec419535f92c8d804562380f936463c4b5c03ec5c2bd771600e6fa4ba87b1f974d16bc90e0b2474007070659a9b6c724531ada50d87ca388a8974934df91d0b2b0beeb00b0368454b2d469f57bc0142c95b6e3895940938171bb2c312eca0548ece51c5f469c4270670eb96d1771d44ab47b6b4df18e791a30475ed791492d486748b045d6498de18a86b85bcf0180acd2ffc530a13c093baa2bcc1ab2e47f96cadf6144d4f3e474260b169b472017198684fe8dfc6cf625c26cc979e38eb4278aa890d018b17da1ebb661ee054a2553257c4a9c31b0184bb4d09a6ec5487c34eeedee2d21aea5e48e08af2ad43ec87e7f65dd20d45014f0a312ba2569bc4897cf377dc18f852edc8a9b3ceef6abb515eeb3026fdb535ecf04cc65f583861a4e3d3587a48b942d1521a6559e079f413bdba05289d735dac5fbd29d5c9e3c94955acfdae14c1cc9721e1c398e5839229df8450f4ff3cafbb841db76579202c4e073e10861e7a01b019a3cfae203fa8248410b6b98d1dd4927b4dda55d0119a9dcaaeac7a45d44f6dd31b5a594b8e8784092c6a343cbfd2bea3c90af53c97226d657d76869daafbe15eac0bca18d7afa764388a758f5c645798c0f6a4a2dd1bebf6daf8db56344099e246bbad4b71029eb0ba47760093ff5919b1db2f050d58728d8ce35fd5d3d9b020a304e56a44d1d3d738c9841814e237784de84a4efedbc86c3acfe033408ae1a681e36290d97bc8d01c49f92ae5f3369deb27dd133aef45d76ea40393f28ea4da72851fa94c80ad26e67f97feb0a7c907bfd443a2bd5e2c55f21ce88ce9d4a7fb31b770d3d3ea2fa62dd2f53f685f3f7a4e0f237f86f303bdf69dce56fd556fd99099ce944418772d8e03769f311b6c7072863f05725dfc5d87d32d9ef693362e5339425090eb3c19a85601646428f1eef0b3c7183c4443c6aa63e3d33fbb34e62ce91884b8b800f3c7eae3309527542302cfceeff55f37aac8316982a986b97d53f42bff5d073a5009c12959185a46352cd94b1b423807726fe9989c048d5b54ec307b398caeae04123d8c0d04213f0947043cd01b6f488ffc5fb55fd262b5449c9685c76cb63883b0cc15956ce0e464ffdd0fc2d1fc1a2528b437b2c406fbd4d4ce6489eeb71145f77dc991227765cd876cf803e29b22d411bb0d945717d439d26245a8efa477e13b3f8c60eb6ff2e871dc730035d5df79261552c82d26a561405fcdbb7df1d27340ae21d4c8c5fee323609cc2f181b1afebca9eb081c965c7b3b5078d473f1cdc7ca54735992a0ba6a7082d82b9a08738087eaf83ea58e156d5769775a762ebcbf99382abed798dce1523e2dfe2b519289c6e0f0f957ff83b2ee08a13dae447ff459d048019635cae395751d14169e43c4b2fde9e92414f441352e066826fb5bb69d9d72bafcb819848b4119432816be7025b22c72b791142f1308c7c325109ac4f63ad662dde4763a9f19c95e3b5922ca2201862fd6a6231c69578e4c4e0b135bf8b9be76b3482ba2bbc312301770eac6b4efe48a5fb48e61ec5382810f48b8903c1658685582f95bd2f29c667c0cd7bd9e6c44cea9cea6b60d7d567279e05a4e80a8799aa36b44b98e36268820afd429bc6f9eba10743cf33d4932e9167d8affb71afe9609777b2500d6c85ef116b29e84b14c003bea0a243aeeb200739bff4cc02a23e6da5ad12325a7aa9d921eab3232de9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
