<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f28188eee19f006ac77baa83bfdbf3e1c0cf810136be7ba9a6b558f3aa3cbdb051eb4a10fc668dfb1edc67cb384b4f1fd8dbb3e2a59a16840a5ae2bdcc70e3eb1f7e693e0f2597373db48feee372f3e3c89bc9d717185634e31dcce034b76e009940a3119b00983e43f222a5e0f96b8012c08a985a9883921889b5a12407b155b8954a0b93123479e7444410dd1fc758e527dde8d3aae6fd990a8ed6b099609ad4b6cfc97a8b6af7326b5b762befa76718e3a5bc0be71c58f00be5eba22a295bbc56262a1a5b5a58a0f1186230fc95e275debbdb4631e7defa302906528b67ebe02de61ffba3798fc7a0675d7bc8b17ab2bb098e9cdda49b1d6832a3d24b725c56b1bc95e0b5e30bceb8bcdb7e28ab5d1aeabd5bd7c975685932d9955ff29f2c082ddc77cb5ea40094a7ad65aa85c9f67834a556053d51f20f93ba8b9174cdc7c951f7ad746fc3fb24991bee376cbd0d0bf314b97258c2b6ebb17bcb02617e56dd9aa4441502a933e3cd5a7e0d5aaf09b250c25dd31993dd994b29a4ec0e58d2e19c3749e638238713578a0b9e9b56b7301d7e76d1b369921cf33bd145af03c2afd86be092fe41c99052280217cf7afb840117ba6da35bcb0a1397a25387c3a3f284da4b92cda8979a5e6acc528d34b6a6cdfce49fc12eddaa4b9977b589ad20d3f65ec521905ba3231e49a87d473928a34fff45cd49fd149e4227967de56ac7bb98eaa3c7f1dc474c1030223a14ae2fda3547dab84883f8b4cea4b277667356a161e674b969cec152b910bcda8efb12327ecc1ebda323e08d55ec8682253e346ae4236bf627f7749a0981cdec449c118b2cc3ee73e0764ff39af50da226dc8051c734c8fa45e90f81b585a54e8913d17ad734917e64096e20c44b25b9c404e75f79d645ad1cb21d8b7e22fc0877d83e74a0dc5f2cca2faf5459e711ca00d04364abba3e8267272b10fafff5fca44188f7ff9a80cc797e2db8d3a865982f3f0a4464c173be49cd2a5da97414d5783d7eea95d6ef1d42caabcf3be90115aa312dbe746766cfbcd54807176d334c1bbcb33d14af1344e641970413e44ff93be841e52750b062b1303db9a40e6baf51ded9e372bc63f18506d29c0b00f02b6d53f89dc82ef210f2fc8797f8cefea9370eb7b1519070afbd382826a792ff1b57607d58cfd69c51fe88d5453270d4719d12f1960133143405d0218351fb2f70586184c0c5664ba05a446fee88e1b123ebcd65283678305d5a376b54ffea74d256001fc70dea13c45f56c9e99f523641781a762e1991d3782cb8bf13ad8ad7155fbfaf83e2a7cbef9b7534b6378702d11f0e29567b3eab23024ee60803226d1602189a62043903e07ff7e8cbed0ab5349417538e88cd60853798c3599fe22f879da4c4290cc2399f41c832ae825fc204c3d15580a6fa2ad0b39ab1ee1ef1186c57616ada97e416d8f2ec17680b6b80b89bb46b7f9f7d7925b9704d5be297353749cc9a331e7400fcef1beb7d3f38774127b5b6c7f1ce6521163e1f0bc42884d6f1c539f07521f28faf1534dfb60b83a777f67f2e12db5d1102d3f9c1cef772f8a7b2b28d7f25511566741b57296d2282ccc55c154c4c2a8cd532af8b6bf4f49b7c48d917ba7779cd5299998aea85ab72e228f324c6bc8501947ed9d4efd35f75277676201379039cfbf46de9419241c949a8350df07c6e1e07efd909d36c0af9a0533e086484b5ab343994b26c5dce9c3d3c4c84f9376cec55990cd1a5d708d64bdc7e57ded5c601f76652abddf05ffec5273f8bbbaa896f06bdd82e34de6cba7235b5ddf4f8c2022eb093e199b777becf00dcaf9923d06b8311f7ae137018e52c328dbf10adfab1eae878916e9c22073930b113a3d1b45ef06231a0c43684943eebff7b0b7049335da67b3ce5864d131c3518e33aa562430cd922bd4e32b0b9332df2c7dce0419bb04ed723a3bb2fbe34e097d84114bb9c61b895caef1882a977ae97ecf216e40b049005cee746eb1b0c891d93fe87b82bf5cd27b714ffbe33d857160bc215d2642f698061a090b12db2c38833c1412e7f665d11f0af9520ca95ccbc36cae1950dddba2e3e70d7f9b1bbfeb21a97502d48d6599f60aaff20fb462b31680b9af5bb67a4b947e2c0530b327a7a04275a88fef89f9708961da484d9d032b1e89dd5e31e1f730b55292ff3ea38c9e5aa69b206973b61cf30c820eb179ce36e8d9420eab621065e04024274152a0347671e318f573799291ab0658d0e97147b3df012140d1074924e928d80116a81086c3c2e80e90d1935dbb1cf239c823d5f1a066de9baab67d74af68abcf2aa82bd105ad2af5960a28c7af7117af70bfe976d31b0f7ccc5bcb5f0260510ce37434e17b5e5049312b3c292e4a201c3956f897fd18395d4631b1357ce6eed58eb348de818c5702986b7e7e2534d3d88e4208f46ea04956580af0cec4d8be28cfaeaed19a80630f734c1ac87f4a5eb83e4229196171f159b19d6560f54e2b0681efa334ef4c90c60f50c3acfc56206edb74b4e838afbfdee165791f0063eeff0ed9f9cf8641b5de16f5c5e42d593b61cac1d56d60c0e2ef387bae50ce6cc2118c6b37e771aa2cba12e3ddf194bcbef7783adc49b5c60159a366e3f89261b36aaa98eab3de58b0055f89716083f76ae5f3cd5c7cadf06e2507dee9247d4c45073b3db31584c3f06ee378212b37bf299cd89d7d6b8106b495b4a38a2bf31f8fbd56ee3ee758f1cf08b9ba7974b3a66ff571ca9c102b25e2453bf91e9d0141605861f03f0d59d935f69924cc7fa2e3d7b2c2b2476a1381f58a0d16c1e1013098ef3f8933fbddbe3df58cf1233c037020a2fdbd74c2084d4b0387dd27b32cc517581d699eb4857cfb6a2d36836d2b093a6a07a3a9fe8a926abd1e59f43bc53ec55aa52d3fab34fc127f5e782d4cf54c5f2f1eeedf56cfa59f6f71a470cbd84db8420eb8dbb5b656ee2c83b23eff5a06ba0d65c3cb3b09bac5a5c1bf5bbe121eae070bfdb2b65caadda8f3829121d648ec88a96f9e55ef0aa2fb695d46ddc1e5fc86b29346312e012f94114dc847d8c9146c330a6fdf5c3446e73476c6bdb1b37e85b0f23b260536481863589a2c0231209a2bcf92a8acea7411cd65e47801a99d5842cc5be1a6ef178631072eb2f4e7892195616aa5ef337f2a688a25753641dde378be32c90f69adbd8e1c23fe7efae95ff7b1b17aee7bf7759bd8353fc56a502873849332b03b948cd236bebc6462b5f0b76e27ece4778444f2671ba59f6bde87458649e0839050971fc30e9462a667c867f37b0e9c8009bdf27417fb4fa1a12bed307cb0a9e9cb1953aeee58d985a8f4bb3abaac8032d2340e10ccc7e3ad9ab350b992fce626532dda14691e91b00caec7650f21db83e5fd9aaa6272d1b52e26ba8b9316ab45a233c4b43404b74a034b1cb7192edc85b633627cfb72d9803b1764436aa5d4f5b9339475988e8ac26229c9043f0b321d3b01a2eddc394b4430da39cb654c60de0190c83394de8fe4451d5b2dbc04e249d2af92356982b51d68c04ffab395665dbda9f2e116a487b84625fc0deac4368b456a5f15ac7fb398a484c6202f53fb4dcd334b343b7348adf3456a764316d97f976b1356d104eae0aa37d68bb5eb51ef50c31da8f8dd09b7e264fa1b74de90908c69c34ae621baae01363c46c3aa8e7500d2f5c6a92ac5e25be2794b7f4afb7bf90c2694aa179b1d91d285cf6452e1e433ae6a3c14de3921ff13bfca1408e69a8cd5bedb9222729b561b7ec9e65b4d02e18f8dd99bbc3a54da1a3856573e3bfef2024dd0cc05c45e2bf3d738f20da2f094284d67b34f2d7588c5967c3ad031f8d243e94866f0200c5cbfe9f109813be4f6816091389419d48850a58075cecb0a7a8e2087fc546647ce9acbc60523d4df9c9f521b06229914749d29ca2d64030feb6ef72002bb73b3202620413ce504483b6020a899ac7d8a0463d8b03c7ab52078c8e9fd0cc87223491ed0ae86c1601d80ed9396971b9aaf950e1b3e7a14093880871f8e046b9b5b5fa102810c042f93310229017378de2a560af8fccec8991b097ca39bb9d5db34c2c37a2691d2a749c90bfa81a7de99a0ac9c13b3298de9c948e31ac78d9e5325753dc1ee63e96ad5e71ebce10a92020b06ff3444057dc9ace5ff5c04811643c40cc192186f66611594e739a434f202cf6c3a35ba29cf30330c450ab14da24a658dea7c48db121898fc51cce78acec7844c0ebaf28167a464890a81a238e9d094f5d81768479c488695c90247ec9a4dbba9c3a4bcc94452748dd8fb2cf4a9a947baa440d12fdeb207b91b39feca7c605ccef1bbd05817c3bb46b0024144c6b027d8061798111ec7244423ff620c956c6e81d2e57d8cc3b9edd1e6500a17301fe321892adf75f4883109dc45577b31ba2db973a740f1af3d7466396c4c3dfa142daa527ad90ea4b0390640d98f0d6f812fcd03b1cb4bccedfef91cb2bb97b8a23e405a9cbcbf9294161bc583e9082bf109634b1bdaf75fea0751bd073bb2e923ffcebeac1ee2aa881f3a82f6c9b2732a9f941811441424b961c4b59a5218533ed03d883c62e6edeaad926dc59a101b8b3a2f1828f5c50005ede9d0950001b1562d954094f5a3db20c4489253e127b89afb2b3fb1394b187433bb7978a41cf1dbc9a751e529697eeb06a06f53f08936d70f47b3a909a2d82fa19f9eee0d6b82b2a8e2ed51343cbdb03b9ef1be9b43c70bdda821d73ded2af12d4a8b3273c54a47ff924f12a9af412f1294da04d682456220158064d01f7fec4dfb662343277a6dc63a28afda0d2fd6c5ea270b46b65144674c100d51787c40d826c78df7cb8289a28bb0b762c57b6d03d4a39f818c5af7b32d0178175312f5d3d913e8ddd21dacf84ad361a76ff944c414b449f46fb5b52c8982e1a67b08714197dd09447351d826145d45f771f17e9312f2ad0dd35e863916d6fa17b796e15c489835b1d6042cbd33c713b8de48ef814687e6c41cc10b5f0f11a0fefd4ad6f61b3a9d880b852639cb250b8506dc612b8da615ad5c6470de4150ecafcda3c0e7490fabbf8b68c7dabe983a5b42754ec4499e9d7da0fd5c916c2cebfba5849f98e65f736430e6c3cb44c9bfe5aa4cc0fcf7bceea47ce1592aaa601079d65ef667f356262866f6e52941a8b2b386334fd8f7ea7606344c0bca2ddd1ea1e8755299b2091175210668841b843f4c552c31870775bc19c579fa87838b727476f0992947b7f25d5372aa17a9620957cbd6bf37332452a511c816bbf29dbab082074b6ee713453c552621eaddf41188d3640eafd3f457c5165bf3b405a4ed80f39040d7cf415ae6e94f9594d1e3cf7759e6b0a0eb6c441dadb15b37e868be62e8df4bb651ff6a172634740a8570c97ab0fcdab4efab870f34c8f09e8572b0cac76a93e4256c8fe6b059a98d41a5ce2c34523db059156d979145bc669cfb992e5e9fd74ce75d97c002279b115c67b36ab62be7e4efa86d7d7923796b0b958dc86fe09df7d987f08edd31040e9bd9593cf5b7c98e2bbc2a54b817803327d0f0a505ac355aa3199e81c4a17f0aa1d7d99f58dcac5fdb5be37956fb61e5222daaa83b352a6df70d41e27cf8962e00d828f275b9199ca4792633aefa6e045d871eccfea2e2edaf5a54576b7cac31aff3aa7350f514beb15208f2d48471cb034cdbc2abbcc252102b9605c4d34ac57cbb2825acb2ac20d64b5255803143e2842d9fe3cb698cfa84f35d9030139b99451cda5d57a7878973e11b108383f21eef36fd040fd80544a42c9461a17fc4721bf5240f2fdde02d42a3422d61c0a6dbfa331695664f6bc7b56801f6d4709ed1bd4b10aef437bde72e3b221d94ec460141137bdab6547c125280b19f4d1650530c95fb8469a96f6ac7b798c0ec547216443bf721db7d9a4be3d863c0547cc6c1d74e70334492f605e7eb848d366d48d3722e10b2be05c69b4b6b846d7215b3f3f760c2c7293ba61f10a24efca7a3934931b2c8c170a6f26787faede64a2dc5d330b3d627a8b19aae2faf185438f651a0277a0d2f14fa12f69ec8d7c057cf25bb4c06c56098cfd13c94ba2e7070c71d8109c2df3cf608b0751e62a2ea036d086e1d7e727d77ff16db85053d8f765db94756e0d385e50fff13c9c504b8200cb038f44f4edbf6ee600b513ccc2d71e53c79979bf9f4ef57aa8470552205fdb5b06d8a04f7a3cb4ef185eb0f2a88942a762e86c87e4beb3459643c6e625fa6459377456305ac622180ced8f6e97c6a1f7017979da28ef9dff0422f24e6b3123395cd42df0de96c451d645f21dcb322d13802de3705556e5cca1889eccd89b669d6a268480f87136f88b6112fd24affc62b0ddda8590778481ecc8635269bd5ac295ef38dba84593853454ed73f6903ff1342006bbd6ef257cc20a6709424ea43ebe7b546e6e9a366dfe23a4e695c144400b668c57daa02a62d5c75811ba4d7128f9f9b89c8091fa106d060856479b8009acf93dfbc8747a379872e9810cb489f46dd094059e0b7ef9c70183907911b33702596d46837074c41f734f3e0f2a65ef14a9c5a3d92c444ab44e249d88ed4189616621bae9f1aa8170eec2a0bd036798ce2b966ef95086bd8f97e80e51be694f634013dd4782507f272cf06a87a67296933683876fd174d06c75c9ce310f9f8c95af1ce1bb94f40b00b67e8874c8cff6494f9048a1c2ce2c94e19fd78bc4cb20228b53191640348baead71fa67c048ff4f328a9cca23be4d83e93d7690c7bb3d18127d4a28911d0ac56570e8071da3d71d9e49487189f251e0bba3cb9c9b16f4d73f26a3f53f24ea393fc3ea32ea37a8598fb38df8e7053324e3df3af4a12e998706a054f93103b371c62fc5860d64ab60d89bc3a5388f30c57bcee504335d8e0d4c2e4ca5b826afe27cd4d7da3cc9486939559b0a40ddfaf36116c3b88d7d3e9c48c06d4151b33763612c6d3d060d151b39776b2537c2ce592394ba8dbf3d92f35a6763f335c2f7253563d0e89b8de015fa3f80e7599cbab816a151977639834b4ba6e24b8c5b551dbf03fd2218d85135c16c27127623b52391237beb1e216c1019ad1773d8aea12d9e253a714f185417a86afc8f0b5159710fd5144ae3359ab3b13a76705909cb0ffbabb3adb1f933cb9268d714b3985127978d2122ea63771359abb2d627e2126364fecce259c2a09a1ee4240ac028c30c51f5e765f2a27550c416f7fdb461177abcba7d790a867bc453694af5d8a645419c37e0923c06f3918024826183c5c013b75a001705657002b3757a09bceab5fb36d78073894d051a3acb4fbdcc32db8d2f069dccae676d56de4ed69d70ed6c05a1768cf5194723c67134e7c3fed6e77fac5e0caf13520afefbe8784675d75b435895a5dfd017e866af1fc1d3e53d4b4091e2ea8f42317f45a260fb259ff95d420c87770d7b17c6e020ae7a3bfcc64b63973ef36c2984be4684b7aeb182827a06883ff08e89dc94a637acb2d898c46427818e26fbe22d2a96d23e3fba9d1f151b1bc410b0102b0d96e851699156e66dfdf78112f4d3a302ac99680b7efa929473c3d891621122d7dea0d6855d4dbf9ac3e317d52403ce4bc88f87f5e8bb24bc9bb9df313a19e9402db778b710607f25e934230451e0967ff5451376418278a8131ae4337fc28644fca727aa49ecef7c9639bf0f70ea323f38c228945a24def499f5f28b5302ad5bb5f00a2c02e28a25204ea285e16254dedc02f522cc81a67148a9b36804e65db55bf1910e2934d959ad969348403dd9b3fdc37703524af88c68cfa61b9f28ac858007b020a02927a439b86eb016ef17ebde5433f733c9b9473eb8b5018dcfce775752b660b6113ee7d09058f00410d0c730b63d64d48df068890ab5159b1c332b2348fd18cdc30e1eca796a6eb327746dde7a9239798b8c4ba1d8dc7cd3a3c5023b605d3a89602b101abfa638df94574e48e28fa62fb2ba359d69579f935b97d225c7af54adc3a3c01c8ddfcb11408fce18b9170cbd18fcd21438b8cc6502e535b0361e4794dee022ddebf7d03e861637e329794db98401c450ad5300b4017cc53debf5d58de8081fe30fd04cd3eaee93f5211f2114c8a83e7087665c6ae6ba974773b752adea66cd4b24df7ab9ca09e17a8c4f7b6d8221a0faef828472d35a1b7d312ae2daeb8415d654dad0dee6b708bd4da3c00124d3b8b140ff1049a940d423343bcdc224373989a95c8342690f9a497f2c04991223e10523e7470e4db766dd05eacf713e0b2c69790126c3d9b9590e8473dd76283369003f0b2a76db047c91d70a86a60472d1ad49423dc81abdc49636ea561e1dda58088c440ec3fd9547c5f95abd5fab1877b3a48e3312cca0004f2f419e0b16715649f827b8aecb7fa974284484589441d76bdadcb110cbd5cd37deca9fe8803dd828512b9b6348c9b6bb7ddaa2a81bd306668c791d51a4f407732a38a1e42d3c9a56db02ee7570650acddd9e6b83ff61766d60eaaeb95e0b6faf58c4e57c008639ce9e0aa4115dc9d327cbab7e4346f4e6b3f6e932710bff45db81cfbb90fe6136fcdcc4e04a177f6612307efbb2be9cd77f1b64f8409f7c98dc4ca1545d08d85a36f246a877b4d2f2d449813386d9dbe7b007761cf8a124c1d80cf83d68ef2c7d389889dd4f744192e33480565f75bac314117ead55f0c465a02f0aaf9be15380a15192cd1bf55897b374189e16b4a44c776c1e1c080f06f0f822ab06309063f0b7944e95e7f5e31829a407209811e0e3cc10223bb3bcd6456557e1feb4497b1fa64d4a52fd7dfa4d11a0bc7d9f582997e785e96ed856bc45af42ed79b8bc9c430aff4ce976cde8c633ea03ae130a92df7f55beccb71b31f576b023c2e4755deef3ade4f5e723fe91498730f3c6fa228864d8570888de2337baee7e2b5133dc46f68f806a5bacd03b67024e2714234682132308e695db2a61f698ee4ac32a418e7aa0bc31ef4f2c7e8966635071bdbc7034b9e319cb054f39baa5c141bb75d2a2a8d5d5123c54b2dd8ba1ea37f5668f532c78a8baee7fbb1b837eb2a4f4554f7d5f3bcbee15782bd3572901525d01d79f06bebb61a10c481845a3adae2740e9778392ed6a898aa4d9a70ea4eff0a073a95a95b4e85c43121084c114d34a18dcaa70e6cb4a408f787e611a07dd62091ba468da1f073f7d52e6a96115082338d8b1ee537a0b222d76dde84a417b00df26a4722919f89aadc14d4f569b842a5dfdd60ff48f7e4435efd02da0bee4838a184b1d62e9269fe3136e1663b32b710c0d6596c55847b068b1edc2425a856c45eb41f15a2a45a4ec9f565b6fa8fd7cde1321498fefa59cf244fc3bf0c9f6291242a74cbbd79a07a4807fefbb29bf7144b270d0273a72155703367f0134b10f01d520357bd0e6c996b2c9ead10479a42b6221d36487c6f1e26ddb16bd3e7a5269a77f3fbc60bf719674a9c6a7a5a57555a26539dab40635c1a5e55271ed41cdf6fd71732ca135cd2b72f80fd0580b1136a7dbb311d7dce28dc46e93e58abd23f04e994865ada30beb244b61cbe7a7b701c45033709ec4b3f7400570d0beb08170d3768737a5c64e78f136ef315f8f5a1076f388f25e349f81df753f307705930f1f62c00670e4ee2c6801b0e976f45e3dd3929057a8fa4ff5a98558ec694a8ae4e3369bb1c5460d96c4f4fbe53578550bc9f2fda06dab9402124aba7a8f5789dff9b096b956b243ede12ff5c2d5a8405f350352232c57650a03d7a14280cf3249360d562bfc38bdf656450e5ee5f419a337b24af236284ca2e672978c09bd696891a2ebf61874d0fa044b3d25dba8f4ed0b2845718b800b6e5e7e244a1bd87135d109b0cdd539da9a50e226126fb409961f95e5c90ccf1e564ba6003b843f26ffe61ac3da04753abcda9be011d960cacbf8993aa3289e55aaf7f6a1b77a6907143f96dc0383bcfd3f192ace27048a72647599ffe76524d35de81a917b304c6eaef564bc2ec92e682e309ca0f89320a02b13b61f45b3d8e2e87029b7be3837ee91cb90464cadd9c479b41ef030ed04576fd9de7350b140aa67630260c3e98873cdc8896c1fd28525d149bd322395d07d26905ed673eeee53777e998e9b8c2c9691cc461f1d42261710011518825a098ab4a0a5aa655dc35f3e57d7792c16af88ce22856b3bb23e60b4674e0c28e7518cc6598a40d56918ccd50630a61afae21fd1f19a9fb6aff1805bc56af7d3bf4b8c33e284bf692651772dc1a2bf436190962f576848691855f825cbb1dd8ff185d448c30a9212660f182fbb08ea28d4971a7ebedbd624dbd3c6afaee02d4b926581e29085c9e4e0692c3a77ea4eeeaa0282f6ae13604a48332209c19c8b670f4626fd76f2c784a7a176ad1c2384cfed2a27697272d3de1025a945730a2683f864505a7ef1ef6a5275acc49bacd69e31c1dfd2b13d291c1e2274172e0fe4c4febf5fa07819b5fc5fce50acaec31d1834c6215f43fcd582ec4ae5690c9c1242480551c9a5f0b9a27e00114ce082bb074253f0c15ff1afaf89e1de69542f06b12cc89c88d1d5d2acbfd973dc95c84994b8daefea6cfa3d00a6d38492db22a396d18742c127f14d4163484faa5edabd9bf63cbea9c590e1e158d709432d753e57d40df652","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
