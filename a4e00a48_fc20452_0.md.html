<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78a9b810390ec3ce00bbc45e2d4ce8e2489e3c25ad0ccab280f7a59e8b03ee0b3e337f82ac74e4ca8d2a84f9bf8d8075a1a3f1159faa7517d662d23e6691c66e2e7a5ebe8cd2a9ec51f52331fbf0d88d2a034ea577afdf30d01d3a9cd66adae3fd63006e433f92ea74a91f8c6e9ab99c29f67c350c83727a88e294587e69250d8f5e4e90996e7a81130722ad475516a20bf1e4d119b971385e442e5c02cd572925af2b573ecd0690fd7f83a2313c12f371d68dc3ee744d80ed4683cdf5652f4d52aadc2cfe2a8430f42bdc9ee42140ae8d1a741fa285be21bb92d02e7755ce27f444624224ed1c79c6984b597e9a2cc309fc708ecddfc16a07815a11c62e314b1b8549c037b912f36b1d369b6a1b0f67b1a26741281fb54a7747934c9f5c46706cf757ab87fdcc67ddb257523b1f40e94c37cca9ba450a01943b41b8a4f3a60dcbdb2ce80dd77ac3984932d1a5fbd0d7fc6c60353c341af5567ca2cdd7c052a3ecb3193c9d8da2b9e091089d122c7d3fe602e5bb738e5b63e3fcb9215e4bb5b8dfd2bdc9eb07ceacc816089ec108c3d7510b583cc70f436022a5aaececc1707f53982fbdf272a8c103998a453bec74ce34bb34a6f5479ff3553e4496fe2b368efc2085459472c165fa5447f78621e4ebccee231d6e46d4f1ca29709c8d0d5c0a6ad9fc5839afb93b1c49c360d07bbca82a52ec7622675fdebb0594ed2bee66782e3a88404525834e8ae8dd7e7adeb54210beaf0b29170b150ee50f514dcb94b64801cd8482ed861f10e1962582020a9a62c661c17b1dde1f85baf26a8b79099be03a54a7fdaa11c9afb65e438963d69376f77dc7c5857a34c5756c4837031747d4f5b90a52922a7d2c84f4a25bb761ada0b2d9082be79b434679089ebc8aa2854a4656fe53316b436975943d315b2815a4e17aa5c6cd27f160a3087e5b3df4c8ac04eca6aa7e819fd166f4beb7ad964bb93cb19d440a989c7b8e2ae6ca202b64e1e0da18eaa5a50bb37fd1d9b0e4af4ee60d0b93fa17796078c960d4e21ae1131b10e16fa809f6973fe24744fb1d26bc030341dbf5c9c494290f7a386093bdbec959c94b24396fc9e95dd5d3ec4fce5f1eacd642c89e727ae7c32122f0967d182e5d5f14efe8aad39c59e2d3190e80081d2ab335efbe8221d3facfbd966c5c261decb4b761e303d3f964bc85ed4c5208ad5c2e4fa7b5cc02c7b74d77a6901ab5c422e3f2e4460e4012c3939be2d99cf4263c8369a41ab990b41e7146ba572e9fcf5681c897d4f7b5661e975ed35dc8fd6e2d7ce042e2958d56ff50a72d7d8bf63359568a0b9ac143318024afbef02fc0ea887db6295b51f255376e7a42027d51a6a5ca7b6585b502dc16cea6d70587c8040300fe49f4b287b5c38f54f6eef8456d1fb58288f0c0f1467c333d45840c1ce5ad4621c0a35db22d43849111c6e5531138ba7f336c53e76cc540982db1702999e5d5e427b386ff1c99cbbf3412b0a3e2e6233971033b7133d8674a09210510bbf45439fbd659af18430da5815ee4d876398922ab3e9002308404d1faa8987f1b581c6b476eb6fcbf8a90d4b361ce6ca4f8f6a4dbfc91d51d6f1b96a8338beb5ed1a3c90cde30ce1d2ef92136867b4b696a3dce526131414532748c36a30ab5ea9e8224dfd4fce5d7ff0235aca318305d83a101fc5136872d91dd6897c6d1bb250d4b4ec135bb0b2e6ca3d708527139563c51d48fb1983833c6d55eb9587d6df61797687bda5e92bfa46b73f34fb6e2718042a687bc0acea619692b4a5b9d2546d04c8389e1ab05dd0d8fb241c02c8bd5a372dffe2686a5dbe906a6e0cf27ea890bb1eaf6da2d87296c663978659160f0aa9b4afd0ff50cd05c2bbce8b761d3818bbee5fd010d0784f2493042876fa7433d77f6ab2ca4dce0ef89e988c94c1e51c765b591bd2e656445a849ef166efbb89659dc26129c82f49e870007d82772a2e79a6f7db0bdf7822423c5d6e943b641e1ed80b1a992271c24ee7fbc4ab18e299d8f0d1f4e344031cdd5bd1395f426188714917fd1dfcc770edb1e09c6d6a53273d6425fd7261eb3c6a122e94537f64b1a2bbef1336bbcb485b3ed25a90e38abb895cbba5a78049db18a576f06c6dc911436bafbb0a9ca10fef6d87635bbb4e639df15335e0aa9bd2c4db16f4330266de8f1d04a2498e243055d9c62dcbb270ad748728bae21e021c3341073638b33d93e4562a6690c715a0bd9e2d5952f8f0eafdada0d0c683d74769e065c7b6e85f28233c05bee1aa2e4298317a9c5708bea90c0e69eb584494c043f1dac23f542f271667c5c08f9056fa7577dac9f475f1cd58b0198d951c5a741cc989ed93417a82dd664f99fb0fd70480fcd0c8e5b0ef4d347db0bb9db95f6ae5f4ccfcb09ee88fde140a471bad7d9329b8fd34b457df27d68001589f54d55d6952014fc364ab7acc6665445571982bdc5cedf989b65f2d524a2bfe233071c8818981581b77150fdd1acd8e084eafed0833f74f8e177626af0dd8fb77ea486baed4c6cd5ab431a71eed86ccdc2865aa54f976ce685684a38f942bb75faa2a36c992746f2b756aa2e434e2e57854a2dff7fc49f9e898a4ae2f6b6daf6f95b4ed033828624abe0a9fe8466b802d0b2f27853f54371d84d93b03ffca0113eed0ae5109f1060960a8950d7e10a90ef06c57a5d959dfa46858e525c566dfdc28af397534e159c6a67ee4b35fd90df15218bdfadc7061feafaaa8b38afac2f3632b0ec6c16ec5ab5baea50acd860857ddfb02186cca947c7ed04e9b931c41b6878fbad2a7163ea0255dddfc150e7f84fbd47c2cd08e4fdc42f8e42b30163ee0eab441285e5de388df04fb3786783bc794fda35680b25740f2ad3aedfc2648c7a622d144723d377d5a09aae886f0ae85e99c518d7d00f4b36540e37b65f3d09afc416f74e8a4a9b9cf684c7f3d401228e9f47552a9ff7e6547cea20d689a83a254985e749a41dd0af13db31b354efc5111a22d96220a90ce6a9cc92f126cd6269421fdb4c5d9c20aee3cf0e8e2d74e3b91662566fd87f25f2b5457ccd689f71ce0b50198a9249cf0527dd537a95e5e959140583849f1bb885937127130948992bab4648fea565276f6174c4ccbabf70219ea0d0817650f4975dced78bf30e758b1325bc64235be0a7f4b1c1df24169e6c669e187d7d38fb1914b84c138e7551022673e4b442a453e512d8decc23db5202e9bbfffa2cdc49cf0ccfeba02697875f8a99a9cb5ae2a21b902737a12c78c7466b2a0c439826294587c95758e8ff2daf0eceb846717e23781f4f49ca56ffad548f77a7ba76355dea810daac51d560789f4a98dbd5b73339975ad3683ecb9ff309aef5287fef6c22425ad0a3e194029108b998ee8794ed55743c9776747eff778456eec8045baba4ff1785934fed465efdfc37a38b518156eba31021157efbcf28075cf3d3292bbee769635db1f238e6a5c0f33aa5b976725cffadc4a190180fad8153698844a99ad5b28853e380a7a36d510c89903c34df65a368bfd937755c1811a2293bb6e05ed6982feed21fcb7ecd32e82633372ae3420567ca40528b9b38af5bc3fa2c0d08b4067d606e0248dcf34c33149ac257af74a33a77a3b163baf476944272db51d2c02cb2f9c2bc409262ad8592bddf6e03a0f897efdc6e9016f8871760adb054e59ab41e5b6d9681739ed30024cf72f308dc2a79ad2d4647c50b8da02cf2bc9a1c3d5c4ff5a759ed939877ae87b7c644bae3fe746eb2e9a3763a27ccbc5ffbb515f2a374d3e09c35860b2ce1c0a1e03c5e9e51b7fe70196828a3b5fd44b3f271c25814f23ad9058b831b8f71691aaa23d866d49ecb3482ed34f03b0e1cac75bae0dd867cbf6d39d0dd17bd8cff5b558965a163b6a7bd52b68941bd132d2237098a546cce6eaf678b573886b57797b3b18462612db0516522dc8be75ac9a2a9f16db049da9e53f5861e8652bfcdfa6694d307d532b31230c93386109357930553c355a008f85deccd3715afcd3164ca6f4474245c97059be27da8e52fa6e7a49bfb64897b140fbfe0852a3bdc903afcf607532be7d8fe50ab148307b188addfec387a460d51650639efa993d193a8c369a9bb0d2d1a2ade2040f7320a65876dbff268c8bc98edd3452f05f709f8a93183609656f3c95f508b1bf90d4239998b884cf3076d191c5034844f29f857800b20967998d784c499fe78143a8db34381b2295556bfe73ad84875593d995b9cedd27b658af4dc0dfefb1aedd3538472a90370153a321b7274c33ae0288adb06f5da04a2770e19e676b88f316cc39f1f913219e026d0fa7a018b770556dc63e2911ffcabd0daea06b288b8e245e6e4f2ada033c04281e881d8ea0bdf50990bdb6838ed9f6feb1ce0fd21eb689aae9581b384a73baaf8b04489d16ec50b418d70d3e61265d45188d2513a74f298d0d2bb5abca2424e6119073bf8d234ad3b3245adece66a6a731aa44c5d29af365a85d18c87a3793d9f10f90a63abdf9f0caed77af19fbd94b8040534fc4e37986741c7a58623d6e059be38a57ab84e9fce5ec6870d9fc653530cc479cabac69b5d003a796ee98a2827b1d52dfe46d66b8bfed0c4762f276668014e683cd608c87dc350e7e53985fd945ed18630243ac97798093a1742edcd7708db0863b95070b5fbd4c364cfa185124b4f7e5f8c34d06fabae6cb2fb8235a29ef2ba0f36fba9341efcb21d1407e15bfd5b2c76ee24a626a05ebe960d98945c6803b4e9f266e578ed15c3d61b5d63e936db4e3aacf1673beb31276003d3ecb4e28ee3d55be935401ab78472df7e49f66f055d6a78419b843d8785288c082aa7d446c90dbc914d3b8dc7ac473236a1893e6b4e4290a6011ed4b194058ca4409278f3f18af66facc61769e6b23e4ce55c232b7b06ff0d80f732c995f0bd9dee570ce62664bc5f317a4213a899d1931fe19bc5efc6aefba099736a0efe7da7b9e9b37ac7cb29f5cb6d51efdba9d75c663815774c22070a2164392c3a67ab4492f000e2a308bf98d2333a40cddadaabe667e972829aea52e7818f87a7e31690b3b2707bd85d1395b35dc6c4eb1a07105e39ecf7c4019035d8239b2215c4e4b8fcf23ffce66f8b6d2fdf576dc7ccee57acea2be21ece6573710a6408fbe152f9c4303a2e4e8c06c194694934e23a903f77d55845eb57e4e46cd4c81d77dbce788b4b60e217e82d951ae6586381b2f0f6b712188a362ac2cb527f5ab18bb15e41b7dc0c137b19b780a12dfae95650603fe2cc7082a74fa25c746e65d2104dc594e37c11fcddfd4e0f98532702e5c95b088a898071458096b1a6a51bcbab9b11e7b5a4a39028154a6e27c7935c2bec7f9748e0f92b1eb79c063202c09d4f5b9e306ce8aec39d0d1a9b6b34b18e0677ff3abfb059cab5eafacc7cfd15e84108d55c783b055994aa631e0179261a958111bf5960d5518d7ff5560a92a97f230b7b3a74b9de217fd9394811cc32766b6ae88d05faba5c34411b9007927239d9437c643b69e814df26cba9b95818ad9f9a07bbb66a3347b26bfc2de212aea1a98712b5853db0987233a2c82f047915096bbf29705829ee2f873f94f92264fe6962f5506a26148acdeba0f311120194d99c00202b020bafd39355ef98d17c0e432f1e77a386737e0a48a129e2d4450ed72d9e61ff194508f39f818f642ec79e61510a2995a193136d2cc34bc871cfc52ee8d642d629a51b6f4b46e5353cab4a470d1b04b4177b29c505f4f5da0dd9714b704ec81ad753634a66b8e943e21adda3083d6cb373a3777dfa90da9211c59ddd305ef4710daf42c2bab4c551d5527224e17d9ad12cf103aa7757b55de1c9e6b8a98c36d255cd0b3133026e5ef04186936b3e83769a895f973015543bb2107bb8a20b934102d286f1bce935e8c198cec4bdd141950264374ad98698d04962a2728ac71a424b642fd693815abdc23519c46902ee0060b5a94e511db273ec1112a579b18067e6559d6e7a07a0a5ddc3405f5c3427abb18dd96c32acad327f64e90d6b2c3626d30f8ded0dba72d91a32b3b522b23fdc6cb6b3683ee53f53c2040a23578c3ef647587c6720b56001c8c7f84f73c87c0fed526581bbebc584d89116e353f19d25e514a335622438447379b6b1a46e8fe8125a875ad122278f15c42a73b7b9afd82c8af33de9641ccf57311990eaa5afa958e89f356f5b79ae0aa4335a1736f08444a3936202fb5b65d775699099e9f2c93b4fccf7683cc41256671985b59c603c9ade40cf6b19fffd4dd58fbd4fc72f83a6457e8b2ae3c11be54467739f4228c6b9059ee068b9895261671a5bc5f1deb2555d491ec12d9989439d11d2c399e424935ab06d38b486e3a59cce41b30fb7c0a7fce1471afb41272cb4eaadf274908a26ade935b2e6a40ce06c2f937795143bdb567f72beae909cebac59a9d6ab955ce4153d5ca195c035bbb7301aa8b80c1030278a1760d813cf1e58780d2a27d556357f5c3d2d63956724a133f6d199bc945af6c59c55c74c1416484fa74e90998318a48e6c50b44cfba044fe41dbc4e0961927aeb3fcf302127d2b0d759aa0d9fc28ce899f903d8d4c896d9b769afd7597334f927119db8da46ccfd4e45d3a267bdd51adf918c55e31c853a405c3dd1eee02562436b9e52298a4b37b683b5897079ac243cfd9139c89ef4b5eb8c56e82134a9bb4b52afadc189f702b95cccfc04c6d167db2b6bffd5e96149b32d98904f5cd6b57bbe8738a31f0e3614901919d5191562ca37681cda1cb35cbff98a3b3a33cdc23e74e43fa1f228639a3d7c14080b360ce27413b345cb246e31c3f8497cb1a94289f99894e97006c28bbc7df23f787fcbff9737b95710dbf3d413dfa5d3f7f3c1884938a59842828f0611d404c9222191844f58b55797a7a4a86b4377733271e7951185fdf8d882bf5eb4c2467305ffd07f3ae6bd5d678b71804bbac7849104ee73efcf12802a19f7a14327fe2cf06d720fc4e082ffef39368a685471a4e60115bbc151afa5f9d6ff2ab90b7265900ab2795ea45ed98aaa2a16a5f2121ebd7e88268356c1f7f47e67b6b8e6f877c9e3a85509f6c1aafec2033553773be03f924dad32cc130b979e90511807ae4c2f6e0e5cc1a3ca29d2367579934dd0276708254d72daa7b9ba8d2e463b3db4b91eeeaf7d9717219e293ae48c8ae9f2954cf743deb2d74d51fc3a4c09dff532c94702406e19fb8a091f05400043ce83e4a247fd3ace6bcc9726973436fea65dd268d6ccbda2f029b4912c1d17b97339c09dade0e2a5dcef526c4528525fd6472ca8e41d882df6de3231e28703386218901915210e159542b804682517b50947138eef44905acf4cc61c5ca5d6a80035d2019ac97a06cdf89cfeba153e13628d15f74b4962d281f4ffd398c4a2782596dc05969f1f559789e84eac31f198619f674ae32fa4009354484085627e8fb246aa49da793eefa1336b3857e1c708f3018b87bfc4f552a84f8ccb4b74cfe4a9cace7e04c58fe6c6212ca27b5c41a64d84152287b26ab15f8fe4a995a28c156999d25503cfbddb7823ba058901f94bdd874a54e304ee2e23ed44525f802d40b9a35b6562af59799a8a26ffa6db82ac253152a73d7ecfaf5c09fdd5f136d9f33847350010c4a265a5db1e0d4d7d074cf33428ba79f75a730930da1359b6f9a212c472e0519aa515431241710a371b7e50f5d46754a1fe7fb89cd057bd8a027b509c9e8ab97afe7c4f42e9f2538e4ea64fd0dfb235584e15b4376cbc8fd1d7a8fb770d5b6a7a7e0b830b84a156ca58cd2ccbb155e892e54bf3b190bafc168b67b2af03b47189358f461ef1774a999a6f4bec53fd992f5e90cee080128e069ef62aba8741591293c6170ea692e4da29df69bec07b429bd731a4b5dc13ccce0abb8515808ac87e4a602e0f7c2b24081c0b15b9e433c8dbf5d9665959ee6549533563057c4ac394ae3f39e3a101c6c38a8c0502b5d5000911756ff46a762f6421d41416ebf6d09600d031346ad2f093f7f6588fe193fee3368350099679e5b01e007e6647eb07f7578c8de136cc9f6ad8b0a32508c0966f7a38fddbb93eff1991e9680ad970d9508b5989e9b795eef92954007ace2e317a33c0816ce1b2d2bb6d616c71c824360d73ad5fa2bf018fccccfd68f61dcb56cba25523c80920786049e436ac5293b754f5e83d2c6ee32d4c1b0fd1ca244f4bab1bd369686db4e712c08cab65dc027e9f9d1ee5b6e0ce628e000d6ce5be5c28b8d83094b7e01b455d1a8bf7186c720fab754e4d904c9d99c3c82fa2318f21a4cd3a9c4b0d32dab091d383fb80ea4ecbf84c74af0b1c8dcf03d0a0a4fd4a85d6d872ae0daca0ae406e5462f1f37972ae06ac05877eb943cc98221809e728d2e34fbc60ebff2b330d6f707188507f21c3ce09fbd71f3733402ae6baf920641db6a652f456b7e1ffe6756fb927712948745e7907245bbaf66336e6fdab70a1c9af0778ffa3f3f6179fa94499b916549ef914e6f0fe6a3f7b4348200457912d74995d555b0541b560685227eca13631ea788dd05329d08f2da84b94285cb7999b3349aa2465f21d46577ee9d89a195f59f7112be0f9bca3dbd7a4c7464aa73e866b6554409fba5eac4232131d7300aae9f737c9d3ba2e0a9c54aabbb69ed0c537fb7fe1e6c18f3e0b513bbc02575fab58a4d047d7c7c9d6871740ad63a987080f9ed71936ffd7e9af42fda7b03a1b54547e3242c4292e49f2998577486a3b065f30b677a7c3ab662fab4093c12f7d433d196024728b714180fddb75bd8d5f33e6e355d31a41dc25ad97a6062b30d3075ca107f9cb02a6090b3d456c491c088720b86840e7929b0954de7f415c637ec3d578b7dfb628604e7eb34f6d4018a62537a32d960a717996137d8d06f5f300f8fcba77d81ce8ef70ce461fb4e9d5d294e238c8e188b9be21b5976694e318d3017561a4b2742be1b19a8dd209d29cf8d8091cd05a1c11273170f655f6065d52991a7efa7fcc992cc4fc83d7b6c3136a8ccf09906cb437001ce12dfbf29de39f0bf7a5fbb3105344de1621f945101294f95272e78b6a8766be497f67fe60fd0cdb0f67652d70f85cd3996a982053ce1f1ee79c28c8ffe2d06a83f7aedc021a133b85b7781ee2184a512b91b5acef3fd21a1bbb065d8865a076b204c9ff6e8cd0548c6f916b04a1cf8db65784d8e3b6130c07653e13d3a60e7852f142885835b9d1e2c89e899c60a8edb5eb56e00c1c84a75a361a1d54bffd581baf1e287dc4a3a8783b81e413e89773d3bf13a0cb52087bb8effd418264584b2380a0a279457f82864eb45d9874c0aa5316018e4e6d58fa61b40cf23448735b5b888916fc8d5a1c6450a15762c9514ecb17178294a835af4d19a8954ed880e747ffa8aa078b16e2f29e9a1f3ea273031c074b6e6dab474aac8d3dd967522804cb6b67343d02795339bab1dd96bcbbe214f594c2e77bac62ed01c75a4b1d92bb656e9852b500b3f7cd2be18637d56d410c7927a3e257b4f4ed0de5d74b1fd7eca3359f39b269d6318d85cee77d506fd1e4c064e652a9ba0a7038a725ddecac0a9d553d571b14e8ee52637c4d5067950ab5cc8e008aa9d8bd79a13fead5de2745de8dc9b0641ed1b49d54674b60bff179a9580d5c9d1f1d6d812d662d376a4e1bf49706a21c157e72d0bebb54f24cd8d01728f869c81570652c78e4c04dfd456018b797b1e6fbc4c4e8bf07769d60319a2178c5aa6a70ab63668c537f9a418ba50fffdddf4a8cafc2688bf29daf7e43a757e68ad2e249ea33e1c0ba35123f817a30db10e871d8b159448362cc181237acde4c43a00350a545075cedb715f0829080780d16c10263081297bd200b0906257bb8e08ad147a06e7b376647b2ab2697c7cee65fc92de88dea7c4c66993c20d2249f193aac51103be5770cd756a0650f35dee55301c3c170433995da8ac96c3053fdfe6c97832aa2e9c9ae698b0e58716bd745a7c59e4c2bd094c2fab00f4531f6922b2e7c7d3f5eb9058c748cebc261f4ad530120bfb3977a6f45d7cc413b47ff55733df2f2eb81e23fef185b55e0d929c3fac8a39486c852ccd50f9f412a9ad541f83c978d2f5958e10a0465dab2673dd0090c7b38ab85529790d4933fad70302cbf7dc9460920c7a96e2f4377fb6c834bbde7a8f390b7b16e74f150e475b096b6439364d3eefd836855665d86a99c9f05d5b63b8b0a5f3434b3e21972a80a0808bca32145044e3ac99c3f2badf81cab911c546e229ca04531c2c556d884e82749d2d3291736a3c1ce06582219bb25a85ad92109b348d38cafd49cb5e28a6ff236d1bdb750718c22b6118f67b0d8471479f26edc99f5e57bc38955523ba0aa6ec46939e65a81c68a3ccd26f97eb560f74bcf1013786076fb238a9bce289248a0708da2680471b1a8142c9467c8617dd2463351b040095a47c63cb42286745b7de1fbe1f205d36cd42486833f99306d23201555453f5fe84cd7a722207e5fe52ed3eeed27452d5b883d34deb886cd5bc30532627f8700eaff29e1d095d33d6d7f03e804d05673883a694a7a43bcb8883405405689e220722584c72a88b7e4bf2d9e7609d6ca04286587137f1cb2562c770e8e5880a4ea76f4a9278afa3655b15e931256cd7f5754","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
