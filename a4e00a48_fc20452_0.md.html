<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d172b65a0156d12651d612bf292609ae85ac7d41674d7cfded7300b695b10b4e0e495571594c4dfda7e8692a96ed9092d99f0b547cfe3f6661b87ad93e7f0c5c0d5156fd4a93dd81030d317b847d71d27caaacdb029b471f5748afe7cc48fbd15466491855fc848fbd8860e154c68770abb4747646fbce55f50b65ee3d3729e1c7dffa438bf33a21d29692147d003c41e9d606029ff6f5fa412f32871766c56d4b0aa032f89f3cd3655f90a753ef6d7f7a0d50f5e8524fa1e9cf32a24c3b27f88a274db5ee9a82c691dfb210309fe156868b09591066bb012645d6ab78cbd81a1f411fbb838a699a368c832761504bbf2934f972656ed3cc3cbdff3b0f8e98c888197d1f5d44aa00bcc6c48cc9c978737479b49d3d6008cb5650d72d653dda795acffee4fe33485ea9a4f3881db6ebcbcebe9c198763234011f290d1e1e604b38bdcab79afb583db62bc88050d642c0aacb583ffcd70f4b4ccc7a173cb18ddbc1e902cc1b6c09f316cf0bc7dffb25d2a0ac1b7ce4715ba8dcde28f2d9718cd4fa42dc98df4e2ef4330929e71596668695750e983036641533ee7519287efaf829001f090ffea42af9856fdcbf380f884cf9e1cadfd669e2e0fdaf74b2abc174d02a4413c11e66f4d57a068258c4dc0db8ceecedf66196eaaf4f469b108ed82cb2aed3c6def1dc6977e513fd26605e699de07d90b66fb13f44d2536ef3b29a0d69802bcd7a025f969a1632a782098c7b2279d72d182112facc3123a4e3a7d6a82d936efb517807a3f467f8826cbcd12c2f89c335da341406538ed3d395857bc5942d8337c67c42667e609076f3559b84c7b9fa154edf1765bed2d59eeb9d7813b69c4c012f8eebe083e04ab0174c3bd62348f85484fe9f952fdae76321642df06d403a872d085e8f7e04e18d56690c0a2bb62b3e343d4307d1c059e4dfef8497812b5ad728e5e912b7cdc019b63e37311b8ae0ad7681d7e7d0fe606022db300e887f05819ef3e5adcc31da5eaecac3103927110f769fe10c9bf43dddcc80b3dc840f7377d4b4f9544a85e910cdbec071739ae2d5571081d5fa9b9bbe5a8003729fb8e46b7dc7e8681c8f23da294ae032c45c14daf7d9808548b4fe42c2f0e1a336405d7256892f733a383852ddb31b85210baca8d4791c94b5816459bd560e5ddb8995bf365db9a649add13e54fca7052d7a6fd85ad81e15fd8723f6b05428e76380a716b34ce94e0f88ea4091c0eb4477cbb063ee7e3bb07938f54d21a5136a5b1ec93940cea0e7d77cf9abfd6e50e2ca621892f9f2396242683f83761deff064123c6e2500140c86a225e8f0c3036f49ee7c330043350498657c2b886ca5f75d21c4dcd14b36b9f0f499d88f6714a42357507805f2414268610897f207dd152067876642d0da25f03e8122d3dfe700db524e42c4aa1a5ebad31c71d4ec8d0c156bbf8b2b1d8edafe5db46fedc83ec9218b0082d8b40633f216f1d42878249cce6064642431ce9027d2a790efd2686a8a8cc2b0b493342c8230d3c93bdeefab4233ef6fb567abe4afcb15b5947a3946276e92404fd47dc4d91c9b3cff5b3dd30fa6c8cb8d197c10f4e77412e0b8ed26dbbb6e11f43ea5219a5dc27693a715fffc3e12e4b73058b4698823652d01e85b380b0049153360e761e55ff28f59afaea0ea16f5c84027c93b2b174cfaa1bf4379345c8c5aae9d9d1d53c9547cad062e03c4e729e6fbb4e32a85678295e35f6114db053e20bf442deb699ae0fec5a4b3ff827cd4c3c3fff4c2bdd9fdb86f10ab6b16d83ae672e6544bf05869a5e2bcf348ad2875296e5ce6e29fa17151061e8df39da0343c704b8ba99b94f5881fae18797716aab4c5de8213f5ffb004da020048aefc36e1a5843c2f0c0f6af18d9bc4ff44a3762336c29bd9faea737c27b4134feec28a09f909310fde1b8ebc561f852d07bf203ef18306facd0dca1ecaecc434bddc804a25c9bb6fadadddeb29c62a540d59861a5ceecd4742ce6e9855118d72a469fb25986fd740d5badff458f61888174196b4eba7d0c370c081f427adb2da63458f4d5030d79aa78813d4c1d3e3f72ff8c4aecd9fc007fe3596736b708d63855b2c93224af40dccaea1e958480ad7970f9176ea72a81ef58ff16401cbbb0b6117aa16789ccbcf53cdaa84cd301f9d9f1d42745a72562532601e8f952c983a2e971b7b2e76f9c90c5b8919028ef87bc3800636877469832ef9230c34f1202a57028d83f786001f4f6799f708ab8c6c668a5b1e821282c05021d8ba3adeb8abc8e69fafe97148a9ae9ac777afb1134b20c8e4620ca997352e69e6fe5e6594175b1554eea8705f19e8e4e1f4139bea786ef43b1c169ad799f59097c77c349ccd6e1e4588af5ab73bf413ecb7ff2ab3cb681b3f4fe709b9229089660dcc18c5a5d6882255afec6e937ef45f513012965a97b717bca442d429ce2c14c4be02eac4f90a76ed5a81bb32bc91c898d693e4a4f907235a0c1994cf19235e24b806c0bc01502565aa2a2c063a1dca56ee82ddcca041a2dbfe0722ed16a046380db449ef52fb411d58f8047eead5d841dc6754a210115bef8a8604188942cf907fe888d334bbbc0faa651964e867d8dc94ba73a9a32b765dcdc14a5b5b00dd5b24e307cd44566a67955851c076f70910778ec528d7be5bded607f37f14a83c90ffb1c34a458dd52157a852c870466f51878bd096485da62c4357681fe0245840c91ce13fcfbaf108bbd9a21c843aa18b65b6cc0c20fbebe8699ca551f3d8a6d105ea518595a0b38122967d41a835da21a43eb07a19a4f041fa5b379b9bd44bda947699dab57e121412346657911a9d2a0194902d63849cb7c15ea142ec1b8ab0e8af1442079dfb16f293124b437cad82dc113c45d545730d376e12e6536a04852c089f9621bb17efd8eea5cef89f33a5bc4de09e6222035f004fd0cec7655ac87841df5d5ebfab6079b6674b8ad716f463001c57a0e97b759605ca2883a7c1b4e4f8f11e6d3bc8f9be2f558c1903fc176740d58a94dd614c4b0411364308a670d131d24b59ff4c151ada49aa92d233a947583c3caeaee9ccb355cc329f97d31d99c2d0fb7c9ab5b46c8ec98a4892143d374f9f7ce315cf409ac4a7740674bee0c56c882fb34bbba689947a175df23c969af510fa870ce1ae5048e6e2a8ff1afb8b52e6904ea853d373aa5c6970241ce643a4316b8401b126114e39c2496d81ba92898abc06e1ea2a13ac061d6d042252ad5c0d56a109ba06abd31e3a56eef40d37499129b9c3e8502f7d5c0db737e33f74c5d4775429e5922afbf9b78878bba8be67466a441cf438fb4e2f4effc073de67b3baaa5ed009a6f73e02bd1732cf8cf4b061edaff992238b6db03c171c5dcee3068e0bb32e0ee054c7fa0af22092dc181fad2bb4c117d06f704ff73252969ac4d9b52cf3a5027a8db2a8ef77369c272d0ba383574ffd584f19210bf906f3a106d46ca0ac41a8693a8c114f56be3bbabd75b21cbb9e4f69941e139b2e83093ad53a2cc511a7f78149738b10ba1d569b40b9ecbd99679c737e7aaf841b31c10d1d94a76a4618d6267392f35b31623fe6f963b850d031914cf40e1e8eb256228fd86f6ccfe425cc8d8e48ae7fabd3d6e553b79e13c3814dc9ec49bd8dab4c6cf074b8ab3da1c0bb63a8ff0563f8c49f2beef984a9fd1af20ca39dcbece159d78569aba031e49f4f2f943b1f7e9b8edc3efd8c5fad0ac38bac0a329b68396d0f72ef90a86eae9f8e9d90ec47d26765bdd02fd9c79cb395d54ab06dfb92dbbe07d89632d3f259867713093dc867dc474acf82e07d2c3d87cc85041905ce2944dd35575774ef1d0259191136cbc119124de1d160229f594e4c854ab88e946a128492e7dc89d1ad1730fb90d3e1685a139450b3ebd883f6e1fbc4b1111360dc8a10fc16212fb907081ae254fe2104fdc8da6ccf3ea5500df9f8bf32024a39ecaa8368c30a723d64648ac25ca7abdc18d2b1b7bcaed364ee9b592da222bc4ef818bef60c4590bc4d1fff826ff1cae9a2fae81aeb38b64023abfc4c7868025559b3314f83cf022f01d2ae2f173aa1b99bbaa703fbeece03e4212a27075d1fc33687e86a90bfdbba535aedd43241f06513a6579b5e3be502af06b847c593cabd50470616714a7d4a60dff5c75bbfb8e62503bf16dcd2824a52faa4727ea6e29e9bff079c224ef9b9cd3f11d1099658b2454d37bd09f7f500c632335d83801b69aa562f4640079cfce059122302ff22e32a4a2a77a1278ffa7deb165ef495229553679c4e080987a4a55d486c6233a822d1707209e09ec60a60a07f9d3ea33be0bdaff097ad0ce7cb6a455858946186c79a1d65268cf1570ea282ae8cc9a1ebaf7b8bc1186e8fc1eaf75c8a8db0a78c2806080f247ad6768a9612045b22a9cb8c0d8c082135fba61704913d10afdd071699c761811391dcbaa58348b785b2423de7e26986e2521960ad9d22102ccaf3defd98f1d483105d0c6af297669d271cdeb8bd1f09842f80fd3d93074d7b52fb59c1e1b7e060c4e6f9eaf9b6bbb0b16e8d6cf55ed82df5b56d64810ee7b05414f4e31b1136cb5959bc44af6bec97badaf8485e69dd3655f7fb82bd2bef8e86a3a2725e4e2e07f29aa7c46320a44db945d50002fc3dcf4e4e4ea5be6c45b8a5e0b9734744df81adcc79ed2bd13d1e5e8e1e083943ea8d3c4cd61d127db79662d1000d03eff5cef8a3a2f72690d5e100b1051a393df6f88dbd352acb2fde27622c5148cffc5278c146bffb0981d9bd0ccd343a82fe20b782f8c4d7cd1c278762d4b197a90d16bc4b83478eae2b31733e2c0b519c60c24a86b9762960e16092a8213d732e979f4b4cff0e59cee74c467dc7e82c7af9718885a62034ecc5fa19d4156cb4908371101e1d00c64ed75c306d75338ed53586edc9e65e662c4b47d1fca97b4ab1f5a2508c9f3ce271d14b86e05e0eb80053027f0ad0bf6d2d10bdc6d4cfdd84ec1913e9a269780a3aa6574bcd842d1060c2d61faef18cfc0b470b48d7ff051afa55f328246e166be70ab051a7dc939f756d111c8e4eeb85086b48351dc4cad563d3dd6999dec50c44e4a4678139404b25f3df6ef7e783e1b881a839545c9b7c50f847677cbbbfe883e2189bbcec1d870114abf527766dac97a17143194dda15c641e128b7d66711dcd6fd69af31debec0f0112a6d4877269d3ecbd922011a7e23820f8e79d6eafdfa7a874caf0702e4ab3d8a2092d849b892fb2014135554aad5efa504c3197f46140885b7a6c9e8320d32c210803a56adbacd0d2dce60c8bee0039f8070e218bb68eeb50b57c31d7213a5b615126e06ac989fa9404601964b84fa81ecb3e8f705f8ec44d7104d7f8cccc39c4ef2a12192c7a7bb44b0f546413106feda097ae482280dfc538175b7b2154c5ff7a3d2b49d6ad7813b52bea370c78ba2a780ea5336ea07f7707a961477d791a839a0d7487b0be55f4666c6f73188016dc5c44109136414d33e818f761c150ac195ccef1ccb0670bb82b4b17c5c4ad6aa320b424a1cfc187bb7350ef2e8b092a47f692aa6915db281cd9eda28ecc8783c0146f383ddaf9d7e381364d47e032b82864b2fd973760974c4eec34dccca26ea83d9302a3b19aeaadf933ce068c513564d96aeb6b6f0c577476525ba0a1e2fd8a01eea223b3e7c0b9017e3d6daa04767274b372eef92de1fa2b73e35dae32a6a3f6f4f83011356bca73955ad6e3f962a7297bd76a567576de82c942cae97fe14169de5cfde5ea0527eac5e0c112b8f63f39456dd7f6aa72b7afd86d235eaa4a41dcf99cd96b731cf273acf2eba05f2e97eec50a5ff966ac94f90b410be0ce2c30bb4f3fed627d933a2cd6a4ae4de3302065c870314583f1a3aead134caf0a47e2907fd690a0ac5746ba892cc711ac99b13114b42f5e8374af011026fce91a1e16058effbed1ead7a66cf8aac351ed656c619cdabd3daed942ab3a88a5385eef453facad57d33effdbd0919754f5441c7f1f75f504b58a8db19e7d8b4496db2d0e15809c7888d87bbc486cf6d60665f693e967e4df223417825ebfaafccff5a90833670af200d98e7778724421aa2613742239c28d32bc1e7efa1f3d856df88b17fac7a4c425016a38f17b7f5e67169b193425a965b958fff15c0c655a70778439836338ec9d58ac9a49e4154b9b0e33f608f1e3ebd5f8565e806be3c8e992531f2aa7813b808abf22c4c39bc4ad55e9040a38eab51f3dfb75898697f6ee957312b45bce7d81e56937dbe8fa744960a21a974b8d28fb3693df9b5e9ee138e1dedda2ff0809a1320252c27d28c2686ba5a4454911b34cfba5c00986bc268aedf8993b96624bd70e6dfbaf1afb828c1121c9a5b1bd6910807b5598949639a35075d6c0a29c4cf54b9425cdd0f40e9e7d371d512c4f5c6582e28a4a4613db12963a06dcfa1768f2726e949b8d16c791bd2dae1f32f5a2552f1e124206bccce3545b385217da40edf3975b84edfba2ec81dfce188d12922883b2cd0608f1f6324e80d043355f114829efe5bfbaca0c7978ad873bf88ed88a5d8ec82fc26a0ab246b90aa10ba3c7e6bb2341286250660e5bfddaef2d828a6ef1980a4deed0b7c2715fdb6656281412af64fcef84620f63b9a87ca154ae49b1b55d57035d4e9ea634907f163a2664f0b09f319a6f07d6dc279227a252e39e10d8368e240746e7dff7af6610874810ecc505bbc489c8e2820920e701eb05a6cb410f0c4715f68d2021b12cad49083505752df9cca2c26d669982f24267f3ed82a325e8b7f68cf412822c124095519fa0c53880a9c1cbc024a77c5207caca977471bf22321322fd2aa7aca70a698a23ad68022005e5877b04a2945b071a6a40e4f67f66fed1043815801874c7d373ffd799b2fc4de0fd6ab4fa9234e344bf0391617c31bb04955e52287c8129dd9f24faecf4612911d5f117774b708d582552cb6a73eff14f272f35ea7579a6ec50752f11eef48ad877c4d71e3888a5ad42eef36deece8285e7a57b990141c599ecbea1ede701d00acbd99244dc7ee372edcad901b85fafd50ab2c9f46456715e2d20a300621682fd55d79a9a7bd6a7febd7f3c971dfaf9e0979d161ffce10e48e65ae69bfc2d86fe5f2cc024287b42d9197e7632a871040b4c2e0e3ae9c9017941acf6d551657d6d46d796e02d5199434e651e01a80aeda92e6ee41acf02ad74ee44ab291d5788f1e8472f3866cfcae0b91063adca7dd6a79888b09862bd247cf9b6db38725a6c04f57d6ddd31b44a42045b0e7087ca5134cc7a56a1d3c43d2e294c1e99349a0de7845b36c24a466cb7998339ef7c4b0520c6346f81411e70a659db2f38411a77e81fd62fe5d2e454f2a45f0c7eb562e25359312376afd571f4a11dda187d5d447dcd71f9b3eb7ef9ac0ce990a611ab185ba3a33e9bd1746bcf90afc61cb8a6b595996c7fce46a42146fe0bd8e1d6516b7ac064f97b76318b04e2cfe40b73ef6de2343a8e8a5b09d933df9a10bf372b8d07b70ec37d87ba31e86f456e3837f5a55748b2b2a73a185f27c87c1ab9a3bbe605192711c93550d2d5234c7788a13aacea3068b303a3ea654b4fa64aede64e8b171c3a441b8b87d25681228ec91dc5129cba12001b824875ca4262eb452c5c0e808277deafa207459fc504f521e8d9b56928b063e255ceeed78dac26207633f9c5550db8756980a03bf77ecfed321e1733837e741914f9eaf130e5ab58dff967e485d745fe7755f0cdc934a4662f6b5384771f73abcf9b27f6cca254754080ac235373c457a1a3a75e2c1aa18e9a80f11daae838866a5663c93160877b8d8e8f2fc87f18d46402bf2ca5817ea59e5264a1062b9b815621a6a4702325e7c2320dda9a5f7d4c75ed06cef52e953ccad72849475b9eb680087d43c62ebb63d1745dacbf3689b2b89863fe9dbd087c5da35727babac4724d3911750ab44569256dd4d6280e09e38bb17602b82c97585cb6bfb628e1050d1681ca66a5567315631b9d545e0e9010107b372f458a4560c38049413076647bbb2a8b2ee93c399cec601e9f2d29871575f3ce96c71470eb448a72875c807f58849d157b4ed00910a671e232c87835f3df6c4fb2c0b76db40adec25a3ac8607a4dfe2fd4a3bf9b757263c13357f75b63ab22bccbde16c2860130a03627a099c98147293386240a37fa2e14dfc6135f5a02d6db62ab0e45d70926db82bedd1f9ece1025e584be4e76e6b72f9ad88ccbb7ea0d5dbd8d8ccefd81aa590fcf6d2cdf7a4d346a2d1584f042c610b133d98f7c9534c1062fd292f21177b7d3b24c6cad71bf7844daf9e88a3f140d3d97c7bcc838d8befe63d419953c50bdc0b64b0527c73678777cadfa9f11f9162ebcb6d5fcb488daf810a2c918dc7c6078651b33e66c41e92b3c162205aa289868220d0666fc7f56376240d75d1973f5a45302d4ad3b88f7968a6ad85d06b1e3762668f0d376fbcf453d92e18a7f7e09917b28c952eefca7e47c465c1a6aca3ef6596d96c7bd799bdca10a74e1e409e1b777e41e3c6f5ec49a2712a403afa90c557c6fae4b55c152b2d08285f594da8a5277f1bee1391690383a1f546918289505d020a5450a320af085ac717feae6302e63765f88e28d43a465f90a17d979500114c62261c2df49819c44ab88900071c4b08c434368e63b26cb2dc4c42fb9f611a296e6da718b4a73ae57d2ebc63aadf76b30ad2870131abba1dfcc1373ab3731d8e6c93a76a6f838128503cb23a844ae856fb62b0aab0e0728d7250e4aa78b1c87707040dc6bbad419b0b02f4bba226590bca7641638be3bdbe5ac01e096cf24b9727655adcfd5fbab17a28a19a33101258d9ed4d70a0b28a3e91322af28c6dfd8148e5b8bb20c5f4a312311eb646b50e237343f1eec8767b73e25bf78336ef97ac91d72d61b3cd2b822775123d243b11b70eb86e84af10c7b1d2938d6ddcb4e5f4231f4091d50c4e1881d775e00d9840f107f91528c5d2eac273f56e98662c92a320ec16fc67a59fbd459cad32610042a74e642f0b7a616a3836fdea789a39ee6f84c111b6535ebab66b2e4047215fd6fb192c69adcff633699ae50eeb4c2a58348a48fcb2d29771269784acbb95ac498dbcb46c8f7605a3df433a4d6dd90e97788f97795c197e864cfa21067b0173a5fcb25d33df4a29c82253e5825d386c2aa87d98a3757628f0171159f54ca704a88d1f8a80f3dc73789141390d75a000968b2c0d2be50ac313e21a808b69d6cc5375e99ebd7adbf1b306aca9ad03e24ff7157ceab3d160bdc70c9c823ea2011b5a90328198f24a1023e383afbd8c9363e320d4415035802f73b4925bcf9f36e895576f51a87379f9c5ea1559827fcb1946b602a12141f76dbcda810c643a029a9b7882123eebaca048cc0bf5c019814b8531b86ed39bb78c31cbe5282709e14a88403745ca52f29796e023664e665dc02e6be7c80c3067843d0e207daa10fade457f3954bfe4e701aef0cd18688266ca2fd718ac9323851a2fb4a01643d3073ae524add1c5ad1de517a0d126f8df2eeebb6e45c2110f830edff389600369b9dbc63ff5b3c565cac2e1ec1b6d84643a8a19937a37324301919d15240e638671ebbcfb796308f6ce73f76cc0872c8c3360b142d02e0ce2bdfed5ce4325d4ae1e905bb6d2d2590144eea3791634bda430e0f526835b4c488ef471cf978476eb08d89f982501bcf5d16b6b227bb1b372bf21765c0899405caa022f2d7190a4799e8f54e972d48041deb749a5f581fba1d35a6324634a7977b22438d10a16ced3d1116dafe255f19d69bb87e3aa27b2a7184818f9ca23afb70febce7d72e25d0cfc1a6caada8c66c8a02916b1c272a125a6339450d4403bcf047f0827eb837b234e3589cffc68bd5e9aeb6f74887de0341d48ed8ce51cf7d42b77e4c9c87ec74d83fc7636d91937a31a6813a44c7c5806482a4ae901259a4a49339ebdc592989bf657f83e54d12e3cfe4a32448cc37172c6e7a3df6dade4101aac7b33f43d96246145afc8d1d36c2a35a90e071f2949adf74401367edfbeba1427234df215324e577395d95dba80da51ef1bde977dc7520790eb4cb05b65ce4341f90ba2f0f8145db1192b1480af58bd2fda2d03cdcfe9a737af45cd1f4956e80b368e001b0a950333594974be78725d6f950065384e9817cabc0938b0e9b02991323932a58dff783883716f561c56b7e93c48a1e5822d25bf1b2c48d18ef16c24e7fab302f5708c85279c48a5337e21f37c4970dc477f9292b8db80119ff8fbb14853d57a5cc487e885f56f6e8888958b35b9038d18cc93a9d16ccfce1d5db86e2b82bd9abcd98c495d56675c24eb2be5fba5bfc9ef6c316241f7f6623bf4a67866f6f1e6d1c6a79c05243561652da6245362da5c9f6b58d56a5011dcbc4b079011a73da5936bc797cc4d69c03a5456c79fb8519f8a03686521cecbb88c4af8d3dfdf552d0878db3c58e15306bf8573d3e40efa91b8c26cf80e6beb5e779dec1289e499c3dbc36b3967c0be8087bea054f1f7535e1b3411b5879080126a70e4db6e2d58f948f0c851b2d2db17a7039caad91e0e32ab7ee6587872057af1fd8dcace4e40055f69636cb9b84be5af766751388ea58b4ced6c729b0e77f602e2bc9122","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
