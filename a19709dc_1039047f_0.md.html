<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12282472a3a22baa176f25da29a0f5099551416071e8ddbc2fa3cd8fd7455a427b0da9acb477361bb965c0863b9548e394a8b9e434ed75ead44e175a6870ddce2deb5971e8308f8160cfac0e66e9305b2fb3f7dc9c04637196811d58743ee5439ef3271aecce80fb608dc0673e6aff12ceff31b446066bb464f67fb08f4a737d437ecb067912e05869ab7ef76573e0a4f0068eca0df84cbe26fc2a4fffe298fd7146b3b4dac2c3971d36800ea143d22ee01e81a30aa0f02d07a7e6279d82b33743fdf169c26dc0bdabc5835bdd36ba5b1b6ccd6f3cecba30ecc38b20b50a8e915a66e47cca6a8b04e7763625011062f5c6745c02798e4e69e1a8c93d422ce3be893deaccb19c42687de106d1cdaa31ed82455eb2d660b8f14f98a07a6857895d66abbba50f2db2172df48b22afb189cd8349cf838ada5ab68de922a655292eeeae6a8c5e568104731d16e71bd82a33b16ef55cc1ab999667709cf115e1b9c4bc293b59bb79f487de49a13bf395fc336512b40b06a01f86fd546a8c5e5dcb7e185d8498de62c4e8854ebe8615f6816a680a1cf978c97fb1b878545437a34c1aa6bd6d8dd627394ffabf839a06b483db779873cbcad31795ae6f49759e52bb2e293b810fca8d48d3577900d8285b53fa8c670c9e2a0e4f7049bfc8db71cb71c464f85aa83fbde7dfebfc0114e261e551b4a98da013d715ea241c29ace89b658f08e96244fe1f6d0e649de4bb60b7ed2c228d11af2d17e32d03a83c0a878a4eb00a72035171bd7ca4667df90a67f6b2c7d39b712bf5d271d0d15e16df41cadfe946484783c69b2af4a762d43d8130ca74f345ed577b00ae95e301260f6321a6a0c2b8ccded712660f768bdd8405f455cf0b732daa3e490c4c7f4d8a69d3c07eeff5832df9e5d197c0babf3be84746be00069c6f8ec6e45e83628764f49dba2207423dd4a419de9c881b4380018009ddcb31e5756452e6e1992e44748f5a507f20a65f8c8e853ee19806f6b3f2e72be60d2e005a1142595597ef435bc14deb6e228ee3bb043b7ab678b4c3fbf1377e63ffe064d8e3055f697d95bd0ce1c3d32c1b0b2adc3f3cc5b019896717441314408b27117808f5035cc350fc445fa1947c9e5ee70c85e5c5e18f6c08acbe3a69bff8e60f9c361285164023c0ac14a8819eca4d94104ce246ed8baea41540be5b94472dc1f53c9e14cdf35f503a6a3ddd4b164fda44fb6e9e7faa19aa8398153be9f4aa61c4a727410e6cb7eccba6a4f032ed785ba5d344b9a4a1ea7fcc88c316a48770b28674cad3aa458b54c9a1a3a1b5050e88074a3bb97bfd9e92f836b9ba0368fb66846f71cd5d81365bb969285c5c4769951794ae7848dd1901d87a3bff28b6c87f7de67541005a210ded7efeef23cf85db6727dca6b26bd892564c942bb2a2dc4a3f53c4b47483447171be93d18c8245a23a3a824c1810b2f21aa293d58646cffe726c19553ad81957057276af9553323f9726793eb535a5f059b411693605df75ba72fec47d0d03c2f2e43d69e96b6d6b9ffded20323f2dfcd609194d305205f3358f05802cc6499dca853fb5c82dd5a9bea8dd58b66e7e84b5be56956de88b88c82a8d09d61f0ee9cbde7d6d788ac7c4bf9a2d020fbe7662de816aeee93d7b5aa4b9a35c81a1a6c96bd3becf3629795bb01d8eadb82e421cdcf808ef3d13136859965c20497f965149d5982b6978de663d1a51f728ace93dbfbd2abd3e2ff78880a2f02d313848b549c444e543905e81b2ee1573a45116bd1bf9a83158009a3f514dcc261456e61367d05327c15b064014b1b23405c121727d69cf4f71e736a3ff6fa51c831bd680dfef2bbbd342f4bde8a9bcdcd2146528eb55d3f0e74a621f382c2217385b68d3ea81c91c56c578ce33fb7191715100ab7058d0e6b8755ad8063f50f6a489cdab28e21214df26481ad548f8577b2b52bce9a4532c318923d9b4511ff9b554a547d912bbe56f214bacf4c970fc66bf7fab9bb1a2045333a4bb192a5a91c9be78542bcbbd3281bff19d9e1be312ba01ccad2dd9a70552c8c113f8f43167bbd0746be62752828870185837c57e203db73f3dc2e988b29c717041a9de1a2e95812c9820e5fe50a57a37f77de10cd96129f162e3b0b53bc60cb99e5a21df31f19ea4eb529cee530d591f8dbc141fb41739b86d16070f3389b286545a5d00840c6b9e11ea3d0f6752b81bd793890048357d52543898a2629f985c15aa56d68cbb1842f06a82ec26ec1892e765cf53284b9af7885565f9fd0d13c65ad0e2b2c0cfb43a34015f77afb6814fc8788aff40e110331f31c4172807b0b1cce1e618d5dac90af1a6c8352eb8ed91b29aa7e3e1934e3c34b0f99affa3068f5a1154707c8dcdb06b0b44774f8ef1f541eb30bf0d6c34ef42b6472f82dbc2a0b89240506db5d6863f23b4b566243d1571e2be599544582ec7992d7535f22bcf60eeaeff9c24f3d3ee31b27542aa99166d36ccd1e308b43a6d292c08b755aa95d8bf539e16f59252c048bf580bde4f931292d31f5d23bd9aaf959b43cd300d6ee28af315084b9b2d6b1541692384b15e50578140131abd94b8be53b584455ad7e7d21be40d3d8482ae4b454e09858b359778d59fffb90704d1915bf7c414e51adafe4b94ee8f56c3612e444926f0059a8955b5538af88b08e2dc4c8ad0c7f30084ae64832ef916616d52607b8706286de3701a02dff9a3d839fe24b3064364ff72f688b08e86ddda9aa99d5f8c61014ef8496e1d27cf30d060a26a0436b59e15be99a001c17683d9deb001bfdd41330072e61fe99d00cb5e49311dcabfd957d0ce3c3b63a6cee43ac27dacf30d2186fcc599c3866aff1b0a9e3721f452fe19106eb0177d9ef0d9d40092fe206dfb70c9abf523f933310afdfe55026f5bc17442998f948090eb932a8859e216fadb73fa80b22631326c6b2d4fb2762179144379eed1784d884786f201dcf1973cd84f3ceccc1c7c4d9ec4524cad91cec842b9ccbcb0b8048a3be8ecae182595067b0452ca2c9ec84ecf18d4baa301d27d4df0aa3eeee2de8c8ef453a588cdfc9980fb63f55a826a3dfe90a8882784833e26918bd444f925b146835fc3549e846fa6af24b822cd8c7b00753ee933734b87dbf28ecb7b8f0576afb31ca3d6c8d29fb151dfabfc51f96027b8cefbcfc200c1bd5191ce553db13807d90470e09e9a995dfb6be97edb889f3733e7a2a6c11615f3e90bf639993d79d3cd0f909fce8a2961cbd1356c74aab1ed0a80ef99ff7131297ede9fa4faabda216afa3492c9fe9b093b3a7951191a74ea8ed742e39c21e1ba3da196186d06b65de4dab22a004172a8de8de38ef43db11b57643e7d6950893d6f0e310e424e1a316eeaf53b0f1a929915a2977c53d773725449de5ddcc35484a568f86ac3ce30cd7fe92f7b4993ab59af49305532f8e6616800cda61b7f3fe9cdae43d5d91240ee7922fbe8604c7d898e64188f69a3970f3c022e54524c052509954602e6a989f1518d2a463805b447daabf3bccdd8d6006714734695d625f858bbaf0ab9230be0542ca39b0ca3f72e9702c06e3a224b02535b5bc4f81adf68d5782c453740fc4050cc68ac29da2dd3c27286e3382eadac30005bc3864b946dcd38d7e528f8be0e7212ca85f388c577d2527617ba36766418b150cf634143ae68e342411bef2c09993f8780255b793c5f4ac4a340926b34aed8b4c9059aec7bc6d28b6bc4f14df102e737b2a44bb69c2751c571b06c9963dae68ba837b91b42a116d40396ec7cfac44b55d54f22ec400d5ca2a6429379b44b9c3f2ffb059fad9d1b7bf4d9e313dccb25101c8e8f2b6770659751369d0befa9a6de7482791a9c21a775373ddcfeae0b685bbfae628f88fd261ebdb9c3c8947b779812fe363552aeb514a563d12fc7ecfe6f8dbfb887b035c33976294095e6bee6e27d2382d853f505c800e2fa3eacfab463f25b39aa1df124e7433ce6a8f392be5a4a229a0a5edfadf5bac951680757fb70c8a3db5d0141e64305d2aa4a2c992145174121f290da1a84093491bc4e3186e790cb825186522dd6ace4132cf62789162e378b374c8cd6b838dae4e3a1fd745869fb94922e77a697041ff4a1cf767aef9194b5acb94ebca208a391974442b61b065d454dd27a5905d179f3df4a2d35331e8c5bc28e3db8a6d6a01ea0b886c3641564ebe28f03d0ae439f485e984f60b93a1b9c22306e86ed56b4b532a87e30c83a93167fb2f6b9a387be4ba6a4a7ec0837dfd47798a23d9aedc2fd566a0aed1c5f31ee3642fd63dd41b2eca6ab4a4f116f170a4d3b58d126bdb47d07f16345dba37da095485b87d8839ad5dd133d2d0b6e6075b6f049e66602765b20137bef48f9cc695fd048554a0537008aef3b4e1d7398bdc2153b5a40590ce8549df75d5fec5599232dc048a7a53350a7c1293d23e56acf104ef1dcf7bfc7b037973b76fb0048566a3244313abe61d5f04521256172feaf6a79757affc15eb989002684a7f72ef269006b49baa92465eb9eadcb060312c201edf8cb048d1aa5f2bdfb9d04f0ca4ed34f26745a4694a8e6fb16ee405dc985cf071c4fd47b140ee17fbe806eb6f2bdb0f4b0f5e83fa1429aac7ef020a47ac847fc9c848283b7aa8a7dfb98ddb6dda69fc362dc90049ffa038fd382ce6fc65c5dad0fc65c8e1705e79af62c945d3904f8fa2b3e55bb07c41c8197bf1bbab470f8dfd4eefeb85934084f6460c2033d84d5d1299bc2ad64c52f5408db5fd8ec96f2df80c81ec024b896d1a9f979d6e40955c8d44d5edd6a8bdf078cbe9b5d3713fa62a82975c7b60840289a06771d691bd9e9cf6fd25390650066030eb51f17182e02b7614a5c4b9d15a7e06c64a792776d7434551885118f2d933151f837711b98ccced5d42f0abe3aba3069365cb98ffc771154f41e5aa0249be5e80d2f114f5c0a87c59ab7921d263c7a442a73734761a8794c05b7c27ac192127e27a5df19447940a51ac4f2888f76e3369289ebdd15ba3b2e43fea18c50ce86a09a888c9afdbbfaa10dfec40db346e3ca74a11ced42192bb723b4a4bc1c44a49a95322c638e7e6341b5f660cd999f7e39d24c3197c41dc515b507f55d25ca51e1341c561a65e8b5ff4758aa5622cd661c00ce42000061c3ea03d30fb9e52eabce0e6486eca96fcc14e0455199ae53d5886329400ff8be33aa21f82d36c35d23972bd444b5890f14cc3f8b36b994f08613f3d46444c146eb41c8311f3fc96d97ba4da457bd526118032fc7f9749b8c465b7dfb04da0f07d91f30f90dfee45d3ab040996abdca25c15d6dfb0b63054d52e0413392fd70ba52a7bd78b7d8e0338c74a19bba08c67a85da24b387899cd5d564d76d47c41b9541d9caacd5978f5d02f21f033522c36b811acd133640e7d3727cf54752c388de1e374bcf6d153eb326e55428c6e511930d385139e5ecec715cfb79f93185d9062e74d1360b9823276b0770d3eac76cc43faf2389a659064dbb9c2f4f14aa4e9cbbcb1d5fb11db90accfdd0c20f49639c26bac36d0b36557bbb381a1dd1709fbb566cda0ee920315768126dbe0496961aa89fae88f2ecd16dea3dfa9c17020d718984b67acd4a7e762b191ce51630f932377a2b8e9a29321f7ca93541b695b0611266c2f4021f5b03f386dcb0e71d8d03a38d2596f97b913046b41ed5f98e29da475e76a5813d914ef0044eefb2089add125adf00ecc5df63fcc6ee2119998e13c254100e35505c56bad3ba2617f1858c7b1d8b008283a9b266c710bfcbd09bf31c011b58b5f478ed92f98cd74de410e2cb13f05e1498b410019d8ca5b8ad759c6e008caf0ce92248a5c9e3ad2e23616ab0f9f843af6810e833332da37eeb1c97a1b2caa569f5cca2e3c9cd9b4d492db3d77b65caa265d2cefdf51a528129b445a90f119177daa0a11792ebc9190d2a052cbcda05041f0311678bf31964d0640cd52df81d99c48ea75967bba0c2672db046129ff3c35b054c1307f4982d4ed03f5b6fa28727caf893a7e77a25d538170aa7e774e715cc16521274eb67fa80f2a7a6d761c78967925109b992cba7869c2d9fdb2e150db795c1bee9aff6d2612f27514045989971b000a8d788bc1b45be5e4bf6a35816905657b47744419b8a4738d5292fdeaf6f9e609a6a11b7936e70a40c3c75b8c1de648ea3c40b5621257fe8791e0f9c4139d18e491dae37a4877bddebaad3ddc27c964e2d0bb1ac6c88c767be8ac7b0a5e676b94b2e6121508bca9633c2965dc3246d9ef6f769abe1f82ddb257f04b03f82222d70a47086a5ca0d497f9bbae2bb8f5778de20a0d9421c0ed74edca4b7382006108ba4ca9a68395fc5bc4ac27db8278c89c8e8d377697cc030039e7d2db702d5324dbc3a633bb51ea4ac064035d8b38572cb96f5a60ae48dfcfdd5cc225a0df3b62cabd8c1db6f43cd8edfe288e2f23268712a269f483757adc0bc0fa3fac3e5dbbbe5c2969893b273678fb9b9897997870ce4208dd317ab2ddcf9e8d238dd980351a8c75caa36190f0fb076f403cdd4871b2a0fcc1552d3ced3cd319a1fb5b46860b1253c9350210359603da4048e0a46c48756702d52332323a7b935c11c6d3c9522413a0f4a619bb955008c2e0c83e496181bedafe878fa3e4376500d8017150cf3f5e97851fcdc4f0ca5d42f0a95cb96e966d3cedb73b59aa19ef9092aff1c7c97f75215545ebfc6fd3f0f657fcedaf6ece3e31e45041d80afbef81188fe6e77612055a17ace0b7b2f56ad73cd35910d1e7f52944fafc612251aff73839a7465cf400d84d27a4238c449ee5dbc33e1ab70eb717afb883241513655fc31833bfc16f7577e47dd83c1efb13d5a2c18abde0ef92e3f6adba09afa21d08792cb24264c1907c773bb14d5410d631554637829c20b4258acdd3b4bcbbb16b6a02b9efa4fe8d6a7d8e109393b7e6eddc6681409e421157268ccb9e64eb7cf7832f789429446e5dfc04e2d5a5575e3f1d0323ed5fe4b5f50600d1505e46457825bc88321bc677dea67b879c149fb852447ed53836cc5462f2744bc1325e3473b72a2131273f80b0c46e0b8a6ed12b7a1a4b817cd734620bb607721e3df346ca62ff3dce6ce8df83f2d7cb4d28334c21a1f534a3a7c5f76986be25b9559b609224b41d5cc950550c3e4029381f0371854f6373703bb2f2f51a64df17e309d6ffee76d0245207f48f6d3d273196a086d3cd64e5a7089dcef33c306086ab69479897dde8d2342022ab9f57a10a7d4bfd3922320fc03138ce2a7aac9f16d310211b98c9a1313e27adbf2f79012984f955e5211edf1f4324c54a6f79a545e2a4c65a5f5e9bc8194c475d4046a84a093279dc2c077efe7c6d6008aee97d94e2c95888c7debd16260f6fbcebea87d8da17c53dc180e3f9c5e62201466551116f421dd54166b695ba72fef4f18d51813ee32d48bc6e490a37749e971cd41f3c2028a36cc8a4db433017957c3169f3bc4e352b77216f4da28906b2a45b5a6adefd52c269d80fbd1750fb40e24762b1dba402fa70d22b82156cd40c6ce937a534024234e8d44cc92d9f2614867976598d7cf549a40c22ca4a52ec873689eee0dcfdb1e266f19bce8bc9b1cbdd7cdc412da148e3e11297202c5beddfb610babfeaa1f72b7db16a23bd2748a605142fa2142ad96b464935ef64a48a1d8f1054ca18a84ff339e53712dcf359a8208a24ccf6f91f98ce558a7a5c17c9d38a25ad2e5d47dae5ade138b5c0f0e67ddb521f686e72a30a7501b625eeeb3c76fed9e2d4b1fcba120d399648437ef95f99f8c316640392b6bf117a401c94c9e5f1570710c61b09009ffe255e618690f1b5bf9d32004d2dbc25d9b7d42f64ef9a71e30f809c2565d68aebe9db0221b25015e7a2da13998cba6cfbda8cc96fcd150dc2b2f96af8a55e52c5d75b7e4e0f13cd26c3b888e2aacd1cf117d97642f35f1762e7d6813beb0844ca8888efe0f820491d6cba66342758a67cfb48401b40c576c3f0c2ff15f133251624d9c347053b910f233ad13a305944e6a90974121e6871a33302f21d3a747aa5d0054078864c5af09d953ea79746ae39ff8201d61263c22790bd3478c2f96f5e9781552d8f3f6548a6cee4aa1c816d354b5301576b980d5460642cbfd36fdd2e64286d4cc6714a401e041af33da46afb02a9abdc20b85c217ae06f4ae78418b24942a61525439df76b20fa60539c3d8f47b1671f805babe4e0b0c5111de5c65e38eed1ef3588eade9a7e211c031be162d6efbc07627eb645801f4d88198a9cae96e537869229cceb09ebd58827673d88c8070943823f49dba2af0377abba26096200dc641645d39b11163d02403cc770a0db5206264a5bb69efc60d127bf1028377799111fa93eeef8786b482ea3511f6334102f4622af7cccf252427e8676471329089944cb30ea13a5d4448a5902451fe144f6865f4570a8d73a6f588b8d16b84c895d97e10aa0534e42f15f3c7d6cd6cf2288829b535cd83e00bb65a85886d200df710851cd086bfcdeb37cceb1a222cc4dca8fd35204ddfa9fcd02e79196b0cfc963d112f2fce0763031c1513885077bd8ed57d7fed4af0fa108bad26ae3d55eebe91bc45d03a484d8e36","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
