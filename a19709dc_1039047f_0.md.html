<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca5d4a4c0ed7916d63b3ea4dfa4328200b611dba5be1f3651f227fdb789e94285f3e9243cbb4a586e192ef48ca3dea0c4a8ca9527308d7870e096fb845a84890f49d40011090a6e638374a953502aecfba8d05bf30c997afe80321fdc303aae964fca9395ddea5ebe169beaff3a7c7553cab7d4cc3cbc04ccc0db121185fe39937ee8443afae62f09b85fe80b0d7e805ab7176f7527aefeebe4a813c56b5c90162d449bd1bc50354ad4015c8143fbd6af2b9332baa928adb6f06d6e2e188a8fedafda3ba6623a4067d1ff574c1edb02b21b855a93e21c9aa3465445577460decea2cd20e673868f526ceb8a8ed26959e526135196c336f326a2607fc14f7351c59629f029d60fa1d09f8939d1f3da9dec6c0156f7abd7e8f174d38e20dbd8d0fdfce5521ddb52239a82c9f9d6a509a6e0bd34926bb1f3b3fba704cebc89c26e98acbf1fa3ee260849ae46d2dc26f73d43dfc94ab6bc5b19d33e6edb0ca03f7f5310b58a25c6a5dbd4ef070f211bf4680af3c3f6c4b573e764bdfcada9bbc2078a0a17310141d409f1f82881c2eebf22db11dbebc4c667ffe7da21d8c710cd6427f794bb1ea4a15849e96cc9e3c3cb1bb84f1cc5840defbfd8f0238b89bfad5e37af1bf837328e18b0c2e74f4723d61be3a811089d3b3efb63173910dcbc2a553d75940c0e26dafe97321335ff14a58229b3f7ddd0e85de06d75454760879d4e85ee4ccac4794cb1c226417608b4ebe1974a9db49d9417c855bba73a8c63a6f9f04468e27de07dfbc67c6fb51be891b267ba16474f31df48e81da3b72a76c82fc77551b1630aba92b61f898b049f84a977dcc359d8f54c8d6393280629d5e03e4a543534a95b080f5db6d1a5f4b0a2c07dc904f59859bc669ee153fd7c4a92b90a7844e8428c88c39b0a76fc89b13dafc241ea1955e5d9f212f818879c49fd3e6ae81b2263f7602a6e5cbcf6ed7546ecd02b6d531659ca59c336eca0290718c89bfcc9030bc1f602f7c47ef73900810ec5a61f749851031326c4533f1e3a2e5bafcb147bd86fe163175232af3bf2b460e2204d2bba4132a630cd0cd5bc3db8b9dfbbbde21fc458c73fd16cc3a1cb7596be7bc087ada905d657d1df16e126213a7672280b30c62c471ea07c974c26434f3cf26f085faaf793777138f47c02afbf3347587e0125543f78bf84a2da95c8ad781641d9668acd205adada3e3019023e55047430323451877a33f468a8a2c7ead495b52221cc169aa35e1c72979ba51977b26e90b97788040d76b18b45678d40c28e0fa527cb7ea91a0bcb8e2314710de0a019d10bf73ebd1199286d39082cb073c669a3d95444080c7479136b12c2d779b76f73aae330bd84666a1bfdf40e96c435e65fd3d9895d7b984f4010ced2c2b5b9065f5f6d99c15979b68506bf0f4b29b411be4d54ff167883b0d4c8c7f6f7bf81aeb600d143204b89e7abb1713179dee6dd58bdfb4c75ab63a6c5f3cb67f890d2ff20ac953647a931d45055cae8f99604ae94db0bcb718b85d2810782860237bf1c4beb20f3dbfd62862788639d62e8f39ba6b9dd9f84636b67d596ee068f28143a28b0d3799e17012387c7cb7fb1cdfc15cdd0522e154d2eb0bc1842a96ace59c0e7f89c8e81f156cf88325668356d4e846042be13b299e1d160d8064cd4e309ec026a7d08d2a0cc5e27a2d0593cc3e4464b2e7942f55f42e09368ad3637818c6c22451f150146155ad2be1562b9b0d73e8c690dc75356c745471b23f68607dd5152a1d68008acc6b8048944aaa6903a6aadc7b8d9bc4b2872811f55cd3b85cc82d1df626e90c50cc8ad684d62e30928f3351182be25e500900ef9941cdf36402294b173f530e9c1e5f92db9667d5a5e77bd54af22a20cc3babd282650ab31b9ea62274b6f77932c103a8cb5c95c96d7b93b08d9bee8967c76078f59f440987f9a1bfa00ee6a85b5cc070ee7885ff7365b57e62626dfff881a95fe665cc70a2bfe2ac0ca50179615afe0790a31345c0a23dfbbba400d5938f4ee9e3a0edd003a8d6dfc5c67b9649139d6b8343c52bec541c3880e77cc6db910b006c5729d861afdb359c8f508664a75845f7ec92463a520696429beaa7b168c4a4a1a32ff7f52b5d368ceef5df54356ee72ea4287b7bcee711c8ea97ed478c331f8b533ac4963448fd5eed46a16ca3fd4c66c1cbed8af35e326f622d3d1eadbe33f4954d37643f0aafe58751300d1c633e34cc00c65be36f6b701fb211cd1ab7c99ff9ef9f4ce2ec0a03c4dc246a875c77dffcc167fd80c02346824fad6cbe7244fcf8bf4e631c1411bb0fd29ceda9c5776288a2cf0279a8e23df68e7ce5bb98a646a17204a473df7d14971cc1ce09486f062d3533b351e199826d92329ab3111957a1114df3879184693448d86cdc28f59f313f4b31b7d5032ee770bc5bfbcc1a80edda89cbe71ee208f51c4a4e5412b37964dbad7fc8d3fd721c6ede6fb8ff8dddadd022ac7d352f3b86962cc8360e9eead22aff3a15daa33d6b59d42bec72f6e39a3f437e292c0a0a7d92a7438b8862684733ee5bf4e61a8b796d753d752e40543294ce20367c32af3e2d5d343272a8d9ad7a6b13cc29b3efb528b968dbe65a5da637ba04fa3d4d8cec5cfaae83d52cd9026363f83fc336d30dcc69c41b0e61580247870f622fd361fade54951e76bc3220451e6b8cf3e06d50953f6ad98824e3ed8dbf19b11b9e25804390655705a45a43d197e0ae1876bd8aea0dd08a8b569ae4322e95b5422e3bc62284ae20670068101e84cb7074ed7677ec479529237cfe725308eff468722c8f7cf137ced003a33fd664e45ee3300e3b472112a428866aeb00bc2ec8736bb071f5aa2b2ea28162d6dc50d5a01e737231e8c9601926d2fa2b139a151466871500fbafaedc1f19317320f3c29cf30d1ab4a16fe72ddc56ade6ab29d314484924bdfe30e0f0e2ef83b56350c1a5a81d268a7d5e64363626ea3d1f8b7cd952af1fdbf392e7b2a89b35f17aa6011e380adf70a3e84cf12323139cdf6a326c6a1ef87f5fc1daf0a16cb63b8cf66e8007fb1f082dd67929d9b25830772965f6610f7d8560c059025160e51ed47d474317ecddd8d02689d3e4b3b3ad5c86155f60089285fd2de3dd51e92c39d2fa761a118b4edd54a864a8ac74f1680fbbb721349f90743563590e38cdca6303f9f9675f4b646e83caf5649ff61f077349bcde3523ece2ec7a6e24d581038967c5dc73659e25ca72fb4f4aa8bc2c519636527dc21da5b64dfb3c98e8cb29b71a6b58b492eedb68757149c4231c01d01467826740c7203ffbd18b9a51067ddc33e77ee70da5687d45f789f7d27885fd75322c59144893b0b76a7ce607c1c85367eb8d744482030e47ff20be0434a2fff4ac46a25f02a47081d75ffaacda6c60a39c28da94b6eedc2b4b0557e4065a63178a3484b851fd2dd4f9aa08130334f6ccd25265a8f35e969c8c025ac78af0df7c035916433618843b257730c7c89ce13c3803871e140f0ccc2507d5993e3a8fee3fdd5d49a5d8a654f901aa85ed347a96784b9c529de12a37cc2a40ba4a451b7e1f6647928b5bdfc4290da0cdd7200f2e216cc03c5079174501d1a5288d27b26abe0400cf5117ef28a0bcbc30c728a66642fb9cc3d927270ccd6412cb6220716ec0f4295cfcc4b35f14df6250af8b554e0e49659a604ce08b12fc9db7e1fd8f2f25d320c244472ce08760b1f88f0800f69e944b48fbaa560a7e680a80875767b2f8482455fef0d96ceae72c6fe2fb6e62f672b95c470b26dc6d49c4fcb7c0613d22ebef44d20a79fc1b5567bf80815925f06816404682927cb986683a60d8e6687e05a6097e1abd40e7957ec676329ec35e741dedfa6a35431c703482ea9541e8bca0c4750cfb92feb8a8f01ce9fb54df5318219f3d6d70fd2d4856e518608c914eab215b5c3baecdfe90ff844cc5e05feb566b968b495c0fa0f13a73ad3357615c23091efa8d76478fea27bb142c0f2f70c1b42c01da5637b4b26f0a09d6e4443a79316cef01bc8f2e727dd82a3d2197db5750520c21a7d1002321ebe0fa9ae650a862a41f883a87d4a0342072bf6045b9694c634539ee8440c85132628baacc5af8cf8b654d1b101aeeb769261ae9d4a75c8ac069d8a33c3b5f6b953333590ca94467fa68efe600d244e621d00983d55a8b2a8bcd90db8b5f26ab362c467362aa48e2b8dd956fb2993fec459d13522b378511c846da526411e436383c5de36000b6de4c5a40816bfcf33e34d2f0099814485aea9781e9e0d3423779cca188660b65b5fcdbf747999ea75bb64c76196a5e85ada946287f55933b9ea8fceeddcfdc0eb7f3f143c44cbad90ffa9f90a83c08d920344d03f700d34b0a11dee0d29a0d5adb073070ac662c45e32bbb16775cafc7381ce9dd4b90bb2b830aa66a1a25137fe6da1c414975e0e96a65bd3a48bcab2de8b0c46cc0d6398c5215bfd52c82a30a15ab9ac550a1489265eff719c6b39037984c4d0b0a912fd782068b0f5b22bd1ac3006b3c82d8a6b935a4315cad665309c83123792bd3beb9436ae3164e23241616a8d479ad28655432c0d90aae4df811229cfb9a0250ae8fef3f724cc9ed83aeb506b7e033f39a7a46c63212b81363d21d9eefc69e1f763248695a97d4061958cb7a05a521ae2fbdb4553ed254a84ded34bcdff25460e4db572d22f639714fbe8640bb1a2fe088aba62ec0e2e5e681a2c6262d24bd47cdfcb43743c1a4cc064134fe6ef667e752fdc987d9443ec9b379b5e2e65edac37bea14ecdddccf418672ed506a947d04512d54618a9fa296dba61bfbc17a573cea1c7a9e0d57af7c1ccfcba11a4d3201ce96063ec06c806baf041ab232a7afec10649552e74a4c78e9c7028e6d2bea73d7f1a7e7752cfab01f7e624d62291fe113b5ba1faf77b1f84fb568467b4575174e9b3b9cf24c78ddf36b2899a1db857848aa82d2ddc35d6fd493bf3160a84c303f9e19024519de6f4ed97fefc2d7af5533d2fc77f1494baa1b5939416639fe347d256609d472613ac1b21898173d8189deaba7625383a3974c02ad00467f1b949b51e3a28887811999de65589b603201560534c9447ba86c98a26c2f080dc67018082afe25d993ddc79f9e06c1b98ebf25a00acd0076482ab90390b36869f83d45542f6403028fe2baefb3fa42984cd3a604e44dfff267da3c4624fe93b5764a678e76a8e72c76b7cf4ca89a06ce084393564bee462dd7e8000f53fbc0c09f9d590f15a4cecbe8b09ac5ee9797aa781c52a2d08337d1d1b8ca8e34af5662317083c66c43dedcd0ccb6ca0c52ccfbaf96d254b158397d2a21c4c81a567a66b780566332b785b9a80d64883056f629dfd04cb681de227d42e098043524e75394828a0eec52bbfc8a25c3a009afc56a5d02c58e360b8c67f4e47606880f47849bb39f88342d1f33f5575156a7897200c069e44ac36745d1a293dc9031b15ba3dda283bc7be309adade22917086a0c5423f8fcb1295509d908564fb90d7e94c06818216662e455ed40d81abb01365a6cd57f65cd15ec1330711de85b42e6717f864df9220749cd8127d8da49c6c42d4abfe2eeec4fd63d18a12e17cea7607fa8252088593b1a358e5f7117d85741204cbd1fac7ea8a5b04ef70bcdaf30539ecd619541a5f394bc6bebdf52b6d85d2690f9a4759a619ddbf4b825b9b47cd37aa972aaa0795ec4b2cde1ecf470c6a55b3817eee69ce53e5297cb06b989fd58969648cb401dfccb83d3bf4a91aaaf78c72b8bf71221dbe9dab6ecff9d47610c32490518ceee2903fe53b0b14226d367ff8f5037ec653e964eeb3aa51b99ba5e7826bd93459e254276f143d15bc7016c9a0f3bd39a83f26f4920beacdcd3b75887c96c661f7be6f2ce6ce8972d7a59bbf57a517051ad4f718ede549556569ca24eb4cb465f918ee8930024812b7d52eafd18b514a65eb628e54869debcb2b906504483f5bf7c275ea56ac9bd18d91219281ead198e26632e6d7bfb320e0b88ac9b1c21f0a9944d2bc4b651781654196d6dbf41a93a551fdb66ff01c51fd763a89877324c8685fe1ea4e2cee830450f9813559eb05ff4805dd71429f087ff274921fd5da29ec184033bdd98ee82fb604475969936737d41b3380d3b4a317cd05d6927e52d673f8c95996317b2bfabee2c0cc9d47c517ab70b141d46d6c8eed33529844458aa947c1eee2a6deb0accbab4a8d2665dcfd9bd5176ab8d37533a0833e657e3ec442db472cb60fd48e036fa52acb94c3b6b4cf909ba51281b90255eab27e2f28f544e012034a745af930abff2a0aec2342ffe8ca1aa4971e552e07aabce0b68ef713cda8031052af9faae28718a478ccb46c284ec7c9e2a2da913fa06f7c3e32f4b187c96153fa2d93543a888ca854b7ea27c2207b5d5f18406943299ca9fddb29281595ce5c4fd0aab76e61bb3af3dcf422663421bec9b9b6522bf3d3f5e2f7be034c4f5b748262af56fb918b46210d03aa9241759060c7bda15d517858dd7d481054c55ca6cad01b45b454ae1397ac6368250ab3399b206a9e56b3e033636eeb57f4d78625123b5e15fd5d2d4028c1a4cc4bd7dc08ea972b707c347f4a451f5b09ca8aed703cc0cb1cdddcbf58672fb737fae6e41031b95a2cfab3e74b18423f7005e79f24a40f96a8b5fbf3b8531f00b51ccaee2803f70e273bfb2fb22663e2fe449b37b76d5a9e31a306fed43bc92bf84bb5480a010991a9890a001f9d6ccff5af8345e3aa66363dfb89624d4fab48358568fb4d79ce3bd5e781d366836afb969117366394818cfce1b19e4b5b561ddec4fb6b13197cd966a838d0120b42b6371e233a36c1e073e8266a5fc0730ff0e344885d7d360becda1d1e1580c7e9dff7c14982f87a11fa36df2930c35bdef0f953446905e459d3dbb7647bc5e30946c69c7e1a4f69d618d98f6f073dd36b85ecc88a4e8f74200939929aac05c63d41511d78d58ca3a091e1040275ec5c4dc6eda03a8072a044e0d5f9cbf771e7d91c0d8e732bf948a82c5f7c4abe2c7231904217ac8a350131cc11524492a3a83d48437101aa10ef22b0127d5ba8e1b02fa399443a23b04b89cd578280885051101a03396a0e694d7ab7022396c4f5711d64e43609a3d8b5330ebf69a312f254593bfe2aea52308943c9649d476293123b762a3e56565c5e1ace2572ae1db7c3cba1e51477fa0ddfa86e5082185a95ef26c94673eee65c388a20b3145a046d449a9efe286a332ce66061f2651a8a13d1c13484460c8c5429e05923cdc775f9f602919bf3b27ccb2aac9cb381068a530b4f7708a5c08e2510e079ab24480a02df2957752c4d72a832010ab133ba76b3ef8dbcc1d908cef046ee0bc88a608162980b1454eaaaf8f5f6059c3879084ffa91dca96e977b49c8a69cdf4bfac6e4b3cecbe33bbd4470d150d09ca17ff30b2e9bf0548a8bd1f14d305dd46551179c7a742e98c62a8091a26dc3164596865bf852eec2de2865c6e967824c141fcd28079cb340ba9860e9099ba2729a297edb68a980bc3e5502572c83ab4dbd1b2174164f5d69e6a15584a04a0515e0482b92ddbc1958307d99180912c007b89ae0a8ad28763c1e8d87bc2d5d6d4476c73c556418ee83bb9b07cdba0baacbc00002f53b425e48f5f2a86cbec743dd52d6fbdd2a598820e2d9217fc1792066ad6cc7ed69def22b471f7978837594f8af1592cbc88b7b63b34ab35bd7ac7652b2f066100fb0ef061225e527262ad53fa1e28772b62cbaf4582b1a8529971953d8e5da6818576883b42400801271732baaed854dc9f42612ed67e93bf4f2cc6b9f8462fc606ebde4b85385c41693471dfcf8d458ed44a8480266b41f71dd3af8dcd31d19261adcffe2c62869c7ee1b1150079974bac2551d3014baf00a4d7f935d1b6ffbecc34a250b1297f0b0caa3c80210db9f04f19c1a288212fbdb79ae15acc09396d82f71627b8939f1bd4dacd38cb0ff43b6e4e074cf66c9ec8869865b1adf84a6736f34b6eecb22226a29eba9fe086361b798ad345fbe7899d9065c30af040abeb506387e798d623c1835e4acbf62501a823384c0be4845f556de70811eda0f8f29efd788281e402cbbfda6b0494402fc4fa4cf72f5e18bc604335cbb7bf85923daa3c69076eb3412aa3b3560fdfe6c29a3c7b7acc7ecb50d9565724abef690c8b17294c66d1a5b8b77c8909e5bf7857af4ae2817781431bc9ec04b0477c9996e4f197db7f7b3847eecc3d8f97e13268c19b1145ca129e1bc1702d7d9826b06f2c7ee07ccba4a1e42b107cb2db70a1f07a4cf2b7577346c043325c183460cb71f9cdd1359c808b21b3dff76513c266ba1d392169d917920a49c0860272009acc61599406b2ee9300a79a20ef25cf9fe86d21f00732bab28cc3d279f31e663e0528dadb477476ba96e4410908ca0060976391a28fd259bba1fba9e55c70400aee15183a292611785283b57b0fecb132fe8821e30efd6beda1ce22251a07d38b72836e729c6e56d592bcf22ace94a483c0649a3b7c7f67f7bf11b3673a45080fed2abc71ad74c73987f4f66df94d9e58d72779a7cc57041c9ba206fdac5774d20937f570f65e50aea66665fda58e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
