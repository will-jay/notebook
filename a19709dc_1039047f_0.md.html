<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03dfb71e52996b6680965f8bcdfbc1d2ee842b2689fe83f61485c28812a36914360a5995ea865ed1e48b1310c6330f9cbbc344ebdfa06862b001730cfb6129949d1e94140208755c530ea0211a6577c392d834ba41e4c01da35bc5158b5a9536996cf4f951307aadce8a84c0e17fcc7306ac3fee4317fba14f5696df9b87ca6b642bd3612ae2129cab26ffcabe0308e531d1cc13a41e8551821ee769e8169cdc537a3d1f416401078b0f32e6a8605e554f3ee086f727be4b7cdff6fcfd885060d5e0538261a894b6f1c90022a9644c3f5cc4fb565c4ed4964438f8e7d7a7656ca502cd527ef690c0ea5709cd27238004e653fb4449482a33dc8da1f997e53278fe6b5050ec5189a9a9478f0e3f72b4cfc2205b486f99435c295ba312d1e57175d31df8cbe9cead814710cc5a206def81250dd0e2793ab546486ead646368446ae900d1a584248f2806aae8e499fe3bc16f41b288656b960ba7317c6bbf90a31090e67bf95c39035701848d09eb38f34bcd910da5f8613209c8d168cef6975bacd5ba5983949e1f19ad75095e43a60676be4b25d55b268d49b1c0d2ac186e57e0ec95d5213807924567a97a6c2a3195e78938204716c42ec8d94c2f58eb7c3a23f862cb714d77147f996ab91809000098bc6a201fb6d11cb4126c2bf133610d8bfd21a10e695919d24007872b505a9a36ecd6191b4ab0beab9e7c833432e34c12b2a0ace82fbdaf8eaa902cd103433483b08822e9bb39cf97241c0f95c857c8ea047a27ac2b8edfe3f27d6b5a3b4e7c8e8c760573fcb30ce6c779f5ee3469e4eb3af94b824f53cee5e433ce7d8ff418fb0f7a57255df7d9a0c8af2b20cac317a1b1b2a83f87941fa1edc977e3c0041f08ed3441b8b497e513bd3004e343935d0cbe147b54e65307d1ea8693dd40ec416164ff73305a488f78a3aa6749e572885ad859492b903d484bec6cd6087943ef1c2bb5ec4bb66f16e75e5253c0cc6bdadd8210bdd60760efaaca626a022afcfc6d368c610536cf6ed0166ed16429e48b174948de83ae805100dd5e43ef24ec78c62d2ad3bc11d098299bb0b780dd008e92cdd83f2b7e6056493e7f7fae445cec18ea2ab63c5a6584c1703bbe02274f2462a37faec354bff05a56b45b44206ff42d4fc7bbc9fe70b863b949dde0362d5ed64c32e78c6c19a7d4e2d6c20def464ae5c0b9ea09b5f3fae1cd3d1c527ce23b2dd14a5d612ecfa5cd93a8816d107f1277fb337c67a0763a5890bfb2a1313812ce14897f365fa7b2ec781c17bccd1a6d70d3cbb31905360a3d4fce92d4a373b7fa1e543c421487e7e588a66be725f6741a86abf273e011b772a3206420d6e50b4ad1a5b6dc0366c54237383fdd9ae0f799029c17f2ebf20ef04533afc16216a1468e3c3c20abf127af014f5423a40d04c5b28e638559f58e633e207805e7c495d89d02d866a6e688c67264a4f8c35898775ece8ac61f522cfe4b64debf3b9cb08459c8d37af678c92ec0b9bffb6e509799ab18871f7e1989abb90d31fef272300cc07d54a088964ed3f412160cf28a638e7600878a8b36bc7d236ca20e7edf6ab53c2240bab4c05444c14bfe13781620a1ad86cb5afe92a937c05f6cfd1684c5b4412083b2f3e3184e18676ea27f07e57eaa8695d1bcc586932480b124c7eaad050b8e133710bbebaf3cfce72b86d3bf173db13fd7aa2c7ac6b1420ff09fd5e2d8b5dce4815a44d288cd306c573fa12996f0c9c9ecf79ab59624a4698c8ff05a984af4baa1087d67d8cde4b4a3d2ead5d1359537b819bbad2df5b4598ecba4c6a45076ec4fd7e5ded3dc9311d08796beac9fefcfc4ccfe64dd6a35fd14b8a8593a8ab3b3a32c3827b9e70d2361b1d3ec8d25d2213aabc530176185636c0d14b3cd691efe07f572ba3a680a8a7ba4cc4c30b304c562d00de5f755fe64c2347fd15415401b704a7d63d02558ff2fd40db8c2a0b80acf9129f7eb1350afc12f2a190d50bd5e9998b3f3e7c480288c5f2b41f198ca3f304a8e6a779aa177aa5925bce2f52eca3a3f0762892da5fa6499b2f0b09bc79410aadf39495f0c30a06786bb5f02a8fbf465d83ef57cda0c63ef02a06797ccf9ea92b121a7d394e9b8e482799cae426ed8a9d2dedb1a178fa065f702271b607efb5253a80a00799f8ac935f2ea29b781185165dbedb5ecb59c2f6b8015858d42e73ada22a1502a34b31597b0812e53eec630c53335b5c1df42092824eece0fa78b712ee3c0a3aef323e753862416b5ac493dfe8d7f250a26d390a3311fba860c052f0e7f1fb31265b835d7292a819de797a410aeedd0125a556ebc372e9a8ab88624450bfd3728120d0900685a03c1bb56a0308839ce9d1bc925a1a69669ae20994021ae90a5bea8cc920fecc38b48a8d79c652b571734f5131b9c1f7982e7129d01acc33b8f7dde9b7bcad4bc8870a3320a6cdd75de3d50e6baeeecfe3c4b5d3c3358dda6c0efb173b00ececa064b954bde89a2a097a7ce343499a2234f2dbd9391e8ac0d5631238ab5e0aefedaa676069bd9221e7ecf3e87f81d33c1d797b3cb89e9ad9e3e44e0d84b1f063b79d6431513226b7d02bd18e839f9e712e1f8d2aa7a0d51e530528038d14d22d5ec36caf8b2465414cad457e0f8c37192ae39676bb27adb3bf7a05d78af43130292776ad77a5989c8f2e4aed56d8376a40c7041c9782330303039c9f251ff44fc20b18a03214dac1bc173eee506addc129edb5055762e2373970a0ca859ce12a23e063dd623ade92f81fea73fdaea762c27329baf0be5895e64720561c686b0b0305e548cda60e1a7085e5145b7da5656e6049376b745452cf46f052d249ba665addbfe0fae04c6f8ae3c76793989689bd39742db7d2ec0c06f5a00f13d4bec55de11075be149fd73658719ae5f06ca5fb5f6b2314e0a8170bcd29efef0a655a2a86d83d727c4e891b44a10541f3c9866c182232f20d2b916edd6d7aa4dd350f492a52089b598fcfdbb2f28652b3d9c08aee831f1780bd2c1a93320ee6f614a7ec2624a2323a95d5b8b0ccb7dc32a8007e25c20572adacba9e92d0eaea75aa8bbaf71af29348ef552413afc0b5a20ac0373d09e4f84947e5d6cd96158f0922e4adbf6ea67d263505244f433b3af3cd32c463c92ef0b1207d40d9a0b498996ae5e8fefef8ae1cc6d6bafe623598a8df2873a316a4c45555e6f721bc24b792cf3ea0aee2067b51c0ed1068653fe2c7c35b573fbb0712c19924c04f51dd8d220e0107c209d3e13e4b3b82d4e88b1a1761383474720584f8a67cbdf9dc3b3a3e1d4f343d9dda385e87a15f229527b69106d21730a788e553222f1ecfd8484b3b925ad3a3de432b653174033532229b8efab820cfc68d80fdfeb636eec47d83540357e477f0da949af4b2c286611db4818d54212718a85639769e6b734eb6ed950a2a3a9760b00f8ed70e8a26fed77b1a9955ed033aa26cffd00f04897d7ec502aa81244f0baa577d29c43f148908071357e4aec0dfdc66e390e7fac81d44a91999a6591811ac1481139d1098a94ac926d0568f054d3e63cd211f87c2ee0f0ffecf6bf1c0f6514fcc81d7b908493aa7e923dedbde057231a28b1f22d77a46c0b42c0d2a0b2e2710451bec082330e668a1bac45ed00c9bb36de1670cef803b25fb43bdf466535f63d715b7bd58b81528bb6dfeea97017acdb4b52149cdebc253f0474f7b1bbb2a0bb6ed0c27913c68ba105c70a8c5db46cbbd94469dd7e07ffb5d584c3875bf1eb347cf75e7ac710d532931bbeadc69e5170afea4ab0aa9ab9c43a3fb0fc012981fadd53b95bf58af7af2ad81b5366847da9a3849d0c7b99770743bd57d8ca8cd8ea54a67ad00822b626b801d48c899f0b8f405e1310fd96cc12be38e7734df0241efbe16704de34534c876072311455fdf053eb00230f4f39b5897f9f7404033f2f157169e9c27d740eadb47956bfa22249abc023878435bc16fdc15e4a240cfce419387385b381248bc0832a059ab9f1067fc1d57c45c22ed45400461dbee9317dd8f0e068182d6b145c0998a8410b1a4cb0e7ab377571028a9dfa651731acb813097b59d18c426f13c58c78b6de193f785f354d93df7c80ace3808868cfafb3bf1b28f3c2930174ac7b5d2553825a60d709e5bd35b056a52bf2b5c58ed898cf05cb78fb8858368bbdded6020714388ac7939d28fa79dc04d0f52121219fa5da4d1ff2426d4312813772ed27d4cff31074bf898b9f73c828c461d7a85586827d6ec967ba60dcb5bf3aaf1e8b0bbd7734bae880ae7b553d591859ffb310bdeaac63d753d71a23ba39f57213e4b791856449d7f35601d43a9cf4267ee525180ed5c6e7320bbdf27e9784889f57e552b42064aca98e112563ce2c12f884cf54fbf33fc2874cc5dc8ed24239c37cb70eb8249d65be66ce9523810ecc2826e02953993d20944d16a9328b474aa62050ba6a6ae4d45a70a54a22559d8f3d14f007fac1cba58f484c661d33e1388837f751ad6b94db8c1cb9a114c7a4064836280aec7524b130c6de6cbed78a5f58fede259359a1bce73d977113512fa76fbcd20269fd5a4e9859940bbe7d7fda40ebe3ca2dcfaa25850bfdedc8b14b4dd7d284bef461b1a4d28b43d4c18fa19be2baed8aac036be44968fe6302d25252f10ef33f6c8e768fe0ae154aa21286ef24a83231af5422082b03a6fddf0204f99756b58a80836adf2b0eb192d2e0b37ade1eb56c18464256e04fee29997f5ddede165e3a4d6f740290a085d7639c026f0cb6173bdd12939c37e16dc3abece6b10355f9e37b5c36d5233ae16d1199f2aee176f286450c046bed2804b1222da590ec7a12a030f5585c8263a2715d5d89ca3be751cc2edfdb66348511e97205a52adbe110629f9059baf4113c9169fa490ba4861b6c1fc28392d460f65bff60fcf923df9c2c5c164ca2cf9a83ed63593522cce8df594ab39c5d4f257483396d42ba31d8d3385b2630722bda545b7c2dae828607f50d8f0e29403cb0346f31ee10c790c508a5e50223f2685eb024179288304895489587ff4dd0459611ec01b9a013c902f3690d6d464db87dfb5f04b602fece1e99b66d22de11701c1034b4c70d8387fb77625277b9de417fd24b57c15664a19f42b104fc234a1c7edd92fbf5aa3cfe1bb9440ab489198d896c2c919dd2a7efc603e1be58ad7cd987208f3153347ccea5910bb7c4052a2bf9b1f66a37e85e08a3420d0d682d5f54a4e2fdf9075ce919ff8bdb740f36afc1a587f6d1cf5022cf1e4509c0a3f5f411db01849b2bb5c5be1ff68ca34e5e510904adcf5bfacc45d38ad97616977f8c4b74c6598eabe587b76d5e0f20aff8765ea6aa896e92b9078c0c6d30b1f0495411ce31aa95bb99a606408a866096d5d14ad8cf3b2b158978917fd717ae7d623591d6dce076f3c5a4b87dea894b8d78fa2b1e904805d62b380cdc7b0720462e01b0a6f61611160cec10c464ade66d0d06404f0e6c81bd2ddf2cc48645a24c665dce7872110b9bbb4dca543a8ccf701e03b6447dedc58bba2144e6ef7b4654fe5b9a3ecfccb59a82574c3f644952f21dc5a7b20456d82b9aac13da5ab250fa53588f9a25c830bf1c438fc3a901f9be7e93d1be4c7af4c125c6460e6e9ce93d9cf820658fd9beb111c23e73c3478a4034a041b223952c1aab32184a3e9b64c0ae13bc49aa710e52e455c15b393daddeebfefdde6812f073cf3fdcda47d9d009e777cb7b949f8f8ac7689f047693f22915bfb511c934da77cc578e4f328edc1ced88625566643b5956016cc6de5152e4da309b68d7f3c88109210187870efeaea6cf856a49a4949db977f24fcf8506be997e04f770d1e038be6ccf39624939a85b3ecef17a98599eb06ea14aef91de83f3cae252523f091285db1fba206600de35f31dc4b59ad851188a171614cf3507979db29b706e25bbf101354298d10119370804bb0b541a146aaf0dcbe9e1d34f5ea20acdb74157ffd9258ec16c8c235b4989083cff5f9df4e47a35b16d387da86e161be08462707dfbeec46e4c617afd6286ce5b22a0646f793c53728cbda2a226f330849b55875c8583a95f5d9e09676f36e13e8c4b878e1bc88c2232bd0d46fc348c4747385620c933c70e38fd71a11c8ae4dbdd0c5011b2b4424f5629856da20b9492c90b50e1ffe9997b7580265535154fda3f9595837bf5479bc8ae83450385a164a2afabbbe25712092270927a9f2c836a97045ea8012907841ba79b4616d7f8aee353f0f8dc5c5a8f93b6c3e40ffa57f9de4ba0da3316bda2c72857b7dedb49d57fd3aef59b876dd38434ab9a02c35d486a1935504b48ac8a07ebb27c56c3075817278caa363f4c40ae2ed019b24ed74ada66d950c4822b37550663be7aebe5dec972ff9c7538829eb62c9a8e973de819d078fcc2fefae8abfb299b3f07cf92979c203c43cba2a447e4607ffd410c1e1ef04011d9f24d955a6cdc0c0ef5d63f9e1723b05839f16a13f0a5c093093b9efb62665d15ced088eb3955313708a46debf75e46161ef8cd58f79281db849d2942ed97527364326b5ed341965bb0e0c93a158ebeb11173239db0e647dfcdf1e0fe9820b689a5a5d778884dec7734d32e73a8603bd8f998c1a281f5ea46b11c220ff5f2d9cf90ed59a205d57a74e7822cb93dd449301525af4b1352d2146ae42fa421e2116f52f127cc2e15b8fc4bfbb1b50a676e707275fcd8138f804fc64fcdcc7ff3307755ef94cc4fca6b0923675d8ab9c1c11d3ab53adac9c332e71d24f7417c4510b50b08fe64113f2cbf0bb7dd650f04741c8aa14d0be20359eacc82d7831588f8e745ae8d7d377480ac03265d18e9bc32c3fc564061d4c57ed7629fb54894aaa410337d83d5ee2344d91dd1296a793f0a2283b8deb39b7b0c90cbd145cf3e4d93dc7321c5b259d51cdafcb0d688b3ca232d4268be1895960bf8c86698aee3ebbf411e3f4cc79aee422f9441fdf44ad4a6244c96f3cdfdf64f2f9d5eed40241a0acb3e41396caf89a56635b846093d3d1c1bbc27c8fd9647c8dc8a2b38e17d1cf1f810eedc0aa0aa745cdd5466d37820e74bf267e83f5badcb09f6c139dbada08dbb10ef57ed7c31b8891c8a9010a9849040c51906ae8eb1ee6c741f984590dadc4f048fbf3e98814cd04151f8e18507a018001f5e6c50cd77dcbd30404e0332e70ed2fca9e644d156aa423f7e671ac2bb6f9f18152f5948bebdf118c5bdc86c76d8b658c44c600621e0bbf0daf110f5ae9f78722a1b24a584e59db1eabda216001c12b10b25ea9d7f329b385882285c130a2b04a278dfc2e0e0ade119bc22d901ba8818688649564e51799e3d0d828a8bbe99c91e9ea9a5f4e1b03e0a980a40d82091718aeff85352f837eb36aadd01dc5370138e087af7600373c30dfcca78482ec583ad3f72afefd4e005c376990c74787514c2085fff91b36c7c9f61702cde05399dbb189c21171890df694f5678b625e61ab9b322e38978fcc2890985a9e27ed3ce33d080e43df448cddcd683d02dfe3a4f16ee95b4634e8f46c1973ce7184ed9cac1ae117ace56d0f2617e1d6ab1629ef57d9169d724aceca9e8465260017533c431b8edd5b0cc1a74b6ec494fddef6d6c6daff9322c0fbff7450f5a920c7a0d9c66b994d89046c59ceb9649e01f3dc7eed77a83730ed36cd79c528458806ac2e334ee6d8449830456b227cc6ce12953021bfab475b5f02229ffc0105315dd9127549ab6952bb2715bc23bd570b46e04e7df24674b1c72696b1a56b215bfbee2cc499aa9a7ffb0a3b2f789e062a1fc05e7f5785bdf7fdc980b923fe6abe49a48bd250c3aa9138f9072eb9d24b2df691bf9f2b5542c5bdc968417968f5c4215dae826af07ec8eb18047a81f7ff22729402aa37e7fadd276249bc9bb896706f690efbd17a94c8a2910f4aa0ae0a568a5fd49b95a0d341c0a1aed2b5e233f0f42a5d1070a4bfa47c9be88cfe75fe2203fe60bb3b7baeed9d870a0436a2b5d7dbdd6826ad1aabeaf9f0c9dab304898eae77bb17ddd3947206b5e978804145d638b2267892b5cb41c7fd6e5efcbf79c06b0541fc1665b9b72cb6c79a1fcad27dc6f20577cc07e3920e626574756f0664204b9ee397cbc104f1a09a2b6d16ee7c54a72598f16e0822000b9951dbd32ee16f80bfa03fc0cc1c079e81cd5e02f009e17eab8d8f2812b5c00087285599f71829233b841f78823b1fe43b689260dcdedeac41c85a4536a7ea5f75e3e05c52265caffb05c3e7f717d6ef1fb1024c729b38bc0319fe851bf52f54b8d3d7862ba1609cb01dd0cd76018144320632c37e16feecf1c275467aa6a34389af49a11fbaf204ba390a8023f5f7ef1f6cf89912aa6ecf50df38f44b0e13383ee2382e2aa3ef971409e27e6baf75a7984e71accb7368c3e41801c72931b01fbc682e5a5a7710b3dc341ebfd0713f0ecc65fa2da4f20ea36e8c807d5c047b4406ed951e6c8157e09939e0c7abd8af4f1d208a894c4ee1f9cf4d10ca4b9bcf5a83c753d30d13df406f9e304c8293cdf4f1b0f2f3f652ee356287a42887427f8e2d26b6666227611303057b6dfc8605cf35765e139fa49383422c76df1c5b3db5efd7b0dbff6b8bd539e0d89","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
