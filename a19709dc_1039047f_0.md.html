<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ab59d784f6defa29b81f51c78ba7fd754ed8d5109d860147fe4ecb5c43959aeafc46d30bcf586a45b5884bc2d613fe41e2d6a72f6d6a4a3547ba7a35e887ad68d2e019370363da5d6e93108ab618dcfa171f6ba7e9bbfc92fdd5bdf906b5cbdf1b3b95e5fd540a84e2f57e446eba2e917a3349d58de756895e1dea22adc03898340911fea1d800acad02d792b21fd064013fad4b48bf301a9e1f3cdf7271a2dae618c39e1c01c41b0a79732e48cf5bb18c82d56d756e2697fd3fe1e05e37ee6420d2b19a99c00580b2a551eee363d41575a7abf76316ac949fb76d1c3aca01058bac0fa1301dbc0b37f53394a3106ded6bd8ab23746be9a7a4a06a905beb4884218e5460d4f5d0fae074064aade3656bc42b715ef0beb2d1f83894c45492811270ac5ef16b59ddc691f4ba0f4b5396d1f99b48e8184d21d140eb7b2ff79ec3c519831d67d17f8cbe74b8d471fea8e3cfabdc08656480a4c145a4a630f3a0accc09e803017adad4580a7c2cb9ac050d9c66dffa19d930898812ecaed70becb6f15b6252c60bd845211e10f91d7725118f4288063271b50d2ff38f79430028745a17c352d4614d91d88381c319b4101efd63286f01daada8c84941d67d21794be771eb0135f42e6aeb3adabd7cba11b0b34c5b67cd8a4f9defdfc694fdf678aefc7d87288a22729d0d66320fae0dfc959764f2c62b48f2e1be36f0095fa9f5daea1b3dcaefee19c798fd98a2d4ad70ad942ed62326458630ba9cad129047cedd1d5acf0cf5a2f8d06eca6cd8e5ae79b6ee73598fb424774dc5602972175ea3acb5580f1c7032592736bdf03303b6b922d1a4e258254fdec9969406a3c84afa79b529e68ad47cffe6d802a591f4d5e1580cedc23b7dfae654b0881be0654eaed890a2774479c87b142383c182cfc969f37945a09f1aef45643cb04a05400ef5b31b6fdc5bc005eb2d032ddfa0812d366d4c66c43b5a6b5c967fa8f36a16a75d995eaf66eb08f813b0e32d0af1f1079acc62d34fdec9f05c248b3a5dabcae1479c21131caa023d6bd3e319d27baf4decd5c7f48c49a03322da999eb8e5dda24e4a0ec09a0a18be45fa79ae49eadb06714094b158282d8510d5bfe4205a4b3720ddaee43330b9307d519dbe26bb727b8340e7e6b3ec016c319ec5a7c75f17ce42db04496229dace38c34b49f952b6ac5beb74449fda33af22b6ec924aa6860adc98d4514aa7018c36a64a212d756a38ab3c7f8e9e1410b2137b1885b8b59eb89d131e48ea86fd4704fbd3e4c200d84be59d2a6da9b9135b4fae238c381695aade07b4b8a9c4fdab8da2f9781542610188f3e0bff249ea1e19219363380afdd8f895beaffd6acd0d5e862b901d63a6d166789a5255393f8deca9f0f7564e7dba1ca84ae4c6e233789e81e0c3214e5b334c4dcaff3e74727c4192e5b8c3edc7490e3f7454f5d0f96d5157c3a86f16c28f9b49c0652eb6ffca0696496a32b37815fc306b5ad7e52d6284a46874340d1a473e7f283251a83c6c5a0157d4552047165ca6cc4ea171c880a2659e2897aa454f0660993eb8ad0f5bbe87d07bee460ddcdce045cfa467a1889c8c75fba6ddd78174c24cc1cf56a90134c72310654d0bc9b113f9a6fac8b704154ea268250644cc51777a1baf73413d220eb80c6dd0f68dba8a1e3559111e1695fe85ea6b4603643e330b1b33322df3f55688b4430c3b63516d89f556584698c2b588c45cd115d41b2761746a48bf705ee8f76311b414eb97a42f233eae3eeab2bd134f455c40c1b222e9bec684536a90485de322bf54fe2184e4462c3a8187e75663efb9dc2e80f217907c38e6a1f62561bbf8979562a50acfc89cb48cfb61aea4c4f3f732d64238f2805b484d0a9f6f5c2e3e98ea6b2e24e4f6b556e33930c150887509e8441169c976a29cb6288642bb5f9939556fdcd812d3a76f5fd8f991c85f3338198076cac209e423ab2457a612423e3c3663b94f42cb63df496ffdbb0895231c17551494b6f24c0c6c8000b41671518d969c712dfb9834640e3d8af1e2229a1dd728e1e6e65d257ace6879b0d54a19a49801da8ad67112220bf43eb908263b6dfb80c41edad2525f1ec23e4d0c30738edce1a9f72c51bbcc8aa46202f675c16a9b0e5fa4b61a38e21df82faaee517ffea03e547477106dc818109a00ee4020c5e84ef38e93a90848433c14ddaf75cb60eed0806fccb61b8e5c65e98695b129d4744dd734153b9cbb31e913b56ad11bec326370b7f5dce62e454a8345603569608b41a9704867574c9c37148f0bec04564c53b60a9004c67344d4b903b1feb7005cbb5fddf87fd2ce908076226af851888fdf3227a701ef4277d652c4dd0b944988078ffe9fa17d5521e1b77341cd0b16b3090622c190baf4f63e9b8a01d00388fbf09d2adf0d0ab63baa693723b5228ed60440be50049ed220fad16a1923effa19d0fbbf654af0fe0632f8485cd2b7161bfeb9fd8936a7683a4acd6797bb944495eecdd4b12d92c175d178520746738d8ff1c3c2a25b9b75a51582f16a685bade55aa45764445af524220c198d1ac99dff3af0500e92ddea821bc64b4c71679b55c63ae34e44fd97c672a577dc65a750ce9a29c6cee83c650a437ff2554e83e6691a8851739225bdc089dbf05ff23c44630e86ea5e745d9c6e68d3c71154adfe9b11a4e22a9e62c7fe09f9b71ce13f91cf555ded012b5fca4aa0219c6bbab0cf9f51f01dc4510137fbec091651b6d706bd5c1949fdb9e34c459b79666262dcbd994a99cd519a65a14dea09cd577331f5953f3314918be14603bbfb9541afba60c3490a95e6612e869481f819f338f5c8f9c95c7970ae771689e032ae5503dce741b0811cf841b9843443e329fd15aef78b566871a959b8bc825d078f10025ddbfc6785e4f27a87e971cfaf395e7bae32348be8feb58dbdc05e17b0ad3563cb6562cf242909792d0b5f9ca3763656959582993f331478b17d1477183820f768d558eaa9fcba5a766f02e6634e489179d51b4a62573a362dded3f62d31cc25627de1fae7d129574eb6252930bb2ae870016ef57f80300b379a42827600985cf314fc8e7c7c62e146a46bb110dabacfd2bf06fd9c20edbaaa237191b977bf12bffdcacaea66c2a9691eeb60c3cd03b451fc36eff9d036f7a20d8bbdb18029ba78ee1072e73e36764edab4ebc137d00d7c7d573dd16661b3a228cdf163ae4aeb8780982ce3c72d8997d4101b4557ca26d6a297a94b6b4781bce773b098c99f297508011c55788685b611ea913cf6b96687eae3cf93662a6b575fe426e222c9e99e7f9ca3c8c91fde7f67c55d5e6723e3569018f395f869a6c6e75b6a62c5faf9ad0e690992c9b2842cf6d33a4bc3eec900ed20890054d42282b8da2f934b9c4d419561e04e3c14d902f7a35d45e6d2da8bbbbdcc465a6ac1372a637a04723d70f73d8c5889d06f3e21aeadab22ff0ba564fc364e4c3c2ffb136bb6f8697290a9ce81256907253ee2b64aa51172c599214bf877899c0e7c931b7b9d38a37ce85808710398f2de9bbb77bf89e461ad5ec49f3f8b0892d40c94bb7625f88593c133261fd3f6463695dcb669cd5b4e254b1e6c18dbbf9e96a3b9dc758087e1b53cc672dc8cf01bf7042233fc92fdf84f7beb565973a449bed10f65ba3bd3cf5be079f07367f338e3f42f9b8efb5a357e63fbac4c1c4196f237cd5b9a034b01eff18953cdfebd7b40b036d83fb4c3daf1ece737defef67cbe87b53f29919b8344020339f98b660d93f632ad442a2b77e21c9947040a333515c4e6db93ff0d38c650286ff21f92b954a6368beda49896d098d1a3c1097b9ad21f5e0395a6e6074d5d39c01dc45b1c26b319a25d0a4deab69cebf5f53c725a80dbc765eb2c5343ae93b1aa1e7f12ebca88b412cab429fce2cc8af47908cc2a6f607003c241da62073b3d26568c11dd7803e0a60f0bb9e2a4f0e1bb487c9bf770ab8be6b3dc4f89c9d80a6c3cf30916108650eaf8f1c9ff487a940fc80d52b6e3a57556cd95676fe92221e1e40e6ec0bac58a4abcefb97f8380345e8b903546e69d5a972e775995b89427b020c771dd7efad2ae340edcad351a36928370ab358ca0414d178d3ad52196f6c2c421005aefccc31bb1770ca40e090bc7d1465d483f85ed5facbd9f953fd5b4f4653d06b441ae5a28f15fa2c51aaf1fcdc280a301bcadbea4ba5d6a2743f8be8c5b376d44f43427621514b78b7e01e42de58c05c506c964074e19f10af095ebc6572e2f9447d90f5cbf42323221448bd9aa5b0ad0d2c6eb566c4e62e5952f3422369135ac227e4b3a8f21972fa3eea02e4f736c839edf341879cbc9b34cb3d37c8cd6aba91112bc1ffcee5d346328e4b8489895d2c7f0f29a3f7b0ae2f690c0344d7d436a3f996e6bd3f107fa842230f6af5923fe206bf3eae737d3b83540fecc127b03c94da838229077385abe4de6ff584d816be0eedfa70b4a7a2d2bc0dca1e045290dde1592bc191acb97eb6c16c9d7b6f96c202f4f23cd11a2190f6d3009b496059074d8ecd95559cf0c359aca22a70bafa15faaf5414af6a02d6b49fc9bb506053b99272ff805fbd79ef556f727610b7a7493ba6802d8f4a5959c79e3a7efc7353210fa1e91bbade2a2e375d84940422f3de19d94c0d4c004134d064765b56329afc4c8aed57c6902404a9ac452a80f50c36f040156ee35879847c0a7b0fde4198497576925dbe0bf53360a2be18289ecda35af4c921a010dd3605f44fa2fd23d162a4c1f07078e8d4e3cf26fa09b4853e8027b9692371a52a4c70a7c9623e0a1f5ae9579d120bafe5b12d394984c43a4970d0d9c9eae4551a15f4ada81e70c69dfc4abc02670118c34d0c80faf0817116c28a59849493e1bb19f9501f8cbeac70442e778a0ac4741f8574aec919798e07e81595b75b834d210c95ad93707d07ac725566c651b00d4b356c771d31d10eec9340639fdc8719dcc5c6bd1be35512c559552abe5f4ce36431e8f86ff4aee30b615cc5eb97770af7aee3b0f084ddb65e87cbd6e1bba1377103d11417b90119c0ae5526d8ab00fbb33a0f35519799d3e8bac4372b80007e1a0d05c03a3cddf887af97a5ce5e549a4fa1b409537f334a49e6d1591933ec24d9ecaa681ae69198131391979e641fad837606627c64264ce7aa9437df6a410fbec625c07ebca59db1e65bcb61d19d21dd1c6789c86d35f2813583024a3bbcec61341085bbfae40992ba8081ef6aae8201dfcd21a20bcc4f87d5a44212b434580eca6d4e957e5e213cc0ef6bf67845c7d7758a8bbcb12a24486bd4e528dd55ad67df7779bbf9aa054cc605f8b539d1fb32139793611e9b6ca91cc9a07e38487b6525567c043940b3412cbd98e0df6f9d8a13b6c06db22d611b13bdaf73258ac05f2bb265fe09bf92e800ceba46094b71ca88944b093585013a3ee7f161edf62be50ae9be08868f1cdb7e743a3d3903d42acca96b1ef6e5d89a016b481f314fc70a9e7e8e35a59b26096de966f5324c2bc99e7c2946dcf3df5774784d7d28471d3a64c8bb2e8c6aa5a210ddc605addb0db23ee3d5ac181eb6e54e4fbb6518e84b7922a7216536b80b7fede87f074f7ff9a6f7cb7c2af0b32a83ce1f2bfec1fb4573cf2a17f30afaa7539fdb996caeebd7e64b675c72e759c93758b8f74d245a0d0978b59be760510c8071edd53268436a8a7ecf0ab8e3fa75892242f4a35c8fd9d3253412dfc8019030bc0f1bb4e3c3a52ec775f829cef1b90af55f612d7166c5192ea1b2f50c9b5ba7ae75c10a0ff59ca8c758e4e731ea91b5ca54d0bdcf1e1538356dbf6e83674bd4f19a634e006cd0752cc64ae4ce924a05b5480165237a9d03108bd608848e82d16d4106a0a2ca7ca5c212a0ecf74e9deef2dcc2bdf9a64e1a9eb50ded801f0aab0d7d3f130cc71692cb3fc6f6aeeb2d07298b5714d92043ed0418774f3a3482419a6192d8a5d435023f714b671bb411337992f2578428daf8a93eb42c28b7ccd5c54d6ccb27c6b1ba1c14bbe746fc92cee0650cbff757052e84f58c4526b5e0188d0fdd87e14d70c1484473835100f10ea8775fd5d5b1d7f83ae3055c2f7bbb0ee6c770827daf37b2c1312d667583c5a55aa463b60e7aa7e8e722ecdd787967b729f92a7170ab98d7a001fba70e11e086ea1afc17e7d6c14782c97c73e47736bae6dcc4c67a4653ca04659484e426a4f6232f33d25161286e1d14e51d3360e0788b1bad083b31807974b3b3e27528b2cb65e77c80e2f8083c56da1e55ce22207b5a01f78cc1c28d76811ac5dd62a39fd7a64a37af0d7040790d2fd7b534794e94e7dd82de4700cc0b9d6eea335e1e7f189717da152e670e074e0df59a391b63e9b582f147947ee69ff9a19579ce513f2d682a699b310266d3a595d443a0b3eb8336b0f198efc2fde2a1364e883d341b38e1340095937ef09679e7d171074d48b48e18365fe907511deba4425370209fecd4967e28a632061748763f8fdcf74db95d62ad1374cb552644a32bbdd9cf8bc14ee943380ead58c0915200b382402144cfc2b09c778209e78bfd291966b956c3e28e19b1e0c96afd778c4b9b4ffbc3d65af24d0a8cf31a6de47fc1d6e3e1811f747aceff377d8a73d0b54b856912734ad23244d84e384f1ad88f9d4d40474cd0760f8528409b8f171c3c3ef88bd23e6d14a29d801706783fe79ddb6ffc6435b88c8263245a4844bed1e0ad6d1596a7b2267f121958b23c1b5e6ee5f4e6ed10ca236b3f8cc08301858462aa42b377b0acc1a73e54709ad9cf5265b917bf4f5f1cc15d0451b3aab1c7a3c1ba31da71f9ea6a19c9971831634970f5c3c17a1678fc7f47661ebc0ae075db5535d49eafd2ff4687bd410da781ac83b316b9ef52ff5c644e5f202b94642c731216c937bb4e4f8405f77d2080df89a0689d37b9ba7ceb8e5786a0b553573a6601b7996c5de261f5cd47cb7406aeb84fb287fb31dced798f6ef7f1ec310f629e0c26446ccfcc0073680b7004389bb3b778330769c5036a0f5d4303601fe06940b966bcf0516822d0ee39bd448aff26619f6356f95cb3afc1fa7c3315f26e98cddf259f6bff8c40889b2e2c5152568b1262e87bb33f0a683e1a5690a881615f2703fec91900ee12c67003a3716e319afe6d533a8dd5de6a4067acfbc67e07923e13dcfbca3323184cd8a898654df00ef3abe84130f15f0019e1be35122ab3136f761cb49a42a4b4d7af645cb8eb1add551b527ab2d25a1303fd4de6a00b8a2be85d64b8b4f0b8b6f74758701f440caaadb8ffe09da4bed27f18993a0e7afbe01eb388881668bfbfe26922f4ad2527dce7d3e100e5de0364ce1497fd04c17730b6d8c88988013f06d2a942e578da345e4bbc9ab0889f47f69638e3ca4c1df83bab71651c98dbf36bfc0ea305bf7733bfa6a0c443cf67d966111394eb40cca9c9556c939010f01be2811e51ac9d9087e4cd9e2351c0cd002a4913f3c4076aa7141b72f31e81b02efdafee3fb30847eed75cf3fa6c2dcb8411945005bd528db57404907f47d014a15ce7df7841997f30e4d808c2f98d85800af8f3f375b94a83cfca94fcb1a3cb7e7e541cd52f6085183e51512e81494515087c8378223b7b938d0ff54245933bb411b0e6c4e0b92089b2cd8942d6f1e7456575281c2665360e0c0234d269069bfef54f196d3dbee1c5dfc5a3cf8e88efe208f459e59b4944f02b3c55f4400d848dbbc3d0b1a86a4461e26245fa60ad8396219a30691bd92f065920385e33f38245bbe23d11f66729a3781d5428be9e22d56933ff1a10b3833ab2ef3cef207c23e522323f523168b84c1ec1d7cba2c71d3d8dab6736da8aeaf53a2c5f1c3917dadd44e5b30a6cc0f486dc4e2a9ee9ed0202b77fac68c6c1a2d4de0cd686d15f97ff7f7475af563309073cd64436b4cefa5e96220cf8a086c8b2370074fdc3d7d89eb9be9aa63fa1a89fa7206120286c037d2a96fed58775e02bfcaae0f9391e7e4cacc194af43e1797865f01390ab4141f5af9f6580ab52c108e4ab7f829939b6c18508b1f8be89f67ac8296fcc239ec0b4e67db64bea111d37682862f0abdba9c8f0c63b6bd0fbebc9824199665324f607ff18536315780cc606945afe43dff78fff7444b2673bd57f754656cdd95b1c512f01b3c10d91ca9d4c082cbd45b14a9933df5c4d06a51c51f7f59d563e93d26b2f707a24113b119531673437b76041799cdd95dc6b0841ec2fd76198840cb45e1a0bb4eb9619ffcff20be0f9f14115d9d4d2be2b53e2cc91586bc8cb2ccc147161bb10715e1cc632bf56eecb13652eec4ebf5092e09583a410e67f0c527d4ab936381db7e5ecdf76d1a9b30dbb169a58888a547815495daf92f849db9f0a167dd2bc799355a87a97923c57101b3abd55801a66e41efbb80a6dd4e09ccb2472f169ecdc2105570c5447da23a179a6b026048cf8b042c7607788dd48722ffa880c122cf3bf9d5314501bc8b80d9fde76f02b4ae1d960bd6364001cc10d634c3aff4a97d779db1425621f0464433655361f7213f6410ab46d59b921f2f9bb328ee41d0181c45f992e76e85069dfe6faf2b7c444de7118742cf44489bdc4d5d3630a6394ec2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
