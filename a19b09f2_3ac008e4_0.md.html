<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"268cff77a0184bb210272b15a6e4cb706617ce9399ddef6fc650f07107027ef16cb8d768af92330f5e498c8dcfc77c0283f7a7df711f29e8442b72178db22d8e541cbbc6e6b01dcf3e4082f9f43b3f0e29476df61ba9dd8c2e5db79cdc2ff190de1577b67275eb60014f1b39cb0c1054805ed052316183453b36e260caca7235a9279fe8ab75fe487b0781bc1c112da3e1033095e5098b7b8912ce481be92ce106d87c67f84392d00d9617d65250869165c21a48b82aa87b494b6a2537da358e96cfd1069f51a6a62d1bd9862dd1f9c8557d4b0feb92d4a5821af2c2f4b6e7fdf04ddc6922a9a53d750ba1d82e435de72ff90b31fa13ec41e145ace63047afc1ff458300da782d702945ccf5a78b270e0dced35484e1d1d1c009388a0e1c43f42ead10f330ef7a06650ddbcf38ba14d415b10ad6d7819382d9191a18b516559ccab1ac08cf5320b5ea473d62215ff13e75471feab40e649eaf0899c213ae395e3ca7ccf95e81992fe10e4f51e3334d93bf0598edee66d0b26f740f9ca87f4585688d603ea118d6a996454710f098953826a2de77d25cbf872e47375e88bd458f0a2376e006af2ce957c87cebac5ecbe99b97d1b965244d91b69c29201330e9e2e686ee53fda8fc2fd717f45c1f336e42ba0e0d92de5521d2d11b752bc8aed37c8175b3558894ad22289afe341e645eae47ed715f0feef43c33041ea231477f3c2e68bcec11c20316a90e15f6b0989fb107fa6ed523e5d03e61c1c41ebe210020853e3c43f3c0f050c9385cb8e2c5c6b6eeb86f1db5f01404f87b1d30a0f64db3716e4a4da649608e409ae16bcb18ba05f458302ade981d37ed4b48ead49455765dab7a88ac401a5bd542029791f472bf614aded7b9c80d417d9585709451be01bee6d30e6285e5520f6b6c17fc7cd1ec05e3bb7af7ffbe6e26c7f3ab39c454743af7f537252c9604d179d83949c874a44c8c9883a97135b51cc22578456fb19ebf4c4763a4e77ca18a866787e122edffb3d25cba7c9dc6cc1b374564a7fdb44e9ea61a413bb920a5cd47dee123d5cdbf00768edddd87725928b6feb36aa6d3afcf5221224de479c79ab73522b3aac233e6cb44b732af31479272fe921a1911707f874486b2a34d74682013d81ec858b373751ff92f5da72d3f4d904e8a9e059f13b867a6ebbf35b081095b8b6362709a5d65659a42f52ad161df9307b50a2677721e8b7e56d40b7809c30d164c70272f0ae34db1b748808701affd2b775ca3684ca5d9cf2ea51e6863e3efdb8820c34cc7a5b969161821fd171d2b8a2d5f682fa4761f62ffacba231c29f0d1f541b5f65460bb7bd2692d6507b5cac5e9c30b12d3e11382dd76d5e33779eda79495db670839f5baed66e41195476ad8a7c7443459c8b68a47ecf44e1e7b6d7e8d002c0e549d2e811540dc63ba753e2f368728cbb2d0598c327bcba37f4ffbcb0169a6d07f11261bcc89233ffbfcf7c9e1ef45ccb05256e7af8c4b04bd3306feb1b399e922183b8b109100727a483c5ad7154f8d56685a9427fd43fb2bf196d29b3155a787a3484e031ac5d7f8edc749f41f9426e7452bec7253cdd862d2bbfd1fd7eec74ce5a4d9de1b95a58b1063ecace0998ebeb1357bc75852d323a357359b34faaff3020036d4bd088a1f4926f7498456a1352ee662edfa83441ec4e917d5112e7f96c154a4a680c16199e45359566fbe8273ace0a219087aed2b28721176630c6b339647f3f6b7495e61fb68195dcb16d21cbdb1c40cd366d9de815d3409c6bbcdfef572eaf302ea8fd25d15f4b11af8ad70abd86f50c1472be4d74f9d50c642648ee3d842594f7e926eadc72532d8bc45419971c767527d2cd311e4306d6aada2748cfdaa947bc6a835fc3a91f8a30e7ac1b572212fcba57bbceaed3c9eb7ec423b68d63e9593e1140d4a38fc899bce6bc283f1c7de79aec395491d37bbbedb5e4211de8113ccecdf65d4e260ce393f7a2664bc082b62ac8bf080095d44c838597bfc3d201ec1357ca6f664bbe57ee172f3b4d09ac4e71e63d361a83f19ab7b4dcaf751b8e97c22e3dac82e002f2896b7b7fe7fb9170343620502a49d0d00ad1183dfee9dfa003cc97f9e45a6d26b8cbeb63f2a60b05a19a1246e0721fb886578827d33954c6f859a1f96a03d410d40efab86417cbad988799a244e9d6a1f2695fc5ed0c03875cd6db017a002f11b5ff8cf8b7a9ade065997da7a1b66dd3c3364664ea149a54e99e932583c08b3cb0bb1eba1e899ba89e60a81e626b6c321f61c2a8feadfa3142e813001259a4ae0ec671b4380e066cf14f905cdd6d92fb5ef73976928c962d2a7a8e8d63c90fc92bc93e11d02b15155e15a682b93546eb72f48391a281328755df99eceaf6d008670fc0c3ff6480ec8ec252d0a78491dc53f746be8181754c020bee7c72872d5866e339231069c34b01880327cdfc9794c78bceffc4ae7fc786f9ee651e17ab1556a092503b8251e3e96fdb3716bb97ee650083b03df3197dc25b0d21daeb4034823ef95d4c50af3ef5d5681aac1d0266f77a204e5927814ff753c4b5a3cc4652415a62389d51704cd56cf297d31e2545db4675e9436515f21ae04b120b4f275b3b103b5b60e65e85f232557f65dd9814fda9fe77282cb643784a8e27a9752b6f0fb21c05a1759c4126a7a55e296174d84e4611d4ff997072494d9d3db5d00131cfd201a14ff6c61a4365f72e532ff18e8e394ff282b918f631b7e496e3a3a9f60603af5db7e47a95d327c3a28a2f14bd76916e86ad32afa3e8f9bc673a92f7f4bb59386c68f225cf1b0ae76b56c0ffa2be5811d853c385b1e48554f23e2681852cf668f5b891497ad6eef1f90981abc26918a5d038e596cbd1204ccd740d55eab3cf69436d6463b8f99f48ed41147b54b483623163d9d075aaddae9a18a4ec2200985a12f2987fe3433bcf39254f570c61171d8b47d41e330898eca0c6889ef9cbb1c6bfa0e32eaf6fff5b3d72f3406d62b26be77b79b129d7bc5b83808f4bbf49735eb4e95a5dae155cfe35ce7a57c6aba6f439204a48973be4b8d3b44f97cf4c3d395505baa828eda2f52e4c937d5d2a6bf0e0b23ff816cd09d5e46ffadb111ac3b9c6eab3a9cad16351b9824690ead525fd4a041348e5365467e89a8373c476a9cc965d043578b8bcc557c0c095b67eaaecad83de913ef2f21dcf2cdd57c7a2dd6e5f58d4715c44cd0a306018583ce5b93cce71573e5c148c140bb48016bd8c93ee87db2f7f2e59d19c5cd62ac6b18eb34974a74b9878bf147c53d1658e1bdc8479c1b4d2b7d6ae8c36294c80316ea9316f2f7d3d49d0cbd54c234a3d8c97b67c4ad994fd73f5e4a7478c1cf109348459fa6984f9ba8e1c3233f0ff2dd8b6c2e94069e8d1708e9384734785365757de1105d166e66dba94291ec6e577ad05b12bc37db5131bdbee087c29375a49002f217e4b99105f1a3b7514efbfdb6275ff49a7aeafdc0d15c2b87cabd5edb929362f5167af5ed45d56850bd3fe0a82138b155d1afa9bdd6b7fdba26d4e37874d76a77a922bbf46ac4bf37edf10dcc440963a36efca7cc780a758ae003cf87ca26c2a11fec6d7896318a8683df024d8ada6b1bcf43f69755757ce42dd5fcc385b411b87ad089e665cf446f5d899333eb9ad1d40717c1bbdcef7718c8c5313eefbc15d34b04f7af84113a1b81ed96f5d3e8dbfb8669e8ffde8c380858496659735fe76590a4a203685a96c89b040285f92c6802d40b2af8fc3c2b712e7a6c674dacacb9cd497d005133c25bbdfa0dcfe70da6f1c840f7793bc0fcce3209d92e11c2fe2520fd2e7b032be9afe6c46a51496c6dac4cf4317f91c8f1f9f5663a4c4b2e2e47ccb91e8174e1b73a6821d14e795eebe33e21a4ba274cac67edec814033bd8e7d1b5cef548482e4c7240482425324ac27f8161d104df849edc2ac780a9976e12b1468e9f269efc80a011f95db2bfce1062982a24479ab208ea805145b1820b21f716a7c522457724f7400ac9072f003f93622bd6fd087f84c27006cd30be8008e2d3fa7d194b1fa60a231dd54fe3d9e96337326145c834125c1a3187efeecc880abd5837e1cf415d4efc885117985aa154c42d4abe75d58737b0f6f9669ce60c2fa56b4531eaf17149e9cc1c66819fc09f988d5095d5ca93e6b546161fc9ad7176e29f0206d344b508868e4d3e959b907ad9ec33a9b5117ddfa5b4190af5c0d5381f81a1a1b93033f3e00290c51e7b9779d6a256d929daaea24346454bf7ef0fbd5ad41925616240b09947f2575633cb4f77f2e97b9a7fb4eeb387a40060b4027aa2414d3447ab114a27fadda6acb4df32150097a020172eb10c8780f462160c44bfc4a428b5869c7a1607eaf862111ceee4e7fcc62dbf2f67abc3f04a04c77f56546a365a38186231ee4db6fe1165900541f70b2a8a0674cb403e9fbb656d11b8af041d861d5289d95929d23b6f8d7ecb637ed3be8b1fb3f37d6670ec313b09e27a75540e9fe8076421a676cd623788d4081aeb77b7efd5dd04cac73828d0b7b08ed9cd6ff97706c4f0ea84262a5702ff6fc89de2f4aefbd59292a183db04122612c22f6254492e3c3091f5c7a32f7c7688ec6ca7a48f8def306f0c3ae48e9fac0c986165b519765310052a5a2070e34dbc5d9b02eb2a854e01a989cae76a94f010c4181dc40567d2e6dedefba9a207e89280ec7cc10da02097c8d93fbebc2edf2ed9c6b7559f978205dfdd9f116def446d358e7e6526b8f7d973c863ab96130a9657eb2ebc61d9c21da3590c03527e85936b56964c36de9141d65f8a8214136e5af8e2200e53df76984d1c3236b208428cbe3d19ac7a150478bfb33428e47f7565e631b818eb16d00fd93ad8518e1605b8c11c4dcc90e5731a5a725b5ddfb4cb38ca285c48c0af5be1c0b43959c7fc4160746cecfe9822aaf6417a8f75616c65c9ec306680b33b6c11f5814b98f6454bec9065f6214192765875924f899e49191cbdbd630f1870e6245b7cbc673e6b2391229c93184176e75ccdaf86dce7d166fef8038552da668b21ab11a488d9d8b3f08e831e0409d2da6aa7cbf87754d8a933c35558f4dfb77002e6363f1249ab8f856cf94c9762e99ffdf99951dc9ab0eb5a9b76e21270ed3e604e2e4b24f82fececb312445268ff8c9dcd6cb97581bf36d5c71cb3757aff407c4bfea46ba5c62ca3c6e62bf7bd9993080022132cd8063708df4de1a6a9c5da31d2cb0db2193e4930b83cbec162a2af569c5fc8a411551ae41bcf0874e2db7d291999a8069c67a4693d0f39112921b39bbb76425473a999c4d08680ce9e29b93cbae0643f5b76b2880f763bb11eb1f9fb0f7ae6b9f22d9c1225e52b57bd0b3cc7142a2fa6a303cd55dbea77caad21bb5bdecc6a86bc978419e1617b48a461f67eb2f9ac637c8e72ead8324c5259aa790f76653dbc77ac2fd8a2bf21ef7c624cea189681899a088cb8ae4b28ad8f804d2895bc9d971d979dbcb12c4176c04943bb26047274ece7f0c0d8815df5e0e812d6a6dbbc0fcebfdd227641d7f60bac591c24bc7492b0dfbb5ce8e28859f7bdcba9f1acf8efa1c0b083aefe5185da3f7ef02b7f57cb97f04f92e927f49012b33031127b0395e741c91f941354d9b737590488a9bb5f34b49b17819efd7caeea9a3d0e68276f87d1f0f24ff4d6b8c699449d2c76bebad7336b6d668ddb1833a18c10575e144f7b6b1bd8e1be3baa5e432ce184158c75ff13dc641ac63cbbd3c943ade647e28f20265e2eb5724195fcc701e43dd5c881e884114545d8a4ca506bc7be5215c0c845a90889f1fe6088bcd98d57fc1c6bb385e87275c8f8b923e501fafa8851f170c1ccc3ba5b472028d9b5a2129903655d09ea1deb1a52547d63c43b0431ccda6b928fa5986976e50b642965a8079e0a5cbeddc8b4dafa7f557abaa09a4d7983caebd99a26169fae0d74037044fbe26b40251b384fd05ca8641d65f58076d8f9e992967d30e78b9c7f00df0c0b57d4e09d6b203d4204f1971047bc453ff68f1f851df419a82f95e26fce3be21f2bcc5d7cb990a06929aa24a925101e976ab722c125dd5fbd378ace433d109bacdb91965434ba42a7278683cddc92d09b9fb8a29030c479799783d7b52b052446801515a8de3e4b4c6c848e2e54a1145c8f04ba1e4f4b940c89255d404ce365bb591ef1dbbfcbec98b03478a4202700e134794c4d4784c98c44423ed9835faa2e44a2c640fbdab6c4c1831dcaf7e2620215663a3bffaab93b5751798c955a938467be841b6c1b341e400d8c8646511d2832359af8383a3b2125d36da44f914d4d3bfa64944554928fdfaa98e053e1a97fefe98aca95130d54a5e5d483c392b2e5b53aee2745cb1eb84d05f2bcec0e97fe6ee2b0a6d191b1306e297fa83b61c18f3525eb37022e23e445283d4653cce994123f540f86e79f7f317fcf80e3e19bdd9cb5649d326f3557a3458e2f0ecd0212d5c01ce257c9d010fe54f5dff5ac73772513f6974879c3e93fdcafd47e29c065ae37f1a25d8a8d62a4b2f172462e68f76e3e54d37c67068f58dfa36c369ea46085576f5100453bc0c9bd22005e00fd6c8a458e8babc81e4bd2f89e7afdcf95348498574b9d4f1a72ce89c3bcaf3d577f10f7dad78cd4264ff808adb0b938ffc891d8b2297e3fd62d424a3e4d7ed417e9a04edfcde2437123d36caa70e8ffd6cf86a4db55932fe074d2caa1398754d3d3d8ad0f1ee78312387f485fcaf1150fdfd1f72e4a2562bb84e94645098033b983afbfb051bcd35848e6e9c1a172d47e5c896a36f1df7acc99d1eeca26938419130d06e2c662f54c51c1579c72f725f5e75ae3609b3eee4ec4f5aa4111ebe307de6379b09129dd05e4641399583cb55f62352e7dad21023421867c5de244b65e7487bd72200a80cb45438cb4dde233d43777ef28c4e11b20b30de56e999a9a973afbc952b82d3e99797744be05b2ef204dfa505d942ca9bffde674c769859fb52704226dfeb4d69426f047b6818ab8971b1494df5c609571348aacb14a8608d42031dbd973e410f709bf8deb1650ade1dd868bc05f634eb5181f2093e33129df3df752b90ee4762e98fe6979529b2f462d0264b0ac90d84bb0741fadfaf2a1cfd020d72ff3a1a795496598983eef1b3795e98576b85a869c48dcd9c27a0f0765d311cbbcc33d07a694af46610a4f78c13a9ef42096d5861d8ad1f10c4397a50153d78015403bf2265a52037bd184a1b8a138718094a583aa0800c94a0b3b481f675d2f49b7a67100752119c90f3c5569e9aed82c10ed6207f4a43e64e65ea6254cd6de637f95f4b6c25fc9087f99ba6ba964c85ee259bb44014156e2f3310b7b369bac5f7e4911b5d6be511676fe91198b5f76a8d46e80f5750c6e1a4ae95fe00a180b29c401976140fdc3aa282aabe1a81f3ec62a66d9bfc51ac124189e3d6eb2e02cbaf0d5dce57006ae784f00f46e222a74529f961de1cdfd8fa8413eaff1b3f2276a76c68002da026653032857b53a17f8f6bc143cffcac13185d33d87454ea77c03865e16c529c5e6bb83873076b8c9956502e9a649d17d45f299a994624d7bc5dfc35cda86fe95d4f9a4c0828c36b3f8bc2a9229a7a69a94d5943c36db80d191a3b21af6edf5d81aa0f4099428fa9a19c54b2a8870b0419ee84df001df2b7980572d899655523f454f00ece08cb31c5d7fad3e88eeeacee58041c0a73304d13bbf59ca061f9fe752b94abd0032c07f2264caf4576c8ba3ee2c30f938bc5263c9996bfa751b7ebeb6092fc90083fa9782f9472ccb0cd7c5c4d922de9d809f20f501b49ae977e95e3c1f5844f1a91f1803fc1cf739543581d59c2e7e6ce0d1cd74c6d583cef480db26057b2ae6beb717895feb97bf0dedbd7ed9095a381652ea97a3ccd0301dd22dc0cd959a1d8c178bad8942e4c1af28875ef481b13c57defac722c9446aae7b2b9364cde1278a55f776efd186a8b6d926eb8e93a234c725ddda6293205ad095607bf39d58020c2b9dcc2271b70d9b7b076899b7be1bb1a9e41cbbc567296b68cce21e26aac2e146504126d38ac5cae99dfc56d6daf305ee01c854c9aa60f3102fb7c86c10e89539e96ef31d959b1882056e2e86e25accd89e30ca04b27f432882b28e2f85ac8b0241d79602a821736159008ac880017f77c61624b99e19fe6aaa14d8c7470203054300f558d6b07a6e20e0833ce5076258711de01cb7f689a4085395da577c1baa1f920e2bd21d729f5abe2d668dc0b8386e168ec3c7b0cce20557dbaff92463ab08180039f2ba9c3e353fd6b068f3fcc8a5bbe95fc1945d88ce66a2ae43e88bac789537146567aa6da26095d293fdc5844ce5440f0618249bf1c0e582bedd9cacf73b6b845e4b705cfbc488cb37fd6f18f3af5aebba279d4733c01c7884c931cca684f9a1ee93ee73db644025d6746f936f377d4caa2a49e621634e72ed7e3884d615dcc8d58a38b2cbbe7c4c467adad2e1b9a991326f60e4cef4beee000acb4e0dba07b756e4c4bfa913cdfc94e25504811deb2cce99ee1251779f063f8dc196d890dfe31556779234d5c90062f85744e8794cd895c87099fe39f1af3c56346be22beaad46c8fc8cb7e2488c6230ff1aab48d2dacc9115fe174553551ca5ceb2d54633a603a7d1fa7d06fbee731b5e75803bd0bf0b8eb63eb534e708bc81903f7df0b7e8f38874d9fb2dcb2258a6a1cbc5b3ac7d6437b50c15b36f7e68f416d2f71687258a62c4be9c3cbb0a944b800558538e9ca42039ab8b555bed2f5cf2a092e8f3a32eeeb43a3b4554713d415c39459ca452af95320e32726a8441c02e2c8a166b1dfbcf6f7c573a34e37e75ae939e77d624bd590461718cb12bd82c4b84422086d601f83b450b8b0cec18e99ed975a65df916dfd4304afc634becda9e95874f2988b2f9ce4271ce26cddb9f9d15e964295a81042215d8d83800094067968284f7477c22f0e495681f943c5f23c0c2e641a006a692daed99a1eb4e8805a67eb7276dace8b136d96f5a5f69c6f0fbcf3665c175df5ad22eccf4bfdc200c54ee3a6f3e04599c99b1a603573f3b780a71312235d2218a35ed614c9209c6801bc9ac83bc63704eba2cc24dbdea76f429d24503d57d9214e652f210239497bfb9dd372f5ce8b42e0589a3ca724680193fe78d3a179f2942dedd1e0ddc4a5ac04f5869e27a80c4b7f310e5b88e33ae7c5062ef59e20a26ca91986a4cbc8f744a1191925ba12ea2f32a541b1dea5aa020c05e4a0c5d370ce8db00cdde33cc8217e3523b66abd4c11bc0eed093de86552b5cb7ae738173f6417187e5bb658a3b41baa39a21131ef05262e9427669183689b8afbe84dcac4822b736e95c8c3193a896ecea222075ea1ce3c9b85a757b32a07a12966be7fbef2cc88923a08964402b4d2b631bbd1500cdfc103f38a25550994ff676d19872edfdfbca4a74279238c0502d26f2d254c3aa21c5e6beb17bc1a3b2348539d45cf46e23e26b33e360652b8a76745bb6904b2363444bab30e6729a5d031741661c35c139d03a1c28bfff68cb3360f299a8420e5043d1cd397d5901208192fa86c5ef8d247dfc308108f5d9cd8f1ed0862d0504226ae0c174dcf7b3d86b72601c311ee293f8843cb6e099d8c53db5a1ece982c597b556da888bf716e68687e3389000f69a9700291106452e3b2fb1cc5f153aa8c22cc1b414de571b3e3964d0aed699599961cc745973ebc908cbfa618fd91b043685f752a329695149ee9af4139301aab8d45180355de2c5e79df22771b522ef2e2244d16aadfa968c39d94568c01dd65a3598a918ad811f86998cd91bf1ea0e7b6f8304e9a4464a30f8afaa1314c4d8f09896152a9d5a19668931193c496f84c2a0b353af6b224fe53f12c527ff1ed99fc62d2543b83ad6311c0450da7ed4f0607baea545f3e985d0e77ebb0779b33381633a9d43cef40745cb44be57aa10b3f0812a1e766ff8f5f244b89bd7cf166fc899aa3905cf471eb84cd5c4e1b5d9c6a92f4127e860468b072f1be2eb80b44","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
