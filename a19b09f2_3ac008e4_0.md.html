<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ddfc4c4800d72a5e52cf30c3ac2443b18ec43fe5f687a8f138af6f144d66b2bb4566403c5a1b3c194d2567c26ca76cd1932bb592cfb45041ec9670c866599cef0fec522e0012e4692d8f9bc4455a3a0ded9261152c4182d80c06c1ffa02f66bf6118a7411a5ca60fe6f534aacf4f714a12f68ac62d4721ba2fbb01e685a3423765e4887ea9d702748110d543e5bce2cc8a22848a7ce8224bebc19072bae45e45c51a4969aff37548511a152e4f936ccd16c9501228259b2159882a7669969a3f70dc04937682d098d5a64e55b3a30acf7034dee3aa7efd5316575ee3645d3ba9d5069b42f9e8caeef0b75cf0043f2bc236ef3d77d96ab123ae81e6a124cf99e185ce167c3bde54369f5516fc7aaaea2282a32a68cf59d85bef50e3ac42bfdf8490e2a7dfcd496a945e073d8fc63f1ee8b5d2e48c4d8c5cf226d5ef886018a95185d93bebe74e7c7d1794350a695fc32a778c49babe03dc8185c8356c274c64f19fe87922de577f78758040339715ec7aeaad24f2954f546a71ae61c84cab9c45e00f264bc2ebda1e5b86d59e685284092e9ce51223f551980000ba9b35037095874ed8b70650ff91c7bd2293c5f20611ff14ef50966e57d4315181554eff3d3abd0cb7dd6bbc40ecf94c4fa1ab5de9e680299b25a90f184c491355bd364b5761555c7fadf3fac913c6aeda29e5319a64d58ff8d251bb891bb6211e4a5f8ab0dae107f131769121a5d59eeaba4cbce79ea1e27c31d73e980a31af2b849af474af0896b57a98c7e94c8deb9700735312764c85689b9cf9d18cef6eafb8219276c210d10cf4c73d2690f1eeaec9c6fd06275e309cc066af4115481855b52fc12003085f5f3796ac79f594531026e613460b0ab40909ce230bb2611427634b368dbc76d4e9f1cd6b0730a02b79abdb41fd89fcb5b9cbd4ed95a652c593f99dc2425d6324437ee9583d247f2bd4b994ce2be03ea8f306d9729012caee522eebde8694e4c9c66f93bd6d7049fd2aa6991d7a1134acf440396b57fce01da80f23b15ce93e4c059c962537a23a6076c72a06a89854218de85f5755566b60f2e8233387bc49656f06a91fd5b9567a4a2e3574b1cf7cf768f0bc17ad8b54a04314205109c90e5699b4c730c151b8c9d50c867265612560869fc395d565cc1a7203c461c32caaf175042e5c6451b99fa89e7b46e3462fc6a16348d22fa8c4712437ae59849049b2a62cc2ae6c541dbb04e1be878fc02583ec8dac817a9f24310f14b3d488adc9d146df629032be62d75017473a476e0febeaadc5888578dfd14f4ee103e8d2990d7e4965f0949941dd2482d6109f7060013618216228c538a6cf3fd3a8345efb12b6b20fa55f103c5c4be1feb937675e5783cc82e927790c7272f58833a4f12867c6b273eb559db8a45d21065c6b0f605debef7aa6de00fb6b3f716b4df0bc7ca2e6ce02baee2d85e045c68206531a7820566213f148d91720c2b38721434561ab49dc9e4c8dedbf6814e92f664013573681176fd03325da9fa9a2d1f1ef6571382320d0db2bfc4d7e5b391c1f08614c4a91eda413b4d4c8505151ef820837db81511a271987a906dd15ff745a4fe5b0a162a043e23f7c3b4d112bf6a65d402f7f540ddbb2e6885d60250ad4b78ac0e373fda36b426d8683d81ceb022974976a9cdbde4eab866bb5c28d3d76832885fe51c57fb05196036fe2cc4a0b401d70ba6cb9d040172b245ecb9e9ec6d1225ecafd8b6d737ae440046b5053530de3cbdddcee91294b8da99e843590730ea028089017c68f7403b861ff6856380a526092c54b1f5d19e3105fd31ed9ce83c617f3d8496617b94df6aa0fee050c9caa59a0ef5f5948c7feb93a0f0b3f5e253d0aa53892677caf7e7cfa76f6639180de1a95c9c98373e16aa771a90fb6e49a0d79cf5e647f83272ab264577832fe2b395f9a48c45216d68003f89360150f63fc2de6c08cf20747102b5e57c4df149def0e8ee991279a7322818919b420de32f0cac384951332a2e42631868cf4d723f49eb53c6aded4e6747ee927f8df38088efe3f54cab15029633705974adc9266a6f1049d16b24db7f342c39c9a5a4277d8b92370abe29da6d9a13e000f972dab2a1b8aafa991206b3b60b90312626779560e678ce38271ad6cc54b963810072b1fb128e4e17a904fcc8dc795bbaf0434997164c5c4fb3f2a4ea002bc915fae0b147b4acffe271765d536bd37b478554c92ad27f558dccc7d8dde98e7f9e168dcdce04bf3be3f3f1fc98d6ed62a051501bbea8e944fbd06992b8afc06a9a4401d86c26e4d6f8428701faead77c709db42312fa5e6b2ffc33854b3850d0acac32189ccacbcd43923af60414ba9a220f5587f5b9c6509fc66c72925fa4b2c6762f7f46d3c6c349bbe6a323a56b1c6889dd3dcbfdb1327169cfd2828884ac16644fd4d340e8965afb53bdc52777b9091429f4877ca94cf817133d4901e453a69c4440a5d62f275ed858c3ae945d3f4a05b98dfe16ed7c22ff2dd930a9b6aae9ba7cd7b9df510a6c0d8b3e79cc1a7835b298a88eaee4df0ffc796313460cf86ae4f397d16f71a5fab505515ea9ddaf5191d58d14c3e8bdbecc2f87c976f02bcf0b22afb230d9d30a962d8308e8db6eb66ff902ad82721862f9e0f1fb717c8d3de6c6a2d59e5fffb21357710f44826bee3f5ea9531ca5c9659ca4c327e7d7668d03ab109739d8c222bfb384f5dfddf72bb49a556ac8ecb6eac3005d6559732c7839e1ec56194610336e004a6afcd04939da9dfc08d99c625845e305e85ea29f660215b53ac1cc923a51daaaea93c666fed864abd683ebf47ef6eb3cdb4962b52902e89bb1017906c8c56049b01681714f3ebd18bb48fcd5a81f63325f7b44cd826ca238e25ba300efc57698bc4c6ebe15a17094c11d4ebc88ee78aff318eabb76966a4b865edf00770d485f191c431ea7b73cafc179007658deb57e2bdfa03f8a09b48e9f0d41d1184f0ec41d807313e7fb3be81b17427c230a5b70ef324cc556553757f7095c61a933aedbd4e38dc7db053d6d0db22f75d05421cec3357fd4926b2b9de39138638c6bd97d7e58738fd534018bff6d4222596b1007c823b6270960dc7cb9a7bc1c0976d9d2f8e1d49271573fa5d6ceac0b314c9e13a3073614fd339890ab5f6280bb190b64ca3f4195c923c36b857c9ba28480220c33fcbc3cf39643ee9f79ce38fd23250f1edbd679ce072cf042f102302ad48ca982dd891343aa94f77580266d1c25642f2b12082bcb290ad6bb6ab1ed10373d46d677de72d6d3b414e1e8e0371e22d9bdb158f8d1bf22e438c9f7edd9313f0935615a1a3012fd1d85dc1bdc1ed0516a3cc565d328f56d0acc3f6bc8aa08f754767362101f1551517baaf93fbbcd3b9399b48d39c04b4cedb0521a5c3178cdc40a679d2c3023986dc16b495aa931bf1378e9e5e415f296167392e327fa4f904b6c895580005726bf1afa5ac159992584f42614106c371a71583a49f69535c3f3e78fea1c62d23a868c4723fb933f96f81765b665c26c399d3904b2d1d991904b8ce6dbe3e5bdbe1a2a68a2b970e497775640719ee17859d63b2d6f177226ef338a18d6bc68e4793599b6d557624d1674661611ebf1eff7e35711c6e8c9fbbd6f10c7aa7eaa1b70cda282d1e6fcd0d3a6a960b29fa4d8edea2ad72212e5a597e859ce69e2507c157cb192c962e5bb06db091b7d0bd40e3b6b8eface80988f1c137feb47708d6156cb2f9bb990672929d711365b1f36d4950634147ed848fb871b64bab6e5198ab980c6457ffa22361e6e5d59a134dfe9f829d19cd93719f7de1d013ca8943c28817a0a46d057933867b43814e894c29628a625e6b319728c32f8b09c2439b41d7dd2945c48a55b0f0bb322d74861bff2de6850e288929887639bcf62799ecc377e669d61cbeb08ffb1800c67c0677fe32773128fcadce0743903fe9d2e11049fffcad5d1035a9894457e68d1e3d57706bf6709a5ba694996f91daabe64f75eb20c1d7b434cbf995220e96184575cba82fcb5d6343bc38235704aacf5a0183cfb84fe68bf69026f445b1a5cf2bee90f81066b7be3ca6acaf0bda8ebbf150ad2789d17f68d461c0afd083fcceeb70a89be9b39cfdd776ce39e73b39ac8e60bbe1908631857887d33d9ca0c8058e3f84c2bf198278d08899f64e1bfc9b09cc2aac91297561929b1b74400de30fadbf8f7b99d4112cd06567ae7a6fa50005a7524b408e24105ee429134b8751b2023cd64122563df8302676571de30f56c285799e02f91400d15b939d0fd615b1afb98aaae383be7bf5d98ea0be7ae08fe1a70522d5104d507b471b2d9423f03686384c91ba225cb7e61c0011a95f4d490f7a7e00e0645981ef1c71af04a3cc4ac7bdc3dcdba4855d6c65c6ba983840973c5de6bc3518c8b1bec4863c5d0eca4b5ee632c861224025c55e348d964cdd7f47bccedbd5848ab8faaeacb63a227f4f6c82d04a4baa107065a7f520fac9453da1415f8dbeef7eccb11ad5db0e34f411491e59148f825ecd981b37771c2c800d65b60094d67a8b42e8833c8b512151e2206c3307dfa7cbf98c5e832e603ffe2b5afe9a98b4eb0090937ea1a7e018e88568b5df5ac358229437d39505fd08c1658df6f51b16b8669198bfda6c4c804aae62e760a9631156682d9d5c66623b60f02bec19cf8469fd66689681a8a5ab20824e0ca2b2bced42b5ee85eb0066f896a5896a0bceec389e0ca442c9c91043d1881751d0a85e9c6df38d2c093a4bb8e1fa82d7c326275e50678e0112cf4d15e68bb6460ddcf1d675d71d61e90baac632092dbf3d5b817eef5a7207554fc2635201777e1b2a681a184cddc3183fe5fa4282836a17f2fc2bb8c94f17648d3cb6bc820d1a9352b36616a2db32fc3eb09cf81d53d7a5f8049e7c62d0af1f9ac2b96ce16e23ee922853bf4dab36bb768de1d021d42f464b443713fa6fd478dffd7e45aba8d97b3bd4f62686f111a654c1abd8d7445a18d5d0940c6a5828fcc4fbb7c639cfbae418eab228b997c23c3b4e7f540937d93755ce3f96048bdd02dcdbd43a4cee493a62a06dad377b3bde660c127703c7bbb8b33b5749ff306e4e6dfc33aad450b43b6f72ac6917051de0ff8007d05fed7fe04ea03061c26dde897aab0cab6ed9bf8f4d263538232af9506849dd623f82bb75c7ff7ea53352732948adcf61a54aec90289b3516eda2b2be7ee25cccb250d10f11c479584a2f45bbe9c923b4d124c5a11f65979e5c772010fc8cff74b89875471a4f40e69a4841892e7b5ea2920654f92d96064eab56c061b69afa438d13706d649a67e040f5cb0e9b9fef82a5b1384cb84edcc9f8197c95bce2eddfa078aae8e333380a41923659a28f28b47436ea09b10186fae8db77a2417a2f045bdc03a532e006baec175479e94e43531a2cec6f8ac7f9e8be1c192b403139ef44b3b6c3c87f41336ed8a61c63b3a176ccb9b9147ad7b7cf7a41ba8b11c7f574fcba5576b4b1f3ab164bf8d4e818c61b700f4f9aa3e391b4203ad16a9ec4e3f4267a5dccb1ad650f61400ab2dea66e8ef85c27d6e4af667c6509d31972f7e30f379cb6f8aa5d7af3eabfb3d044666be1c711a0ff066a073690737e5a2e99c3e79adb307b5fb8015a047276c10a8b8a750fb0d38e7b1dbc1048a48e8945100f127e90482612b0f3ea201e4bc351b82a7a4d739720a8dc087096b91ef5fb6f929b61e7bd67b57ae041250ff15f9e9d2daf2b915dd82194b97c1439d8772c5352382611f76fa8f9bfd6df50341285e5ade5f0e003d0b9dd714263d2e2a8c110ba3cd2eb7c1109581c95e8b9686c78dbaeef0650220c964de9aef969de5c0a2649699f0493f0d1ae7354a5363dcd42155ff17738f00a20eb6304ab6b9bcc86d24d43e5044f6e8dc9685dd5e925a1496a4c46737d91ad9f532584accd03b5b4b16ab779c6b573a8d97b2d42fc9418b20a7fa7a0cf34030e2f4095c1ee6559dacc4745a60b0c6394aef5a87328de197f123cabf6c8967df9b0958a7d68cd10b865d8f65f4bde73d411cbead8178295cacc391ad4e58417f7324772039e7cd6caa51042eadd9384d2367b6dbb278ae028addebb202dad236acedb409a0c211a337445b91aa0c5d5dc2c44d6931c6a481c43ee6284a9edd0f7d1a78ba607870cc061500f5e58cf675e838f8e410432c77f46cc95838a04cacc2d87ae0e457434ca66c612d6b41af899e551997dca6a623c9ce7ce951746d2f89bcef9ce67ede592782b9c82816629aa73859e2d999fe7683a89b408562ba976f76390407e45cf599004a6919c2cff6e1f1459a81dd66599c7e0cc30eb89850dc6aa50903674efb696356ef51494b8a90596245d06bbbbe9db956373d07a8962290d7f408e5aa823cabb5ca96d1a00fe588adde7dd2db97a310cefb3309b09f665221a5465a0d6395d52c26d10c6665ff40af8c3de839759bf48e71357300ff122399ff30ccac280833c7340c6b6767a377e2a5702ff6e858d2b345c5a6c43c427160b57beecfb21b9148bb9e6b04a521e49fae579695cce89f0de0d532c1abb30e3ebdc59b2e35e4ea35b2aa165fdf92ca4cad730b45a9c8bc3f14554e677b4d61b049a03b2887adb2b5b645beee4e051ebf5bbf3e4f05d1dd3c3324e66ea29007a6e24ecb6a414ab40940f6833610b756911cd543bcd0441d2a8c7ecfe756ce88d438ad46f3239821f7a02c01efe32ab123ff3a949c5bcb18910e288854b376930b8d12a436bf476bea5ebc28d61d1f40fe950596ba966b0384c55e13abf5b84fec14a71e20efa4d607839283e260b867fe9cac33dd90a12dd378a9b89f15e8ffa761d52fbb482b9d45fadd8c445d0f3e6f223cb16571d3437cdbbe7ea78f0d31fe8933a129e77741558c4bd40823d36fb96f43b79d8d58c3732c7fc0958db7c98bd2c0e0b4c47edaf36ac855e6f1af33365b8f3fb5ecc37c7b679e5c58160c42f181897b3169ff9d83f534ac663a5be6537f6a0b36897cd13b92d48ae25f36f57d79441a0789509a1ff1975df310ac9973b145fd7483dce6ab62c260196421971c7f148de2a7ee023ae926b3ac17eedf3fc35e7f6e2f45604c2ab207634c104a9193695e4b15e538138cc485c348e87c1859702765266dabc2b0f99ad63bf1929fff1f57147183495e74c57eb750a23048080e85bff337e959d6bfc4b29fe935684a8146fb1e15d53b9d0080148476ad13bc3f4b5a301e8e8712798be862bc426d8cc73db309699a6c1e48149dfdf6dd9fd1f4d3768328cd548c549469cc4c9fa53e444ca8b4f8e67529ab8e8a5eeade45700252013ff7081f6b915d064bdffc545d5372fc5d72981699409e198782a0e88911fc3ea74f3da53ed300aa9535687086683380c0a7abc8cf6afac4b343120564d7917e915b93efe32b3e0ab6f2afc68834d1cf8d240a0da7f186a4c6984b7eaaeb5fa4d40293d36a322728b02b1aecbb7445702ce9e1723ccfb1de8c17e2dc2b83ed9b5335f59563d58aeebd7cc4e7c8859f103e7f23715689821944e47f4bc42f4a10750dcd23a593837b65ef95b4d7fa52c0a56152f52446eef8710e0a0211b247a2dd307c9159521aea5642ff474668bddc2fca9f31ac16d4228fe4190751ca3eb81b2c440dac7fa7edffb4c2b493830eb2802f54857489b7faf0b86d1c8d1a2a728c1676e23beb48e6701e77c697848f4e020a2f6479b6c969ebee98ccef30348ae72c026e5f8baffc87b7098be4cd9a82513fcd77c2c2451a74f7c3ee93878c7832ab6c56565b2ed87b5ff1305463beba0807ae39c9acf4019a09a7b0f387d3f2b9e161361578c35dbf2f53026a2221b0fed36be913f9b3f5dbc6fc9195c876431c4e8b9074083111c3a695aadf7c233bb9b2d627d1a677b2b40608fda928ef87822fbffe7eec876c39815b62bde2574b64478c673bc0296c5443b9b87d22e70dfebcc654f494a1555f85cafcf95cb06e3dfee6963a2f82fce51be78b3368451a58015b3c6ad63497dc6a1a95bcdd17e4c3af02e5f942c29d45d6c0872817767447405e2256e827e15545816806a25f8d0e08ea3872de949dbc1c8307399116ef6700d1da0be9d9d91ed2a7e1c9284dc9415999b750510e08f3b0512759bd07ac925ae74d36a6d7e76932676dc0cba47b2d9e73bf6c09d91f3ff225d94fb030afbf23920a26ecb4dc01bb3cd8972f5d8a7b634331d01fa8712a981f0a8e750ed120554fef6df434313856d21cf11bb594c19764d2a05ffb4e9af7291eb29cc74a770e1afd26998ffbd3a3a86bfc50381cebcb76e99ddd858805a7033759e50928fe99f1bc88e669f15e321ad7ae7df92ba710e42bb0e5f4f46271868f4c96a335051ed03b05e6e082d3b73f4eefe28ea413dcaf555c08c1f939e64f64f15e983216adf08a48e67523a44ada511f5521cf5af6bbe8df931d4d6f10a7803902cbab5fbd35fc2204b2b1cdd8568cfa7569b7ff33e34c3dff3298d45b00d9f52d3d4b5ba20b66bd19d3a75bec0821a7d0fd05591f4a662cfe69b4b7bd090ab6abb39a8cb933d2aadba0ce27f01819c4e2e43da963456ad438e74f8bef75f3e9b5adbea4fc1492004cebd13615d87b850d415dda7f2ae406f0466766e6ab1046e058931733da4db6e289a2b9ba9954b01d2796c64b8f371716ebabcb5ea223be37c0e4c42ad8bf1b20dacc5485c1e67f4bd7bdfaafec3c1b5b50956d933ca353df65c53a2021d866fffeb4302ad620a0f453dc5517ba83b01b57dfae4a14531882217bc180d044685ea4a84fe12d0adda9f5feecfba9a0eae85029bf42ef2dc99e76364ebdaa16784fcb5663ca4ee07a34df78c93368cc8ed3d9f268fd04f187e710998f99484c289b3ab2b440785a22515fc2635959648af4356d2fa151dfad5b18669d849d9d3166c0952c97e16f1f206828a159553b0ebde1e18f755fa3624b84d89b00eed8910b0740b1fc2031a7ef9c3445b91e500d0d15c6394d8b18eb12690a801e016943550f2219eb616a6e5b418aa124c601d742bfc5bd7a89c2c5fa68ff65e03a90388ca09838824be21fbd7a9e0fe57d26915eae16fadd612993156d0921e9164f4e65275bbc386ece7898514876ffd3dd5b5e371e8677c1be7e13ad73972cc1b5e3ebaa5b20c7138cdc9ffce7a10ce6a5cc344639fd9433c99c9e77ff328d568ec99ef7c0f8085df9fd76b05c495f5cc3632a76b710d8587f550a4d9dbc23b8a131739e5828e25a08e926eb8df0eb1f731468cc124559d1c5dd9cab23861f0c011276301d8fc4b00b09da1c809bc08c9a322d4a6fee9bd571bb7b963a1377e3aec44c5bf998e3f24fc1c4938e59b0bf599ebc89378e2be9f05faba273b5f2b93e69cf1623c55e4d6ac1ff85e63b60c10d8aa8f319d77b8204ae9a2d8975ad5dbeba315a51c06db1a7eebdf742822c3129b083d8967af33634795d1f8ed00185024f5bfb0b332a53ee0f878f60b25e6e3a7d9652b7aac980d5ec348ca23b86554fc4b651fa3905feb6362789fc198cfdf1fa89d5034797a8efb895ea06e640f16d745948f8bab3d23ff01c1f6e25025f9f897028f63bfca3a1bbbfb91d4ce57c373de8a202e29673e8b3a73c98914fdbcff69c43b599203a1d6f37e75afd9d6bc487ea6f75865a0a3418b9427c230946d764d7134f28dd54c18b2578971cfc01701a4feb7ed1ec5b700c9a7c2b0e6ba1b5250015d1ddf8dc6e6f74572f8ceee057926e42b572a8725442c4c3820d575fcc91948920dbdc8ca2126d9357a5edd4f28fc6e07e0e17482365eff472f9d1a9f5448a434c6ead319fbebd6dcdeb65be20ff4e54883d0ebffdcdc6121da25640f86fde81708ef4ce446aaafd86cb89c6902b4b67947eca8bf19e865f5243f72a101ee27439439b2e4eb01e5a22b78ad464ee34e962b554dea8e8cded3a0a750483d4af93bf3b6843be503ee2a5e7dafe5f6b6846bf5a40ad6546dd8ac58abedc5b0d2b5ce216189d0ea0ec1fe4b6fe04171a67e3acb1bb5bd7623cb874ee2c50a5d6b07b7ee36ecdf48c496","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
