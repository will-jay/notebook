<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9af62f7fa62daaebaae6bf6004de20310969a649fa4271febe6dc2cc463d3188cdacec88f0c60c6afe08269b5281af7ab5a828373f3957c6a8b63f2ff1bee6e0cb3b689a81b3739e457a142478b44c348f17ea7464c1bb74abfffdd3defe624dbb763d311e30476a4f67a0d761d4b98441f1d9ad54464e07480db342ded70bbdbae2583c837b633dbb5cb88b1b14a032298ad8e457c566b8a6fcc2b155c1198e81b38e66fdd98ff53b74fb6b4428bd73ec8d5e88763543908475a6e23f0716231969b57e27558513fe9210d9b9189fb1016a27ed99169104085d6e8c53a7cff83ee58ebdd577302f040ea72e5cb219137de4e347dd174d04504ce0429d9d6b3fca5cd7dbdfc40399417f99343f69a91d6582c29f6306b2377d9367f6bfd887166cda44e2a73186bd637fb2b1cd3e5278d1bd3c01e6bf011d2102079ec53683d97e850499dd0c27a3dc5d8e7800196d3c42ab4280b3fd45038332b362d209a75bb3d5f193d838eea1e1747678fcc5d4d4477fde1c4a94ab326a8927c36e5f8e3fae70f7a01f4aa9bf5faa1e7b7a2c7eb2b28f3961ce70dc079bdf98a8ed4f422ae6ed6bb633e13977d8a703a55fae13bdbaf703e26014ac5ac217bd248eb3dce00802cb487bad5701574df7b900f87fae654955577e622fb36832ef58f50f54dbdee8054d99bd7be475e6c8360c182c63ea19d0483d6af083516d526cd0c238442ad73647d727182984ab83223c927d9e29eeb74c368006530e65065ba201d2ea3ce26e54b7b6487fe44a446758922acfe43e259ace0ca837b4287642ca2c9e62e3037c72018106d237621c133ce03d184dd76f97ba77743809124f7941239dc95121737ca5698a734a568b1913b9b13b12699c9f8600e51b128e1547a93f30581129cd47762f859e35cccb11159aa94fa5d310ee0c50cfdd36dc0fb39072e22a5b6a9ee4e51f23653a894dc1c2a535fa689fd538ed1b8e7d5e49b1764e483f7c1760fe1518bdfa0a64dc2f22d3049051322a19a29106c177dbfb8bda16a9d215d17be7f4ffd04e80352a306023d5a58e869fd542897e198467c49b25d125a0ae9f5257c6e1034b4e5d73fc4a763987858c792da400746cb041aef7553540b4f945a7d3091c2d2aae32cdaa35cfea4fd65240c19b789d0f9283ddb2962b6de6f3d7dda8621fd53872053d66050979cc69a50b978e431f6a649f2248800704b435a5cc6949bf79b7222fc6fa8aac483851fefc04414bed8ab51ff3bc3f7d9bc00bd2df11e67407b734399013c9a4e4cbbe6c08df84fd9e02a40baec9bebaffdeed09502c6cb5f46f37648b775d3bb293a8f49e81e1da9242bf3501838d2415c665dc229d627ea0d2369397959bc02d56fb8a83b95fa360e7b80230cd8d719edc702b5a1b5fb7cb817c937fb5d051e79451375eeb6b3a96895b16b824a936540be831d4c35fe75c614cc39a220efbb97356de56f8b32c1cab288a52e6f602f3ce8aedea7f883172f217b2f0c06a6b3dd73981d8fc4da39bb152ce62e9c550596f92184719203ecf46368a9868e2ac04a8bd0cf1bed049b215375da4e668123d367a66e93d396a7dd4127b68b64c385bdea6d30e109e1a55fa7e67fa48dcc190fdc7455aed1bf7f8719fbfdced5e99d8214fa8736990d79801f7dfdd67ce853a21a45021f7ed39a44af38bee312fa238ca3f29e123547a3d04eb60e8e0dcc73a45918cd5ff38d1ed52eeacd0bf14aaf686ad5099d85b370df70379bbf8466f38706cf75f7da204d0cc1bd5bccb6ffb8f1b926e6eb34d633d1be7013aaad75fd6e6d10a0650ddcef5c1fecc7d931d99e71f4928a9271791fdf2818e84546600c5189d2f4d1d185dc8d02acf64b99282192123bfc7176be87ff7cfd5028f2355a0476cb38222ae099ff00fbfb0536e5baedcba4ed16daf43368f3a527eeb7983956bcfbcc102577e0c3a081c7d4c98bb9842eb3a80bdb1efc48c21ff5755e5a97a95e6e78eed92cb64f70b94ddf358be666c26bc2ecebd6d536607dd0702f3818eb5d862bdff6bc6dbe2d737177310709579a67dec92e4f897717e61df9b6520514c7d1154d60d978888df7962199b34145baa90cf635a06aed14298589eca093244cfa3ff1b296bfa8a2a8dde4de068a0475b21879381d9270487c6d8d163dd96854e1af696f669e47d8d4e114f51079c07cf642d8f64747ef7112929f13507996abd8c2ff1387d3b81bf91b9514a6fa65bbee3604d5b6f19ec90098c891253b1c911e7ca8abaaeb8422ab8223f0bf0a505f6919cd7d773dc06ba45ad04540acdde25274f8a45d22f77ca8c15020faf1ed9f95ad62a4bc8afd6de22c028802b3a69136235dbbb563cb228fb03493e5b719bfb6d6a51638c7a1c69c27e8fc5b835cd70fbc4b108796d1bad9f6f5965e9835fa468b72bf0ed5665269df2e7db71c3111708ccf10c131277a07c93c34e1b9d9032014c76b11a1e8674288e52326562d00d1966a460395825d6cdd9fe5ea457bcd75197a64b2430e05e5f248dbd3dd883172f8c25a94ca16b9e86ff55d67037ac600627b4751f75f405360e5ac4dae594e01f8c695f16244a70be21a9e096db8f37962a7bdc4a7feb96d6b073f3836c6539499df40dde18fbcc62b65bbb6de10180716b287cd7cfcb5e074e0b1c3bbe8c763d9a6e1fd684ad7a1cb010062cce94b5e480c44c1451c698a4f6def63292adc06581483130534ca832ed347e88dc4e7a94ffae51982e5132c87c0a51e2b078f9d30a0ef8c27fd9fc73b6e1b002bc82f5d2b882bd9a61dd4e9703907ea9384a926a8033a2d180c281b7f51503d78ea400a24d672f9f18ed0e639fc0055fe03703d26457824000337c9ddfe664b5aaa7f9ae1f3525a3dd2915185d3b2e2825769a669cd8d1dc8d0ee57f3128ca01153912324d2ce2be00c0e27c657d77eb664a3635a9b2b20c2503d67779cb00caca5b6261eafee4952affc4f719f11b956b75620347b286ddb8b8e15e9e466e0509cfc09a0672c08535901ff187723595d20b90bf37f0f34b68079a8b30ba7681eaeafa030e15c90715a2af286b6bbfed5e8ef2d7de4b3aad207d5ad8ddd4148a201a1b2f5abc0101890b8ab2ec711113e7d1fc0bc0e251595a24367d1399f7394405da42f6e92ddc0c2e8117e3e62e712a51fd2e1e8f1590cd0883150dcf36a1f0718709d6eb32e757ee61680cffb15d9c42aeb7f777f5280aaa415e1ef343285149eb49041fff18dfb6898adfa30856b38bf3b7022215b023af2020e5b8f92c9cd1db4a328a0968dde9ca6200622f449a1b61dadbeda3c9ac0170f2e7f620044e2b2115efdf1eab152dd4c720e99e201478f2679d028e386e1c760cc906bf79efb83b76cb899f7fcec4d8250a8f122f5e4eba0879dbbd19c00265d513e9dd569ef1535cedfd4bae1625b9d81bde1cb4255fb6c0fd994cee0152f7553f3a419191174942cd230012c24289fb99cb6cfbbb6fbadfb4132c37038ace769eb9f6b6da87fa3533a697ebcd51f2fe03121a6357b2dda1ea3551320fb0a6bfda1c8019a66dfb982e0a631691b01229076b91c213442a4dbc4d51247ba4b8f3c76b6d8ec8c5394be31f44ee307aaf59f842808c6130ac376cae5d121012c38ae8ed50784d4809e42eb9f2d8cb725df3909b38ccec8816788d1d85b16587304558545fef982f0ce9271c6c24566763380e1a5e009ff3373247b27076644942132d6d8f619c4e399d68e5d5b46d955738d1f6721db66feb3285074ba260a862690c994882b4586e949d6ac208f8e40707a0df40170eeb3bf5eeec49fcdd5628dab4289fa4f8dc66c93ff06c03bae88ff0b4191ef2fcbf6561339c8b56ce79a11f19beb49ba38f7f80465c419bc58e58526691abd34db7c1ea2371bee9a40a234c29afb9d1512cc125de5872a25f465017c948fa1b9e4f3569427928247a16816853b50f1ad3eb3f1a7130c61fbfc8e819b7c826c4608f06e02c18919445d585c914f7fbc94dc4cb57cc07bf72d8e9832d2aa96b3819918409ef29273f1aa5be131498b45b9952f3bb3d24034113f15b556551981163158e4232ff3973def84311f71c8c3d04effae2c32e043d1c93358b9fce6eddacedf269045eb0fd634f7327ab6229704b883c60c1a3bfd6b529d849218ef1a95c3bffc3a4070621e5d783b60a5cb51b85255cf824743adca6fce9a9791305a78ab795778f21ab679ecf786edaa5886db5f01389dee4dc77ff0d8df15b6e07d6226390a7cfb81c557350614d231d77bfcba9a8936af876d5a7ecfbe6f4dbf956d4cb4ab87cade16fab4d074f14ed39a7cbd4d1f34723525b5cba6c13b47020980a3e103c8a98b7c6901ffd40fea91ff870db5aa97bb74c9f63f239086d705e7c4e94c2bb1bbc4bd3e8e699d2e93dba1ec18505b2e1ac738e4f90a86efe147fbcbbabe9030fa67d2b1ab73eb39846b56dde6feb2ab8864d012d7249f61571c3f9c757a0de3debe6ee3ac0c3c13f83797f8422003b2ad112b593186654ad9154b0d18978e11518ab1699a216f2c770b0d5ae91ba38ca02998730bb4e6108b5cb092c891af870bef275997458f4b4f10bd213d907a4bbb20c1b6df18d03b72adda6de6832dc834e0ef76406a5875a180a00ab565eeb49c6d88b2e52a71936d2dcc0c28804be43120ae4fecedd265c3c01937429617765e16bcf4789f3fd0193c80c148eda7b1d608b697812d96c7fce5a4e528d105548b1e4383bf2d873fc4b46896808b72a9cd42af0e0cf0eada589d08658aeee2d09f18bbfabaab9cbc6aecc2101a442b41b06ea350284ef86f340ed33b54edbd62ea7224468362ca8fca27932e2ee00e4dc4dbd545826ea0cf75e0043f5d1deed8bad0dcdb55e81404471caa3aa435c64031d74d260acc73150940281ad0f6a5b1caf375a6fcd6deafab88143d25d835e54e3156c407252be08f28570fefe1159cc0fc43e2b27b7730113821fe202fd8ec2d2f7f770ba07c80e13aee0fd54dfff34d0fea7c94f053b34c6f5cf125b1b50cfb0795b952f0d58590a07ad7efba05eebc9473e874d55ec28180affe313c3c4721a35af27fc8d5b1c279d896d6d69516dbdc1426272da5e9c90056c012b6e7cb09e0445f26c51c0dd07c6dd212f0c61400342225fda54aa46825fc7bb01b671c14af77ee26993b44e424d7a9d750a766177612beef852075864d9416e561cea1d3ade0471c523076f54e3942e03d38cda8d56d619bdeb5c1e1cfb7aede401d54e61176ba0aeafe6560e50fbffc575b2ba3f1821645f99f77d54bbb3b343179604cfd5c57ff1a3519a7e92b172cad4b68332264f8d875e98490fab86bf78eb6658344d18ca5ef6cbc55c18a755c7f174ed6335f01557d05e1be1c191f61aa3133f0c2ee6537d4953c28842aac6b3bc7e697ac862a0847ef79d58f4fefbb890a3165bd8ed729a5a70e221d57409d2044cb073261670126a1c57a09536e2303f0352c9af90e3bcb3dcbfec86a272531253a20b5e96956fcdebd1f7a7fdcd1fc089884d3f05b17bc876d8b0f97d02deb5002c72179609bc07ed082895efb75e6d792d73c5059b9efb404e53fea7df3e3fc29c9fd0dc25d4a6d953f7b06cfa8ae9a9f39449fc2bb7b51ea2372b89118fde178a13702b8c8a10241c428f225a9f44069ad0a3bbd359406ac2501def19b43c92f27d5f06becd569b5eaec0b6e9fa17aea8280fb07446f17f9581b030e1fc52999363ae9f2299984d9a2d548dc0f5326f47c7c2234a1591927b012ac2201cb92660af4ac3f1ddef181db9a07339332fd95a266199f844a3aa82d601d0d1a35622a51eb5f754e66c945020ec817efa43115cdcfdbe46e45319fbfb00f9f422fb2831826efb79892e41ba8c2855ced5577f51b79303a9c8eb66bbf5baa8a8596d319d0c67dad01f4660ea8d73dff6a5064525040ff5b0eb713db2f2293b6e83b359aa5a700afb9d74151a6810f55029575cb2435917171b83d3fbd9394407154c9b0cbb9e6d7ec4fac4831d237c7b4dbca1654557fb7e45ec70050e08298469f7c52b6c460dbfe6ece73dd1572659b4a8be5c8e7ea2e0fdfdcc944e8a42fd43e7c7c7fd114fdc6a0e91c107bb0a845b426357eaec7286dd6182285f9a83c02f0eca7d9c692e854718359d4e4429fd1a2ccbd606382290065c68f48470df0954be383714572bb415d6d93e35d22bab9d5c56c4ab7fc104c54129653f2e67d5ac3d6c380040b5fe6ed3a74f83aa6bbf2647b64dec2c5406f2f82d66bac9c556ec867f5f5202f548228e8ebe3ee1b6573c574e7fc8ed4781d6f29b1094d45b57c1500d8db417d842b6562dc7c088e4680eed9508dfcfe54e2b19871fa57b269a8e98b9558110d3cb37d435ece764bdbef014fd74460ba89c659c1f1b6caa181607bd16f8843006591b5820fd5920da1d8d547a9b42c14e7dfadb9bb2f13b469a6a146e3193ef1be1e16c4e90870dff09826f97453300c1d2f8d0e01b0688b6a57b3a2b6a3f4a26a46b2e050acb74658b759c1620b629accb51c5e58c8219064b6b147894ef59d5c07b8bc1fed08820357115b804279a3dfb15c7d0954320dbc8750bb9ea1e320048f785cd3c77ee8d9739aa4ecae1bae73437934a20c740743cefabf688cc88e55b87f2600d5199ae278669b3b6b5c2b12708c683e93121060b5a27289095d65e3fffd5e60db6793550dfbf282546e8e5edf477e59370fd9509e405b8964f19c371a02ad10008cc344f5becb03406d53e496cb520adb319e6893f324ee9dec00cf488c9a8e4c5f55841d352bf72a2cdb6e7f26eed1881d2237a8b79a9e06380668bdf67b0d99797394be7510c3c31a398066f894d3019b2c50eda038fe7eda84d539e2427022890819c07f0170914f175dd0b68749fa13c8a98360a4347259c794406200165e5f00183792c3267edbc77e49c157a88a046478188f216d60f7d37c44cad03f59c7e9002ce8c95c4d0685903fe94eae2af080da1c3c6dbe158dfdd677f6ee3c99bd38a9c2cab17369832c2263afabf5d439014bf1955ba3e7b8837a81d7f2bcfd7b7808421f04800d89adbd415ceaf582bef814a4dda478b3d438772cbe9181de684944234ec5f19ab41cbd629fad6f0d4e1cb59fbbd32cbf71355b7ebfa8ad1553dd665576c65e9549784c9b191cbc6b2e583f9855290dff9961d2c7b3afc17e147c325c10928d3491bd7988400e21a3e2f1214ed1f650899e3b01c896b04a80f6de755f7b01ff20aa6cef977be86a5c93b77b7f709044f1b9fa0961c974fc57f36a9cbca8639f0cac88d20d93f85a3f7f7c02ae927f6f9345ba6ee0cbd0cc6984a2a0aa4f1ca2fe2dbe9d775f9f54cb8fdeb868fdeb56359a65e294201a2d1f954b30c6da090234527d62a8d90f41db963305b9b26950dee94c2dcac131afa82b95813e8327c9317a037528b3326a82b357784389e62d98bb47d7107a234cee83e7656e3eafb80a656b2d70a135712507025964ceb3d7dedd59fc086be599caacaef78336b85afe74416fa21c767e41b49589bbdeedd7819fdad57cbd055c21e448e486888b2afd9a539e66ba49a9171fad2a5da396ac19d23b3d6b4c7786e9d12dd4a1e59746245a62bd8c837c14fc0e196d7b130c52246aedafa8838e021c97eb94baa67f4289a08407692e8f056b5bfb4afcecbb8c269254f7bc26409e325aa143965af6b7b1086e726cd8630148bd0139ce9731c4c1508e6592435b2a3c8fd860e49dbc9c987a4639fc9dddb10a4cfb3b959fa01f48cc9a7a9d75db7432007aa372c54c40a16822d6bfb6d6b85064c305a0b7ee7d41e57f5f26bd2ff75d31f63865f4f1807d4494e261d1764cbb8b313a3250384a377f978d53dfaed26d5aa2f3c0d4f8ab7035b868e5edf788e18d75342c0f66beb7916e438dd056075df06bcb6a806cf20c5a151c0bf78880afd023fdc070232dd823cc45257656c35eb50d6845127da7d74ddcb6cebb05aefa3977c7cf73a4f39ec1fdadc9770fb48b79872d04211d0d823faf2f213d6af8e31bb5f4dc84b478f73eae282ad5961dd7b689af3dead152394efa33674d40bcb180637d6bdb0d6aa1d10f940794794f811134949f9a2d159a4f9b31cf1684e74d50d741cf9fdee2cba01f8e015b8095c4a3ffda1d0835ed51bf98c3995b4516a929cf6e88f8a3fbc08c9047d3f21ac5c397648a936454fb54bc08c7963f4801d625cd48cfc2934a9f8d8c502b642097db021ffe4ffcad8cdbaf149554040a4bc22c7abaa8508f9d75059c2b20b8e1d9f993e422cfc4b3f1e2f20d24ae819864e60af14b912df7b57c1c234f9456f10152d2b35060f87ef72da2efb0934ada4c4ce00c50a37276e86046a7394be95e0d2af76292f511a89b1a933be0b2473f31862aa52731daae9e3953ab08ae12829e882d9ca90ac6fe9c05d67ddd52c4c7659aa88cb5e67979c40e3f499af21bf244cc8597acf80c611f9dcaf0e032106776eebb7288152cce6c4970d9e5b009a28f1cae6b17dd6d6654342db36ec693d3973d7d1610681732ce5bce99a83b937358f2bf344bff4ef5c7f2d8e91a1d6db19bffbcfae6848a53d9b5dbf946ac7c0b443c30d87cfa84cdde93baa1b70a9685cde1169384b7da1728bec180b8e6755dfe5081bb89d78cb556e94bc763c3b141482fce17de8c5a9ad0cdd46dbca892f316ca20a2d0a6358eb47ec00281b6e342015496b2b9b6f65c405ca2a544f4ee612c6d119a42b1a7230b2f0e2d827f7a11f232a0b00f6140c7049eb8b0d7b4257ac764935a5f141b5828bc13ad4a3451f72ed6a55eba5a258cb796512c0cfcc0e57f0f1672453b493ccc8fda4ac68b5d850d52bbac2db24a8a33f6ebabd6135439be8fbf9810c0e968e340a01a507662a0a1575ea45d208c634adbdd51275552c2e3f1ef14d21d26340d037e87a34292e612e726ffcef09d88bdaa401c52bdd32c4350257fdaf904c1acf6cc6845ee9f0b00c69ac5c1288b69458ec2ab7cd4bb354d8ea6c41345cc5ed6607a26f2467706fec8f3f7b8d5984df2f5e1b30f8e33e400933a0d4315b0c1573e868d249cbfbcdfd1b7f19fe54761174276f0131bb9d768c0dc3fc20720f898f11a4c4ea1ae248140af8067f68200e614db210dcacd7001b76d90783c222c0f988aadcab296620dd03dd0b265325dbbf7e0ae1e0cd6c6cad852c95554bf3ef67192259192c99c7f1fb0f8c816570a2898faae16fbe143b2d4c14dad00cc029dba74a295fbf1d5239c72afcc32b01dea357c30d0ad8a212ee9af688c0bd774be2646ffe19ace8a1a9f6b3bc5f595acb3e6bc631558f580b52aedf3c44c0b12b56d64a544990c09622943140fdcb6ce590f0c15a94a459d8aefc2512995837088fcb526839f22dce1a9113e08401d1f8e79b54210b2add662eaf05b255c7fce2e5981f2b1219c3b3f27fecead40c31e0942a03e972d2930be0ef5685ed6678fbbe2c0f26c890e234fcfa93020e1fbe70c97e910fd1c9e054ef2af86663187697da04ccafce6ae72901075db68eee0d69927f1fee1fe2dbd26ba7d02e332b768cda437fd6d0f1305141763fa6ed14f4464b56272c52a25b35bf46ef04bcd1907fcb5cd4a1d5bab60dccced7225eaff3228b5e4295059929c41d86d001242393c02595c10d449a941772e80ee177673445ce4cb9c3361569733a34f7f413b9df4906e224a02a76d150169bfc5e795dd966d4d61af64ee28e802d000b9e54b92df37a2dd941e60744857fedb38748ecee8cce52fee4c8f8c92f92156124786f8c2f84d0b5b4d781fe73b5c598d2e4c9766645c3c849e12fdcf61b59a8627c25397ed700356917d62420e69208574fa0553c9dc42ab33278ee4720b79562162997db9e6c9ecce4c76f389ac98ba62cc21b79ce402ccd27bb02a0f24be8e87d388e60fb6c4152f80a1241dfdc2484a77a85db55021199ea48dfed94588119ab75b5969ebe25211000966ed83cc81dd4c1bebc15d1bc698f72cff56609bf759ac03d02754fb396f19cda8596af62d5f63f3b4a8693a9fd9a453e55c36d95cce517e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
