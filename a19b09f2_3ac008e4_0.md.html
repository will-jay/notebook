<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d017c859c5ef82cf14faaa64555ab47e787141169cae6688553cc0ae31c7c0efbd957c163cfa81ceebf7fc130949806f9d9f452452fd63dddc25d30026d8adf61c685ee3ee2774fcc87edc14008c4d0eff3665d82e8ae7158e86106b843a6a292b09282c1fd3cbb8e91f3a5e57e2f8a3f41bf5c2efd526af7f12f9d622e25dfa0666601d0b5651811ab9a8cc84e0a0acf109b1d8933beec89e0dc069b38a395aa9c11b6d34d3f63da600c6d874a537c31efb1b08f3f872eceef7955622a4800c7bc7f573b2edd2d42ac88ccecf71fa83565895eb5a56e573493f1b67000793feea3b446082a2f7bc518bdaa1c884ec7a5c097682a354abfed5ff7a35545458f529d992e23d898ac827672e9531d3c7449fee28288cddc5b12cac825aeaf99500ba6b87528bd757df9790f140d796059e004ffa359e1afbf626f17d4959121136bcdfa8531774d339aad9b53ae983bdb15776d8a00d77aad65e2e3426143ac1e4179819d4544588ec03b64e9c0141ef1f992f906076878a150376554e95b44e3e678c34d492624918b5454ee1b3a043da668f70dde60236dd9f5db79680af8de97a98fe2f05bd72802cff8f261dbf7a3ee0d3cee16a8bc7b92584b3ce1a8a9d6c93540a133d6ad6c96407324bb89ccb4d4cc9019de4cfe0d1b72a6189d547a9a69eb4693f832af1af69cb8aacd7e8cfaff53c7765250fea139df3c35ffa80ca253fe0d421eea3d50bb82bf30f3f478c3fd73bb68e3dddcb8b902aab5b8cbb2417ddfd9edeac1a31873ebb851ea35622dd6bb88e5433f73120763388380cf8599bff11e5d43202a87775de9fe91fbe6946771d73896616bd4a6ef8aef1d03ec782d0bda2b25f5114789c81f2804ed45bd25178f6777100d2d61b8a282320814800e86a10c3a5fd38694057b4ad69fffbc892064b8e5753f293de8b1f74ed09cbd99ba849c8ef65ce5c7ad0c6706792ba2d281f87bf7fd39aa25990694472f106607b7c298a4c38a6c35f84037a5d02e8055359d1f8f336e45adaff30fd2cfb0ccb7a2d944d386946beb5b7db07ce9d94719a517efb30faa5c68be759461960ef16693775b6cf40cc4abd50925672ebb872077890aa82175861c63fbf1e4b6c6060fe9e085e8d81629d3173d515ec385331ff2f3c0cc795d84a1970353840033826beccfa0ce15e5b93b8a1c44110125ef5583282676856f77f26b3ced0012cf5af978d51b2051f167d23be9fa39b22f172c26f835af91c8903827685207e97206414dad689712e2ba9a57e2f44fab3c479fd3d439a112aa533a38e780d9ce522b7bcc6ed80700539001b66be334cdd1ded83c2af672ee2aae3ce2f303cc44cf6204b7b4d2cb438433fab27d9cf9db60472b50a3e3e13425590196865564e6ff97eda489ae14b19fbfe0ead43df3d7d69a868e46d4eac1d46d8ae4a0b126d4c8a1a9c903e77932ac0931b5f6232f057ba43a6167bc560d90fa506d49719a8ce90b8931f24b00237831d9154bbd8fe12d7df10afdd9b399ba6f2c6bd556274e976c2f10a66333362c3543560d721a3857466a436ffddda59ccc3b62826868df49bf44018a881f443b99b638f504e61dc8a26fb867a1057c495a6fd9df4064d24a9232331dbdea748941d45fe71140b7c78acf55fbbca669b42a928a9938eae55e44a41baa9e285b9072397836cc5e12c2d91db5b23463cfbde522ea85b1953542916c153272028b5f9fcdc9ab69668f210e59263240e7f17c8acbd8379a0c0fa90a58561867c8d47ff1c737fc165e20aed8c62372e5cd83edd35cdbc40f44497dae066f8759ddfbd65b8e598ff8d65267e315346790c0ad3641c610bb7c90dd510041809d273588cff1e6b1088a8097c7448cde8fff4abd01ec3b5aaface86a648bc1285f6a027e37a901688c197fa79ab9bfc88ff7a3cd8448e0c5d3ee8b6cd1e323e0c89e181143327b61cde096c1d9ce50c69562b1d52ecda5f0a98bdbebb0f0f29671072a47050540aebc6c314de152f4bcd0684d9cb7942218716c1f06c3cbe48b0819ea7475dfe2bf3d2d79240f3f8d123868ad937e49222117637e62c0a55887041f6990f28c5f81d74472c174445be47b2ac4ea73faedb782023da9433a0b8d66835d6a1dc3e1876dd652120079ba2da9721fc079969a5f126c6b77bc3685818de2f4113f89aa3d4701f7aa42bcbe8781596b53b799d1e6567f28e7c4767957d152a22f6bf4ad7f6882d8e3038fc51a52a1e0b6a06958cf05d13a1854032bdc84e006d86bb5dd5bb776e1d00d1a3cd099293f268bc731400fcb3cb3847d6a068ae49ce0561d79fc76dc712057ef5e19e257b0a3777cddd7bb559a270d902cd46e9bd5da2a32e8b4bb8d44620975fdaaefb0379be83e93d3a6a446eba4c5c520f6fed1eba27bb1cddf1180bb9a3cbbb835f7268953b0ec84989f4108a6d098cb532a9776257fc3bdb90a22b24c3ac3ab6d12dc8fc492767de9359b321d732ef7efda8aced47176b9ae4a67606c5c477eaa7507a00ceff4fd88dad10bf7bb1eee588aebcb643bf79f57a2156068e9c8ad688e5853595e9fc368a5d2995312c2027c12e784a7e55d68caad4f3ee3ba70abce0a160621d42b979318f0263d4427524ba9084bfffcb765e2c35036496080da4d619799c7f233ff61f0b3a4e9143e13e3b88d8149844a4132da02ed78fea906c83c389620a54d23813fd1d645d6ad04ceaec8201f63e4be6f08837d67547062839ad082eabbc5ab28421433576611c8aa8d7d9f4df2c2bda83ab00dcb9071bf6b045f37ce37dd5fd213dd8c5fb138fa8f2e2cf7e82d448be62a280979822e72017a885ee30756e4bda37a508102ab41a68f178042947ef0bf5922ee3d5e359124277ef6ba6bca9a345925c96fc9146a6619a04e33c72ac7e280413d49301328f07a5a8350b2b1e7871cd281cf36b74f2c16180e857547c1bb7a72070cbc1c9e7999080b52b48bbfbf36b49aef7a524d2c9659f66e368c0f57caedc0dfe8df7400122ab45f9b2071312e3a46f0c25156f5f86d085fc694cc5eb44c8184973a7923ae5227763412aa9545ebed0d06f27641a2a0183ac396548d4cea0ddd912d03394ad30373afa3db886787fd4e0112336d97a8c90d7dfd721d8e743fe7b1986574340455f1387b3de855f4dc0d0b22ad309e9e46c999b7200bf82a1f662c357f352bec5f7367014b2011c21e044057083a269db5d324fc5491fb6e79b8bab5d1ce39f6d77a70d588926dc2b9966e8f83a1d706801ded5b160ded4e3ebd5a52ee1ccb685dbbcb3991aabe9426a7fb2d21dca48c6d71accbf47d4791b2faedb2b6f1d5bc2def88b9ee8c836d49cfb3259921b6612ee4a93b7e880428b74a1c56d14b97bcc286f8919ac99405afe76f18fbed417afc7029ddb4ab5a71019da3161ef10db3788d4df019571cd682bd32a0dd201e9e703d1c0dc8253f84819c64f505b74ca6047f617fe4a61ec28481fc2622dfa9d22d743467b1bc59c873a34209c6b18e06458dfda095b5c4ab9a9f9b23ce6a0e20c147f57da4167c6822bf1dc4212cce27bcb28be91bb3c950ee767f78c02607caef8db4801d8cb3add41babeb5d1a8b9f484367fcfdc72c27f1df8bd6aec5c3099937e878305b5e08cc2baf82362b0e4420ab63c85550ba14f6842cbaf141ed2b4159bc373b421fc579db1be0c6bdde79ae75a59aaa19ef51720aad4852f4c35d54cb828e6ee4b188b76791758c6531bfa9954bd47311dc6069792a29830c779c1109757d2d613d09dfd9fc6ee1eb45f1cfff6674a9762608a74dd89c7e0ba8538092526a849ce4d5aac14af887098a46af70a2d0f25c9f1e7a92ca303d86da8e2a5cb12a7aea375120fe885042039d8a2e66accc0d82322b611fec0a594d558006ed70f36a511b8ab2d3ebd69909e7e7b728c9fadc6d6b8b035d15df3b440796257b0a15f88a720a3a70308d0e62972f6be6a9a9915bbc9d7a964b47963bf8a99a497b4e7559eeaf2f44f4e81047b2a25a70d18b3923415b4fa85313f872c26d68cad4a14d6154c0a8774062e3571277c33bede141fb4e9dacea48ff56794053c7f42354396332d7c2ca05c02e6bc8adbf0fe66693d43b7aac35bc87fb267c22c9c0e4cc7955e20d15c5fdd361973e52e5cd1a90054f8a860150baae3c158551730cc2809ddbfede10dbb5a2d2944ddd564c84e62ef982e02f9461ed19490bdbefb083cc18c7a36acd0edc8d04ec285d9d318712263947ed711d5b1d806ba6011670be7586252b47fc28a409ed3464e85cffc73b179baf04937694c554596f678d2dfd38d2eaba027f8be99402549edf68fbc678312fac92dc1a390bc429a76faab2e53c19c3c2b73fbb3bdd84683dc291ee6c842934cdbb1afaaf712ff259379f765ea3d2162ae2ddaf74eb6622ae031ccd5dd352c30c9877d53bdb420c75a157228074bf19263d6d2b439462382e968a68a7ef17cd6ce37e3eb5eb07a17ef53165582844a920629839a15e8f9c19534e6a9de3c33929506b3f30207b50525c0a3b6b0557f0c41d8e9f16617abf2d79cf20825edca16ed8a3bbdded1c18bdd26b8aa1a3d9e9e6dbecb3e9efee4ebe8d073ed7e97b310cb3fa4b3bb02866f187e40071aaa956364876280c9a7e2b54931165eb7da51d4c4f616c9360a2aa3bc66f43b02e35ea0d91d674e32469dd2c5e528332139004d2e0c9314e94184ea2bec56a4953cf2328199f632e759729b0e8da9d7171b9e86c78870952735e9a8bbb781bf7c36ae39f72f7f2ace6b986f4f05371ec3d4ab30fc046b3ceac694a41afcadfa41c0923bb01b35539b6ee56040750e245b43c17807118474b8b95347921ea127330970cdbe597e918c2a8b391c842285def64148a4f548a821069a6cc65b7013381deeacc8969d7e50030818217890deafb9ccc10c3e443d375b3fb0857ecb464f2572f35c59e47cead4c10899f6d05c7d5b542ac45973e8ff6c53aed7edc9e6792b35bc11297924cff59e43f24e06b9944960583af8bb97aa932038fdf93a2ec752d8d90b170868dabf82026a819aca72ae9d8d88f8211c292691142091d9b497448b7132f385e87fb69d0d69f526e218f27f0c51cd9d6048f019cd7091af83ce545ab13f8a736914aaec84af84a33d372498f9d491bbb64e31319a0ad1468e3f73dc6b02b15c667a402915ee116a4622b2e0e79309758490a1bc1a0a4f5b9789a6d1aaa5962492d0bc2a5a1c20d11b991a7c1906ac588bc1e2bfd0ed83642b72338bc7f52550a1268083a7382a46b059e5b633b7226cc89a13531585866b39a018e6c836d70108992e0e589a8de77cfb90ca123dbafdc436c260e10b203a29b1739720472ab2ea320ca0952f8874cd71183fbb005f150d8c957d959b11f1781f691fd62d90b4e1f2e73660c70e5252adf0478707a783d0234620746c03b04f5a252b99a717d50428774b31473f6a637ec38ca73ef3f6b1563f19ac2cecda733810c5ef62933219aeb5d5b461283df7cd75314836999b2a5990aa9456fc37f5a1f9a0a4b357eeadcb3a8878c9dba66be1d4b0bdb4bb2162596c85233e24226c2d941e52e2a7668454ef2757aa972028f4036e354f64847618ff136f3c89ada37677f970e88d56a8a73927dd2f06584e458f181c554815defee16e96b6ef6b7d1e43b9a42f1e9200f1d7b20b32861ac97c6276352499cc215f2dcf2f19247ce158ff372a5ac7ed0a0b8552e05b1ec2bd6cd2c3d6e079d0efecf784565958ff270318e4cc9b402456c7a9ef047d95522c800257acfe9d7255d23d83c12f07cdc5367e6f21a6061c685bbb0d6638172f840895bd0cab16c22ffbe1d7e35c42c9caf4f46dcab03207170dc75d342484e747c38f4c8bf02911d6dc9a3d14ce90bdd71db2d6dbe0aa555b77bc09af79895377f50911def221f4e4ebbd546f54bbad5bae21b31594cc359785c41b3008b2da008b81c5bdc0f3cbd64c400f0069c50a5c0b2794c26db4fffe8200d431da3ea31b259b94e2d319d7f4c969414ccefd83064990f87bd810224cddf053c18d002e81d3ee41dc49e58feb696d09d93671efcd27a3347fce67ad13ed0282b7cd76046def55f23869dceb34c67173c493de71f6c80fd128f3f23f23fe639d69bd4fbe3594e730131c63c5651ec29ebd0c82fa30a48e9a593548a8f02bbfc200e0c386da6889448a2de7f12f482a88e1c63011f673115b38408d6c377e0dd71d01826106e538f3ef9da4357f9037bb187571b9b1410636c6bbb2d8cc4eec5132165d78e83514a115e6dc7177fdc1f122fb03fd69d334c72a308d7f0b8139cb7b9bd9c21a51c62f6ef5efe53511a3e90edd601ce87d51ab5dad8187c704a1949f37768f900d62f71f300a1cb46edd0e14ac8321b43c8bba913a378833b19035e5a8f2a751ee8885d14941c73503e4e774a90f304217dea19c860fef32cdf8e564dc19101249aff8e1db9ceddf8a381bcc3a3b846a79a6dd74dca03469a739b9be6be2a52f3f8129eb4f48783da642bbc40fcd20629e926658807004d4547b3324fccc8c1415527644deddbff6e6af989eb21def0323fc7da67a0a21c3e9e80705b6b01339c33b59a8af63f1a1b5a044381afb3c3099f014d07045c1b9df4018916110513062eaf385bdf7b3c91aa13ef2e63ec19d53b49a73f365346fc1fec159df43995134149866a72230b7ff2fd8fe44fe24027f2ad8bedb37c45d513fe480d9ec8895ec7e2bc3590c444f4874cbbaf400f2b4e8463417698d7f46b49edc397e6608c0faea74345603d9b08c9bfa754a5ecfdc374e3fb84ff126b9558f0ec133ab8ccb50f0aef1213be2c18098074e24a53dd954191905d01603648d5db22edcf0666c80efb5bb059a9362b38925a6158bb028109440432e4b9e125a07b85d4c7ecc4b00390085c97713ad8d4567a0131e7d73ad5af24c86825d6ef1ecc2dca7103db99dde30d3a07e997282013643a98af98a061d5ffb1f258cde36fee70f600f2cdc02661834dc61f21d7612ad05fe67e5ad129c746199a394091bd58d3a0721550abde7cbcbd138281ff9de56cafe8f9b876227bb57d8821c4d35f6c4fee5e80e3ffcd81341372004733811ea105cec5b387e906f3479718cf4b46106198b883d57c03f556b6aba95eb75106d6ba5f18aec099f7507b80c4ed9b6a7826e588ca80e71fbe4aaf5aa38eeda601837e30b31d3a46b05fdbac369afad009fc139e841054b8b1c677827c88425590b0fd4bda2dbd66068d9017bc4a4406bcca095c16469144127250a1b4d550fff1434a10981b61456e1886b4c048ca6e3815a15325c37f8296579db615d83eae294854c57430fd1c36f1e99ba41c5d4bc7a1a80efc8d8b6004ebc49095109899e7e3335c38d19cfa5669db8f5e92ddc875313e2bf101ba8620379f071633ed33fd4e68e7e655ce78fdd289e07bf176dacda84ff4a1bd24a1b5882531026bbb9d1682c8a6cadd9728a7bae0b20f096a41833bb126587fd298b21d7a2ec8b2e69d9a833ed128c33268c690a71a98c69d4036e63208cc902905845bd558b56ef063e267334766971bed856d9160b64aa5df0bb26755d3565e2d1a9de48c0c5c7ac4be20321c973d6ee47c5d8cb96f1ab8a59b77db2018c46213baab64cde6c9da0a4be6a7d34bde1c4b90e8843f131c0c87b6e67a6662018479a6edfbb7a5b8ec38cd55500ffe366a5a7af8edef8f41daeea7a8b097f8cd57210fbf05a9c0756b014481ab3565e9a826ec7c8f26446a36114e786f6a066fbb27084b4dd3bc61ac94f5224a41ba612ba7ad9917e0f9190bcabce8e82ec1009840fa141cf0a28c51af90f242e670f742561b53b728795e8a5bd3b8fbe56916e407bbe5ece8d17e85f59338b3a8d608c7729b72796c81a83d9efd32286c3914bf8eb0f73f898878014f73f268a7b1987dd1db2fa45b2337f0abeab838f6595556bf20580faeaa1c8a3f9b9623d7e241344d31d7a2cafb421fc4f1118294eaf0b8fd540b7ed461bcda95a033f5565a50aaa9eb85b3eea62d0e66b48d1f5dab6dd02bb6fa6d6aef885245a7df9e2bdc0aa8f759a1065df883ddc045c2dbe035d9cc1919587e20defc618a4a506962897cf7d30425b36d54375644a8ae63bec167e0dd7f27ffe9958b11b17f9e2ade1a12d90c234b67dbda79ae94a07b4710aa876ca7788ac5ec73c7258ad556f9f11340c55ad4544d7f35f80928096f71f3b74dee28eac60fcca48f3c3f0a22336164050bbc7c464e5462ed5c955db3890072f354a529bae7f1c213d873175755f15bd2be92298d0fb83f215db7c5236845ca08f635c9e4761b2b76cf3ebb027cd879245bf835cd076f49913bee5aaba1a587a47e40aa1f35b641ef6fba643132b35b6efc476a2bea02795066f8a5274c5d251f68b14f5793bfff7380d66a0e90e1853376a6f55bc8baaf38a7ebcc8be11c9c94c4341d18a145b036eac58add285edff43c1266dd6442df4fe0ea766914391c675fb471e58cd46df9ad6a21bcb7727a5f68357f05b02984fe1045ca693d30a824fccb3d42688b802903c9203449abc0d9495f1bfb84a4ed72b852b3eff7cfd5ef673727abcfd06e73ee8b5c416525b663da6c77fc24ce7ec0d8d59ac8a1ab7c36e2cf70888800641c786b5812a4ee3f0a67104ac4b2f3f5e5d1065219910e7ae3e183f125b2455312e88e84eb0688f83e0eda6b9cbf87b3200ba3daddf224501c9dd4f615f787050e2e48598003c49547e0f99410915710eefc7bea0fc2dded77bbd263f08177cb6f51e63a227ad755fce05c600690c8c65855c97fea1c8d67d4d07d1cdf9ccefe0b2b95ad35090dcaebea1bbcfda7dea1a99a0a9c37604a2a8b894213ae4f8d42544147473e0ea3ea154eb8049f3804685ddafdd5469619445168b78c0df018b322907cba254b8091a00e55f95c08de2b86a0c63b6612ecd51199b31e6c5cab65fc80bb6e4e5fde0c2d984be04075f1669bf5b3e753ce8098f3c0f6c4f24ee516568f47752708099c1b499a31375cb0993b9499f501afbc466ab7f7285d5a9bc1d0c3ca1d5774bcead220ed6d76080fdac7eeaeee7b11edab167fd293de6abb0600ea76ad94571dd9d91697f6f62de675aed089f7631892cfe7689d29636fee4c8be212548aa297e3fc4f203aaca3940225deee7e368f6180170fbc8395cb026a2d380ea959c45e5f542ab7d2c764bb5911538b2598b73334e85997cb8fdf6fa3b90f44ad905219bb7624d7237ce99020765348e70301f41b596f771f0aa853beb2c299400c27c14c3b210d4659a4f1fa8391aaad2fe6ecbe93a55f5344e90cf8222e07ac7280534bf3b8491408618fee1e6bff9beac928187e3132bbfd788ff8d23ab9c98ba72a3cbd19b9c8900ce6b3933d94a0ba7ca6c05ebd1b6b0783ecea04c5ce0dd26645b73de69503f28a75a0e35fd0b3a31088732d1a0dd291dfd96e55a9a0365360ff78f057431848093a5e573e90d4207431def07095e1da08fdaf1f29696262ea9acb4c073ef508c7f49f1fc7dec8b8a9ed3c9cd9799ff44613f80ebae74a73a770995feca3f5dc899b9dd491d6fa38cfa33722c31b239ba23d73ad566e5e690074280b7c5c2677d87c63d6815289a5b3db9d84da3eafbc5a00172d795158d602befa30b51b214cfba81a3f0e7e77b4f66630d115ad41288d92e56c48d4251275d5e7ac7824e45d5bca71dbdb51fa81e608bd850ca875c74ed67ae945dd099a62d41c259675e50652836a8b797fac2832c519a6651e4f2ad915ac7a6abdf02cc0768deadc0da2cde9653b59d49196f928cce2f85b20a7a04a53d889a1eb621e371f6873f129670116d068c0288410ce72523e383c00bbc2a30f423b5a986ee97e2393fc8650e0b50180be89dee5857ee398d8c27752a543455dd9e57de82d3dfe8dea0bc2a77fc2d61d2446a21ad4ade00d16a99605c7694d94a4848c82e8f72b3a05aac73ac3b06cf73a3b096d29d544e22c7a9e0b0d423c3b7beef9145715a95d7dd8b082574442069e3c0ddc9ec2b1b3434884f33934a16e2a29ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
