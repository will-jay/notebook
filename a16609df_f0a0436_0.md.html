<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"698c4561f0499941daa6c46757846232eee86175478a886a0c1335f3487bb06028a32c7f7aed0263fed47c8f0a5eb57962ace7333dcc874a248b4baeaa39ef742df2e195f1834031e3b0ffc69c2e571a718cf336fd65650bc55ead27348b3e4fc1d172df62c6c0ebf6cca634d68d8f31955cf096d3899f97af370a87f1c68bbb6d9cc6bd738f906972b78b8b9441cf6418ce913c42bbb10d6992700f98b04de4c98eaa557d5e1899df0160dce7dacc126cb848d7e9f963cb9fbf5e898a5939704f5f1f1c5ec693d4c073661bb5f321d304d311b375d5a08c33a944ff712d298396b9d6109471c1cf670fef4fdd458b3bf9d0a6088b0e0ec26087f0e2be1ae6a31ad8b9384d6d671844bc7c6bd8441f81a14ab9c8e30bc415af38b40f39285774bc2a4dad094aae846275f66d0954697c607239155d10ab06ccdd995efbfbf7dffe7ca687558255b15d8f20e4af14144384b3ed3d5ab029922d421f3eb45e60173a8f60bea722469006d59be3ebd6b91a0358e8fbce092313549929e7eae69bd457a208658b83ae8b0bb3fadc488aa02e108efe482531be17b841a3d183e50a47b1d2079dc45e4a5fd0cb71ceb499850bdda01470e218e043aec5aa1ab2f5a06e396e4a2ef7df5ebfcc7038bee01aa9f97495db69d43faf288a92a80e1d001e37780a905f3171886aa71ff49d474c56a902c04343453b7d4dee3220cabb1a402940508c2a600d082fd0ea9a40bfb832be8483f1d0acdc77bacaa318105558ae728d39170b4a6efc01be4378cf2fa57548b6fd9801ef2e61712a6e21cd6ec6f47ecbeec47f09fd1279110df162685aeb19747e385a2d33c45d047ac2d02522f0be7dfc4eb64dd0c6cc1af7b9e653b7bbeef3e5396ed7cf4fce84a563074e1b4b51c684b86f9de316e9500b56243911812b0c5d559d6cc235ff215362a105e4dc6de406ac1accda0892abf552d9979c1862b23ef9e10dfa9ca2ad60412d12c4bf0c7b2602d32cc2714f7ae4c5ec7d1c2d5dcaed168599b21b40b10323c7287ad9cbc3b4aa93066a90fef4051d56668642b50b1a2a71cd6393f43c812373ac5c7c452eef79e08e5b9eb2be7b2d6d670ebf573d32ae020ce0e8f9fefe1f2329493a28eff3e57293ec8b1c277d6291682dfd7de7a7f50643af0a288c094ccf8752257e02ae98cac680a37464e0b0a5191983ea8b0a43124e9c530f628b0fa72face0c871634bacb6f04a137f0195c09df981accfe1f91e5da0834325dff406f31022a7ea393b29ea5f574cb64d5568f0acf57e5476f5687922c55c19142644d9faa460aca933ad1d1c7f28efe7ed20ec286bdf53d97b7380919f864c6a83ffcf3fcb38f05de972bfcfe09f1dd416c780ce59473ee529a2255e121f51641a0f1b67de7644402b203c38bc819356a659cc6117bc166561b80a4ebe8cd5d90e930c23a379f4656af576ae5b8c52fe685c3b6e80bc249f6ef79263d66ea87238617f026ba66e84d242bd85a6d4f14fb20fb4a1aed323f13b6477978f56bba65106b5009e23b09b445260105e4d888edacae415007bcbca3a156e00c6bf0a409d48d33edaabbbfcfe90496a65be44c814d9369ae217b7aed57daa753d2ee3fee0dcabb7a79ccf29e33d57393102fadb2aa25e8b0c36ff713048b75a1453fd8f315a4099478c19241703577b89b80a522ab2688582f5b9641b86f916295ce3cb506d78236cb3f051883a1a270556a1b586a31936e387f792c3c9f078ebbd903282f2de28639ec623d226f614d12f989ee9048e3ec84333bcf447d2f0c8c5c3cc19a80b1107256547219c6db031134030b7c7e89c8aa1aa15b348caeed9c9d51d52bf06e5d62e2726cc13ea3f5d71eb64a4aec46366704f4cfcab500174448b8ed5cb71e4e0939a77b6ee8c0b691f6ae7c7751c547d61f398b1df0b2028df72531893e09bc1bac69584374245cdbb3a4ccb8b2c5f4e7bf41136a892baa5b9450b41255f3dc278fcb8fd732f2f6fbaa10cdf64943e443419d9423dca94046ba6af830f1235e5427eaa00d334bd2a147afbb096ca7bdccfdc0395683a9ba8f8fc643aaa60dd36dae1702012f0904a99ccae3eecee2292b69fc034d2f8200c5617bfa8f3d4beb6c29f9359fe213ecddd151c28db3439acbfdf83c3f31daf0d61efb69fd1e5a0f19ab735f89e6234e113aac50b8fa6f4b51efbdb514dd0454c26da485ef2fded7829fb0903097025954f1fdf4e1dd255bcb7452e70321edddc37c6d3295221336806936a3e4bb165bdbe92fbda371538b26cb693d03bf3466abafb898385ee2388c0450f1b2891d9167d032426ecbd3259d1d26b3c326f14f0b668fe3bcd28c7344212b44b36495c524ba355d3e353ceae52f31c61e347ef70ffb22da349ee11e3dcd4e5ef7f1364cf17cf58db75dfdf4422fc032488fdf8e89f641b208c0a18c12bb940f51efab83f1a2aae5210e7db84a3af0451047fe7177de0709ee6f4810d6bd36dffc9513b9bc6b545e3e1d89ea6701883a271e813203ced8cdf87a03f3b651cf5d9b0abc2094b9dd13eda0267414c53cb6757da321006b1d39a94612bf2d091ad4c12acf0abb3d661b94245cb3dda90c046a237a7138cb7a247eec36c56e4dc5a1072d25de2cf68962a5d8f2816f2c709e7be387a4eb5bff44aed5e731758f3f52c1b21ee58dd0117ee3c0ca560f230c3767d7759357e9065219326a1dc90d7e3278a5230d678a30d89eda8e54695dcc3643c98f7f3a09d32b662788e429bfa152d92dc831eb1e07e6b875a0d197c6ed13506004e548bdb6af5f83efccabab6046f9a0eea4e1782e62cab7b1c685d253723ad2448642952400996b0d8e1dbd8437914060c53f450a93c94505055375a8967067d7436fbb4bae0cb2683b24b45a0d569f012ae0edcdc9fab2dccf7eefddf9386cb73e6037c1c5825310e98e00955fbe5c6662f5616ac77b0199cc383406635eace5b307c7033f2673c977f3071fb73c467d925de43462418d79cc1d0c13c0b6de9ad295165dd1005c21969f916dba56345825a6263062841cb43dade05022ba0df906538afd020e54e87864adfb85185fc70ebedfc3b859254e3eaf6c7e78ee4e40b68b14e70b10e1d5d24ef8d4e8b4f9f1a2b4cd838d476bdfad050c0b0f20099637b788ec709f589dedff4c53e5f7e2810f3b611eb462fd8bbc94b6e70da9e4ef54fc92880c1f2b13fdfc14d05be4d883269a116b3412dccce81826147f75a8080f3bce280ee180c35deccfa7020b3d453377288a25786c93842dff941e18b43df0905c28340d05bdf14000d2c4412602185c61c8e7d2afeca79c37d7bb57a9292726770e9e66ad0c9ccdf6be290016f5864147da4ec6cb7add097d6971fe3da5fbf42e359cc25a4faab364ff2749532aaa05dffed0922b3a9f7e1107c96320464993b6a011126b70730145bd331b7cd31039ecb8c2e4da06452f757a5833fbfb54c998fe7531997fe082ac635a5b4b813f162063f890697a0c519d762e5ee224f1a554d5fb88d1c521f04e5f0af04c5881708a6500aa20dbc9f98639300096dc85a4a53851f54a66b388807bc8299656ac3b349e4ac8ca01e0b2ec2226341e1bad3ae9e85690c82548db207bf8db60ffeb28e205889ee8d1233851ff307f7bffc7dd348f5b34199da20d5afa0553ce0762dd1840553ecdb9c1443ace392824bad25a36d5e0c5c7556f2fa6e4534ee00360ee12b9eef4eec67eaeda57981efbbbf946ca6addef43d140aa08128c13adf978ae836703acfb55acf143547f25c00f8adbe496a85f1a2918091f393cc095232cee4a66b6a99f60447d77337985160c4b7e20e4edd9a249ba3f575a991423b2ab6b46b83c05051e1dcf765cff967f136b50cc188ac537f1fb56b10e48bd83ff8eed71b5dd5ef608622f914bc1061724cffc8dc6dd51e687f13e37b3bbf1a4b4a254b30a4312a512c1cc1a0b8d3e6c74ff8eeb1cf9852b86dc658733f4cecc8b29f1fa554a601272f16fa2873d168bf413e72546d77f8e329fecb57275d446ca7f707dcd986aee99469248a782e26d678428bc0eeb25ded20906b738217b3b68d6ec8d812417d24bbf8781c072853ce6358b8635113ddfd1582f7b43866d0224dc71d91ccbe4c0d641cdaa945c136d1383b08ed181129091273c2a5614c0b385fd99cca5a475a91fb8cf389534ae0a1b1515b1f0dac25f993c29099ac98641a532e3ece3b9259379a5d824f24f8cb0985f95e10e05986b7ae6bdd3344bef3f9b3b5854443c4367e382426e38873579638f8cc81d8154fcc5f59c36940984d15a4fe549d3c9aa663b57758677673abdb431ee0c3fa5de9325d78cddc8ee399a66da78de1c2a63d8b45923d6421ea7eb93503aba50f149b9972a8abd60fdd2e5b846c26e21dfb5ba9dc675177c3fada927110d9bef1218902406d467653e3bc874b906302a4818757c2f39b3ee6718372eaee2ebbb39349d66304ab734ec6cfa3243a48fd527a17e478433e94e5054b662e17a9927c4d593c2cb3d1cd1b1d7dd569b979225a5091ec2bf638226e8cfd4306699057f907f961d6c70d01fb6eed07acfeec09f81f1714eda2d0a028c0531f28ad3e00bc2c889c9011740de10ac3958d58a70ad9d90f6f17a82cbc6a778359f7a5a97c125f8973c6a645b85bc998283a24e34032f29c29460a7bae95c8183a91813fe5e09462347d1be3246690fc80609f3972bfe56fbd8f3c2400394e0ecc7e01ab1447e8218ce3987de02dfdf3d9ad2561ef8d9bea0640eb7c086ea914d8c262eca0b2d49087810f0b822abaa81a29222ee63aed7ffab34fa13dfc9eabd26d52a73f5c7b4e372e76a5e216e0d13d3a787b8c9f1e17545a630e83c3472f19bbbcf4350c61fbb1ebd04d7ba912830202bede17e1ff273996071230db6aee1b6013a777f5093ac2e80fe67d00cb2dad6f861a136db779fa776351e9293b78ea6f3da348ca013641027641a1353e59a3e71a8203ddc4c8547f0b4bf7af6ad681014621ee76e5445bfbead5e3b975330b6b1acd5dab97745f8b890828507cd3acb472438113febf45173448d45a3ee9c87b4b870df9adb4fdca03cd8e86fc800a3747fe83859c5de56fc244fc7360c93810925fdc38e71fc8e3a67191b341b11a16402ca424e8bd5822e09a26638c435c0efe0fc85e094d7ebc037764fb7f0d3c992583fb56d4b5a4d49f3433bf5ec4bf08497e034c6251b18535050db3b64ae0a35570b7323ae53a49a964bc73517453f07d3f55dbc586a222f51002390a79ae138fd3f9b3ca4a8f40bd180c887131fb05615bced903704562793d6e7288154816e154d6675f7bc80b4dda339da28f88364f436da1b167f9313cee7ca162e31315630a1890d2cd494c449e3cdc057dd5e9b05b3800a1b8290d16c125ea062b0dfa4d58208fd86b39457f78b3d9af51557f51f3e6cd36d4b34ee05bf59955b6e9e7f4063821269de6d83f9e9130169e9e0572955834701b34a17c57320db94bc512a839ea7a5500d9357eab542b1953b6714c22c34720674d464ab5651df50ad9cc331bb303be0f8cabf8e39782d8e55c4fe11ac33f925673c176c283541ac7c1f4ca16d7cffd0253c3a9d430b1504df5ebaffd939e254d7f25c75791169c43cf0afbe1e20b618bce4189f7b2595ad466017bebdc2bc2bfd170c3ffebe159c1bcc332f27a92bf61cf738ae8878a7baf8ef8e53e97c5528bf833523fc8d8758bbab04d3893468bd9f9d55e10e135acbaeef5300c3afb1c7dc56f8046e3ba252413e234bc1403b19dbb9c49aace9f8f217db090db0417d9c03716017b9e270d471030b681a6e3844571d753f80c55bb37bac1a66a35e132cb6215ec2369db06e1eb163ae1f9d50a7c9c25a11740bf70ade7e80976c2be172bcbfbe020356b4ab666d2f97125a0499afb40a8a4d6eaa2e9ae160135496ef11361e882097f34348e137f7bfe230600c91eb48dd1b165ea01efac298d85f66e40cdc169a41f504e17db1bfb867dcc5893f318ce65907d752d87f7ba1c7df182402a99df5d4f23b576c69c599d2d2932f61ad83b28423383f14d933bf2f547143ac9cdb28b052252762fd38352f37facba362abca2e821d58a7111c05387f0ab698788beb1142a5f7ec68fc966cc0be400ddde195e4b4356016503537f01812bfe53973f994e25f8aca1ff3509a646ae5f1da8efa95cb8f4ac3d937bded5c0fbf8b4d3aeb2ad601516952800130fc21f99f8049f43ab11e8ada9c6c44a192ec8bcea61efc989eed2f0958dab9e581ca48bb1f3f9f10c7f3959a4af7351ec359156736ef6273b043ca48e9464dafe0880c7d49225489aa0d0418b89ce420dfd0af84eae42f81266415a17cd8e49b10904e4283b7167e8986fb067c8f4ad62eb0fd4ce5123980017d14d9b63f9b24126efcaf7df3afd277c34dccfa8b5d126ccbc93d5b2231a2c733744ec43b87484d17f0690248c1355699fac5d78f69db76f09e0fb37a5b86083076a36e2ccc584233848c78bc10477eacd1fe608043aa3ae88c5ed8cbb4e4b71c697763019ba65dd0c296c7832a66171b292a80b6b180940c3838dd35bff0294c538c8f078adb3db3497224ed9211847ba10ea4f2edb9d0d3461f063c6ca1faa421c56a62d0973b0245799dc4145cca743848e0838fabdd5907b76dacb8b4e5ccbfb5d230ca3e49252aa4eaedfb3ea46e9fcd938a3c68f137a24b10ed42de0671c95c0daf7e9e9b91ebee07e7da52cc28a370cf49bf6491ac3d53f0d9a640190699c870bba239e38752d7e1c0810a3f61c3279daf951acfc3b73ea29f1ebb88f627900b935858964e1bc56da3f0400d0bf3471b137f5167063f75465df3a2fc10795297eceee6aae372634e42d1827d536d0cb016f625b1c261f64e18ac6e0a8d450ab62119302b4400f08847b797d1c762c9dba675c238f573400f189a34031c67e1ddb9c10032ca744f6f7eef5dfebbb9d9c40b52f3c4f5ec493bc0f6e2923a1188c47bcc7c61ae4a9d01094a2e5927b4dc1cab3b9736474d06ec1900318f67e413e457441be9e68a5cd15881fb08e6b1dab2356ee98aae1ffc0e28723e2c81a15dff7b1c08894e31f9915cd71daa5d686a694cdd85ef90234d4eb8f86e5b98131ff3085a4b83aac6aef6799d18c378a8ceb5a5f63840baedf8cb1790d632fd190924b119c597ab8fd538a46eadf5a78b9ea3ca7dbd9bda9855bf0c57de57da387c82d9adfc6074710b9e5285a0b016f4c4c36b05cf7feaf07cf5b2f68847ad0ab0f3e50c871e9f3f806621c167b922a079c01258b18e839b4ea3fd65ff7656a372ce5529c77b56085d968e057b92ae47b6e93a0534644efad716837e81e8b4fc793b93118d007522be33375d8bcc4dee097f5507e5b38325025e73fc745df398254cf09b86f64c4b3246a20e4e8b04a69818fd379def474a5df98e970171d76abee4925c520e900a2128c0a50cba177a0092811cad8d7767b53fefd7560ee896f3cefd99e3b38c642d36bb532729561f62b45b62fec07a164d0faf3253b810cee3288abfc81ea2d83818512b0a5f2b4592cf4e9bee1af478cb25c18e1fe661c452b664c9af30dd28df46e3b86116a5a53375964fff760da7b76c23513837ab67e8b6fe78e469b5cab053e31c3aa039c13748eda11159e0378e96b23ffd13549350561e26c476ac0e31b2eabb03f9ac6129a82f5b76c7e0760cf4fc9a00efc217c9c06a6a6bc49728dde0a80537105d3f8218d68871fae4e48d0a3c8ebb0ba9c3599cb03e037e043b9489805ae30e207d16c34820c9dc812e69c92780b627f8a4ca1e1edc602a713427a57258a0abc956506255d4b36cd093c8627c4cddeeed9d904c16f6923e7d90e2e2e444560925932231cd4f03fa97ebcd682554c5590944258cc69ec8f1ee1032dae412dbb025379d13bbe8d967e3b5a802d913c397939e6eefecf2fd052de32209667dcaabfb90b6ebd69fa5196105af254aad66e1e8f71c20e2bf8b05a176a57085079144fe1a0d59525061c78ba06da9e72079a264415e41d6bf672f41fd15b89a69efe1f02cee3a1561d2523ef95b71dc22ae161e40ed1be04f1c8e6bb96977abea79012372c4bb51924447b29ca2648c70f9d9aaafdc635a35d1ce507268b1b30b4f8d509016cb16444e0c4f0f91c1a897d3498e7a473967065e54243e8b31e8603eadb267b262f3aec4c9bdd30dc95b98139f05567d32fb594546548090a48e1df2945dfc22dc84ac0516476f41c9bff044a19a972b5f31d668725640f98df07850fd8497fe94328a55854ea3f7c36c6d7b785289749f31849746d2a535b177bb8c74c9df8d325eed4aec06774879beaaf3bcffac00a6c6d47abd2ce605896b1cd000fa85e5a9880b580627c0f78e7b0f6982a676d7cc06b1e43ac14a3651aa2b128d53af0aee03d288e40c4b86162b4a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
