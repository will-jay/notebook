<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9294764239db4681630060b653d7b0def06834730fec020125f5d29aa213534d355754f146c9176d1231051be0de9799e6ab678ef9311ff469c13b59330d84e57f721b18d49073d85ff5a95432a314b63034739d1d3725b9bf9515dcf97d31f5df34cf0a00c15cd0795cbb1f41e7f4b9549759fbd2687710d90c62b1bfd44654407cf690d66e42bb5e45e7be9e65b1937ace0c5903911a4c93e0f29b20de58ee40905537e25fc6ded14f1cbfbebdf203a7e128ca16ae46fcc4c92b076891d713f7eb523e3c9d8568c3dbc19e26c659d572a097801408dc6ee67d2df46bca2aede101a504ed7050629424516563a1e0502bb6d3d584324e7241be47cce0968bdee7f229dd2fc085bf4f63c453ff64c0087480d42d8e011a6be89b0ba7d8c9a297ff833c192019cd0d869c3c7d6b81f60e44784584baa17aaeeef79947757d415833ad11d76867fe8f6c791aa444d80124e57eeaeb296370c31d8a432c91cbc7a3eb55bd9766ff8ca6f92b0e7a5cb451cff4d07aed10f007c8fe4e2a27038de752bf4707d2de719f62ffe599829844a21b61bb07dadfaf1dace9d754f353b44aa1a1e9957af338f439f810c556166ea8e0d0b5def2f9baeaafd58b8f876f39e2d52c1882c87f1f1a97cc89e0e29fdeaed0a41aa48a9e368ac71d2ac0c229060adbecdd52051d3b843cc4726bdc54b769cb7b8a076a125ef96ff755f3514441106c048495298cbd8a679b96f6ffa2a82e96c11143a8d49a2d2edcf3909822533a05ed0084f7fb7b02a15988147d5982d6c7e4e22db5728590ee751749e498160c86ed4b5911b5e89f98135b3e1fe1e978902183070fef6db0197e45dc35fda69286cb3e2d9bcad4e4eb392f7cacb6142e5d5cb1ff90dc89f2f5e0ee2ddb3cf8557deb558a8be772f74bd7e23bfa6de6f027cdc61da99968a585428cb97850165e6ac0136d9a1420d52e775e6814b0bbd3d77f7f5980f711d76ea093f8833208eac6e4cdd3794010906d428357da6eacaa046c281b832dff232980162eac343f537cdb672cb5cda0467713b41d096a46e6092e4ca7b33a4143e54726d06d2a0d69a78a79db22221fa4b5e9848a9881a3715b43475875c4a09c161aee63a3c44961640985c352f1e4e69d51d2e63c55d4b664585fe691eb0d328da3c50519a22ee5236d2cb01d56e87900fb670187806b0791ee1a5942ae3b510e56e0b5b1cda7cc4626927dd8966b752182a5131531ab1b5719ba8e7006e345730f081d0509a0c5ba0431ae7ca8e22112535a4cdabe110dd16c7deade7853c600cf758f92c3c18ece8ec680cdbcc286204cf95274e83d88a191631c9bf5bc13c4ba48e26e625ec6387d13716a19535a91e01fb976651754fe37dae9ccba747ac753f126fb04f5d9ef00771ba8a5983570ed763f49d1692a2bb747596bec33aaca2aabac8cfa0ed561702bf6f67de4300658c2d0d07a769ccb379044a05d450dee5b3527494aab46ae61919b12140ddc328232b83601a8ed3026ffb09c589f735caebd301d131d1ecffd794e1c56801ab1eccec90d6eb1b08f9bd7627c3fa108004c4929e75208a35dc9e210377867cc0c85b95c03833f0fabfe41daf138e0d314907ec3335c91386da46c35328570878e5c483da158a3d907341985c6956f03ebfaada60b17228020dba043959c4b4598455e7341469991ad17f2031fe836c19b1d28a5d827e8d565707ecc96476d413520f89aaf6000b05aa2ccd418e29166ed9e752bb554b5b8610dd7d12843deddbb699e793cfc1cd4ecfc9468ab55f345fc598d510448f9235d502b264932870434775738fe78fd8889f3f38ba82e77127b7d9ac1787158d56ab092615a63521450bc8d5b653db06bdb8314e01cf46893870b6337052a54a37b8d99f28d189bf77100ebdd02af5bcb115f3e84d2dafd18de11f4efa2242626265e08de897888b21468b68a6c087dad330d69c3fc0c8478ca284eddfa928500d740cda4c29970e1ee12df260b0a73363a94cd09a465dee44c060fca9f8bdcb04b88973c29241f049400d3bf96e2722673c741029755187b146b466e64d4f0325fa8e3c3ff3871fd1ac9a736a19a73f33f4ab6a49414aa7a9a60b4b6524ab5a7f75ef3b8f83fdd866cc8b49c61088e6e58f24dd26c5895bf513c98acd242ff54a0bb9c112f81f325f22112320f47479c76884b3a3944972e08eb0cdb5bdffc19110bc70672e29d3c2483a3305ce58b855e511fe6fdb280f7dd93e30b55f08028241c08b914011daf77914c8006dc23f83246a43d1962ad2dd03f661242f575092f21b185967518fdc6c50ce67ffc77f9281db65a480f883f7be18f9f01b89fd1854eae7b6525ee939ca9f543c100e8b932cc0d59a8c366819887cd990f7c1c837884cce68902cacc0ac7d7776dfd40742ca9325d289885343d00e72f5f414585a04e7c14be2fec9327122702d25c1e24a53f7e7e9f78dfeb832638126f43449f8816a54f990e4b9755ee3520179241f65a02db2f327f68cdbb5a65d72d8c227bfd42faca0fdf530beeae3ef76c6a9ca29d89b3a465d6d02fb4209eb85f83f93591f5a597607dc42ac6d1f085781675f2609858f1065b4150f0a2ffb23c0b99e49e6c5990316ca398d56c1b2c0849cf2209f3819bb9c9fed6246d80226c5fe7fbc8788fe87a05f2c91059a04d846f40e96b05b1b10c7439c44cb6abcdbeb7d3b0c2ecce3920c93c8b5acdc8bca667982d426bcca1f18e21c3187515a9aa9fe60a9ec9312425d78e57a68f1c9b93b6675f2af71fb19446240a8964bd6d218d451d0f7ca1af6935986baa98db612bce6d9d66a63d2b94ca9a8d6beaebd4a7558475b2189de79b71e8bee62fdb6ea017175adb9fd59240999edc443156bf03fbf0cc78d7c5c75cdcb9902c9f14ca095213654183abb2a676e1f418a8e88be7a3aba46a78265a0e73ee3878ddcf281a53060ca5d8b69ba5a7b3578d85ec5d30ff69fcd52def0be9ab5b0c19ab39f9e0e303e44ed221440fca36ae46c335cd4049064d840b74b50ec3a0584caa10001566dfb2903885f65b90ae22e39e10817ce054b92c0dda939f33737c298aad0fe628dd0a4529c19be3a2839d39044b82e98e9c7e727e38013d856f1f3fae069b88866847bb8131183af0697096565e10458a8c24bf46a1eb2574cc44158e61fafba18abfb1a409465d5f74122897b9c3ff803763417d8f5e2ef40ae0af5046e43a16f3e13581a5810c67d1de77be3550f3ef56f2500d7426454627a2299fb8dcae0abb1ae1f573099cdc90bf02e71a35eb74ef1d65503c094828a91420bcc4131a1e1a0ceb66533d4075fa75ae8842be5a09c2a8bb1432d2a340a4e6e4df8a756f50b0833cd7718e1f3628e14a73831214c48f24509f531a0b29618df4105b4deeda0043d21d5da5a4a8561aa5cf484051cad5d19b382ba9657340f10410f852791622d7bb900db90dcf061437dde8efcc218dd9f82acb93ff9246e4a2ec01dd926a90033a5f24d16397f98e3bf616ffac1769494711850ee41f08533b1e21ee50dde2c4c0115fc75a1aa020137620dc932f2728b19c15f1c1e112191d0b3ae1bf114e4aa0a74d2282b77b1edf8632cad90f9602121285df97df04c45f9c60bedfe1a11a2934cffeb8295668f811f596c45047636914dd560d317bb14370202af3cf67c2e77b453e0f02b9d2437922f061ae4afa1d3048e6c0947b5179b5457acb004293021b61b85a36c689e14c4b71864146f89c39f5b739d2d71fb4239b4d0b3d27322e44f0e0d76f7a6310587c5f6b3d62d8c6e4dbf8377371458b82086c95e7bb6a6b80bee7c467253550e3e21e9f859f8ad55d6e1fae6779e592f884b1d6e2846d038cedf6d9090fd2e7e175efd9cbc67337c133f51ad6975839d12e85c41170eee9f9f9a3138dde94d9418e918ecedd0989aeafe1519bba4e7d2f6ef21a28c97fde4a61b8394cff6ac66d8599b0b83a12cc8901e12da2d098310a0430eba85ada2be48ba0010f26bea49442ac4d5fa8215652a39775cbbf4931b384762d11967fc857c8b83797bed1bd61ed412702df2a8b87db9c9b318a3db34c9d4bcd7d979af4de560f7a77556305ca1fa1f696501c6f228c45137fb210eaa5f46e74a15036e4ff34ae29beeced33f23ad9be0afba94ec7293f95b2ad57d46dcb1d2c3df5e21f5416d4878b45574496305f308766bb1bc9086e21d2e275614c8264c247cd52e69b5acd2a7b59ec8d6a144e3698510f77c22b96ecdaf985c0314b43df058905b0d40ce85eba4eeb7a03cd4c9a1ae14cc34c4e964b9e9e2d3e197ea466da7fc2600d30a59aafeb90566b5319c57f940bda729cd3ddae4b6c6ebbef653ec78f06d467bc2d911da35f50cdedb8b17a6df8658eb65f1cfd3c16eca1fed2525c1a5637c83f933faa6bf78c3413a2aeafbf62609af9ea2d9e9c7bc6e143a6efabd9aa2abcd3f6f0dcd56435f8000cd4c4b0498f30424396ff3a070176ae7cd98ac5b24c0d48cd7da0c7e7e9631d0f77a4d9c4c7ef88a81a22e4e4f1f6cb5ab6aec6782a4a319e5d0290afb06fcd4cf9792568768861748234d0a86a1d84d1eea3bd2f3a0add1623c28a4b34ab6585211b04ccb62d64354b33f4ccb2ec472e7522143f2f3cf6fb8724720bc412e412a1d0bdb24f28e22bcacda249eba5deda0968e400762d739785d3dc85e20efcd6756c39863647ff5cffd3645331c810cc4f6efe0ac11293ac40cfc20b5ff30879c1c7bd469c8cc5ce38f31fe5b4f5e65fe99a52cd47e2ea77a6ed404bc940c56fadce65ee21fa009b68b7d8705bd603674edde61df3c18190cbbce26ea0152c47c573ab7c19a88cbbd47f0e9ffe0ae851d04fe76909373f0b68537ad9496fb6d9a3f4dcc2470b73aeeb5261e2d717549d4175ea0f05c45999bad90daaccf19ac40cea64f0cc608f945b09bdd0e9381fed47b5f66cca199502ca1d311a4692a10d33396f923bf98cbc242e11f5a1668ca4c742621f135e9ca3c3c1d3f838258822cac6127e6a54b0b403138a3d4007e82225b1e0044f89968af9c87fe3d40537e18ad3ce7d1732fd40958e014a9a05fa76a498fcdbeccd93f3c3a81260ba3e7b85b2336090704efc9223180ccd92cda1a787b6f2bb54038f17a65f77d4c4027b445c0572e0710eff2b2fd4be4f8eef33a66e3dd93be5937c32769e97c64cc33c7af908b9b166d50c68e74b7e5601dfea9fe31908db274029ccfe1cad9931187bdb9a75605e43836dd5a290888e4a37dd50416f7907153f0a1d25491194aaf0be2d2f7f3126df232f4370f0256b5f7c7a1eb1d046e7e9a4d5df68579d50667fb900cbfd9e22bcc36c0ccb66d22d8fd853cfd160d8ee310314ff86f228626c59d441a4fc37143e23bd620d0feff8b1241dd74a0a8def9e2dafec85e92f620efb855667a9d9fffef6c893adc97ef1f83a677ae74b5db6a43cb8bcc981b2da736a82b1aaa108535533ef7fe127c3798995c03a82af44216d9e1fad55fc99d8fb015413833efd8c7a14232e165c58b2d5d6686e3aba193e3d561bc8a989e74da5c08ac8d0b9e9f45e0e7890cc9c050adce793545f95947593ad7b4d7b97391c7a5fecce991843b79095f0b4ed92479ab48fb14229f31eed1b72e83d915357856d08898d21656118b7b713e67611e7ee8dee569767b8a6c9b9a7a126f0cf5a4235af75517ce2cfb7cf6d10303cf75eaa1ae7724824d87ba8c88e92d5daf03834c50fb2afd5a140657efa8fed72bcfc83cd01e28951b13605e79e715d565d79a7960e068e27384c6a6b75b43ca619722a5efd07299ed3ef53030023ae8cfc7ccdf2e6d83c50b9939a8d0f953c82472daaa4e9c88b9787870f2001d29a718e2298fbb78823a4c5507c70dce7e438fd864d52cc54381425373c982a20b816e1d545e89c712d48c9c71d98376a7f3320bfed4565ff943cc981ef007295937f5e48ffc94c43a26eb89f515beadbe18bf67967570c761be5ffeb7a8596cf9f60a3229101408633187cf5a0e2e3a0005f76da290fb5168cda45607ff1f9f7e66612e6c59603397274494cb1ff03ab39e477376814add3cb7ba572572cb20158e179bedc1815ce8f427ee51d48a434a49553cb55363b744d83262a9e25f4cfb16f358b551305e0ef91192ffd20e3cdace4c4f731c75c7e95efd45e4be5046d4688666170023aa088fdb17ff8ab2ac1194294ba1537ff4846e26f6e3053c1b26c82594d673b313abfb69980ae67daceed387d5da850d051eb20ae8ab7162593a6477da5e79dd66b4d53f410b7fb8a236b3eb8cf340798c2e06f8fa55acbdb516a6e5747e2b62dc416c8e22280a888c2ddf806c2f8c74b4994107d19d9f4d50a45c5fb1412a28f52593f0a4e05c0b333dea1e6162c1d10587006f8c27737d019fbfd625b8b65479e4b6320e3138867e0ae3cf4d7b952aba291a5b7fe29e9d8aa8da6de175d1efd3ab0bd6c98e07d5e8d515e3ac91c23ccf0279aeff4022b600772058b2b8a894e1afdc7b390d255f2541e0727b5baf47b96c1d7054b172a1e8d659418eacf3e37ce17fdeee640da80192de7f8c8001086c057614c23c943d87b052ce1cd35200e839396ff40f44a25c38ba632541c1601697c0e511684933398ee3ca2404ba5b9f033ce7c9b743bbd8486e43e2e12d4294e09b17eb160a9b647c9906e74ecb1ce28eb7237c5794ee1051ff24854f4e1b3adde0f8d5897efbb1ea3bdbf23e4f12419586fd0400d0017d22dc82095a4600ff4263530e8b88cc758bfff593f16aa4bf8371e62f22b0496c8eeafe58d688850e545f9880d8659049def9472c857ab8ca4d8f3d8e74d5cfd9ef3f6ee1cf0609a01346e7f0dcc1b510a9aa12bc4ac106f7231fc17831a5dfd1c37a4c02be129fb905e2880201b1e79f131fea588a1b480e9f93c7cfcbebc3ba4bffe4f211d01d43ef17b612d9f4a59aa8bc85586f9ccdef663ba34c2d728ae402ee09f0193403cf01427ff46115350847c38afcfd7214a781524ad69dbe378b6f5d3ea9b20a064eb22b4d23481c61eea89ba85f1751c7b6417d03f05e97b31d7cc824284ddc173f53603ed7246cecc9e7edf664fbf6138bfb6c89f4fafe5e429484d4ba1eebad8e75e9eda8b2e376594122ae7a1f4f9e6532dac48bb35a9854c30c7016f27a63241be12120c93c78f04f6503964e630293959302001339524d98af61db6867b0311692617930eec4473f47e95d76396d2b65d614ecaaf5b884d07eeb600c4315a1c972ff5cda2e16dbb16ac8c5be1e3142a9d2cf6a3796390d03dc8cb5bc3cb6ce17114bb4b10d6a4a3563e3e40b9eea2fb15af6ae7181a9d3cf0f61cef6e45ae66f6c0b611c49a71c7348b6a2657eb19b8b176e4f5ff7ba99f85680ee657fe6f3b794f47d21307a77422db4a39091adcc194bc1f6258b267705179b105153dc3a9f393a39b96c3166a0d85ceb5ce1fd81526db636832bedb02b1564b290c93dc74f7361e27bf0684e8b59009df56d7307c8382d19b9409c5e8471bae088c7e839374474577a0e2d6233368ec02bfb003a8ef3e65c33f9aa94454a163bdbade7e2d72bc48cffffbfea2eff7be8c46454d007ab524be1a5abd1196c76716fc0e34ca23ec521795eb3aa88117730463ca29ab3ff49444b4f45a076791cdc63e1ae8336d1a2eb947139637b113e454b505c49e7102d57867a760123ba52a35289617c904d5cf47b28b488fba9e2ae7e0b1fc5408a96a312e65970fe0ebe84e11715c0f9c6c1333acc8c699d3b89c3d41ab0909e13b49ae903e1bcd1df59816ab436807fe75816fbb29b57e5f58dcbd8a8cb53158e61ed93adc317e38623b5bc391627cbf11d70b366d2cf22fe4558967307b55dcbe8e48780705075f0a5896d04d868ddac50a2845c0e36031b2a71e26299e2bcebf1382e35df5b782bfb33b9fecd919dbcd3857b233cbdfb6940a741475eccc05efda1a4724f4b8197407895c36dc65b42a041ad1441a2b58083d5f2cf119416841269fe598acca063a79c43acf7fa4b5baff875d9da230921d028fe2b84c2a7a1bddb3a0bbf74a02d94cd42d26bad5e7d47a30089e986121eb94d2863802548fdd6a02570b6c2baaf45ef4d2807cf7ece1bddfd88f61e78496acfe399cda3a67ca46455d1fa387cbb24a61f5a1b9e8b04592b75b3786325696962546e12c331fdd09f17208719ba440fc58ea2f5e4f466e93cf3ab66b6443e9789dab2af766f1329a8a7a22e25639afbc97c6eb8dcdb779334d13e8bf8cfad9421eca004cbd7b25106ff3a2fe26ae691cc714896a2691a43f3717a2185d97a9e286e6eb9cbfc2566b7201e61b4c06e23409a85e54352db5b446477e888e2cb960e92565f190cc05effa76b5b1f994f6c5e452c61fe0843f3d2d916a9c5c6f549d6eb761df2c11c83ccd944f02fb39b96a05a75bef5753fb197b1d7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
