<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cb4f86b8555bedcf33d56ad6295d7ae10dfe0fbdec8089737fcdc3546bc4553d3e495c793858413865fc376e4e04bb93381f531c68014ba2a83084744cc15c8e6c3c523edad27680ca7374598551adbfda41e86bd7c38c3f2a6c1c5fcf45f37e43df961e777a68c6ff246a1633f1539b021e8a7ea14a8d0c465e62b3b000d9a96ce966ff44a0be045c1ed1434f5c6c00e7985031ac486b0d612df5ce25e497f3bfc4f6742cfb5b821a320851137d1f0e97e43db9639a51cf2d01b58a1d04baf2a3adf47ab83475378c9c80d91828908a4e06336434f0dfedf83e6b7d2efdd6f8e69e1666a9264b4ce49549721deda94f846352ab5a4e101827ffe3f5a43ab694aa804af560db8f55173c85d9f9486d4db285f19a64770c723bc7511980c708c7a78829c0fb22b069e47b4e72ac1a2c6e0c5f0ce875cbc2c5e9a55cc3a22283533a3b2371a986f69949ceaaac6e7e2cc368615d0926dc401be69349a9a1c8650478ed2b019c6947ff503dbd65485b76772729467d480b6796f8aee07764b8d5d8779c64a427a347988108245adca63e550f602f4ceb1e8c638c3161b5c2b34f8c23f6b690230600f647438f10c283515bdd59d49228e375e038407831aa92f4614e89845b44e8de7c5f7988345c5b4da25c98460e925340975172bb800b2ba9e893b0278bc346bd106034fd91ce09ca31fa45385fb61035b2a5803ca14fb4b31edfe5d2ba1db89b29c99307c277df4811d280881180b4436e50067cbc47bc56ce0774d2cea1868802468a118a885b04bbde5991a13e9a6ae35d00ca4471eb2c6095ba740ac4bb1c538ab286435e84cf2bf590544a06b7014ad07858eb1d5e75505b590e5d4b54c769234eb871e63b7c342bfce205c5207631582920dc4be904ce2b722d0f5e44c180847703c493937dfaa34022ecc48b6fd8bdada95d3efc126977a05debdfbe5554dafb14b5fe1f287c24ce998bc62ffb81d4fa853dd65e680eedc767bc0fafcb9556f1b4ce9ee4e1b9492cb7c6499835b4846a706e1329583d9201b70bdc68b1f5c7d8c25b8b8fbd89320b7ca863f09aa0a593630f5bd9ac435b5a631758aaf4bd6028d42c0743ffe48012c5664eb2a1269cb293c1397378613fa01c9e13f00011ca09746c0b8acddcb8f99da288c321b26a51f022e96a403b8b0f67b1bd8a7dc57438175340e4530bb5f0825c71de9922b37135d77545ff86e0f60ac2096a4d858e5fa3a22dde3011dde1eac305cc0f806d54ad52c0d0e3cd8a04867ab6c4470f7b9ef48a0f32b0a404da92c85c1e81f3c0073dc512f9584b545aa25c48315c8084cdaf5f92e4a68abc2da4a80311fd2bc135c37a1c9ea921161d751012a91f741f883ed2b7244b573842082ca28c380944dcec5aab5fc803fd887be4b93c9ed50941c703295988c406ebd589fc4be8b0869603e896cc6646e2b884d440580e62fb1b8c8981f12bbb09ed431fb5f917add29b218880b45ff83046cbfa82134d501b41f0e7e84b9bc1df34a8833d8738dbe115937914232d1d652178c185680de0312a49ad9346dd61266d8330a7728e1b48390e77e2ad642beaa90750782ca0438dc9f7750afaea46011c0676646cea90ca5c8366910b3f054b8cb5f52aee705426ea218373869e0773eab385286ee6cc0e736e50fbf3a83cfe2cb99ca0ae2ae0794fd006f17bf664d0222b028652f322d5cb66c01dc62dd32b7728e327a4d95fcbde600f2107b455eabbdc0afbc54d871819673468cb92fb6383507b1542db52df70428d0e4dac99bf339b6fccb6199adb364ad692612e87f7283f0d5a0cd5e4f0ef4f868c8f2fd69cfcbc1f37cc1a9f81a59deaf06106f8f839928e6e28f8a22203fdfcbec47cafa654251ce51fe22b801e1fdb95517750367bcabd3ffadaeb5da7580ac6a588a8ae6673d5fa2825b016d25d15f81e393793aa0fe740469702c7042628f49184acfcf486858d22b8205dad4472834488f2547954fcb9bee8858e857a1ee52619920ac071570022e5287c91db2d1ae3e04745183b5035184eb5c29b1e28e102338bafd243ebd1844157c88aefad0cfeb9fbc5040e7db23bab1e5b41bdfcb9b7df347735787c1d98316be9e9ef99b0a2ec938762412c6967b1b34045ec12e1e69f4214a64c8d05f4389a58c8b491a19e80310390f8e347945076e5efef7dc9c42a2b92bc4bf931dbcae6fec2756b74e1fc96117cf641cc0285a388242fbb53e7df196e84f13869273d62fb331a2128cb12820f3b5b066be8cf9ec465d48be7c8a5ffce4cf17f5c144fd10a78bb143e8016791507637a7c3dc9d358697cfcba0e96629420842b635c25e416a059afbb5dee01a61e3df5720a1b890005932e2b1eac14cd8ee9cd0ae8339f3ed39687babdc82696bb5b89f49df254ff7f44ff40685d355557bac01b723898b9fb652aa00e30b32194a0468c74bb5c2fe9932db0b4ddc2a97e539a0d1f2f5d1b08d54f4eb55202c9ba687220f6975bcc66ee8ad29b85b12e3a48b5de37bde4bd03ff1d2b643460b37b5b0fb2bf0798e1cc29b0deb08e4ac7b8a34d69921bfd64639dcb7b60939ea9b1f2c74d6b6fb89fb3fad1b681621ca689ea4b39fa5119995535c7cd2eb1863adfa0ebf783471b8163e04dcd5c2e4af1749e29bf0ae542a018610b8dd416cdcc9b0e35e05ca7503fa695d784a2a87183c580f641b491fb4c48c04e214574649f59c58a46a4374b97b53f673adf702751ad7378ca9ad451d8feb08347b8b9ddc2e836ad5898b4a950bcce9f59206e9abf8c2258af093162f1229f7ed42a6c250b1ca20551c0309839d64ede4bb248196c7a3e519fcb62e21d1da8c252ba257e12d16cafc827eb5866874f023c3f1838b7d06433c3ab61535e76dc9c3ac72f5b0a215d924d817798e6ad0e0f5d039f49316865304c0791d541468bb14d2aa72ccb2e4ca39684fd4b7aed5b1b219aa642e8afbfb54230a17a400ac076623fba14a629e540a6539ed75e95b1d9efc284c307cf530678ddbf15bf30210ed6441d93db1ad54ccc42ec2a8707ee7845fcad5d4bac80c8e05b110b20965fa5886ce685fce060c49468a9a04aba15d02e7efda3eb5357e077706ea14287d2fa6b914fbadc6a3adcf0489a07b7addbcf8ff128425ff4aaaa399e02b0c97949384bd18ee550e2f481b37b46396523d9dc2703bfc87c999bee53c5bf6646f7dfac39ff058eab4faf051808ebadf1173f7a10f366eca2be2ca4f818c92a033fbefe930d9bc42b30e2ecd042904ef8767a5cbf4052c3d41646bf5cbf7f9a436e54a652309d5d54657c52722d5de573086d3be6aaacd30e5d02333db6b04303bdf2cbb26a318bfcc2dc3f8be309417fd0aa16dccaa4deb4a23918a58bd3a3d27ecb6801e7f3b56256ad57428ef737a87957da07030e2d96846a9ff7da9a0245060fe251218423ec28c196ccbb40067e3d4919bcfb20015e39977744e5a2c68210eddb54e5cb64957fa9b61096a5c88fbf49cfcc6d39f3b48666ccd5f531fbf5bc86f535877ab2466fc3d319423168428fae6d5b8083aef8dd623e5f79cf150cfe409a84c28115dba53bdac0978088ef706aaabfdffa1b0e80b898e201336332d63012fafce680de07bba5a6d9388f8562ccfb3909ecbc64c27903e6a9241813321da2e6194730e3c8cbcfae1cc98b5ba6bf66d03a0f1c3a35e4913ad672a07e2dd5673dacd7d7716716f230fcd859b72d68789d95de9b0ad0a488131caa8eaa9831af6156baa51686b739e03f32eb86df3b7a0a32eec847f2634062c518fad95fff0ddbee5275ecb83f74873b160e17bb26e07e7c617e4ae83dcedecdab05469acf7aed6f1eec2a32736ea08596b7cb54e8deb0969dc4f84abaf4592dea03a0ec8494df2ebc412aed07eb6beca36fe0ad4351d7ded9c60fb932a4e55f1aa6d0b9eeecd950648e9eff68cc43ffabe624b9c2c722f2809491575c94766e5f5678d13934e89c41fc0f8474b7843ae7cbacd5b12538701a4c728e3f610d87c65d269c844203e6c487d50ee04ead906ade21e5eee9c689a27c7f9a05919af1fb334a2044372a132468a3ae83497d49f0ceb1c3d613e7c4de3abc5cd0da690344d18d69c035a52ce80db4226b001bb937d0095016a6746554ce853f217d877f302c20072a1b8f91a9fb28c77bc64b04a92e570b2e5be5e23a43cc291e34072f0d39cbe7275f4ef4b48b870c5501ceda8bc0f63a67a6d9eef9f07c8323c7b6fd540a3648f05e43095d3bd556e0602959579d621eacdfbb4f8fafbcd7abce25014d15b5f7a7c9f953d01593b4e015daeaabc156776d66432c3028c272fe7a40a8c2eb775fb9d59a3e45f7c1de8c9d0fa370e39eb454689cb36c1179334c1e8c87972eed4f11691a688464cf81b1a22bf2b338e7fb5421896cb8e2d0e563e41ae6736ce712c1c9df89a952da3ea60b8fcde5970cf77dfe5dcafbe0adc6750c723d3ebd85fedf64bdf5025c5bfc4879e5ebb91ecbad41306e1134d0bc09e56c5e7f25b9932da9c88b3ea1346eb025e511756c2b61d7363db4b151f7ec0126de348a3122208cc3d58853b19eb508cd602bcc27db80424cf43b92dbe89b44b28d4f87332a4037df47e85f950cca8551d8c251eb20a813b468749b45d8be82d5b27bb9f80b31bfe47ea2efb2eee77ba9047b22aecb2119211f13dde836bdef301d311f2c5007f28b693f7c7a67c2a6b9d4ab6c1f42d565ee6ceb4bb9cfb1a4aee036d6e8d7b6f63f685bf1245bcd58a372641e185dcff873ed6a68ae15fffcbe32a3e12ca884ec7065e963d06cc50fd4085be05af7eebf33ae14c622f96b52064f7ab4a30f41aab1d70fd067459b7cf1fc7e71f6b8cadfafd54502465d7f44423079cf4bd60a9e68b670f6bca9da0d371f4f55c3dbd67c69437ccc1e9ed720c03d2cf4f7a02a8c6a5b88a5048cca1cc5e37b7fc88897efc3642d1b15cf7b7d84b7cd555d943339d6391e3976180ee0bc2534b899ab25ce473e90dc8fa15f6f59df7a6c58404bf3ec37a6dd915e770dfb19562be8dbc229c1718cda00de4690c1049c1bd3e20ee535332dcd580aaf064f3300ed07a9279e006d968d21f40ae4da7603799e07c4503696e304648e91ad0c3a28615153764070071605fc98cecca0e8b165c072b2bfe7bc1dd180963dab7c46612042868166a72f286a1894809e362045d4c6b23ed405ab774c066fed03b2009df3b18c30dc800a0a599727e16ad32353ccc67efc34400fb30149159ac4a2073502f8755d2cbf0a3debf1ff07ed652b15f90957d5f77fb77a9a2592afadcc421997d3c779e5bc05be240996c46be2af4859543ff82aac9966fc2b75193948e61f37226c9d025373db445a99a56b0ad3e6db541bd031addea949e8adfb1da135ac121ef33071cf0a9d4d6a8a0b3b06a308e797a1c24690a1dea8f86a1706612503640ef5e9f8669d9112520378414a927b76d5a48039f54060efe6d464948ac96997ad0de7da202506139e6de36378efc516b2529c4c3b288ec96a567d3fd35798e6191f48e9666affd9797780efd723ce0f37375757a7135a419cb8653f1429c401e9bce0b60f98026eacad76f144c0ed03119d3c0c7dbf6bd710135e29e35d750a63f5b2f4e86755d5918578da7d8d2f3e81c608204d7f75794fa42f503f842841710af156f29f405bc2acfb71e50a8f7780285ca1135d1fe626a4dd94d304e8f97b4d4a97dc809af8a7affe00d56939b00a6ab0497c146c3638259579d0455d09b66887c07049646b1f7b07fa9b596e1822110e9686623b2d34e38a34ff68099c2edacdbee67578e80e2fed28018fac36624079fefabdcfc6d6d2dcb24fd40a253f14f33ba5a28362c68124b139f65c52f5f65962efdad4e14a35c5f9618611b1295645992804220410b065fdcebdf0ad60e4942472f0d0503cd7983c5dccc2f357fd4983e2d1befea6f6dac3690fdf2d7149cacbbe622e359cdf12ce1c0ed2aeb4a1de3c6323d6637c711cb5bd64953f4bd0378704111f81906d8d1f64f6552572a98fb46dfcb5b25cdcf0ec196758f9a760d2ffa622c4646dc6839e08100d717e2b49f053a646d6d76e4c8f00e929c691b7785f871fd06b70cbac78af07b5b48b905b654bd0a4150313974ba43c99ae7408aa014f1f6b47a32b64fc72940151cea9f39a815015ab22fc51e0744c067fc87923d96d67a1529e1a7fe92bc769876a4f3518081bfb68654745e2bf1b590296bba92c6cd3d5f9b8f31bde457addac5d79cdde7132a4f166b14d1a29839935069d231f4bd25ea68838cd2e2f96270c4698cb952f816dbdb8ca7578f7f154af2495bc237f0a0726674841daa92f964efb2ad3bfdb4e3f0df753354b5654ca7d227e4abe5c54b3346dc00ba48ca803b06cb53b8331ab39d653f2b870040a44d9bddef03d8128f319077615171f0abed4b04230f94244f67b7d24a8568bfc49c504b77676c0404b543f48ad6a6e3a7d70a2a21fe8b3bc0f14a0f9932f9b393213061bf702f40116138153e6d82fd31fc8279f9b2cfcc9bec5736c51199c985dc55a975614904bca7d249ef2c0553360821270f57e8683511d2940ddfc337f91148fbd36630016e5d532ce292298fab736648c377cc09313828dcaca0b964456fe026731e3f2af94f4061d6c07f6633631cc334ddc50f96b55e21a9f2793bd890b129a3f09b9c60dbd7ad3ee51b612467f168f0b3706d411e4f6c3cdbe58ad9a24d043050c895454d461cd209e3a4ba52e8178ebd45dc81ae96816ac8abf9c892eafeb1d7aa51df8e648bfaf6f1ed75d43455ce80b4df4bbdd75c7fdfcdc116a6504127f779de201509562891a795500da52ffdc95cb16a767178b50e9c791ea875a323ac9893d76f8e4dde008bf7d1a808611781b296b79127b8d0900faa84e394194262e4a8ac3f479165b58d5f240b145ac993b16a5b8432a38232f0ebe4ac555eb9d07a8488c2ed1e7c49f5d7681b85caa595fd63f9283741c857adece6c7ad3c37350d49012357afea0f0e1b49d808c73aba6c24bee31a8bde342c9a9efe43cef262c2cfbaaff05fa1234a2c0e78f0e0561072934fb30debc2dfae3dde30d4f2a34ba1bf4b86dd618baa8f55e02b258b3794e925964dfa809fa3c98038c6adb14b6535901888823f8f225f650aae5cb45feaaa88143d49babe4a1c663523f426c741c5a651aae9a72ac2019d2b637215e7abcf599153644b7cb7eb449dc2788dec0b61e185acf1a2e37f28da86e426f8f61ef5f05361d1732823526edc84364bc9645b90bca039e03ad47bf1a7a6ab7c2d894e54bbb36a35aa822c65f8ac4580b1df9ac961ed2a0aed06aef40003e3b9796d254a14992bc1332faa6dff9d495d42accc6c1a832dc684528c2b3f6e5286b9cdff4a3a8a91c3bc0c10c3f4e992ed810a10c272cc7c274cad956e8c3e3e517901204bda4130a8785830b6e6177d712dd9f8c9edb727a5729bd8b86015a1ab2b1d8bf35084e15bf7719b08346bc450b7bf595fdd220e7ce6644db52bbfed49c80f71e2ec718ef74b79eb2df38518733d2071e61d29a8fd472f391cace8e9b8516a9b3377fe121126658dc3cdd0b16bd708b9675a36a7e1b83ec3281a1acc759e79c32c806c61a3dc26fad6eba90e240ade924588e5ff8fa50e9314b682322ba75020803b2c5e9a50a294e27a09e3efc6009bc229737c2ca36ccf9277f8b4211f20f0ff87c1cfadb6e8d4e38f216bb3649a88c4c55856667dfead364195714044b4031821cae065087178c8dce7ff792a0cd419fad1220de98ba8411f76ff596b04e10e0c3e767842f8c39d27f7eda729573ef0f2047fd35467a6164080912263cc725b84b73dc605fdcda207953c174410a3d6f3d9d3495b3e575ef68775d1061f7ec3668b415d081dfd5c0ea5cbe3143bca3afcf6d2f0e48a18e2614d0081031f713107a2c33364a492cf41e00d6782f573df99ca865f1b6728e018b8d1e75d8f6488c0e6e15529548397fc57af4b09e8a66eaaa5accf03b393ecdc594db2ad67ed50b39342191ec904d6da3a90ef0a25e08f4ac37b8ce1ca4a181d7427635e2865cd07b66b28da610b82fefc4ad4345ec1a21b901be432a43ff6bf9bcf0c7a32cdf7e9ea56ae317db1000fe08c5709fc7c181fbc2a87740ac2d1e86744ad2633d1191ab3df4ff4f1754b5360e67349fcbc904dff6ca3c9421e053657af9a29520d058fe297d4f6cfff063a8d09c51df7bce277735baa5542d881ba86eb6e44c885192059e100831072d2c6085a4d1c6ccf9d92212d964c2432ea7a8431c78452296ddbea548e747ff11964f05001a68527efbb18eb5e1150090d4b3d08c3ad8a88ad57887528d1acc39d1fcc6fd8595565c025b66ce53b87952e085c958a4bd3531323858f491a9146efad0f94e23a14e7cb82dc16f7d6533d00156d285efdf2387cf1d5754cd64f5ec5c0c4e6bb8c912d1d45e957cf0fa00e9c1b2969bd0cffc8e40e14243f8bf96c16668d27c4cf6b828faafed17e60f39986cd66ac21819febe9a9d91a8c8d14184ff6862a66fec1ce12fa435f6ec56af70dd3091fef9b55530b72c760846cab2e68513ebe0cc18cbed069d013f5b21a183c94a25e92c2737792b7a735e6931d44deb2dc399528caeef96633c4eb6645c19127a58d223c8c97f1431fad1ce41328dff411f12d0b5faa39d2e7ab8b8ea64cde120d568ef953325400870fe3f8745d1ebc0ee4eed7a18ca01507b0be0bdebb15462084b178a2fc7abefa1223864820dabef75d13580b5725444ba494ac8934f1f1e9e5f1d3af358f2f8abfb25a4c5135c15ba8dcbd28533714573dd742496c4e258d577e2c807d5fb42b5aa702f082a41ea2cd29a69928451b5737fddc40013ef348acd7fd93b6c0e015ee6edeb3ef515bd8af2ed88fa8face2e58aa923d840ec510c13eed10925080c5d4022dae2e7930791515478014ea32ee75760cabac879e03980a1aecf24735f7ac142a30225f7433958376a625e290d76585845f9c0b16e27ee8d88977e0fe6583bf3c893784fda5910550ddb1508cd7453e160857a5c992fe5284768f5a00c21c8d7b1e01b452eb35f6c8196e5b9101a15607f0949114f8b9f74efaa98ffaf53da25bcf3c627d903c8685ede094eedea3edfa21ce96ce4674f9ec767cd30e4a47abcc1aaa98b09ff0bb577cf268d126327e4ab7c6c485fb7a236a85117da2d6c3144f6d278e6bd829a643d8f2a6226d4dc12034ccc837aba8bfa942425fd013554d5e186099f5ca61106ad2326d46d3dec8e8f57c58540c1d8a00d8a2cb22995a9cb00397f0a380568a55b54b1d9a6a582eee4ff6a2296d8e0dcf4d5b8d3767bdefe887f554da355ba6763b96f7ff4b3558a2cd8c6f7ad4a3449064645507f23b5be13d8514288d98f4d8fd4894a99a3b43de4f15e7b7c443bdfd44aa35d918d6753db75aaffa6e35af37204555788350321a4ee5e52c77671ece53bb8255bc2683c5bf86b6f18b3916198aea48d25868750dac46548e8c467b00dd111167408cd39cd6792868a21e08f2b9d42d4bc0b9fcb69cd2838193f9153d4797b65762f329cecfd16467e5670083f2128b3d81e027394b4f498bbd03b9518e3d2c05207c4c36a6e84d0fc5887844d3c5651b27077eb9b7ec28daba143847ad1de28b6a93a6b4bf1615d0d9683fe5f8377dcbae3c9f588a9f7399585baffcb426aa6f96aa4c30f74602c3aabcf10381bca6c431620cb11e8e0a85142efcf767aca8a6d82e2508404772b6d9345d39a287df3b8f44b77d68f65f94208843c4fdc091715e940a215fb5d00436b46ed4edda9a96c7a361190f75715d1ddf217c100381ec84d2735a6b5ffaa52a0ed7f57cc4e063dbf47d84ed12f63387b070d30e10b2f45c3a53fdbec28475e22248f5084e692b0c498f4ecabc8744090806526c973a5f583617b24295f333be8ff47e2a80124f5ff24ae248743236ca20cdcd831978616dd466ea9ccf0c4b0dfe9e9442946c39dbee8e3229c17e0ae61b83bb681ca088989618d20ba12b5d42e08777db95afa221cf9f3aee3a78d16021f93da83b05320d6a721f4e9488c2941c25d7b01118dcf17cc38042562a222dcde900b3a1d172c6019e58d85b91344818f131a696ecb38138c66f51d14ed8f44f1ba749a86f72a6c0ae638c142424f74130a5a5fc6a296020e75c8c1be75924d202f539f7a3e2104f31b9f29f5e15290264fb9136ee6e1d5090fe554ae3f90cfadafb4215496e66fa9a300d57d1881f10ff4515a49880d4fa3a1ac9f3f0cd74a772416782a2dd336e9a09f5ea13862b4c1d34d882eaf3261bf732206b4f2ab88cd0ee6ac75f5c3ccfc25b72203ff7b81bd28efc9013f3c35c90a17fd195bb4cc26c983dda24b08cb52cb45c2c4a7d37db4e40944688052e1474771c73c03831ba59116343dcbbaec68d7550860b270508fda66737dea9a49c1d6a552bc15549a30b854b0ffd904cbc1c0d4e731ae758164e8d8d570a237acdd0126ca2115ba026501d25357378c68def5b790a7b6149d8a81c81001f362e2f52cd2cc97c6727200d5c54b1e02c234ed0e19a1d1fe44d2e8c12dfbba093cf28be2e23d710298748582150f32833afd70b17b349ff892122ac37dabb656d400206787eefaa851ffa7025bdce836f4d35f9f3a1cc2e8bfd997319300bd22a3d386a8f6fb7c9495c8959c3eedeea1e1eef6d1bf3a7ef21cc9a31640ee019a76bc3143618e45e5c0308abc8f772a2987d138b0971739014a44efc6991984b9134e9597c967ae7bd06dfa64f993148391452305adcb7c1a18e5debf5dc155b409b206f7b7e3dcd8340c72f608e88b1624fcae4f1ec15ec477e39eceb95d539f294172ca336f763978df0d3ec6caa7902c3acaba46e573a6e2460fc14a7988734d060d7c601869c9d427d788862e6aa02e41a868bccf65bc40f4cb2774f59985b692d9100d12df0bacab0f08747485dcf0c855f8f78c3adb6f8e5c271904c7071e66c0d38cc28d0dc39a7d9a65c9126adab03e5fb7373d657caad57f42cd363faf3a9aed8f1d57e401201da0eb7f2225b7cd32120ea29f8425c084234afad565c3549666fb04b63c5f86acd9198e816ef241bbc2d1ac84e43da43db64937939fe97b0eb8107bad665894d4fccdc0415b526be5bdc1b4824a407d8b73150db24584a299a61ad1071e29a95c403d6efdb1804b006","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
