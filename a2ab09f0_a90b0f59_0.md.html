<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a66386aa7cc8927ad9207831840120c3f1a3b8fecc75ca501549659d8f3d4cf5296cfed779767de0a4d68f0c68aaf126d5419248ef9dbe3503e83ef662d6553ec87abc79d2dfdecca42c12c23c6659bb7af3b2d6dcfd39ecdd193df97921a5424248feb43cc05d311672aed77b617671596d619c8241975cb38158b7453f2659c0face08af65680865e1c553534cb5980be4b0db64491ec6c0571f921c6c4a88671459472e4ee33488602f9d48cb467de7cb4d02f572a6de99af2a1c274c05a20d60137489225a050fa14e483307e3a521304fba884b0cb4aa508bcdd0ed867e82b47791abf58a8b97ae1048d78451c812545dd2c99513393b9da7125256b039e0069c3b300acb43b70effe54202521ed0c42d5f2c00342ec08aa416b1efe4d36300324e325351c0c66265f01ecff284517261043396b25ef7899af0084cfb18d283795605c205ed0465ad2dabd1f8bc33cabdd5eb4b0cf2ac549eb7da9ad6c9c11f2387c59c7b9bba0147ea74df11508fab2f18b33d2d47c0d5415d07812d4a2887392f95d176a79ab457ef060b783458faa892daa526b6f2c48d642d89afeda852ae02868358b9df556d78a3b74d9c4e145d004e062ae91001ed843a6056ebd4bdbdc450ec29cc38420f01d4315233c670e52383c3a095fb864a1687ae0278c3842b5f292c9ec2d9169261ef9771106ded64c4a2725eaf313c83d68cefc0aa1ae86234f208b3bc22ffd0ba75a67313ab21c8d5e7a1ea302c319bd980bf766b432146c9fb4ac0c82d6b6af10ec8f853d233ccacd8419581830ce8cbad5a6aa244398ff0ecc54a936cf8933f78beebc8dfa798a1f80dcc67dbb3224a11fc8707730b42bf912925703e5e367882de0c60491ba1364f71856ac06af5dea19d2260a850d2ae74e60909d28c20c9e93c2edd3463ec90145819e891f640ac3f71badc530500cb7b60067922baa22240a428701fbad2d33708b3d893066738c03de47d9fb0a70896b1a180cc3685d9b7a7d854d1651126e789e102a60edc81951c49e357535b16e937bb2b59c6554f1c4d5b9fa712e8fabfdf36cb74b6deb292df0ddc8d2baf80bace60835075f67bc1457f7fb37d3121395b11221e94fe6e8667ea25a632c48082d6d9179fd545dea1826b6f661b45e2da507c23ff3adbc028079cc92623b31b7c4c583a9e250e63cb0d6c783075e3d31ac24dd6abc45368e89c91e75d29befc3bc4a7e8d9afae1c52708ecccc4a419a92745ba805c45858972135c6a799a233ed5fab76750348154b7f665c4f4a98790a8cfa7af21e647de25df7ba3f13a7e12d9bdd0a2d9d54ff92a95b077bcebb3ff7e21f62c54924111cf02f9d4645f225b1fe7a86ecb21926097de0714e5f5a641c02d5e89e30661e656f540da0e06ab226ad57b9671b4308aee4ac28dd552a07ebde420545e8eb779dd0d2784c0ee693b17a68aefd268d1c62eca242dfbb8950006ec6ac706c13d831eb6e828b634f50b72d1a986445473c389b5c2e4d8795e796720a75cc370763809818c76cae53e1b63679f8f19985f8348f3aef6e89dcee18af718ef74f1447b03be754ee406ac8b677fbbfe87cd02ecd0641c9c6e515a68afd8ea2d646557e191e10bc0d04e09c6cc855e54bf18b05512eea225aef9b9d8ec5a5053e4af31e39ceb4bf48b4fea3d7ecf0cd5c1e5defd2b9f010117c2752ba1be53d5b948bfe80bfa2aa07e009432db1fb057f083ce1f52c2a7211e5f0939068bd7e7eb4e2ffbcf681b2edd32d89a12b68db6ca36952c80c162943c9fe24beba407dfb7ce9f2e3e6c5b528be3d06242a089cd1dc037ae0113ea9c4b0d615a07a0abbd152d646404ed3df154d08b58d6aa549e519ca9bdb1616b9a0ca32eaf37bab12b0bc7535146d31e6e76db3f2c1e78bbb80b8b902c16b8e37523f3e6b0f26ce1406ab1598103736f9aabff4fa48e227186b77fa1a6bf7126b44d649e2fffd3df8dc83d4e1de990b4aef0c6c035cc84a25ae7ad10c344e895f987ca93bae2dbd883b8743c1348bfa45aa15c99fa52bedf7466768a84e54d4aa1a51e745d084758451866c5a6ec716002b2a2ae75a986e851a303c0e7ae77ee03d0b5fc6097749d72974f91bbec61e90f8ed3a35633c1e02afd9de0e3c538549bdcf4f4d5ce8921fef824c67340ba42a6c70588541397e2c0e6c12e36e507acf3bba622b7ae563fd88bee40b3dda55ba9153c7b1ac88df3752825b59d76407f23b6c5bcff4bf96302223a9e1d11213a36824114b348fe1ad7be5c9d23b2601cfe2e02255cc4cb796dc4e29753481953be5f36df94adebdc7a6bb8cc3bcec831fefa54e0178658c3596247b563df6c94b60f13442766f4fb14a45430bc4c35d11e646ff19df75300893cf72755cedfb3530b706a4563bf16f77e11d1016760cbbea294f989c9a2806a9417d9fb8898e9c35250b8a39b3097bc829c311867d190473ba1359a8eb82db465a13b22d44fafe122316c15543b8140d7141dd391c7bb887f675336615390d7017d30a5e55b9bff811bcfe29cdd400f118e3a5bfca01592120301a9170a3d65f76acd0d1621724f0711bad6e1749a85488bbb24252e873401c613ace25ca4d1f2440fabccb40bc323de273ca98226c97ea4a125a82509ec2aede2153d3b8d2622fc2ff0956516bb4079f637bb259c1dec028928613325972aa2babbe5026d4248228880001c40e10a2df75dde4ed43a143e737d29dfe19e1ff3140a817bcb6cc2c31ae40a37040c1bf041f8519fd208153ed9522951bda99f60995a014b89daa439081dd101a28940137e140101683ab39d24ac1178cd7f983ae3ad864b79b58a768071cf2a7049d6e255d9a8354992662af081e6ef4f7deb9d358d8ba134686d0d0bf51c4ce86d52a03f4da9e8e1159973177c61eace890f511c944eebb2363702258361f902296fda70b1cb9ed3fedc022cb1807ef13181d5cf082754db2545fb4f1a8cfa16f81af8eb903562bf726a67686a72b7707dfe2e603e5d0c07eb641d54a4eee2ff1987d670f5384f8d832ca712132c6e5dcb24575d0bc3e498ea5b486dec496d132818a02f35ccc0b18ffa5116df1d3835afcba41c08ea539a6ed5f02d234d7c4ab22137eb98ec16b690489861e672f8ea051c88d0130a671fdb0b9351e4ed2e593c4f58389545cef09d21416a8e8e7b0baa5512766f04b8fada8fb0c2945e425619e06eb7365de5d5d4316e14a1f4d40779f5b75625cb86ed38050d99205e1fa817ccdba77bfeb718121c926a20c2bfaee56e051787db8e3395d7f983b78a9e91d9bebe4b2da4af03453de56140d0907243c892280177544d9b36a0f4b4315e492b11e60c0ce0cfb49e7347222a6fdbed84d3a9df926bf8d7be9c14b97799548c8fc2653d45d62b76c72f5ff0035917b70ac3c34e24334dfa67220775373910e1b55b726b705ad8fd1cf3c5c9557947e6ab4e14060f2eb3e6fe10cbd07f87aab023beb1ea0cdc6ebc1bf2da8cd1b440e843d60473a5cd45a33eb6e039e63e923ba74f1e6c3dfa7c7f54764b3fc57b784317b55978d895d61faba7f2fa6193e5d4c666a09984abba498b5dbbbaaaf920ad24b921afa919584aabd050f4e815e990fe66066334adc1be9197ea55d33d47a97a5ce59563b14e633dc13f8db45044d545ada94b1c09a55f6c503bada289bf3fbd4c50bd4e20c0e352dbe07740778b773b5df19d165937b1b0c28ac94f5704b627138eac184503bcdcbefe82cc7990cb2567e5c307e70fd7ae6d2fd43fe507bc21d604c08f2374a970766c5f55bdb457365d13784eac9eba9ed2d494f1bc929a5bb6faa842c21fd3aca04f94a9654105ac734397f345beadce3993abcd6fb2045f6a08b7442a69da347bbaaab47defdaa4f5db08bf50caa86863d60b251eaa9247a28a7d87b683f28aaea79a4813cb66f83403ba74a58c8b1c079288ec99bfce19e5769611b067c46ba2cb0abecccb00ccb7eb6a310a3cdf41d6f39865a17ddadd096be6f3e1b472d93bd483055ba2fb1bce51f4b3400db3297dd63c0f581f977dce8599c2f2719a8de8ae9135a49ef9d2ca4fadb3615f1c648a81c14256968936ea000583ab2978ac07a6cd1ba12aab7ea6764109018028da954b9d39716e3e383fa625f82b16b6abe1dc1c6ccb739a16a97481ece9752120450b0c093120486642df1fdcead163d25e935a0e015f168353861ebc04dbedc487b527508164d5cf38d4d7c69dee1b432ba8544105eb04122d4cf49755563d6d4566b968598397115e4ffdcecb0402e934fb5c618b74abf4c1d96a88fb053b0491b409bad096d79a39d0811069b1f7f63ac5ea147b593f6f037969883d485d28279df1b7ee8022e2f45df109ffb4c4343ae88f1433f6c09cf2654d90b1a69e241471c02126c887bc339d7d316ed5aa8abcecdeab7d83d888575149e785f4c8228eb47fd8fa7d87a8e4667eea7f194069dd35d65fbd9885c4a45532c3f83b2bafc4f0d1b3b06416588180acfe625736db49ee2bbb33b52bb42627bcaf11a17725f5ba21d0f636362e758a756827419b136515611f5feaca80c473315f6688a0ac848c330436c793b3bc4c46a2246a40cb1a1854b35219038c22b2f6d701766bee2ea5e76174dc8f984c7e7d9c9f0ed2abe6a1dda8915ffc22554f5b2c45593c768a178d4d1a5f7d98d2fbe24a5a184a3d539b3cdd75a5210c700df07876db765a9fd34997027fe2ae7f82cc85376113856e7742f719cadf197a9a4ddd65c3af86b36af91f20b77f14568054a742e34ac93a6c2e9f63e4031e0acb80409ff0d771be64a6534290a4a6d1cb9536aeec6c00c04f8733c5d4c8b6aae8ab7f7f9728ddb0eaf1180b37bff14bb1d15144a4ea36f883ec10ef02d13800789576c3e8cdf7385a2d9a10f19ec9c3b80a0bee6e61cd9e5fa452f63324926eed753ba78a7f705909d0e17d1bf060f5dc444cbdd552881492bed46eaab23639d539b7980bd5664c104edde57a2a50c27e79a6257330d6382cb57a36948442faece71d259151caad1e9397c0ce1426b4c85db02533e117b3f47ddbb6d4601d8fcf29d7852fd737f5ac38bb17efbcc60d40443bf8e9f9bf410cf894f969ba7f3fc6aac9b7c5555a381016dacdc99f4a1975d0801d553f41f1b336901a4f9cb93c6fd4f77301e9d6625809d3343d640dea6e6386b63300302f971c1e51b926892830e629759d97d2fb8a4ff0de55c342592baf607959d43d0f923d3a1e4f404b6e4845307b5bf3fe9cfd9c6f5bf461e68a3384c10782bca4e7fbaccb409ea397b9bbd8c98074d0462944b6df556160540fa5707e535da72cc91dad2a8f8dbb1b39038fa851ce084ebd304181dea02c4e8ee59bc61d42a22d4b0f6f49f4d93558d9519de8eaf50c3b923ae96c67c99595894f42590bd9750f37ec64fce8265b52ce6d8cb66b6a30d40799c0d58521e16c8e95eebd4e89dee7340d9ba12b50b522e803a7212ff80d55162184d07e9ddf1f4855288bb0bea296d1bd704f807622c5073151ce65023eb3f67d7f2521a7fa7e0a9e6893ae25cc46c7f14fbf282c476605c1f10722443552204d95e632990e8b291d1919a06a36270491a9a69a31eb25b909f695fa5adf30cfdbc6c752bbc074fad77f972ca49bffd959bd436fa467901740993fe94944cf909883c827811c869650e89d59700c95e1ea77e85a4ac24763a1da1a517731ba6b7e1c58fece6a151d71f305880bffd9b9d5d43942d99cace852fb1e0cb28eb990e98a8d93d691207afabcf0464fcc8d9ba4779f6b60503fd29343e59fa8840715756f9524c637ff3e542d0ff2cc3b80b71f9e3e858fa6b4b89f43258f4f725f33089d8f03445ae4fc01757d910f08d618e7e6d1d16b0dac46c65e2d2cf9fe500ba6aaf16faad762ca66f3f89b3da0e19221f588f935b9c35d6b1120b75fecbb71ffb31d8c2954a14e3209f8c73443883a64bddc88362e115d3b129f87df18c78fd8f40d4e68a0cdeb9b2320c26f069cb187648482a543cdd5658d6b0e029132b9caa9f16f8871a00a5f4db957172f3648e31abb4e1ffb6858b32a7a319deac11cf564073e25252a0c6b6af5f05ec9dcabc44ab2298f7d183d8c5a1e7ac5dcd4aa9a33fccc08f1d383d7ee841502a5efb7e85c95b00f60b72bf90171b9b287513c7ad0fd528951fe6a74c08fdc742ce42c914731690e53f74bff6970f7229bda90706cd7cb9ca6a2489aca49d7dd0c18ff37d7cebb91e7251561005aed6752082cf35876ef2bade3ea1aea744cfaaef5d2076d6638ad5ea06d1c78ad4624cc47c304c2a99e5570c4565a4ebd0294180f1f6ae09b662581a37825306c413054cd9bdf0c486cd7f533214cf1f27d02ee92c213eefd02bf0120dccdff1f2e95beedce622167f37ecf7258c2ad97fa583e86b4be67073bf43524c13deb55d682f832910e03762129e81d0f2fdc4b348d30d8a7c20d2263c17ab5402335a300b57b87c17dcd299bd53587f4e8d3cf8f2a0b02a1d653051ea04b5a6d60a31f35a2adf677b7e468a81da02bf8c4a03adc713547f20977b67adb2455ace07c618c572a0132b4bef622a6350586437e35bd64de42b8b5de08cd3ad622dc708d039842ea33514258de92d2af76b7e0029310ebbaf6c67869e4fed35cafbb60e6dffc7d59daaf033641bb9ad7828da684c67e92f95662b8eb3fde5aac66ab161bcabaf343bd5de462c10fd665daba26cedf450fe97bb0aeaa4a785111fccadf1e9191d2b2d4871c2f399471ac67dce78244cc2d94b7e20893428796fa35a94a005ffb00c20696bf927772a13a33e2aa31f8124ffa3ee6d472458a7b80c75bb47e727275dd9916c63ab544617a89687338b0a88813e5e7421f2a6e90d6e8af1a35b17be69c42b6f862a50ec26fea3491390057ec0834bdb051e2a368832ab06ddbb19cc5d22ea8d31b00a8a2b9f9e8f4b2e827d52542f2f6de97187f416a5c848b42f7df8c140475ebcd68663b9decf6411113cd29d7f4b1421450ffe5c0e81771e4554a9381d6c840fc5d2230e62a7ac72f7eee2ef2c09cdf95a4b7152a15eb3c392747c05e250e435e283767d902c8e6f8efdcb0215b32a7322d1cb44a1c6dda63523887c3d7e667442202e70dcdd8ba8ff3e7fb0a79cdc37637970ec7db908a078ce895da5a2b87de13cc426f8570ba89e41432571ac83b98788cf8a4ccafdd5ab33bfa5bf69f5e9ccea9701d83874aa82bf80d4aa2608178cbc7f1dded3d07f024c243245894bc3df69e7d196eee083b877691c675df887e4e954284577f63c1c8cde1b398d6f3ceff792818fab7a5804ae5721f322ca447fa3bfce5d7593d93746b43da8a757b40b255932a216e00d718f14d73f3747394c09e13cacf80307d6bd8322d313586d9d9524e1078782ee4ccc99058bcdfb688020afa3f26ec8e7123ba56e6c354e2fbbf61f91aa2d6f6a9b6f2aa2cc7d370c03067fed835bf28311626c9c4974dc3a7682ec29aa0311b65b54f1f542933c6431f1e91a5562f957b64e17e59d20d9ecbaa3ac59ba3ec0ce979f6e7c584b07f9de6f8ab233605a09d6bf96bf84a8ed7f250f04977cb0187d2c80788724cb40ea68e83833af0f43e7a22ad4ec43729f4a6cf92823ac5782b4442fe3981274d2d5c2bb54479d64c773f589bf1f81f68c90a2e7e821d57da579dec05884ccc81e89925e7881525d32ecdc123753f8c7806aa304d222328ead459ec4f3c93e8ba904d1fc046daf448487495cc17156269ae7b1a5face262e4e568b2f4d47294a133ab6daa287f81a46d42a14a5526bfc63f4b76f013b52bb35d52711efbf0bfcfcbe391b4fd2d2b82f1045bbb72454b6bf3bf31dfa582cc3d1a39cf81cdfc838ba83f764eb26216eda85a5c28a25b9483acce449a172cfb890891f71006c931a86cc2278aa51bf5a77646c316043735b989b33907996172c70deb9bfa14d12cad88ba396ad6999127be725042cba75d10d9e5d5c05f176b2d70659dcdd98a928f1013088b50131537d707f749e00bfa6a2be29bd8a262d1c1f392a3f8992b4983e7c1d0c4972778b13b767b717393709da9ea3717a4faea4b0d48485e344f352e72b65825dd08827d99cc481caaf86d5a79ab351b1d82bf562235a9d516ab5dada0bf0f8b9b90eb60ef27bbae6e5198f300485cb8dca63d64aa4e6af60d61c9f37c58ea15cd57d447b30a73f9b2622aedc50c3414f37fa42ec1cd004a26eb38d660411e87eb11e622ab462c4bac03536ef6b8866a681e1deed54d84ce27411a9df0ca30eb1ac111ddb2289e0fed4a266fd464a4be993d98db03d320ad1279af9adb38f38ef4f2021a0d5e7ded7261cfa9ae94e50bf537cea3a702f791d65716f35a54c595a45ff7b6f2dcdacfc6c20e14230ae68a04a104d680e7e7ae40a24948567d9f026e5c73cf907fc43fd13bf56f4646f2d2c23b785e06adfbb3577a64b4b9cd6763a422ed4718ff68740bf531973f7a8e090f05b6f177e316ecdfb5304a5a0e532d8fc3e6123ea0d2874bd87daa03151cd70905e695aac070e1a3779e56e4984b6cec6848021057055392efb2dc83560430f3aecb06c8362abc7e6640d500dbe83e3ccbe0c8de53b0e130b6b74a074ccf9ee9957398bafe62e12e09e5be1c5a5f24b63fe8ea66fd1ff2e3513cc8b0bf503812c73c44dc02464308053a28616814b84f63b278992c38673cd3febd5c72c8e8181e6d857eba2d034f7955cb152a9e1bb42c1e8121b75b7b31e55dead01f10b706edfb12da6fce87012244fb75aaf1db9d859daee63b1812fb0d9b347e9dd1b6a09ecfafff3296831c74ea70747777d72f97b7134565fc7d64a8e513d19da4c6caaacf02838fc11792c60864a122ef60c68c331108606d2657b7f73ad6828810cbb45985afc9d117bc520666692ee3a50731f643140682ea3d2142e1e16a836a86dd25c6614e0c6fbe16936bbb70f471807c78ba5747407afd90acfa92913cacf50fe1f65385033f44616fda67488fcc9a7396726e2e0f7fa1d10773a8b9cbbfa565a9d94df12b1cfc74d37ab3d2207431ca0fe3a1423f58f795babf0fb5a5ce45bda7395afb50d4f13713c748c3fda12b7061b43473f8855350b98cf03d3bd745e895e36a8d80d7fee34d7189671a0a2b08ef0bef1dcf8eaec9a36500318a7c9323d61f4543385c97be391f4827dc93782b9cef868b7172d7b73599c08585ecf0e25b672610674b56cea922eb7a68bb3a473fda44d93ce4dd9dbe3f9c6fc95ac484c20c9d59222878dc20f70f3577bef3a509ad7fbeabdee0a72a3e263f3b5e45db5beefac2e24b92565fba101826ade90af72dac82be9b0bca67542fa58f765d4fa03e5e0faed735e6b99194ae854de6d5ecc7bf93aea4d5c47054ee8e75d9d7eca3a02b811130f23eec5d2f4149a33cea78744d6d4f0177cff46d3eba36690e798fd04baa506642e906dda74b744b687ee5da6547c589fde4f81ab4e4ad9872a40f706eb8ba6c9c32283ff97c766354626f1f9ef3655ea04353192c89f357ab6fb97e4019034ea2ecf09884fd6c0d70aea261d800f189961b22c4638740ef09935b6aeb61b9136f5c3aee3d53450a70f05b30009dc8cca94d2c1e52198a3a1090635aa82fd1478ab8aa6a976a2fd96906fe3bc5d7feeb47ee2528bac10fa484cba95ce7b96ced1f32eb0a7c0b99b5a00b73ce4d1d8ecc7b3c2397b2c5c7711185e9c6b196d754e16a233d978e9ba638b162756426493da8208d9f9e40c378f946126eb93f2e0ca5f8adce090ce05543112453a59512170fb4ccab2f1b2aee5e6b3ab74bd4033c65ba03575e07e1e4e2bc7cc48da88cb886aa367107802d251002541e17f6d685cbe146dafa8e15986998cf05491389b29a5c998cc562f919bcc7a497c062ad6e5ca7a97b8deeb33f5d5f63add1dc7d679c7c5fa48ff561c4287b5d345e7563cddecf519adddc2d5840a9c84ffab412fae495c11d20463d148c9a30b80fe632d1b6b9aa9f9870f9e1bca7bc4d917e1e6ae3d6b0c390706eaddc9e6b6ddc2ae5695721501336df16e74834946a33ca04ae638d959a603c27b1cc9cb70d8e378b724148e853f1b81b1fb4008f95532b7f2b5aec0a45487c69a1281b4a410c3e0786bb8e3e8af461b029b7359140fea72df77422c69b1d58ae92a71397f3fee718729ad6da47dfa5705ee606a06091323f2ccda1888a4e05621710d8a0fa73d142da7215bfb8da94e52dedc8b5a68761fa704fcde450bf2d1203681e653cf653b7da7d2f99dd5fa4eb831f1e87f042fb9a64e95591a832a6df388088737822066594f7a234de89e1ce89570a0c4079286ea5be4a1b6f4a0be089d2a138887f272d0bbea437775ad82623ce71f266220061724477b4c9abae6ba5c5276eabcd4016d9629b7131b3b1606d4f478ae6a5b5e8ebf96e985e7ff101782c33f4e6dd73f2e648a1ba6c3dbf3d9a702beb40bd39466e26ac3338c40856e73728fc4b6014103c4acfd0dcf70f378612d9943def1f25700f36408719de970377b0f12cb06acff4301b2df8741358057777042e75d0039889ad1840b53fa708b89d76e68e27e8528b3f5e681268f864c71c7de2092d76a8217a5e21b55837f06a75d1c7615400049245f3cb1c89a6a705f7d1908db7da7d4e7d583c3059920b721e7456251a560134b4fa6b5b8d076e1ffa8e9cca607b3df861f3d3aeeb18cf0e1f6f29d759b1a2f20f5227207a9951ca13431d814129803d0658535adb92d97bd79e5a8e9004dff13f122d7bfdef6c625b17af65bffacb0449fee60477bdf30a5a9056e5986065da7e5bca107f8576b5d61af0cacb32a54c7435ce4af302d826650aa064979b989074d060dc9420199f3aea69465caac2bf6e61748075e83bed616bb6a068a45314dad57295510c8cc4abd483ba38814394ed304e9dc0178f6d6485cd5cb42abd3b0680337c933163782555fe6ed7eaf4139320cc294f6fac01468288ee55f123b921539922c0056bf96a7d65afc8552ece381f29569c5c5c5efe9a4b95492ceef2d036b538511b199bc43676494b7fd18dc7889ad22b35b7a6e108d6226ab989c5fb74d881167f7790bab169e5326076d1d8330319fa1e41979530e30a23212ea399c10f70fcb11e90bd15c244127dabd141fa7197ec5fde50d24f88960c76a9661ed466e71b09f48d525e7247b8ba6b91a193b1d057e6dfc21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
