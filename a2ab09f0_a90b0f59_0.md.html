<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8a3a15dc3cab61ba7694f44978c499d0f4de7bac857d593def1e443a7733a3b85284b3fb74a1366c9501fa621b76bc9f402f449ac2edf7b331e24fabfc38797f61f3b17920058f6c3841d6683274d7c9212e6749a1d11f84949a1204d50cf4b013a3522e45c6f00bc888c0060f29a4c92cb1323929fafba003421bd3a049ba121487e4428d5d193c3ef9628a7e18a3d639041d5be1631c25856a9f7bbb241c26c608df33d1c6557b9ae23517c9cc5e2db76173671f7d2ac69b1a15b3fb6ad52fdd53ab1e89462d12fb3bf02927f628ee9c9d056579522995ef50bad95d7bb2778c6683496de68456be50f45898f56fa4c2c3413ad6975e722e686934865dd838d587d1b57c2a094252472c9d482a577c0215f9f87ecabb2473b89ad2ebbcef0dc833cf44fe7d80dfe1e02a17dfb75e82072326fdbfc0901fe70dd8dc2f01745d834ce7406ecaa9b00e2fb49b3c011f5c8a43cd28bec8fa2e9d7f34a1bc61292825c5e8ddcb2eec839af16cbcdbbe9c38b980363409cc82771fb447f4feb63996053a97d382ea617a4cc49d165f31b67027331bd898478e46e786ea41718e81a579b33b63f4a2280a874f4d0858609a3f72fbb5ccbd6096801038f96e3e89dc5a0c2da731cc2f474b0de35a7d8a5d4e4f490c6ead01308604710f00532fad4d2f7be96f98cea48195d34dbf1bf137a5bae28f52845f5f3ec92e66de992a1064fe1619156f886f86fac477fe2118f3a2246ade9a380f2cc31099493ff0a96f4086ebab73df4267ef90d2fa66a8e9314529b796c59370b2673b685c09a680c78bc996900b3cb59c398a51086497dd009874ae1f89b1e57eafe46bc3ea3d3fdaef746a7085af41d0401a1a82110d1f36ee3c726f0dd17f10fe98ae6f4f41e2cfd87891a076586a586daa37f9182b0619c04be0fa8b9dcb6503962fc5505235737a25388f629b3ec49dbfe77369ae643d104771c17d9c110d723d4b84cb412eee3fb81850416e0edf8e640ee8aedf52437b013f693edb837a4b63a8c30a5dbca3f6ed43d17389cb932032611f9e0c15779d4f8829842ac3ce79661a80543c2efd2f2e5305f084ff0b1fc90083a359a406d2c8d481350bad0988c71d796e7bcb13621425e178aeb8cc99b78c061232f921926a8a20283118768e5d956aac6916942d763f62f393d3feeaed5622028e2e67b8c863cbdb8a1a104f2f4bb78973bafd7456d4ced488c3b09ee969ae55676ad5761536c8d975b6613006828970ada8bacd80ea11587c6e39c4ec0c2acd55f75332ea07315bd43989f0739d8d3338fca804ef3c0a5b5cb5a2433886261f851f83fc3a4a455b2ec1d0396c87462246f2384fe150803a55ce312d9bf5a91b60c98712e9dae19afdbd38791415f43cba7a0374c73b68275b97a258aab41de3ad8da1e6c9fe931685cb4490d8a8939507ba5551ee8b3814a4fd84dd2fc780164290aab8e5aeeff82f7f9d48a3af6e72ec7c44bb8e61112eaa958bda7e80fb884b3cf5d20656e114e018acdf030d6844e2e371ab535c9c0240c76015c760e28d3ec1e8edd7dcd75518d1a600f887fadd235bd1c3ec4a882c8910bf213865554f09eb61a5cefb16368b94741ab84a9499fbbb8364026137dc9f5445a729a8a2334f32b529be1a858c7436c8a0ce4b29ddc12b575889f5f0c7c6d2fa5ff00c5e3548bf1b6f6e7f17198f1e265659b7a8c563b7dea2f48210400322fe899d507b424783f38d99abf66a1577223e6ea69eb6b9e1fb6322ed167485e57cfc60bd326a7191a67129e661d346375edbbb2d891ad62aa5c13f560209e4f847cf555e3ef8831677b090e626266ace8bf3d84165d9f0c65d40aa129251232bfa6324c422bd1d47f97852216d674b3716c0d26e0ea992fdf6046cea66218f009b2796eb9a3e29ad0f7fe64416d176c4b14c67af7021b364370cb3a08b86574b226bf8e27a0d559f7728d9f8503b34cfac1db2ed54079dcee1b2b200a894fafd84f3eae518d142f3113378eb25c42cfcaad07506a07f3998a4e6a121e855364e28ef514a7979b2c64a600e697c24fedcf0173154d794083af5ea3026938ee621502240eb3fffe9898e9712fa136ea4f3f3b91427fa7c64f330c798a7899cf8d46fc80e8079a06fb38c8ed15e35bee50c9b164edbc3b75a83f1ba0ab10535d1aa3da46d0aa047cb8c8a98d49b0e08984a2009ddc88992b38fd8af11b70394b5604a2d8c7db590763b221de55f74e4063239ecd07bee7c16e2f0f262b814d86f5a0661f56102b74e314f5ee1a14db727d777df806eae629a26e37286f5acd099938f6c83b03c53f4500c8be6faf7dafbef83b6e3247ffc768b41dcc3aa1c27c39a910345b6668c3561e7cbf894bbe33ee3b2641afc51115ac1cdb27342278c5e316f45430146a7890e9bf4c26ba3ce45f3374ad4d7c221f1abd03954b7d6a2efd54aca39674687064647465ffba2937f36993b73029458369081b69b540776f806a0485a115d3b60ebc130b16e0d3b804b233a23c21f40fb4baa483e7f50d2e72f98d5af5bc73609fe8f11efdd0dc7fe24070ba56bbe074eb30f6cc977140415dbddc8c6db6d1eab3b4d11cc75e52860ae7842e09252257fb8f96618eb3b1508ffc35068f8d6500244f5a91fd84fdba12c3a1ecac6567be2fb64b664e0e60f7117584c2de54a106e68bdec9a93de9dea3658d3da5aa75089c3729128e0b4b579d00c8fdb67cf08c025ba73d46a8398f7feb6c138b3c78b3bc2474efa02f80b43904f0a1d238afcc03747b9346bb8f3e5285643b923aefb7278d62af29899fd209ffb2f54489a7de03c6746eaaa507fbd9fcbc9f99b1b59a3f0374e60a21627511ea0e3df07e3ad00aa897375c2a324311703f8dc112adaa5d92bd4a516a1b6771be71099331f9f3689aa2c2bd9668967f1e68dc8e920e6615b5e23bf4ed501da541a5c76f49f3bca6c60f7883aead24c5dd1a47d88f60cf8125b44cd8c59cb072d863b9911df10400cfdafd7bc950b25898aaf3c7063035e267f40a78e3440ad2bc50ab4a6c02381791268f283440061c3049dc0f8907892eed62e0782cbb2cd82e37e3ccbb90f77e051ab67dcc61d70b35b5202a75254c61055ad1fe6e5bb7c3df50d85af8bee584f3742e24ddf38e6f5f79ce40794e473d075d92ec7bc65194e079ac169f848a292b14cffa935651b912b495d9aed6fedcbde4614f7d0f363db159d4ed94748e3c2fc724db81fe8d87b10147aeade0e48353d70717c367ce24480371b401b96ad568a3c9da5e8f8549e785214b5497e7209907b0f323f296e533f2dc376e7a73a1b890fd36471813f35e21c7b1c87b80586d9e35a10ec7ae9292f959502086f22ec80f414494b076430c3ebcbcc9618cb22901f22401419d25c50f18494f9ef3f603575b3d68f2b6e4e830504e17014672ba0f20878a0afc9407cee8d2512b102ae4d61dc688029fbbef0bc606c0043f89949b1a6012c39614a5264139c3137c003d1029a92913e4d327aaab3b818b2e4201de30f737d783928458c6b49486bb4ed98596d8fd124ee1ca705f21998a70a8f81149ff996fc3d5e29d2e8c6509625cfc47f1aaee6597b52d6bd773c57ddefb5432883eed501db5b2dd7bc440ec85b0454992ba452d8186428f473fcb63272006b68f0d43f9a6bc1fac4b6c9cbba9f23bf04ff30174f5b93d036c9dfce7c81e9f7870acca37d064c5dd2c5d22cc5b20206366903010db854c7e409e4a565df8cb4eb8fc28a03729e7c7ba3a3c405a65ccc9f751070eb9a150e5d61c1a25607c8698e129e196cec7c6dcf18d32b1077181680709c84059fd884dbf9dd19f336106d148a514ca8bac56a47775c947eee3a690afe04c2b6bb3b54cf53cf62361f6a574b8416b332a6640303f82a829e0dcb053014f37cb9fa506b6012f87427951139f75006257558b4ce9fb724f88cb62e6fbf02d671bf7b0abb6e61292ac791352d5194993e99863111706e2d41c1e5d10dfbd68b7f93b1ab00d7a694312858671233fde42a3664cac21253c865f3bc136c112d9cb5b7fdbe8995f73dd268cd07ae2badda1d9f0df9922338bc8cfbec076ecc5aa925c8b412c82c51bdd979be6867593111a397429b671cfe91dfec3d4a5992e20031b0260c7c192ab52d276fb4f9bb595bb84aa02aa44507ec3908132324fcb0ebde77d1c66c8888f97f75d4f037d142afad9522fd48f08c8bfa0d46cf8ec266826e470075197117d55a38f78a57a8e8d65b628bbde6ecb80c6af658e62e443089ce14b1f3b1f20ef00db1575d6dd3e9af96c7f3b5b587c24fc9c600ed6b88ff524c556f407c79d3c48574ae77a4771b99ba986d488ad15d7dc8ebfaa801eb4a5c96f74a84cdffe267306f377a39001b16d8685b303b082c55a2446fd3f8be375a16019df1d1d1f023d66a61df887dfe8f19dcd8f02e14143dbb4b3f84f35f362259fe4bcec57884312fcb85028d4b5dde9692269f10b56ed7b29e8182d1d59f37c40ffb73e7e39b65e708bd9a7babede14450f44ca265f061ffab9f8b306a364dac272596d5b265d1ab457b6090313a787e26f84da650f0214b93ae09816a2d8313336920d75a8a0373fa8c08dd3001ea1324cc82cb61c9eaca931233dea6a94a6cf2f65941d3471a3a2322597d38829a1e48de02db13b9078398cd2552672acad4443427a52a0ff0b318dfaaa458d6524e0590ffc4ccfc14b11b3509625efffe4f85317137427de2841816bb84a90e4c3d6c316aef53894860d9680e6e5a31bbe70752034cf7b63e7e037cfb3895c219cb3b710dcf931931a1efbd4cdcad2538789a0b807b9baf7b3b384fb9fb3342716e2ad6d81cc41b1e4190de5f655c6bfe4fb53ede3d7edbf695cb648da59090c334d0e15e25eebdd0bb83541ae75d8bd7781445a0ae3b6a71eb2bd75b2871a50427e4d7dda42f716c506e81681666d0777d7c6765421e159dbdacc0d02f97d2a5cb262cadcb25475c1f63080de2b49b5b0684063861a23383cd88eb81b05c473b6684c5eb81005d2142446932e824fbaab6aff40f676ae86c9270a7b7376f2cb5aecb820bb21544d72d3bdb0ac31309b41265e76de414c737e94198427572980d03bc538e77fa22be4d6fa338ff37b3a84bea3bb1232ae8898110d6bf0b4caf8c3fe7535567f7ab26d6cd067aca433b6b76d3657fb6c74a4cfb9003101a1c07d793f1159d092d8efa64f191917dab04c602b32782d6ea71ce2d45514bb8f5011d275e5a0b52032e916d138cd5552032f6d58fc0f5a6bed81bb49a0f83d736b04d36cc8388fa2410963e6f50a7a059b9f331f06d5809536a47c86c1ef3386b62b666eb5d884dfaad2c1a9eb08dea116270bc9768e9287be3ebcc86e1d29493c482279bcaaf2070c14e08bdad6a386e2335f1df3a4b5e90db71c74c8f1210228682fcf07a7f4b689b15adfa2a0894c87144864012853a116c8caf2940498c3b5893feae4247ecf8132b70f2f3c25ba34730ccbf35173847883ca7791830749df4a3905ed58da147b0efdc6bf8876c1c894ec5521a338e242fda227739aa1da3d0333d05366629a5e938d022759ffdc2320938b80b9f154268ea10be5a75b4ec44772f55a873d194045baadf162250fcf85521e47f11d84622c2bec6cd6aae036916e0c01c090e6772adbc1abddcc7ec48adc724f9a9379cdb11b58ca75a9eeaae153aa91af6f23bb70323f1ec13f2797a35865db902fa767bdbc898767acd120e6148154406b98e13050ce1de5ab69e40defd95362a6e167cebf9bf89b283e75358bf026dc5115fd3d8fcbdc3b3bdb7c400e9f06ea9effcc23ce7a32d6baa483c885df6cbafb517dbb8b677cada7ed13a5f7a8ee493628e72e872a4c4dd7e6aaeff04ea9c3788b6748a4a99fe7a226595dbce7b42d0557b80338fb29bcc7049d892613fa8b5d007bb8a1b94f349dbc92b37c303ac95c1d6b0315147edd6bfd974d2d5fd332d04372d20731fd0594a7528da1bf7d0f80afe0d64ab47e8301e26990cb5f17c97d3210127f50c2ceedd4a25624494a0fab6a99a90433bde577cbde44c5e9c90152294c6f67ff71bddcc36b1064922a70fecd1233404aea7a20200686a8c857f613b69cc2aef01ee433837d60870c1c7adbe159fc3f4edb9c32a71ee24462ce88c71e634a8c881ca05da6c0f2d32d8c7a7d5b903d67ef19d53b424dd4810005eca24ca32d9ff88ef4cafa55953970a2cd205b2fa88c8f2a230cee09473a2181849c403c4c8f8ff4699ccfb2cd42e5d41102f79a8c8446dc1efbfbe6a278d8d84142309510389eb0b27e480b38f60a89ceacbed2310426678d40b0d7f114581189d6eb04291cb841727131c682c4883511439915d49b4519e385bf062499afcb3373644e3ac95675825305e83a7dad4e1c18117a7763792a200e6922e53a3b3d2d50e4f957b7e5284cdb40672774ab08d5f9ca6dcab9d97ec6c7802f03b943da100de95c25ad0e9dbebdf1ec44b7829080d07cf7dbe895f83cd489e94be29704cce0632a60d06e7a98f3a154955e880420076af924e62e2d6851583d2feae0946f9ef88d143e140e01680ed0f77f7c66779e8e3c199f06a72cae7842277808245e8c5de99f40f4b25ac3b0dbd59537a7344226943134f6da8082c223c8526831c750daa5844c1a4322d86f8b6220de85a627aeb5045e31a9e78efa59027da18bc14c5f9a90d41c0d22d0d693474f9ac17d1bbe99d9a5f45459ab3cdeb6c3f765ddb2986b7504a62643a09b69cc09bbef20ef980838dce4da047582f10273aa983194672212be57f02757e8b94ad362afa5f4ed2a73e3bc868067605039a2f727326d03307d269e90b98fafd61282e526d87f6d762d6f32e29ffa94f29b40593b05e748c44f1233a93b33431931b834b9647390beccd6e3bdedbd4729b7f9178cc402ad00fcded020c1ffd70e2856746aecc0a6091326bde1e82e9b7edb11d7f9d2307ac269fa0ec409712d00135e7df9f9ed8cf67f432ba27a37b4c676540d2c0780ae358e3593830e18092dcb30e257cf4912a223388bb736e3fc7a2e4dafbf312e7b121434cf68f8934ef4f290314d758f54d1f0c146174930ff7d524660734327897df43772224be3b68fb55ff30b00792e44c745ed226baec83d36e3e3375a20f0060b7a3ecf59934198f63c2bf35acc2de0bbd16e911bb5ed3409d24b51f3f327a81d301ca84d7c693aa2ce401204fa7e7ef34caf51708204db782d9d8739e3075d292f566a66c667f2f0fde602f04769ffc858944346dc3601cd9c1e1d2c4a54e6544049cb94ba614553557c33e29d116fbe265d859011e7797d47b9d8fc7676f16cf3634f12b578da155ee6de086d118fe14e70f930f1b9a5c9d52b365383d49195dc590dc0e691cb8a843b71b7b19d471f128b8d739df5ba03494ee8f7ef68fc59b455e6db6a71924b708a4cd623eb42cf8c18d1ebcff040f50d316349daa620121aa2175ceb464ea61ef6a17c3b7853ea9daa2c4354a2528b671aa943c032890ff9b18e3b6e0507af9d17095ca910d4bac2ca90b921fb2b0ef696abe354d7bf91aad5970e61c9159137d1e8744043d5b830c8d2350b17935e05534571262b44a5f276caf250aac9039325e103c846e82c7864d560d3794bfdc94ac58d400b466b59cc4b4697d2d8bcef66f72842130ffd31e51c73e9cd4c5cc4f977dd45566c116bdc6ddea37bc9cb9e3a512797140cfbdb177d2d584832babcc714e66f6c298d773dee2f9844ed6306558561b626e285024d13a33c306e33fc224068dfe292f343233253cccc19a68d1daabb42bf2cfb2d6b1c6b15c53cdeb7511dc7821e17ac25de4a6dd7958e00cc2f6794a0d6e520ab9cf7ba34ce29f71816cd0f5385fe735c7ff72f49319d4aec6ac5b1272772edd22565f9bdce3d3c266afd4f6c75393d73c791061953b5e35b5f6ff3d44721e9a866f722316ce6363a9eac6bce3eeda58730484eb656e3429641009f92fe67dd9506b39caa4c9b08284159f6d56df7776575abe263f68d5e3e89b2a5990eecabdadf8d9fc14b65400caff9823642febc6474adf05945c49738969be3e1bad0370d25046c802cb56cbe84fd278c33a6728fbfcfccf8ef67b68d20b9f1cec989222f5957e7d71af92e661fcdd7d110451c9679b2587fc679758497f9fc2a6ae86d3196dd654d1176bec6f5b71296ebe2aed37a5609c63a6b016978acc354985dfe2f1b59db031fb678b395a8eda32fba5be69d6bf70e904c60dd6d157c529a3a2d9da191a83396cded7887e803f219a3a4b58eae7eff9cbba828373fcd6c80a629c43d68c9b852ec29bc1f3be9b409318f1f5301ac5fbb84db178265ba9c64cd3bfd9e42d6ccce585317db4f2d5edcf41531349b8097e3e4db728e941734787c8ce493236b08f3f1b040cf5d4470b6b7cc5ec44ee273d66255110a964eca2fe5eb6c8c344d41a3cb66e6cd570e206ff07392eb687a7f661a39eb5d79130cadb3aadba19fcbd662a7b528906b111d1775454b7ae5056a51531c23abac39366c59f4a647483fd07e3d6aa7fc3d7b56346f531f757b1e2d6abf01cd9dd838f365df13e7a190712ba2f99066a7bb14dc1f525e7270e8e7bcbca1d1612f7f887d7a82f4c5c7ff6a6479b265c3deaba68d9f02556700d2fd555e17244da937c715bf25789ef2c0a914c11ce6d1d6ee35a4a1b3e11dd2ee0f1713e77f833e7c065c1d2f3c1f5288c844340225fa8619e70f557a182579b9979e9567c397264e2a2f9752df6e25ef46f667480d576b02f0fe8222cede816293f3f65a9f1d703be679b31e7e5651eb241aed18979a3a3d5c8836f008c64a9c6d282e22c4ad2ab9bbacd1e810ed28e7a3533d4bd6b0239f13126e54d4eb4f67c9e31d0929444de656900326357c4d3afc92ca79a1537f840b0aadf07f1661eb3b3d4962a5de8176e21ecba28073e6c53da612f5e216c316d776fa6ba525fcd54596cf8485f1be54325be7605d1cd193b7fdd05305efe7cf4f2d5c02c4fbfb40fc4f2490385615d099f581e9867957166a3f525878cf83947786f9c749c234b226900beb22818e4f0e09d048b705e706771adc928219bd5ba20387d9cfe7c5b5e65c2266a30a72c475847a77ad4a0f1dcbb946764de223a281a2e18908ffa8816c0c33f82df831206558c775f25245b32c034fe487f2fbc973b4811965e72245fd0bd2428c68d00d04174809f9a4c5c84a09010a52bf0942bc5e5195b661fb8ead68af0237fa939a9cf295a853148dbd1067dfd3e4d6107b8f54732d368b264135a6137c7d96f3dc5082e824df817beaa82a4f7f5081854e6d61d6a7217fa9a159c80844c472bfdee67286f2781103eb7c01a152148d07ecf77a0f6175818014ea2fb07573049b60f9e8ae6d0c71d4512a93e2ecabfb231ed41e9eb09f1b5167d7091ce44da7e3e3c1afbb123bfdcd084a6aebbf3d61eb2353e366f8d1ebd16d7a1831455029cf2d624412d99637d7d438f11499fcf21f380b6650a148cb4c8ed21dca45bde97d2451611a3c0b07825702ece1c77035550b570573c25f0b56653ed9558a410881da635695b26b6ae53d6adc7d54136717dbf67d97e7a7e8485bb105b7107d2b230c79411ea827ab82a8fa6155a85c835c0be85c82b5ebc34b61168785cb10cdd08bbfa92e8077ea857efe9da0fa3d51dc86a1f904f53c18183434ca0b8b838ba9c5e209dc5832d512ecb57b6a5d3012f37308bfc9c161b747e5f289d18c6c2aa22af94c58747bc13d29d5c0383ef1f2b43dcce8eb04d13514375ec93a14d371cf5963e365a2414f524ecb1de684ba76f7fde79558b972e6bbd876150435056c087b77ec74850847f128a073264e6d01d840e5605a6bcf6db4106b2c472e3388063a4df646c0efa66585a37971fbc7d13ab6e8b9e5ddcc8f510adf91ff11391a7daaa650e421b8b8727fe55356011a1abc577a68717fa8b343f14bf07f6cdc86e93e00ac832a564fdfe2d6f637a3f3b22fe6c14564066be53ecddcbcd65d27b54e627b9293aaf15bafdc4035a5160b895abde34506058760f6745ba72f67acfbca4de6f20605a87500e60289be4a7101c55eb4ea5f423eb0d189955e9295518d4783662c211c907d45a4f80ad53606b574867f7df9858ca1548d248736f61ef1fcd1f31d9fda0518b426b5d5ab6f9167fa7598d817e7c4518c943adbfc7fb883b50c13784be37241c23ba6206bb7b3b496dd07c1ce43fa9e4e821f6397d14fe2951ce8c04a237da750176f24187cc49901a59d483e9057631b70844039a18b01eafd2846ded7550e64b148f6ff85a5685e20aa9ca52a03c3b409252aba0fc94f959ab744dc77c23d27cbf7c934ae8e3336a00fadfdf175ef3972c6cf7d4bf3f69127e307bc4fe46accd0c2bfc229cc834fe31d9af35d18dba0357a8cb1a9d31bf3ede7cba9aa287081556f09aacab3fac5b920838e22ad7971a2ec48efa14941bcc622211d53c6454ad92c31001f86ac91148cc75a6f86fbc124baf752ba0a89ce25f460916e129ef563fbb8b7d9c8a72783a1a1079934cd437c21c6e4f639b78ba9530dfac6f4fac6ffa4893157c30417cf45b8785d667437dc8cc9d9495feda42020ad9045f17e11eaf45f452f9fd448f1db27717e469f66d96a22665b2fbf0842636d71c167e9f64926b88545ab4d0dd1d4ac2c75ebf414c7f8f5e9d8597ac54d2f442d1ec0d70987a9c5262af0e0bfbc84478e08b17b74a1412a7417b08451e078f9e65904b7ccdc9723f5a0b6200d40bd48c0d2dfa2c1c2950b4be18c5af74c29e7e25d0451d90fa3ce0bfa9bb7bffafb92359d9abe8909f543af626928d40053ec71aac912567558c9aa16464b8f1bbddb6c152047c77a494f00abfe99db42b2998e16fd7cce67de7fa94bccfa3cc85c88b23b6030bdb2c263ff0db7ba3555fdf14ed9f4e210b2295c7c0581d33081fc759fa63cd0636139eb577dc8f8d856f52a52ef1dcc4bfda26c50592c5fef968ea1add633c84c29d0b3e657f539f7fcc9aeec5ab8352a40a28562accec8ad6c227b057761dc42e60223d62bf3bfc319334ffb36f36f00c12c12ce080ec57a052398daaf6886d9ff731e5a1ef75f0872964a47ef430f3184c76db65b3dd2fbae470d83c81213717d6aa6f5cacd586470406899952f97890a16b0c0d56a285686bc4a7b3d811b19f2dbe85818","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
