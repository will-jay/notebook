<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f5dd7a4a6578fe826247935648ecc640495fc1a8617c015f8393dd61d0a42cfe6e779e84932d66bb22431614054a9534b15b11a84629f18fc00e3e0accbc6cf59db9985a2f2572554089665c7a9dd1b8c1e7285e31aafa6a85b971952ae4c62578935c5f170b449d6efbf53e6688598a4a48a6762691f8baf1df856d8bc2c550e5a637777fc7b53f1ba4c37c4df629fa51894b27728087bb7c623e043243638dc68f90120645ad6e3a6d285f65f4721ec8abd205ec9800cd608375d35b2f7bafcb8302b370058ee7b141d3a04c06be99720ee158af02e6c93971930e89caa89359300e32acb7fe1a00f115b69728f96e8ccc7e3e2b9aa5203c343cd5ff99d818116d5be9e2b37aafc66bf531faf42862d11b59fbc720ac134c8e792080d7927b145c0c521cb66cc4b96db3463fed40de7690454b6bcff994c690bebec6b56e8646286c9e281f4912e862cec8af9847098ad711fbc6f9196b560fc7fd6ad8fa325fe6070741a1e14684f364b067c45bc70e1b028775e8001b32b270f49948b28436719c01563f7b994b67d7798eb3438813254e0081829b55b40b02d91685ae4ebfb8070a559a832948ad2a6b7001014005ee4ead0ec9200bae14b9ecb33c3c56b1c82be8b0846033744722c9fa16be4be23059b18b5cf1e86ffd3ef4c5d1fb9b24c62c3d0b2e02a122f33a419fb4582693cd435240484199dc90212582350b838bed10af00b51c58e1de04d5dd16a450bc9627726f262406408438e0d5685f46b254603a69822385a1e6107f06797d6d1352267e6b56252583dfd5afdaa1fa119ed0a8a1b2f0b270efc0759b60dc8eb81d57d529fcb9b753a21e7734fd40c9c63b31ef08fed72e596a53c54e148999c606fb85ee7563701dd46058a4f1150fddef26c6931673f613854680b07981cf01ee862d339bb41adfba4c865d28f8d330938a797525b4387dd5f038c7d93d10493c9ea082915497e90255dc85fe24abd9a79b91d018e1a99c38f483fb7e3892d84288d2874100d6b00c1af80ec569965bbe6067403089019f57e7ed9454162e1dc62d2fd9a93d1258b71e0c490a32e4d512a6233aaa47e294b03ca08693d544bf00fb323207464138f213cbed162e12272dd41b91a846ca1ce0c83f45434d8b891b8a676137e930f27a441f5f4b55b939e7788c5120b6e38342da60e4b2b17ab34cac1b288ce1f39cd8d15a633ae2ae74079169acb7207b7fe821501560bd503e3bfa1ae78555f667eb344ae3551c93925495f8191942d3a6c04bdd6dd4e1b4df87c87b4dbad6fbb7f65d8d69a1a5d0933fe84a48a811eb997f392878d7235d5e629a8a99cafbcf1547bbea9a915efbdc5ba915dd96f41a935ccf33fd0dfb29bfae738bc9e91a8586ec586f4018ca2e4bb15bf903886793acd0f5df9f4522de030fba6148c765dd6e1bbf19aaa7721fa2ce0cd9b4a69b5099f60eabae14ebecaeaad54255c990ebf8a7df510698f8d65ff733d1ec635e6ebdaa42dcf1e3b4f33b58aee3b36c86a1ec353f31fafbca3e99c20e9643cd5dfb999c996ab3f56def37f07f182bd467a0ca60608f7b9fb24f5ef01ec95f0dc496d45f3b9d86ce3173f2209dcf74dc0fd376ea3f82df359c772a1a3900d764c1abfad9cc21c56d873e69c544709b2e064d5a451d4256f360740b470115b6114b48ff948eb7d1aa00b7d16b298d98b1339924283652e3456dc2e88261d18f8f15e9cdd4fe6228c2af1619124040ea3c30468f2a4edd62f16269e3dbdb13ff5ef79f8b85b20d2c1f17907f9b9ec17a2b48f34ad55d4af00ccf974758ca332b1719fef6ba479c1f207e20b84fa2a766eba768f79d1074e4d8ec35a48cdc404f9dd044dc993ea1af0415701199859bf1975be718ad3ab4b5d55a544ea97fbfcb985697dc1d5cad0e72bcc253c74f529bf61f016c8c11561ce8c5b5edb88e1004ef10a56cb79a027428d67523449e1be9ae941a4128cb9adb2f15585435f4a6bc6c6d6a6ff63c2cf50f742cceb3208861812095389334c268a17929dd328984d2a7a271ee82cd4ed9a654f4037cd4b5ae6ae634c75467de14d7224b40ad36eccc91ee647f6538480fa74601a90fca777b6ca4f387f7b9ca5c801e1d75a40515d7c671786379eb7a56bfda837cf4372709a7c95601455d8c60f802dbc1e4ef9aa1d4e7a22ae49af6dd7402321935f55e5688bfa1498afc1321b89826cddc42944a79aa98b6943a3cdd28d38980944e6feebff37c7eebdf24c7c4479f9f93c66f71e469e4c313b49600f8125bb1c308be9f76d6f9e3850e5b272478c6765e619a04991c32abf78b6a9034bd22e90b87f279d2e3e85d25b5d3361922229e6a98effeb22a08e54d3bde35c8f794c01b93819ec47566f80aad4ee4a7d7c2a9140ee4c12ce7f24d4f3d0ffa7007f4a6644f71c091b1dddeabe8113ff95866de902b43eeb98b9dbb74f93761f8542a2343bb579ea75995941ccb6f0a36b77f9ade6119ce8fd063a3491127f273c529132add8ec55e45364368bb183d52e21860c75b9f668771013286676b9d97ae24f6b7bf26bbbc1a909f46f13e8eaac9d996ac5c26067799964c6195c9b59044f53dc68234efd2c8e1d2552512af549599990399e254baae98752f2779114b59116eee48d7e5f353315e85f383e9a50bd0276f40b525e6b878cfdbc519b8351db884a59b6441213cc0addb5f7e33f1a31ca1551db3c216a03145d0649e2926516ad8bff7162f40ae30c7120e69587f6a73852bd0b3b1372804ea27b1fa37cadc391362e933774304e494ebc4bbcfde4018fa6952fe8a56607949e0ec275c99bfb94073780e5d02a422fcdc60259991f8ef6ab714e6d055cbd0575fa50b6ffb840673292fc5329660d3583f39f184e60f69292567faf5d2fa97b021efa497bbd605022efbad0b381acce6c85f25d6c0aaf726b95d3404fb72c6d84a412a29bf816d5f857ec37cab94c410b1efd3957140cd6f7cb931d71f920cfdbddeed314c447a78597d5abb34b0ff79648c631fe54e6e5ab75eb109d8252b38578d6ea57230ff3043048c064b014ea08f9b80f698c9b6397b7209a0840fdd5e7c952519ce1b712a65f2a1f7acfb37e4ec5d101cc1df9ff1420fe910fdf89432e34c456a54b40aab57894cbf75260d1cd2c4b6ee88c2e39bff6103c9752b9e87665f9832c21e5238c5fe4bc94b4e110c320530dc247e7684bf61ee7e957abb6aecc9bc407a42695427d88d37cb4af52e7414e5fe3ef4a6d7d5f5f7fea127a3f86021401237ec190501227ff5be23998529fe0d0e8c75bcd25b7bdd723b40ee0843611af2af402c21ef1873dc4929b9acd3246afed2ff9cac9e4a598af9467eba2950c446b91295bd97597960f95757746da76bd6562f5d02bfb4a21705da2071cdd27b01615eaa80bea37aa2974dd9e8398d8237608bd758a5e3bc10fce6755f6b79225d78bccc453a712afcdda0860418b20d12d72052047525a4dfc31d200d9e7a977699feefd899a0b595b21d54fca2087ec3ca91dffacc58878bd11a1452ccbe0a162a23be05ecf5b0cfb212a17fb50d2d53a0764d47bbe10f044d8446798043a0e9f27842b71d8ba7620c943598925e94fea08d51c5662c12edfac1426736791895322dd57307f44274d1a5e06783fbc28957d022bba3632479599815dc22f6d5e8904b4e8547e5ba6ad6c23af18f1db5d7f3d00db266482f2e84273d5168f5f6704594ee872e0ca4b260670c8d5a0b21cd617690d050334bcc06d518e8e2f6e7f8511303d109f7a1890e70cc0222b13f1d3bc415b38fe5c387b8929fca682a99eaef54cad6f80a0075949750df64d4830b0b6b223b5e7f8a20174fd5f30cf2de4a50ceb79cfe4762b48a50dce28f3206005f11099604dca5e28074db1df11f9bb7ddf11fd5f431039c20a5770b564b88f5e6ec4d07ed85b79af4da8345d0c90ac3326becb851233c7afd017787d2df71b56888af3f8ed15f736e48df4051c33f941d9223c3c6a4c3ffcc456269e2fbb0d67f2431986b03ee9961f656ef51609420910ee7a2368ef935139ed167f5648ea4a031e9a43e8f5b94ab4518400c84096b8048203fb6dbaa6fededfacd435662f5dc93f55989cad3acf4be9f8538f37c5a251da3a2ae2056f19b594d94e531979b65f2a894dca905520640ace4d15c515feefcc983a4d7af4559d8e6db03959f397f4458d358c7874930f469875ff9067454b44e30c17b4ae7f15c4f3d28cd30ed2a6b9589040c39b28c6070f199ba81c7d0796ac8462861b1d810a2e763c7be80ba534332c38ebb1ffafb3ff57c346389fb30f95c80a643f9f19be8c35e52cd84e77d231077567eabd75d906d3e6d0008896a6224334959fb827b3306ec35d9035cf34fa4a2356496d9946f710091a692f6dd84f77beb6d265de9edae824a1511a80c47267310bb924c8b1be3dc70513f2b0d5b5aea64f4364a6a49efb1d16d332c5e1d28f014002e2c68c6bc26e7d166d23eb9bec051568ecf4ca6cc7b65d58255416ef8483da098e1ff3dc8fb54d42fa40aefbd94d0811341e8926687fa8908bd9801be62bce99be819493b1b577a261f3258b1d3a6dc6b8fc4f3b9d6cccd70217a01108af57605ffc145f235205560fc93652f2fa20d01bcbb4ccba1536ce088a211af7a67c42409b22f28bc45b2e2ddb4b13670c348b481e9dffea2bc74ccbe61b97deb91a2e5107317a41664cfef6193bac68c35d0f2682d52dadd3f69473b538aef558d28694a19161301f3d758136a24443571b6af16fa0c3bfd74d3781a0ffec0ba46f72a83b8b1de2e65ebd0294a0c1bf778a45185fba7b3ad9a2b413d4d368d37e0cba12b47f0e18008c9c7918a6711f40df0c86f221390a18ad96caf95ec7984da9e329445b424f36f99a91c27d99d26f2fb735ad74970412676c44246a96dcb23bd3f85d67980dd405c650cb12a34305f4a140ab3a4ef107b82773d447021193bc2855d93e9e86f6359a5e9be259de9d012a98a328e6491a5fd8640e49f28e308933997fc6804e391fcecc603cbca421ba21851d189c046603a47d46d404df7ffc2f7b6c1af2b8ad0733f3048b70ea9937c659612090a99d3d26f2eb0658094b36f7bb7d543c742bda15a783b0a60417ff2e557a46208e8f119523e675a09dfba868ece052c1728f70fa2aa10372a7136a7dd561ed4304655c4cdd5b82a43414f1a36b113962ab82c45fb5bfd6c551937b4df8a4b1c7137b93dfa88d3101193f391ad3ad6bf95110ffdd67c9c296ccf7653dc3b6b21aa93b1eacbbea3d904b8b4e316ec6c3f4dbb9b589b3895e3f2e01b35b8b6604470d849955d6bbace63493bd11a1157320db0f7b176dbbd2d90af34901f2bdd736dec56c89540a2b9ddc3a8be00574e28a3bafed765acfc7324961f47976dd1c17d8d5f59832f2eac7abb18057c70b17b378b71feae93a83ac4b81079cdbef18562512a4075bd3c0537ee7f9a25c31c37996dba33dd1eb01261c8a1adc201f168c87248b952db70e0e6eff1f9c43ac8744a2c1e1239bfb33394fec7bea5dbdcf703f7215d960667c71cd7d7fcb51366578d8230046487b7a9bbed308ecc24baaf52d8aed6ffd4391b441f53016ebbace2635c1634f6457e36e54b1ddef138c811896d4b5875b92f36a03b795aa1021d66e93960ca24d0493dd8d3283e329e02386fa6416d45f220da450337de8887172229311ebec2a46c56cb9ba137abb6fc823798ea6b6f81c1c54e0d5d53732460e1d2c47565031a6732bcce789340cb5d316fadbdc4deeb378a6df87866f758e9edf27bd877733b9ce8ddf27c9c60621fed304bf32118e628703570e6d368e14d3191799b85e12a1d244dcd6e3acc9bc313850e42fd7ff7100b3995fd0394ad5716227d85bc042c81b3f9c58b2f80de51ee40c028fb807b303980e4c90fb161a6258cfecb7dbf298f53de06feef7618907cea9fb30b9532adeec8ca31d72ed7fa6ab7e134aa00f21f04c8822ff6560b8be831b2e7771841abed255bd09498d10df23c4cb49773f14803ccdcc2db766d3d1ffa5a05df014a7ec3740dbd68f0ae3607790dfc2818362bed173e9ef71b28add6de19310f36f5d50f4d4248c5bdf5380dbb82328b9048f0bf74f0d85e5d7ea72eef5ded3d2378b4423d2e15ccb8019f6c15818d8212df8a08e55020ceb942689088aa91d266671c4736f6a5ecf11e46e5c285fccdc51c36a9d1ddf1a486168475ee7fcae0b4c820e231c7d2e6835a0027f57ba6dae2c73e685b5caac66fcb25276db628bd3074965c4125c01ea4860db603ccb2ef8964419522908561ed6de9646a6d5e2583f6be2b892e238acd1135a1ba4398b3e138d8e6e0cca9a9fd8a30405e45fe4f948c4cbaa2c3aaed265b1e244ce4165b2051a93892d6a86d2746b602c0f2d037f8de1f4bbe5101262b0e32963d80b4430cf81e890720f6057f3bfd22a8668d38a41906ec135601fe154c5f5fa48d88c6b87d39d0e93c35509ef74e812bb665b57e87599f7bda4e636edd7a8e5bd3d41512abeb93993800b608c61ce4eb9ea1d16533fb464533acc4210fc441ee66427d9c73bcb2d252a198a8c7d5cceaa0e98a479fe414bee57488464b95cd69eff958a9e3a1172e9f6120dc3cc9394da3d2d804d8687ceab112cbd3b96654ce392b20e4e78ac8ca6042cc9dfe4e50b5235de7e0ad86322fb8025519d80805023e2e8637687f0dc6d515a0236ee20c7f452ba6725822cc8c9c574ae220a7dc364d620dc204b504aece1bdf7916882e5c98a1c3ad76f496c817e201a21775a9582cc977a3348cbd10947e58baa5b6c82076bca101d1f924411e88c3e871046a5b0c2ebcd7ccb0014f0f2f0c4c633067a021643d22c56066d23786e54d93002457676e39726a58e641c448e2153cd2875741d6c5b71072c8bd5da068c9125ac52fc2ee5260c619ff16fb03dded8ce1be00eddc934b91aace8697d96ef6309efe6974042708311aca08dc215dcd897ea8de0ad7cb177b32147b0c1f7d5b33d58702ef788d2a78e018cfd2383ff267b99a550925e2af94c54a320c26b39791ea8a68fa423697d55fa533f6e5fdf1713cee4edff9a78b3766bfee034c2e964655520727270cd2e64c3917c18ff35776871a115d436e41b58da38b898bcc7fd4ff1bc5f8e218a9c8351ba07075ae8407d74277cfcfdd61bcb79273b5fb69a8c1966c67b1c098abba067e7e367e972234b9df5aebc921bca0891605a28dd332daa736dbf03e7b58afa3a34224568ee2b75c6847f024ff5525472ed937cbef1bc3117f86f69ea792a3e698159526fd3ec3e60b3c905d55f3b8608be6eda2811bc3c8c9d3e79863f9b2f7f54a4def39dcbe9d5bd74f723c609ae58cdcd2955116dd585293529902709eb0bf87f4505ae1f1f6465a8d044fb6cc927afd54fc344f8d7913b42bcb801ce738e2f64bd86b91febbdf049e7b024ff18251bf8414ff7378652292c3fb30d216a38c10bacdd180f27cf03345c62b7d9d8c461170871e4ca9294fd60e26dce6aef257db64b72088f0d41a98a96d9a5768a05b04754349173d0acd53902bdbeb15afc596257f69d1d04b8fe66c9d74e224768896da978d28811c32910802eb86e8f4c03c6cee355192c68dd7588eae84632c50f861a2f02d727078499f99a1d57fa81d3fa66d2ebfad750e91840a3615b1cf75d1dcbef5181ea6890430f29f23fc4a5a244ee766b37bf50c071136ca6604d8e351138e0259e7069d16d240a79be40e9a77f8be5145ce3ca792aae287662d13cb5a0705096f23245cbec7a2f3fca60830b31735ef9acdf31290398a646fd1493cc7ad270abc5afd1ef1be8f7217a598ed4216b4fe091dfcf31f22b9f6a134b6cb9ee4334802558d175cd7f89b5bbe9833edb0cf1df2371b20cecf1de6bac958e5c71234f928b7b2f30b6173d276cdf5690af567a70ab0e98fc59b49aaaec00d5f045d840e50bbf3355e8a0109af35b98d397c7e1479b60b1272c43e89e37928bf7a5d2a403cc575ce4af19aebca612b47b35c0479d0c4ee6f0bed26fdf1053ec48cff5d418cfec879d8fdd11d590ee37b997a278d59ae275107748367b033f58c1a745a47c2f5a2c8a03b045b9d0c46ff79d96c1fcc5f67ef0f66ac8a397078ae04b8286feb4dd62a84b14d21c12dd5126080c3cafb1326f9493b672bd793e441298d780a4d573a7c2ad61013637070e25c6681bac8ef17103291962b18fc7fd06398e77153c2abea70ce820bd3d16966b223da9a6534173ef28f25ffaff93e945067ea9dbf168be6c1a9414a3121674cb4b7a9fd53b004c193033101a3b2a2b29845f2e5a58f09ef73fb76ca379cce502aa014bcb2faa6f360f46d35ee04e2053941e8d94600d45426aa41b50355212cef02c6a8929e3445e8b7f93a7257aee964533fb7bcdc4b7d60c0b489bd2b7b1ccdc1b25a42cad866578f162abfad1df73baffb5de3afca32bfb0c234e32c621afba0ec8e5191b72ba9f2474926a1196aca349df8c93d85d3f0a2302d4e3ddea4735db1abe5514231789981d030cb378f908ef5570832e8cb060f507dd4afe8c9e656886f817321b4a8a31ed27c6a0c59d0428f65d9cc334014138335b275797f1d70316a52a8a1abb6f29f76ff9da8028f4006eed2cd0958721d3703cb85fd1aefc1bd49dcf0f61ff4ee915313ae43ef4d0dbe8641c8abb7af1a4062d37d4b104cb50cc3a30b515783e95014b3c3889ec9b101e5ddee8496a788aef4a40fcee4e3a616aac6d4d6022cd9e163a8554aa3e8fddb48b0098d7490eb9bc3bd7ca5f98a88889be022ecf6b3668d9dd5198de2858b7252dce82b150c754b2ad92f613c9f3da5a1e5951fd9633f089e6d99fb34805521a15fa0f4356a33abcba76d4a727d9c4d0a2120af5bffe05a24266274754ddca6aeef06c0e3c71ce3fca436f247e1465d8c23a71f343300bb1b9a71b7b2efa62bbb548a65ea2083ae86fb00cc98a6ce5b88e1dee9725be18fe787562be08369ba23397ba3cd299f81e514fb05c4f1e2b16b007ed9f942b6706ba0b0f10072d2eddd201b2568a63536c678ee22344d0063801151c99316de1d87a6814679bf908a9f55d51a6bfa646e13702707841f0758f11481b9212966df87535bc20fef04219e73f865965f29bfc6e58d213a6efda69b9789f10c3c258dcc461d84d423122ff332f70b98e28cdade8ae3fcd7f14daee03b508259a3dea641bada8db22ff20348a5eab0a5525090ffb72f03645f3ca499b50277e73ddd69ec424f254b6a681be30e2e544a901f1cd83ab5ecf9afd9019171faf1e8cfa68a85f83b9d287c61e6a23930f1c2b2e3014a9b4d5c31ecdd802c2ec6d36efade07c9a961b5f683c36e528b5257f80d05d2719c0ec490aba7f628c36faaf84c7805723c7a798fc292fa0dc8df102074d0b1ba660b7329948084fe383d6fba3c7f222b8a6c3b18bc84ecd59f25340f271b5ff98f68143dcdbdf3a02a3d3ea628d61a3d95563671ba0c8cba9c97e9f02d437b406d5885cb998047eeb888714631e30d61b8a9d09a05839cf41fbbff9a9d60ef36ceaf8fcedf189a5caeeefa8d2206e2917384fbb6faa392218c3b0bfa42217967b5ac981abd5e6bd34d0b1e50dd880f137c622f33d3bb0008405278e71439652a793d850c05dfa155000739277948dd979c07634c4bc365e2226b6fd12843dcde62aa9ba585cfbc6dab8880c6c776719dd82ad58153d7df2b0ed62b21344cb46e34c833182c98938956d8030f49ca46b0d73e8f5c211dd1684ecdfc796daf5bc81a7db26fa32c4ce98fc0f240ef7ebb5111e103eb679ad87fd44a21c6140b947592610d3efbf87c0cb6139de7232567bfe4768a2c4341fbe03bf8aee578e5ce5ae239f8fc24afeea91eb52df6d3eaa10958f5ce1c3fa1942207fdebb194f4e2a2bf1f6dcc720ca0d83675c1281e59d8ab3f1d307aee04d181461eb4eeeac29ebaf3f24128a439983551a801bdfb0a168e34a7fccac56423eee8594fdded80a281a6c28b11dd27414d36ee43d48b9c9ddbc71a81dbd8fa116beefbb0a2b39363bc5879c489b360b5af9e4109e90bdbf742f92a656da175439535a439330475cfc3976d77c961f0289ba48bc27c2b2c3550565ed45079c746172b4df4d402391ffca1effd92e725a7be8e90b3da031f3d1af062d5019b9500bf274523aad9c95bf7f8f05f358d5b1b05e6027d30895a092b702cd96b25ffd5615520f787fffb1556ec28a6f9fa021078b9f31ab6822da01a1121925e68fb58d425985070b4c12d5aefdce0ffb936c25fa9be6a6a61a2d0406d8aa6ec63aa8feaa4253a35f054de54ffbb33e1331e7393efa3c56cc8562ba3c11fd74cee039719c6598062a74e3227613c0c57db1163ffe23b397c6dcefbff3385323b19450d1b2398b618c8629353efd102cbfb3f03ddf2acf12d5612ce7c2e1510336baa1c345bc17e840c94b1d1074890c925b3e5051a4901fa3bd50bdf081d05621e091ec2013f456d729a94d225484fd899ca3a9a5c84d74104b34fb5b7de13de8382abcecfa284b8eae5e9af11a656d5a796112dd7e189946dc1a97c1f93933082a91ebef3b9e66663dd9043a9b0710636c768ba9231a59f372beea3af04319237ecc76b4d369d49a40b2affdd740f3a922663222e7d1ef8fe92c9eb10be27a1399113be762bf308324640ff6fe4ca2f094dbeeee21177b54d3fc573fb1b6d025102ff7af5c7d2813496f1e166a6fe8044f43a2b936b445ff55c43f72d1dbc5a300e2d2b672925cf3054f206919a6c77003fe8c094682f716ef3c405943ba46a0eb0c8626ae21b4c5ef01e5f5b47f0430a177b1d16befa1d1f2485d42b55689166c172db206f2e3b7be39e27c6f1512589a9b7fb07259a8fbed21057cbed91719730b99c2eb61a802ea05b76532ede3e4424ff90f1e4314fe08d6d8f24bb631305a71e745d0389ed32eb409c66877342b94371cdacdf383816e91e45f44a955c3db4cdfc0008d1f0e5c17bb16a1dd64fc1fbe4146eb967b5c5f031c8ef31ed4416e7b96f26ab92b4f270a65cee9858ab972d9039b54cd0e91231497b5af78500e1108ad687098b3cb7e590fc22c1750ce4ddec494e5f692d04582e7e9e2aa94d8884f4b540798bdc4fc409653ef79b549158bb010ca365c73be6bdd0db79097067a06614bfde1c3d5c1f200178557de4a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
