<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3f03635820f04e7c9b78cf29e31b125d79b9f746fc31525306b3c8f43bbc37295965f347289a6d5c16c1d78881ccdf2e15ea319501a0feb9ac829ea4c4264c2eaac93b2c689a5caf9f0336a8bcf113398e9e01e30b91eb09c7f770bf301ec41cf3be4d74c8f777c5dd7ac0e18598b7393ba270c20f03be4ad8c0c9c6d9233c3434dd4f29f4602f2a82a052c78ce85155dbdd94fc3619478a1d244c1a8e0716bddcb0c32ca55d7c6f3b59e8ed2de3a5fccbadcc2b014d6e5703d2fba0c6eb81224e5a2ea43f0a171e31bf02d1ab42296807f3f35cfbde7623bf883c7e7a79f265c5a4c5328fd8034f87db0ddde2042c99d901eff9632f0004e4772f088e70d66445d9f8f2486027b87ad39e659989aee0fca4438c767e88771fe0fd90f1cb1d6197333c6ea2ba3680ff2efd2270367fc0ec93baff9fa2c1f098b6c98a4b3e574ba72a8cda36782aa54a91dddc176131106b6b8f2ebe96f44594f685063318d909c3e181d69f9164d8fff6f6db2f55d3c4444015763c746f75fa7253d7cfaa9434032c4f703b0291729a62a95dea28bb7bef6d04a49e1fbe75bb600adf50511d527f6158802d497a2c14d3aab2c66a85f12f519d402312033eb83597a0a774fb1d5ff85d37ffc8db6b6dc0cc92d6e3d4927f4e8149aaa04bb1c9419689e1018adbe4b05f51fc01b05fe783836b729e3038a2a33494499982f918e6db51031c350a41a759f10ed16b0e0669dd4c52632310c6e1bca4c6d8664923f38ad12ab77b9f1e35c9616f0e179a74c4e370e37e25e7470abf0309683dc5f2b97bb4d894001ab3adecc634d25679f09bde7cc8b1f84e13c28b42abab81c14a6f19bf16a01430fcb38494d45af5da3ac3a3f59b7812f4e86960ae41916855ea7c6631c776909adbe6445c5738f21a46273e610adfc2b26a5979af80cc577a27f8a922c087009df1249bb93bc01d8905a5426ddc5535376c455c500d2a647001c790265889d2752459992413fbec6489e1bc29b43f35d523cfb47aa7a8e48291f5310ffd5a58e5cfe790fcfac05cc5fa0cb62e299722960c81276184e0b87a3d0c89a990469c019528710ec263a1dfcbe39ce59936e254c3d94ebb15727b6b7fc64cb9b4370b4cb93062efaa4fcb800e9ec31b4de4e72d6e1be069e5161c1e74d82bf0917f0ef3517c212d8d775fabd1211001759e09dd8ebc3df77c20db175d8ad2b449d3ccaf32ce2927ec8de4d98a21bf615c833c4f694b178ef1d751f1e087412b9ea8fa4bf816bec3928bd1783ec05678c92f9eb257e52933e7b4594ee87fd7a797e4d289e1ce4a2ad4a8906f484a71f29facd8ed9f36a509cc5ade932940d3f7df4f824ac603b7346eff190b3f87c7d8f6d0b08d4561dece618c7b1d09f275c2bbb2ad271e1f2471138c9efe59b4e8fb7c0f57fe36aec14b660f9c8598734eb2a27e1e0540364f51218ab8132ab1233a271091e51c8f25fe2327fed114226171e42ae2768b3a0cb5fb13bac19e08753b545e549e7747028d3d4dd3d88412774d66be667210099f9686a1997fba49424ff4dd432c4d48338f34270ee9995069db4ab9f1ac88c672ce9fe76093e475c339822ceca472da24fb4beaecefcf4a4f1dc823043d80ab53aaf928656907c97cf92a6319b0135d972eafe2542c43e621da824a8e49c12a076999fa6ab419e156c3db19fa4fe8771229f1de1f01037afa35725dadc4d2ca0622bd82d7783e7ebf75d8d7cec25848cd803ab9389eb9f58453feba830f655285558d655f8579e573b11948a61eb7702b4d5640ce8ec084a914e9888fa28713da5c57dd72fd25db0e1eb7a85b860101baa7cb1de9c2201a82cc8e60a9fd8a7c3a128e5127e6a4ffda9e12bfd480415f4e184bd1827d00bc2ae3ad07b8ea7cd833dd7e17e2eee316761ce6f0ffcb13447ad72d31180a40799615265d760fee294238cd8d68c6f5c12d8ddc7925bbfa93b2e837f57c89024d7e426e89b387b9fd9481752f012df157ca7f12c3b959546b8a348f70e712dd217fdb72d1112e23620391f072ff58e1b3ae34b4ea9b71863d10cf0f75ef7826be09ddfe54e47d7aa5119a6bc44a735b8889530c9182422036be7cf65c61e88e4a6a437e8b902ee6c0c1f4225fb40712dd430ba6c2bfb29e99b649b92516aecf9e94e6f5fd72976955c9abd8d1f785bd80e0e9d471050a4ad0d9ed00b0a81317d4eba1a4e37a1a99f664ee0c35e52825a514b41eab34bfb326d6776b3c87b2f643e654eef4822ef5150d6716c9ace2b14cec268ce0696e1d6681013245a08ca649641378fbbee620067d4dd697a22348a3cd09f566842a001088f0cedb34f81ac67a4cf713fa00b09bd1a7915b514768690261108778a430d2f3be0849858cd39cbcb83f77b7c8e937501c761286997a702a5b6c609e8003c6321f661588d49f24897230761ea9ae41513824bb1e67f07cf498b74e50e7f5370d3636878d8998d6e1060bee45cc4b27ddfc74274a5ce39bc5e7c21c122e615112adaacaae9730caa9365a30a975d2d42aab84fa9b1ee259034ba5c9864927b7a5083658039b7c2ada6c56be2ee70cac2945a7d0419e623116e55b52020e57fa3b810f3d22743b7738e6e9f14b0c61925b0278e747afe7ab2d6b379c24feb6a4ef420e4fd57e17674b51d2c90670cf357c0faf1227617f31a011b7db8681802d034e60199882d25993406a7a5ea36801f91ab8e2a0fe22be21bb91c2b5fceb2088252e97f62784147c707acad1818515a998da98b6b4924cc69b38febc6d41fbf85474b87092323d32f470b86f62193026d614fe02f7ebd5c86adf89e47ed2aea17ebb7862fe9c79a587e27ade24928e9d3771fc3ff4093fe6e18307fb25350dac1cb53279ab99cda2f5b64310da38635b8d1b047d9d6259fcd3716854953059e65223be2ed29179d31cc37f9d47c6a29d77548089d0592913bde759c69f0e4f1e841037db104604676c79b9944630d3c4ebd41b7d99e59577def28ccc64b4d3374248008402a85233e71f3c3855b465cffb18ca6acc10a5e94efc122f2ae861d7cc55c9ba349626902e57c6a98ce6f082e3fb04d2833c9b9b508942f6a20154fe3688b0a7d2173018d570f8c5bf74100cde057ed4c9816bf9be4483f68e761ec43df12748513bc9529793152f1f759db1d8ee5b387abe495cb00f9d27b7b7f1b5f8b007fd43cb147146be9e21202b5d9c843509c86aafbafa270052da5a834babf81f6eba9dc05892dd3db6a654c047f70f5343b2b779af2b34f71ff78cefd17ab8434022b3c6e16a81b27500e33ac810a258a9764545322ec5e9b8e5650e8cdec68935ca4d01c1f2d9b4426371b4bfe709e8a4991e734212f17da97074180f4463654ed3f48dff6b253b6bd24667aa597408c986ee7d6c44acb10a794305c97bf747eab74a3c199894198d656044128d1ca69a8b1beca9e612cf4a02720a9a39549e32e78c4fc979b77e40f0a8ba168012965d37b34485f2eb99fb2613d19d51a7a57e4b9724a59658e7c3ff6c61c0d711c0693ba4688dff3b8d236cce933e3531652be251b511fa1c9002db779cf4d073ec9bf5d3f3f0e94526c24b4c37498a20b8cb3f46543ea93fb1eee821a370537fada4b9856afce9ee0e132e79aeb6d03ca6de8ee7fc3539bc54839c400c0a423af121d5f0d96e441acd148ba23781e6e39529a85c8c65e87e3e704bea427156af903fe3304b388579f0e7bb04f49791db3a76f0e85ec320f78db96c320a23ef490acfd4e2951420c735feff53fb2ddb25d68c9b898ec629ef162aa05da2a3a2d742f1462fd453d54006b263d276ef75fedccbfcf1f9d0eec2f7c73a00cce75032d244309c75fc3bbd3fc512fc3e248f6a8375894c0d5494d3c3c11f23b1ea83dde629871ec61bd8b554b8581d6e943ac7e2a6f4cac45a108cbfb9092c74e3448018ef23c26fc45776844a07c13557833445609cb8960ba17f8a008169e383d43a1185bb77c41138c116a983223c34771daf293b3ebf5dde57355048373a4999983e9c8ec1fedf403a445ee3897547ce7107f168f80826a3fb530dc48a247debaea0b1e3e940616ad56ea2cf97ca4742739cfd22e1eb008ed74864e6a863f4659f090fe2d92833f8884c4669e666d4e470cf79a69011f139e889575d705e942041734562ecff6d2253d2a5492ef55b0aba9ae5b2cdff40b20cd8174f13c5a1ad6d32bd6db58e3d22832e680d0ab1d67ec9276dfe614f43f997a9723cf4269de017a4d4e65150877201452ffb493d9a9bc38f496da34da9c07e16e5a5914d6b7efdea5371589cb57dda421ec944386ff06c81e1303236224946ce31d0c51876c2c30abda97c633f302b09c7743cbd643f98331a689c8b81353e2583eb8cdda338a9bd2eec28b64c578a3447b7e1f2982ecfe8c3fe56d6bb8497902d8509fa4a558beaa1986b298d9c1009c028158799a8432ba3504dd38a459e6ac44603ea2cfc6cf8d6c51aaf002e60c856bc16e9a5cb4793dd0463ec9ed499d52545c8790e8632886a968f972a9e56befdd163e3789afa00f26ad9ad4cfeca24fb97bce8d5479a4fecb2617ec2531ddded7bf9a733b60d2049b657cda676eb4c6c81c0ca5b36ead102819529bc012dc83bd5017122849ce88800023390ed900b369e5e855b7a71163e1f2da2a11f70e8243968b6ca69c9aaf561790a0c2d7a9ff68e8e0ec68b9c29a2fb953621d68555f441c09baa05a8e45c2c0b64b6b57e75ae491123150fc29d74da5e21552722f21378a6966867c10da9c957231ba0f58eae75c020e4853330e312e988cef79a3a577c96d60bc8588a09f2ca434b8a88500c288bc21f21cac9bda7f3be549ffc0c11bf68a15a0205c52af251ba8aecb072dbff4be74ca745d4f4f8265f7f0ea65a3627d295bff835b8c156797a36f85235e6a9d9f1ffa55bc3a1850b3782bc7b41e9ba65f5c9407e0ba7070cf428fed98970b52728dfe92a9aada1c04c611f937f2bd38ae0b01820483551e7f408bb4e45f646ef7febfbdf0ee1d41f2d8339d157b73d6ccafc1439ce2e915ae65f2fd85d7ce5df1f0d39a8a60f3962b60b72c971bbfd927891354546c8b4671f7110f3178726dcd3b7ba438c14d9be8ae3d49f9e01b4c6445a32a3b59ff157f46363b1e30f3597d7c8ed0a55ce77270ebc80fe0a44ec99629a4a7c6cc91b46537c21c845865f95c7f30fb4772be299894b6025c599e7c79998e7cca92c6da41d2899bf476db40dbdfa2cf2d391468ce4815aa989bcb7713afad57bda783c90262cabd94bdefa24176d41ee926041c703b1bba9d3b5647233178c75cec9f8f795796ed62a4bc51e3c83b518fafa2e425983ad58a60756df8df2418fe5491337052426183a1746b7a0a0b001324502f4f4a671177d391da3d8c742e1068b4d3243cc3c1e5417a6a0f45cdc84e2bf5ce61442db19b9cb39c3d3450259bb3654fa93f39804f9dc90977162a11f05a71a65a41ef8be072424c360b0051758bef14e543be16e6fa69a3c8e2a653628376e4350c9c898ae6b3f6a4c9a88b924d754450aa18b647d960783dc21aa710eead29ca7f8c60b1d320c76e15e2ab18b069b6152bf5afa9e8addcd9e16abd82817bcbd7ecbe6eff80ba29f8d9838079e5e71d02c56d2b305f4a6f5e2d8a43abcd343b025c989d6197e2b809585ab4aa8fae91609fd482704bbdc16e147a02c5ea6ede841b8fd037d753ae1fff4cec01d35ea9aeeedb17d09ce957fbab65fcc01ece2f43bb8820a6150f101ebafd6ca43786abf6c1561759ffd038988518dbaddfb7bbdb4dca19ab5af4ec00c922ac8f699c7fe7d1e623e41e563ba2874d3651a0b5fd431679e613979ebca8b7c739d3cb21ebefef2377d62d7f2146979e72f3d1965b1c3145e68cc937d2699534993ccd27bd25c483972142a957c2af1a7b841e4b11414ece2c2923ea8a9a07e8d200c72e56bead5a032592e42231df371346aa175d9a34b8e969cc4c05302e1c5b555c9a10c1e1e5ebca6ba1c8b1194102beaaa7c0088316a802c66fc6f3cf61eb03538638190b7b557b49f1fcfc4f6242d7ba95a3f32e025ce3351924a1ad7ccdf7dd18b59687e6fa59f0eb6b211fc3fb3f5d45426ce8a41f7e2b90858bbf20e86d2e2610f17fe1a42c8ba511ff93824353e451a72a3e996def0472d228aa34a375702496e51b19b87deac408acb6baa5bc2dc80b98b93ed8f83cdb04e7ec4b375f85594cb6a28cb694d644446600f927fce55cb15ca2b7557e2a333ced767b738a2d3e4bd46bf9e53005ec0963077ddaece80539f81bcab11d5df093a0cb0917c85ad847021e64755570b858319cec4f46bde0a0068163af79240483a55bc585ad5655fedc3e89b2a18f8330948593bd6528d609dd54e5c588e39045ce36438f31124853c1969f57912da709b7b94dba4938d65208e0fe7378b8abdb6fc8404c8c6d678d96155bc2a72a5eedbfe295b5ce5ee5165cfae030d28a5683329cb31bd8615700f0d332b285616bf08e59e077d908ae170f5d0b114230879bb1b25717e70c511c0d5725c0d95e041a18785de16658ce0dc974444262520dc9a1e09183a821137bfd5a40a3b20caa277019ed3b660a61d9e3cf813a3bf47448708e7848fe573927f8f0c3663b657548aa138e3038b5157f200095f1b0f3f74d3856907db11e16e492e076a60357a26461e4737d4c857152e756167dfdd8748ecf39c41d59c1d46212a4abf8886a1bdf3aced577483f0ab370c8c3e190f4c0eb5eaab75810d2f357ae0ea0a0c173a208c1703122c98bd077807c54ab1eac849f2a082be21862404bafaf79e07eeba492e7a705267ce708b045c6225ae9de35fee4a343a91b149a2a925bf6c8bdfba23534b6a1b611dab44931466445ca1a944f1776caea5e2fd26de1fce86a89ee4b9b56d62a4ff802cdab7bb6315d9395f1942464deaf9fb2ab5431ca6929d7557f71183d25fda8738f90d72942aa8df251103acd14f4f41a78195db8bb2e1b9562cc80aabbbdb6dbb5d34a756b81bb325720a5b2d42412a585f70ab1c36300746a0157a420137d6a83597b8d19afb690bf094d6b5f914e067269d78943c707cc0167886f3a236a2f19491494f95929e0d70605ee57bd47561b35ee7c61a50e7c6020de72c0e326da452692424476bb16c3d7ef0efe1d1de13ba6f7ad1682e8fe1a66cc65e406519c5e7265418322ba3ac2962fa49511fc59ac6dbb2f00179d1ddb5335127a3e4a12c4979f6d952baf04eb92cbd847af15044c179c87a439006f5683d8208da7803d22889604688ca0c248d554882f64d5631810fdd91c294a708f083b3f779f25a5e7a01a6a381744597abb3fc2b1bafc1f0db076ba3f13fecffca666a3669cb74d6b6f0000130e351b255a842c81305f8386566487ad5cf1c21fcbd0c721753550924e8adfeb9ffb60c05389ea51e4e89e7068c47aa42a54270b6d4208292e27186548e6a6d96aec822795d0eceb143cf62c628cc7227c0ce0237c303c760b9e4b077777c76e7f4eb055d58fc727bb7f516ab5554e51757b62a72a855db1476771fa6e7c19f69fa7ad37d38bf437eb79fff9dd6b4ffb46eb2fa19ce4b1764d81db6e63a447bd08f59326c9216d6300ddfc4ab37cdcfeea7c07bd5d475d6ad97e2d27e8e5eccec2b110e6e3b4d470ca68b59e750e8793d6f2b74e2c577f9287887b378e8d74ee33c91ba64983046b47210f1e8bbe745909b22afea4d7c9519b24ac334a129f9b6f4694e29d54d05a7de6dd92f40dee70865eb66a8fee8dc51b2c0ba3686b21002a3e338ce08d8df768c2590bfcf72bcd785cc30a47a4ec094bae2b3ffc4412ec62cac4dd93990c2d364c15e7189bddcd7e0a10d26479e73357179ec5eeeaf2c88a90b3efe80cdf4390932899df76835140ae3a91e16d59a37d086c56b21b82af0a37a1b07ef511a5a16bd7fc71a8a0f6b5e2e0fe27ac1c923c23ad589cf4c6dc6470565d118cf363bc0d9336fcca5d96a7afa327da67b47efee8b5149b1b8942e03b0b1811b1c955b2312ea4b5e2d394cb6ad6e60f03deb3477768111102307b2d931c025fddcb1ba73dd7943c3d99586413f5e94686f88381e428909c4cd3cd1bd117ed877b5f6d640f13b9ee929553c531f35944dddd2fe6fe010bed82bd3f6a5aff15244af1096828665fa6f6d5ff2b1f192a96db9ae117c5275b5ce6480651a3a6ccedf240f7ab61e5df3cd1f23197ed1879c4858fe0471ec8e1c8216692a9aad6e22882f5e29c456cb1e967e80e8383fedac3a8b40827b04643cd4b067294ca73bf9da6279145cefe2d16d28e50d1c3e4b6fe23f3a519bfbf9e5dc89adcc29b9136e07223661a61f6243ebe7caf246a950e99810800a6ca70205dedad3cf038b016bbe9e40d246b21c906acd965adbb40361dcb9985b748b86a6da64c6c7863f86ba62540a74a1811d18a38ab886965dd750069b0ab7ceab442c7453b1b388fc19db2ce13eb4361e0ae8aff369f10bc73d1e8e11f11e3eeae67463d56f19c36fa5307f7e458fca3190cffafa8c674fa5081de9e06d0ba17d0a833ecadac1e479102816b7cbe01ba0a876a5475adedfea130bf88c13040ae37ec5de9a64cf3b9472402b2479b12554e623c9b9e0c61deb6840ed1adb0b4882b3f5e1b29e135926668a9484f02bb429359886b2ac51fb2e53a09817219063093e7795c95380e6112e3b3f3a96168b4d952d40511ed180dd87eb9d51df3021c7ef018c47355d56b218771256336ef5038aa4bd3c32e97c0b44bbd70aa5cd8a47375cc367556e446356e390ef69ac4d4eb27736fffcca66869ce58283a4be57f50e29cb72e8b4ad85830ca6f881ccc9886a7bb1e341e847beea97a90bd9939cae83bd25628fa3197153028292daa59ab136e0a86f5273e5e59b2fdf26f92147cb8662def219ed70a8b3eb933face840d79707c6d7065b4ec8a85a11ea8dd4780525796125e7234f6363a31d5c72f6f1614a8e0af4bebac7dd3d94821fae39691def357857e919a4cddf5a1c5b5c253504e8b0d2e565a8cf94cb45a17e985024234c7cd9844f820618e8cf5f4d5d2dab47da986a497ed67294ce3abf2393ccfa66f10101ebdb0bbe3129511a522ed1a55754ec20fe358c3a1fb3a54f89927140a99a3a7379dc1984d0741b5091b9ef558841ab88e1be1b74f5132b166706e987661c0537e5a8feb361325deb6e61696c0299272e26990fe857c6fcb2e1c351e30828d5ba1d09d4a1372fbce6c29eb380a47393f215a69bab24ffda66720d9d2d58d1c54aaee70d8b234a8bc91d26c9ec8d906cadc4936917bea72a3d1a9922fd127c1544024ade39a0b357f799ce1fbf4eeac5fe2ed42a4961e7cd31859d3ed7c6ff5171800409fcaa9cceffdfacd6498e15887839b3f5c35b2e35720df5fb31821a880d7e40d5c56fd4048cf93180a0ae8ecf4d9955630d9525c7047c7e0ab69cdb83c0fa8a922d96430546ab6f1f4ecac51aee1220e2a066a91e220c8edd41732834f89c0686035d2cfacaa3b73d3b8b459e07df7975020e68134b270f4a9e651bf6fa1e222bf96e329dbed839b53c105c83e3308250c93f8964685fa81b3656352377ba8383ce1999cec65da15030bf418cdcf0a31d826024cd713e8a98c321dde4227bd363def9e223f54fd8e8ddb2583ded21336e13e5bd57e1f3412624001aa75271d7dfa92f41ca1ba73645945cf0bdf104db01b7b6c90b21c6aa09bd2aa0a6ad68a4f09817a3f60e584e242a0fdf92c291284dfebe13a07b153585a0a5436fc73ec59531ee733059234ae852cfca7f2fffaa7e88d3ec2f2d8f8a8a7998e1a0c0a78efa1602b12662e31ded17ccba9840c77d776956bb3871985285d724bfaa55f12c0f8c691ccc56d01df25deab317c3b2c05c908bcdfe0c702a29bdad453b74b0e6ca6bd97c62692c04051f1bede37bde3185c263bd6a8dd424b6732ffcd7082579e9223dba709dd8220cd210efe2502d4c4e45adc9890405524639754772e0429ccca4f4e3233c4926d890b04dd889e9582096a55f7a781cfc64a5b177f7712670066955c0d466d00755b230cc13b7ecfca65e0fa911ed944d93aabf77be6bcb0e8b37b5fdb81329d0d29b1cc799d8828272815842a2405de3b4d890aad11837e20843d32d33f48f68406925f66d7b2afc007e80fcec7aefb01c0932dd88987a8b383577d79920096689ed01f3ef779686978be6e12c09b117c1ade3a808e0dcb3cf5b485b2858e85a0ab63e48ccbb720523c57d7b1208a233fa3b87dda8fc579ff4008256baa9e1155fabd2e7d20482e69981bb94a7574d18e209110041f4019dd44957d52650eb3cae82ebbf1a0182e8a1f85bc9621488b4e2e546055d4b3ba5b106601fe00c7edaf29f53bd0ee16385501bf42375fcc148b8fedae9f801e3e26dd360cfd03f1bb209e4029d8264c4aab31d92e3df3b270e6641644c1b22e20c8b696ed522e979d0efdbcac21dffdd2580ff5e695f3a37b2f136525535ae326d64eb15012ed2f2a3b3d85509a046765d9d7c4075a2de72f464439a1e553f0fd85cba0d67e320d9d445417649493edfe7ac972edd34c0d6d88b7c07f63c069cf5e05b565e69f61360c5f92906cabc1be71abf3bf0f22814686f62415bf83ee32d833738e90d64ad7fb4265a5b935467f7b1ef56df66f840174fa82f1fbdc022cb1e1e9871b34ebdc182349ba23685697fec4db5c0696e3bc34befd1e5ab6551f98692e386ceeca3e699229cf42dac99b1099a8ba30fe9139fe1a4a5f1dfc32488204162e7f0db0f818b7d5fd45510b55cd00c1569adbe51cea590dd9aed04460b836e842cae4933dcdf17cdcc75d899c22abf45e1b5f7a1d956c997a92699510937ff86fd29dd701e797579576c85a0e640f25296b85992d91682df701713b2bb051ee27614ca3da8a65d2270f7284557aa5167ad4d13d51bc580a80f622d6ca755e267c95f429dcb1cc650d2d0a55a2e7bfe4b194bf8d1934a049b8f84acc24ac1543ba932a691e7b5999de769b6ef7a9036d6543802564a4d700ceec4729a7c275368d96b352f6e856efd588a38d22256b88777db201a4adc92964ba71fdd65ffbf573be31f150ac7048d28f8de47b5d4455bc1d6dfa99ae4abdc1cb9c5bdb84af7db3c36957f7d4a10c34b861b6a011f7c82a7a7fad09f13182d69ab369d68393b7d7a3b2b13723b7874e38c0dd7dae06c81742f42bdf7e8e6dd97f2223184a98d8ef5167187c34e71a897d9e4d9b656c8d16f158edcb4fe2f3c4a681b3d5d161991974c9924ec736d9f3a04988debdf0ae9dca905a63fd4a3cdd03604372a2f60fe7d6b860fb9d5fd8d7631d1647b832df3868c200895d50f101c062b2a8044c2f8ea1448f23f9ab3d3247e2d75f470634f78dc970a6502c108f444ac4112c0cf42f426663172d15d944ef6f3d62d6b2a00c92bfc458f5371e29cd6a8bd5852b7571f1b8b51063d0c46e81c58a0cb4f221faf36561043cf5ac0733498465d178569c18238b7390f502c6d7e4f9a432be25d9e821dcbcbcd70707ddb0f599950a43ccfe325a5e8bc21d424766a15df01abdcb994acb504edb98686791f85302cf0e66875f85bdbbece1617121c009a00b16e8f47fa7927555b9a9f76932c0698fd4583784a9164991ffc846629b42ee5e613ebeb78ced5553b8afbf9be8b2952ada74260f5a3624fbb719fbd9c49e69b32e8b657ef231a29772ed65e060df1c46c3a3e8d691e125674a6abfb236f43a3465b21f8627ce5d7a43b38891345b289d0d3ccde8350d2190a7909dacd7823fe63c9100d901c9fe810bf134e03328393f27ed260db74885a63538f9f5729fc3eae38fd3844cabc5a9020b4870a0932bb8bc5368f88f358b387e547dbf5fb9a3e0533a00d4bc366015b6a1425946205a895a9a44ad5f0b4255e2aec75936883dc968f2f3a2b39d297930b68730ee6c3533768d287941e62992551536ad604adf03fa7963cdeddacf57a98797efd3d168487c51c494c9e245908b9ba0ac63359e2838dcb9a65612bbe5b55c98b8db70ec43fd408e4a2c5c658a2485e665c4afd8a72601e43dac9230754de9e191076443790ea42cb61a1db3028410bedeea205d886561c53da4f34e3d0cd41ef834ff5451eb4094a29dc53730c5355579dbf93c7f5e04f4aababb1f18899eb173f4a17124b52b130e59f806178c837c412f8664899255a9dc6319658df9475310dbde03bb7b4292c425ff298b5da5e5411d36d9a2c13264174067561c587a4d06f27da13d82caedc9ad04cfce10cd364390f58782e3c91c8c8ab71b251090a7b7c27b9e374debdd69c2dd33342113fae32b96322025ff4c744b22d09a9a94de7f67cd1918134c202f473497b414579b96913cdf49c12fac365bc8565d57b7e115c8a73416e425072519046240d1ae91c3bfc242d5103d2f74f397c1ee7c91034e948f227df70baa896896fd79261ace4dadb3b88372d58e69d181176b0afa333e3de26f3a71fa93fedc530ad9a7fa61047372d188c4e9b00b5971e1401bda10fc62eb46b9aeb2152d7a6d4fca07eca63b75306b755ddbd5ace8139940735d2a96dd6b3853cc015796b0c37776f820360a50def4a1914540e7055fe856b1d797afc5ce6127af409e04e0caafb905b5c273dd629848a36e559166b8b993936d539fa11dd1efb084b6021e8be9e7ca241a0c68860d66d27c7aa64c5cad8c0e2e8cec22ea46c87995a9f26c6619f01f988ec9d63da3e33d9e4a8135ae00c125e0da8afe5b5c7fe6a057b4b012db41272a0e96d3e5301eb083b87a0dfd6f9454606f3a621ec4a6c19bb9e40247fe0aaaad280a07ebd90301b183ac3ae7e30f2aa05dab8a4c5ce807279e46068f005f6d3ea864b932d1077f2ee09424e660159ca0248efb1291f34c1a610b32cba182da0c42c0750754d59c2f61655f94b28aecfdea95e5d07c080f7aaac29e8012efe80390b9ab18a59bf07ab3e9b8d20a10cebfcb5fb378c423eaff2c425c94e80a0f3ccc054b35e3e40649167708098f1e2807861790944470c5bb698cb9a0b4332960093dc23a5504ba58b5f150ff88d47d23d4a2aa6b8318cec2d025d5dd854f0457064b8d5a606667ebea28e02f923fa2ec43387348ff54d8a420e5bf471cd1a120abaca525ac61e9a2af5eb99721a7e6b9264dd18f08c5de08dddcca5fd4fdad0c5d2f874b416c6a4d02827b49a3b80bee4b187101c0bc94c5ac1d85dd7a91ba627e0d48a8e6b2552ad1a4a82fee466aa7fef9c35f928d83ddb10f2eacbd34507d7726333bafe4fe7128276077e6d681091f8a622023f4660aca17bbaea04db165475389381c7730eb1c0f82fe44114e119d8403de196354aad6c795197180d602689fd9616691ca755400395e64f5783720f861b26092e5b881f2d34adf468d36e1cd23e8ba10ef9be57a228fd2e9014d23867f654b85c596dfcfad725a7825bf2597784b4e8621a75ee17a5d0f39f8cb553d52de4545f1b3b4ddb11659b27f6b9a474afba97d22fbf9eb49d8b09eaa623057e25eab8b1a8c07685f3f59e733175dd3a8e2dd09c327cf97199721bdea40a491ddf0f7958fabf7d9c045ded32f231e31727345d010115e44bc1c1b7e9e0231cc3fb84060d1edf9c288f8e6521d04fee900907c7c998a209ec42f7c58d050031e54837278bea176b90992b207164e7a70f1d05df0419543d405155ebcc46616ce6f96a5b406f53f099afa53a735a90fea9c83d99621008e792f447f98901981ec89d5c72b6f80f3da259cd20742994035c6a938a94b7948a83c033ed8537e09fb4420fadf9e423f57cdea3c05a095694688906021d6260afb4fffef730e840a01766702f7d6160d837acdbff022f362a2a682cb32fd653f84550dfa9e2ca8205108f75c2252f6d182f3d75f70fb69e5cf744cca5d8cd855b2da866770232759dfe05539e7d94b3b33d544bd671064e06e8b6ead2bfd79d1823ad02428521e2ac3042a76f10ab3da86ae40956dbef373202405088618ed97c205f921e0e3385ebb797477bad1ff66c2c9781b27ef8afa9dde739f6c766b732e23d04dc438e9742141dd1cdd718858388d77cb8e7710efaf90aa8fe24b76dde7792d900f763f40732a47043fd30162f4ea7cd946bfbadfd354bf94dae424b530e4f68eac921c36ec7e86910f754b0ad2793cf46bcfbbae1b49ed43ad01fc71144e6836a4bc709941537c4bf801eb6dfca50e2187a11af4020acf459cbf2a1b602681bead846f0b056d12f4866aac0e51080f2867c7be172c20f474c39ed8da6126cb10bafb7055f0f59997793215749b6c9c80959fac4a5d1d99c772b5d0b1ff3f7904666d2af6549f32664b6186cce0b360d3e10db3abc3bb7cfd98eef23c83b9fac151e35bddd1431abcfd8ea605ca7b24d862e376b11954b5c78b246cf7177386d44e0dc5164ccd9410edc1b9b726514f74048fc4b3c810e6652a5596a3b71656706b1fafb400da04e1561a4b4bcb07efb4d074acd75d15d19769260d6f814cb04193fa1670db31af6a60c2e92c8706b2e165c533ec9357a2c3105215b1534528bbc254e7d190b39d92ba112e4b09233c546081cef6e392aed859d2777476bbd3b510e27002812892eccb6fcf9ef5c4cd2aeab390b347d37fde750923a2a06b316ffd86991a98fc32a3a2d401fe58365b3703cea68b400691598761c98b89552c743f5852f5427d0a20dc7dcc9975e399f4d46ac0b92e4f5c3a20e6708c09347bc61fe39af2f8d8da98eec601e1a4df73abe7a1c3fd92a479ac32864f162d0b70e2abed3c29e97b0d5e30145f59f21bceabe64d3d94a36ff720ebaf42d0f212bf877be14305f51abc2f39109a1e9933a99bf379553cd856cadf18f757e570c8a95bafb951f60e157d7b3727e4a20623a60d57f96be66d772e4d91fadede00e73050e8dbe60855a98cad0bb2fee0eaf14307c4b7e51b6fc0553f83f5e09a164c0e3e5b61927293c047d0edfc3e62e2799fc991d62225955bed2909816789fc651b8e6a34527a9b7c22e5b846c0eea743257c5a162ffe8cb81227609be660b919c1afd87a5ca18adf9e2c0f9e2232a5c70eb68c360e47901a546ac515b324522dfbbab0388a794ff8b8e78a75a44103376520a778a427cc223ba7221b0c8cac77baf634cf0f58ab6ce5e438bf8fefff6d73d848096995ad788ddbf5966b8a4f2c5a23dc006fc471aaa73310edaffd628b1943f90c879af4e17164a5f5231856f795197b9c6880a4202a8a41fae09612eb71a65d299805bfd9b7ae80783549bc5451056fc50a20a321e569e9364503d37917f0ec83d61099663d165a3765dc6dd8f00d51b5c73ff0b38e52568da681d787cc21424ba857460f72af51121e46313b0996efb0640ea9379e3999cd8dba787e282d496397ffd73806d30a8418a126f4b3f7216d9eac370bb80e8582cd6c937348a1fdc0b644af34199a7f5ad4336bab895aaf1a4972fb34ca55ca01c5b40c63e393ab1aa7b34f08421a4ea0201e9d9dec59a9a3251eb5fab06ae43f3e5bbed4c3b1a1ecf3ebc754b8305667f2db3f6580507bea8ab15368fb599d4bc9b58c4385bcc3195b987a9cb32f7bf0d29960dcc494dd8b6c9e533ef4752268a060ce05490df48369e0555669a449362d2b4fcfd27cfeef796769a22557676c6bbafcb994830616415ab25c81cec9b84ede5419beb4bf7edc88f7beea8618e2d51732c8463208c5f2f2bdb4ff49e192fd15bac66d11bc81a9761055dd8302a3739c099218d1e8d2b40f0c08106b23dc089d2296c42c495c9fd4d6ddbea565729e1f2fd3cad33361d6f88313cc0ae49f99e0a930a8ed5b7cbfaf99be4123956c2fd40f75cc74e8ad0e9bdae665316010942f6294b30b071bb07bb444019d6bb763fe1e6ae153af00ca7e0cc1d30c11c44f44968855491d44a2b52efd6a8da3fa24ddd69961d88fc0b41551a90f8921a5f9098985feadad790bc3357c51b6683534fe6168975691fad9f70b4433ac1acc5d4eeddcc05515e4dab5977eba050b762a5a7dc1ec7e58e9d39051ac3961d6af963b6b1246bdaaee7ced1fbb192e4091862d569b26dd551866aa362087fef7ff9121bd76a5f5605be678ecb1d56a298c9833f722094ceb8a634f8b410ce691f661936946240b5c8acd302683d580f6bc211dd246a0cf1a59dd8870aa2d9779f9f9226d83090094c917d8ea7620d565e845d0eb747a0391df224aae6b6eabd2c2c84145e7fe412b542c6c0290c076ea2aa926d88d412e39bb23f9e330f2d69a32192444d8ca46a1ee61c2e17229c325a48a1569fdbef4433b64eae1b0ff9e394bd8338b5898ecc1a6909761748e111ad09b77201a8180871b9f123195f99dc216d986db324fa632c798d7d16b3a6790f73c7c0763df7ee88e9415f1d0120f296a97ad8657b703b24cc8529b46195af700cb3ac5fa4b4c13867a1bf01dabb5dd74cc4519a180ba9b478552e9eaf30149d750ba7098177dd6f059263827e0e0cd554b5d4d9a0decb08adfd27ecb30e7fdbacc2a9881d5668754b146acec1cd80e6c58376f1e9f9dbfb087b424ad42d7a5297d2b45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
