<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26a9745fac5e484f8ca5ce1d1c492b981a55f7e03ef5f54531fdaab2b4ed74583e22b6ab91e0193ac27df1697281d3b7ac8834d05aba4728040ed388732b59354ce9552b65170ecf9ce8f35ee08a7e92a24ecc727bb16125c6b6b7d4258483522b120f793996d516c33686eb369d3880b29d6ae0eccabb5c1f5ad47c23a99339d6e2d91b1de70d8c3ba01995cc379026b4679e0647672308b44b025c5c969b593bb068beb9f5a6e8ede0e66de499ac9d8e98274aeca2033f3468d5fe2779babdf52fea248e179cf4ce6a6b296ee7914aa92d55f3de107b494a11933dfbae0e904a15a78d77f1c066bf042e0b939ad362661c67bf42136f5dd59272d865ba0a43f35d237edfbb56681091d9046b74336ded7049d73bfba150b7a215e07090d376210615d1c26675f69710becf1cb871e51ae9407a55553f186b236bd04e44c0702693f3de533afc282976d1fd795f3c069133102e508b8e719b4d4d11e91649958787612bb7cfeb700982db201b39bc463b526011b5bb0eea9e899053a25c441291afcf514e85f7c6e8b736d28c542a65886d6abfaa4972b56aa2ed16c80a4348ea05cf8f406df6ae1316c8b540f13596bccd100193b3e33d224823d54a6d34a66b234850333be6f59aa9c703890de117c030d197440e6b05b3c79c4de40282f7f42450cbe34c926b2af9e4c14393e4a0eecf045511c4dc4facbd45f8c0f276d0910d0a5e5a06c19ee2195ea5f8a2916e4c7f9fa72297b4c3953c01340731cce80fec6eb8d2b018636b06a5c0cb1ad347bcd87200edb862a9db8f3ff8e2d09db44fd30c100d2ff3e9e6faffce97c508a9b7bcee79d1d665c48ff33db31f2b1cd632612b9e0901901e9882db25aafe662eaa6a1754035f4ca898ef54048d5589145581a0f589b0311bb624f7660a067ed84e08ec8d107555902d86883002ec9c59d36b61086f0d1682ec14764e1e41b923e2f01d5bb68f8c18a43bec2ca1404b121b0b84e5451a805ec21a7a85788b0d734a23416ec6399f206ecd498db350ca720a508d72cbb549f6e3a4be5f6cdb53dbae3a72d1af2eaa970519db74da08d6282347961d5607a07fb920e0aa1ceeca3b35cbf52cf8a052609391e0cf05628629ff4c9908091fbc9b2e94caf67c3a73db64a5fe3a661ed48c0b1d999333dafb43075b3f3c7bdc01d7644464d1c2daffe795a3246bfacbc42aac907f8e03899d9fdce348b97348eb91621adeb0071ea6fc3ff91dcc77cf449b338d7dfa7adfe89b451adbe20926138acb44baa659f4ef32903a3e99f6064ae15714e3c0d0c90d7bb08bf923d96dc4a6330f3552fea20c9f926b09c383ccf1a5f55f30f355373cb1411027765729101b53674e670bc84a02016a6c3b39e05af2394b01dd65003916fab29aa184f000847f00158801834f2a0961b2a87a6b16997fdb32241abe9fe0b6f0fe9b60568676defa830ae1eac8f0f5970d605a9027c3ff72de60a7bd24e490bf0ae1e39f165f4d8a41c1a15daf305cd5d6f0a32fdfdc2a0fab6bbf8c81709555b39cbf74b06e4223f94966758126b858af9caa15c8c5a62f8ea4cbe016f3fbcd51294a0087d9386c4519f218641216b13c5d15189bba3ec1447f0c9a6c0a113dc0a5ff6eb80b4c12478ea53a176435ac78156dd1a3b343dd8f804574eaa7b7d47d2d8c10f95e80e620cebc13811247f342a367c794b7dd4ae9e2fdb0471442a4417b64129de21a4c09cbdb1fa2ea7cd7eaede7845c07ee0409ed82a5507c4a258321361a3177ca75394a8fb19cc22c5ddbff42638f98574c41645ef4a7ae9971fdcdf2af3f62d6a9d209cff756fbd2fd51e075c119bd17c6e15d50f9c891084091d823ece2ac5c35c1401ec2e6778a94c6713ca1581f68926cc5041f2dbf67b006a7b4e101befc54d4c87e9430a54e1b5a9dad8f3ffda35d03324476a75e1322bf61a729bd3c07f076d0257af91fee63d3b4cd4388bcc62710b73a2427e8701853149ca0348ba46f84a07d0a2831068038f1d7aaaa860eafb1fd1287aad5665146ad7e995334953fa6733eeafc49abaf6551d4f694ce188ade9e1ca93487176faccf99914457c4ce8c88f4a0c42245dd01acbe328074fae6ae29fbe3c0e6a45020bdcfe4e39ca5bcd62b7cbd0fe5dc2c449ac9e710a40a6d008988102dfabc11cbafc7e753c7a18c0391fb26038b15212dbdee6a8d83a0cbd341ee121c0605888703fb849cf0f77b5dcb976f9bf85b216ae2e011709c06bfbe749687901224aea6c7ab49d23eab803cac8ad7e590eb996d64c27dd539a11e5a7e61df0f5881a08f172bd6111eff835c16b48a715b768562c3b861aefcfb962df1a29c9089893b4a4ed4179a69c81594bb2c16abb0edb389ee16b1332f4f3f46d0f641053babc869e7cd50b0aff025afd3e6cc6f6e05cdfab6fa39c1548cbd61632fc1ccc93f751df551d824cb61bb29caacfd91dd668b532139f3fbd648c44c54c8b8e377736cbd9f3def900b62ece6ac4a80fc3b61b1bede9e49966362d7076eb7f67d30d2abbec1f370484af99856c682191d35e1d381175a282c954b44dd1a171591a97102629ea91482218f3dd43200defc339e1b0c98857b13fa551a22665e62bc98fd4741709cfb2649d7cc4a8e1f6b8934a6af9a04d9a86eb15415eeebfc5c3e1065610e3ef04af97ef7424b5bfc78abbcb625e246d5670af02196f29d8409f3bcae7f171810e074295c25a42a23ec5d54c274ef7cc0ddf4305a0be3f234524bbae66a77ace0577fa552a9c61f3fcdef00ce087bd8cc8b317b7506e01db3fc77cf9ac4269d83c96fc5f1dfd04040bc1c538a23cad6282cba78306666ba0f17c1ebf8c28f7406af8926687e8034cec7ea5d2991db78cde9f99076784c43c984bae7a9dd7e6eff9d4e76af554e824992abc7fa2a6652b029ab1dd9e357ceac64f458920dca81146fa0062b53bff69b0472998ffb0a22f5abbd6d45d0171f14b7eaaecf50f44148245a037096c1e18bb131ce31beaa71b8aa154938f8a16fa0791191ec6a6ebfe5611efc8cfa7f14d1f0c49a40d1292ff8b6481d0eb98d44ccd9cf9f318ab78a4b5b476755cf66477c0fc9f348b57246ffe9c137a4da3c97ebe7b75882d8321c48947261b82e57131790e42c96ac8304a980b87d1cf7f83ec8b8232674556f0f0d9ed130c64e09c2fd232e608d3e6b69ebcc24e589577097ac85ddc2c20a4a12380b2cdb7a94c1f3ad17a2d249e76db3bcb143e8dc7f4814270736ccad46383c6dec6f6d29fe12e372fecb986e896b6eee737096a0f163feac5cc008c2d0972246953472f2b27cf2d503f32f3add07d2b9591b0dfb447ffa12d0c1c139a6008ba407788d30c59ce034fe358035824d4643fc2d445400714a40a16893e67df1c9393fcacdb88797c55a0fb96078c4f4bc8fad4d37ac105ecb1a4817a96a084a55bf74bbf19064a6b406434c70439a8fc273e8ba745f7b87022103c23bdd68dfa36b47a8f149aef2951be941f2c537ad2646388b386908f881cb874a6d11feab405d5c40563a8239ff2b3786978ece8caa43e46610e863998c0677856c9217d86d3c826aa78248f9830cd25856ac5948c844f02c85b136ee6dd5d2954afeca7a56d1f528058cbe30a9138821527b240493bc73c450d5d87bd101bd74f67425fd5e98b21cada3934a9c3dbe4159955792f98962d0c4d953d745fd5b5fd660e1f35e77b41a5f9ce4130e60774db9a8160d14519c05f4fd6c12617c4d48bd285f490a25faae6b1e261c6becae00ca71e48c7fa5119ff6ffea93f4b04683654c7169f3e160b17aa15dafaa47ec713d4b92f44c21d8e8f2aeca75f85cf605dc86495564d1c3c608322bae38dc24a924204bdbb5ff398a5a5d1e4a34ede92f41eba7d57a88f372c76a1415475e133cada22575cbe433b5470c20749a2de420a39c32592720557a1c8de9ece5aaeb15cdf1df247f9f2170d51f186dfc8a4b0446716398a50afe88e5d815c13dfdf825812232262d087c9191a573eb0949aed91059bf181e06452758ee09623a7ee46d84fba62e0fcfe683f0721717e03e7fc8eaa11dc3df18254e782ffe4817e64bc990d94ac73932b08f2b9216332fdfe733f6156c6c1eb9d56b891a62f3788375642c6c36436b8b164cebac212ca0ccc95aecdb491e49495fc5ed33a094bee74c1f357480a0e1472add406a728f1788c2cb522bd23229d87bac64b6f34e92c9f7a1605c26c52f72779ba79661626125e2ccfbc9ee883f962b5e284eca3b6ec4ae0a4e695e73df73a345743519914b054278ba71931006fba2a06de912524cbc9ed63b640f7dd7a9076690bedc72f3f700bf3af7314e8490a0105e8eddd6f04d8378e9fb8f3224a2f6a3968e254f5d4363124d8183d72556af2aacd2fe101f6170952923aab689c918d693f975360e09d6d4315206c4cee38a2fa3c67993d8f982d7430782516ef21f953aa03ed234dbe82130f57abd19e10cc9fceaa6a60a6f2f67864f852db553f75999231f4b28b7cdf29fd7ebb25a2a0ed383e333733008b4139ac778ed161fcf0581c1d7634912a032728e32287d6272ed455ecc4e0c4e90a28b4bc1631d083b8f82ae2ba57d60af8a7994b17d07411f88563227c676c1f13a34ae11f1b4029fda3bfb734a22973b246ac6546d1ae8c7dbb07ca3122c553c2d4932e5bbf6e18bbb53a75297e195e7c7d9db78c3b2bee238bfafe5c835edf41d7f8f8cfd0410a502a968b71dbc3bf38ee5814a122bf35964c91e52c38b8d67000f727d33a1beb15fce9b5d1621fd0c9d8ce5c1d31e79efa94d7b9d1635ee0e7c9faedc3d180a812c895d312a83480133f29c1f39a9d662e624156139bf46485254501f9976413848e153c43eb9146f0c5de35de7bd90367030272136b0eae3610c8082dafa7621e8671ef5df3b3d3e7b08a051b6c05d2b0770e0329c6e19e3962e6057ecdc501b7f8dc37328fd61c88cb52996b70fa60096710c9c3da5857bdada55192cf9d7b82f75032cf69f5560c20df46524bfa751e47a0aa54fe3327cedf31e91eded18fa7e0eec43db7b27e47836f57f9f4279ccb98681f3faae6f3dfd9e8838b9093ed08793e632ba08e454f378f1abd4904125f9d74e2c6f6fab87eae01af7ca89dcb48f72149a01a8f9c2b7aa66ccbd198e7871aa3fdc58320ff74536cfdf4af7a40a27de13c09c9da0f24517d0209adcf4b7c9c94a5e7e5514f230419c385f9376eb87b1e2c28ea20e5403c85f6c12fb7153b0ce7d37684c48c5d900075b7a9dc45eb08da610a2c9737ca5c5f7eab9a6b74d8ec1cb50dae52e6d35faef89dc06c5bc25ca017268993e0b59676e91d5a497ddfab7a6bace20e66f5208f0741e55e1885469ebe16e315ed1d958432f781e6c9e46f9a56a7317d37e978e67dde539d8c6d5e9b484303255367fe4352cbf3e0dffdeb4b83f9e2f1661b8c696dd26d46ebaaa23a3a6d9a16fb8c17b2829908c3cc19241ad3044459d914f040652f0fda75a2c10762364f5d7db0fd13fb710bd3bf964201483b64af19b6e2237c675cc3f397edd94ee5ed59937364c4ba75e941b0b6978b7bc350629aac26141f0e23506831888f0416e7842e35bb599cce10d3447bf8120806dfaab136f736d0ffb56a495f1ec4a5d53f3d3b7a12d50e86db7a4b79bca33a281b6f0dca3706713535eda1460f6dc85ec2431280a0488d62700655ffbb7a37605220deaff407373cc5b67b57a97009ff0bb6b32f424c9d30440ed5d72d900de56022eb8aa1453f0b41dd2fe908867d420ba41f8ac805c7e90351d0b22c4c5f8ac4154393aca578f96c70b10e4858f7c9c85fd8688b6528c374d3e453b803be0af4ebb78ddf57a0ee79d83c8fef13b67c5d81ebbeb16508df6058352ea52ec1fdb5e869095e826f3368bfada90be2fa2f48ce2f515466e3174abb4d79f078404cc56945dc522c4d916fa01c3eae41b8a7ba581ffb6bb184dcb3bd10ecb1c66c44c59a15a772614d996aff4a085ee8dd9d124c1fb1283b17650257defea6a736198d4dfff71a6ae753fa64fa9b837f51213e56d9e1950bd7eb24465e02e1f411d746ac2577c3095fb865e8860896595b280990f1acc8e6bd898e64d13cc45804d846bff2e5145e59e008923a03e4c0d0cdf57d254fe7663539828118af1cac368710ee41222c37d87b6fe2970532e39092008d155f7fdee11a10891f13b39c8fd11346df83be893668ce5acc676070c0b53360cedf2f52b3dc2f912d699905fcf4451eedc8a01eb40be4b49cfbcb22f996988fd0be373f718e95b9dd200a6e207a16ae7d9e92675d5185439a0f5aed6f9e03ff603b867b625fcf4f0633742136ab7c6dd3d075707da8287c50fc067ffaaa3d5ca208ba0b7303eb9c190bd1f62c45acac0a3dbc18f34d2026b11b3e3bcf714f2b7bb3018a91ae2074fd69b092a16674ea45ee75e16630b3310c43fb3e4a8967e5f993fe5f5c50110101644d19ab08443906c166cd0bc7a8dc8a203694bed88a15b8967caba6725523eceede26ddea5dc435c86c97d14807a956a626cd5d9f96ce2fe40275d1ce477210ceb273947dcb3b3e9486ca18cf9cbf17aa152b96c060670b92cd4cd76c85c7c196e571c375556991fee742035497c91a949c622723032052abd6c6239680e1b9af0498352a5d021e6adaf4c0bb9cb1da00d2f7645e43ad7eb288b25b42acec6bfb9c782a134da24996043b877520f839ca6a5e99fac56160c6ce3385d3124b47b0f8fe2ac439ba6b51ea3fc976ad5a3d3777e78876f9306daf4404f15b4b656aca98cfa24dc688679ca027ceddee4918673ddebd94cdd712cb2f276759d9b8ae78d42c2b5bf84ed1e336d79aacd69d4a08b7e2e928a00a1bffcc95aa6d6e559fb59691b7c327a66cb6208b318273de8f323edc6903fc69001a7e2ecd16f89e4477051b7db9d916064ad3bcdc291d228cc91207e862bac4384843d2b94fcc9683b3e454dca61704c664f18f237e9c049b5f6bc34d9bdde3374a7928d9e5af397306df39b95d0cb3daf0b141e48608620a13668f2f1a9ec8decfdf082284ceaa13bb665e847ed658cce2d49c7c6fd348f55a65017ba4bcedc6a193cce71dcbb6c6a6466b2d05132577cd15ded2ed387428025b0acd96a28f61f7c121eb377283245c91a8ccf27d82af2f9cfa04ddbf9874a60dec0f882d198a7d290d6c75e76dd37993bfdf54be23a6b1b28569ca83440145d2040e3e1967d4cf48ba591401a0001996a43e272bdb0a9cf8f5e5c8b6d7db195886c2fb2826de616987277d4fa87b5244511acdcb2a26fb8da17f7a93d6dc9b1f7c04e74590769331d0f486eba2fff20f90a2478061c18347657449b8b906898cb0d3dfff41a9375d12f04cfbb96ae9fe6a148615c9ca4af5ebf0fdab4d9b962b9761b0931e3c628622d0c07fc21552174f3aaad8b26aecfe60975d5d8b41ede96bb001ef3f0527587a2509a8d04750f900909ae015d6ea79da6b2fe2e83c733ec0a727b53c95f13aa11e14d17ada595ce8a836963d35dccf5e714b5a7b51df3c304db65565102d351908d0bc5d207da01d512aa13a6120b91963110bdbb002fa603ee3600fa443799724779d2de12b84b28c962c314690f10acf9de0691daa83d09c02e443a6aa588b82bfd053cf2dbbceff7953ea7349047d36f8e179d6ff8f19eae27205a4770c6f28977d0986986bad5a2913adc084d1541c789fd5ba1aef0c6afe7b7f316dc2a9c3d3ec0f89278471bdae1ebc48c6c1556f2a0b01d9c28316fc481fb449d5971c2aea50bc49915899a0f8f758e2ff003ac5e9128b224c05664596b65e0f770db7df66582427f5ec1e9297a1538e9dbdb4b37a9f7396dc755fa95162e203b026c33fe50f2836918d44fed8d64bc4c44204edfe92d462c00899fc129142d451cc91026e8b5d7c060570f9e901fb02d303b4efa86dcab38daca658956090ebc221ac7c88ea764b37a29ddc7d199b2119ed0a6bef013580db0e7f2182399523521524ed9992c6377f93cba7e6530c9d6c57a8ac9d9c2e070d65aa7111e07f2aea072643900136fec0f9d550604f5ed18db25be4ca95bb9385e4cf64145dd6cfcbf054d9f41379bc63ade45d99ebadd7145ce9107dea0b4b9dfbd0dad5ad3f7bad36a1cd534257931c4723b39b5935bebebbf086e8078ec331587933a83005b280be3cca67ad78326e21a546cba20e0bcfa6b22096be020141d464c5b6f814875ccd2c50bf8c033ebdd9d307ace2392edfbbc162ed6a6d0dc61990589626f3366ad6af7eea5724d1a9704f8eb1ad3ac62674c766ecee3c340b75655e70e60ef2ae9b1b75c1aa7e3011e74d353aaca11661c02d317fa5f2e094092f8eeaa205abe22931b9771fb634bce1ec25a1601e9d14c36f94300c40e90564b8b00c8009e9504031bdb1c188eb235b7476ecbf409fc6cb4ae3ce1c80f273cf593c4ce6f97598c425651f963c42a22e090d7f597c6b3a657b11ef5e2110fb07ddc0e99f3c12679fd2e9f8a9dda6fcbc963f6638b3fabc8dfd674b9dc111efdc56c7b2394d327490f6e4542f50fbc7d037c63a8c694e70de0e6d0ea9c4471fe11c4a889b1c6bf06c967e17d94972a0baa23587001c4a537335303616ed78238c96ed6cda0f8576036aa8dc5425e99ad5ccbc323eececb4f801fb908ce1b5a477b7a49075bcd8c13f04dc95e0870f1ef993adaf2b250cf60951537b0998c5b444ee21f3e687e630c8ce4876bfb054a4a323ec7ca2bf74827c280fb69daac1f325fbc4849b517ff49d254cf2876d045de2426a8e811434d667a66841aa28dee60a617b60de6bc261631455fc3f66d30933258f8ac4df839e8b267e113204ab049fd83cb833e2cf9c45ad9d34d92e1f3db57c0fcbb7de381380a5ea8e7a332afb473b9c9decf2f5de8a19b4a74a939aed4b485ed4a4dce8b42e5f05fabfd33f3df6d99d46c7b504b69cae3fcff39b057d9d36d0ef49c2a0d2af4a12ea0d6c4a42bd1cdf9ec5ac43300b83eb15b7500fe00c6f51e74285c5a593905aff0248996ba109fe5eb99e990b54557aa5c140d84df035ef247ae5321b44b3853f508e363daccdd79f2e2cc0493cc30fea9faee77f4031dc77861a910860e4834dc45bf70d550d378c51153cb09ea59d20aef13e6d6923c7e671b6ed74208f00b2085e18aee6d37cac83ce0e382d19cc05b8e23b4558dd03f6f74ee9bac0b92ad987b767234c7a63bc66f1d60399dfac29a7f0158f696e85b8cf3afc8a699ecb38e20b68ef6297c64cc67dc0a746b57c365c2110a1bc59c1186f78df2093c03c1cc05ac4147fa7a9f57792008339e2faa2fc496f3d2d6650d73095bc457ac57e2f657cf768e087741635ac2140309343179035e501142cd2b1a6cadba4aecf8665259eeed7ec239a1dd6a804ad18c9d1d8010dfca7313bfc15c423c5e919db3b015bc5bad548a1f830ec177ec6496f0a135ab0de8819679c825f55edcbef85fe8179a1f9c0ac49aae4fac3c5e6a5394f1407ea23b8d53966ef33045f9844d286dec72462d792ad8b16b0a1dbd1565c4e785702612be8a931233c6c9ccb5a5623eb4aeb3ff9bba5ed2af52063198f1d884318655e2f2a98b9713c4a43cdfb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
