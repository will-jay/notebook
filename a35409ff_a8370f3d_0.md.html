<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6516ab9a8ce17bdbdebcab6fa2028ec276da005b5517b6c8640b082dd2b47a184fc3c985df31a4e6ca034ba8ed91928e4e5af98b2fc56170fa940a5db8c733b29c5c7f7cd8b859349004aed94a1c8f94d5dd4fe3319adc454b6adfc5167f9b96a3fee008c2c11608485a49855d200a330586506c70dddf516248eea4aea81284d50940eea11b2205b7ebbd9efe41fce832c151e2c144b6ce40669a87356f6052e360cae6e1a463cb3ba200baa246f9fde1285c6d1aaaa9c89b33b96a276867beda537bcc6bed8f75b00f26c8b6de0758fe1ddf317d031d945972a181a0de1d6054d5554a984b4d266c58f67ef1d6bbfdb667aa87235cf389198fc15bee8b72763054deed87ad8e86a981e8ec0dca71f086839814eabba329e339148dd7cce26a2a833791679b60e0df06aaddca77c16f6f67d5f7b0959b856935dce518ac2141f202b7e8c30c5ec5f70bd37ad67c280154788d491f2a3cf2a0a2a69965979be33439d6652d3de77fd67d4e49dd155238fb3763ad7304c8a794df1de415dc7298bc495095c6ed2f5226121afcd101e0277b902fc6eb51e8a136d0a89460e7abd16bf011b8ba339b493fceab3c453edf7e45f63b6fea7df7acbfe4184b12b5cd791257b8b050cf6a6c94fe26733ce9e0856c31c2cb58c38b19a806be1cacb2f411f1f11f4d4e00b01794fc82199fc5066d8851134c7f4b442422ae9278ab204933c8d2c3b42438490d9a61727b4738bb5d7f9347da28fd308b36b0b54c4e4b1df0059644168db5027fdf84697d57b4023f447ddce7941e03396d397de32558dbe6dd1eb5cb85fdead28c1c90613ef56751578688e867b86034863c1ef23441b7d69a3a7db27a4f123e7bd563f3c0a916d82f43c424b15af77ed08637c78b53c179fbf077a4664f4e8c5140b86061264cdfb2a09b31303e12272fc37c9f46bc4363e5b1fb26a3516dad6c8224c39ce825ceea41b70908492b58c35e533a8d69d0cc5f47f1edf1cc54927a1145c1195442904adcdcafb4d447365984dfee4617f98bdeaddb98fd201a137b4fcbb073ed6d6ca826f67212cea7506a39cab84ed3f21b5e613598e4e0872242e555eba1de40a79b8d61e465a21edc29cb96cc5763585a90c941230c7cd59c3114944f8dd8f1caa78703fa3beed6ded43365d89788641ce50770b99abf72caa8e2f48b321ac842305a30be985e4307b5786640c44774ed55627ef9ec19471d1ea1208d87ccecd4143f5b1358f133c2404aa363a2213a41c2fae6a52684fa3767bc9cfacf5705e16b64d4cb8f29f97ee88bfc19df3e0472f442421145ab276e988595fbc9828107485a9ec867c972bbc68c677a0e4da9d5f419dce544680041855f8ed23c9df228f257a90ec598504aeaae3d3ac049b0030f4956a14df2190a5cb7e45fc60994bea8b861564b9a631acf5307552be6c65f1c2eec7fcd27fb3230ab30750fe175cd667e660ba8cd85586300e8689fa0f188ae7927889ee8f56d187d1c380478df3575fd395a29cb05a4e0e3bae9836c9e39356d8e33ceee56a66b155b8218741f0b6bf0e5102b7040cad10594dd7e0eb367dad084e9e754128a0134d074e7efe587057b43711b2f5ffc5ebb97d470b56b6ae9461ffe6a43b8a7ce704d0f7f783efaa3c90a40426e9bee976e722e36a86ac034c69cc60a17502d1881bdb1c983fcadefd0ee44a2d389365a89c812c9a411bffdd4b967e4c56bbd1d4d6b588db465081bcbafafd05881ce24e736b62d7686fa78d4d22252c708de488a83a10168138ed7e16d672e4212304330da8a4714f14f4da5ba7612500a5b0b0fd54c1c43f77119a61f881b820b185fe55afe2a592ebe8855c3d63442d284231f580da57f4187f9894e4779cb5e8583cb440dccc7c4b605af1f69a72c2f7a5061147e36fcd37f545e8f41a2c392bfa0fbd2866ed6f503358cc5fdcd186a81c1cb38b2af9d007aa7247f94ff5203da03f20755c95dfc19c1dea48bac724cf90ed348ef75cf9c9dfafd53a5118fea2ed2ec2fae7afb6203f5fc7ffc79d9adcbb36d239a059d2a38d62c65cec5085ad9e9f2b1ffafd8f6aa7e40f6d549f9359179f6c254f23b2cb548c56ca6a4fca10f71bbfa7474776c71672e05a90bcc884ee0dc58574fe943ab49939477ea4d03b2887eaff73a06cd6aa0ff9c20416924a0be864cdb19c4558a4f260503158666da544a07e31ac1da47faf9c3e3b3e7193a8e2b32d4206b5aed42d01f25103991f0eea2c92b751e9be53f941ad1d80bc2a29bc7d61947a4314d042cd213b302486d084aa0bc39faa83af2bc0f7e1c850e7c71ede0effb263a3e8f5297e21755130e1ba15c4113b754f4d5c7cc6b5f4e3a7b7666389df88f10a24e0c1596d0276a1036f76052491f4e3bdf1c8586ccae15aa61ebabf03b086fc2e73323fc29cf6126a1dc96a316ee993d3c5e3e45f180a6e0f7ed81a14d85ff6f5c9a6eb9b4250b16b7d1dd3be052969d4ea2a6ccc6c84c171dc4239151aea89786a0771a3e3ed6ac71084fe2372cbca27998a7e60e0008de107a0904f4d12693d3cc2234cefb57d445cbe722d8f261c0ea80b7fdba41fa30451e2f6df69373541cff597c298b2dea45dd1851ef4bf9972456069e4200180d33a0854c26376fb4a61c343ce874f160eb249fea50cb0921764f613645326a91c42a0eb6cd09e7dca3d234db7a75aaceec1d4e8195fd6ca5bb1035d1ad57629ff2a77473f1eb158f327ddcb13e358e86ace76034ba1a41ccfaa4235ac13a33553020bcf9aee0217c009601a1255f022f883a3ba04f0a65915484f4466fec043e26bad1a5c19ce48afcd88d06df143cbc2a3a8cdc6949ff480740c01b02045088e43ade02531c53e09af1eaa786d8aa63d790fabb8dc5f02bd8b75a66bb111f92f3e80aee4dfc419928d17d5220190541d6444d41d2a3aa96b05f93290b53e50057501effdbf59158a7fd8df35e6488ded5039c297a36a0509a5ecb08a898aa7ca8e9ed2cfdae0e900ebe4b10f9643893592aeb958dce528d356325e35cc5f11c8097a1d26747691fd83e97f804396ea1b6335c16b9460cdbf1d32e78a33a7a488f4be468a9f1b0f26f5e485a6413dd51194d6fa9b6b18634198a66ff0ec9a758727fcab23ab6616c5187d1ecbf221518747d4b0fe380e322c0fd46447195498669f99e02bbe1d38fa26d5af81812556c9bb9552ff4d5e6d30459943a2f5f1f425723187cd97ea7d528fb89d1467562c9fa47d2a3147706a7fa90a47689f70bd1425ae9b51dee303182a86016cef44cfede196f08d4b035fcc8e0780f08f688e26bdde51575ee402ff582c0e7eb674ae987dc22d81976dd05e7da9799d33f00c5c2f55736f200b83fae98aa01f54859511eab9dd139e1da504855b9a4c6ea675ddf2df7729f0c1d9c919b8570c3e06cf3691d9c39e228ac3310f4540bbdee1a89674359c04fb673b88c499e72e4566a8c403f2fc5e8c41c366963bb7731a8be0157f81251b6b05bc0138d2a2cb2edd8d95bc8d6eeab0993f922ff4f06e439e4c3dca17b38f041c28bab15727326a384e22314358ae9fd5c95ac3e0ec0eede8a0cd645f3f25a14b648f72efe311efb936d1ea751a1fcc6f6803a5aaaa6ad7a7504ec1546a4d737784497acbceb5dd00eb69f445200652984e94007f6caccc6de04eca7fd828e09ce19bcd31a5bd6beb31716ba18045786971c1212539d8850ce50e8a9f29f54b28ba511730c35fe1d0e9c9d5781ff8a1131ee51bdcc6d5d2b18d31884a4ca708084f855d45dbb5a4c0c8242c0d955a120da786ac46f8af99ef08c9a94226f24b0d622763ebe53955b1a813878ba1b4c8f60d9583522bfef30263513a25c5396efb3b9603c91fa6837c145044b3764e4e5407708185bc66b5b874535d51533e19d8ef4aadc078bbc515729fe7c8cc2ec1b9c43e6a3622c8cfa434434f8efff8c9a94c2f98b1c7c3355f87685b9c0b39b60ff976d767480ef095cea318d7174d508014584a536c5fe0135e96ee73fc84d7a268c36f90eec10cf2736972db0d4bdc70e843cb274f3956c49cf32376d277f6867d53f801ee8caac4f0d0f01b81ea5a52a9a934fb3c000cc0b35cae181974008e4fe5c9c82d28d7f3e92d937a0134405f8e90a77feb78ca10bbf51a4fbe77eebbbb55bce5bd1674115c8c9a0561c57e9427725c9ed581e4a9017e86ca04fe9deb073af58aa9ce1a9584b001d9e0b8ca515cefd70258c3e99bbac35f6761a77a28bc537019f3d4c3765e32bb0edbb6644c853e1820a7ba17da41f0dce9c8bf7cfec1b7d69f3541e423b09604cbaa48ba26d87989d5d82f6f91ea64c173e2974aa8ed7ef825ee3a8ab1c1a7fe52356f49606c3113d46b6337a734e7f993472fbc2cad70877388eda28f7deedaceff1d1226d5c82b84f1300aada9d62dbfd0da7ea3a2292a8d9f3a134ae5915f7616daa74db6559329b1fa85c859d6c2d9c9050f553c0c06127beda9f6f8521488fd20ddf622dac1e0ea7b2e935637c1b09e78dae608b1f0f8886c4a636930e050a188ebfb09918f0ad1a426ccaa0c79f5f266e1cb4f3c777c72c43a395440bbf0a05bec8eef091dc5fce06cba301d03672e03b858da9422abe02fdee214fa79eca2335da5109285246596f32edc60697c85fee59af2ab157b89facc5a7a0004ec86d1d2139fe70c76c629e01d89721dd82504aaaf6f6202862f1934b8185db4f37c5582c1f384bca6c4cd2d12fbe19818fb551f1afdc404c517ef7b11ea04727c90a5a5e9dd684537ecdf43b053c13e1e3a2a4ff4ca895addd3609aa8a72e3cf102ceb47e5406d0c3f3696bfb5b3f5c0455929b492d5e4a8c6ab8378ccd7b18b4c1ecce97b0bb97b7d689296cb28b6f231ef2607767de285538f953b084b62ba33107fae54fb7fe4d20d0239d17d53ba37d85231baa394821843f087463790dd47aa51a236e25e924b1b2c63fc492e7b991272dbf45832f652273cf2a17831942217d7aa515896076c96cad3311e10e09c6ba241c31be33790e697af351c94ae1a772fa66153fe15eb89f62f9f5dd673bbb3a5dbc6b3b9cc672a68212ba3d48d78c17aaab8496ed91ce672016c3cefab68b7074b1924c02c1c0f7e461e3d34f13c061855e61d89966be905a73fd978cfc4f5098ecb32f88a1019855d415f9fcd06aa373bf992782a770a002ae7ae7e355f55336c6479b1767d425c7a9aad7aaae1914e15ed1d242b508c000bb1d88f71a4c934e69d9a560f5c3e79c5d18a362539313c69145e663cc1366cbbd21c8a21aa62537b2311ba1926e46f215a0392dd7de88d35e66f1fac2426f26f9572587f27934388dd584aa330a6985e01e88f6fbcb69815eec512a0d12c43de78cd9cf402e6960411f4e9331b7ef50c8c7c52a6090b3fd1a958506d7f79e080a4b61289157e1bcc055f01e853563e56efcfbad6f20f25f55e54b5d56a7f3c3fc5e21bd79af68cbcf4ab425cd2ad71c475c01ee659cf956b27cb7d838a2c1d8fa2d337e95fa482f842e915d7ae922e9350b18f2cff1794285117a023bbecc7782d279e8dedd5a7725d5857ded7112dd7458de62e8e153cdc8c9756e81ad4a17bd2f7f9fb420cc018e5a2ea9af9f090ad6ed1292a68f45512379c6f842e16a853bb3d63c7e0334533780267446d01a63cf15f6d07ce74227116332941d6875bd710ec7a8f6838c1acdb0aa5f678fad109e7eaab8a78b6fcba4e4c696703996bb6da1d6fbc3c2dd73fd3add51d5d083575fa9cad531ad28d0d84c0e0e21bc5847a47b90b81c68c81c3cde18b4684079aab75ac8948532375a1c21dc7eddafe3a3ebd110757303db01be03c1348bb2cc12bba2c6d365a3a947d48554d7a80dddcb9f691662ddeeb2e2b1c42c0419797b302860cb99f5b6ee92965ed8e6514898097d91d571413c60212f8134c5c37fbd06b81206f01f9ca077de2c6b16d4ef942c6595fd9ec9cb8a5db846d60546f3becaee1af7617de1b3fa6e5a804c4aecffa9972780932a6396e3c86fd5b5bf10cd3485a9996bf78c5b0a88f176f5c03ef45f9b6ba76301f695f6c67a1bc785c0fdf24816d1214843471b1ad0fae3d67a18e01e72367954cb4c83537b4fbf89b2207117994f94fbf61ced8005a2b278f0705f12ce76396bf7e4a7d458bafc24c02a19755542588a59f7fa128d9dae4610ab885e7e97c049ccc5b3e2cdbf7e83e23825abd25865c64480ec9f0571768e6a5017a6e2a9ed4814eaf1ab9208d154ecd2ba9fe4539306c53ea500037655f9e2eb8a46a873fc5a0db473ddaa5f244165144aefc406e89edb9c5542b6eea0729c724fb64ae74afcb8047d05f60d0fd175f86d30fd4ed8bbf2d1c6c4d305e689af4bfd3bef6c6e13547c1142b4b5f5b476012b0a3fa68c03ae2f734c9f2997601b4073d98deaed882948e676655ac8fdb4dd11c9a3ee87aa93dd80ed9e9b7004fe4871fbbd5b04e6db68b2dc3aaab225442db6ca4b9266038616fa49d8d8b16fa2cebfa1166a066aa470556ed620224384dc78441d109b61fdbcfe36cbd7fd5a79d2ef264cc94bf6ea47d6fa956a2d75670e66456225586a18ff9105423c5a7c2dac997a414910224a1493a943a9e657b8549c4b28b65f12e0bd99d8c3de29d3d45d7ec29bde82889bc30fea941998767c1ce9c271ce9f8003685d5f1937cd238e5f36b2f19e27457262f4b9235797bbe780a9da15427352b75c0daf1aebb6c36bf91d1eabd7cbb1e4517856a19b950ef725912ca0b2c67351cd06d5d766612c07c3495a9d56f51633eb0bbe86d6b14fead83bed530bd276267021cbed565cb3f39108ea62c16acd2eb2365df2cadbe51aee8ce9ba2f103b4d97d207cc196fc320d25f547f339027312ed1260c4237075030b4b066f49cd7dee79f39270325c7238b821e645dbd63a04ba77210ef632c32e85ed0d67cd658cd885d13a979323ffc26d81570b8ef3fdb6c59055d358053cb94b54d64f3bfdd73d6ed136584fbf562954e279d1d9a69cd2e7492aeef4026e9c8f50d2a951d3be0563570d56e2fe5726395dabed3d192c605b3a6a4cb5192f857431aa520ef96d75b26d3f5d22d5b756d32eb29223be3571092f20677b3baab7685257393b361b7372d60b87b433912f1cfd2941e3f2d10d0b05235300b6bc9f7cbea203857af07c6fabc22dfeb0ea3c0fa47c00ccec243bf06e29dc847a7a6bfe24cb1ec303b65c148c3f607987cd5d38828c9288e257115c12212d42f6144ba381a84e6ed926f47ba38ce2195a19a3cb932d5d58d6526834426a8c5f62002d18899e4771b46b4841cb67a3a3e6cd899a80db037c1cf9412509a5046b3d65b72be39e7cf6fb2de26b82c6862a5da509266989f5182730684c6b66a8b8f5afdbcac9e0f438c4b678f420ffd99f75e5200dcc994c525a93b3503e92b71206cc2e550644f86a76e64a47d605f8417afbd42c1fbad4c9be8314bc03a07a5137495de1784fd3268bd4a8374ffdd93e89e215de00e5afde3598be84e9120a1aa53d4d215da80b2cdfce9bd15320d6b65730b825794acc51f3e840e5ab6043151063ffd9ed495fcf5900922892d40b5d14e8a82c2abd8213768d716ce1d1758fdd7c9125345c4e3b086b21f931ed067f8a9b71a6f034e490ed8ada17714a5e9c78410997219f5d6bc700258132163ce23d82b4979be7af5052eb6ede1e6a2755fd4aeed5c666ff5470bcb4d6aa54e3d073244e541c6b1c945cbb3b527ef52df7eec76c35146d7b5ff1d271a84668774039cbd1d3a2d7004243ee10098c972eb4de1e247869e0fd81884b26555ec1a86bfa864e7c7a2119044442b4baddce7cbc7c208cdd76cd98b1503f5bd8d00a953ed6c4d53eef4a0ab6588e3cf8e67ae5152145b10d3c88c4b5c0511c1ea16ad68c43d9a36e31c34bf417609eb7dbb57818182b24126068ce3c9e4e0c92cc8be2772b23963b998d3f00bad9c433e997e31f7f4dfbb9f08aa8a82cf79ba5469f9469c892ca3ab42b77e8e5ccd9c71973b153eca82421eadf2a4cb2ec6bb697b91b2b4c21c48533e43a687f20f3f7419de225e3196f50adec71917d36b5c3d43a8cdee7288b30f3762c5b48976100423ea8995c0e78cb8726b8e0658b445fcba1e7f3d5537cc43ef9a9a565ee2f430792e1d586307eb29b4a3f1e27fb943be2adcddebd9a64df67ea8c149507329dbb7d41f5410fc60d73626500915cbe4a1198f199aad26d89bc81f2ce11c2b0a4de9e0486affeb08652470848467604666b52c56db4615259f79e78c25e5437a115de7043e1c13a8c29d7a9f6b6e8a55b8c20cae052b5b227d1c9aca9ecdf2ffe0884cda1b6a6a8a6ad18c1e26952f5b0e387e2d06b47008d17b039707750d55e457879667fd1bccdd83dd22aed5e9819baffc55187f59701b372063bf92adeccf0cd0e6711d2291744f6febb7d4d198fc85ec3bbc57e4634f228d63ec72192cfe0573eded3b8bd9ded17013aabc3827eb028cac9ab004424257ce9241df5819003b37fde9f192019960e935d59f68f2898f2d26ebd3e75764694159369c7d6ec2b8783f5f16555baf2984431757b2a08ddb768da0aea8ffbf6e9648b6954294fe503a3c2102a3fc42bf8229abc3b4110a11f9fd17281c2c1dbc784a603778dd4c3b6b72751c56dc0061bd1eae32e3582e723d746782f48a020088afacfc81b2b6b41a464458da2a24d025d3175211a17ed400a5f771fac9284f5f7d6872cf699740375b36ed19a80246be94931fada61ceb6d8c51e35ef4faaf9c3236bd7d56bac2a766f9581a7b0c61503ead745b0beadd8fe72cb2c88ec0a15a4359983435aa48a4855eedb33a403c869e29a922b0fcfd29da6ae9e21cdeaab7c707e0de8cc04a5132ede884148b26b982509febc6d246acdb52e2a35f9991487b96c2874932043b94c8b346b8f8f7247a8b471f0375b7ce2d7eab5fe50b1117f7a47edf6ee667d8dea18384cc6b6f470a59d5929f50fba28f5916014db29943b78b5301f8dfdb97532446ab1e385d17a1d7af4c8e15658946931f78671dead6a50408d0512fbbea51d79ed7081d7917c9753cb9d60233f9aa022880c24bd1bd93f24bc96d57b89fbbb630f4275b89fb5a7a599408688c9b08b05bfa8f04b54a323bc495a2d713cc10d41a9ef4b7c94b9044296e1bca2b9f3747e303c136edd518fe546042bab810d77099fc65cd563cf65e35683b13600c51760f6e1426f26bcb0798e261e599246f294930868a660705acc8b27154c757b9349be3bfd52fe33154ada4e616fdf64a530e37b78c641249a100084f2d18c98229962d4eda858ba55109396ad721323b127e4610976a50f6ecd5c236610a986f5050ca190dc661cebc17f142756ba59dbc058fe86d76a8278a6d0117e35e865eef89aa76c3bf2cdecf7657fc267dec6ea163f480f7762561db5955dba1efc37fc75209fe52ea5816c1a5a1639899249dc140305752d36aaf4b822feacf469a27a376412f654e12de7357a5e99308293c15b0fcbf788f650fccea23ba8ac34f9bc660b1b84daf41615f55724dbb65d48cdc02b3d9a86db07ef0e4e70b2a4ed8ad014f71f729040ef16f7e17f2c07c80f5dfd3f41b1f7203800401082c1c0d72","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
