<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef88d6db902b926dbd2417ae1db1bec1dde5660d352f35d7cd46a52bedbb3b5f61c0fa3fa2185c9e030890280e63c105cc296feccad3945641369aa4db5066f5c259b9d00bbd52159461585b078c2daa328ca5ce263e743584b810f2880173eef486b3f23d16b15146bf905a7bf367848362a586476d110b0f26366526f848541ba393cc5a4a3cb23d830586021852502cebbd52f47502e94f597573bc8bffd7b56253f8c1e5cd4f5fddb3d0f362a72764513da9af3eeadd2d2711530a5113349ede7b6927404b5c97323284cec6d9f8c8125eb077b73b35163e359866cfbc1a91a802a67ec9d226c2863ec356b313c157ace287945d3f06a0c4f0c7eb570e1401d7e7fe1f25d4b4956a298011d55a61a9431ea2b7e419956d7a98aa5b7cdeb7a55c40230b1d7ca25125fb23241a8fa5f6aaaeeca170f7ac70f065a2c85e801e6872524dd85c41fd1994abfa738e0fe880957ef98aa5d82eb989ad6e1b6b8da22cee91bfe0ed0347922df0115bff7537175a619c9507b05662e7bfcd3ff2206c09eb6b72ece07368c4ad62d481eabc611fa05061b9213c481238478e517ac33b13f2203ad0f4ca1514ef07eefaf5abd477e6cb6eff270b1e361db231703f5ca712a78f3790818360b8898aae8bbcb3dc536b2ac44e7a55d567129e5c7f348be76ddc77c95a67b7bb6897620f6ba29532213f3c6275a15665400be1d9baae70d1f076aef05742394ba87d0c34bfb2616dba73086b7005acddbfade01f5016675a127e1be0be221a200c2409c5e964de18f7948c5984c8be69c965a55da90b3dbfce8991677a01a6ab659a827d94bdbc50ceafb5702956e39f417d71fdc8121db4685dda1eeea81a154737516c865749376e76bbd4e9eedb846d9ca79b3341f7c93c520b0396fdffdc7f2a6bf3dc6502e6af7d4d4c7fd193f1e5bf732e63f9b3ce169bf4cbe6bd14c0251a67192ea04d794c1205cf0a7c5bed40beb64b410f11296130e3eab4f49975a7d361ab5a07780c67855cfc03fd79b77244c084fff51dd748ac863bc75e8710ef6a45b463c206d8dcb7bfcdb297e8bd8c7227ae3ba8bf4fdf85872ed439663b521f1e865444b5d83deefe19af6926a007aa3caffbfa05d46216b619d59f8c01e28be03bab6fb60c7837994d41f09a1f7622b16073837fb568f9c6716807eb986455590ebcd710352aa8049704080e083090c1da52626c64214c8b15672ad102812ed74e5ae11ddeae93a09e81d4735c95aec88ea1f6b85427289e4c3d4f8652ade6c8a04e5c8f017e7f347b3028fc60a0a8c10a7905b8cdd9d7a6b0d507506dc80683561b2d947aacb22d5713eeec2f36ef686300216c473b45d5e29ce11c07214b5f595803226d530fbc4c79fc17d0663613e3a17259ed0fa8a2ccae933d3cab4dadff693cef37a1e77a66fa2bb86eff0fcf44350d24ecb3384c3ecbcad25e35390e8f4d56e9902fa88d12fe8b345cc2e30c3f7ebe49d9f3ff23766f9b14857cfaa066865c6b8f1efac221965c374072364c155a26b71d71fa66d9e8eb909dfc6debb587604756a3be24a400c44e30e29a61a09090c7444439eaa62909bb983851d4f3cfe49ac5dd447096fb57d33000e71a586a30a6b381ab461d1c31ee62669f025e14cd33e4bb8607dccfd805123ed3982ab1278a38d9c98dd7db4bdd6b445ec5a9b9ed99889e91a1fcdc0f17324c6a635e975f38906a691820041d6663b1fab31abebd576194ec6174dccad82c170cc942805575753f4936d7e04b7d624ef9aa926be89e07e60ea7d57bacdd36cdacec833e5391341b00d774579847f7fec5ccc7820aa59716dba319d5c35b8fd959affcc1c922377bdd9364f8b711834cf0b43a1b83855cf360c338d02b325ba46621a1f6a57c7f4dd92f44c5b33c8eaf4f5f703136480206ebb6601d63b46a61ad4e7d76aa7fb2ba29e6392d7ea1bc8c3601bf0bd7007c463c864dca51c3f3c16d73bf77fc1b843a4f9cfae7c0fd368e195bfc437fedac583b15d10381fcd35381e70a3ac5b5aa6c266e0a815f5dc298d897ecdf50e3475ff4f435f6f3ab75db29f71ca9cbee19ad124501f77ce1f386fa29c44dbb1673015c96be83a866e6bb0b2b9ec9d6c59b99c4ca616c92aec4ec920105e5303b6df050f5fa1e816590bd6b38d38ddf6f922ab4eb8b210026d590445e8edb31b8bdbddfc1e7534e2a8bf07eaf975d51e9d4b7144e1d16f9d608ab4913be38f2e453825bdea18e329839250b2687ffdb69cd698f3cfd8cd74ec6f43d95c28e8d007890019a89ff592d9cd31dfafb52c411993c3a4a451871f52ccf865d5ee3c33ca0997ba65b280ae833829557f86f8871ad775087d4c767df7b7f995111e11091a9fea36622b92aeeb02f4911523ad917020d4fa7ac8adf6c73aea38c181c14e0b4c593df7c5647751bcad26ee358b7cb67c04865f49b81353933d84eb01ebfd7074be3fb5adb725c620080029a62cb5787f162d6336d5f5015cf7f814aca6d5d44493b5c0badc761d6c36ac57edfd7d959f653e0a4dd43b8789a4e613f9a5ffa2f3012f0b5f20acdf41b56428b5244981921d04be79d89e70a596eea386c906b53aafaa690576b3b081bc04ff07f9fe478cebc2a05852f16f1a8c070a72ec568c6a0be3d942af6f93bdbfbc3e2e63ed84f359dbd5d83dbc2cc4bdc5fd9af8b7768ba0af1b21f59dc650beaa8fb9859e94c7c2ca6d4e8eda034050066fdf0bebd95042649f84b8f89c7f91424e0900c54234f1eceab0cdc1ac5e7bb4b6a1de3b51c71a2797f8d41f3d8d12feda01aa15bc3e4718c00aaeea67d2b6befcf4bb0025a4dd3535b7674938fa30dbb97d4848b250a9bc82b3a445242d7206a92eedfdefbb57960d8bdf462d29ec54023e90dae35739dba2c308e09c7973334ffbb7b3cf2d74ed08a2ee2881273aa132f5826ea3ab97ba2cc422841163895992f54fa0109c9c6397b3ce80b071e5d734f9b867c36a3bfff361ee2d2718c19daa28027bd635845480d8a4ee6d1d0d8cf3780f5e554739a2323bcc8dfbd144a9740472e856c1af2628332d8dd87509b71cf63d38abbc705c1b9ae87699e6c4307cc351bb48026225c206c334432a4cd8033ea5f02e1cfd1ce0ad5d2e6cff0f58ba9a42e4255023a2cb8c8843f37a19fa632e615e3f7a4d8355b9a2050625d4642e77701bdf29949c795d26c99046ba45f622854b0d4fc8a243a1de1861606975d56d150e95af5d527999b38d43187885b5d67b1dd2e7d9b6c13845040676b920a21386f185cd76a9e84a663ae5cf2833eeea18156fa3ef2213b2db64efb62fb7bc4298c9689b96e92ede821cb0fad955a5c2f6b22471252e56482a624abad406b2c90966e7cba4998ea19833013fee855b07c87913f8e2d2d5f3f46b9040507e3589cfd9458fb7e7df05b306fb09164a6366fc5d51b7aadfc6e6194df5575c0063969b988839b84a3cee44beef7b7393081f07790e767131680405f19e196899efc4705ed44ecabb03af4d7efcf2e951c8f8e39cd109f382e6cf37dcbf72b9451c4ad96e22dd05cbeb41eb6d0595de0e74368b667f4ea2fd99b9dc3481862c972fca8162bb22aaa2795e7662b51230dd98974ac504fe9afbe2b3d9192743e6d4b52f422dac6035a35991c5f529cefb4c1cf448d2e1b05805576e767b0fd5f954371ce377d0f9230d2fe94076fbd91d3bc156d104a8e9c4bdc145341ad4841d01f20f6386aa689f651f7409e7a6dab7b6139ee3d3553cf8e2b8a09428a93f01e77919639a2fa82188cd0d6571a4a163f7a999437c912bef58025f3227bdf7a56a6783d116f66b1726432f13c5d0921b4b65a6889b826092f741dce2bf003a7c10764b01a887cad1eacbeaa4ca4144b0c1007ca03f50e6f5e80daf9d38c581af31198a852b153f9495b0f14a19a96777f283a4632fa2e09c7389eeb87ca98f0292efb08b33335946389865e36e547a257009efc74286c0a07340c1416bfad2e46649ab4d598d16130f4010280ef6b01e5369071c9677f33750c09a0af9fcc7e3bcb33450f2cd38d43c0ab2564b409f8d453eb2fc2b76b5fbe9f4bc64e103513a75ff46cec1d6d58b633dd50d97012527fc6e16da2257872484be5203b9becc269e44d30394efa8ff5f081047d4b517673818a5bb635ee1551818e7b336741c422d38acd4bd32390e58b6bebc2acf26178960575fad896b1ea895cce9e339d2fa37fb7ca81f80145ce1ba8e1a0f1fec6ef8d3376e316709444d35bac8d2df092e46bbbe13562f519930ea97ccfa43394a67ed1faf6c37b6ae3819b7f0954f7dd13e368d9891322555070106dd1ecca12d49c1fafdf4b9abab4daa42d19a6fcbb7fcf0c38f9ff24e8e68ef851eba3228faeacf219ba67f4eb6889786a54a0196f515f1d35c5fcbad8c1d460e6900bb1c57eb9e99ebbbbbab459b709e74787547fae989520ad61b8cf75b3ece55cd71cff2f2c14309633e843131be6275d6dfb5659d5adab37d82bc37fbc8bf49a83071baf64aa9ed4bff5b97b2fd17b6da67a3594d74c848cfc3aa58ddd4e55355d0c862408de12a409d72aa3bb1518132980e4e3245455b78facaedbd39c9306c0f3e87843b6dce469fefb63fef0b54a760524b0f4b46d998ce629e6e7dcec549d24d940d7805526eb4390d34d61b507fb979fc735e995e2a5af6c3c60a26e6ad882d7fcc342f530401f7362d8fcc92865466257db1b64648e2d62e6842e853b4e640390625dbd4e5b3536842c72862d904c3580d7a30c6e26bf28cd81954bc1d1cdfe0529bcc1c2dc64ed3311ec1e48c8ca3f4bfced60c6b11f77b7946a8aaec8d8734384a66e10b00e36a8dcfb6822d58e6da58ecaf516c659bddff47b095e187c2b01d3953e7d7191f3e025b61b090b468117244d68e9d7f1c4b2b05497550c745d99a0016bebe9a7d32cb9c1d382f1a72cbc781b4ae92eb1add40e800714b892c03010782948de547428525b532fceb48f0319d7665bfc7310371c1d6324b60149134186e8dc5aa0576a12e351787a82e3b4910a9ecaf2193a1c5f7669f6d7d8bce3489142064a086c1757a676b70a3f5c06fe688657293243cc21da7e7ff2b694cd978ac86c65e4c996dccadc033e1fb0d0aae16586a52b4a28f4188eea61e5ac5b5ff7d353dfe47bd0bf758b9447407e71235d95a63cf258d8467ec5671f1dd89e3995110b43ea86585559620d8b7abbb6aabb7c003fc5f055cc6a6f373d16754f1a980c7f07fcf930fc4e4ea171f6a85d576aa0d9541ca5cbaa91f326f3065fe360d34414ad84f592612d23b1664db1ad6576b805a56545fc7601f8d3167c13981e6bf6868b9b1f7eabd6264eda95420ab4512960d0aa1d6040205d9bd24a72e140665db6bc2d02e1d7094dfc58031e2a0137ce0299326929a136c25452a5c72cce6cfb5ea7231797077db708d760ba151985641c67dedbf8e962f3c72aa5edbaeb6b989425761aff654a8e3d2987052565702ee26d85b67648c71504a2750a9f226d5e196ee23477b046003147e510bde2463ba2cf429ba26ed7b151980ce13f1991801a7497eac0b18186c34fac35534e7ad2ea1b1f841ae574c327022ca419433b9e05ecb5c8d12f5a0682efdc9c02c0645154d30b41817f362de0e905f11ca0d13e67b6eb37241ec864f87052ab380718ca52e4b083435c41bcc87d5b60b8a711d4464781335b1bf587dc2584d2d2dc08cf3d08fc3372872f4c35313bec0aad9fd4122a3c0944bcdc564d772c606a70f2baf0f74bc6389cb449154781c6c8c2505efab80950d2e4b4605d5e87b3485e230162b278fe295c74c28e87dd67b7b7d810c9c3db9c766fbc00b50186fa52dfbfc465c282957005708899ca06504324cee03e957be5660cbe4402a4ab9b15306501ba57af2a8b939fcbfa6dd31c05f88c902e91364327a2d9d927108bdfd0b1dda61939aa40bb578a2c946bc7c48b10a9420487c60288d2e7d010a56046f754244f441939262556387d95d4d5851074fa43fcbcd54dde93a12caea91d10f1569f29332ab645e0645b3fb7ff337a1faa856f7fc4891fcb7a475605d7337e2e3de2a96b2d638b80a6a4ace50b9cb065d7d7a71f21a9c2ef7f0eec2eff1d08814ff8a40b1a8a2f140fa029e0d10c58b7be0071cbbd2562d79807e6201d0f89a675bd0646eb486954e0ea2e29f164e7b8362afca00fcb0599e74de486bab7115228c6cfbe64612b052655ca600984f54967ff4dcd6f75c378e40d080adcb6e767814da3bd78473f2ace77f3b4878b9412c3bd05be985d776e6c15907ed1db074aa220939419dcbdbb7c1ac2016dbb8e37fdf1aaccce0efef9e88b46b7f3dd7fe9278a98c50d784818d2f738f04d213139657b2f2f92e007eeaf97b486dee6be09c7645aaf816d3cb86ed454722e61cf9bcdb4f9f0851d97a65cfdd338f312b2c473475fab79a04af109559f2c29c5057501bacdbb7eea2d674fb6b4263963eee92f0c5cf5595d8e53808f116c8abbe1bd2a428509fec532a108aa7997351be1a2b13bc5cc750f7797930ed1eb6569ec3a7ac9a4afecf3febf1c692ac4cd22e0559b1f0e110f591b81d081870162e2b33258a58bc842c1822001f56fe62212169df6fd0f7360cdc844b516c1af07221faef5b07455b3634c1e4264f7d85962c5760c50d6935edbb3abd3efb3a50383af616a2d0541aae4ad7f4afa1ced051c3ea9b564946f16bf046ea7214d303c9c677f2847c76638c6387abfb709d8879f7fdc99384eaf9fb76ec5fe23e24dbd701067ac29b720ac3e38987d404d72e51c7a443549011cbf460545b7852314ee11dc3d91ae2c71603af160dbf8d6df223e18c04453f118f584dc9a07e662b523b647a56490cbe8217e253031d123c767b3e2de77973089da33d82730b3179f74faecba36ec3640f6c8eed51a433ad113776b0b987c5dba5f5fdb2ea5d54923dceb9a34a6642cd0df0bf3be043f1a557620c28a99c47eccb254bb6d484e2628a5768ac2eb48b27c268cf81f9e1801910d7956564e510dde39c11863aa6741df45ef1556382e790655b85e6d1243997dd11567da4882319d11596b6e322aa7013e70b07c71987efec8963d30e03e5d75bffcfe283adabba1be74263acc69b2817ca1b246c8e36bec0af33f0c25621354aad9b9ae6e47d84f973b3644e7903db114ecf829fae90448d9c4c2c9f7c51e9dc63adb4a589c2cc661fc8c7cffc565dea33ebc8a003da935f3f2ea91cb00fed85cf4badc43ae879789ae7b9b9bc15e5c9e20dae0382fae6b680ed730767e02e5b013cf705657f5728b3cef140ac8341690f10acb14bc99f353fd6eab868b74fac30495ac108062083fa339753efd8e9b933dea8617b8817e1af81eb4524f4447c21c8618bb61807e2b2f7a98bab49486cb4cca4b0906e761c9e4f507948e0211650b6c8bee6304c6c41c6d6a3e0c00a3dc5b81c5d4092ebcd5371504a6cabca555b4facd86e2c09ad6e13cd5e6678438bdb581c5ad0b16fc076df4de645b46c5de44dbdd4768794f4d25d0032b66f4f509bcc7cfc485cb493ba46628a72b1cdb1267758d42617f1d5bd8565cf4f983084d87db1a31a08067d55a82490d0cbb65e1da614a70185d4346a5c1898d868b4a23082a4f3081794b3b72bf6a8f4d9dd0b4b2103a36566a07304ff0f1f35cbabcc2b2bf0ad55936b10d38f076a9622a22efdb1d3dbdb75946779f6361749edb980293b54f71478291b27e7f15024c8a0f4a78e0289e9bb1bfd14fd1ce285936147fbee3a0344a3e877988ca1dd01d43350119be192b8df1dab03af4b06c156f42830eb4489c5e407a492a8c7af58ff085b0c17b986b71fffb3f25431e9b6276091a252277561a067aeea7b5ccdd155bb32c6eb2b687aa94976dd51b15177c9032ee22a1a7f8eff6726863cc61c9857f94a23b2bae4e118719e75075043a347c4ac6da927ed9fd08209afed18425863f9d59c043cf270d0fbe3667601019841cc48a9fbacd8ad2dcdf40087271ea7ebb7de79903ccecaa4e26604ce3f9d57fde9015ce1eee7d130c88406616a592cf97aae65091250e5ab12f74adf0772028dea2fd7796b79b101b72831f4d379e6f3120503bea6a43a5339091916431b5487f560f72ef4b90fdddb752e9eb3598165b922a2428d7bc44d2509a98e202ef437d849cde51db2e2a571add6232f7c1cc9f5584ff68a9f7a6de08d815f1b19715fbe26dd38ca8cc4d35421190c9b5404b57f692d1e91aa87bc61152697a1275d0764d53ff1a36772add750bfe1fd477307df53ad503aa905a92efb88143d370e4c23a368d267c1c9f218ef87586c050ded2525ce7db78c08c4d188793abb483f30edc0569f767d754f9bbc6e02b51a3392bf3a3a29d6bfffda107b650584aa4257cf1e3feecfd8ba9ae32616c41f77521d5337aec418bab3233a21daa910c0d6caa6712f5fe73f794b65cd7da3f3d9096ca6612483d1e25029d9a3237213b972523b5d0335f71fbf12ca47ee86ef90e3fdc215c1488b8998d1f2a62c0533c6d9cd7d6547986f73111c68c62526535b9757f9ad0c5bc4e7a7e3c0a56b43dfeb43ea16e14465a6ff591327c6df84fec5fd0f4fba35198db3e3520903dc3b8f34b7e90f6613fe168f4493ae8fa539f1acdd3c75508cea3ee588f73b7669cb7037b0a5d3997daf10ee6550c420d5a3a945bf3a903601177441ea54ce064d8b06e9fbc5762082a6c0ad3a3220829fb26f5e7544774d863b9ae692f75a93967990ba50e5c346be016f5668140446bf463c85b3c3221e07e68e6a3689a7dc56beda49185a861ddbc83e7752d4683fbb5899de52584d81be6a144461bd9c186417f38f7daa00e53dc019a100b42a7c58d2d8803e809e0afeae47112a42d66ced8fa9ec4a04cd459aa0aeeea0a544688c2cdf30d80c19efb3a1ad3285994c7626a608535f3cd3c7039e5cc2251faeb266529c8c901a83f6a27e2bf48ad839149b6bfcf1f7d9783c07012b22cac181299ec6898b920aea4982b7d617cc40afaf2ac435590d377b9bcfc08d13117a5c97660da43338060ac8cd554427be63a163394e1e06c04e40f41cade6226bcd39803fa47e6aa7a6eac93b72ca3078ceed53c03ddd1cfa734c4496da1a147c81937eb3ea091825cbb89da474b25ccf7314cd375f7943805fd1dd4cb451f019aa038c21fc9116592aa1ded529d68237e7e3380b750e2cfd11dba2d6ce379cd3adbfce551f589c8f2424d9418d3bdbbbed3513c5941c9fd0a413177dd57c2fc38f1a0b67ce28f7b223e122082429803170db134c0f9372fcb8f2881862d071f8a439dc54d1bde38b17926324be5553980ad4c8396cf85ff6e90e85aba5b5f78f0119e0f483bd246c738e40e8a7e813f4eaf288d4d498d26453e077b5af015fa3957e4c425f575d557fa2678beb4048e0a5778fd2a81fc98a754cabc39abca2daab2aba23119c3c68c7cc78c5818e7ca26cc2e194f8c194d66df5d4fcc150dcf73f5eb90eae87cfe54dafaef07311dfe9fd40a8ae59bfa864ed499cc44d6e11c61bdb6903fcef7e5752f00c53655f0115b3ad3e6f0dd849dc79ad166c242f82d34619eca22a547bfa0197aabe21845e36ab05c3856","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
