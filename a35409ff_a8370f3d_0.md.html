<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52df48e83d1bcfc181bd675eff5b65afec472ec8065f5e0eb965e4f3649b32c167b4d89b1e3f8052b9497378ec64cfd9321dc8bce072e2d6c025f800b4eaa7b0054af614cce9ed1b3211057f219eb07020c24e97ee899acae58490468132a43312297e3dd27b4b52aace4dd36308f0b484dd83e03852c60b54a2c26f5f7eb406fb4373371d7a6782d3800fdff46fc6a69c19df703820eb5dd4aecacd3987ffcec019d037c5f7d3aa0f48fc75fae4d3cec48c27955c3113458e958681e8ed8f73fe24c7270b64963d4271e759c2f6b08bba6484faf8567f28150f830742132c9a666913b30af0e228fa0b351ecf5128b69a8de45f68de94b2121d76027e263a0c81f3352cdf00580be6e75adace38a73e8bfc6c2f4554b986a9ed88d238641da763f0ee9515393948a8f70c9fc503e9e04ce224b75674979e7b100ddf6902b39e1af2761eef556e08829c36b8e14ee3d5f3f6a3f85c6764022563bba7b9196f670ec40237120787cf3dfb12cb8a1d17021229913578cc4ddc88b4b915e5110673ffcb719c6311940a4e0fe4e4c2e212af8147e31582f2a6b0d22dbeb9e3b88dcb79d3079031cd6411b07d030f44c482208bfa5b1b0c16dddab9b87dc2b766b85abe2dbb71013910856abec86209dcf46dc1074ab11ed4af46ba2170d208f6a56cc1bee7b6c1c9d8f22ff5d19837eab0aa5b616d6676dc0cfb66047b7e00637bed052d7eb6006ce62e3c45e539d4a326bf5cc5f05b309307e79187e011fa26e22e774e567f3cefcb24155a2c99eba881e44c5d5ebff65928e1463a5515eab1f453d4eeaf3cbb0c3c5a83eea4d71e8fefcbef49c526c29206f859ba708b4ce43548f40674ab78490b41b8fd936664e69ab5268a3c3520620e8b96d31705e29645a5bc0669d8174b24f4b9e90232d25ae434c8148bcd230c748269f14e66da44682d66c113685822d158319e8543d5baeac08fbd2ccee3d1e5ae195a73b6f24c5a1265abbe87c77c7236286bfd325d58f4ace3c14dafa300bc9b708359991dfd2b238667ee0c20bdf29b5c5cfaea0cbdcdeee82c4493b1d3db56c336ff66ae12c2bbdf826fe8ef613a402f3eddeba1537657629031f1b3a8db6dc9545b16ccfc478c2cafc492e6c5835a714b739338903a4aefded27dd7dcbf7052528579f0d820ebc247eaf0eaf2e4ed1094810f9e5fad987695f1201e7ed6203e50611cf8a50d25896f62fdf0e5c40c0dd6e562f92b0a11567c087a343e33696e3613b1b22a4132206d7541cb3409e768aa272da15a2692002fe3c67f8ad7b73db844a416dc14e971b64e17b957fe02c01e27c6f2871dcd9f4e5bd431ef7e5eaf58b89c0831f12c81a318278f576572c79fd44d30b0616b1307830b9633d3ca72d76fd0c1572b76654c6f7169f5282b9891b2e394403c2c6c14607a8d12796e23453a7d4ca228fddc6032e5bc54004df6e43bb28b7fb2075a1a921550fb6e9f9832eb56f47d38d3e5f12e3e773a5d9b5b57390d5e547d2f3c4ea106ed7ce59a5e6a63ab520dc1f8db48c99953f80fcf1b8d1956300002284082dd72c750bc2be447fe6def1c941924b715f9279dfbf851a2872790301a45c536fbf64b3795b7fa234f137cc53caea08c83951f003cd62efddb236bf466f8b77483e800c2384765faf9edb5b9fbfe5611505725ae23d8340cb21bae5458432d1d6e88896b4e52817565bed7904313fa48499253cfc9053f4d5f9461b3d4be0f6ceb96c0cdaac1a7bc5e6d7ef97000455aaedc893844481adacc90c654076c87e0e1c8d60e30211326d85a25c27d72e4152bd93bc32f10a82911c5b9d5d866ec3876775a8d2e9be2218fe68f27e978cd2b14a876b87f6417e0ff6b7abe456248baea564ba6a38139e2b215c0380a4fd2f2d71c2080aee61f17263f48b01802995f3550216b2b42f995c37367b14ce1785de3f441b845378c693b067f53859b8e389d108b434c59bbb694a36ceb4045f600d66f1c00ff451b57e333b76031fb084e1e2c2e7de55ac37cd2238268743881f7b88fcf9c37d59817e9caf2960910d970faf196f28bf0870384267c423e301f05b564db168cae4651b53a57022fb87ebc10fcbbad6d757170946ee0595ac8a7552cdd6f1123a51d0145d8ea5822dbbf88d834759ea62cd55b75b4d38502805f37848e0c8b6e7ed2a330151d4045c02c94c5a78dffece58c7631f141c17aafc9f2fa5c4e7e86c91ad74eb8ee9cd995e7c114d79efe910b47576f401632bd39339fc847af613d2abf928eab7815cc7ba637286f3628d798e17076d8968c8cd37817a2a5a7caf7991507e878a611dafbc108e09e1fc03621844d83cd818393a06779aa807ec2b13290f2b54c228b351c4a5fc61264ba1e4efb28fea63505886c5f0c591862c9f4f87f840a69232379a85e18207571b5773a1b0441c20cdd236018d3bd2ead86bb58db53fe1659bc933b612710443df2184dda99639b38b5c9564eba17948abb52221c50abd0a4360e60e9a275ce3028181632e58815ba08950b1a4318fdc6328597f7d3602cbfc1cbbfc3852792cb507a7d8e659ac2ec708bea7e937ad46075a53626d0ffb4e3bf4f363d3c79af49103b41d528ed7272f04f7fa1fd7c62ae105c2a90730fa6b8dfb03606934029c396e72fc28c87aaebd8911fb8ff64c0e78e5f4636eecc4ccd16dce765453071ddd0f2962d86b8c5a381bd3826920053cf99e7cb4393f9cc652a1e02b4e39b9a135fba48401b33430e880b5477f638e01d07ddb80d141442534e13384d3fd41719d0a09950c74f218197404668270bb57fa98fc91bd31170306a65eff87f1684eb64cbafac9dd25e521f26a4b3ea9f2adadad94b0407daf7c8a9ce03460dbdce74668904f0e17c9afc7abf6541ef19fcc8d02442c18bed315a21c053e80078c342a4894edfb9351c94f0f8eee0e53a1e681a63ae7875caf0fbaa78a8e17ca7fc8ddb0c3d8fd126c0d8349845fed5abc94a74b26753468fec3e2899aae3d612272aab6b250b89575445591fb94a751683f367e9b8fd504a11508d2d5c091e78037930883acd9eae0f6a5757a5795e2e6a539505df9bba3701937b1e9f932e7dd480a0139a975795fa87c2380dcfa0ddb06931c6052e237fa431dc9364e6e62a9cf0f5a444582827a4f7810b2b74adfa00e640cadaba2e904a828f07d455410a9ad37b930a8a9864ed4a571132c35372a37c8d28b91176815b2421131e787b40389d90548d437ab740dd2bfb9b09213df377532a2535b57200487ab7bde13f0126234efc5bbeacc4edec963a389d5c806eb78980b1e8d322e27c767655569def6aeb5ed7c12cbba1f825c88a9cc39dc9fdc2dd0eaefd08faadb3d718edb3ad789bbe41974be38a079ecdd50a4b01877ce852d5d4caa8c4a3bb1ab52954781e8c1a47d09b102b5b3fc2216350120d6260ed5f06a20eb3f62b18bbb318181f803d4e8727194d539c7d4c8bad688485e44d657456d5999e5414135063ce268fcaf7e45164309bd7a7db52383a4401fba187e882b55d126a491b38730e0f82019aab1240fc372960a5b76376152ae8c329bff7212a365f872fb8cb0b141d1ab86bdb621048f2d14da169ba729d8e3be0c6158fe4d6af634b1af34bd8d91fde6a7eaef3899aee2b717cd493a8ffe68bbd260b3385fa68f22a494beebbdae7fdda9239610718a67d337537645759cd93a85cc2ac531e62c18c6f618f3b0c7873bf70cc4eae6d4382d6da16391dc69db8770070af4bcc7f2605bac60ce2c98add68dcda3fda4b925a1601dffde11d69e2858554f15ed6fa5c5630226b0a4bf566d8565ba95e0c0d06e5c2bc95a9c0262ece8e543a156e5ddf2e7528b3b140f30128100eafe9262a8e2205ae1039988f25f4172d9e7a2d3e5b052ad95da575a5bfcb7299532ad6a4558c94272586060d13a6fdaa97ce12f7920463bc01836cac72ad284f601465e5db51e3d8c02f432f42c9dba7a7fec487fcbf56298ee52da14100f4360bcd2d2170e3c9f7b4de2bf83796df3b9d4e73df8c98426c1a0f9772bff2b1f8ce52875b206c1d468a7407bdc7833f4dbc1128d2e33a704ee6f6c47d0dec10e07bbe5954bf2ce78d432e510d90237ac883929dcc4382b89757fa9520ad6a49c94b8cc9479c93f05e69d4980e42903b94308f1b2bc88b575b1f6086d5780d0f94dfea6dd9b90bb8c501ea2a9324ecd88a46f09d836076b240a4226e475580740e9a04adcbb00b54eab3008476d30b3e069283ffbc0ef69d2d62d329271a30f4afc4e62466a26f49d68f40e08b07044649b7c703adf1180aa0f00938e43f574390ee9f8d17e7bc681770b67fa5aba1a576eea97e3878c33bc4066e4e30dc39c49c0893f5fff3de561ef3df33b58a3cd3a66df36f4ffa0a227a41825657117d709684195cec3454a6f2f88e30b23434e82273ec9ad5e911b326dff2c4cb2a880bb4d2981f35946c18d5858ab7187ab5563a20705546909d6c30310e07a610f89ae5ca9648d9077e07cd093e914bb54049fa7ec475b698bdba6fca5a2e79dedc067ff33e6766b0379016a1ca11eba31e0f42702dd335d8ef5ad3fa2178404f0ca9c96457e0333c044dc6a8dd900035b28ba375a31322f2503518252d6f21fceb8d21c31119e149a1c26f477f5e762910e7cfbcde721796e9e4bab95b4ebe2e491da07e2b74f7c9879280d4399793a823046262c26fd1657e0717bff9acda5d07eaedbed1083df6208f34c56527be6784027aad1ce3227534c809410efa3f649332fb383787ab2cfd6b684febe4b69ff8da53bb0a516360eeffd92012bdb98b80b5d7a625882afdd330e58879e3373fca093c2e21ffb3dca165798d87fc78420c49b364ebeea296c11fc61983f98d2bfc092feb9530732da505a7c45a6b6af74f023bda0c52cc783332200f5bdc0d8c620f94b97a4339df508c4cdab7cd521ecca7db1e36c9a660ba2a66dea8e03bb6e43cf1a4be8c7442c7dc21d8603a1fcfce1db61361a3fbfaacc15950ed651bf7e733a48f94b392c8963059cb6ce8e9f468f4c7bc89a0b322a6268c6ab5289f9ebd55cabccb34550dbbc90ed0dced5241f91af7553d9383c98bda7a8a0598ccebe55864848ed134d345d80598859e368aae3a3d53469e77863d519158090291693dc795158c12fa42aefb3a33737ce98cd8a882ed5287cf7a3b84ba8075f8aaa8fc065a74dd67ca9dfc23733514ae9efa114432466a386ed2383da2b35b94e0d7cf82909dfc64c50ed6b57b5cdef438d69b3539e188b9ef34b0183471ac9c34e23febc112a5e648811be81e0b228c6c2401a1afe4b3995473f95adc15d5c35ce236976a8006ce7390ecdab7d7fa7236bb93784609e6c457b560355a25c40fb26f5a06908d5bba66e6beb44bb246fc9e9dd40c9e49a82e8111ed49dda0577b882b4666682a40fd06001e594aeabe0956c1bcb9db796953f67912dd3e761c6d94f5981f85f69db3729ccc78f3c6afd50a5a6e6eb1971d0087475a03b1f492d52f3d940d75cd1fd1b908d97c69af4f26435c5cf6386661867d58ba3051fc1d3d5f7c539bf71420f492f6b4e1976d12a56a2834809001bd5a23b9328132f06b4242609ec7ec7ea88a4dadfd81b6de3d62d2ae7d4c69b859284587a5cf19008ab4f386d3e89a9c7f1e5c662d2c36e712bafbabd4fb0b3d67efb8eac96ea0102583dd40504c7e04ded1d3d6cdbd2d35747058e6b83cbe9996d249dd3f7c6b5e10ce485d3c536d079abb3b964a1230d931469954f14c85f07dfbaec82d8d9bd77e19209a8b7bd0f5ba7b095869d45ee7a19fa984760a4338e0a234998d1481e9e825ae16556aabc9c6046d41f4c8d773fdfabced7e58d764559b7a7b463f73263c0da34fa281a06788f953f49db4faacb030f3d05af9b595109b4918ac50397207142804ae6736f734263e6e34c408f718a73d4a6da87eb32d93cbb3001e50b635c7fb2104c2409fb5f5a23f957a49848d23fdb582ce648290ac13be87e2c87e9cd67a19b746de56b68652196b88489c8cd00320a52a2c0c394f32057a32e04aca21732c5e0461e92eb75b98d44d14fed97e76c76c905594338f8b322488f546adf6214dc301fd27a66f1dad2154aefa7c0f06da6d13a42b7706b89b81d1ea5ef9ef5daa5b4730212bd4d1370da9e377a0e68f75902a2bd0d6b9e58bac9aa8a189224b90f48a33908f34a4a3996eeb0656df9fed320ae7d14d057567b5067ab23ac65a6b0103a2ae1f846c49cb5eb7c0336e43b2c36320421f68da1d871d808baf396c3279f7dfb1ccf370452073d21c57e9c42a4774a315bd18b5ee788674060ae24e9d98d4440556d2570d9330c94c2540503ba4de2e9ed8616f2681474509fa3ae42edf5a95f3d9cc8043ced3f58e93533b381b5c6443a4af1d5f28470e7e0f318c9156c34b9afb1f945a7d854207fde24d91c3b277c6f04fac927a78446dbf17fd09a788e498e3f26644b9cd31a326f38552ad124f3641c9a7b118fe095d977d56149702ac315b16fd3f6f6d8e3cbeb47a9a8429ca1ef7f3d1524e93ad3350fc5c57f866a590cc9b8a215d60ac370eff1e20754576e9c46661f3e47a631d5420558ea6bf52ff6358aa1c4e2bff50531e30c65487b778c63e227ac5dad641e2815658d8408d15c406cfd0ad5997a26a81a0bdfbb9f32c958bf711cd08c012c02ca442bfaa696ef9f031966af0b85f26730bff2f0f795a7253bf4173a470006f88187ca30cd9329367ce4d7d4b5b6240fae5027718d548e0766c5481666858ec281c8511a4b28a89e2d62366aff903400155b320cae57cba0ef396891f95652607b811c2ade2561d8cfeb15cd62421b069d8c8ccb8419cc419332f22c368c4a7437169cf7b087382e8afd78ee04ea1d31999285e77656dc5e8e78f00fd211a83d5c5f47bf36de4ea2fe6694a051eaa1c9217b59f0fa5e2b3178fe794329a017a539dc3bdb88ccd52ad5122f7da92a863f2639920ab39a319d5faf92f6900e93969fccfc0e037719f8fed4b1dea440dde5043d5b6f8e8fe689929ecf1813afe61d11f3beab2c87f3341996a933f9b35f5d20fb07ac716a1f05f6e124a3f78257023fd625599946d93bf4c3011af9628edc6ba46fa764a84338e98795b5117b1186d47e49dd911480ec39145a8165ca6563aa96bd2484e0bdc88ab68fdfa80d369fb2101886442daaa1d5e5151c2c83f9b6ae83d6f9ca19eaaca3524e206bb1df13b3e2f64fa33cb7b7907661d83b6e34123f42172803cfafb4d9eacb4da270b41466c00f92e547961d96df66c15a677805b801d23a2b8075749fc080d7a9bc6ed836c84b1fa78b360b7ea0f2663e2768ab58a8d1567809e6e442d7f2bd780d0c4d82415aeaa1bb9f3259e7a903a2b0b0216e935995bbe4a8a159c2642b15f0a3e008547d22682f35f17724187196240c6240032289ca436b023ba764b7bb20c6a85c3dcaa9a24bae434ac2f0bf404ae60c51d64bb762e3f4ca5f8e8b240acc1345ac1138a4b121ebafc2145377643d993b79a6df74e0472f0a281133bd3c90d19b9b98c8ac9b6ad041a27ec14761f2e4ce7edf3f6f3e174627caf22678c04d77c9c3c80cd1d3b0bea4a223451c36382a110c72292066147de2a5b08955227ca9d0afc65bbfa1d555dd099b2fa083ba6c939762f41106fae7efa4534f47da863b072baec92f033fbb590090c7ef3c86f9f3a60d1ecc12df21e1bd2cb04531f52bcb6be415d19e94404015e95df720d787fe2bd6e617854243c68ec6b04ddd7277c87d76f9562bee541f90587ee36fe754031e3a31ae5130888f47896d42a35d0ac881baff716d4cd2416b427739a156b2d362eb761780132e4d7ee446d4902d3f768cf4de40e982b949296151c2e307f0796d6f1e9f8e21f844edb9abed1401adb7680cf2b05873bc4393970e1908ec4496fd57df81964865dc86710179c978a02bd18fa7b6bf9e5517b4d26cb93d7e91bd7ffc59ded0af665e4219213d6a8501fb6601345de516066b5ba0a63450bff4198159c99f0428e751b516ea6ad0dde9fa4dbcc67bdbcccbbf9dbddee8aef3a4eb702fd719646161e7aa3fa79aabf0c521f2840f1f51a7145e22fcdfa3261da6cbf9d66a48259ac822a81ad9318191b9aa7b43dee003cde04c06b925fb8b22b155c06b8b81fdfb5f5b148ed243705eea68eb312f5c1a31f42ef681137f009f5f6a23e05adc00d2048ff5e5b0a3dfcdb55c3932cd133108e2d2e5f9ba9f93f2b9bd76a194426c6655851b5aa6895b33271bd1c21c7cb499e6930a06d1ffb1bfff9b12421a217ebd273710571b1f455ebbc23d3d83aa2676e52107842ec2a11b819d861e2c2856d120b60cd4f225a4dc6b7b687bd8b24201428bdc36d095096bedbd4b1b12b2524cba98116552e56965231f55a17f10e3c198daddfb0f070117d097b8d0b16025b5dc83f25887ae25b648328a7a7d85593900e54b9147d937b0c4e07d74552bb6d88ee616059fbadfe96c9d79986f30e7edc937aebdf5e39af1517ef7f1dee0e32df91c58b0762cd2ab5aadb524d036b35f6474d754d159360f1231a1599377390f8b3f0b8ba1a95cf0727c2e1bd2c7158d407deccc6bdfc53bb4c225883d9cbc32d1af35059b0c26a31decb164840c5933e59de6322a26a3f7e99573455423d935870936d563ac8f19c84caff240848f6d06bc78975d6d530c3b701ab7053d54e163a228cde02ea58681fbdede7910e3759741dda4ff8034e334ef018cb8d7ffd89f9c0ed1eed7e570b7371851fec63b4378173b0797357540996dd82df6538ce05e482836e6ff444ba950eb88d1ba3d1dffb984696d8744d57a611c256b0a366dc1143b4c215a7d185d0653495decbb2804ed4b0796c4fd447a9c660c7a98b4265a76a608d92b347a1fa259716ae98ed1346584cd7d5b36c0470d45bc3ea9e4c57d1d47e4d29440bda0b61452c337d22f11474a73b11e67fe298f716e86c95a8e21ff8dc98d85b11f452eff8dd71ad07f79315a638d893b3bcc9ac4e36da4a678102a7934bd14758f7faf45e5ded91b5006c080cd23b688ba11f917684988f6e547c56b5e9348dc2a4bd8030fccc4f10516338498211a84786472280e9f4c98b1132dfa239b141179471974cbab96b0b3e9257bca72eda8476bc634532d65e49e53f98e0a60863b81325c705d351e764337ae85b4597537cd42daf88896a22c5bd9d2078ccd96ef70d49dbef86c7ca70ea3a39ba5f43c3570a24f0b0ee95aaaf2c02bb4af6b3c27dd63ba85333285199c4f0799441083844b628adab1afec831216d16343eb7b74038a993b0f94c698cfd401a5ebefb9aa4a3936b77cbfa17591470573b0fa3cc754f2726bd9ddda84868afa72c7a22ddb4849c70712089d1b7ae2d9e704d66845165556a0084c6dfb86b77bcaec570424b42bef5f8260b7d4129e623aeb6d2b07cb8ef945d358f8d7a790f6c36b04a69953bf9538d025231ed85c1b2ad9639407891cd480abd87f6bbc913072357a31a8ddecd5aa9a8379933a3d64ac9c7bd47f3d663ba00ffb0c70138849de3210a65f5c3bed44547506d7c565f13a42f8964494b0a94ef6fc5010b5082464594ab0626102439b39a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
