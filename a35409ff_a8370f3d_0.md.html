<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"776b08378a6339f821ef41b2015df0aa4816eaca556e628cd83535bd044c23f6cff0b00d8c60a55978febce8da263d032fd2aba5996358ea906520b0a305e4dd30eb1ffd080e7d3b8cd39cfb7029933fc06f5a9eb476be2dde5499e3733286dcf3af64d0fee472afdce6dff57f317b83fd0c9c2b9a81fbaf454a3fcff05edb55e6a6de1061edf92fc9da43aaf28d65b72eed23d1569cb12d094447efdea8377063cc00e7a4b0f6173694c03a7bf0f2620ae449be1054913c7227150a3c7251ea7e74ffa7512fd148da7ad9df249a0d0ce2cd5ffe8a7f007724907731bbe2fbae6b2880878e419b2b93039c6cac211ed7135e9b236eed1d2bd1ba9e199f5477adc8571cd92d29b8c79d81821c806e3a833c4d0120c452f5bd4864e9e52574bc21e352d5ef02079cdada40cff44cac092b8d17f8ec215c9ab129dacee211d315b612a6ea0d6777b7ef1c0bf84692de90e82626afcedfd4fdcd896571f62bd1ed2ca13933e138004812fda55737ce4230ce170e605e9ad6d9a9804721ee03a5b4328fdc85049cce97b9956361e99fd8047206ba00ac0419022ac4eaa775752f9864f6449fec8fdeed1542d70a99e4bee69d9cbf562593435c37d186518f496b2dba475b1e882d951d1bf07429f2d23758f7e8563c061fe50804464b85e0958f6e12ce2181fc4406d68bd93582dac3d1ce276ef271750aa62038617239da7ab001d6d1a2ecd926e1b89b93ad032509effd9453b9882e04514150cfa6bde6387129b38153d6122cf4fb0604f391f48226831744fbd9acc99538d822ee7c21b2702ef0beb6076e74a31524baedaac9ac83a7f826ca5e3425f4ecce43e565ae1f887d30c183cde50ad7f80bc1b143c3db18edd8656f40d84d9bd20554afa87194a26462fda2278311d07c4f92cb79da7bf4cda95132764e4f45aaf895dd9ca2fb76f09a0fc526219a8453c9fd62160fe86817c3d61417b0300de8437d389d21e0e9dae9065bac3a7823080c136bbdbe667c4e8e940ffd78e5ef5ee847d96c720ff90f52bc1fdbda44e1a4abde7526187c9cb8979a4989f74c6f06e39d2f88703fed0caf9e187d4720af2f00626b4132d37f83da62f95a14af27f8c7ca061a1349253a98c89fc36020cb64516204741c2ed4c20c2214aabb34d3708c01d5670b3986ed166aa00c6aafda4366e1e44319e881b459f172c71e333b682d562feafee108a2316e18372265468dc166a0e9767277daf7ed625a1e7c3b333904989f3f07edc2e441b5f8540e77f051686709b410b3092501b2c960019b25294f4053ecc0b840321c69882214234388e8ad6a18c391cb8c64acbe35ff154e39c9e273e5b0bac533f1aa6115d150cbc2c0198599268bcea841c7b0481059cef14c55c4542739a282c57c40d9c78aa78f325df7a8febbff2d5c560ed90a9c7e7548ca1bac1a6e38bebb196ee581e4736ff1745c00bacd887be8aa42519dcc4eedbb63e674b5225e29074dc37a58662eeb97c9c67b342e35ef1ce1e582ec57c4bbd1074aeedaa9aa02b5160b59708c1c65075bc94ac165ec3766b8e8e178b45d7776743a2da1ba51666fd518a0fdba102df92432eae232db00397d897778c15f7b37d85e8392bdc06c955793294a64a715afd161893221753490d3eee2127712f2b3963a5d3dd8eb46d8cd085448c4203987ac749bf55b13f90ffdbfe1d4329b99a265a9592228bca947c3b6fcc05c9c8995c138b1909f14a87a23623676f2ff25d77f28c6d63d8e84773eeb3bec85f07a50e17061673b5e433781aa136dbbb34d2de8d179b40a15b2e07e56efa91512ae38109685fc498b0d63ca26fc9671f28e9a3faa8a63aaff6b2bef657ba44b239299302b6d1815b0c6f4cabb54e50570ded6c2a17db7a315703a26a99ea79e7b662ab777103ac4ebbe9e1c281b41d637e660a378fc12d1d44b313763e4b1b7280915b111df44af7adc99dd03f9a8667b130749c98453675f7855a2ef2b6d0212573014a3d211ab276ba10f5710bb74404129a1e1d5209b61c9e8f2229131d0ce16b729bb4cc12b5e89a535ed849018bd8aab4335ff499106c617a382bd39f4d261776cfcd7b5b489c4786eaff2b604384f28953b438c77ff75a1093fd44229e3c4a5e1111748bc1f8bf2cfcabecf8e20d865594430040180438b962b67c87feecace73192d1fd1330319ed77838e85fd34902af00f1e2e46122b1faf6c7e8f5a787bc86d5c2e598c85d4086cd0412066ca349e78be333b38b5da109b38ee4736e8530a9b2fd4ed56feb2cbcb139c6686c8db7c31a328530bdae48e2ef3a6d8b9c7ccd5ecd247a1ba082bbe41492084dd8918711d7784df389ca7b5d9cb89db125eeb87768872529d3182f492079c3acb26ae982b15393f61b2a028febde0dd2cb9fa0f9454cc4cb4210d91060db21bc0a8168e5d0ddb735274fea5831b7516cf913d3c44ef1c895f05da1e753b4a14b12832498a5a1ade8d7522d562f8a041eb45aaeb6411df1f678592fc74db6b118d23dbbea766c26ea891ef410e58a464a4fd99cfeb3bf48d84da35a8a165f2ef96c20e9d9f9341de0c84a1fd8bb99a5470c735c682fbf451dec267ada33a58e3bd6fe7ad6a4655c6230248b0fe93a7315213ed9418c49502f5db43b4481628094a4e6b08589286e5ec7d9d1ed1a5600756300ea12dc8a5e9b7ee3032fb175f65a934a2fd6f69342b0f7658de0eaf677064892f53751ff53b79f588119c89d7070691e5f24202330cc4bff09776297a37434993ad7bbe9d019d2b4836aa435ad0ff36f44d26a4fd869c04209cc2b89e6acdde4e29fc099b675eb060545cf7275874ca0300d6941d6f1de1e20b89c03e26dbb6b9445e112b64f523a8b4c8e099120739411ebb39d0eeef266eb7aaa848266b44fe08adfd96386734f8a38b45857847b520e999795c48e73ee0a2dad91308042659ffade9a3d61075e8d9a274c76dd85a874104abaa24e8f490100d986b7af48a01d304b4e5118c5686cd43bc75578356398a58d6577c746fa9c4a3148b6719b409997e5cffed1529eaa0137f3747c5d1c8a6d02347d4e2275c1e84a47bf0689fc71030ca852ec758e2d29e764961a17525502f845f5bb1cd644e1ffdc6009dc1d8c9eb0e95a1909c7b4bd06c2c1d9e7af4bf4a7e9b79d03cf43f8241bad61c0a1acfd20a64beefbca520fde35b12a6ab7ece154e358e40d7498226cd889213b174793c2797109bbc15634444671ba23fab027b7fff266260b6d13e307f859bb63df449e079d008d8e81c064fa0e32d1cf2f97178f5c0056848c1fe4576ba428aadf20ed6c6835a4a35e260c24c7a7b8f71dad54b0b43317a733178d7db3c8ee85cb5ac4965d5a82699b5bdf9c5c797516fde118a001e366ee3c0ed80a9ccce3fceb5993da18f995d40a3e2a045e1cd93ed50be6b05d541cfb14355c838f6b4dccce61825cf716df99140ddd9e67235dadaf65cc0fa713c9ffa4b5a74c273e4e240da3e6deb34e31307fa8668563b2e29ed476705259f96f033ceedd1af166d8a3f2285352fda218b52d63852f0860ca925b3c1b91342400c5fad92debdd8f984cd1bf045579556120a785cc95e3aa598e7530efb4e1ab0b6186d8292d9c42456532ea9749512c7123a69b5b5ab61ff362d54aecda854dd90708dfa24514e785a7acab8a832c71bbe901147c2196bfdf45934cd3a442e87e1c1cb1ddaa057cdae9ca029f214021cf24f18b534883372eb456e4615bc288dae2c4685329e67b5abd718b83ca4896ab867ddb0a05c8b377566fa19849f84090caaa66947ab744e6656928512212f638ec681680f776e1a209a81b3b19680a3212e2aa66f6d99bc9ab0a30474205ba045de4500b1c81409b214056e13492b7787f5bd251319e1b0f122f086b637e7c04d26d9d10f842ca49d7098dedc7c71961b00dc2eb82f3fceb004d7dfc3a924d1702f4074b5bb07b936936f5b4788676a65494170fa1fd604810651db33d3e6ea64538ff04f290a9181c9d3c49dd03c4f8878941be8fc5a5281a58582389c46372daa5613a2a764fa47fe3876df738d316e7ba422dbf60b3fdd59a1d5eae3dce1144bb6e8f5c076b539c530232dde5b4b336e35f3e587712e33954ae26b00b69c39c2095a9a1fbd827cf852c217c74f242c08320cd8807ef9537b390fe608e95551884f13c797380b3992ae28449f935523835fa66bfae33da1fbf191bb5acdd0b1444f2b1ceda119ebde3a39da44b67b0e05ed08f590cde6fa94f87208828a7db545f598b52c855ee587dfaf16e058d18d03a3e899882785a181684fac36f598aac75a106bf07e57a8e61aa757897f517b938a0c995a8c1f05fe6ab885d3ee447bb9c900eab799fdb1897326b53ed521bcee236fb0ddb75d17a274186c47e92394d606f872701d4ab82a2efe5d9add1ac86e74dce561a681adacb4b6c9361d98f4b51d8e91ea9a2acb26364fadc7c00423d1eac533727f4c7eb4f4f3737fabf4547a465c7681722b387b382463ff8ff24d82f1833df34ae62fa5ef941febcd7dae74ea43a5ef4cf756b5bfdb509a8d50eed9838d890a1a076b312ea65f20fe7dc1d2d18789739adad4a1c1b5a0ea284a4b41bfc00601e845779750983486535816fb24c72324c8a4fa89eb9a5eedbcc9a0eaa8165fa69d50b11aa8a44a62ece018f37a3b12967a5d245e4f8b162f358a27485db0214096fea1c3f63a842e184e4e33d35b168c3909f609170f76e02fdfc052abb27d8bd802fb4585b1c52fd097f893aed20bfe663d3fba473911fff71b6cd5a7528dbd3849d8c8efb417279e36fe2b9ab00311b64ac9c870640d052a976dbf7bb62b71ad3a32349debb1ac9e790b2877965179f4bb1407829eb921b980311fd5ab31a456f941ac740ad82f6e30ecc0ed8124592a865b3536fca75238944f91d4f8e2a9e4d8cfb8891584eb615191de8616dca365d853399507af8d7d6c7754c2368ae834332dd2551f26ca067c84032e56b13aaa76a49c15ff2c66762bfe701418848c1aa5ac80cd0c9bfcf9d6ad7a0b015e42d8656cd3c81ec2c04904518f77ae0f581c26570500e9c523ca1e70efcf708eefe9658570854bb3190e38886a8d19625f8f9f427f3ac6e1db460950c71b61d239c2de78688fba5f8bab0dc69e5ea3eb051abe04262ea360bd079a8c07ed799134fb0101c9492ec6258fad125719d428e9f0fb3ff9fd634427e106d393b69006f4ee32f8d3b78c7c22d282534f5f71d6a5f9e3526d0291ea6bf3652222cd300a5184ae235290cd06065803ae033e286e5f4fb35c8e47c146ce39d453d1a2b8f9727c284ce6ece820d0192802f91d28de7d6ee7792112ffb3adba16b36b4c8a1561bfe9d02bef05491c69f42d28e4b3e766066f188c115d262391ddd4dcbce20a02a17ef73d38338b94f8b8fefeb9b0844763217990dd2539a7db857e0ca6e89957dc5d993e21bb56796b4990c92b4045e6f6facf8ae88728bac8df86053aa06b4f549961f177ab3d9ef0d99904e4bc8525ae41d0346905bcf1171c37c4910852c2ef278af4298ceb168cf2da7b2a60e5e01832ff44eed95362a5fdb912661cd6072921185eea5b0bc5144e2f8c735dbe2d0cbd59f339fe62e56fd732ac4d546892cb67c197163824470d79df73160376ef8cd45723b33e5f34ca911875c57651c4c324a9aaf11ff0a103357dcf6e826b2258661751bfa17b0e90b62abfa1ecc33b96670cd130e5ab21e3f4cc4c8db63939476d1e2aa35fec9c2f1dbf849a76f7e37947ac413ca13062ffc986bdbd0beb338c66abb383de7676fb7a777a23da424a593aa3af9122f1ed14dd0e5d93a53d3825340e02b556ab59daa01317f9ea7e5dded0ef28043008832e8390ebe562b966dbdcc7601bde31c1a95bba768e7d931d8225f4de783e778494712fce4a45f2140b306a812ee157b05111086b53f8764276dc7758a23e208ecad09c21fa9c332094a6b8c89a9929187d003a092f12f9ec70a928eb0d72d0c12fd5fd6d8f763a81ef2042748d962d8fec1a787a3ecf5d6f8af50f3cd456c31b645d1491c6bae12c21459b150653c730cde3559354c276030dfb93ecf20bae734c9e66d11485ea8650cc021d4ed9116e7328d2271e8ff1a00d54ee64ae6fbad57a760961695e2f95acc1003521294ff3371df41cb6ad93ee855038f8c0178df691995b5f4d2947677858cfbdaf62a06ae40b02aa46ea66e4ba2afd9d2896f91058fc26fb75028c0015ff1cfc22eef1687551951b7f729ff1d3d8b8c0c7dcd5ef052cc595d7138e1855876c1acc4526a0970b435cfbfb52cb2d6b6fa541b06c45bd61657647819cebf7791230cf5739ef2d554bb2b4f7696ec55ab5608b7267275b9a8e5ab31ebc5fa51181ec9d755194e15459328e5fb36db196f21fc94a3e46700922d7af92680c896eb822c3b04f854aac6159770286528840e0f4aed09982816e13d6fed9c114793504809a2eab6c625be7f7d41593fc5f4298e7a40d684b2c609a8d197dfe51a225700927d0a29be60958e16bfd6cd154e69c00b87c1e61141eff75dc86a632d5cc9a345676c550c6aed07d413074e59fb75eb3316aff99ea535c9421f7a02030a7d2280f7fbec6075f1788c8b1ee62f54ee83d82321a8a57aa3191117efabd00c974c8d63949c1beccc53867a49777ce45ac24d2574d3cdf5350c4dfdde27e658aa7e271bcb7ccf795072b781848419a97c06caa83d41adc2ab067ebb8403035b83912f3771c5a3e18e4a713e8b1ffb47de76f561452055635669686dfdb8e01a09da16b0050705fae7285710d5c0498369bd2352f5597468fc64cd2091509dc8f3534d74536fa2f82d837702d205753919e3a91ed40b7bc2bef6ed140f281d14967684fa72af4b74dafc264037e83897417af082cb449ffeb559157dff34543c909ef3dab566ca1e2ba5bc2b86c1c56ef6eed8cb55ee2f51c601ae35e90276ce17bd389878b0b5762b1f7caff54cc5275259c2bdd597a779b9d2923c52ffb0bf4ae4c4642da7b80d5a3491ad57f56917e5e0fa88352e64fa5e19dcc414abdb0541ddf5760755b1503199a926ce4ed6f65e9ecced6c842425472f923b25cc2395a2bb804ea80dd3ef84492cdde6fbb373b848da876afddf6a585c83aa942a6bf4794612d0f7faa5e8e6984f15e5769356825fb6bc7bc2e3826f88ad6f442406626412d3ddfaf9bad669121e38089bcc493c1ab758cb21f7ea2ae65d361b68738eb60f5421537ed5b126fb69bedbc897fc46804a401f53b80f0abb56b61187eebd79862a0f0a25bdb340326d6336833b02f1388ca8ec4e07d338d3195791969cf3c7666a32f10ac3dc99252b8a0b8c194d9af93b786117adc64e7bddc2f41a66f8a3fb6cada11cd92a41a77355b05bdd73eb1d4719d42f5fe2f041aef6acb54caa436e07f15f31a4f1b30907a2be528f879975686b617a4c9552991a5f5ae509c77fb10700375e57e8424786544fed013ac4a8660336c319abb112231cd18b815ec0363b955e72bea8d48aa3c62bdd7a8f765200afb61881416fd7bce786145926ad0a41f7c3a94f1bbcb5a0c8853b7a7b835ec37a8cc130867e936f8e959296fa09d31a5e7c2f74ea993471f4011802f6024ca1839a1555c25bba5235eb056ba46cb9f0cc2ad2ae3cb2464b7f28d9f6bd7d4d199919a64ca9e7a43c4708c4b32bc899ba2ef94347b14c5e079f7c27083736e7f05c7fd3290df387f2bac8fd5245d95cd010c345c92e19368edac0a78312a432a8b611245608f204577cfda2df867fcb138778897229dc93aad92152056ce4101ae06879e42dea0bea84daec5c9f4617f7ff13861bd9ac4ae3de878457fce4a808210b8e8eac66ba07df9b7b02ea3b5c597dd87fead7cce73461087bf4e93df1e55eb00a3ce1bcfeba872a31ef285bfa77f1e97de70069872c4e00eabf4078e9cd0680fa662d89df4bcbffe064e1fd90f14c90b4875d88eddd8fd15af527a95354d53b0f10676cf933f383a499c416686afdb9c7e3cfd4194c1c90503edf2c9b61cccf1794f18562ef39340a1138a9ed1fb4a183a79d84399c7de69e705d6be6aba6e0ff4aa5c751777cd3fa5ab3df33b6bc5ad07b57a859e310c7e7621fcad61508f333db1b7000672a33fb3c66a3e1b252effb538089dfd1624780215ddb6fa60bd9dacdccad6d2ca3268ed82899111ff560cfc7083c8255fc6ae676e8315d8b010b99298865d721c6f588047df0b85a52045b986c61a3128642aa3f4b6b3d9cd25a4595a8f946a2fc0a74f23649147dae393514a0eda058ea76eb4a55d6863e16c6c778632e5b1038cdcdf2a2914cc7c4ed550fc874e8c858364078f8132a26a34dc3e29b21b2fcc2b1f626e2b4c740541f84158eb19eaf9330843e0b25dc363dbfd0558540fb0f675bd351251ab6a82eb43dca1c840f5c313a1f94788ffaf5edd11d9823ecb24b7f1ddc6782ce80707117b6f13ed254b67671289b8908a58f7222f21d6bd736aab6cf2e2262330ffd7e02f808f0e2ca1b861f81f534ea9a2ecd3c8fe97d5d3ac6af47753bf10d1b1e64cd8ba46def388c17492a0af23be63fdf5770a81423a28493e1a169255e8606b2399ebce0e489879d9b2ea5dfbf7ab740b1c7741b98399a5b703822c4732d9611b389a791f3f6a03c0d0aca35b05aa1ec3b3d9e2d394f707be9e1c4ec9240aa6612e9e2407674870ed039c94a33e9ce98d1e6bfe0e4712aacfef21e976f904f677c5923f1cf931e859b2a5eeba59053e1deb88eee152446bdacd5b332dc03c055f26cece695e187eb1dc10ecf9d7067ed70994cb2c6fd9adc91bea6d2ee0462f3d238c7fd220189fc0b2875ea95297fa86214f9bd07e50d5ed947b6ff725b55296f8f41a037770920605a12b09ce4cf1052a470104ad8dda01c65ce5f3dc5f843d4ac90594dea3e9216b4c42dbce883b551ef41ae16e382e76228c789c845d899d439c926853ad53fc01be8902487198068aff31623dea27f8c77be3fe251f79e8d48838845b224597a8d87695a879e8ff409cf16fe857adf959c41e06dda66cdccc6ccaf614de78061a58ebc8c653594c5d545403172b8a8e32dfee764d66af70b221d08e22e0b4ef5813926d815b0ad06b1929a495fe49da876b66c5393990d313c56c66c43e9ca4166511641eca3a0cdf5a356fd66639e1b3b6fa0bb5259b8a12df2e3b21a0e732b4b42482ca9c7d6c469ef552c79868195f9fcf1e37902d29bcb9ec9173a20bd43b887bec45fcc4acf9079829a8d76fbb70dc1c5a3059aa17427247fc3634801b6d25e32620a1935e4de3bc7674f2acb46618be830f87e282926c16c8c7ab822962b1a2e4380a6e45134a7ac0c485469c684ba13574181452c1f53bac7e12fb2c8de60b027e0809fba1596580866dd947ff013b030efb3e75fa3b2c7925f63f7bae03aca26e2b45da8512c2f14fa0c501e2b56d47f87b26ca0babe7f3691d8e80d9f172261cd1fd9b3c7575843bbfce451f425ebe3c9d4415a0037612f17e811f6384c721ffc98715bb1fd01f22550e15fff295880de938b83bbe7385bb7bbf1b982e506cb2ffc7262d9799e3bb0ce31e3676c907258eb297539739e5ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
