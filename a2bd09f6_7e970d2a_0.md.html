<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47cbff035fcc1947bb2f565c2f96dd468f66a73da9c6ef32c11a42acc6d2c4d54d420ee0104ffea73b9f3094df7e70c8c822201cdb35bfe266c7e781b77543f27b5ba408499a0d415d2591623d7dc4888f5150c7ffa6e33e27242ed368a20e258dc6c776635f24bec7b78618ecfaf4e7d45aa4bbd7be1ce6ed2b15d5780182687a00ffa44ba8b3eda75d53f1212f067e51a4b74157cbffce5a27d4ab1c1761a2c00434ee4cef941126b30df4813ac1323800937425ebc9f747439e1dff48379e309c3ae67a46741c3c3e9e63a3adb5a3feec84f5e5f3b938d887e8a83f63d9b1fffe5f8efb9a972546daddbed65bfe529b45cc82873ff176f22ed68b724c4c95ef0fd2d230546e1e404dc81f7111dbc51344c99f12402f5f62c9bb0b5f0039097872383ac99788d47fa3655c7f61f55dd4f59ae67157dc7ff5e97f86af33e1343b7f80e8cabdb185f4062ab7eb864ec5f289502547aafbf00a44f5983502ad6c9d05bce2e41ee131b669114c2f15b2cf36da379f8392c6d4f40bd919a028f8fd77ab04c34eb2660133c456b8e25229378a0ef8cd98d9453dff1fa84a6cd83c294b7af3d10c4c58437398f33247d9cc948be427284d001e901d8fe55ef35f3e3e05162b88a96610ca9aa9c86a93e59485423e12cbaa47c8e026e7b057afb90b760a005a0dfd60dd0ff14e523b58bf1b2d10321ba11ab737d00d5dd9f724e0d1e07b15e91498d9a26fc9ebfb5bfa2501b071547c3400f24f2ef39e381336e45aac9eb0e89d8f74b35069e2f7e50f185104554474f1af9f6badc6dde096d613f43963d5001bc8eb40c2f4ea0c2d6eaf2d5ba768d91abaa7cd213088aa435cafad3fd9817dc65302a6e08293c27dccce0382bc152c128b4551a18e67943664476ab27d6b46043a79d2c9258fc4c87708fb79b8e92e6b67d0134d9709211f0c07bc32a009b482657b1452e6f6d77b6ecf9fecc5e3ab7510e58befc2919bbe9cfa5e28c4c0d4562c5a20ab9f788700a098ede11f326bf44a29d0ccfd015cb21f149a37f84570aef5c654d6d216f73316ec29121407b3859c79466ea22c2889a6f88a0308704388f09765764cdbd7f1673c8ad87a5855e39c2ad54460b84cb617ff85d7c57ac4e96ece916765c4ab3732779f9e2108d05644b89d6b945b758bee436b8cae63d0835b884ef06a8974c36c308f9e78f4bc96d789ef21504401c3d99d818d29e623c77b12bcdfb7e25c1a9a8a51c03ac335759f182447613dba29917ae90dc8f6ecac7db79eb98626545bd5d57f5d88b908f72c86c842bb14bea6eb3e39c8a49f05d1939027fb96c3f2bf0b9afc5fae454203878e8a5986d0bafb652818e5274776887b38fa2edee96a0bc798e7fd6b89329975bc0235f30d33d83a99b0ff60d4e6b36edff4ab620fe698f7d877dae3785c9654f48d81ff2dd4ea5d378af55e724afe1327ec3427d63eb5cb65c23a59b0484529b24452e20056ff180007aecf150fce0beabb48dae62f2942e64c0bb0c1dc0c717fe3700f608a97f1df0f60e329eab00c4e62ea73c9c6238cb1fb7df6a256e73332547c47f69b0e7f72a0f5a147e6c800088aa5b3d01ccf2c27ed9ed52fab7682b08838315eb4991d54e23835fcba0f6fd8067abbf1bbbdc61eebf792c0ba78e82df86d4a484b5c824b4e8580c889b6343e0ff65c8625f37df2c8eed5d41d815fde9f771c989f8c7d759f5b733904c84c42efc868e29ac0d3a645433032c72247b6640f3348a505969092cafe08db79ad7a058d0b3ef15c30b626eea42dfda744dedb5bd0b98598d0e92866d954ce344d8c0356410a4b8e92516fa6c61924bf66ea50dbfedf8041d62f77623addaf12cf1895f3170d838435bd7f5f69d7e5b2b298bda2cc14d3add077d3be1fb248e8aba84e69b81c8aa83d5a5542bbe36f9d9164b2271ca59205c09ed2180ceba289693174bf5a88fe7651ed513891f56f96071d35e6414ddc9ce103e1ea1c3a26de17fb5bac27570f18b76964e65e61b2a415e2fefc927182fce0ecbabf232dd342732860209d4a845f61556079e397f70ce0e6541cdf9f1d01270395adbe403aea21e12ec9998a935dcb726a265b822edb9d25a4ec7194c3218558f5abf54bc9dde886a2f85ce95a7c01e7330b810df6cfa512d995f2765776602165ce753869f91a76a0cd2c6bddfac6b49aa6a9d830a222279e58537e3220a12313a7a1c1999b74399a7d038c3179073a00d6f39fbbeaf75a064c8e6fdb1284925b63365b96438219eb128e803598ac0a24fc9b54eed2cb1af16e36665b9a10e11986f3f9cddf3aa727a521a57c9b62352bd81967180a2a9f80f70768ba20770fd91bd243e683bfd42018980d68960ac668dc87e9e41d0337b1b76b8d3bc8a377e2654b725e41f99462f0a99daf03584c41308ffac372babbe0fe201e439ec6ba0d3d588762a531a8e31c0b8454a081c8a6a80eede4cfa9fb67e7d24ed7e9a4b155671c56b069c2f7bc791799db1a3a56e475a937ff67ac94055fc6ffe2aa9836d2b3a2d4e72544537a62693c3ab548b1c2756267f469245f91a05576449bba8c4b8196cf80631687ca63dd464dbe5e3f1d3e7e434150b4fe8495742e70cb7b27173bb4ecbc1309cd05faffe8efa8e7ac0802b946d96b07cfc310268545cc07570f196942534e92e77c96aa0af7bf5f42734b9b39c3910c7b5f57aacb7c97c35b43775d19116222a6c76464bf373b305b23d48b1b46a1cdeb980fc9ad1a0f7cc6c7c0d21f1c0d22a4947a86fd383da812f775f6acb1e5d65573bbabb859b9f0c37f6533182b47cc371eac01e61a25bcef9c72ba2c2d003fabf0f2e7f7644af6ae60a6cc8e8e9cb3c4767927bf5cd4db94a27796f5a7c03046666b804ee54b49f16947075863710d76dfc967ef5953a90e0aac70c73c6b08c72ba1a4a601d73246f7457d619599fa6a02d26948675872855a04b372db97f0fb6d8c9757998f296b706965f5459ccd7ef9236b119376614906a3060838fa143a078ac0fb8d51a3ea58bc433ff107e57aaeec25e7fb86e8bb2bbee5b324ad21827205c271f874302ff47ee9b33b64d7f725732d3e22416177f2b1768d0d1646621cd746f53c6efcd41048881183570c8c90cca8c20e058c73fd33f4289844a09e055b40c218a01b1b02352fcc46242c67a5f0a358b649b6041366a84ce4517d050db74dd213f69871e521aee25e7eea9dab560b9d5ac3309e6c06c4dd415f34199cf7f9f2304a36e3cf096390495ff6e951e5bc483d8447a8e5ac35c4c983d9d1867b6190eb4ba467f248717d11d89d7b5ca4bb1ada16f0df11ecbdbad14fac9f2737e2d8c5b666f948c5958e0699a52a9c8d8649f9ac42d21d3acbd78992e881ed6927f8e8458d2fa771e8e5b413ca7936e616c8c82d9b6978575f4cc1293964519427b77142ac1f5d901461d1a4ae0af5faa5cb548017fdf6e3c36b82ccbce52e3f6fc1cb4dbc874e917ea3d1857745bc35e8a08e4a09db0bccb3831808d78f92ef777254b0605ea3917be95926b6cc986892103f888efb49d0cf952726a8bb125726570acf37445fd9603ff8b398aa4709fcad233ba193001a8b6d536a06270026b4f7cd918829872922e4a83d42ebdf78ab82e3dacd6eef421a115ba10bb01a677c21cd0b774b6646ee5a140fdb51695aaa3a6f866b781b79f12c7131848b8a592205f4b5dc9a20f4105b06050a492e8d0b1f5af99d3b85a388abac31c3a55736dd9bfeb36de1e68a5f018af2a728c5a7ee03dba841fff6b6701534586cb3c25d90f32b68f6f5f8e76e068945642a27b1bd73bf9bad338e0db60b21e0c9a36536369fc1566ca15eb9e22834acb6b713e9f840ea641d04268c72e463a5fab70a3529638268382d83e969950a1edd6d898adddda31f38d2919ebdc2f3d4e13477527810a7c8e490c43db2ad303a33587e0bb4831b374e8214df75302ccd6540f4e37404418b297b865b0f6be2a7d0fbadbe65b169d75417f91a8707d192c322379eb198c6994fef77d89856fe1d327085f903d7f068a8ff7a8f241cd511a5ef4b96346937c2af86ba4f015cf9eb57c1f92bd7764f0b7b3d7f9c7d1c56e5c5f98428ad57825e0e0c642f9b1dbcb9ed79dec696bcf8de1f13a06c1514c6897fd7820fd746a031cb5739e2fd8397e451fe28b1f46279f79397e863f34572da360966590ed9406b5c7dfd67fc4d5a2fb540e26967a52a1c9004d146b627948a0ce33bba5f6a3299b50412eedb68bfa096fa694c0958d16d0379873c7e60423ef75dc0fa0a132303c4b5c96756c426ab00e3be5e2074eb286a83941b197114ca04b9be0f753e0a3be01c1ca75c76128d8a21bed566636b5be1aded24cb4102beff95de12efcbc4128667c065399a825796c15137692fa902bfc13574aae483b7c9ba2141335e9f15ac4bee110c1ec2eaa071d16328a576619c9a2188aad5a0bd98653b9636a24dc685333a5769a76b77fcd5a5b78ce15955bf6c38234f8e9f6b03fb1ee8a7f3584d283648e347c89318d387a96035b939ffdfa5b78eca3e71b36830aa0e4670fa09815833a0682fe8c387b01b0f533fc95156c1a86be8e5077afca7d1af7ebd15c278cc8544b5fec44c129970ad7421b318344462f49351a73bc44373e44953f4b1bfba88e4d5319479406aead9b7c9c9c7c07a9318ded55994215f7e1551e7cd1a87f3228de9d28ff34fba7525422a002fa6f8a33b756834c6703aeb00e89e9a72dffe179626dec7ab7a6002b1f98b7ac88bd8a196833720c719617c72c2a7574e97f97777fa53412cf47655be84d29122e26fb343c1353d8350677bf2601ec06507be6de104229e26aeaaf6dd2eed573fe507fe19150749fd32ea1432f221d4718c3de3d85afc334c2f3628de07898d10efc680b2222af0595bb614a4b3009bc47c852e66066063497d7527c2dd0aa99b14b38503dde6b8d5d5a6b57532fa5c4bf0ab1ef2a162e1b0160ec336b6a477b3ead65c381c7fefd17c5cef6d531436fdeebe1245c827695600d509342e81a7eaa4e55f574a3d5dd4bcc38392e7f28b8f92c4c459709fcd222f744266cb77bc84feacf1cd5b5a2b094dfc387017f248fe29d9997ca23d56282eb5aae2c05d2f7c4cd460ee61a6549274e4d4d707ef5337e6b95aa514f834112a0fa58a6872fbff7fe37498139d76be88af24d09c5ec76d9c6028ad02460cd03d572d28f96706716c6984453fee9affef1382e735784885a3275307740bbaaf1d030e082cb9674afcd0662d507fab521388faaab04c5c2dd2884b61decf9f54d7b9986a005164c00bc6facc62c87d2c0b9d5806af601cb8838815568b3bfb36aacbe614b5a09132bc6a6e259f7c47f05b7b108294aa8b679dc235742de3798f200683d837a51c98e754b8e0a16440e5f3b223327abd1b71c8a3e0296f6dbfbd71798fab19b66a8191b3b58885cc9fcf397341557d829ad048c918c29a6d50cc25f02b485bcabe4bf386c9a460a673755a811585cbe5ef8cb60faf6bef0fadb4ed5856f80f1e6658fbe5f95e2c7b34fb4eec5e81d93de6a4f3cba908a879401c3fa4de68552d825f2d88d08369863b1256a6520554572c12e6edcc834cd34d11c7a8859db6f209de88de7ee38125032df80681f2553303e198148379ecb9a64b501e5f988427dc8e7ec510fe445d2ed977791c011b47d4858d6d7eaa63488e5be92f927fb2d2cc7654a4c08043f1ae27cbad815b3bb734d3cf22c0e3c7758954328b8d206020f48bf0e10cb635c4e089fb7561aac48a7f515ed6791d605e868bd6b2ce8214c3ebf82584a87ddc22f96a9648cd2654b9eb2c574202071d75bd4ba910bd844369265f2c28bad4bea51ab0be5bb1e4cc611cf26d2b5e288a1d4202f3f67b2d0277143fa18942a7327942edc8e7d48ec016a3d49b6128a5f16d69d5afaca22e69005d64974f10bf42731769091b7bdc87f8e08f3b56dd88edf0c20f34f0720a6de00fbde86e61f57a8396d92197ad2ac501da231c71843fd9fb1e8dfbeaf0673f18339b916ed0786f8d62e33814ab04c3586e6ddd82193cbfd91772b7483ae97bc8af7c0c1117c620c95e573d5bdf6c53d5fbe511ab955ca3190b2947d43c88b4bbb4463f6894f275af9daef63a56b7e370f8eff0880fb03553bc5f1a1beb72701d7b95a5698d8c90781f1f0c04e046ce3a07627d83e27eb01c520a26692a169f582402f01c8c0a3281407e8e683ee3810c502deb5a1a49f379339655d3953df006cf3268909559f72a2c27d513dad60ad6030e034817b0893cec87b9db5a39574651a5b1851d10db308100b78e3495454655adebda949c880781fe60b11b1dbbc5b50968c7e56e571f6223e90372315e1b5534125e43e0d2b173bda83d7d735464ebef81f97889ae1e3cbdf1df14e0fa04deed0274c331e5567cad3b9fa3b38ec3d7d5037bfe58d7eb8960649803f8c8982906a020816674d29b18ab276653877c91518b68b34fe9b841019c3db86c1a71f05e2fe110c3a6cec29bf883a48fd0e2db9de12e2283bc574adce44cfffc847686c4b731141022ce1cff8397de2e9086fd6c134be0bbf6c1a9687f11376020a28e65e8c118b07778c9131bfb833621cf78d8738c0291ee839d90cd4dbd0efb433e8bfc4fcad30fee902d89e13c128eb8b4702e45e97c02e42518f54987c43c393fd08772cd5f16d8aad5036b4d04c4aa86ff616acb179367569d66779226e69b18131ece40c002957995078d8d1b7768813833b8bde2435eadbb331ec73c00b1bee358f76c05a3cbb5c8a553ffc5d3e4162d316672191591305756937b8d79c8521bb4ec3eaa71fb9d2d42d281d7eec8440ec82811925e6a0d3b99437348a894b75ff5e3a9edf63adedcd4b95f50024ccc05db223a868cd9d936e24042a9d9b329cb988481815ef13c61bc8bc01192066034a0b0e9ebbb90feaa2c41057469ee8bd69fcdc55757fb117dd9c2c546b8fb055aa76ee49dcb244d9dddc7f3975fcaad1c872eb414138c13cbf949772ae5405c9e2a8e7ba12a39bcb5d67a04e15587683fce2362bab159b43e92371fc7b6952952857aec3f71bf3baa806c3bf30312f98359f580bcc19f5fc992c65745a95a486442aaea8c9d52081f90e7ebc8c30517e154d57ce633fccf476b9266d9bc823fefad1da09a16987858f7264d63e8bdab468ab75da1857ca761c1c406709f7742aa4b74ce7c70cfb24b3dc402caf5d61ec5153c1303e3300db88a4c2c20e0730fbb7613a276cb899a8f55b16d82c17cbb762e263281b72e2051042a50e460767d8f022e9d8c2a8eff8b6241d546b2355c0b8e663e98e7753656919ba6765db4f66869e31ab6f58f7dfc6379ea8e0ee229cd5f894bf7ddd82b71293db6671f7d267287966c2c25a90e5d1f3962a82d98ecafda8aabb9a306bcbbda8146ee248320ead2aae37dd3d60799865c45d7e5c6b5e95b40e0b283cc7b8ecd6282748afd2e3bfcde79a0ccd1238134a8028873fe6e3d61b2e3888ff845bc0f767ebb603a70c88740c52be55f8d703709f1f93d0a0deb6256abfbfe033f1f39ee24ad1d4426b55b72ef0fb776e59193ddc6d00c046b96264a9e213e5df9fac82a62dadd1fe778fa8576a6deadbe4630c7926aee77faa2a205bb4230161939f5d8cf3301510aadafa859632f18993fa8f60855daa5f6bb9e5f14a4dc74716c6be7a9dbca0cf3278f376d3b791a7d3647997c95507dd672e6ea859afc8c265a0a285616a64789116db05fdccf6c55a2e4b7007c80633eae5b1d8e1b3bf868afcc8bee77690b6e3fd1f76a78d665a35139b8e48e966ac602816dd988a88c2cde8765668c6021330c1d118a431b2c3eddf020760c33c4fa0933f0ff2947afed5af26bdca37df905c081512c1c54617c0ff6616020a33749c513ff4273383f07afcdd46897d53fc09d5ad47364a1245a25bcb93bfb213d1123721258320cb5032451c9c0e2c966d095b795d4f9063cedc86692c1e74bc8c04d81355c0b99a211a603d39128bac3ce8b6aedbb304a16fbf3ae02f70ed00f88303bd3c2a85384fff05fa6770391ec10286c9f74ad6fc6fadd2f49723c9c3b48af1838ca777d16a1c1c45931c105794365da4edba3b011fbdc721af9d7ddd287d06e8b0dc761c07990326e7cbe7e54d0e7c436b9c4cd11933c52b0f4cc1c9e56539f4b4354c241ea860942f6c3ae35fe31e9e1413bcea0ead3e87135946caa70c257dfc19dec6ab31c6736b0cfddb176da2c62d9ff79d3717995796038625cb093cfca0f81e1b00c9f331f1926948205c21e8fad1dc0acfa9823a2f0f49db11d6d43254a539457393f25f1e87bcec33269d4e87f3eb978893faf9e88ce104116f35431eab4ca840b27c6d6e9b20787c9c7686137d1844f3b6bed9552571da8ba2c82bd7c9b2195503195bf219e6ab7bacf43319abbfe0c0a662a5e9a8d03314034bb6f3aa8da747be216ff17de410c7dded4f26750fce4500a780884a42445c8499bf659a0f74059764630c565b72bc39c6afc154b67484dc44fffb3be080c7fe627623bc680eb7d37c676bb18aad3d5b019467d8db63046a63a353c4dae8f252cd5dd1db2ace71c5c26d3fe73171f6b3946e7b901f00c537859a57b4cbdd72670c2ce0c6e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
