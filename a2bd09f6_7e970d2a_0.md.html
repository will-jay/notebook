<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05e962fa513d09099f2771092f8797f1d15314f29ecaeb4678fbc336f2a950d361888aec38cc1ffa20a46a1afafa96e4a80c2a894d09149e6c0555e75304df13552f5f94fbb0f65f84a656b2516f883400564c6df9b324e852332ed57b9a3fbf0edec2d698518bfbc2947f53fa24a5f29d698646c741b7429863d434a7ab82568657568c89b8b4cc1de0eb94c205d1dd01c1a533514ab5bc911b20f7d20d2c8b6f9a32942f52219d3e070efb97d211eaf136d6537f9b1ee86f425420d08976a883c1d35b42a7359329b25ba3d00445be20ba20cd861db0f54292c2ef752a2a20124a47826e6f72265e118307bc80615d841918bcb7d21f5d6621fd0c3b9de0ec7a15d5fc4a84167e6955d84b647d28ebccb06acc88f8e457c2b78ed7ba6e24d8f4535928be64f77c4f6d3144d32d8862f9d037d4da5740c44a3ab3027e4ab42e56b32aaf2711d91894a4f5a4086ad136746a60351fd1835c295358eaae78e6f999eee5978bf7505aa01eeb40d73e7449fff8ea6334c1048c32c6843717ce3f8c8cff424778395c948a4d4f7c425e2d104cc3ab11eef4cddcd7c570615e78f16483149db26c4c8439a06d92e35adf327a6c432b63cf6e4506aa51a4cbf0c76b0ad342da33828621e2899305e8fd1139e846812b81ea10370bc72cd5394f668c213c1d7a5ecece26fbb5557b0f37411a679fb645f7f415d783962a119ebad10b6589a13073d6271ca1de89a92a5a17c1b806291fdd1e122009623d2aadbaf6ac6a2d3792c0c19092c21515fe2aa623233fd74a1d78d8892c1c0637fc07a25a64153f76a3b6cb27edd847289018c606916adb53f5ba25da3f739a15b70f014bbcdbe0aaac4ac905cd0a3b2e7abafcbd5fb416a45cb9a397d475c56935e66c627daa83fa3227f5176e5773497084bcb5d47d2edb886667a01a8c84a4dc2233fb54d1e9ddc48f874504a2bb3c46218e38e0e732b57901415b64ba3dc0d65520f1432b6a67cc31937b30ec0c00caafb5dec9086fbce11466f230f9b26bdc7c3cff56b60f4eb96f8359e0b5cd6fbe0b312dd163f7d185dcaadc65040f11c22e0e8af9cd2a269b6c821d4214c921475e09a9dbe0a97faf43e8b122fb0690200bbb2ae7547cf7dcae759c513cd545d756d5f7e3afad9985c994e617696e7baed91b6962818036f5961677de83709a7d996f76f40b01ec3f8069581f41933b6e9a826a2896d8fdf9447f53e9e6798a51c34aadfc23cea16d10d019f4e8c4c8b28c74e9f9f455207e9703ba9268970546bfd4f931f69c0e2f597ee8688bc335ad31503684797a176e992b3523ebf8932a222b50f92db276a4f9a17f7e322740be90a796143faf45dfa4f66da6188ae087678f9a0fe79395ffd4789c830bc76cad7cd6cf6ea64b94bcd5916824e3b5ec889acea3d526f205993b38252ecfb2692dd3b4b8a1b269fcd3ae08944b7f6327910e03c4d5ad9775c2f9925575f5e577099b6367e7b9a08667f2f2f44c3a7fe93e0ddceb08a7ec0cbdb05bdbc6dc539f5d08f3ce46821f918b2675eb302bb66768922569d99688ea1d80588dd4ad25307ac498bf13a8d92deeabef445cf3dd1f6f45ec1deff835df53cf9aaa5a1f0ab812a6e378c9fd28c15f80e5f7986c24cffdd61da9d37e7125e1fd5024dab6efd7ff3d64a6d221db30cc9a772a9732ba51d19c3101d2ea940f5ca40f1ad2da6a2c72e3f2060e8fc4eae2c04c9c2f8515bd957e2da5daaaee246afb31b76ea85dab5ffd87f076c0a948dfd0640a316950142c6e7601b03ba6112063ee2c43036ae45a4c9454295edc448c96f81af40a2cd51a7e63bf45834ca21a9899f40cf12525112c8073b1916081d7ffd16cdeb78ef9ae213851f3b268e9a5f8fdef7c3e7de0b67b70f36d332d4c5f3202d7e0048ee16f97dca283b86d07e809f31eb355d76dfefe151d62330c804022476e5fcb9ffd98144488dc5ce0b8c37c27c885e5d324817af401b0eea7ea6d06204270f79f0321433f022d9519e188f853bbe43ec6351e801c1f315107e799c10553810908fb04a239e5651d11b85a38cd443c03ea65ad62a7180b33bd33586b43e18a1ec5bbb8ab6eed967f56f83c24d7bce5b8812d156453ddb5aa65be0be10af937c9524dfed5e2afc1f4a70a8c61b559fd4d858943655b2d29e7cedb93336c12f2129af3f347440e6dcc436b7d87b0b13dded6a8975126a7186c78899117c38956fb60129e615b6ea85604c339caa856f9a34434632a7028a1b21bebf030b7f0fdb097007faac7dbac66d2ae065c0e12bf38224df89c100bb5aad3f8f76aa27021f9ec49ae6964a5824758a34d8f67fb063812874b375e1a371756028ddfc316885b5b67ac192a5ca90cbe8c9869c304a8126fa426f61e17da62bc7216b2995891b0cce4c25f3e4abd4f38d42a263e78f9b5bf3beb85463afe41c1c2d6e89bffed7d815d1b65366c5ae4496bd0e5aa7d51f71079513147924b06e0b5e8060441bdb07e775b419bdd737cb7afd4ea2c67e3a78cab900420d794c253f81ad08c266c15dec870af2550ee768b9559c73bdd7d326b0cf312ba94bba866643def28ed4f17be46968c1cb03d91d7a48860d695c3abadeb84f3b0d66c120211755ea362756f4ce7ef3ca94483737ab3dcdb017b1f704e712c60537cbdf8d7551f47ae02062e761f92939b694f64d1fa388bbef79640249acb7074cec962689c1d392a5ade799f3a33a230635313eace0e6c5bdeb832efc83997da58f58db9fbff53eb5273ee84bd6e8b5741f3d570c230d617ed5605d5f01b10bc2c172fbe01acad2801197e9be8acfb6c852963a419c2d2b05c8a25cee78910262c0b56a162c00aee97fdd954e160660790234bc3bd64d5abcb3cef0053ffaf3e51b3323903c32c07a7182c0c884671b8d95066e3e99a311031c3fc0c18cf5b9ead716207fedd8e68e7441f57babdada15f6d1dbea0db6a314f30499f145340203f3d9547befa1f2a677938ae14223395e7b50b35297eda40e31f63892f457033a881a2e646fc06c10ab1a13b213074189bd93c4ba3faf5ac6564051da16522f5e2e3ee904837aa6e5a9037a91d4ad0a4b5b0192c61122a0ca06ce402ccb97a71746a0e639abcd8f12f7f258414fa8d9bd3f57dc957770c7f0691bbb553a776e58966899c005697cb1af9ab0a661a646cbaa438794c82e562feb4f6632e8c8bd56d8e0ca2eccfe515257dc2de1dc15c98bb42f020002f9a35c68b4d62b71f76e6f1dc5d9768629ddcb310f5c93a9fc1352ae5db93a44a1be0da1e90807f34392b67b5c7ca61e5405d1aa54420480373161731c997aa5774fa14862698c103d658217da7b6e00d1d74b46ff0d6f876a860b0539f03e7ce2def40b5a50d3eb23fb9e6956af0573e321fefbcd134c2e3dcf7e5456201e3034db3607b3e9163ccbb98803e3a480a88486859e91c92a07b2bef2e110729e704dbe5bec80f885484a0c0360a3e79f7bc28f9357bc54e521cfe52982b5ab38225b52e14961e8e6d577f46e237a67cb46ca8280fbbfa3160851429d7183e8632e9d22970ad4247f5f793bd977f7834b50a1f6f22ba1bc13d9c98554d372ffab0d7ee0b7c812c0bbf145b4116f4c52430ea4dc5f6e35b4843bc8142a4896b6ec9c7fa782c139c970acde6c37a6653fee956c3fdb804fbceda95bb722e2a1a3a5cfd97c68df17fc77adb486b25bcef41f44aa15f7bdf25161f92883d9d338e198c0206fcec905c64c34b11bad86c8fa2ee24ac9e0ea769f3489d70d7a8ef6c7644f01911a63047a22fce6e48f7bd46e8badc1d79057062d38be2009c29d7852b2795d4435c6425fb9ec3f1339fe31f8dcfcca913312ef06a2af0a14d7a9bea22c2e509c573e09cf8905311cbf38298a951d316272c20dca4ea6379c533a15c3ea2ad5e96d8ef9365732ffb3a3ff56c424ab6b7be2dc3fd8c80b9b0889351148cef84ca681587dafd8a83b874f55a8f234586578e9e4efa639977f02bf506dc0ed98d123e7a8faf3946eec979e0f06af72f212bc3d1aa50875b52e5b3f8d9a5fd87a77b6f3ec917e115772fcaf3725196d3c18678df4db424acd0050511af88aded788df5dff257ac3778b0139d130fa0a037b9fb880c74cdeec6029a43d84fa37168e0eaab45d57eb85d8d6087162a008fd8a7baffed696f4797d823a6f5062720dd9514a2c3ee4d138b3f9693651f5a4366439efb79c7062b027ce4ae9ca7f729557cd716ccc30562e9ef0d96ff7aa8726ac020f06c079c690270e28fe8ee752055456ee72810cc25083115eab7c3ae5b162368170607676a2519d690b5a08c5fa7145ab3f9816da38584329e07cfa3ac0e68f1f8a872728d8f49df9cc67b25fc0af36ee0f040914b51abd535629c6153132890e345dd64c68a1e086ede44b543b176e9197a0ee29711d83250d37cdda2ddc173d51819df82fb96053d4b2308d7a822332a1806b016d51cce9f17876282010d6f65844315b8f4d9479d4fa390d8e3557ea97b9de5f4a857434e2b2654a33cf6318a299cf51e692bdf0600a2673a0815eea9e6bf7dcdc6edcd03ec1e49f014b086f3f4f5f31ad5d2c296b73008acf7d0464352b86447091dc3418a379b3cc4a2ebb4bacb958240c3525ffd5b223bdfde846e5e6a7e1b9ee4ff077bdd8dc9e3fe8398445ea5b0d49df051ed4605670db28ff15e2324abaa795f8dd514e8291be6e5d5b037aa51368daa9f38aa9a90b89ac7af7cb6b8664e9b1f6a062a0fc2939fe2b3c13baddbe7f14913807017722fb1f8d7120235e95316e6556a4b889530ac958f2f1ce9723a94e117f94041429cd940d3484de3b2f65fdde0035e51be68265c4bd3b708ee661ba0a927b23bd049299ef4740aa7e2187e181c43cd0f87273cc24959e4b8c207173ae41ca43940700ab78615eafe394b3152e720b1c15d8177d4a0e8060853813f3165bff9261ccb8dcdfab28fddc3838a76b665eadfbae593eac3065ad62b63853dbf1b03f45f68f8d30d1814b582d38e7d4f00c2ecee869c5c880a3877f5db02aadc69ef96fb8e7d7d60b59051c8ed213aceb948f4e2b67c2a6cf5df71e755d009cc892bd5a2f77427f6523e31b95dfb8a5d4c2af0e681d6c62f3b632a8755ca8809edbdb416fd78a6f866001c2e05b1e3467bd571a4b13c60cc13757a99089003b25841655314e5bae22e1cd3fb78b152abda46063f22aa182df3bb915f405b323ccdb4cfccf09fcc8eb98ab3a609c87f66dd16688fef4b69f87fd57ffe73f58b41e3f72feaba5e135ea145e396d6e28f6ac7c5daa9d6a6024d1ac7ce28541f2533a4fd2765afd49cdf5ba3a35c7ee5d707ecf479020769c0e4cd618b0c97efdb9c51864d6a9d1020cb18e946dcc69284633e004cdc27224039fc0031084e78d6e6f77d6f43a2a13cd96150c909712e1f54b2aed1146a44885b8df40b24ea25d995c30fb35ae15326f7229e398b8b7ca26ca8b2f35832fc86c3b4ac3b54fce8cf77035ebd2d295c185085d5827f418e597205ca2cc3be8520cc79217890793529e505cca9b11ceaa985f7b6687ceaacabb08e51cb4b67995d77dc1c3f2e200bb38b2897fad1ba2fe610c4575b79c00970452e494cf31e56309b5c0f3b7fae272d820650bc6e9052f1992485ae07e994d84ead7e5f4ef691be25efa46edd35d169877cc9bc622d0457474152a25836910d32a7e2818bcdbdb43550d6b52022c56d25e257b50d6d652aab8bb32932c7e76049a34ff442c67b36e1683dec0e5828804873c5a46606428c3226aac2447885a9c9571000b6f92491cb6998b04cd41f1621f828303e1b0dcfa80e347b172b32316171d823dd2760f81957ea7ee2255a1cd033d33c076c440a68d9c6a9e0085a63499abe92b7f4bdeee036df93163b9edb192611f5a22c5f28dc3c5a466b2401e6b26aa2067166f78f11ce7cbd2eb758e6d928461f11a7c98fea9b4a70f43cb46e0a6087b1d001dda7f12ad0c1e97b1b4f869d0fa321cdb84aa872112c84c030547f1c3c9fa22f2027f30fd5fa024e638c2a04080aea819981b83625b23ed50f9f4fa32165e502c31a33d9160afea9ce7c022176e1ac3afaec6e115e70b5bfe353f4ce70fcfa155a328bd99b226e6f3771904b68dc87986677e693b5f4f5900d86ea33a2c9a56b8be2d2bcd84df9cad2bfbf4d646435e2587548b4cbaa3819bcf928105a55e383fe1177ad8eceb0d49977f91351496da76df4682ecd5975abb9547ef9dc983edf62066dd53c334d9798db4c940c933e1cf1fe0229209e4528479ff0ab947dda293dd526a3a287265e72c132a86d87e66dcb66070117a34b14b3632be00ad7fde4554786231bca11245157a564a089263c8fd85062e08aa667a2fb3fed8aac97d4833708df37011525cd9367ee24e9429b18e7d286191c88a50f9491b0dbb2dd2781c914628aa58d587991849fbc6c9318043c1666471924d6b6c3f91cfd7fd30ad7073b68b7168eddde4979c7dc873c16106e5f7522df99ec770bd49193f108d3fc75f7e4ae63d88d77a3aaa18daae0e39b0d7a6352a882e8db7a1fe8417fe7b6eece5f56410899f794e35493bb6e40d5e3ca33e6256295a1fc6075287177755044966e4bcdecf0f84cea8de7fb3566296d8ce8b736fc8aabfdbf45c510cf8fef73d0d008b01974ce76ba2d7b9e2dc4f0dbdad034c99aa64b55089aab97667649307d413c4338b99b6c2cbbf1a33f3695cc68e96968dfac203cc68eb724a932176484b9051b1531218753e245ec626b477c22df6ecfdcb0663da585e8858dcef9c0ca831a5298b7faa4f734cf8cf862bc5d6dc0bf44c09ade16ea5c94131f95a5d9b188c3d58fbc2a74ae0758f9c98f52e66f48812e9dac38f404af65627fe76269576906721b85ad4c8536d57396a1d53b76bdd751b87944b87c7d982fde288317e7f8d8be88ed888444fe07c87c4903073268d9be0d367443db8a31f9003bfc65beafdfcf6471fd742899ad957a4eb2f2660e3f30322bbe5ad56679d7c7a7bcbb18049e53662ad6f810daa55086469a39a3108cd5eaf2f1a77bb3d85978b4035b96af6d57c953f377f4af0edc4915cb53b1dc988c7990143c07193f7a1c50e8f3eb8f8c07b403e74c5f0e507b230f7cbdb0bbafceca13191f3dbf2586f2d5f3bfd8a9e9708019d717ed608ab679e714af3b6035ea96c22bcf625b96ba7b4f1753918a67edb0781ce34811b371d11f505ce2142635e5ba626ae1167c838a49aa41ea5ec94a79018ca132bdb636c8af7a9109dcffa63b5d84e89767aa024dfa7a80698a6589f272b3cc06cfd4bee70b777c76b662d2df4de51f53466a6b9df43f4a93ca200d2946497d9bdbcd7d6311bdf417dcfe9fed45ca2b3d0027c3c771a1371c2ff52f88afef4409f0d1efa8bd83882417f9dbc06e7cb29a56c21dea43f36857657d2f40255bd4881240e5454b7d1f784a6c73cb5e97101b82340adfff81caefb03ddcf3aa492b3fd5eeea467beec7172d70380e2f6919d84c6add0a1396edb4b5a7297dc8360694251d0b668e07b38e31c04ebf89635b3cda10d1c0bf4f2eb95ef08e470496d684e4534e4be8a08ae00748825941bc18cb42793c7e95b4686c91b1b693c34059097720399420179b1ca4ea595095d1344c07d325aba8686752047043dd974360b66569c9b39134a390bdd24433a5d9011391025623aededec68d5fba91aeb48ff4fc4c936bf6a7be5cddab7242bb82f2e7f8cd5990477e75d1a4da1d0adf48b865746283945d133162877563e49d59a37568585a095823b8e792b384556bca0984cf0a3191ac6a935d79994b9437ae62c89f586ffc60ef73be1fd6b17e2123edd8d00e602864d8eecd4ceb05d71484312c9a6946e38bdf752e9283685091b52349c3186db8ea8ee3bc4ba6c9ab1092f8685423d776580fb31a8d24361d594b2a8c49a63ca4e38206730777556ddfa49ee7ff913d42ac4a3262a338160abff1ad383f0dc66230887cae7068bbed883796d48176675b464fe1924ff60cdbe4607d4a5f5915ba3d9a9b05f7d62168182de424e7555ce860ca9c61d5c6955bc9a892b109fbfcb5e71f845c66dc12256b29e4a0cce90331b33b1d79f2b7e732f47446444bb43ca4535f3ab4a8481d0e4902b1fab68c6677369fa4019b9d66608e201bc925b2f7fb5e4d05b53aacc7c1f3d0ed2d2ba748c563e3f3d591283e97f8245ea08d624cc491da84c6e669adf5146a2fd76116e2e9bf882e97646aaeaa886090df3c566974e8e56d0420c6447e67038ec3786d544f9554419034da5dd1f0c866815d97e8648e4ddd6e7c8dcc948d5370c1a623df607c5fc2d199bfd7da091531ebc8e264dc7e8c1bf0a0916b3950a536e289ba16c6405299686b3f23a30c0d46c1fe737b985df698b157e14765143c0d522c52d0e8e04c75c18f46ed236017c31d4a6345f903e2a1e4e5f2395d18e61cccbbc36f23b55dd4ff5f75260007cc35652dbb4c3e6d2ce9de73bd6d98533a00724e61c3d4eaa60688b336e2b8175ad32d42af04fba55030640c522979b00732903a8dbe97de1995dc0f5bcb677343f97b74abb8769b624f48823869283b63520c660d15f14cd03ee32c7b126c45723b642185b460ca5ba92be16783512380ac9f0a8af8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
