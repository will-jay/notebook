<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb9e38527132791a4ec38d344626f71a5388ec65f02a34f13e1f575e2709ff1961f9f4959d744ee33c29b65bd8491483d8aaaf017666bb3fbf1fc86c8fb776d7e2e1faa184780bdc4d2da2e32f5ba4456d0182a3ef5155ef4064e507ee882b155bc68c380f65897cebaf6bae5177da4f5c593a8a6fe67118740d3625383615ffb2e74f6c9ccc76f99885dea9fa8bb6546c937e8963f9baf718a81d850f77c834b99f725333e3ab74e34649de366fa908379b99ad87b9ab999c50c40f64fa9f061f938a6616eecfa2a90017068e520ede0bd10b481628966d26ae354038be5f83e655f2297096b0d937de202e5619fa8df078463c55962155567516f241d5aac8ef25d67e0c01f4e4778eb025f636f635a51f24bcc1a39f77472506f26f23eb60ecd5b8c5304723898ed50b42590ec2f444acefccfeb55f59ad22b4afddc202cd46f4fceabe6f4fa62a17e37f35facffd2a4e15c893372d9d379cdef9efcb25914e63276fc20422f293d35b312496798ee3f4eff44eaba17f3eeab79b59817045a09f444a6ba6d1d3ce93d6f016862d8b3370d2eca94779083d4ae77cb6b064b8e476b02b2766c3bc67d043cd341033a8bd1ff9437c5acb7597240238e6fb31f33f47543fb09c263dbcafa712e2bea69aa4665071d5ac441351b09cf26aa51d14695bade2b51b1e163803dc9a8c8d680f0eeaf064246748c76d9456bc9238313cdfd02bf5ea08f04b8382600be2e292e30b76b21323acc73f340e0e773b021d1e477da619e9f2f6131b8f0d3bcd88b424b9b6fa8e99fbdd1231ffb87693bbb5c58d6e30309551aeb75492427f389d13dc1ff8cfefe9a0fb814ae1c27be1114c9df6954114f323cc8994a8421174c95d000f92393cb03ce582e6bc1343bc05edbab1e1f3ad124ac72c46eba80b39628d211abc5d00c649ee3b4cc473dd337c0af88a0a547db2ad518436137be09d4bf2fbb812169116a2eacc96cfe37b8d44c640f06087fb94d7abab214f74544d9b7790fde339dffbeb6d887f06048e9cc5c36ecf9ed4b77e52df27ec12ea01eabf50153b0ef13277a76f51cd3389f36d08d8b70e43d14fd5cbfc9655ecaf4777f7691db5407b2fe28eac03c8c5edc137575727f9a88447a8730748a53fbeacec12c706cbbda440033d8c689236ae200b61f0f03c3a4a16bb4f62b43cca6121e70ceaf57000ea06c77a937d467463f265b337ad2f52ceb4fd55599a8101fd4ff4899d99250e811757186cf1cc6ab1aa27bd29a0f70832c622972ce67ab18ea0885a3bb0f2b1f8315fe8abc14cc081df4968ee8f84813776e3dfb10211749769d199d5ef3fd5d0bbceedaceab15a00df646ee9299065dfb588452841d138c40dc80dc22e8007b0a7fda42d83a5b054e27b80309edcec43a44859149aa07390722649bdf5ebf5aee03e825eed013cd85683ba36a9ef45bbced503ef8cc65b34047eb9f39f2088142cd8a740887144dcc2542322a4d392a569aa5f2da8025e079e632750a4e0d488a94a8327c2871f7870e8a757ce0742a10101e126483fb453938856c81d2333f173a0c4d4a736c76d85c1194ad463469090d5605c9ba79ad664bbe3af34dc6720a37a884ad9148ff9305c3b41570fa88d5a3d33a197f880eb7e33dbffa077d57208f03dfa2f4a912127a8171710a22ef7dea8bf0662fe0d8e36ed3d87d0086d0d76a67badc7086a81522f42cf8c5215f86386903cec5e1d5d733619e37160ea23cd5ef33dae4776313fbca5ee3d6bed2df5ecaf611607e7579f6722dbf9080177c96c70a527afeee9891981d899be1579ca5f3d07cc856afd554d649ff3f91fa4aae9ce9d1fe2d4048f33db95862dea0c6579c4ad93b4707e9176e8bd0f8acf7085cbce034e507e0e3a35f82e1e6375e45c41bc2a407b7959422067604834804e83af4545a1cf5c47682a97a3bfb417b98bbd1599f343c7776a5698336246ad064da50e6f15f976a539e63e6fb5067ac4eec9d99215c2ee29de27cb962f4ae32c580dd626d4d4c56d008045ad6e8940ad05a4a080dcf29283e98c6e3929eb6ebed826d65ddc7468b3d34930029c7a9e36d8791f16d09183e42469ede95169484143fc99a15aa3d82adaaf113a94f7cf5f3d9dedb00191e940e376ae58ecbaf383e78a7fabb9059a511154a2fee1f212571cb4116998fdd8d1f9921834508e19f708812c9e180fadac40f17e914387d789e6b6bc39e050fa04deddcc1339f5dfeb7c14ce5c1c537665c6f45f5a6a897dc4243bea79c75d5de959d7401035f18f75064e736e69e21a94e0402a2c4858e0e1c45ba0801fae3261a1ed9772be75c68b6591c8f9781857a6f19df0bf4337c7d36a95a536342ef9599045da38a0356a19e25b5ba61b47d717708812d3a11953cbd9a547d0543c7678a4c51bff20eba750ca79af36841a0056f281ffe31e8863eb5a6ce9fb8124925baab304f6b47318b8a8757a0a6083c4a3fa1540d1d9e40619a1ea47e37672288f3e4d027f30207dd5fa959dcd804d9d8c972d908c1d8dbb7835fd6f38772777cc9a092541e72aeff53e2bfaf11e0c884ac8baca921d20f2192c44c634e9a72cec253de9ae1e9f778d8c3213598e8d611f2d98fa7ce22aab839f83808b04fb19a58120638f79eb775aca22e11e511db07a660f5a327a497bec9bbb24460803e2e754e9f3a9afa19e929a7ff565e0a8889f03bbdbee018c432d5ce28da7f06d8ce83923e01e4952a6f277983d32502b5ebd10d1147d2712677b00277d070c45574ca210f3a8f3b0abe9273185d1ec1e4f8f0c3b066ccb5593b08096a372999fdb823899ae31e4e1da51a599cb771f1d71e0c2aab1652d798573668922859982bd62428f03b80ccabc313ed878901fca7eabc6d82ec2e140cd8c5b0bf21dfe3c791e713ece6f2a3c3bfa753a95f3917a4b7b48316216435ec6ca89fa12292cf8c8d5d1a644427650d551ecc8311e77c1117456fb6b8c338cff77173b243365dbefe6e395c75dda2dc9b35fa493940b95cf351a008d8d3cd2aeb87dbade7c58b765c90ec36567a4e0c55576e572b6f928f21a7233362c86433f95494bf54b69ed31f64662a469a882b8869826a4a76364db22e726fbdd8ba7f3634f92b9c08a18553ee096b12b664be29f5e7d1c558673f6124229761bbdb33e7cc0143165cadfd5d25673cf6b594988fcb2cb4734a1bcd016b3c3a7c48ba7ef69a9265c571f9e5933901587709a90aba5ee4a8d3a1af494efbe1808359d39f9e5d3da45b339b35af9b6cf344f09d54d86f32c381e085634e7630d668865db38b50b91902361741b0df0b4b88f66fcbda89fd7ae56bd71f5c1b8e6c4d6f9c5db74d60a710d8c2544651157ee1d2197da19d1e38e223f9b5fab8cd72a89c0bf85a417fd896b090277347c2798967cbcfb0f29c7be378c4fbb63f998541d6ffb3b7ac8dff3163ed0e5cbdc31bc285a785a38334632eb9304d815ff7e9c2d891b86a3dec82a585f2133bf6ed3593e7425303516d62266b6475af7d52a6eea71aed6080fad4d2d17c00e7c1019e333063a973c83555cb86702ccc567bcad00890ca6de0929dab71f18b1e3dc5a3a06e6691a0143cfe70801c7fbb932ad0f6326cac76657fe81b8f1908ebcea1a1a3c827046ad6db92a89a56b9225d1ac3cdb9900da0daef2bf640d33c33f7172adc2ec208475915f9e7b81fae66ca6cc603a2b9a3be9c2a69edd509f90086435f16d89811f3e93569452e33b80f26f0f5560638b998e4ab5886e434306baad72751b8ed67eb29e3965933e32940b0b10e47536810831c342283607a025ebfaff322e3d54748f9b2e3e07b1ec39f44c93a937c7965501a939b049eecd6e285051d007cb5f7eb38d5b6807c580c6c42443c0f2cb6cf32c3bf5d4cf6f0e4f90b89138b029bdafb161ecee31e79dc71c86adb5d26a112be50bdbd509a9b45fc58714edcdc81414bb378c6dcd0a09a8c29d14cd4e83fce9f947923609af734136eb088901ccc4e3514093338e3a65e530b51a530966bc60cda96c036b656011d32dfb60a9f9b6978cc3086f4718f1d1e61fb9076c703e0fc0eb32531831e767cedefb1d1d14e125d803be436771849f8afff9f7b55e8d42e49100f6bc424820e010a296c134c96548c976aeff1e7acd6cd3f49ed8ed11fded6254ad030eb2e0892ec804a78d10db35618f1dfca8925ad8f22159a62f9e6e4f03e41bd83cb3b85bacf837201151580b59f6714ea4dbba0697a6968be937788d17b05d82258fc1095cdca7023f79d14b15170f609dfba1446c0e66b49a2fa0158088c91ac2ff31a3ee14f4bd22b4de3380074ae978603dcda2d004c036ce4ce4243e04f99dcc9b432729dc6b2546b395e444af16e911adb5b0c4b848a2e550adfc94c51b33a8f7e1756cce05f4fa47a1548778a79ee627dd38c355e928e1e783d2034e322d3dd70991c630709292348b9cd09155b9074e7cce2327efc12dcc80439422498a5060a1c382759a233e8d274cc4f595f0a157eed4b481d6b12d1f8586892b81abfca222ee47b7ed553d8580b9b724117d60351546978bf43b90359cb31bc42edfed5987001d0e7c9b70424ca8b967713c6a1d1ff6b1e3a3fff6ada42b327b0e250984f6f62378c2960d3684a4c636e400e85c325014a460170b72586ea07004a4bf716994717a46b2c1f48298f50bb6624bc4f8674bd0ff737092f9e64ea0678f9a61f13517398a4326d209f01c531afe19ac3843bc7389e1d53a7047a099c94f9a3f242f41bb18380f3842c7cab0aa4867611a1154ca2c41303ca814ae65e66ec600b13862d3d900f2626b2ee51b5323454d9f9b1bec4ac618aecb1dc20a44dd17c3c0ee84b8e36f25c4e7e17066c95ff980032c6899cbbe948b605ea10e8fb241a81c5a3dc479cda2807ca0343564bf340baea4e27d4305e95c15de793410b666c774b796f7bad746db5c544394edd40b78094912fb9cd3768ef458ae569cfe0a80cfedf74b4e1a0d4d5fc310079f3d83b65b71a4b8cc8ce7ac267d2d7e4468c7fdc0ee2ed704f05c99713c20e4bbc0a13effdc03fc33069f5363b9278058c89fe95a8a1883d2effec68177caa5c13278bcf9f0feb4e06e54c2b0d06858e44d2d4e6b014f60790a16f7e8976e6cc76caf689b40916e5466a2ee0da1ebd74777768930aa8e0870966f2c0c09ec30503cb042ffa74d62d533076fe4a7ab6262fc9a66114812183edd5867fb3f06743f8e028c59419525f2061fb4ebb55ee5ed39fbf838d70f26cce3f3a05b7724b5b7c4d887712ae2c93a243729c671aec2fb9dee63bd14007152fe13bcf24204a81e1423b08d8ade1a9fd80a6b6aa227e788f00bbc8c5da4b570052b4293b880b80fc9feab83584142cefede135961d79f3411ea4bd9fc2f47f08b3cdc6868bf00a6fb06e3904eab49fcec9ce9d4916f461760b7440316cc41d79ea300699641e56f338638c92e59644e587be594816093524e8aa787e0d1362938a0b740ec01d46edee5d276abe8400012778a2dc46156d728df303348f880ac537d6e8f6ddab45ba52326f9916767ddb615d9a9b3d7ed9f091d455c4ed3670b4e8d434e5979ee1e885e6019e1745df69289e56de4ba41ed9398c1f553096dbb835a2fe6a6858c7e0e5031a99583d1fa58e85e66d16fbbb2319492de2680c68d080c5aa80349ed5c1e9a6716a7addf841145bab2a63ae03a2c398022cf44eb345b80929d60db5862a841a2e588dab602a128f77c7817d7ab367155f6cad35a300319f4aab41200ff7494d693ea3f6cb808d3fad35404892e57111f2f16c1fdd1f4ff366616043aeea7d727f9c7e0bcac1cc0d7689747a3365cdf7a63d38d72629beaf1631d57c96847f51f846cdd72a026a99d63b1893cb0272076eb7aae73902783d76b09bb3d5a6fe7ef52e1cf7d33c4cc20aea0133a140893f544d4864ceda975c61f410c7782293ed5b966626a6d8d64d337b73822a7b3c040adc809c8f1fe5b1077e38ca087b6a7579de9088bdb45d2eecc71c6ebcfe9b54e5dea636359c5b3fe082d187c20749be4559909e327c0f30bc57651bc93e77f1d39fb70d664b089204cb2309e9ef1757446bdc59e351a71ea35d9777a568bc0c353cc787d7529b58d499bb119fa731a45d5c630e7debeff6c76fcf949f7145f92e43bcf0ca44db1ee11ce9d2efe42aa7cb707eea7c6dfb66e99b705f20acc3c202da530c7b17533b99ebd561e94dd4783b02415cb0e2144045caa0364146f4331a7d126f4f5ceda75b2288ad4ee87cfed8916b9c416617f8c8948ae5fd7b787d1f7950c9be3cc1f4fcf33d67bd9dfa3cb7fb925d21a2fa0df71ebf32cafde67932fb184b18699431ddf3a9bfb2cf7e06841ec853bd4703e9435d98b61cb1e000067c3b68cfb67ed02978b00a916359b4f2ff088469ad922fb05f5d74623ab949bd9085242baa23475bf752143e28fd4862f87f9010045c5bdce457cbc649e44fcdbc1853ba521dcbeeb6531e25142d6d85b80dd46bb1f4240c578978fee2698efaabf28cc91492abdcc0eb57af657437cb0ae6bac7de1078ee807fd804c662e17d568ad18716dfade200d6802148437ded05f5da14a470f045b800fc79d38920967582ff64c856b5214769892cb2e81e6d7c42e847f29c989387963d9eab831f28d54883cf895577e51ed899f7fd10a65401300a2f7cd18da49241201f04818139f9dec1791c17f46cadcfa5c4379db5d0a12933cc43c913818ee9532c85832104d7a9da58c902d73ca6722d12cb1df9a47be2f48ac9113a85b11ee70da6ea724d5d2e3ac7ee555cf4f0516bc567f34a47a8bfa668f1de7c3e86a8d4f10cf0a1094eeef1688fd0994f71497358eef979b620013ea5d894339d5023744c360941f9ad697358ebca63c0dd749a19121b29becc77696e9711b7dec3baaf7964e4e6264d48dc85fd7583a6416b5abdb800d5369dc98e4b63d92cb89b7b19269693f15d36e0537507761ec6706ad01b22c5530c7a492068e1982a063a66c8d07f0fbc729fa15f46367d940c17dc9df28892108ffc48e431fce27eeddf6a6d8be8a362a7ce040ae84e266936792742e0fc79cbecc8639c905301b8c7547657c5a94fe3423af1b65e89e493790e32d57fdb5c37261470898d0b771fecb8f6ed955c00e31e677be947c22a5637edaf9cb5884134fb28067dc22caae69b3a5dbf7af5f1d02fc4b4934a467834a4b6a96f4dd9eb0e72774cb1cbde17f4042fae408dd21ac419388430644a4d6bf35ed34c3c7d30cf9da14b0e1a7bbd5f052138e9b7cbcf4fbfa999cbe5f2d99499cd31d3ebe2068f857cb5bdb10ca8dedc29f7141ee67c5a445155cdaebdc95ef14d20e510048052500036347219b472a7e28b185923267fd0e6508a488a95b25264bae44dadfc19fe708c03218345f38229a3c02844c132bdbddaf9fdf53a252e83028e3ebc659944e00c7405750b753217283c18b0b62940b23bac4eb2575fd0e52a85f99fd1266e836480f7d543135fe96fb40712eea24fc4cdb9adbc8e39cede09168e6a703643eb9e6ac74c9e14627efaf02cff47bad4fe4fea62524378445221515ef2b51d7e03b9230f11f2de8758a81963b52fc02f867c3468ea3cea6baa7ec2850a6aa80473fde92a992a69bebb7de9f284922331433d9c028d4bae49b56cebb60730ab43a723b49e9f1d8c4159ba2a5403591dfd2adcc74ef9a0064470df65986fe4b910969ade44ee125cc466027c30e5ff5d7470585945bc6583203d7b1ba0ee842710f86ca869ea63580c9875d463189c5c4ef111393fe9237e55879c5de6a7fc7fac44c1a2b895b816260fefbeef60e001a1b7a3996d2931ec8e29cd6ab6f9f5167ea4eab9bddaeb12c8ab91766449de1bb2ca2baa5b18c9cf6d01efb4518d7eb76bac3f2f77fb473f496ad20d5905e0208c594e8a9de033a1a438e64f1556a992c68e0b55e6fddcabf11cef4006c55989afbc42773e279426cfaf58539fe77b568c4e87915e6b2dc462333c9c7ddbcec8423c7eba65548d0786f34d69c25da274b9562b008e28a6c76cebc1b5a4e33f55b632369bf1e0915601e1270659505d00665ac172b0b5ff067b023638a9e1482ed11b8d6c97df74efef262bcad078fbb4dbd6d2187a5b831b1bf572551a82f4da193d289560b6e75d269e542b79aef0b35b2a557ac2c07c0d6c1a44b1137bc7eecb04cbe8c7ebca52267a2add3cc5cee836d566f8271826b7816ff3c93fd5546ce7581b7c0772903d3886d21554d1953ae6738f3d20afea07fc92e1a7c832c556e7b14e7f4f7682d4d2ce8085d59b47161ddebc7407dad070c9a55939c053b75b797953a183bba13f2f5a4aea0ef634154a3b085b81e0a8c9e78c5450d59d75fc4740647e9ace05a9c464ac7d79c8b059d8b7ca93c176253f00d2684f8743ae3cf32a68bf820ba15c545d91cb0f993435446abd3e1ddab0c17ee405b14eb26a375691db7eaeddf46c0ceebb61ddd8539f61893b587788332bcf69a2fdaddf339e166192920c9e7e26e95f820a29a511e0161a6425e408df6b815a186cddeacfac468f3e8d08c0dd94cbbb9e7e90bd13af73cd13ef83d97f0dd32bc082bdfe559f0806f9008e0d561d0d2a32ddad32ad30334dc2a1e54f6777a976bd04fddff4d36b0191a569c2e32affa4525b8db12bcf4ca8cefdaf7e31213c17cc5f333cc37bd175a7dd6ee115e896832ece51556964114b9148de8c5d5bf09e41c92d04e478f7cd8078242198edd95e6496a999b7c1a9aba3f905cb42bdb9d1c2a02c037fa00b56c5847dfd7ba986ad2bd901fbd4fbea1e9c435330ab8597b6b326db772a47a6548a41b68e6eda1d9bf2c08847c61112c45f4727af0ef94cce03774d3edef6205e16ea6e2b6cd503d62e4d41e8b14390f8b308e7b05aa6a55ac4b7a823e4029f12c125a257b1793aab95f4ab3924f0ce9591cacdb22f9aa769f543ea030637d4b34d77f52a78dc659a4c72bb9add682ca29334265084b28a58a175d53215954bc93fdf5631c90206bb5ed6ff63d47e3042f521a79e31ceb836febef90878a50c63cfef89de6cbd77d456f2966df71ee6d20f80b426741a73cd01a338e26f07d5fd59b91de9696eed5fd773f3570c22615384d9955f76e77b55d5b7a46c585341fbd090793487ad89d1a3c860512433d1e2f0485590f5b33268c4ccf29beeb723e08a7c7fc1695f7945120f664801e31595bd8c8de9e8a7b35c22bc56f536809bf161a9c082b9a50349ef4653e8d40f8b18afc285260b4575ee0cd728f5e3a7f0ed363b7f7f7d380edddbb4e0ee20bf6642c4a4f0422d0794a6b7ad307ef154eed82aaaacf032b90c673e8810b1c76eaa499ff34dd7644ab6e7cd1a682b12cb958164d6df663a45ea7633e58d5c30e585611560fee635de133ea5caa802d947d63b808f08a0ffb3ef540581872d031d79c313a0f2a6681c6a01b645ae460e9966670a0c1e36c189c197d1d61e3847c180a6b444eafb052993bffb376462c9d54427ffead14c4db7419783caae0c604f1ccde8771ba54f8e7c2754a85f9a457d73a7a8bfaa533298289508dc15a04ab26feb3e54a3d2289124a6213b01436896b50cf757805558549ca281fe6e4b85220b08c42d613ba27fabc7210a973def560f2a789bd8d994ec75fd529803eec9040d89a6f0d33e5cc8d8542f44f6a0fb7f895fba56e913b24cb8a182a88ed47ba339e5c8f25fdab8cd8644dd30f1aaf5585cd813c067833abe4d3a99c0f682612549ff066b11eef3a08c00b9b8cd7e4baeb07ce4d629b07aefa730f11e3a2277473da3b057add332e9c61c376707dc2857c3b821cb25eaffe536a6c06635d83f849f4eee53e6dcc5aa56fa8ad6e2bbec6cfd9edc1b7f1bd17a02f888c6403903634f1ef19342afcb5a79fa85cce01f95937e72af319f48e36817ab21790fb78498ad014589c25e279cb7de3c2d62bdc553cd38faef909d1e7f80db6e23de585182d78be47e9455d16a2715f9f36bc37cacf68e85f2c06a91113eb7a1f768f43f76f97df6c9e96f376f3c4d4a48e5e02ca476b08cc4db8ec5bbc5fb1a0ce09e3d5fc66b9fe12463558198b01a29da6ccdb9ea8d465f9c8d252aab8136f0422c8c317cf57c9b50bf372775ec1f38177a859522ab60d69064a51c037ca5009522c9740c13d43c1bd8e730b6f7b01666ef8172e08e2f18f921610e044295c4dba2513b4c243cf7ecc3a1acfc102aa60c8be9ee94c6640d1283c3ac7d5f378bee153a438b513cf0c8cab50b566403ca20f6cd81d28edeebaab599669f094c8f125b7351f6490fc7f1e20d26e424cf5db7ec86380d8d095391964554aa8d7addb5149e59948a4b26b46c5bd7ca3a62383ccbc4a50f553c12d89ba6a15487ddb0031c690d3dfba115db0d34f216eebcbc8ba82f23c8266ba6d2af2eebca2edab816c51baed93841b7f7c0499175ceb072c9dfe11679cd89d59e323996be2c791e8cf6b079355655134b65eca0c128b310ad9253300954a5dd2f2a3dd18db816333eb602e6e8a6d32585572c0b5510ab5600358140776e983174bce8d01c184a1a344796bb9013eebab5fef693b222aab4a31f294109ea8f5dc8e6eb128b2dd176a81f10ca3dae655883f8e5f55878f0d39a6dcd4007ed40d14df34b3a858b4553b42adc647627900ad47d5e11e012eb3ee07ebe143e02aa640578283856d5780901d5cea5afb8466273315bed9a151b847ca53ce57c8d9c145ffc80b3710e1cdc5de3919744f61a4fa43a838b19e41b436f7dc2d9b4399ebdf7cc019531688e5bea3ae617a6fdd9d4ee91b9787e85ee035edc9b76c0947ebdaa64187ac5985230a835a45805c8bfb3beaac217aaefe6fc777256d1261d78874c15a1f5ddcf0aadfc84bac15b2abebd4e26b83bc87ed2d9e1d24aeda883e5551d92713fd5599411affb979f0bfd4c1b9161271047ec28c976898fc52dd601833279d16ab12e91d54ef42a94faaa68732285d79b491587ea01c37c3f16ee582ddfb4eccde054e69580f2cd7b8e9f9daeac07330d654836432e2286afc18ab64e115575706f3d79d2389732030aad23aeac86344ecb1053c71ea6786248cf79ac0c9b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
