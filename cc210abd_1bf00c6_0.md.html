<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9dcef9cbf118ea5768b2dc8f88e6134f5aba59345331890a84a9c28e3e6d8dfd80be79aed50878dbf07cdea9f90973d60e290c299427abf7089c1281589c5c4c2ec3e4e102029401c79cfe1f12f636543c561342beee81e69a1a9ba80ba57cbcc732ca6aa1a44e620b5cc070ca9022188e28b900227333097f1eb5dac3a487042efdbc0ca7cbed56190f1d5aa3b140b1d718690dbfa4d955c916b1062ced53433f2f7fed129bb6dfce9d460cb4587aacd788ad1d2cd5da1e24a52d5206b42558a68b3d101e5dae41638c95888dbc3446150f2665de6ef62833318719cee4e9702db0ba57644a3e1e0895d46a9a501c39f51cb259cadde1463b31b36d16d7415ed8d6ad7b2c3b24d2db1b4142f5d4b4350eba1df0babbf1d096d8cab6cdc622160c76061e145645f374d6640addefaa0108b1b07115d8ad87dd78bba501f125a584dd82fceacaeb98ff177060f0ae5cc9e24a0f7e7d6814e9ee70f5b0e8e47c0ecef3a3c1c34a1bf22cb1c8856a04bcaf4111cb139549bb147d6a8d3f98a599f0210e9a12f40530e887bca4f3054b1fde39cfc02204bf439a6666ca431532cbf20223102473339eb509c3114f8187a86dd45b4ec36def2ec34e142c5cbb96c175cd60beea9c760853777802b53abb31f8085135551f0b69a38ab20ce52f9b5ace18603e1a58dd6b8ed699efc512286655467dab20434be1cac50912cda67495a55cb8abb119f448cd54132ab0b6088280cc03cfb2264d3d527e77ddf54675bb46c630de0e4204c8855d378640b2ce80fba50c64f0059bbaadbdaff465031beec84bc9a82a7a21cba7a09cc5fd52779e0c0cfeae455bead541506b5065881a88454a741e8a4612b4524722247302220d0463cce78e4e4024087841c7bc94639193f5717b527dcc48d01519a05227a38f6db84ec815b29b3d23901139943a3ef399bc205879b55b07fafbec07700794414673705c880c7d6805c20b35a72a1fcedb251834335cd42c172db498b0d88dd682ce8b9afedf6ea6c2c16362fe3ee06a5077420fffa86542c95ae3bca0be074f794b7996504331ca19daf5b4c205a7eb1cd82e65be1a1b00ec2de6a78d919ca39d7d42742df58356c975734e0e9debe0fc46e0aed30e3750d31b7703fadfb9f0ba58f14e4ea98f96b889131cfa6464872cbe31461e1b0f679745c301dba597c86c16c600940bcc3b9150fdc988b3905f161fc05278dd2108de12c56de155dbc631c3d68703d0035ca7b9ef7c5bbcd6296f18e7b22a8dd2acadaec4bf71bf6a932d0b49d25ea7f99eb85da2f46ee9329e770f28e7a0f85bff096112593729ae174daefdde234e936256fb055375a6e6c19380695338573df385b38633cb2b1c9a7be20c3f1c3abba032c37ca026f909f5a61c599e3baddb092ab566bf7388569f9213d9cb0eef817fa0bdaad7496eb017db0840d4bcf3ff6f4b2a9a726038d872f23ab04de16eecca174d4fd0634478c0b20bb160244246816159900dc7642c71af7a4dba5bd68e7f0179c20b6d8aeae7c5d6cce81ebc9d45e7017d3a3708b2863041a4f3a45c823277b2e6ed592ea5837647a5714309b68a32bd17dd3daf9960db25460b7551769e6cfae986048fa89389ded40e104ea8c3457c18e37d7fff278590518fdfe17b1e5cd367d0df3dca1f97e4f365a0650e42ad5ea84883a616b966f8caa526a65c3c6e2fbf0ed4ee9d7fab8d40596066a93b927b9f820c0d669e16e1697c9ca89787b78ffe85ed900aa7941b57d3083cb6075b332601294f71ced990aa0a1e47d59f2fd12afa0c88ce569f13a65474771b2c91c4f9b7884c2b1dc00d3cdbbb581f6376e769735e6c614c372b85eba747caaa8156097c7a16f4ba255a896b13b098dfb8c524c480e3f84b45867896be2379902752dd855f05722a47ce129cedabf164a1001afa5080a7ec3a85ce3da8f29bedc88ef28951aec9cb2d71182caa40627be509012b2eab3ebf14faa79de4336c70c1bc5e2a03df15ed961df07d7d816883441690ed165622c7810c19a592b2f0ad57f483cb45b60d48b9581e40341ada0fc39f09c65102576ecc8811e6019b006c4b9fe106efd735362b0371702b90797f2db7ac836161db875241f9d6c15567b8765d8d93ed1d65ac4057240a2f2ff40a32f249dc3f1601987a53b3cf6e63d95a0142002755a4249eb3665b660d1584c51900f1e6e2119db1f758d49c5255132347806cc1c1eafb361b1a3d6d0a182a3ba1bfe874c0eba681132a6d4666e0341b5aa0ce49ab872e1d7525943a9a8f9e928a00063151323c09256bd069520db01994f21c2ec391a1797f091ffef1bed7bd3059c0ead9630e6892b000f7cee8c40bf6dd085ff781e9d2e51a0ce5024f23660e5a4f14adb4120f65055cdd89b87c9a94200d8db0ff5b9966f5a6a5d4f474a00a911f994ddb79989ee24b0f79a90ccddad9167235516fcf77beddfd873a80c8239cc79a0f5e809cd33b9dc19f9934150b7bbd4fcb130f6611e126bf06b0cf0ca642a616b669ece022e2ccf8dbb936f31f121ff932ac0ae0093310119b8cbf7195e6e5575253b7fb168b4af6d4bc39ee8d0bad56e96dae06937857be7a4f900771c795f09a29ef8ec38d4d0f1059284a2959465335d0817e4a500acffce4aab19d3c5e0698691de1cf211db438f0d8fd17aad6f4573e3781e8374f71a9916353f3bfd6724b26ae1839aac630022830ddba27e666cd3fcd207df4f05990e8a67c24a0266b255e8120d9479c0f85036e25ee2336ed63ad1320bc8c7040e6b7e718fef68d7a58275e9c88c6a3599370a7250894c778b6537cba9ce7440d799cf00552fc264b908a638e2396d2b9cc8906771f1fd07b89761ee108174ba02e9034825194949551bec7804d577219325e85bd457a78839fdcc07a94aca0f4c70a5ee7148b01d3ca13d8563bdedb023fd0de03915ff7a61486ee1f257926db91268583a88b2cf885e0db00720a3e9087b624fe1f6bf94fd03efcb584dd8616755bcd64e0434f19419e26caa5bb78b81803b311b9d5eed06ffc3fca8ccf501ecea00a48b5bf42d59bdf25ee19029494b93e6a9344d03752234228f02c8bb47637aa16e26ecd2671bfd096584c75dd0df7013c6444385ce39293d92c511169ae518fda57f17bcbbd4d57c93afc7fe55272cba9c8daa3022e91c66d7a840ceb42b89bcf7ac4915de64ba09310910a0816d3bcf6ee9a60b5714fe5477575ad24bef7681b4ccf86c7512dbecc53daa4957c07275aabb7a7347d99787b480c221f03ea5708f3b16785457f98e98317eb6457c6b26db4e5a4ab11446eada216abcc19e6b99d23ea36fae1cb05bc802af326a5cde3359a56eb27e2036ec3acc5c6b467d83ea56ae41ed63ec8346bda238d0220c7a47d552eda63fd1349d027f7bef221948676c311c565ea9bb19a385b2d811e41a205f012569a348922cb71a22bee9f617aed37c4845d29ec432d6d07d377761400fa66cf713cc88abcc89fa61929d564a6f106b889489cbf70d2f4dc03aec25ce0345d0596bcc9fb4b87afe8f3a769850b2ee414bab718983d5709128169bc38917806cb7e3711d208f70296f2cb780e2d4dfaecb5f0c49de58d8b62efb1601fa46754300c937006fb9ff299dc6bb4a85e89b3555a7ec3a7ee563edf9a6616262566b03646397af76e5ef8541914336a152247555139820cdb73daae4d3ffc51910622d75ad2859ee9633f67cc6fc70560aef8d75f03ade880125fb32a0d0395a9b99a4df6b27c2fa49dfc4366d9d42a6e6f03ae567b50977c887a68f041bbed054775ca6d59d752b971dce1ddf5ad7abbab5450cf95901287ea55d9e0f8d578e687959a7ddc42b790c8dbb537dc9d1e50c51e541c9552bfe7b930e525fd157b095254c4bd96ebbdf4b55bf3a46ad0cb9ccb6e697224937d735d5139bc8f8d2bee743206e4876185193a30904697313e32c0e07190e1ca5a7e9dbaa9c4898f5d4a9a62cdf6799a7cef4ad9d6a0fec15d3176302739b14bbacc3b68f254db5b20a4c740a037221043ea1a92902357f2bf4c4d7c55a5a620c49fdfc3498b12f13aac3b935876f426a4fce1cd9519e71773bc57cabcfa4f8507bebf67cd8c573f9a1a75afd35554b3d9ba34040fbadaa68ac73938d7ede648d5ed55552cfe83a35b266045b1486fda3d9fee238981134f30c4c4c02c14243d069a75476e1d9745294566c3e0a09d22baaf8dd1a80a87004a5b0fa3be9d9ba9281ef43ce7fc5fe746dc361e7c39397d04f2de2126440a9e0fa6956dec10254f1ba72955fa6fad6ecea45f8da4bf2c1e76a2e111983368b11b4dca1dce39187939913cc15cd0b7176887d655d7ef0e2c2886081e5fafb87d8194f70bdb7c13d62f386d7968fd832af721b9569e52cdad385da04038c1515c12194447266aa9eeb53a93e14ac539280443ae8ca5b4843903c3f5847595af98183d4b1a598cb1abd3a300e9b5420537e495318cd6f434d13f34e5d6e4c15c3a2792e80df4d05c8c48a3b6f1188ffbce611bed2f992f9b60a22e690f918b52c4ec5f70832c03a5846c73ea863ec9985b3724ab34af440e4435631627f6bfb0210c8ae0224f074d352af3f71289325db9e3dead6893448bc3f6c1ed71989c2cc41d321a1818d2ff5bfa97a3279ab7f8cd056e0b3a0cb205c3b77b03b6d9bd2d4216325bda1f9552dbb19ca0c01d76a6c0cea9a4b44bd64b4686f92d7ab283adef706df9925793793dc33b5f66b60f036080aa7f91925f281b597966b842119a78911202563042ba1f260cddf93973ab1b89ed77173a84bbeb0bb21f598f05ccc2963c32d30c2e10246b970f76d42a05f7582a959d0e57a8c0ed22f67551fb666fa82165acf7b2419bc6afcb58233b5e7701dc00740ac3e81153c44a6eba95959ccdafc70fc2e6a14cd5755dae67ba9ef26b6b1813dc3577d17b89714911121ce9c9cafcfd09c232d9b1b7f8358a11305e833f1d65a3a04f93250ed47470b6edc64f41d8681c727eb0ce48b2ba5ae80f5746a77dae7e6e1d6070d6ac5124b45bd0cc384652cc471e39ba78aee9f37c28d5f7aedcec23d20fc98459ad1a4b19287531c216f69583cd96cff314302c3a2240087e75c9006295302b1959adb5a512a178feed1dce0f6b5a74abce8fa053e6b760efb957952fe7ab7eae4492b0dbd2aeeef900061b0b02832b537fe05f24b5a0485558a51fe7670bbc8c36147068d40fb23b343adaeceea0dd8ee57a27c695bf59c4f1bff07205f6dd3ca88bd3a3a579872dcbae6b237bc1e2bacf9aec00de8f0bb78443360aca9ef7d7809c45a91ec744d926da76c4612f1b64fb59dc222a0428c4dfa9c760978e528f620e8e17cd085910f022c20a24211fd72b2c953e5aeb7763b58119fd8a129e8e9875db14556c338e5c220735c5024578a9b25e3d953fcef0affce9688e43b4d7526110a3277014a2ea84206b950259a1f7ca05eeb572cef0c92cede9d4e23d0bc3622e3c6cab0d98cfe172296e0c7bf6588d311cea0e4364de626add5cc93530f8ca5a86d1c3cb8bbe89806c5306c5284abc772af8a96beb4642924261e3f8537bce7ad86e538d17d867b9ee09280a465be0fb130655f17d41c3decd3fe01d8b11cdc6008a2967eefda7300a295e049a6661f1dbb22604525a86a3eb6fa96bb0820741ed5d3c6b63b7ff1203eaf23aa63c106ff884ac9f861b22ed6334e0b4ff9b46d906397ef8d1b593ba98f6d28be1d45eedc21986a090ba9bc45ffb75dae6851ce852469c3b8528f7f838b9413e414c96f02e229779c1e09f6375630b3001ce9ea8ab046d65a91e4713834a614745ee10177818d7b0f5afa87231426aa9fb7d51d855fb05f6deb901a6388159b41c7b6c3a870beaf104d7ab2e0401322ba7fa9325a4bd6953ae6bc380b14ca77f389b05181c9b2a46a93f32b66a4fc50a6a568d39e5414999ad73d7c1a814e01f654e934e28957416a59f124c1b736bec627d5c3f38529d7e598908dc54e68e8f5c47ebc3d9da2d50bf15996b6faad1a484dbfe0026e0fc2cdb91adffdaeb27727e63e581cbfbd6136c8dc20da3aaa0ec0d66b5c1b9de8311c83a64d207cc9e9ec75953f4b364a1c73d35f0f3b01a16395c2b8799a4416cc8e803eb7d399ba0345d63b6f903adab8f23b49aa3f861bc5ea534bd55b000cee78314b4f6c75c58c22501b2bdde7accaf67ee78bac0f31feadfb9e0a87d02ef7dbe37e3c275aecb5b7b16a5e8da95e6347f585f8f1fd44b2b98f6668e883fe4dfb7cdb8aff120e54b0d9995cf2f95af1ccffb0ffd79d2c600eb32344ace21fd930a743bf39df0c3011cc9b7a28385ec8494233c0e9bb0c952f8331140ad7e476390a7e3ef5bf0832cc6ec05718400ec37e08ce8cdc64a545d99047c8649d1ccf274bb2a1c3059ac122a754e90108278c6a4a962b10af254026187146ba0ed7c3ed6efaed0e5c5458172ab007bd41e2e822ed3ac09147a4cfd6b5ade969f33c480a20f4b878526b931c55ebe174c9bacf8751700f53d433ea7abaf0e775b1a534573246117c32130a82e30dd769ac948000351bb7eb01f76461012f4694ad3d87040a1cc38010c83298cc85a5700a658c379b98ac679553ea62e2234da963b82f58b1737c5f56621dd36a93c3feb483a9472299038305f9adc4aa652bb23a5415b577b5b2aa03a809f2e9d8c2711ac1eefa9e37dcaf79f58cb2d3af0301baf21b0ed6e8333b9f81ecb6791ea4b884d3e9adb57d8aa0c9d26f2b81f0dff68f4bed8ac85638800903efcf95644e98535142f808e227ab6e657637a3e962d106426ff5d2ee1d26c7c498322266a92273b1bf1bdddbbf72cc71c78983c8c55ad9c54ef2dd1e158cce6f5d58f25bb91aca6bb578b4c4851834934611ada0703a32e3fe2a95429f50af634e42b488e820f0ecb83b682969b5a3100f0fe40f5bfdeb5b398b867d4c133186f9ef3acdd7cf946eb885494d3ee0bab9d673c7e8ec833a47197dafe98ec881aba0146b4383b270a3db41ab5e65f464eb6b752bbc8e3476afad467eec4a80913f5a23726de3c098afc10e050f2777456fabf3dcb2868e5739f21ac8825fb89cb22caa9776d79bf5cf3050f2dceea56e58f642759b5d5416fb7e2eee4cdc438d7444304c757034d296817249295a9f8e3052e50d7a686b436309fb0f9a2ed3fc6632dec4a6f4d1c8295682c5c6c9e443aa26358c59ec62db8a5d88a5852942d19ab50da4768a107d2dced45a36cf91a6769c0a18bae0051bdb906f43223aec4fa1fb846f3d9e55f8e85bc9e13dead5f971181e7aa1b7233bf7d1cc2a74c49f73b105b4e2a3bc2eb0db967eceee087ea530edf9feb4ce42fe56f571490acbd8f2b97a2aa8ed892082805380a62f160671ac4ad85a8734cbf8a96056b85e758f79a97bb18d0df52d266aa2109009654f06abe6ba358fcbdaeb45eb4cadb95c2c0becc1964d3504f5cf4309e8ce920940c6b5f40b01558c79ab873eebaffd527c627fa401f8e05dcb683b673e66207bf9c68ae8401e64df8760731f12ba810d735c27ae15622f2ec5b28eee039767ecdaa7b88d240892b688a3b35d19cf0e76c00f1cc4714a99d39ea63ddbd5474e2b87f84d450bc7a8e4db026a4bd0ac770c74739e18df3cc237e18b826812853b402354278b39f92189dcb7d64fd725ad8cefab7df22e097d4ab52a74da635a06ada10dd154262b9ebb9049570ad68f23549fdedb1d4eb35542378fbd81257867fb2663aa338acd12417d4d021598cfb2159544544116c1e95497402ac8975578089b71f15897e3931bd8b9b9f793db83a2dcc5e884709288d8abcc6920207a45faf08aaea9c468414882bda58c395e51cd615444146fc245dcbcb1cf3450aab96f2d3c3c2bba100053ce56079c4a70b8ddd834151460870d9ae26f50d42be9297dafa0cacc4e44c3e28ae16e0e8a9af0878c78f2b7da244a3436344ce4536c7a05484600cc8ca200c7c975403a5ca8e3a40a5b2961ee85c5dfbc0dfb583c7cec978bbf56c61a1912654d92f36bbcabd391a4a90bb4c563c82651222f2d7e93a17fe8e6140945ea15b70ab279c38fc024e11b2009f7fc57346427fb16c3539d1a5330f68f6ac37b8a8ca19ac5df27285e05a07af865e7b41496be0696d5b2b22b19aaafba49470ecb3f2efb3bfeb3ad13b098d06ab92ac8b9fb181b88aa3b3dc70db6fdb67cf894b3acb85fd970b4c778ff4f6d5a928d8bea7e9aac769096035d843b9c39b249fee4e823eaa4d92eba683a7b18b7c279517089214e32cfe486c6c076d5bd7a8efb903612f968c10de45ceeb670adf1061c64af59d80e9d2f27b1c2d8fba675356c7c9a8b9c70b4e02f89cb0e82db603f907ed673b3ee928da936c5ed28b106aead34b39993d6c7f57d241d23887377f769b2e9000a6dee9d6dd82be35815d8add56694e7431fcd34338a5492640b9fb2a9906e52c618782709ff7f9f002491e962c5d640979e716078af4c069845661657ae1096764b45e2a02be220816c89ae92014a5eb62d6a153a29d6a448341afa61773479539d98faf908dff51ab790346936566cf06acd9fbfeda6ef0fb7844d69bc19ddff63379ee2dcf9c41de78e0a61df9b02f0d30ab0d2b4f992b7b52d498827c450aacc51f9a8f8d5a5871e310e94a61188083d9f7143b29928c747ee8cf791ada46af4d6b87700c661cb1b15f9945c50af44af6829627e17fae0b06f03108597fac972914beab5a3ef91a4fca446b901f5e587927ccc0364cfd76c7c46dda447f9e66713ca4455c99b6b89bc77cd0ddd31322a99dac3fd2f77070020fe774f96ae16bd3732dc6292b19a1e5fede0a5cd7ab36ab21b464b6208dcc408ef1849d2855fefde41eed8bf6a75e78cfaae8cd6f427039dae94ede99385c84e0c1999f3d57f0d2d9a14ee433cbd0db141bcbcb1c832a2409b2eedd612f9bf6ecf947a64d65fa6a60d4eaed177ac27357ed9b0760e043fd8ab9e0981786f35b4c0a62663c6d1e7d13674e1c60908175ee852f48112bbeb1514f9aea93c72e435c4a6a8e2c023c1ebe896a5f417bb676c6ca2b3199d72dc3a6a47200ac9efb67adf8777812483fb6705d2594d3018bcf31e9a23bd7849098939fb76dfbc9fc15e0f2e601a202f5d4221b4b7d639e44eebf0cecac0ed7db5f3255045abd59dbf6d1533c1472b853d962b26480f289329b1bb15480fffd93b1a88e86cab80d5084a620fcb3e4456120803181eafc0f0aad0df60770581e664de9482899c3a89cda0863bfd56c9ee95a4bc5e2bff490c76a644f0ff0e431c6252b47b9478d2425b98f2ab22bd0ec45d501c8064b2d79270ffa2301c69085a08787bf9534bc955351b333858ed0bdf973113d1df6b47303336a917070a079bbfb96227628276d7e461c47f6d92357e7e6b47733e1ccbe0bc23496be8dd2095ad9416000e505bd637e03bb097f83c891ac830f68fe605b56ad077ef023f8f7a8526312006406a335eaef54e4a63908389646e356c8ce47eaf1630c2ff914f6a3d9a7c6167a24316f1b34c61a445217cc15047ded0f7344af0c18dcce6e109bdaee01362893951a0d44320e9e4cc39e3377f9bfd690276f16488d3bc4069f91a7bb645c0ff769b6f7ff97a738f6493be5dd234a3be645dc87e2b67ff7209a2d788c5e9566ae9277532d5599eb12ee8e1fc0a9e5e5432bac1625856ef6253e6d7de47771fecc58d6bb7e1ad52b54ec0d04bcbbb9081bb6eb0694060378c37dede3423bccef4a3652fa6d3fd6d9ecba10b96ef4793f80f455999bad987d4103e914800239bc087fbd7dab8a280d72ab09537fc0d0720450a7bee4e2de05ed29c3c4b4bd690c8168d38bffd51a497c40f476f96e956031b76cf4ec9972b7c0a9647a27ab4668f80f911acbf69673bc89d46b1651bc315fac11fd6f5b298f8c3437353509e3f1ed912f55b426529d623e540bfd8b7307128c377f31d2e3a7dc412be62b918a61018aae1b389dd33f2645f67da4b7f845f9294a46cd99515817da847122e91f0cb82460a895808754ef1f9278b9d36ea2be77b615164c8cab7d8a0838cbfa1d8d05972ead42f2a6a89f297b83da8ddaebe092de3a06e5744d24860d34b37457c6bba971801f79814b6c2dab359ea93fe53d15cbbc45c19115f456c8799d05532d912f822bcdf2e3ab17d8063dd689b6f77166817b4ae6bc16365837378c963f89cfa722f35fc6e63e7fdb084df014abf2f5433b520a98b830827849e23c83c724bcdfafccb69962a0a6375689fa1fd5493de34e2b1ad4cd430391a8be15c680f90d73d64023f69b9398bb2adfafc783f6c3133a0a72909bce4c7e045849ea516239b671bcb22b7281f60d7617e539e789b6632fb1bd1090b90caa48a61417d212a7404c7706acd6d631256bcdbcb2a2365ce2768abf7011a82381c8f96b39f1aac0c4cd27044ac6071100b6d9da3330eb201bf0d3de2b1580055e1b9dde63dcfc04b9547e3fb85f3ac0179a107465a6232b782e51116b8dafaddf7015ab6418943b161e43214c2d0f373bcbff26d1b4eead6acade6a66e980eb3b3ed00f34aaf67812b881e039db382e42ebf3f47d11dcd67fdf0d5d7abe3e994bc49e6c9aefe09250151e49f367e111be20b77c5c42d90b72839e08b97480c2f0e29c0013cf103a28777e7fa901181b842f918e8aa2e140438aa9ba485305114d3c5b3eeb7f59682832fd3201623d925d54b485d5af783b4313e3ed2f49195728369257a61817ae110198e3685565c21f9741041a166928404bf3649662f4ca29ddfbf14c7afc5cd5a0607dc24ca2c3947e7c7aa76f0f82cde0361388faf985fbafd33b2f05779286e6266fce80c3d2c026919f15b9dcd0107b29f745918ddad4d6aedcd289247ecea87b84bee211f86036503ef31940232a9deb04bed28db0ecd70c8d08d4ff04249dd6778a31d605bc4017c671e0aba0bdef2cacc75f0764b0a80c149f9c0ffde3518bcff8c99aaa864fa2c8663904be542e3f28803cdc1be51f377db8b7d198a687fd1aab45015a98911cc9ad87c0066b18039551a91bf9b763928b86d8b57af8f955bda224acea0c45d959e5cd57595b2507282af2e7797","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
