<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1cbf3f0866fbcd949b1fa123f9540b3ae0d3cf398a2c778cf5c100a408e7f4be6eaaeb8d698ad8cee9d7eb4ac05620ef783c7acedfa38072b1781d3a4acc80161f7f1094f2646e9d28a7dd99bc7d114040f66422902e477dac2724a01339add8b0033700a4ea1aaf21839a993b19d320746eb2377025026284784206e79f34565a247bdc56fbe1cf190135a629384ea139d109c36f3b19fd41672de9f01bb8ba3f2abbcf87410b0b14099967ae74759101a0943fea519d4279d5c472f10b70ca395ccaf5e6b1e5e43e14e9c0d116c154474d84d118ba27494e61365e2fa6d4053b01ca0a39c716b6a19220fcb871915b47520f12790c187e5c5c8d189bacc4cceed77394cb8b66029984a9dbc11ff4057e9b07c5f9017c2e46772f2144cf101dceeaf7296f9ed106dc325dd53e48a95f307cc0e26f56f664f206cc55689a08920f2b1a261895c242ff95d9c7d5b68175e6c1fed1be5f8d2e16443eca61897c79abeb9cabd77b3581f094570c0847eefde878e69e322822ec1bb766187671567dcf253cccab404f1b5a1e2ad920638fe10fadc3c2c4dd1e7dcdce7e8f01526a75fb22c95e832c6fc6cfffc810de7a5c4aedc38a04c0fcd992fc73fd5f40dde18b8cbd1bfc5781c6350d0b6d7a61d861a1d1135827c3ef3a0cbbb154667210da2e99acc3308578af0722f27476abd99815950ed7fb6c75683bb56558270f934e8673980d5973691c91fae924738b427f87a7b30534f15d5316721d3005092cee739519cb135d7da30b00b96d83108d1f4050bed73e19b2ee78ebe0d19e80d71c8d447566269ce311db70f7a9b6d2b864ca272c34ef53095309b4b86a363b0c8e1c7cc6f348637f0428a6b1c4308de19b7b65fb251561fd38353df7b03d9f17d552fb8c3b21b81e8f633f6dd2057fc1c3fec99487b9f0c8bb98afc0458b4638e3defb3b03548fbd5944418f1bffd6d369a567e44a8d62edc0da1846d2574a5f76caff5e3bbd7c4c8c60327e06caba60fe65e43e90047dc715676bc2f854019060984ae3f27674f49d6b668f0d79e41dec4feeb7b498db73afdabf2465e34a65341d9c8000967ac19988c57b5de9829f60e59b4ad8d7c4e765b005ebc83665d1f8b3cf1e73432e4a50084a2f284fafd298bdc80b1ccef46e9dca5c741f1578a014b2a568ef0f27e4266167fd39c749d1635af363520000ac7781703dc4aa5a2e9a0a00943894c0f954fdbe54b8095cfeb8768a378d4d5ee10dba740974d4de32320c119e863307dcafae6803a4d12a33abc9adb44ea9caa4c46050a35c7688db278996beee52e30f8a66d315ef00391c506d4d264bd4041fd733fd5de65e8c8e0ec9a209565f0e8bf275381e04b74d25aa31d828aa94fca5e298c0f1f8e0e0b94649639dedbc0d2bf3086eee3762aee405e20050aa2e2d2dff13b1cfd9cc46d807003d10749b1708f182660cb1cc46276d88e0753b5c68e6c6de661922c85940c9b1400db3f434f27bcb72b623df341f4a038f865305d1a9d862a9aaf57b77a318bd14258037fe90d98c2b98315b9d9c5e527052e4c188a91e930283777ca354fc143c57ad8bde0c28347eb272bdaa66bed113b29a32e04d282ca4374fb9ac360bebc24581147978d12657f25287bd1342ccab82fb71b79b4b63c8230c65c8bf2b0f865511f92a7dd185b45130f7af2cd520380939fed5ad3c168c5fa2761acbc683ef2af8920f80fee1cd39965472dec1ead250d4e4300d549ed48ef54d8a2b108fae40fa34be083b7a5ab5f24defb6e2a1b39b17a1bc5353169c1cb56727adce41ad9d95d9f6ced0bd3a4aae27f957360d8183ef93f884319e07ab58d86e2b9ade512c5978d8fe0b5e6d30f811ba4d41c73492aa86c7e00f23afd8e0588d870f2ac7e75190c841c99455125e744690e1ab8fe77c925df29313d4842a862ef74b3277fdcd69c17a9c560659191bac607afc0ff1a40b6fa5525504b8c5793ec9f3c37fa664e8d2027530479bc987e40b1214b5bd0c1e850fd9b2450d3df120145824c1263a0b38c8438f943c2297c115061f6b552d226b606c1f96602a3a8cbcdc552b490664fab25b687358e70abf4c92a5c7621edf855db7739c6c7ff950d2626f8eac66c118507ef4f5e33af8036937add9a1b5d2293840e787ed41727be4684956d141adf4eab03650c76680723f0c120ab8b3b78ab94043ba86658ed3b1779b85518db9e4bf9b6b8a26e596f3b45b7aeb5cc671135b1c2a54f63cb1e0bac23ad90a4aff51f6714553da658359787d8d779f26289789a6e510c252a5672ac7c060edc6bdf3a20db741d81ae926829d6cffd5b0ea8a74c3a580c6c23da1ec104bdb56191849e9d1a06a5e02e1191ed1dafb1befceee1a5e613285b6586e54dec33da0a9112d06e281a6f61d253e954fb1327c6c77ff8fc502170f4ff21a52ad366050262bd59aa00831ebeb9931a1ecf56e031ca74882e01dd81940a88b978e42b846453c01ba832c9b337d2a3f5c224b011ed1ab4e001bae8c36fdd617aed10f9afd041f147bd30ae1280b32c97f0ec223e2f6a648f4173a2bd6f4f216f4607417631bb3404d40dabe0bcfee7e85fa13c7013333c4a6e92ec63cde2463a6b17034b39b5f2df562a28a385035fc16f761f0b591cfd0a020111604ce21cf6686ee059ff97b1f6a13bc0d0da8bdd675e850e423ac6b7ecfdb437344702e2d6179e79d5a0a836d49177c35d16d213784746507c5973411f4dffd2f5a67e22dd8919246e6aad640d0550fece9f4eae5727794d4c56c69bb100055c8020ffd7de9529bbdfb2a9de387d0f59e1d19ea424940492404c09b372c2179af6cff4f8ed912008fad1f593531f965a9cc31d1ae9f418e352a4e950f0426c00f1ca4f221b5c7b81e8ca89a9e92652042228b1a854941a52c9b8d19875a5450c1186a600d3ede30637b0bdba7bda00386bb20ce41934173d7361cf8dcedf5786c09599ca2527142491caa87be2968b64e16e8eb4cf60accf50ea0ba2916ea24df08e9a48db23d85bcea5a3ca01b44dce80f17d615370f626300224c37f576014252f806cefb273919872c8ddb349ac1b9d45363af0162cff25adb8e2c63a502a47214cdf71c971a591e70892097d801b85ccd3b09138a06010e659af03e1643ff8c674e8d3695eda1ca7932ecf9c0508b148759336f18f06e9e315a22718517e82adc57a5853d0c53b7c784c500bf9cc1b4b208994631e30fed34577ea49bd4954314548648178b5f9b56d5878a6c6455a722c607ed222d7eb1d46d9bf8e10f9aa0f160d367956ea20a6170132dbe009eadabd7f843524728005037cd5fb079395c7e3617723cdd251afb69d49f56abe86356359a214b336d595ce16273dc92f98781b0fb8399dd8ec22fa5e171bbfd4644d2a7bea8ecc6ad626641c700e68c159502cf446f3d4c5dbecece27b8883788ca67cb0b73add756f291306194f704466395fbc2b936ab0d2d79e2dee06608d95e96b52a6ed48cb3f1b17c841c98f52e1ed4de93321261399b15745b4f7f77c9df6ef45b00341702db7ac19770a835323f84e8eed22e62070acafb0ac3c4da2f9a6c2e102b461bbfb07fa10750489937f704cdb65ce8aadeac5ef85017478b37d74acd08f1c83d946d311b4303b00c92bb11c651bf502392ca29a8ef5711b89d25dff090e51c4a7362a99f3a3680376b7de391b8784d8002a447b3e360b913182dce07e90c9705b71a4778deb739492dec021e630837540740fc67953139f589de533e1c7c7788c909538ef253f3b3cf0216ce63fb2bdbb3d794e7ca1446c05f692ac843808a757d9a14442352ace25020b45e49a85a32850f3402ed0f25cb28f723eeb5ed36022f30b0b2365c7b6fea97d67106b39a5af2b0c1c5c5207eb67be49d5681cffbdb1aceb59631309fe9c52ba5106e951ddbe9bd1de6b05d82647f9e57e8c7d318d1ae6a3ca0531b9f77d8c8fc1f4e39c103afd90ffb2433897ed171fd3071052a66c216ea046ac6623ed65e95bd60c348e85840163c498191db6fadd34d04e9eeb89c734a7d13b429102c0ba9c7ed0c5b46ae7d42e5591cc5452f43584a414373ad2c9c5d45c7818ba750a9860d4c863af9fea23a2de22212cf848b1b04784276b57b37b1984f85f448b79f688966e765630d84a7154e798c3fd1409245702a2b97e5676c204fa715af645cae7bdb2ec8e5333e709aec78eec4962b729644dab10c6acc0e9b5939d23b22abbc0e223729c7df4308b7bec791a546d1a7d85013ef7c0fc274012be71a664833148b257075ea57cec1a981b671b32b52307f5a9dea289550ee3a101574f8ccd8b8cf78c4e619f590bdfa2b40dda5d1cd66f4452da99eaf45aad47081c1ba14c968b3b4a3a2cc827b17c2db567b66d5ae2563dc540070d5c94eb1e790dfbc006ca404d4b1e860052bddc8d515e170341f2917689440ff1c4de765ea96334d50a4dab6ef8324a7e7dff1cf00b0ec4d01f4eeb9b048da5c1f9924bb1ea2248cbff5b3898b268b2c456edce81ffb067fd8af4da4c6f12244bb5365ff3f2a55d4bab6af8b88c3e8373ab797caf441ef9b2ef2d4de33af260adcd32eb958ea8dc2317c6817b6c2305560a7efa4b4880802ab98e8749caee2dcdba3a29aa3a9c4c191acf9f1fdfb96fe4e05e0bfabb2380a828e6a9f06c382aca656a31285bc299925104c06f8abaa88d276971ae60de82ba152b4ccb5abba795adf23f2e14765d987c33a93cbdd3c81585a2a7b6393261923eca5e89ca7e136b5ce198478cda2ec23a29358e36648769fee79b40603602bb8544ca2ed044cd5f0264f0a93ef3ee21759e05bf0ed9388fcb9d8d478b269c517bb9c22cae6c17b28b447d22524ed7af8f4fdbfb3a99ff4dea4f7193f4b56393911325fd34adc4fa1c98493549399e2024e225ec524c841776db4ceb82e0f449724fde9845fd09359610a3f29afc606a05091f0105133ee33db37961f3b4121f9d7b1de75314e6f39b7e92f3608bd3ff58c80b207d4b88f04a1161d7680c2df366af16a869dd989a0ee0bc61fe398ce1a920e1bdf808b8085867588a3ff6c32944c464da0c828e855207cc151886c946175945dd725e5a69dc560dcc281f20925959adb3a762f0c192de01b71e749d7cdff7fbb2b47bced382ef568d9fb90bf16c3c5a78ba4504f429053650be00425c731790d04e8788b34fa8e865f255e71427cdf728442b9f6e2b3d178e6f6bfed574e11e3a9ace0d86bd4f66eb8838e11c776395fec4908fa017955074e11e25d0e0af49489616bbe1990bc0b3510966c61051d62d92d34beb9e26ce3e317134f0a72d7ec109413913d25ffbebb784322f2d21c1eef3009a5ac92dd6a1b9d6f2d863d2582722d4cedb5b5a215ceb1566475eeaa35dc12c441ed69ecd56def5df2e5c2c131a4abb6c14727a7878e2ea74e1ce262769de0ff9196d7884e04e6f7e61f9c297f0e3105b96da8d99617702a61342dc69c3fd518a2d9af992f73c1e36a82f6edfda39b34dd405f2e60ada7c0bb36270643f0f513ad5691f0870b142ad98c5fc394217af3f3e6c6498c789ea06095ff9831784e620236955ccd8eac516593c18ffba3b5cf2c70fc2e36a40e733a692e9afb560e0297c585c94a69c84aaab16551c69de9ec1a5130780d8655edb84951e160b78d7b4fedc9b457311cd202ae8dd007cb7508b79e1091c2e56e88cb20ce77439cd7c5d797537c768323f7c38caa3221474c7781823d24968e73def272e45f0697ba2fe4bbcff1452708289a1848b2f59527a4ee99ea4a8edcac788f3ac591dca7fd0828613fdb1d47f3b7b863daf434a3af5aa7b431653f4a2012d73663deb76027035bda9ba7484527f97182e64e8e5f0b88b8d6a767977e5a474d71fe87406a136e4e295b0f8818e4f8abf9f5b1bcb15a215477c9d2bb8757c88bc7e91fcba885ee1e1bcfc33f3daafdf77ea31fdf6cf2e01e90630733d60406257438cd7f3b82feadd99d32ca25a8d406a141cb8a4d90fe53b889c7fe870f3b60bccd80b51e01fe0cbca3256f35ba67c6529c03bb14f3b9f79633847f0aa3ca72d10d9426e409f753ae4db5b9a1aac27aa4b9101a666f91d2e07d70a941e4fce452185cc8be6497dc582701d9243eb46e1171e3f42cbc936e8b8f5d05854536dcfafb2559695324fdef67492d1cf88f9cf8ba8939a0afd5dcbd085e46423792f48f4aaf20947b58295f0854bafe5571edd2177f0d155bbe6fc78c37c55bc5051888efcd73d89ccf1c161f934d5af7b5eca99d46231fbccad5326f0eaeaf5bf35d5cf65dae893888855c33811860553396dae20d4ea80f898b2f014df4a5d053736f39de6900f24dfcc1fa9761ff76d0026c3d85c15ea4050b72927d68105ce76d7c251646fe6f55ce8602fe3ca1c468da27912f8b3541a3af4b67434c90a5423156117f01f4f9fab86561aa3f876ee79ec863c4bf6134c9e33832200e4efb47269e28719213e6682134f169c86aa78f53b20357f80a1d9972e6491b153ffd7c411ea413af64b1f73fe3bfb1ae9aa3a7a3ece0251e3533a35af962d727b36f01373999eb76cc9bd7e1396c59a204ed03f125587958eb9a4b4ee38a69d2bde74a61d335220a1e3483d3dca65c55ddde71e9c42d5832e41145c8ae5a6634c4c243517369b62a88981267e9f2fdd32ec95d4ebe60062c457dce977641a5d412121e24a72fe738ebe5cc2d7fe86121fcf808f402a7ea508c2e077fcd260c3d7071421bf21d3e492e92d98585dc8b488b540e40190292930b6e970c2e23d41c1aedc17a1769036f180fb0d9687056cdd5bd70e98d286ca444c34a08d9af38bcc3fac2a0556407d6c0a4cdbcf2b2864036c1db9d0af2aedec933bedf5b18305425b232fc1bb07df232b638cb7eb1c0eb0865e9246a277a243ff425ca4bb73a9f1c6a6c768816170e11475bfc68190de970a98def187683006ae06486b221d907ceda15a1c532ad54d6d3c2767a06c0b0f7d750a21b48c610c623f8a1163ed052adfa618652d0543dc6052faf7441c8d55d2c2f4ad4d5cdcdcaf39e5f1d10d7c3bdd3064d8d06f4c97d902887564efcd14660774274628d5fa1ebfb4782067815e8cc0ab9a96159366d73d5b61c2b450d394ede795bc13f879a57db5ffbb396e3ac02beef510f1f984335af5fb7da45d72453def1464bda6039928f89d2bd22d439b7e65215a6759e8ea9692d96d2947beb220b751bff12fe04b03288ad4a9b15fe81153b499a51d5725fffa13407d299d2fb952c13fa2e6610b15f897421e70dbb784b28d14f2b1e4ca27ec4c4fe3934dcce733b4cd24799e1e480e6196be5b6a26d43d5527e636b394b0752c37fefb56f0d057b97333cb50d925fd1450320e95c52f1d0a58a6c4f53ba1af0c1d474b4046ae0c6ef4996b14a778d34fdb89cffb00cc0a4e34ae2369a4e896994bce92cba982d78382d170c7d500f9726179da5ef3804c313db2cf4889a1ed5c6b3a8d1f6e67b2723de8df6a239474ce17a709b1ae477bbbadf4db57dbd8988430f046a42cb6cb60f7e27a9f87db403ee2cf22b15d3bac5a5e652dc7b87a5d955128fddc5e34d47909cae9e9a6c8d5df8785d96ed51668a4551d6abb6b6e5f1e5b8179392139a3017c7132e6c63139c4fa1a32eb85cb6e5930410c03418c70fbf398f241cdf56d74d02a02b3b3b65a979b390643318f4ac8d26b31c11ac6a24457a02dec170a08c1cefad0671933d0e20aefa5970d5f2667cd1af37712fd2b9b204bdfeaa23c10aa9ce6f88756ffafadcfdb1fb7df6f4d4567057c4dbaabc94d3961f59ead159d395fbc3b24f1a9ba452d24e1f2e77a76496152f40bc1811799283d86cf2d83a97d9bff5f1461494b05725e77292cbbc412dc069722f8f2e17bb3c37fd00bd85129342aa3c0afe5a16c9b37d54ab924649d565797857855c36c49cdb0965e40ae25492913e2e9c5c7c2fa86bf672c30fb40291e940f9756f70678f1e9631c5f630eac057a3b225f3c543746cfc0fe3013f29792a12289627c5239c8f679c400ed8782747879eab65613e9ea2efc104baf474cd9c202d6c9135a9fd536c95c8a4bf3f7f89cab6410f87bcee29d8090e761d447fad02819b79f8aa5342b862580fad2ba5a5833920d4a92dbf9511923805bb46566e016fc04417850cf5e55cd718d31536ee9caca0d344f0a44e7ab13122bcfb7d6cb7132306ea5fb69f13dfa0bc4f98580317313a1eca48d7ef078d5fe806d6ad400c7f9b342b5f114520d1065f7cfbc9f6fd3ccb0b37fcb56220661234915d32ce906b1f6c37c5902b22da8f193edba2dbae2ec82fae3b28afdb32cd33d1b2f7751e9281f704aafaa010aee2dd0f1f6b91baec1aeb4cb91f06e10cb99ccd142649ffe73f541a21f70f73c461d744945f56a5ae506c638a8715e57b7abc38af63a3a01f5d855bcfea7983ea95608b47ec41ffdc7ee8d2f0c825224d95639f37b950f8323e7d1e21cab9981e72eb719cf9c67a828f1e691dc446e7a8e556ea1880b2b445863b78c0ade24b7a6bb5b62760adad1a847b583bc66d628bb5724c4c790df3537bbe829128e50f5e66693d1e467467c795d02ef5ddc9cef76273ed2507c4c7a57e76e502b131b31135d1359949246f22f0735a5dae14c572a6537268fd505a1d05327cdda4f194893887797d2f66f9a96b1355ddad1b023bb04ca5afd6924d80432cb03836670ed5cbd54ba09d60b023ae4f526a0ef7db056ea95ddd42b0c0a34c830bda2299e74772cf6d82e36b944f25a5a2d6aed404b0b51e9a3f6a01afc532683dfa0c8422089855fcbafe69247591ed463d9d06e51f8b0c8eb308e160d6b4f93e120216c8505307af0de7136e67170e5940deb6b150db2d2138192148f614db31ae2707e627c50471e63cc74e25b08bd365f773e0a3da44c42e8659d561380d6fecbb3b4b46a0c2b03dfe4d50d7a3d7d9b05cd9c8324d8f15cc111d3a9423d51f093a8b8bf2cf2e1907b18b4474b15b4a2502803ab975b5d93be256b23a93ece323aee7bf7e0ed8c2ce808dbcff3b0bfe42be8986e83c85a82bdc91ba6d1a19a580ab9ba4ffd60d1a4c433cfc1938713618f62e2d239f3edac1c575e38d1100f9428b0d331e0da8d56f53b54e9366b167e8ff3e4dfbad0e6dde2d8f1aba4848be5c138b32fdc0a139fe394247832bc4ac0fab18873c7d7e041ba13fc0da1a67845fc0ccfb3780c75744f27119984596b9fd7a3a237bc17caf6d93c4c5a0e9db9546e487c98ad1c24f4edf138b9df3a7c4d141792b8726f911ca673cdaf0b337fbd35759b48836ff656b6ea08bad20682315ac91b38ba216fcdb176b173ae845665e0b56edb7ace0c763e33b94ae9d77212f1f58960fc12267a526baf370ad6ad8a87ff921330aed020d4ad4ee4fc2a4e8986d60cc6c9f423ee1b233552fd274c8e24c7d1c38a4e7a134ed100c697eea3252c09e2de2b89e1c822e74c37cdcdb62bc3e4018dca089e63bbac5de65c572e399d4b8e524c1a981e38ab0125b330eaba201a84c0af3a21e21242355b54becc331e1419172429cee939165dc74893a953a6c414db91336dba87bba8a2036dda5d8dfa59c7c4976809332e2881ad477a94f915a6712981f91c3613c190e3459d2aa00250f62f66c8897b68552599154ae552ca7041d1b39fed9f119990dd61b6369b03193cdd49990fb55b056206e429d0e9917e87b09d2ebe1a50969f4bc378d2657432232a6b8f9c2a3a227600f00bff463a6930af54649ecc4def5575154033291d9d987e7db61f7d1f7fb58ed09812a918bd9518b9d070f17f73b0045a379ee94748dbc785a21cbe010720e4d02108316887f341b815de2a0176fdde8739791d3f748fcd3bf150887d3eda719cc17086bf7df2d1012792e9a79a4d0e1bd9f89c9ba0cdb2b4e6315c2412e9a24e79195ff95f406a4dc2a2d3d698a382d70b8f2a65b04bc8d8cb5588130eb503b9d3bf65890400978aae99b7d73c35668867310064c705ef9d34cafb233de89193f7575cb0a534b3f7c32104ffe302601cc809470cb3c63b0b288535e1d420f322cdbfd44f3c3afeabbbc417cad83aa965b2de69cc651ab3fb57ba4fcb14ea6a9c9c620a983e7f10f32e90b91e40754edd06437271e0ee45b60556776474e178a4456bf63394cb1bff4434ae626f5a30143f2f6f5ddf3ee823aa4c13348e48429b9658b597a5e3d34d604e1c851719bc96a7c7e6c5c13557c889ce474fe4215286092a1128971b975e88a53a48c87ccc1595da47ec196240dbe5748eb4f28ceb5c77e49f590e6cf65fba5e4dffc8ca8400ab5b759e9114297714095ebc7214033cb983ade6f684c4f534245fea51404c0d798d803c1a026b0b2c50de0f5467aedc0f023f312b98d83a168e3c0bcf414face233f2887e79776a92b0821b369185f844e6618c518064f5634b088f0f644293bdd3a463b8e85b856c15a41ecdd3c2631df421ddf5b6277509e3112725f8b5af957d2761d9001dd830f6f8d3ef1ff0c7762fbef03cdfd140b199ecd82f4513fb9b95fca5e08844eeac7cac231cf170f959e8a0acb5f38cc00f1fc2816ae727dcbbad970077c32e146ae9c3bd4fc203460a250549f8401f91467f396ea549be65857e6e06df093aa56b2e41e3c8dca5393560c9b8c34ed12d403f544675a5c476a052ee66cd1ec0a961cb1fe78d21c398dddaf86e44843987a2f1059be67f1c566cc89b8e31d5d5d91ea86c9eccbd459a61cbeea04cc171dd6b7262df29a5ffc490a5fbd02146aefb908f4f8ee926de087024043493110975e5fbe469ad6cc0a99a7872ceaf333d4e1806a56ce74b690652d74afd4176a8112fffcf002d103579b3a01d0f5e5b14bbfe22bcc5fd6f27d0ec3d44b0bbbaf5388c3e6d6370732a36ca1d1966e30b43eabb2c2606308f94211873595fb47305dfb8549ae34f4f334274eeb4849d2a7a26ce6ae1226feef055f39cbe7d1022becb8606f708cb5f3db03b1399678139ad3b1105cb0bea936c989dc1dee294b6e56945366c01c530ff6bca51e63f5a41193c02ddacb986adc21f3318843d89eb936e13cf2a72ae921b28ea1d1b87886bfd937b5fb699510a18c933","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
