<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"add2dd61aed7e4cddb4fb074a3c9ce94b11b279d6b27c275d2b7df285f7e9dcb1048113f739c892470bf9ef3f456a3b058589aa103a6a0ec9b621dbf67226bdbd3cf25bf2641c40a82bbb0b74ed2cdc665d2c6d1097184b995027858484f1c9cf2a279072c6f1315073bdf95e9e37b5c127e8d431cf365b5ea35506ab7417ec81ffc839cea270220c218da8a0493d48016a23241e2a6a480f3cf1e99d685d55e64f0dfafcd52ccda8abeb219c24104efd24fddb3f7ea034bc804be6a252858dfa52075abb7914df02c9ce84fe05f4d3203eebf8d0a2d523f15e7c98c6249ac8a800927b0397dddc1cae36d815a41ad010250496bb046e76509a1bd0fc03e0ec631aaa68c7af0e60b0720f7de6c752a51b9e9fa4b0cdac05b989899322defd64fc57576d46a5e3ebd63ccfe501e4422e5d44b2ea5b689dc3734e89ce395a57e28752f2ea0f9e1d93befeaefa1fb17c770bc5040aa3d313415869e93e0999749501105cc1c12e266328c38bbc1e65f25d5666a7e201490370ad8f7c2a9b38f6bb8249dfc4df8e4e56a8c663697120025631cd76ab3a2fb709d465cfa981b57f242d6bc6eefaff3a095d1d8b4ea014f1c41a9f7190a143c293b1a867fe342dbe6806541893ce5ade1d383c2e2e8a63c089760c13ce30b6439b7ff137504b33516c04a6785a88249b302a7f3693e20282b2858c5e7dcd222acbcf2274fb35cf3ee9c268274a8cac43e4c0f9f12351b7b2ba5c9198ebb779222bb832c6a4ea61d785f39a432b821c84efdf77610bdd28de435d37eda6a53442fdd4f114354bd67ad0e39fdef0c49f0bee7979c183d89dcbec4c679e91d1ea8689cb66094efc2f798a8fee2fd0b319d972a56b9c1a06c16895f6902971993b97cbc91f351a30251a5990f6065854a308a9b1bd599f9949a44ed51f92cc64970f9af338cf1e0fd6b5cb3c489260726c84adbb2509af4b33d44ca1d55073b7ebee4c875e6f6d6957c62a5ef84eef675eb4577579665c1f46691347735e86de26df2101e1b77ea280f8ec0a4d7a2ae2a194dd1079eef028972ba5f9dfd0cb665f6f4d182064d4a7631f483b2c087988ff16ec3d82c4cd4b1d75edb0e033d5cc6cdeb10a9852e145d3370bc256508330fda2546f17bfeea2a53f8c882a628cf0a4283a9de2a1de7325f23abab03b0456b5befb273afbb6317f3ef1827f3e2cef9c920f74eef395a8f0dec6380dc5ae0fe62ee1f47f487926ab53aa6c9a0bff76ba8313ff2acd07af634b38421f0a1d219b5f6d6980030a42f6ee2c76fc79037bacc5d15f5a03757d388c1040ac793e44999e00bf50aa2f711fdbad713fe3d777b298a12a7c0d74c21ec0d91745725db1cff718cfba540742ad9af5cc5a648867d6e4dcfefd4d1166693276e6816f7c9cab4503402bc8ec690a74043e3b577d4e734593b712133c8f34176193831fd05e8680c5cdb3c4c97b1ef15da4cd2eca61267aef45ab84164c1477118bd96daf12f41bc60f1ff570572d54de595e3daf9b0353aad3dc94001b80c05f3055402116d4ce73c2172d09d4fb9c43ffa925037ee99804e8f11f42df1edb2f4698d10297660b8dc5cd60f3bf2ce3a3eb689d91f9ac3b8f68c9006d3ac547e1204fcea363f7adeaf54ca9e4a478d44b6cd287dd0812d6c3952ce20ede02094ce20587ea2a9316bdd00f999939e9ae1ef777e149615fda49302112e6c5fab15aeebd8fb710dce125f18b276c9d62d6357bf37b2dc7b1470bb2d36bfa9187dde859b440667f0aca54222b4ba077f33bcff8a63ed5d235ec0d420dcfdc4a7d6d0499363bbcbf637589d0443241ccc26aa7b0032abf900bad10095c0976e3c66eb757beb63a0deda8badb32bb14d3ae312d71edfa63cd7ebcb17aad25bec03bdd9ffb593c28c332baffc078750d652304998072ddd4c4c4c8f59c209f02f6b40300f54d6f4ff65e6f0cb0e058d72e9dfce5384ffe5385ce25a42c4dd61acadfd49ea8f84fc70d68f90b507cfc89ef8400896bac662bd03fec02d2d94e47c2fee6d07c8e7ff779fd8405e3de41fcd1ae715ccdeea0c36b4a72c91119a2cfce7f71ae676f86987046a7578d91ee3f11790e757cd87f63bbac0112b8628b61a039e7d5b9f92cc349aa90fbe0cc9fcf1db8fc29c8fe8f80c8631b5ecd4100baf2db1b4f0b4fcda727a37578d4aaadff072724d4ac497ffeea1ea0f4571f0c2ccb6fd1acc24504a5951d4212cdad45c1f1ec0c5923c6be65749f01dfeb8b6800bcc3544d1dd7d34cae0e6419af4673b3562c8a88120bf85362fa0fd37b051cc406ed1140bed2040e737e7e50966351375fd0de74708da1daa39481266380ad2198c012a75aae19bd0a729b531108deb206df7e246ba40984e3d96eda8131ad8c0476ca5726878b941440027633af03ea177f30e2a88cb4017c5211b60e47bd5f9fcd3e678216c3081e790aad09425d8d145a53e4baf5869bccd9854a9b5f99716f5fb289daf7d69b91fed769d47624b22c8d4090542e901ca9a890cfdf882d013d4245044919a1371050310306e376fde581222eb6fe0924dc0a0f0b800b628a311e8c50ed5b08a4f42f52fcd03e081337639809293a8ddab3e181defcf2273654e62b7411dfcf8bd27942cd71a1542c5b909b4fa55523aa038f3973c943d2c0d58f75e10683d34942906330a6c80b8ab7525c145c0705aad133aeed91ccd688ebd82c30a1f3ea0a7bc672587fc608a0a0b6c88296080cef05a267653c8c8e084e0780cec893c51fd2e257deb5747fcb034bac0964a6cdffbf747526f7859a2aff7022f14a0f34cea940891b66aec844e53dab68ceb504d510e7fb27495b66fe0bed6a3594e69828dd3c7320895a0bad9c79a63f4d1b79a86d75c1e320c897a96cf4eb289595a6c4b23f24e5ef2e26dbfd307cb11537f1492da9eb824e8b659210c9f5700af1b33c51121ea000f7a00cfa02a85c35b50a9bdc1848ddd8bd737a07a49f226d02b03c5d39be8bde98f281e8e97a9db9907bdf7c81d6262367ded0178d4774c8951de7112843c602079410b85eab616fd5f99142e6877c9b1c31beef119136c1209fea3de3f71297efdbeca7346b6786cd7de64f2d5fb0c5a80862c10d937904cf4b70e5e4acc992b7f7494ef42ffa595cc692df3696d842551e6382596daffe1db2bf7b109f30893796073c01424b253a447a6c771c3c62fb0d79f1f05e86ecb96e1c6ed80b91e02d666b3a13107108ae5984201db9b832fcddfe9366b590ab3e9c6e58e1c7317bf3ea3b75d97bdbc098a976de702f379102e3cdc5550ad25ce74a6d1f5513f1612915183adb069256ec46fe7ca1c3879a960c83cee9679ba75d644c9872aa8f8af4dd17d9cba8d1aef09b16c415c7fc310398930253f38f45292987503cb327cc380c926062f3022c5ebf84722eb8fea269753d8f97a345a977045e98b2b3c533868a41e947a266ec37db55824638b4c439a3b15ee6462f6938eea6c92bf2be2a2e4353487e94e4e80c8c3abf1c4a7f3d3e72b0eeb29eac9456eebc3a9f909e72cbad804b793c2e5555bb8376732aac41d0bde9df954df0c5121999b69a98dd8f58942c27139a8c6f38050d2c577788651fd94ffe01eac80cf82634b58d8ac31bdb91248a8d9dd906d4c431903cc3cdaa05d89201a709ceca654b53db0295b7371027c4eea53d1b41a7f49dcab6527f6e4690fae7fda8d6ba374ccb5da0cf64cdad15eea7fbee11efdbd16dfc8dfb805c19b1cf78de6173d209dedb1a22adc5418d8240ad454b395bd34e464886ffa94ac8cc6a4101f302f1c9083b72bad1601a8cc0f05e7be3d8d83bb8fe789af97dc76e5417b4f71f85f5eff0dcad1683d2806e44d6a2a3d8055fe85c42c8eda786066d896567ee71409090bb33ad3e352b0fe012d83767bd22476cd7552c34eac77637cd47082f54f5ad55529148e74950037a4225556b99d89820066e1befe87228f5eff87c0d20936d1c5ff928ea74a341f30a4cf8c915612b4840663abd428a074bf94107181ddd22ecea8f741917fac3c2d89407da9f64789bb6315d417f289197f18f909565a35597fdf2d575d0451501ca51457cbd94005508f1caff08862933b37cc1408438f7ad1d4e0a44d6b5ed19e5f6993892a00aa6e9b746a3652c5e2f9fe72bdd19b60bed253991bfa629ecba1d4480b7332751c2ceeeb44ee198b249188e29ecb4a6fc40b4bfcb69639fd1930634797bd0a453012ffc45fd173f01ca735a0fdf0506c02265f160b1f3b62ad8a98c247741746b1e27649211fe844089d0bad6f021c9d7e9016b655920910087c793fdadf9d765efe24de2d09e3366cf58b59a6ee67544cfc76948264d17ed12ae74236b920e51602f3b9bee5753f63449412fffd3303149c683bd14db52e1de170ceaf2f696a0fd8c808e3fb998625729a188c9f3068ef7f60ffd78ae575105a7063690d45b75090832a32b64dc4679767e5ad56478c66bb7b3b773cb8d62636d8e80b5c4e610e56472d8ba168022bc2a9d04d5acddb0548a8a090954fe4b04c9ea90cce9675b23b4db2fe7f7805eb64880772631b752c1e1e6fd4534108f8bea7c1cc8b974e6628f6ccbea597e643ebd7bce97eca5a07fec9c4b387f0d3cd3aaebed05fd0deb707b16286b6c8e253bef1ad0e6848a2c15ec2f4cc65e8dd10fc07740f7ff6fd69e42afd41e236d22f46bb11551cf5952d0eec4aae4d7d7516505e186fb3830a94e3e94e4e1a97aad79ca211c712365ca26206b2e23884fcf18c7d3d6dfd4371c6a8a6931658547ce6a0071fa7689813c46ccc8ea6dfd2d0b7b79613a065d080aa7d59eecbee5f0e045034f8f9570b8a5751f79157c325657704636d95213933ba44a0154c6d0ac4586289663a706f64b22b3582097c287ab7c52cd86ff43beb9574a769a253e08c33721328cf389fd6db200718b3e9b770cc559a4c0fe6226a2eeb7b0359e4f2427c7e991d870aaaa57f6977c2935ba28dcfb0d20a57e6027fd3e7e127c716941ae2fbced71311c96020d435d34694d4a2907deb6984cf00673db13910e8620d0ca0540197bf43626ce817337d50023ada522aa0ee77d34fbbaf773b2cb3658669107fb9c4e439ba380dccb03108e24e547e765c2a2bec2ea4b20f7dc3f5151eeb093568818c1813840f3a61547fec0998e41f89e1ec4beb9cac1d1a6befeddef5ffbd668a85058106db503a6924e6207a690835d45c9b3f1b5bf00f424a346473644d0cd2073eac291320e349ceb5ba681c91f2dc992d8d918ae13200ec382083a10c16ae49c9b0aa09e4b02684aba97e58f9fff4de1c647207149177d8940673b3f6a92b9d7b22f5ed1b1708dd7e33cb0a7863abc21e1279b78b2c1d7e3ba593cf2dc9832d39ff7b97c9fd14e471bde569be9a27f003a6087e40536202b34e45e630b4845318d145437d728fd89d1e714dbd3be5ee8acf450077deb962766089c619ed284daa8b21585b5e895b367639420c8875924564b1e360f58ce55880e1bbdcdea7a746c4212251096ea1f8fdcd6e7b16e1822a220559f77b580f7e9c2979d9e7250d9297f49defc1a1dfff9f6fe242ed5a2a15871902ccd174e4af5ef5e859945c96f9ef7541010559e026bdc3925be3d9009bb73307e92dec0136e38e4d1f4ee14a86ef5577d539813f25de0908ce4584e8cb2cf45b60e8cb9edb35c5f2a0dbe03f5aa7e9ba1df265382731856a073faabd99434f22293870a19e47629dc76a36301e2be614758b7574a435d8ff0cf7f8c6995077b2bb0277341719f8889fe07f1c5edd46101b4b233e45c675592c7c69e72db238fed62700bab0bdb4c833b07a6ce11d5e35f114669e2144c23c5503009ce2eae34a2dcd8d6cc88e42afafae5069c0516dc5236e03e02e26284171387103d1f23138b74098c65b6656f11622acd8ea3c41f5bb7a0bd4c7a6db64faa47690747264359d47eead5a91c87fc0cafc00afec2a4d6174c49612a3b20bab0977cb3b90387a666f417ced8a516fcf6a035cd12487c3ad1004c343fe52fcc294f0951d0ecae034280a27abb4c45cdb620cd3e6ab147ab5a6a1d735912e19277a98d9321733065e69039c59e4d431c1c7d36778f3c1eb438d2f991c17c52766d186073d69ed0b3eefb3e43e9c9cca5341cfb9af4b3cbb1f21339781cb6d07c2c4a458bde8e04e2b4ff4e5f964a0db9475bbe791f7a0598123234c0e044ea3fb8934ab414b8e0f4bc0fecf625add291e9423997a162dbed32691f4151c9d49c3136f7a94364cd5caa0ffb2ed0e954cb25aed62dbdadc5087f94835dbf44adffbdd4e8efd3b3bf90156944a0ea626d5657cf3c4df6cd625aae0fb9f8ff657243bc1acfad7d4a900ece93e45142b7838f872a2e4367b98b5e1a8ba8c1f38b637874a52c7d9aa8b9ce2a09e6e400d7716f2dcd342b70d3ad82e4775c9b375719c67565e13804294cf56fe4c20e24e8296bf16a27b44d083d61863527837906f2dfb9b3b67c75d5b6a678796d381a355b6a06b715e1dd44fefa966dbdbed3fd4110052d13714b2b6c61cd31132724381055d59e43975b3800b905d40eca0cead35289d0df1fd36272e8ea34a453bdaf287d8d86e26b1d68706b9ab2dfc255339f9b213fe6d6013011cb13407c80e368490cddf0ba99a5e04398f0043298196dee297d4d4f9f66bdafa22af302b0f73df8321edc210427d92b4d0ca199e22a6c44b9384830c62973df398974b0e6f3091d3db3abc552679eb56f0c819a2891c36d803674badf81d28acdc926cbccff8cf85e31763fe6372eb10f91a21f2d4ea29e53100e70e60993f688e49260b90d1d30f152ea2b49691bb8b45017a1061a39e2f56252e1bbb687b5c6c8188f8919a2fc3d79bf5e00ca00727eecd5facf8e2d228a7998d15b3f34db24ed050f52535370845456ae45ab58d9acaf2f6cb9d4dc75a0f41aeb5c6a14063fcd57473b2d542aace7e7bbf89ced692673bdfc9f14adfce61b50a469d59f90caa0eb6bf7e5aecd6264b1cd72a04435fc308b5fb06d467d8b8808b63f5a6bb39bf49b990fa38155d6cda5754f6abd1a65657a274092e793237b394709ce1c2c2f853ffc63ea816d91aa7726376aff6af26dcb0b133448dd8a04d7c9dd1a1373c431bfee7c651bf40ad239aab3ee10001daf7d6456a006f4a58f1236cc8bd2f992af5010b66a9544666c7bf4779541255f5eb1ad1e4e7e8bfce8321adedaf575052c7457aae92af2e6fed9dcf3d1f1644098c43f1448124aeba3125c7ae98062a205522c32d8ab3152094c7b14b9c133887b181ec54be0bbbe96e20c7e9c8e34741159754bb3e6ebd0db76f319804feda582a988db2d05a614f447184a70922e316f111204011c05e0fde8676e1f590e3e6c623e989a5965d76366b0ad82bd4846858c05367817313cba2a8ff74234448806f5438fede84b957a34d9a97562bc92b503b6eeba8422f0acb8489385a56e29fa3b54c5388ebae55944fbb90d53ab182b86787aebb936ad128b6a4b56879eb97c34c9f25421ecc1813fc949ba9efd52c99d83236875b515492dbf0b9556efcf6399f987a01193228b8715cf2ee65ee29d696bef6beab7cb5f6ed2799e85bc9ff00b3f7ff59f2df8e514a67d68697eea6cdf5b8e7ba5fa293c7af14fa5d2e2fdb3491ab13641386035cadb3f09c8d951c938d872d7175981ceb03db369e86ee0db9b2b475618201c0234c252767ef6edafde4c6a74a3a7d71cbdff6c635eec8f306f423566c61d7bc4929006f423673ad4e4dafa354d360291c6d6b8b4e9d1477608528292cd77ef6449620a188b3e115981003088bb60ae9863567404ee248dd3134bed144385c92aa97ef7a361e2fa6f28460d781310a555499f9909cc1ca985be119437615a0b3e1bb0bba670e0b1ca0c360cf17d806397030e9c66c19a6da5c6b6de91128931a55951d74a656347c3b9b69c35b747f1884e65ae26e01c41486532865362731d1f3fb332ac9e4871d0f427028b986bc2b1254dcd539f7455d58543498af43f0a9eaf60d04701d0ba7659bcce1b6ac02bb4abcc817da8f50ef70328fe32995a9d517e6c38d1646f09b181d231c44fc18b73569d5d430bf6d30905593180d094967565ebb1f08e16eb21fcb28aea5c1a02f01fa166528ce3bacf0e3f5f2efd36f088f94a99eeeb8293e2c7703d07ed24def2bf0f32c6d051b64a8141437b176f4850e03bb7180b0652d22dbba92764034f45639cd545db348894f2fe3f67e3092aac0066cb5d877e2a22c5e07e97e9f3b6a766ec976ee764893c4340b9da5bf3444271570280b882e2e54b92f2b3cc3500b3050853ad6e139e947eaf494784279211d820458c3a7a5ecb0f4befbf7689bde11f6128de80ce2d8934917bd2f48df0a900648d599f1cf861e8b9ba13acba7eff74c9d3f98c5fcb9b3156f716001e03e3d4fb912d5d74f12bcf45c1cd135b392bedafee38c3a1272a9cc2188e769c00f519a5bab5f069acaa10e251e120d8e25aa41eb530114bba72667bec558828070ee48c87e800b1b10ae77afad64b96a48f586cc928bf527878157cccef98aac1264f19a815e62e4c3eb948965d6360fa5fc9999ea785c7570d535f643f44c827d1f75fef0bb17251e797a00178ea9097f5588defe0d70c15f47280ece9c64f3d4e47a118600ab48abcc9c522017f99ec5470ba9714820c7c13b994f86ed819d0a4feb5e6480703776e9189966f6f7e7e2a4eb63929aa9ca9f7c0fefbd4156495f54633f0b74aa492301e791d9d70854b4d2abc0a303fda6857e2e3a8f29c87e9fc4c91c23c7b993c73b8459e8edaddef91c7d0420e3ceef0b4ef3f4eb85ee205b466b4c38cbde57e70513f51319806d0188ebfdb21205be4ab42184c4c5665ed2d6f7fcd337c25601bd72fd5b7cfaae003e21ee4fdf0c740fe9506224b45fae15c5ff5245a8c4a97461afba674afc2701592fc229181aa1c9de3b44f87f290c6b49c8f62b727de4bbbdce37071d5a8d2441c1b138cc47ad62f05f2b5c0202dfcd739ef540137082336eaa79a3f527daee90b0de71a69a93b167bfb96d04a6795c13da8c8719cbb7efd6a73713d25fbb69db73eb042bab7c9d06f8172d847804ee459f40f2977c72bfaaa034fce415ef28fc3b9bc7df10fa1d2c4f3cc200edfec0cd0741d9ec6d72f121d19f8e1b234c0ae3b0407b59913bd43f5cefa75796f6a677455166bc700be77a6c8f1f06ec9e7f4b68ac09acb77666bff29107b1265e8cb3a455545e2a75c96fdcb862564014ec0d16d71f2fb9da9ae91e2f45b97f2d88b763e426c8fe5fa0565db74d14dae3074ef5f371087f504eb9fc1afcf6668a98ac07583d89e90df938b5d321c61f1c35156ee4fc727498d74f0a63612847ad2c290c2bb13d9e50b3284794353ed46eff5274511f992601dd70f74f26f0bddd043e0c2014a7f7e8e32ce6735c0843c45ae61b1077bdee49ff255802498b0439b8cc61bfe8ddb8dc63c8381092259376fc2f85d36bc1f26641638e5a2412deda4c818a9df891426a417f8680e3d1e79163a56bc313e392b77e4e79bbbfdc76bb11dbd632953036c85cad4ad2d5ac3dacaaf60fbc07233bbefbfe487743cf86c6b6d4e28f2ebccd8972bb602fbdbceb2d223aa1e039697e502483fffb814de8b7f30c754d14379a1ebcac036928db465d3c4b1cb5be773c4d425e9b5cad191004be94765c4921fbe35717c3190541b1d4e35358276bfdb24832ccc01e5bae489bee701049a9faa1f8a70a9c728799b1c21e8b7e267eb40199b7f902b24bda637c1473a02098d54dc1407da4bf55cadd43ae71de1b4875df99446f282e3d8aac4aec8b5a3223ef35cab3e80f3390befe2c8de5a6c9c0c38448e1df20bd405225e8c674788a0633819a953d7e42f19627403c6707e3b37483b15f3abb59515f3b6e0b98fabfd5c1ec5f7908c826a4124d20638be6c5696d35bba9245a1832a240bcef495374cb7e78027e3381bd2c13f20420648172371a5ccacaa804736caaa25468ac2e1e4d0d00c2eb66ae1fa0df08ec74b4b419480858fa3b852e20e309706a5938e9b30cba004742dfa84129e598defff61f8c10c02088f2e2b564ca501151ad196b399e6efa47d63d59fb1e05189f2f4af0952d0843febb2eb0247e6a41d646c98c65eed2541d7174edb701de836a290e433221ce24516692875ec4c682fa192a5d1acd9aeeb0f4f85963251122c087941da26ac1d9b5e6e6a8546f3eded60a7cee544292ba9a0a675f796debd0372c3d4eed1a6a77c967cfc1c97565cb189f4a348a95c62a453ce50cf8db0b626f4ac2a15a8597cc4b5ab942bfe736bfd342c9c9c5703ed51c808c22ec5600e8b54d87cb82de2cff2fa9f8892296036edaa395b26310bcdb904d08e99bf0302a51a91338303bc5af37da9280bd3c664c082e1f3404335457a62898d9658cc59a7a2258e3cdc81d6a9cf9215c8b3cdde9e67944a623025a72473b4a5b4c619453ac3389f9a3d4673291c44009b301fbf3e5bd2f8a89aca555ece9d5755a98b415db54b27569572e283ecca6b15d48fcd05649f1bed682b53a3b08d132195ee49c22c26b2eb3f0117081c648f5579985e4f6c38d6dc00e7ed304b3ac43f802f822fa674009559f47ee4ca724f12bd582c953926f46c24edc6a8b3e6908b64dab33af19ac2e358048e6929a89a024b948f1c2d79c50ef0ce3f4b299cc5dbb2ae9145d0ce8da864dee5f05694012a29a359c020ee48f200ddc1ffb0e0553dfe504001457f18c4dad4e27e0821f36e76c08362d76a7382dd2458f5e803702494a674a519445c9c776c1b3bc3b5f09b9ab7107f85cf1e0d3220968ae9b27eeb2d7b3022a08829c6772e1f119914e014ec027ae876ff5799114a5a9c0f9828f18a4513560e131e6560ec4deafe6e04f780c502c2f0ba4c331f927b988903951dfa3abf0b89a38d829c562d02539ae17b5a721091ea0b354edb2fe65dde0ba45c08c9969d6d5ac4b46a70825b8b57c1e3367f5355f49d95e08c76870deac27196f95940f36edea84131f70609db3a731f2ca9c917f92038808b891eb3bc3f87be6d10e2a69ac2ff10846a76fc3bcce5de62a737b8e0b3b62f65fd708","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
