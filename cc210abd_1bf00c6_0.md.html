<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73e3ad32f6dd545d2e1b2e63a60996cd1e4494bef19bb899758de29751ee127b9c0a31d1985201d8490636559fe3b057d9ca5149bdfcb67bb487d9713948df8b2e771ed82ba19348b908853f0d1af5979ff3c30d12d5254b024dfdfdc88a3a503544c0e19cf59b219020b2ebd32b9bd5157b5228016291eaa71dd1f50b5a816b59f4ddc7e735a40bfb89f566c050ba8ff40fcff1239130bb7c3dc797bd38ecaa1d41829538eead9b897d6ebaf8f3412091ec913d719397adf7e3b31cbba60e015551f86c2bd194aa5fcf0834bbc650076c6e7d212ef53a15b164560fdf82be9a4f3348b38dd3e8b0dea67dfeab8d41cabd225ccbef57cb78e5b76f72c18357b8d39d4c28e86bc35ac907f031fcb07af5d736b678f7bb0c76254d245c953b722c8c8ff70100b020b6fe4b9a24c4219df518be811987134420dcbc365e291a81e38d4bd85a9ce9b06b3cbb1e7181fb27b0b77712478a42c1aeb1258d886fda6a03e34cc4df229c6bc3c800b5977e2c80fb9b97e2103469a89bae559decaf41478dc916d8658d9efa9716ba6c02fcf5206f692cfb23ef2a9c5b13f5cb37e519f3cc82d3b1e8865027cf41433eb6108f40ca81377fc5d4159cf77d0f3bdf931ecf47d088b67ff952463626c8cf38cb768ec6e2af7f58189ee9f3458731506892e0631bcae6120aa7ad90d902eb98e46c660fdf4605c8009411e8be50f4944cdbd53e8e97248e6f2369c77f4d056cb1975c65a201b9353286200b1617c96c241f4dd9e1919c014665fc5311d90c064fd48a84d454ff84e550766e0f203ecb84e769153157a1639586bda0d699f7c7b59700b376c92bd8b7e4740db9889bbb582c30009c3e329f3a440b2c264378a6f2019677947708aebb92b830aed6bfd325673d78a700dd93a2e24473ec4f46c9d31e5a628fb61a132857a35718f380158caa583cc0c80c0e8323a848df2ad054833b551878f0ef3c5dde5e708951e123d22f79d68fa61ac1daf2f2383a5a66514be788f5595a480d8c6f8067b218e60ca205859370d90a3c5bff5b80e05b4f3ba6955c7da02e04acfb83e270db83372fcd54fc030361e12d9e4b8bdaf9592cc13b042df380a015a3a9291bf46337b07e4a5afe4ebcb3757d1e4e94556dc2fc38b62ec1a2faa2d0b69d0aabc69d67b445f32031298198f2cf0ff2a17698e266551c76091bb6a5e5e2e49830921d319674577ee559320f7563b4504c52858d0c2e26963aa9467c18cb23f8df609a7d7da36414fce91fbef2d5058fe97127956263faca43e1c6ba043200fe28ddcd533b5b835f66c8a7c2045c40fb436519e4e4f73e787f195c1a0906b08c000a2e056504bbd49cf116f0a1ed249f19a976bb0c6fd597ba47ef44384074743e51f592b523f241122132a8db142a3ba40ff024c7b52b57ef74ba3f53a2feb318e533c53eb7f6c2b19f473a0386204ed19c1c17b73c9743eb2283c4a8acee08f51d4407ec7786b0cdd8531b52443cfb4174656553b1703cfa22df28876a1a641fccd680ce9535a5c2df7a8a7026e8ecaff76495b4080811820ca8829f25d25e9ba14bc002fa73301b41399fbbacb83d7a2d61dfd6601b174f939bdad31b4a7548fd741fb7f0106a26b161dfbe3490a4dc9506a1176be2d6a94a1b7fd6f27afeacc9cf3d60311b277e8f483a70039835a1fa2d6370287cef9a9bf68bf14b1fe44302f39cef092f8b3caf3f23191f0dd2f2d4e779e47b492306198a4676a16c3a337cf5403f13cf1102dac99ce66f7ee08979864f1e1595c56498e734296782a4e1dea705cb436087527b3ec57e0e9055df16a99f4879682001a7490ab22ddacc848ca0e8a5e2fa720e95982110153dc6877b29294616519af1c57b59842c5a785e08b558ec65fd2eca5b237620fa5766b9e4f161225ce6ea26f9541125e05e3c6af5b725644daf8163f661b94140bec3103a4e4828d205cc97abd8718e0c101336ec5ff756593d95dfde5d7661d9f51cfd2ed76ef3d1e4640bb462b1c39ed2a2ea13be75b49164c444b83397ca04daa4a2ac63f93b5b52ce4726b80845dc7cf456cf343f0270dca91fc1fb243ab733d6d74357c091e70bf4f6437f569218616bf34a46b9c5e5fb4eeb93a6edfb58c431605d93ac7f44508986f771b5222b570ea96ac8073480ce54f1ce0b4da53ce0a4c5335464caf17a18091eb16d8f3d762ae06217f8cfa1efcf5389aa72a229f077a4cbf0be5b16794470a6d1c98c7931aa96dd0eafa8484ea8148e20a062b73e6aacacb42a85710127183c8551638a9c219f20119434446ef1b97887b795304f73fb976f699f8468b3ba4c51bbb627e8e7bba16a2725de4894ede62f5652e46dc7dc9c011990d072903fb4d611aaf8d3995d26d2d151be52f42118422068053f3fbdd75778909fe9b6080f608ebba4f996fcedf5124a422f6fcfd71968569ef461d10b62ccf58bc19f012b080df710ef04c66f5f610d69797b684c225d8073ec5e9a3d2b6077eab3910aeb277853f4079cdb2de4793d5f1f9cc351e081ebd0e624218a09ea4d4bfe5d0f93cfa9b532212408be0002340e76641f445fcf40d404500b22a596f5b6a0711a64feac7779273e9722813a220a4796a1d1b08f8287063c938229970d23e1647a18cad900adb9baceff38c80e516826355cfad6259a405c164cb27551e8d2bd55bb97baea5e52573c88a844477b482d04c17dc93dfa34e59dd155eaa692687a6cf53bb3fa3126ff1842eb5c683d3ff6ad74b659382accc6ab2f1ab539925c931bb6ee548f6854b31d0a63a029e178d156ee973585b612c480f52a854249722c1ae8ae5224fccec3ecc3e6b35bd64f8bafc88b52054bef11ef8d45a09c5ad379bb6c89338567e35d9459dbf56523aff5efaf7c2870b7a602c764ee26b508b84145d969893a9be116c5c1fa934da69061d5a4d341e00863bfa4329197e6d0bcc367d677f5aa81ccbb2eedc7ba699e7adb2354a459f75a421743e5bb13affc24c562e38f60b5486e6ede5c2a186b453ad138ec6fbebb320896fbfdaae86c11da67f74c98b2ca1ed531399e8bbca825f0d9da83d0c2534b736caf09b26e82eeeeccf26aa3fc70d268731f0817f00ae500becf0e24009f38320ab10ce5ee0c151a0d0bbeff55bddf58756943a13653db8f10bd22d193b3312e290a4c36652a89db144c614b722ca538fdac483c2cd5d3baac8043677b271c3c8930fc5a3ebe074ff34594d5f00a03dd5df276f94ba1ae77d53e22e55d49ed632b17b7f1c0e9e2715293f867c7ab67edf7c345a355535a13047c62c963b0e00753a4fa919c13a74526d116107c02adc489424bf3943736fceb3fc40e960219ff037c6327d35809f3c89c33dcdf19cbcdbc3f0948a8aae8d9514ca3e13502c99b78858810dd82c0d9d3ea26ae7d83c53eb0ff2e77e4773167b10ec12ca5211ea9d57cf5f8f8963632423c41a0df9a9d73b0f713559254ef060df43368ed0693ddb8308259e3e6e648b7a1a46052e3ad1c807cf20885f080a8850134b762d29e56c270edd9b9cf1e52fb8b7d2596cf47a3c688efc1494708a69c27232241d42dfad6d8526e3dae63a2a0b7fd20ce86d7ef634f50579e8f331884bb2135487732537ce5b3a853fd025e643d7cbeedbdb6400c6952de1b4bc5a2d3247ff47af1deb10ffe3d2699560de620c4c5b92ac66cc69d95446db5c4ac0fd323cd709dd616f4409db226788ba86b1d81e46cea242480222cb202b71ebb15f6f355857e4d8fe6126b08081fb0ce9921726da2b15fcf6a139d97d46fd9a292f25b47750ad802fe0276c7aec8c886f5255fe033082ae573b8e294f3c6d1a81fcf511a700d558733f5d38808398d45a4cffbff47c4115433640449187a0d895e0f05b1cd09f1c098d71730c8dd4241985a650f634bbf7234acbbef1584a9ce401499f9afe2cf72dd6f6ba7fb36fb1c7873c9c660ad4fb467d99f17da087bfc39718b515c23c26b4c4123e6c2efa591c4b15f984573c5665e8f99948e7d61811fdc256206d72c74a04127816e3ca99edb039e3f510881ecaba8484c15db32dcdcad28def28a5eccbffe97c783149ccbef819ec1ef0f1bd48e386d5202d57f9fb5df2227370adda068b9b9d6c610fee17a265f717544d5a4998aaf8185e094d828bde43f8989262a7bae868b0f161493ece0c6027fdddbb99d7dcb53f64908641362734e5700a2dd3de4d0d93fdbea262301b671b3b332ae872314f2742f2dc5da575f09fb9fb167b877d91cfed099bc17b7245da4181ff0271a7488ad125813c747bd791689335eed4d57a20f2e06a6ccbec9907aee34efc255fd6faf5195ac1e8243b709f45d96ea04d82f95c870285625d5d389ab494ed944453bdaa695a6fb29d093f6fb745020d2ba17b763c4fbd830fd20f9dc17f6753a797697f4d43ab75ec6478fef10c28b70a4a7f0446a39afcc59adb0369e33144730cde904d39a5791860880718481ab84e2ea993e49aa6999f69249f89aa5d100307090e167a4232c0f8dcd362b240e3cb8d2319b452bf9ba83095d22ab79df7b30a2c5fc1576684a815cb095b48c852b2961bdd71555ae9cecbd7c070aac5407955294f0b7f597ffb0bdd7a502cee0dc8e81ddad2d89d1c086f0d29a21f9eedbe5f861d30975ef4a8fc78ba2733140c2273147da10e4d89feb227d1c9654690a5fa3f0b5e68f6d926609f2d05906466255969830b335a40a48a125f43472e5adbf1b87727c12ea4c8cc9e7e84c9933c7bd659ba7cdfa1bb6ed94a48490f5fa7916db67b8616ad6d2d0648db7fb2058f4e278479d408cea5b3b86627f2dc17074286d2773e361bbd83afa190aab07ce543713dc0002c0ed7a7cf556b225eee9c74487098b673ab3253314f7ed8336fffc6e076cefbf7791752114bef571c6140c933f7b4f98ae38aa263d1eec1f682ad03ee20bf34e28d1ce41805e1594de086d3cd7523455fa4edbcf962b1d16ea9f2c950f67e5a6fb7ea8f0a30fa83e91a107f8b6a95ee97f896668626176deae9d08b00cdb31c8657ea47e657d1b2e79dff16b9ce23dafc40274ee03006595eecb27fcf0d65dbbab538ea2590c300fbee02256cd0d7e94211e6f816b7a9068a1af574a66ec7f006ca50de64d4848bf1a282804f8409d4884f5fbfa110e21c5df0b8e380ac800db19c32bd49ff9fb1d874af3466b2f34ade76417885db83b2c35b9db0ffe1abd074896795da45294881ed526567905e2ecf1ed4729ad4acbd8afcb7133c6863dffcc8ba63891b4cf6a7342d760ade51847ad79d5c3d4b24b4eb2ab427bd528395ae45b2be58d3f9a769c636773653af1865f024b90128748c8bb0cd0fde8829937a0fbfb0b94316400dddb8d95db6528c2cd8053b18721c45253b1f628f1aefa6687106902cf7e5dcae2dfaf38e146f92bb04bed9807c0c34fc9b45706e720328f67d32bf8c228e8af8db8baa55215261ce739f19e2254f1f4d81121d7f57f1ea831d76c66add61c3772423a9e6ba5b732632fbe2ea206474afa469090e3bcbe8ef63abfdfc1c141c40ae6d755f9560b12a0be1307891f0a7444005e576b81646d72f8bdb1b6c712427c97764cc440170792a2eb1a8a119155de38d00a7198c632d58940a9c967b91d3220872857b9eb867b8dae3dec19fc99c21bb579649940c02e635fcf83f674023721a271b4b53a1c84c347f7775dba0258f601c7d82c33471d51e1f0e42b3a9446c62d546f45eb33e4168acc1920e15c8def418d896752cfe7ca12c1317085775ea58d1787e805319cf9940101cca91c02870504c9cc256563f716e671693ca3b535d54e2bff9e4edb329038fc7543475b2a47551f9b939d7f446068c4163845766003ec229c39abf5d4c716894bd7583a4011f0977990ba9da7bf4c49d8033159cbf825da3baf4e3de7f5eb1616985ca75953384bd89b8c9fb1025a45956a1f1ddf2aef056fe488f5f0232b1c30f9134fa96d1c9ceba9a2bc2f8241e056c027a3a2b8ec26594a3ee6e9f4224b676a5d08898cc94f15c7126cf6438c4bba81d75169a27d6087136c19964b351012eb0c74bda8a8d026e7729a900cd50a22aae961b8277cebfa8ceaddfd2567186508f52e0114941b837f63898e845a3b7f9e6644ac8f9a6e3e988538bf2b712a2978a6d2fd2b0862f41c95d02b9b2c8644517c9081879f444ebb9c81af2d554daa3fa8bc1ad1c63225c295ac5d1badd106057de5d814da87ccdeb521146a80c2a4481c8f23731f54b4fcae13e2488a683f214584f66e42a2a68ce5061e8b3923c8c8ce251298ba9f3c5375c4e10f1f80ee879301fa376df4ebce0525018fb955ed0cd75b9de25fcddc00a6b5d035cb0ce4374a4c5d437995547bc48d8f163c5a54151d2a1a7b38dc6bc50ca389a08c8c408ea8b5722ed2b26d6bc0a068c085f50b6139d1f113f42147c15f24e36130b2667a8ae10fe5eda721b926254978190326eede3abe67d3836d40b3a58590a2d24b401b840e720e7e58bad997328e6527fd6c34372f97785fe0ca106339429980e86d30504a02c8a1c21b04ce8f20fb0141a162f45a70e8b6352f942bc60b8254f4cee27d8c995513f9d3016c3318663f15781ebf715aa4ff3231e235a02a786c4bfac2ff5db0fdc96c392958f0cf3e66e7cf7656b06439fddf46c6e4f21e2479ec4727649ae8303c3a74b948b8d51c5973edef2f175f57ba31478f44d92a3d9ba8b38f31e6135f24ec0a0e082a04cae8b7a60d19f84f8694f970370a6760e1965c88fe7c1f6d3dedbea09ed4946f93f8cc23e4c369189550945d3f3421b07b53a934856b80b917bfc571f4d810119529cbbc1b13dd7dd9834cf26091b23dfc74c3b09c951a57922471a2af47723877d5833fdba60a6b915aa0b45713af5eb3d02844986521c0275fec04f90c6252785390185fc3c22d568e97beb3c4f06566e5c231c9cfcb3afff3e5b4425984dd90544717fcd10c0bcee83819b7f04d495430c0230d5138deea4a563af689d4ea840b64bd81d83b95be3e7b3c73b550901a5983aba57e7588382e13df375a5bdc396ece78d4d28c673cba2a78720788410777095ab2196785770346c42d26a5b287ef03c53652b47872b4ec10b491a0e94495ab5ff61f4ac72bbbf1cbe86039ffe96b3d30e1c2d26eb03c96b2593a58162812dd4ec4146d97df30a5ffb548abce50fda82f2ee90a39253aa88e8f5de5ab61f9bd17c6b28426c5833021e7d461ca395b9f164339281b053b9fce27c71f5f6a4f2c1ac99e94cc1086556da234551317bf48a1b150af5e8e26a5c5eb4c0990c152309a5999cf5f5f7949308e8011389fef36abb64e6f1dd255ab9bf54ac4c4d56305938562c0860e4c751d38329637bb6d75cea0b5bf7f790bf821fedce6af735f6dc681ad43365b1b12c1f734e6aacc7191716933a9c5565f555239bac234b4c871b6673b0f7604a61f8f9a243b5c141ba0001c8f096ffa2d854c725af4f13334c4f843dad1085922aa88d5597c115b7c2e7b210e2e673e1b79e1dd80af648aa2a88566a7a1741c8e73050e57e5fe18745ebb8005b14b3001e2da0187a1579a9610cf1fe28f24de3e510ac9e04f0865a29547ca6f069a71768893af9aa12cb326c30934f760e705cfefa1551ee6baf294283222d237a8ac5bbf358b13db61d123775ab78a93db93a4c998870eb82cfa56b9d9474fe7bfaeb3805bb4ccd657cc1d7c2746cabeb22d1616e33ae59169dd54a68a794842eeb41d2424dae4fb401379c57ab478956e480636bc11112aee00f3b76525408b448de4f64277be4972bd70482452dda1c9b0d875dd167ce107e0ddf7afa5241bfa08b91dc29280b4c487b3672c858cf17bc220a728d856860c378f220ae0bb2351f4c369112f1a8463f1babe3525514bd497558937d47b12f04d2b9c3cff76d64132d1d8e01e54389a55253637f9cd78e8c822639b7a0bcd409f74eb5fc29339939d4ac0d03013d2c9726b16278fe2ac188aeaa2217174c994c187d76095791f2d95efafa584907384203d1c556202c35162130b0c8828abb05494cadff3948e5c98e2827464b61eda032b77eff3264b09473cdeea5af94f83bd6d3c93a1208537c24b6198acde8c42fab3641a3b808c82a4a7064966bfe143403e2dcb4133f8eae9e6aed617a71af0a417ec8cca9edd3564c3f03346e720e3d30d60cc4ce07c5dcaf53174d027793117e2ed8bf5ce3bc98a02693b94c323133f7ddc8b947718340c479f29b3be83c91c2d7cf17b7de46a42a9d83b3996563cd6484faa158156bd7f585932dc5709979c76a152d954cad735c5e80013af4f79cb02aad094ddf429c5f08c3fdf45957df2dd3a2720da43384ffb6585a24ef4fbdc8c664548b044ebb791c96fcb0334c19e591d124a5ec883579c8cfbfad7a772e46ece1231db7fa8c57e601a8e263a323450412d853dcb514a7e5ba3a12fe41416e5e9ce1abecd907e925bf1280392577e35381438a25207d493d94489847e571a095bf698d92a032ade8154c3dcfc456f5f799241311344ff0685f8e1caa3aa541876da7daf8c257fd202079205b007b55b993e8214cd766ae667ab0ea03e5d96d079e36a41301e888ea528f4b08520cdf0c435c21d79959a97b4670b7a40379d1346bb6d3398a9cde4dc12be25b6a42accadc26bb6a6431f09a0dc41238caf37076c28b404dba433267787c65a379a706806d36100dba04beb31a781d82b272b0bf4487aba6ae4894c5aee7f00985a384b638b84d4e801c718b1322b2043f9ba17522bbf36dfcf5a5856678d313c4b34600bcd2c75c77170d9b6b362b5500a118c16cae53b83d47be744d66a8e2e41f7bbf154f0480a39a2eaac1ca2ccbd02d926ba7ff5c35d2613fe9f2f2bfa496e09eb9ea3e323a78bb1b2928568ccb4d050fee1105b3e9383a98b2ca7f5148be640f29ee5fdd99a8c47547308024bf04cf9f789a9665fd46b964ad203cc6aaf2331a71021a48e82505aab1cafd53fe9cd7b3fa039cf1a14e4c00fe49fe511a39eb7cd2752b5d6d6c6e830e6c249f485b0f27ca91549ad9098588fdc5642fb7870c30c1a38af625e14dfeca0a79f6dab023b989c46c2cc082010a86e31b8e300ca94772e184dcbacdb627d8f0a6f64a4026e18c7dd005a8c65a6189f0aca2d7de98e3de1c3f6dffc1bf775160e523e3c84f1bed98dfdf91718bd8fae3bdb6e8c3919379966eb6d08dc61bfc6913cf8dc91b6b8c8157b13dbcddbd4472e1a04041b94d002621d28a5052d0a950f5231c270ac9f9915dd7180edbc8bf89a3117def124b3afe0499674e6888d3650d93e2a7241f755a1918aae759e1b23ac05835d5394356bd6541e9471f80690f221254eda18876720370fee14c129091c059f8b2ec11e04db105f90666e9c9c738844f601f0273b9e43262588e63808c68407bae357cbc39f51776ce250be558453ce47bda6cc6813025ac346832f1fdc097514214628f7e5cebcaa58209bf95fc69edc524dade1f201c04ecf2354f71ce37598a80080438b29c7e751c0ca561ca7e4ac02a2ce8e64c276272d7b00a3691c4396b70b7e7424e34353ac603d27bcc531b21c128c3e954fe319e8d718a20505c4702888d2d16729eb8dc4eff31284e03ef35bb0b04cdbab1b2b85bece6e46409aa56d20188f520736fdfbd3b8873c44618f6af33bae071069fb5eea2156aa1de1d51759d9e2a1d9ed85c1a5a0d8fe71e9ede24306ce8e83adc03797d4decce0055704e5796a8361b9ac75390b5912cc49cc7dc8d4d17f2d8e9f58225dcea652e8be46aa2e3a2a83a76aa63e64c2439128ab38771558414709a2dc912321ab64fc6cc442c644c424e4291c208a5047208fc02e27ae9fc1c1743c12f88e857539d705999c2f5f3e71c8fc6162263d9f607efcbfb2b7d190a63b09e932bf38883def12730adbeaa304796cb19f911e38d894e40581fef235d471004c18bd5adbab09cc0e64cfffe6aeec09bc7a32f9a73cf8384688e6335f4522c411513960d44109867bc422510c2e312f635611835ace91850145ffdfa495b46c53fd3c38d8d01c1602da016e49d3c27677fef305ce50121051447344d79981090fd4967b8a8b80d3b8874250478e9a2dc12511556f1960a7ecfcc3ae27bb0736a03ca218f3bc549ef71f92366f98e864f1207de69cd68fa1f207dae983a3ac60f4265ca424bb7a4cfbd997253e9005ef4125bd0ddcf5948090aeb5eb467912d9b71e9c70a17c46beb12477ca61545163b56248a313a370b7b19c324d5338555b68827e1e7620029dae78baac9cd2a97891ac0cf9401b86d8719e958c7b396e03cafc94290a3eadee38ff51c4d42e263919dfce6e392d31e243f706a390137bae7d8c277a300b4b49426d21c3640906e39ccab1b15015ca0ac49ef201f220426683abc8413ef8ceb4b221835014e4b21d45c68b9dc6437755c14ff00bec62e7608dc4809bcb50324aaaa4c08e286393babb95efc5c37d74e8f32d06049ca237dec570ad46f609ab92161e766499bda7335e90fdf9d91c16c1fec9b173afbd47c962710be61e1ab30d1f223fa361a72b12bd4f4127b0b01ab7ec007dd79d33938357cd0074568a84022ed1b627ceebecfc4eae3868ef9cb9ae626b51cf6dc9c2b04ff12f8b474ddfc410ad64af2fc10f5cfcaf58f4ca5ef50f4ad40a7baa94a4f8e386083bd08b9491efa4b1574e50d705cdc8e953f4094853568115eefdc2c4c52e83fffe2eac1c1b8449b03b622ab2b6a82d65dda2af910cca81ae5a0a3e58fee05239aa011ddb071023e18f919d9862e72338fb9245228f69424a3555aa151df354f743f7c4d1fce436fd20311729c4f207914557f2525f0ca273bd94019d54b678e3b6918cee203d5ec264ccc77bdd0bafe38208d44b172bf3c9b4bc27327dc94ffcb3769846eea950ff96b61ea1be0213c76942a753a8bf42cb930d54e5653873b9b4a54688c27ece344d652eb13aff622ed3b992cc73f5e6c5570d3c716201b442ac0c4b8aac6d17cebd51db9eb03c75c0eed8d971f3ca37c4d369a01e0f68452a71230236917d278d3b117dc336c42f2e7522fd934e7e5d4af564b77b04ba74978c36f65747798241","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
