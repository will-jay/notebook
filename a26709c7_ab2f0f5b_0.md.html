<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a0d0db7a1e0685d2961ab570b5dec33606f8737f2b44f41627d42f29fbbef2a7db1f49ff599339d73ff00a721bfed8340664ec9a1138d64b2f8dea13b4d99e445cd70a2e38bccc5220960327de51548d5cd4deea0855be071a01077902cba31b3bebd7bd4562640beb2654b752ec159774c0a96e067e6b43e5e69e056f0d8e282a8b4fa9cf1ecd89714ed0b5e646e8d0b653bbda25d0f8378fbc8126f62c4f86436da8fa6b9b1f9ec9fb8f76ab60ed260973f720b86c9d1bfd1dad41225f8e52613e0e04abef2a7d7a8c60f9e00755da7b9c925f4b9484798a10f6b08cdba412e9a16303be9b46d88da1b87c3061025f24c43802975f63a22235152f4385d0c1071727754bfb64cd81097d33cf2abaa21d4f0eceaca8be11bf3ac33e03102e3b91325860e87a476be2ad355b703d2b36fdc4c431f8c011049e66f298c182421ed8ea23d7070c6062c2e0625c397c520a724640518e20a74884fd5042d4d4084bfa8db21cfdf868dc7befc80041129676897f103de6631c7be586da1b50f5467d1d04154d42dc47fd66183017e905c23876bc0b27cc53c8f9c832b4362272a80b60c9a2bbf634366f99cf7d63f8059bed6e20646fa8bd68bc66b9eae121a877bc0db44ba0cae18dd7870545fc6e1fa3100e3fdc4192ece74e9f7638451993be7d882b96c60b4d2691371814ddaf3438e59950137ccf448431bb2fb1d2476bfa483d32606b1c91c5d698702519628e2db331ba5964fd6771c5ffeab1ddcbbab32db31ba652041ee8cca3d561d1c34733d4cf1e3e2b7066b18bba3d2135a92e294b39f8c6050e8be1d3d68cca80465dde5766fb841407398e89e5a13ba21ca76d30d4535cd3121afdc181acd8538044f3583cee8ae90b364f72a904363382db18128e88566edb540aa2108268dd9f230b374a96e309005f3403aa204efe3db6842ec5e1740a630df327999c041efe86fba2d744fbf3e28c64c3f7bfab7db0a761a0f7c7db5c3ca3025cad2f5bcaf1e9c5be16f01427c769b6c5f28c374066279e6b0a73c842da63c831b9258dfda34153b44132bc69573d056030c0111c77bc4be3c4d1b55b10101883baa9e02b574833fbfb76c1f94c22ad637ed22f84f969c2d474def48e4fb173c2a20c920212db6eb2cb7f8e44c352bb5b93b46a94179b75b45312643c3ad8eddcb8193353b1175200942625b06fca08e0d4c6ecb988884cf93bbe0d002ed38f2b7624af3151b03da9cbf613cf65a8a4df2d1884873472073460485b6d949f08d66dc92c695e6edd15645eea6ca7a6d56ab102109174666f8ab21d9a760d4db073ed906f329d51d20b1d879c64d41b6b024ed8b8ff72917d22c5b9684aa9a0cbfe36c0ad7b0dfad882779853d78bffb0091043d2d60fac84f9efebbedf981aba3ff749ae93f725b5a8e55d22ed1b5acf62597ef3ccda1f9492d3e4cc589d8c87e86a2056bc4e8fe3b2f8d3b53e899790e7d077ff90c6aca45f72f8b98ef73fcdcfe75bd48c3d5d40216f2b68560ef9382c960da3f1ff5421972223f48d75c136f2be5a033757e7fa40014d9c8912fec13fb8d46dd5cce486b94a3aeea36f8c24288520db6b14a0b57d028001578fe9e610be704a8b22af52bc63e44e968f5ea4f3143150d995a7d5fe298b2b6279219220bd642f6089c9cf77368bfc824ee4ee2eb96d12d57dac1a6e5ad95dbc3ddbe383c3737f8f7463b86c34d12bb7e52c2c09d6c88277c7437bd37f9c18529b1af4a5c09d426b85253e271274c13441233bd1aa17b720b1285502d9fb79e997a9d08efdae3eb48778fd62bda588b947f0ba641f34acf401338ff030e510f1a2b3d293aa630b228878bcb6205a039ccf2c40ab1d33b34f7021ab2261652225f8e7e5d7556fa586cbf6dd94cba40ae137f811ce27e80f9979b6682e2ee871eabb27e17fbda0cfe93923b7f2d53e0205d0e5a855dc6d6d05bd92b72440a839959d863e6573a1e11eb0ad00e3b3d168d7bc3abe2cf07814d592834bd9618e4c5e0f9e3c28a17c94b43b5e36ff3b9fac9463b63397fdf97c7ee0ed60e6e94b9928d89ddfd8b6840ee28b2b53b7e8e7d4faa508c181f519416d5f08a7f8b417af73974f528c1f77f24ee107c82050f4700d1b66bc03ea4dffc642885d2c533a95efac91a7cd3ffd50d57e644c14e2edd667c0157ea42e2a697d26eeb197eb47bec97726bb772ae6ab4b477f658f61987394d7c8923bb7b76b3765b1e2e239a7511e35443da51ca7c79932d064e879525e48b2a3138aa7fa5e462ea9e37886de69d0b2fbd13163e7411af7c8d807eaea23e8b03c2f5f334f59c2d271fadc13da4f02a7b4b49b241a265cd366246f82a0efc571b633eff871f47a55f06cd99af60d3d24f8b12ba20349e31ccc9449b54b5ce3e2a0aa49102e47ea75ab5a55613adb126f9ccf7d82dbb33d9b3c5714fcee4a9c3f7344990399fe91bc7937542fefb2d8d3567eba5cfd7cdb43244eca5a3477be0f7ef10f8202e66c62aa05ee5bb243b90b272eddf2ce25676a8b23ec75fc0f17592f690b7ce7d4a011ad2e88fdcb5f82dc6daf9c7e867ee667430725595009c8e6d13ced86f963b7a45698f853bb9cbd15910849aa132a370c5e0bd230c8ba09842d7e1565fccfb29f0654980d4c7d615823ab9b0bd10f11c83df3e87b0c358912bd17b16d42e9b41344029303f74a0e6962571f728c8b92737456619fb7ac3e01ab4283c67838cf49eeaddf3bebcf70e613c76721a2a23303269e4167dab11a3eca0ce73fdf36d5c653d2180a3b91fa57769ded46928a24f53896894def40e2c9e38fb45c576654ad692b5479141f9cedb74bfaaa418a1c16dd7e984f62c2b81c55ae34035f01d1aa47ba3138ad4b89560e53d445fe53fd98216111c2785c574b31e71f10a118c62fa67b94e8aa3a3ec814a36f3d21ce800df12e28aedce11dd2358fe3102a5ec967e550426ae2e711a20be4584a433bb9cb5b2db0d18141640306cab9e5f4a6a01b4618f08fc9a3635cb8f5a3dc1dba9fb5f869861f3381a216b42bbf982cb6f0bcf46038aacead4006a50b92026ebd646b92e908fd58fe2d307f67eb6875de8016a3fc28ee02fe6df9f60e183ee123c11b960fc1b550e438f48088b115635eaf59e971f2691a22c47f7d0f6c15c689bb24dbc275d665929b168d1ee5eaf246c60ffae2902b9e528663a23a11736c9aa1cffafa3e3153d641cde804c9f684da0a28785df19c6020f5bf99ecdb4a0ebd8c14d9a40d8b3c5933ca75801f09875400e7ffb2b797fe7a3211b0dab3f9a8381d25cb293d07e5b2e9b37b1e8e0c576af8d06e96e2346d221b1e218a3d64e279c255b1025a9b8c237d4fa1fadbf2208d9babef5d2ad333ac898b58eac6f9928f967eb32d41acb702409457ffb9e5312926c903b7120ee277fb8b056ce349aa12d674df65d5a981e1391cf7b3969e5df8ee7c41bc939d3099a5ad0f5010284a2cb4ac690b053c48dc5aed84b332e108f2542a16c8030dab6bb92f9f0ce735de51b5013242b594dd2bcd00ea83d920a5d98cbd8b6d608cf31ac80c78031e8843094091bb15c1ce393a3d84b19679869c2c80425a206dc28704cebc2ac8a4527494e3178e557a765c5e417b7f594bfa19d9bd48516e26dbc9c6d686566925191032a083100c0ca678a5f3f8f404e5ecb0bc877539af725b746b185e328db3dae01f2a652142f5d02e3d7a97c7f40d5bca3e9a28a6a1c7c1f21eb05e58c5985dd1aacf3181b7c54f1ac87268d61fae7e9806f88d44ec0d38658a2873757618dc66baca3bbb909257d4ac6ebb56ca17c78da5fe7255c05ea9cacd7468d1b6853781bd71b1c006af75b8a99c8d39bd3ce77c13dff2c1c6930c7d6455a753ab03792002660be1f99292272342eed6b3a0c406a949af3ea38980f29ad9166c7ae844e2821262bd79eb81f0aff5d45698a1794b50faac16dc4b3e4f83d3f28842c85cbbd1772870d456cf939ff61a123343714f514fc3e1432f7efa1eacdae31e98fdcecbb51f12ee127e1279d4281f670bd4ef8be227b83977469392fb824af701a077f56f877f08634304620613fca806ca89e3dfb3648dfb5b2d6d170b6c4477bd56d48ed59751f896a23d6dc5d9c502ce8ed50fc3d8d27a5d51191303f4bc0e91020fa990875e62f77773157e4b5b3128377a1c7fa19463f40116f3b24009a0de3c3c612661ecc8c6094011a64330bc441065540a146c15016cf1ee0eb0a677c3c2b47b1c2d86f496ebe5d84add4a3141c859191f08dcc76a2a8d0584467a79b3c5ed03e3cb343e08e5be2ee6ae2e93ec222e063d27395dbf7a2a9f5b89e7e87a5d6b33291c6a6eaffa8d677e32b261e7edf4f72b840ab36c4ccca64134fe3ba2fb059890b0d2b38054af30f6effb469f95d2a5ba1d7683849b05c90a6d054d200fca6d430928f3ef8adafc16c6dbd0e0dad972224c48e8e2634a6ce2b4db534f5f7e3d5ed1da1a68449572a6786643fbe9677a0094672715a460f6d3d9e927cb9a09c0a66d79c0b43409cc358b237eb584142e44dbf2a935e0c76e42f630a57c61c8516761ad6446fd3358fcd0a7bedf6d4ed018886f32e554eb018ff28d433567fd769da39a24dbb1940a4e1922970b5e6191ba947004eb796ff05e1e44979be10400860f480d3c0fb0877b24191606503a55646d2642742faa16fa24682421a54ff79829a067baa1d03dc0a8b9dd1bc8173151e450fff0a7a3de3893ff6a7ce396ad7e60e53389d0dd9ecc0151d6586ee02155c6926e32100abe5ee99f5778a2e78aca0b855fe2f14a5a8c99b9ffb32a138ab30849fb4cbdbbf71fadd8a0cdbe9ebc844e53c52d6a775963bcff809233be7385dfe1c2aa087d6c83d585997ee3a9c0bbad3aa5595a1194816a42e3d53d797d256d99559dea8d31c2089d41a9a4bf9832f23492caa2e4b164e650db6191bc79fe68dc109d10de0ee50e376458824b29c37ebd65efe164d014b26ca322c792e13eef64fad2697f82e9aa5a19b0a3025dc2928c47a73cea5358978934cbd9cdc030afed24534dc445ccfdf5e23060ba4e2b0b08e1763eadbe46f6ea7188010073e7efa2ab149d473102fc42c4755a21255f41e7e2b916dae469f86af273d1b90a7e3aed6715e093513b1049c7a21bbcd85f7a5fc0181fdcf3a436567975e3df6d4c29cf698ba5a7833a76242e03732b5c19953296446814be4e20e4ccf3e74e5967625b5cf6ceb2b01fa5c343429d6556263059d3509b1c57667e7b9f0f280efeb708f7ab947af8b59459163939ef9ab438fdc6aca7552e1c51854bba900092ef9512bcc998d1972604e0d2bbdb1c039a8032390660a97486b63fe342f18fddaa8ec29fd75a97db9e4f29d7225cc150c37cc00e3be26651d213b526967ee24e791d42dedc81ab514213c4db4ee0844b5619b0fe9bac7a7e7a9b632af3803cabfb496cb563d38ee668114c96ab6219ef23a5b8a6f0373ee39c32118ada0631f5472418badde56ecb88eeb30b2009154d03e2c0cf6a45475c95d753cf97c68678d8c02fd871879d527a9b9a7d3eca57258efe7c18d2e2e2c876651150b601e00d0fbda33b3e8a262327c26338cddf5ae360efd873b1f6f91b9db34649b7be3762689b0e639580b053d0f3ea43b0738a256040c38a40124916899a0f61b4216091df454f3474ed018e902005cc31c81026cc703fd04d6588d954db56d6b2dcc4050f7d2852aa61874c60bd45904f44547c98ae103d1395964c44cbfbc422bcd1b19087330222d322818b4085bbad38532eee50b63fca00361982aa407f1215148d9083f22db68c427095f0329b9e4b7fb45c84c987c861132d210fff87f7b675d59f2d466053ad223cc5091d9a0effc5caa13c950f401636fca1dc36799ae3b34479e848a26a226cab6f26aafb5e3e0024e6d097549f4e0c178c0474c7d5a7629b2fbfff4ec83498d72a704a403b305d5ef63eacc33e63bd2c7e719f34f362292a1c993f149ce6a0d981087c25049667403a7c40372ef46684dc4cd002c7ae292e884f5ac80d248fd4425af49c3e2d70adbd620e2cdf169d814d5be00f5904a2bf7f3999c556b49f7512484c359fe1424e6d1b58d083a7216349e99eabc8eda40dc19473d38ae280abc491ad8deaec3fb66716207d68c0f6bcdf3af907992d07899511e44caeba5b5ec62df6cf19449608075f839ff13e6499fbb87f45ac2fdbad5fe2c8ffad7be2db1a70480fb2ef8202a30d803e7f9612a60181cc9273235f11f2fa8da1e24ad45cc558811335dd918eb4cdaaafbf69e2808582da39ddc31a747a83438189e4d8a5f05045d933957dde9ca41281e5bef78c5ef9b1b5f14832590eef5b5e708fb747aaa08fa466e611d9e523b23efc8ff7b80b07a328e17f18b2b39b7c800cc6dc20693f7cf33b9e8c6ad0d512058317db062a7a8f2066547919b4bef72e5dae1557be21d1ea4a90afe4b069464c993e93d75144d9af2ae27cc54929abada56af6e19fe027b385e71e2bd25dce43f77699ed61f774676c4f394c407ea0fface9b507c398afd4a95635e7cf583676bff92c44c62ed6496bdd1daa337fa967ea6342f0ca571ed82b6d53d17e3ab4f512bfe18582a06bdea45b8d019c843d2a4d66c3f31a6efc1eac73bf0f15311e186f942f5157fcfd53e8af78866cc7c3503e3c634b56d867e6b71c2c5f41e469566bd09284a2d9d64867781421e4ef1bcaa518bcc84f4f329b9908ed9af0243088496e47776af00df0d1ddd19e81c3ffb1a89ab95a02feff858d751524dae0969fce4a1b90327af9efd05bfbd84954a1a2fc250171e7011d6b38c4f8967a7b60ecda9f01c881b8149a17c28a12de51a8c903fffef2f42710567e7581ecbba0abc4523ada1eaf8567b365294100ff64aef454f60fe5012123c3ee67395d1fab6cca87e3f8367d3ab6f69adfff6aeffa01ad3a179f67eeab7a319021e23372bbb6b0ddae486684a2a3dae13769c9e2676d18c161437672f2c129b3f4685e70718069db6c732af00feb999e41f43bdaf076c71169edcb15ab1ae6bc4803d91ae65baf9dfc15806659e0065f4feaa616ed8198472b76bf8c4b09aea2181723263e0914f3d04d6c1a2fe3caee1a3439e98eee62babcdf2cccc8abafaecc062240c96887dab2675b22bd27b739419ba30267869a1d3ca6a7a1d9cd00597d09fe908faebc9af0cca1590ab9e5fe1deae82557e13ef8ef9fe8f385ee1a90e7dee80ab5a4c59a4c00f913b1b29ffc8d5a205a9b142e7a5a6ce4ada5776584dfc060f972e338c10896a478051749a046a287a945228bcac52fc197e1f7025388476a87a900ea05b00f88d0aefd77b2cda357b9b8fac07553d5f34b677e3f5fabb57b18d0ee94405bf0b640feee0c4562ba46b72db9ee32b8ba6d97b0efd38962850d070f0858f3cc72e92f86c82c4e97b33e479da7995b278de910fb1513f02fdbe14cc4909ddc2a52e6c26ae13c1fe45e938d97f6cc6a4e950e7ff2c03a0587a122f0728721ec8626ac620c6bf8f5e68266c603c2b29107bcdd3aa372a1d5913c70811fdfdc2767e23e7adf9ca42a358021eb55fb07eff88b65e10a1635aba1d3de0e90352fe8290bc894df17f3e899e6a1e46e54cf795e7450b5b2b174c769f93163ac529b0fdaf6625987030c0cabebd57dec36d7230901f4094e8785a8505eac62394873e1070f8378f9e9a0457f01a747a274121253a884d7fd546128a81faba22b7041732cba063792b58c0b33b7c6cf44259e4cbbfe07b19b7901cade2d1ca2951b9bf3374dd9a7312baa7ec711d4cadad540505d2a729ac5d1bd439e2042d2f948772dc7955c007fc030dd59c867612c0d1e152eeb5a6faa9ebab65dd762c8ea2d529a635415704512224a44331add35acefcfa3063444d4204778a78c493804ec4bda17d05ff7c028ae6776685245185ea2aaf57fa2135205d7641f1891ea54a48b26fa1faad7999dba5df8728a06993ea6e61332cde8263c786af29d9b2aa527f8ff215af263f9a0101c4473066a7eee13bc83400858781b077570d94cbd2722e7663005d604403c29496aa698411f6744c9874f03972b9e8a9fe8a5fbb16d536c02eb15659fc8754a8b9500a548a1d6b868998437edf60ca7bd9ed746e56b64163a6af3f43bd36344782d196bb4e560c7b3bdcaf3a365defd2b9bddd44f721988a5c8151b7114426770ff9dfaa9581a54c85db0e65f47807928c059a81c5d7f6b8d24253815782bdbc14c6a137712ead6075bd3b02fdd7b3db979f5d8fc08b05a8cd27472590af21796aeb7b5358cc5551b53e6f5a3dc6410e9f932594b31d2f21cbf76ce393ff356fd1eb1fc64e89a4d5b939f073476729a1814adb396316e4decec7de01f999bddf185bba66a50cf103bf9a54989fc6cb4391b4c32e9e1bd497f21def5cd47c7bd280458a74a01bb0f7e8b44cab446c2b25bb19d9db4c9866c9010fa4db52f627af0d5c27d74ad2b6a128db854a292fbbbce2ec23d0dd6091cf2f5989056ffcfda210643d5fafc41d8738293d2f7b4cae4a7a5c4ae59d10c23d28dfcf98f04d77ded51ae809fddecc44d85d13ce4c6553caa2b50cd9ab695f8b000fbe218aabd04e1fe90102542409d6bff078bf3d9f3756e585fc87f989e03290f1183bca9494b9ab7014fb71b80cbf89970c4bfeaeef61ecba8cf5cc299d810e2b2fcbcf6b929906974c7f7a0b30abc5b11a147448422215f2fd24373b6b5fadab7f0bfaa54986f3e0aa192d2776c9cf74efcf17642278e4eb83c87b9e56926b77e8e9674421ad026b7e6d064264ac4d59872c5df6e3fca9add185fb09330dc67f2c5cb66dff37acc55d400db3b2ccbcd5a296ecea4a9405f6ad0bbef2185c829c8b42de11a5a08c8115ade8c4524327e4252f668882081b62d70dbe603608e4d390dd42e6d486b8befaa8cfcdbb05e5ba79b6317dda9b5f3f9579dca7af06c45df3394ec9d13eb27dc0364f4a3849cfa65476fdcd6646941bfa144faeb4b5cd5193faef62ecfa95eb701da31a303b089c3bcc1b3ffa55463c30d8872b483a658ddd8c23c0d6ec10eb6b597dff964efe2d816527bb29d25492395fadec92137ebb53fb3399acb381dcda39edfed54865a143e7867bea2dbf31df882159a46ddffac7545cd0892018fe91ad23345e2c94e62ecc874fda41fa0c84b797a095321acc1922e6ef841e4747766ee06ae1e0376972f0f50a7f232ce3191cb995f896a73826b702a53a4242321c28e91a4d9a64ea6dd8f6eff37bee103f6bf7f4073e0bec84ce1f8c674b37d5bff69342bfe18d0ad34fcec40b3cdaeca9ef5d0ea3a34b102023af5751cbbecce80750f01affff3b9a584e8346fbf0ed63db3c52caa917be5e370dae43a9e2e2fbdccb0efd0b312e26c8c9eb1a7442c6f5b5d95c8d239fb079ea304e9b9100cef3c3ed066fffae278800a513f9185334b275d8d7fd31dd56eaf92f96694752860148597ef3e4fd338f81ff8f306f46846f0ebfc4c7940bf460f79775ea812a537dcdd40a346ac19f30ebb9cbd8b0a2122cdfdad552cbddd80715409e3a1ebc268f9be454b1a8451e3131b313e04cfb60f6c3ea9c201e6685e77e8b675ed4618a489d2552314348173f69a83e8aeba0355692c6a941fe3f5904b4f1d775c1db6f5a7f5046e6f570ac95345cf0085131308eb650673dbc997e6deae78e986917f6bb396a2a8353fa39acc7be8ac87ae9dc9fc3f83c7582ec5b85c82def32522d3bbc8f14d4943462a2155454792db922e0ffa1e6e0a06a760106eea37cd6c73e7bb437fce313fd92823928c8698b89e35e279fb8008885d5c71ff59e942dbfa91219d728a4ffd9408c8456ea62dfeefcafcd550364733e0fa772bd85cb5c3fd5c6cca397e0919a4643fc0c0b77bc15a3b198f1eefda94519f91dd71b3a9228d37ff0cfbdaa90c5afb49f7f2c38f4050f881d2e2826d5eb80ee0775a3558ddfcbe5502fc3600f0d6c510b99400865d1c2e80dba0285bb7b345b3ba648ba92091ca5d1c29849bb3fd484f9e5e367beec73dde878372d349bb24932c917abdda4942f5d2574aa012eb521c259096999bc9ac731738ce6b1167eb718cd6cdbf6ebdbf503cd448a94efc2930b7bf735a4f22885f943a525118e5467c9b5ddd7c5b78fb0a53eea9bec014e1504952e74a66df7ff1948740a8f704881c0e529a6a9ac4176ad0fb105fc4cf139f781b6c16d85d388b995444be9d070efa2223c3ab35acb38f45b8cdedefdb239d7ea35b287927ab72020e8f954d1b1822f64adc747497e897f21521d1c92af3f8095f4ff96a57c828630ffc5e83ebc2a2f9cb578fd178a1384a6cf5e9acef5e9b015e74b4c6550ea8006e2b07c52e793c70d6d809b9486a31701c9390ef95b9dce74727f8008e52106db6d53120d2ec945816e6e50b209727f3d0893062f1ed9054237120204ad48ca2c7922d11d0752b0dacdc7382e7e37fea20b3c9f79a5ecc383ed9d2812e846b898950f97ea5601c8046e0ba9cfa9263cfd351a7059b4334f159953eb3fd9d70222b566c89afdbeccc3f2b9720e035199b144586ff3a65921cb05688b2ce2ff6ad55234ec84034a5fceae3ca6900da82a4dc62a39dd9fe42f8580c08352abb47c842ffa1c163d5a972b4cf90b9ca726b2b7d5d347840fc23c3f6582c129b3ef0c73480cf44b69672ba893b76b37220c097d1a8a1132a444173710926c332d65d207ef49d0293c39ceb59ea716a78aae0df8a3ed2403eea81b5d672c030e1cf6e76632032b90ff3fdf069c08393d03983b16040f58ed72155f983e8f0f19e6c08d2fa7d8d945ff3b6b5e4dd121dae0d815f4367e54baf9af0d92cac2b44c908ed5f44c45295d482feb7527c0c59b23179dfc73a381377741344ef6069b2f4dfcb1b5d79ef584cfe9224cbf03f2de7306523d54e5dcb9f287b5d7666b071a10eedf91004fbd5ed32bc4003f7e890f9920f35253bc254044b1314cde4402b98cd918be0d5396aa8cf8bb18fbc42a217efcf7cdaaeb056862bcb9fb0ffebf46a0986d9bf06b1f9eb32920d9f287a3ba42e1468e76a58edf8ef526e296ca9466c9ec45c1b88e4480868f7c2de71b9c9376e8b1e9e92047d396eee9d5314fab46a2a70521ccdd255c5560b324723270c7ef28eb911dd805f77ce6d9c6df8c9cafb09c8980ba533d39d2169842ecbc706dca7705a05149ef0380a722605e2100e613fc020c437417f8ee4174b1d0a7402e156f7d3750ca415f4f3c7874588450156ed7cccee421f049eab75feab8c935c95e941d51fa359cd1fb318a8a48cc4fda424b9783aee2318d223bb2f8a3efe12ea3978ac6f5bf12463b049839ee06782e573aa256bcfcef12561d28abf9e343d654c3084eab83e6d4fb9f144eee35533cf31f7e543915d6d57faf44f8282df768bdc49e491c8f7b7dff88328b1020e4843c9fe899fd9e545d2fe1319a9af19a66a41a49cb1ce6b9de6f4587e76356534e676df647487b02ac091e5f6cdb183d10028f51d5aa8ae2cbc6b1d797fceefbe6a85e1427760308d1b4d28cb525275d633516b39ba544979fc18cab4921105ecdbaff7e6373441a8ff9653256c109dc968d543999f6ee194e1e200dd4abed02a0890448e446aaccf5242ff66cd83ef0c8b8c542b1b6bba3ae4724c73062d463acd6981803206a5062e70e416cfbbf22ef65aaa8cc8a010c5061ca260833bc6313c6179934330a249528d9c1b46afb7d6803424048de06e4a9b4981ef5f39b7334ec13057bcb2987f16c000ad45989780e712e2f45f1db331fa5ad76bb9219bfe3542e32393feb243bc5aef4b537ae86e340081d1fc336dfe2471281e4890283ae35514d3cebc24158d843cf305a22e5f8009f5d0800f567425c7498d24a0f99d9508819b8704c3044a378f12b909ae1e3969aa7d587373644665774e96e9784b9fd9eab3559a8a6e5505c78dc66376617c876c6ef671e00a1e83e7851e731536635946220bd5811ff6b09b0507773a5693a7c2fd9ddc15f15cfa02e8a523ee2ac47bf5befcd7c11b3fbf55dff4d26903e5063ba02a7b0b2c67d3acfd24fee50328c7b232487122fe3aef63b97f8ce08618af51c2cf0e5dbbf8aae06a45e1ccabd9e5ee12c512a6add91e2b297b414308bf9cde921628ef71b3a0dbd07617090a88f262a1be28834875ce7aa3aa8d2b0d029346c7fcd58f627c9a3311cfe1f34740eb6bff6a984e2558c099fd9617299303aa51f6bdfc53c8cb3640aacc2a84c9093360790bb7d2a614a95f838117da54694b1c316035dc6c0dfab86849c10c127e0dd3e722f11bb8c5d8ef01b47df1eff55fbce42776757269d0ae05628f72f23d8b0121cff90208f192c0b266ee3737a0fd1dbd7e77e18514f92d44dd77620d9c25d51d771b4ff0ba2bafe14be7f44730df76fdabb73d43b7031aa1bfb192692f39addeeee47ae480cbebef96639fb1fbd872cc9f516ba25140364e54791978caa014ab2e45ea6b1ab0cb565af222a68c0161e008ec04bd6c576293a8a93267cf1943ae12e6cb1446","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
