<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a65d53b5bfdc9f03370fab34c85b9946b06b5bcbf3511ea1b53ff6d69edaa45d76b0126dd38e03653719e3c0052164829c9aa2223d8ed255eda12d5b197f81938756a00d9dc217aa240434d5323f17d37f3c8007f7aea395d2dc0b8450d954569a9c063e34e8e9b723c1d9a88114a957c40b6c68a3bfb1aa0e26a30b15f59b16fb8f0ed204223e6a57765f1c72cf65470fc42d202dc2b5c9205684c6c52e7db0a5384c0394c5945ba8f67a9975b70cbc45acf93bbad100e057e2a9a08c502cfa33ca58d147809e3ef7a8af6a2b100064f6318b7aefa2859048ffd40cea835a9ba47fb69dfd43d868d73be72d54793c08a3bb296e09e23e0782d632d453b4afd44691a7afe736cb7552bc37b77279fba7efdf748c3a8dd35ed99d0744c1b02471a5f702fdab51dee82ad088d8584320e60b3865d217e94c33c3674071068b57eaebb42905cd8bb0dcbc5298484518621fbb7e72567f12831f2e9fb2e43b16c0887755d70c694b8b80b7db3696f60010f14f96fcd963533bb9d2cb1b46b70d8b34e1f34c0c4191014e6d00114ca74ac299cbaeb98598d9d7851a6c04c0aed80d5a31ce8e96636009cfff6c6104523803621ce4a17272df1047cebd3bb08a7e887a548276b5bf8520eaaa50b23bcf7973f3b536ab58878a6ee5e488d142daf4a64729ed58f5f5b126876f7511b5f533acd5ea81fe6877af0913ecfc6c15895df2186063999736824dd35dfd59a28cba38e279c030b613b5aeaa1a3afdf42c964decbcce893d0c3b98d144961a174df1a91ea252002d9e104f4dcec43ca9f1600835f7bd78b073baedfbdb0833fee7a0c57fa559e63fa3f678ac1d281cabf5d99a167ed6167d7ecf3bb1945ff446564efa5656394be799be671f01f7148936e2721eeca21c95e99f0724e033f7bf20f68c9550f2bf06ef6444a2a5512a0de14c41a2ac5a8285c899fa0ada946650898e05870cba746f9c7114d47d3fb61022ea61a5c43281e5007dbfe659bbaf0316ff269963611f5647ad5a828f7e88b5375216bedc9901ee80a2f681ec77b774e8b4f9777be765f71e431a98542a8aefe01910dd6343f198c6d3ab5abf0938f86beed5e90b29ea9b6e9f587bbb0c1ee98ed5ac598365325953107a506f3e577fb0696de53992995f18a27622aef44424343551efaf0e8b58e806a67159a5b1eb330e21eb43f4e7ede588024812e6bcc24db158bf6c89aa440fdea34690e606ffc7a967a17a179062adcc1338e6d7b15a4ddc2054554e4c1c55b7da2d5daba04375e6c922ae43f25afe4a2e0dff94ed85ecf75e05c3ff3d797b8e28cc3a43e9b2eb2cfac3f9707c23fa5fa87d7e120d37feb260b880a2bd0873cb8eae965bef1c4f3b6c7b8e9c207900d8c74bed9f0d6fbaef473ad3535e752e154bc30afd2f0ea1bd5ee3404a120ae606d02f3afd1365ea30000c157a21186bd365fa5b73b3776ac4a9bffdc13354f52131d9d0f7d99df5998c2a8be6d072dd163a1f297f5f4f4bf0ec8a45b4e3fab05dc7297f6ecbb17edc856bf678ada9c56bcea62104815eb87594bb0d3bb9a9bdcf40af0d0792052afd2839d541984506519e0370b85ab615ecdd50347e0d47cc3158755a15d7b634a2c47fd7dcca55f48b82213ba46980793da6ee8547748eefe4b8029a91ca4d845b80d11c4595134be5e88949c710ca1e14b734b9dc346cae2f52078aa649b67a0f79623a8e5cdd845c7ef8090f9feaa435297dd691dc01b10b16d64eb841025c67d3d21321fedbd19d92cafd521f7ce3362c5e6f3115a956bcf36cfb74a9fcb28fd24b3686b7798d34a5d893e1db4ac0dd39b3fca014be01a7ecf58cb6f697437658cddb5d49ac642b03b6a0f01ae59b2b2819001d2bf3ae1d6d5f7aa61afed0351cad33624cc3d12b4d5e7223abb448204785b3fca969da8c1a92afb11617970a9156a9772e82abe83756c7c7e2063b88fd497f1552bdc11f15ebd2481d717d04c33cceaad101ad4c0d3ac7667f1cd1a33e8235aa87dde4f7a31c031133880af1826d41d371f69be81e4ccb8ad1ba1e6e022769802b405d4c3660dd093994824fa4461f48503287a95b38421a54146d593e9422a30fff9666d5a6c917ea0f179c0261e9cd521e7d03c2c46dbaf7128bc123964da6d4517fcea1bedabc2efdf5783ca8939aedf48259439241f04375581ffec495db3e4bc974576a31b53cdbf65511c109227bc0dda0540d59e9cd9609f47e2014370ddc6e01908dcb1e32fe683e62ee9c67f48df9d37d296ca042a1d95e638b6e5eb0eb83ba2882bf39381d8d7e0b462baa24f55376304a61dd90d722f230992402e8388aed82ed88744f4a7e4b836a2f820c1b94f24aec8d76089ae4438ebb892f987e84f90a808d1f653fbaafda73fe1b54d01c14e3b391b6c360169df035efd8af78d94078e5f77780da34568a1a81d817f30a8429c2f64490efd80b8f7351e7fa1033bf0cdc41125cbf9d4d0eb38eba676220cd7741aa05e8d7c78a1600fe8de778a3f420ded9bf6c2295569ec34ad54085f775e7ef51126d0945cca542837366be813a956ec7f06e4f40c64286ca1d22438d91896f19d38abfcc2884a8e92c90ebf79a2adf5b93ecdaeb9ce0e61a3ceed9c1519c2feb7c32bf2d9637615b8deee78ad6296190d920f57b60dc31078a968f56541b194e573e6a2036fc687e41d34e6d6f0ca13918c624f5bc3dcfffd9c41c516fbfacb886ed02e9afd00253e9f7fee5e974f5d741180a6e110d49fb8b90d22de97eecc6ebfea6965daf8a86da341c95dddc9b11e5cc341556a8308ff3cd94ebf07c190a531745aa6fc46c08d407c1c490d1963ff6cecfa1f3352f65495d04a288d7ab35536ec9590fd76d7fff547ec31702c8fdb9de9f71c6dc4240dddda319e3b7e9ee03b8aacf925923a75a3d47e6797ab65de7798c2d57b75f699e85cc8f6da27cff62cc04c6c059e4409c030ad6c153195aa5b20bdfd07e86233cdffc7462229f9ae4256cdd40e3f08d34177ef27c0f4ab72fa29512de2d1ea4f5ba432bd3d0db9bad2e012d469d3d2873500693090d8f7fdc0f690e6fd50d7ac023dbd3a347fbc71572e85d44e0e97135d554450ec0d526d742b300dd783863c67496728503157e5a3d314f303d0ef21f648f98b4703dd54bc1e0075f68bef968e7bb3283fd06b6b0e65d8cbf1ec135b1c850fb4253ec30ea3b03d580c0229588e1b2be3ed97ae182cb3be8ff32a74d3852b1bf0feabfa7a9d211ab4e4aec9055e8a4038ed30a1f6d6fc11c809c7408f3f1d1720481c3b8f7543ffcf68a19bb0b7cda56547f42791352a07c8f464506de8606e0fb8337cf7435826dad808d96e1cdc749e5a0076e1e5e38f84defab56c9ed15638b7790951617a6eba686f221962f46f41bdca8a7b339c3288ff7f7f285293e9d63aaab8b23e87b132db2ee2204bcdaf25171e742f8cbee916b915bbda151d5158c99c063ff6aaa36df6313ad1d7c2c1d8eb7e80d2882e92b5347a0d2e43625b2b7418f17e13ae08f5f32fef292e59c6f1ccf637926f955789139740e3b062b8fb8fb63fe236bb2568f600ceecccd7ee150a7d62824f50e45e39f6787a04e56216c00548b20daa3d115172ad9ad8d7da2120f24447390b3010f4568bb301b1a5ef282bfb0bd6ca8321b375bc37411775cee9857f8e902fcb5fec99226b49329a4338aef69a851407671a1658228124a8905b6c7369cc85b1a65976c3097f2cb9c3babc29c084aceeaf1b51dbaf7ed7c465d5b0097c0216bca38c1a8a509278f082a5ee9e7d0e376cbab77607d0578cf894cf2410410c31febd66b11a0ccee153ba83946c78f69705e128e51e841f9aa4b095a2d7e2a7ad0c90d483da7bfb9a1c6d9188b6f88a03c4b4b8b665d6fb6e92c0c21acead5c4b0ba2f17b18e0c42053fe294f3a27d5defe4684e686b9daacecf4a2e58828542ad6d4edc91c46cf34c50414a122f5f0d1a0b702e97fedb1c72568df8ea30fc30c2510f8abe64da0ca90ae017cfaf8b8f22b3dc61cf99ec85597214ba22c1fc790c7f3c345cd95c741daad7484156d9821826e852162ea14f3bdf23040a6b89ec5a82e17acf69f5d45d6fc4ec3287a124caf0b0cee12e2cb7702ad6e40ce79cbcce3c72b8f3cf541589045c58d1e47529f1fcfa9011d995a078fd538bb80bf0fdf5f87340e6528f0d541e438147f7c85a636fd1c567d2f93aa58940b1a2d70be2af11bcd3c0ea527a52699e8ff8f775301e1dd74aceba1aaf26d48d7e7e94e71d02a01365d9f5b1141f9028f3f212ae45952be1a4a8fb6b20974858850125f2ab5eeec496c1ec23062b9eae04431b7f01a361b4d1c6a6ee17a5d8b8454e6dfc184f5515b0f3ef2b6d26a1fa88cae0a9489f5cbcd5617166b1642ab9bf27fb73c934607c55655961cbc525f68f36f3f407f4ecce3e1814407779e6f66cd664a8058509e207d04e64bf3bf24e7d5c8843b0b02d110f42a1489eba816a9c7367cad7fcc5f6b8be80fff338ef7610dfb3fb86baa4879483f8414dfdab98d5ff12091fc2ad5fe7f7ea5f425b556e30a21fa26ac3f6d9451a7362789dd2b61e5059115e82176a1682d0f4ed3771ec2e7ad289c02c37816815a5629f4cdba07ffb62ab56b1b45026f98a1e8b6dfe0cc826ec53a626dfd7b0ab2a53ec4ded7c9a79d519b7e72c53178ed316c109457c7351ac4346f2361301d13203e9b50fb6ce22a9afe5a7f9c551ad2c8f0439cf7ae0515d2ad43c553dbf66b0acdc12a6bf1d561a7e060df031202f87bb292b9d6081be892bc3268b60d1d909bdd92c95de9e7832d47302063c68268a6464bbaa2b43487222a525b9e7087d3db22c27a205026d0a2622da3d6edd6bd96daefbb8b5938d2e7368f4a4d76426f5682b0461bab81bc72c52097952a14f927162217f139af209cdb8d12b8a7b29df1b9cc6af7329419b5821c2e533ec3a2da1655ee23ce5898de16cbd91d24a2d908bf0db906134c388a78fb4ce105c98743343faea626cae6ba628ed538b98bda9f75c11d82072ed1b7223fd0727548bada25ebac115bf7673c87c4b30e3d9409c5aaf2e3ae776af9b959786e98276275bfa8bcc48a327abd49ab3b623c0fb5242808c8d2afc81728ea2ad44ad92d9b6a9a603c8b25033ebca93d56fe34b07c8292ec8f28be1bfcb732d42ad83b9961c0592dc0b4792106ac70af1db8cfe3f71fca48915b35241d8b1f4461a15ec9b54fabed26794e9590c6dae08f7712ccce5e8a5c72392921fca035d81522f876a70a6f998ea7c0d5130d8364e792713687a0f5050dbf64f55691c88522a09056bc2035f3f65acf35e5d0e836f0a35dea851ceb48b0a99bf14919383c987ec2519a403b8984151aa10e167437ca8e24a40d81b71a63e1c4e0e1eb2c892d32ce6712a1b9e946b46f2ea2e1be6237b9c67829f4a5feb2b9a3422ead0514c76fb1848c56a34ae3db19ade191159e6a4a997aa60237ee1e62643315013771942440f8020e56c998533ea146f2d76cd67f19302f65f0966a9d2875ba2e5ff16c69e3856d50869a80047372eea9b6cb56bc79f55b8c90a6637e440fc315f59693791c0284dc3ef7e3330924178d621c3a18b903d23b144fb039a091bc5f34bea9fa33298cbaf706659373f004acac3271e090b6473d9821ea179850520d6fc6c6f43eed977df0715f216ddc968abb13afeeb4099613eb782ff240c22d4cfc6f8e81f26f97491442758fa748a5ef59869563a2d89b28efcec4ce4a783c3cb9b57a6af1baa5facb7a0ad9a0a7dc3e849d353e85f391825123f824a49b6293fdc0d95ff789398811cb345b423fc22f5a8ab2176f4f59509ed178b924204b3d606c2268d87b5dffd1b4848f9f54e03f2dba662c8fb62e508a759936c14038d003f48fe62fc12e67f68d6ee59e32aa3425f7e80462e2fb6d181fe636a4053bd86e195e47df12f9cbfcc64eded4d7c03cd47810de1c89d480bcfdd0123c7ce8a163f14ddf47b53dc44a5ba56f3db027e9ff31f2bf01501950c2f97de5a69c44573d6a8ea892892303446b65b80119231096ec3cb3713df51f971a94221d996e5190900f78685e52033936781ffd22e952d8095f1a87c8676393ca21f63f037aca5ad1999a5e707e5ffe7e7004e64c56e69db8f8b5b1265edfba14f380c1f8ec74d5c9cbcf03c1b38749748480140f748eee764f29d9a7f54d0b45f9f7e83c74bf8c26affb0c480efaec2959f4e4425db8b6acefd7dcadc856c8fa89465cf642f0cf5f589be6e7ac139516e04eafe0a78131768914dbccc11d813addbbb08380e3668c7cec1ee8eb5f719d29f3e35ed1ed1a9df9ada7033ea5350ea0dc639e284411c25818721e69d133fc0185f947a97571c70c506a429bdd4a392d73c49cd0e243ba1a9deb43434e2a3451ea449377f8465fdf54e597b893ec5d62fe695922b1cf93a5778aa040d975bff536f12d71baaa54690e9be4bad7785351664a4298b15cc54f7b9ab24ac68f0ce28b8ae3dcabea655b59fefaba50f1835c8a4e06b933e83d0d781e131237060bab1e19f77d699bd3af2298197b791459d7dbfa9259cb63111cd516b971cb88ebcd36bf071b43e7d7c01e1062f0d09c2ad5f414c8196c3c97a1c04fc04919340b0384fa6c5083c13af0064e491111cf8543e281f38a4079f401a340226f32a50b1077614c18109a4ac0398cc1a4def0b5e196d17f664136835cfb9f4b9b84eb39bcbbdd08474631fc5230b808f295efaa518e3ff463ca39cc5295ad6d1e6ef14e08ba57695ac1c5edb01f8351d7e4439fc6163801d8bd6c87d5f770b64412b6d7c87a4d2d0ef56c0e696e3c58f6410e3f427242fb513c72f3a3316c3b77f60d7100b8689c47bdfc2ae7e1eb4b6f4c2fea748b76e857e609e415aa7e5d68dc8f85305f8b825b8162a98418d08e849309b048a04c2f97c693e9fbe2cb5bb2b2c3ddb8059d772c44a2a0b62f7b655d41bfa399dcf599a855327b480f3fabe95b6a69b2d0d4ced033b78124a298b914998637d1d1544a45ff21e414781de6bda6f2da732252c7cee2664d93e10f5b7f7d2caa3d20623cbc1e95db7874b311b8024b947aab1ed75d44d12ef26fb1c637956d180142a8321821caf97127c955c2b6580557ea87eb18a3307e578428c12152bcca8eb49ea1ceccc66a36f675d0797b58c8fbda5026cedcbbd0f4cbd11d665ed5f099c4fffcc1c2076e6c9bdff86e0a957130a77bdaeae8cd2a80f09f0a0d1e661e24ff9446711c9404d5ad103deeb3be7f94199068109cafc0529cf247a58e6b08fe72b6c11e630bfbac099dfa0baf4b532e8bca0c76827a221695f5a00693e1983b66f2a78a8f0f729781d65bb7b615a4047693d0433857f8cda96d93699f73a94ced6d7c91a8d2c514f3192a69b863ac4e6c22882001bd3030d7f0109664e51386ed23837d12dda74927a6dc3ea64fa4322d448d9023e479e7bb306108ffd03ca745d4e358e3059576a14bc441c2ebb9f150f72f8340e46ced54ef3a16d643db6c88ac96da78cb103d701c754ba9e7857aa4a834546b9972aa667dab9d9dda65806088b126ad7d80b56bec7e9f126497dd5912590370e5ec80180722d5226e9c63b61c174856e81bfd26cda4108be741fd187782e8c240a1ab03275fd824f8b5504c6f4eab8fa0ecd74092b1b05d8d215ea1a2e7ee18db55aeb273dc88c9f351b6634520e6f38becb663c823a0766fda239b2bf54e1f19b96fb58f614c90a4c34f3aa5add486b65d61028d843d7fc10a4515afcc6d2abc0040ed5ec1d41044afe67e98711960d446cd99611fa00125b22285609894ba56a07fbb31ebd6aa850ef1f2b960e7016d9ac1dcdc4a9cca2d3d99ad11563710afd9bf7a73c13418bd61c094bc896e4868eef6de5822db8ddcaf90dfc5bc4157531856f2c745476eb9dd4d7660b63531f85626d7c2f3d5ec03a841ff25e22bcb316167d29605919023a4a7f35cb7b29ac6bd64f7ee1e3e79b44084740adb3aaf6c44bbba7af0525d5dcad79ef4197c42ce013ad04fee3f3f2dca416b237bdc160ef5eb577656cb105917da5849e5869ae9cf594f67f8b027386c57370b1e3480f388590ae66cbc42174b0059a31c77c3ac84a1ea1f821a98ed91313d37554337251472e7b9aec2ae4ad88676f080e061b2a304562f906e4a3e62d6ba11a4aa31ed17d24db03f887aeb43735290ccb2356d8dc5eaefc724c827dbec5c50b02dfff3164c5481a0a381ca04c7b345291d1b67caa7a98ddf3e583867b6da0af6690b5d815707e128cfac5f10718ffb0617dd92636972e0b0166be8e4b016dd73c423ca168da451f4ad7fda5287f4420d3e30300f7724d54f7079043489b2a368f732861a3da2006679d1e0146eb0281f84fd6d8a5e731ffdb2d5d548a6795af7f61c08afade4fbc2ccc75ad1af96e5c2e4f1af525a15f897850fe053a7069b38dcfed1a616840d46bd6a85113cb55b86a8a509f50eb909511df170537b5f161b5fce0d1b4a17c05b75b5b01a393effc137343ce97e9e33985d87c36a7ff4fec43b8ad11e9b42a2483f2057730d3caeca6eff0b2cf29eaad5cc8dfd24e00a5bd136c936ee623cd584749ffe19f97bb004bc653cb3d161a3569de64d8fbc18d1001953be3aa41bbe2a3015452eaf34a283ed41166b719e8f354c02357a304e69ad356c3706bba76cb25ff845c54a7755f313cd2853ca58b86953fa3c0125ebccf79445bdb5ce8b7fc8bf0488a4e738aaeb2638a9018869ef60ae279b6395330acbf67208fc71d8a1dc8acdb812706775ab396c76cb25c4f27425ed6abb68bfd870ad8e797bb5717374b3da66ac2f738bc8b6fc59424b13ac3aeeaf888da0efd759f2a9673f714a244a4a74a8dc85f0a8a3110d523137b0826d584a5f7cf5c90e7859f2743e6f6c31109775ef8a4479f32b097b695f32588e1cf3444bb7d94645cc85cbb7502f73236b88331754909c4d4afd16b7153bc9a01f89fcec247362a7aa575dfb0d2fc2e6b96932e48f52b474051129f1fd0cc6c97f529c8c44ac2c07c1b29fea907aa39de6e20753cde09f4116f3f0ffe979b62a2ab4916de2f275e78658606d037a1c429e12609b5a347d4868fb022121c6d818c0a565f7932b6715d7459b0d101e9120299961233f8574d84498bdc2f8a3908a2257599eac4b5934570d94fcd82d39b0e87dd9a143386b7ad3fe201f3ffbb9bf6be7f249830191ad6f3b5f6aecae955b5e9b6558f01bc7e20e6a29c55bd1696e994e716899f99ec71ecf8339034e8e528b0294701acecde6cfde87c36ea1c05ffdab6cc9581032e5165f4e2b6514ba6f356007c65d7465771d06d80fcaa25a7a1ea1914391390c65513e89d2e6de1ba3310e2aa4abc50a05463abc967dd1f6d48eab12fb2db5c23e68184762dde92f7cf88fe0d509b04a9e6f37c4caef1123835baeaa69e83832adb74dc8eed660cca78d40da16ba618e7e5f5ab63614da289d6bca31f6a69c7a991f6da57a0dcd560e4bc0315f881552b2f385375c12a807f6bcda712e81384143b79386460897989f89ae211cdeb90bfcbf320d173814fa2846d8763efb654e8a9fb5252313da2a020d9e7ab57af692384f2a594eec5d7b5b67422c0caf7c4f74f2d057cd3fd4f3b1a2bcfd6074563d99ff57afa43423952d37c64513df7bcc7992a57497977dbd7b9aefa3fe6571921ccb47f460fece0bed668e18036820005906085ddef261d438ca4ae009b23ad0c564dbea4b45f1634d6894d28506d13fb247b2f8a4fc33775f7325ca6ff9e8870d05ecb6ecc9cb93d0f95f3d4e8637a2ea0649e57ff5e1feebbaed8b3bb1c1b2737c399a0443b9647d423f588f301755076d9d38275cb65bce18ad3a6029cb492b209d6ddace9d21b6618fa81039eeaeb7e31c199ded5e5f2cc51935f88a1db59a5a900ae1acf2e1bbd871482b30288c399aa960aed5391249804550e85d228970e55a8d232bc9eccaff5af1b225c46308070646352781eb318b8b9e72908eaa99bd2edbd6037ff0608fe79165d07c89ce6adbf807b59d0353b92df18e276c9e5aa91aa304678f9041c7a3b27cbc4d78771f12712a3343523c19b858d5385eb4a364c87fb5732f9c2ea3fe9ddc006ee3a53df2a03a5c1ad4445772a15742ab54cece397229f2e92a68157682670dac95e447d9f69b14c3e33da9b64f9533e57fab906604db769c9ac110e81fc0f86fc5b7107095d0bcbb6a29d9771a9b756780fac06d390f15d18bbcf1ffed9b3381b035912a9a7413ea235bd41b4b7dfa3f35e219ae854708c8b98fca1d51cd79e60bee7c5208dc89b2b346c4eaf814141584ffe3d6fd262aecc6800a99bef5b09ed414e8e8a916a1d80cc2fc76e58e4816a349000322cfca7c8ec3d0f72cd1ba2ee0a953d4355c18d840973bd23280143eef4767827162c8959730ff17d63d93d04ead66b57428e9a61a384020e462e5578eac01eb3dcae86a2ea60e87449b420877351eb627836539b9496da6325e2e7407abd2c54014991061a034a525479d3abe35843bab6251666b79cc6aa98abbe58fa53cd7967e82a9a71738af36e071a4994bd9758e612d1e11ca97f89dd6538975433cb296e8b793fde227ecca5a1a979f138268726277d612da7ee43e84857648c521f04ae12bb0756e736aade3624b6f841ae3c1e35179309a32be286d398d9a44b2342f661acf353f9d387b34cc7f4f99170d6e7a22a11bda19233c706a25a58df460680611c2b47faaa7b761289c1b0299da87ac476f84570956ed1081cae8c63f97abaa058bcc18e7e9da3ef1de25eafa79cb266d3a7f610fbf7b466b81d11918c7fcc88696814689683851398e7a2a59d056dc5b2974ab060204dbc5e571a5f9cbf6d116bb2e975692d6bd214a42e0ad1c8c774120757874a715b28e6a488bf4c55ae783ba6fa2d8e3f70cf43c7e1f0798f2926dfe071ee133e60367721cc5ff5985fb91fcbb6b197fe6c63ed16ab4d1c64efb4c2dc670ba2c1f24c2dc9a9fc1d553ba829e326386b3a38e0a902a817995597691f0caafd01d74dada688fc0d1b2d0cb114053f4186aa3a6a67015e4670732f2b140f82af3dea6324287c8fba5e73730fbaa2eab1fef0cc3cfe57a8cf0389a507d58b490a5b792bd20c9b11b7825cf34c35f94f6675d1d51506c7b1629ccfe58860393688259671ca4b47bd49d3298f1407f829e2910cf811e0e9621c338f7f6dd4f4db3b4a079eedbdd508e925f54d666606f309c9c4ebea4c29ca0e1da48142b3a1484fb1ab66129822aa8187c0f570f4aa682a80ddcd108cf6944e618eedb6d3e36965474a7957cd1572d026512c8e2af9299121c9a507aebfca05a987089c010a9cf382bc5beb4834f43f4a8310e7fb0863a65dcaf1a6681021ac4658962131e11c3a355b7e293d61a5758b47411d9662716939facb242ba9a765fd978d344010c587b0d808129d6ca847b8f2eb877a17061435cae6cdaaada68b38a43325656b4b3047830276a0cb59922816ce8c7a13a0a8c36ef84eeccce01ae64e538d1cd1ec9b838cdbdf081891ff7bd6c652b88c71d765ab4a38b8daf57595b16bbf20db2fa2054606be12a7450d37355dacf5a0b80d4df85cc08194f01d9fafb741909c7b3b6b74e611541cd9fbaead6cefb05f965d4976be9f9f76a8bb773f522c3c72d9547617a01e6e36b19a1fc17fb6b586bff196a24311852d7b831be9a985fa5864a16db31c54029cd5ad381feeb24b26bb4a1087d87e5daae7d99ace7905752471cfa06482cb221d7a0b69d32111a360637deb4d119b52660f4382df852a4268d4bf5f7e5868144c46b2325b07a000849321c79dd549c2f9deec7a7ef916ef67bedc27541255722422eaf12894bd6e2d69affeb6db03fc3936f158166502c4ae2e834768ce4efce8c5a414eb5b3ce889e686fa64e272de68bdeac315845b7f0d47052f3b384117a0f70170997d6b531895bb857c459e7b626b7b272a3222836e4e4ea83665c35e1f835691aab73d084e63f86d856a84b9a3103cea1d475f52c7f9ab1219b083381cc4b6b51a78bc523f17bfe6045030f7167213b94b737c5cc07b2c1e2922b1b1d35e72f5d9f5766fa25fc8652e3d56b95d9c90915118a199fe7fe46dc45fd5bbe731527d50a3255c35d4fefcc8e5c3b42940ef16b5b7ef70ce555c607034fcf414b1342c9dda33eeec930643e0a0bdf833518de1dfa2cded13359f4491d4a5713972817010e8caf844b61f652e3b0f66ff307ca82d2072cf9a30d08d107a302c2b9547038828b7c3303750da38a2f3bed886f6f323fb49f5947899a3d3208d0d9f2a231bb2cd8e3468fb2d66b99d371268f191740c3c4d30a75f2138e2602a119758e56f77d2b0cbc126a70d74a9d21146d2f6841143edbe3571c19fea113269cc22cfe183ed386b5aac9f159daca54d01b5325b2bb1dcacb241045b3cc5a20e56c76bbf53980e9ce1ced388fb4a1cdf03c437143fea5253cd00c85a9e44923558a72b4368dc0f133f7ee5dedcf7e00ae2af5da38f3c6b9ee378f58c04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
