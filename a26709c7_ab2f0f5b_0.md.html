<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33cbad1063bca7ef45c9bce8ba57244d5dda874a3cc9946c55d7c386d86055081f838843cd97904c7ac17c9647b201c77e9717081b232fc8a2ad730eb7b4a51fe0ea6a05f07354d8ba98e40db86b7714e8025dbdb700535e56909599a35d5baa5f531e9e5e28bea3243b457d5b76e1742129d5c543ab93e0b3e3fe88facc5a3937869f045a1a318438e18d5f4d7621463792afd5b6c28dccc633e8f7b8495a16d8e188f1ec8897165c9ff7a16bdeb1bcd83a9e1b21bbaea9c245d2a92b686f11016a36cb9f4ee59a9991e44edffdf614bdbaf18e392a1592e5eda059924d640d599e74655410d4ba6ea8bffe3081bfa8585975df5678a1a381b5ef135b5125be6d37abfca46ea81e8fa331cd6a4aab5909b7d11c6146df0b41969b63df2432f0b0286259168810c07f0aae67ce1f11664d4f04fa277031981ba3b20201e2cc5b2a3b2bd83150dcf9ede907f3806496098adb34202ea3dcc0a5f6ab62d0f01026c2feaffb1a7616b1dc048adbc456b2ec42c286108cf85e5b0abee12b875b920a7ea38441074bcb2df062a91fd8ea934741a28ff190efec6659125baffa13fc87ed8cef4d663bea782a21c01243fe90c1fc667211696ea96e092e1e027ee01ed57d43a5292ca79282ae2b523897fae1c56919a7dea91986cf19b129ba0dda382070f3ad47e7db26e9aa5b30f15264b4e40b4fe6c026cd8e1fea790e89063e83c1fe5af34c8a89a00752f499b7bf3a8c4aa1ec080fd2bd2a0c79482e3f48665c06f4385f574015d93780b0e7bf6b6d398e5be6a1bd05cb142d7a0e4c364d9f36fdf3b13df8af4269273fd54fc0a438ac357cad3e4e2c60d0876170b7b0757b044e89b0b76ef07e55b7f8de4ac7517e19d449ebaba51fefcc63c4ff89095952cce83fabb6f55b66699b648ab1d1ba3c4edfca5ef92afaa004f29b2368453e4807a7e4f458e3c9b7184643fcf62cfe05d64fa7e745b1b6bb727521c25ca367ade28b4c0f48e4b84a45265886102324911d4519144ea2a4686daf1551c3798cecf9804e9c8bcb49a4cf2e4e1d2a67c9342875f93bc76d3bc0a736a3c16a392f751bb0dacd2e21c47a57424508e9bc796f0a4fb97708113a83bac8697f17dbb0efd8803353ce2962433385525f38a85d0ef6d7767f1595a079fa885a6366e66fd1d1b57384e29d5a70c8513fbfbb5032fdd5c8d185eac8afe26fe8981c948ec239109632cae7576e7b968253d6d35c4896eaa3266bef4fc36f3a0c31fa3add13626441ca899f2732d7488f9720b7e62d40307e589fe900ff618e3045b0970b07f14e146c2f70cf1a5abdd68f4891592265e9f4ed1290b27a7806420862e869dba8efbf7353af992f186dc2133194a37107a339512570b70902f435335469ac708b7a3859129c5711827acd7f51a3f9b84676e054a0c87ed0a216222b5d0ee85dce8683540fb4bd68feced4aeddcce0ad428bda30d00aeec9ad79683184b194ee58dd6498188d88a094845c989a190ee5f723e4694157da9dff5eaefb1e2e2eaa238902a75bc9d5e1ec5c8dfa9bb1d8edbeaf5a30585f62d3c858553a69b527333ce42458c7a3a82aed30d1adb5bec377294b3c54fd359c628db3e655a4d181b991eee77e118514a95d0468e016480158a1fd9c847628231c149c138277ebcdcf204ff97bd9488f6cf56f32f2b3fbf6a326041b6580a5e2cdc3ebe1df3dea61a2dde487032324123556f4384adb5f4b2aaf92b265ee40081dfae11a0ca64b5573934286f355cfe8a3c5a435b905f244f6f7382cbd3b3ea1fc9e1d3228ccdb877380370060b55acfcd56f9fed7d7b2dab047afc6b0e9ec3b291f571fa18e009e40783493fad9bfbb2134a07642e7ec6316fc026442fb4afc8d274c4dd24145f4dd781e2a270cfc49b38198da12dc39a9a65cf0631f9fb2f6aaf2693f7afc5f5763c2f7ac8a1ba97fd22fb8a5a1bc5f3b5218795ec83f8cb33cc9ec4985d884d62fe231fd7722f7b3022cb81967cecf9b0020cfc13a7734ba079e0fd0505dbe67c3da20f01a36b81487438b089dd136e03e96e9fb9181480eb53b0f422b9391d9d082e85dbfae5aaf3f1c985056cddd94119ccb5fe278845e2bfc87524ec6dab98b4d2075587dfffff4ee6e27b80ca567cb2b264ae334159bc56c74a94a1b4e1f6f32def81c5dd55892f5cd1c4b60870fcb74ead5b8f017d3c5f45d5ed481ef392613d171301e0cd1bc5037cee9ab59465f81727587638023441f5ac79772a31ea1bbc7699d3fc4d70d29cf291306b602c753642c8785ce5bda3fbfb6fd11bb51c5e0ec5296e171007d7a1f33b697f72df9c8be57f4e6e92857ee35daa466972ae440b034352575bdcc73c0af3f01a7614b8e8083838a3c514264f7381af3edb0477bd2e7a62fbb9b0933d444fbfc2aeb14b376a550f0ff277e98e569a65aced0adbe750a203c1ccb58bd49f0ae6607517c65cddef0d50b9dbc65b71467c423d6b326d71ed80600805994bcd5409f0a370c1ddc1bf51cc1cbf1d1e34abeb5458854be86aaa0d946ca13d74cc9046bd8d6ed73ac1005d8c3a3872aecf3fa0a700bd74e8665246eb55cc6d1dcc824e452e5f3766a1e86138bd4c1a1334c7cda78527056c9a6041647633f7981b88758a5d722434669eac10d5188e41c8a1502c8c58b18656a70fafb9e6a89f84c740d3336cc49f63c2f91608368cd7dc7817a36e5e8c41e8a8bfb1b77caf2d1788be63cd754d6be74f3e468bd61e4044d72a130ea43f25ab07738a105799eeba387b5d4b7594e47a792d8010ab278ce1193bf9bee96cec4282fad1cd5b1948e9eac38d94728155d16950e99089fd579924a1e6676e166f25fb8bc4d96054f44b71cd4dc4f22120b73860b66febca1b726e40f99a8c2d7c2ae126f7d1f8a11eff68b5cbd3dd3dfe573303a2d3505a461abf9009cd49e58ef61c84deff91d103d4b1a5b78d33c1ea6121fa0e9ae5f3d2899c929c1ed032cb638e328a4f7cc995ca5ecce03db0353778d0c17fbca60a69d686905022e15947b597990cfecf04133c5843ec5624225668685ebccfa5e24532ca19f8232c99cefddabea719a98713e6dff2e20442958499b4ee7b03261721b65c6a2c4732de85949d3b782dd0e468fbbd5740edd2b01958196be589a81519d3b91945aff46371455279073036eabf7f11cee1df535966fd8df6ef868f0e1aa04d5cdbc1218da5d000880f99815a25f74343c991031eb856b35fb3b48ff7f9c0378fabb7eb00a65c20ca21f828e0f101003a25257217f8bf7355808a6ca23e293a38499482064a8a629b6ffcd340dbda5a7133174d38173885efcb76717a5ea21e33123204e7c553abc3dd3e29151c85edfb807f4321eaa76d4556928009380cc0540efba5433045cd6371eef80a0b0bd517a49117047d5ff72e42a98984607db81285aea6cf0df8fbc5e89db79ee6cd73086b8c39554ebf75f0a2e4c9edfd863c365967cf26901090222a346de63efda46d9a0717ca42fd56dc447e793eab48bd436e67b664ea44f388e07c790e006f1730e81c0471403fa4cc12ac22c9d00ab1218b4995254c384874175ced6b747d385567934e8644b8b404719c217592ea90f31df3c423778838e78b3626843c859c1d150a9df1ebe2fa033dadf167c218c076d56efa81e7b9fcdd29567da52b8c7cdefc48ac95755b555f9faf2b6db53b4ba0169d051d3ac04cae70709826d4227eeca717ccf5f190f4d7f557e028af3f06d49c251a25fb67609d98e6c0f3e663bbf9caaad381e0a89f586bdf121631232d483500a44bacb561a6c07c4c84e550b248095ec8098c7e367b8a555ad18ed1cd532450f35b3f16a5c0a27868f0aa506af35136e17d8c1ad3a0b83c7fb1b994dd9059a6b481770ea6b55978f30874a36bda62b7b77f4a3a4aa92e23c17be9959e647b64d28c94e4979e9632d88ddf188d908c13815fb24cdd2239d5eba7435f5ba8d2c09a2c0b8d65785d3a7a69dab9627d886d0d2958cc2bae6759b8e649e12e9669408faa37a660915df3dec3384a3a06de50eb8ac218a7c1e92aa1b359bf700306c87b91abfada04d72b584b9d27ca0e83f9657e3d4de5a80b5369530dd070b9d4ed4b776d35299e63dcef1fb2d4b0a818786f5cf5b032c6291de70c1cbc42dcf65839a35cfc942c2d0960130bd7cf8564a70b335810b4ef5ec79d0eab14909664157d9dc8ac962c2dc5bbe70bbca881dc9a9ce4f67e1df120527cd53b2ae85ded6591d9932817afac1f7371fd4af58b07b65b52496fc5e6f0010c627fef3f36ace970a02bc2a4e586ca3c69653e92e9b2c1b36c1106e77769cbef4bf9238fda43ec6a462fca894ee869a08893f700ef2ec8e38c3e8608fb85d225245e5329c9f6b0359e0e73d155ede5674684435c2ca1727f046e2368e091e5b3797fadc3107ee1720a96f5b4c19c7d26a304c0857783a27362fc26f7f8d4adaeacc1b67a730bb3745d336a60da85d18548aff2aa10b7b5b3b1699a6d2a3215f0c7d6694d9fda2750495c1d57e335514ca5875afdf7a1e0834e8f7d7c09fc411244c8b67e2501b317bf1907db0309268f6be7aea42b151656fe587538af960ed239f3da07bf272458cf0658789e08e6cbd7b159dc5b6aa2ba8afd301dca6f324e45e685b8d4431d8c268bd85592f5cbdc20db185511ff6a0d69705a47825b25f411d38683e0728da437a7a109e5fb6bbc0f412acaec2a12b3300ef6c67d31d50ec085d4def845938bfc17031bfb76ddb3e6113571b19cb3a69b1888ec21d083ca0dfd5246b52e852c1c16647caf393ddb287b721db9d08ec3ed656f89f7f3d2ef3a84cb9dc3cc5e0c1d092c683e1f83e914323f649581f9519e20acbdd1e456d8d482bb2cc34d5df15f082252dce1066016a120727095209c3501a1848f7b18d7b14ad54ca10ebec29c59da6dbdcdde011d9513222d32ae101e367279b9dba76bd41f0522c7be7b57a2b11751362bc1506a42bb19b049650408fb761359f983d6faf6aa667ebed39d73273d8faaaba83a550d4597a9c55eb94bd90cfd0f50b14f624db26d44882bc2d52c0a9a09129b9bcf11bf2c64ae68bbbab90beca67af6c984795dc2619f13f6e45d1868da580623ad5fdeafb2cc5da2e716b9996abb68a1d0dd13538e0531e88a0415eeddd4127bb9f2cd381d72ac04171fc67c9c81b402f089215c3d0bbb643ca983278f8a4eede1a3280d2552a5a67b46c4262c0b63bde6036907655e8decfa4ce48ad1c2924b52fa3af7534fecf254eaeb8156a67ad2067cf1c5cf3b355f8a8c2002e62746218d232c9b2852b39d839a094bd4bd6344a136e18152b47cb5684fe0c539b2f03f85119c902e180ffd43c9b80d7aa6359b58dd6740ad70cd4b3ab24bf6ec8d38aaf11fdb0ef9d2c613c08440e4425fea60824f2d540beb67b29b8deada3de247a69b1dfe81c25b157232550b64480007d8aed87f264454aeb88112f5ddb9d27d06aa26eed87fe2c1f7f05d726efb6ba2756e38b016dd9af33458773ae7bee5673c16ec2f0642532d3e8ec9169a56113fa6a42b4637090435c9773fd7363d32e78c6e5c1515dec64235b522fffa312c39db9b5de1f543d3833a339255a070938bbc10c64aa6b9a5765f5a33d2e6a2aa91b106cd5cacc350f9c8cb7d8f98cd33fc94e597375d96100c04baa79c8221726afa1bb770446cbf4219068b498c1b796d1f2a6874b45cf26b9387e8572387f42748ff643656ad131d27c1b248f3b1b4e6eb50fbb2071ec2ba0c87f315a7541f44f7db75b34819763f008d60cd964ddedca9d23a7b22cc30bdae5d82e03cfc2c36b6c3516577645c44dc8e83eaca3cf7994e6268d63e63f06d3f629fc4e9a7a45103cfe34ac8989139dfa2febc3dd051382ff709762390edcb50af1c6020a05db3da38ff4559b95d323af0e97caf500a4b7489c113307ca03c47a3c7151dcac6cf77ac51161b8ffa519425a33d35b42607ba212fb40821f229d45a64be2b7add73aacb15f356f4787340619620305f06fbc099ca101902393485db3470159f9ab2a8359f490e4e4b7a57189932252bc0c1ff2c6ed4c56b7116e7f92774178346dde65cec7544dc0e21ae3a8063347c3b515678825325fdb7058d044e1e1e7166809818305d2078603fccb526cca052c0e41bad5061dd471094e90d9854203771fbcc5c6f61f7cc917fd563c91df39085d1199b4ab38f963dab928cdf02a11b4658026fc9a0eac65cda65e471a9e27420db319788bd29bfdd679289f74256dd497421f55524bcedfa9ff829c24b375e3b019a3c970045c95cdcf4ca783d1cdf35d05728c66b08f297756571be45b842294338d4ea7a4b01332d370f4aa73d4ba8bf527d377a6cbb5758135630ee59c1ed22132dd8d43a429116ad9868644c26d138c40902ef5794588ca4a6e4ff2797f2ea4b314413f758c67069305c305a7061e969611b1132aacba16eb61489a13c9d14728294dfac0b42ca3cc0e53c5464e11f8701253474dfd1e1a664724f0c418993f006b380377dce03f295d48587f69fbeb7fa645de3493dd50084244b7825ae5bb7878f43778e08dd7b56405c1942640018e01e3d85ae5aa4f6d9f92dd9da7751d572d2693d46232bb4fb0eeecc137c64d8fabb2764bb134bd0e3c5659c92ea606ef49ee49234ec6d186dc35a6b539c662edb005daff6ddf08cc4cfdc9ee5250e7c8435fc536c991c5235f404fbce0d86e0de815727ccb2c83c4a2c1074679bf0ce70b196759059fd6cce2821b1b70b8f90f5ef90eca7a31d10b14a7b22230abe05e932d283f38194d592a849c19912c2e991150c1882fd5b4a081a5465c12c5846727dd1132bf378304fa26bd4af199e5ce866050b657aff2ad585c3ffccb9c1e9cb7aa396f361a845886efabd7e5a317fa08c4a55a412478e095df01d8b820399d5d2e96b9d818a4e7910d654efd455f3cceac4b52e45730eeb48b2a9434880cdae393a3cbdf40ca3f9b8af3ced3572d6be7e5ac49d016d6aa07e12d98e9f21f61695d51638ce37a58c886cbb7b009904cd0d08f37e8a878296c982e5db1f0c9d7c9a2c6cec5f547ea9dea7d801a1d9f72df77291e8aee96d0ca6c0a9af8608926757c315e8406f9fb1df1285681b0d6d02daa8e95d30c20efa519cce636a93cb4a371979244e996f61708a2419f0ae099f23c3d02c6e00109222365e48b22b67ce02747216d4e9f13d43dc8c1ecbf0b2b479dd1f08247a18b42a23b4b32b3689887f7db4168226e0c1d8d21cabf5ce83f128b0903068524579407625e487c0298296ab0abc56e7a8bf7fb681d4e5eded3b3a0dfbde03539f578c8554a0b3cf9e08db895aedef736ea05e38d74582ed0db7abf82c3699b6e0d438ab0e785672ecdd4439021805d2e31ed3fb8b8b5ef937ba1f12b270b4b6b19c89dec96104993ced5081caed2e4a2532100ddd773c129543df6a64df0ec2d3514a5d97cb725aa555fb8f2f70921d39e076934eedefda247598e01bf0620c3514303758218faeca44bf630b8a93c529643cf32a169c5636a3834526724c31abddcf95c463c8c96bd2dc2b46059ba52d92ce888ad99d5134925f3dc3755c0de4513074810b2ef1479c252d2c8a44d7d0aa92e850bf9dd76bc308a902584410bb779381e00a63977c4b03456f1e9184e672a8a9406d15d7aa576b9af5921631c8a551feb2d50710c39f913459f57c20a808f152266559d678c626842b0a5d921a0d00309e807439f1a3a02dbb19ab1165e6812966dfad086c4cc4b4a25cc0d87bb45ff5815d59663372eba184ab93053e90a81cde4556cd03c3343bb946472f6f4974b9545603ef46292cf6082e8c90a89ddbe5820d4b0118b0e8a750c00ce22e5e5b7a0b98391a3c3afe0e31302ccba9a83adf8e0de6fc8b52f385a3d4498518a5b07146f7c4703c07d36d6141d197abb87256c34e19cccd725065a38cca23fe7fac000203a38e0c70cfbb8d03e4ce54ee17f5f15d2f6797850da540e7ba6d7ea8791fa1f0a21072ce4ac5bad83f29589dd0c2d7ae86ad26358f8bcc5011712bc1911b761adaa1ed66fd903b5440f590df2b33ef9428070eb432901e79867374424694873397baaa55a8284aeb1536fb3bbba8d76ae4b955bfd3f290aaca64850a755e802656123ce1d47c13553ec78a01acd918698b0a69cf5f9bebf3cfc94d2b3463d4cd45603a4b4cda0b041d6452cdbbcfd96f8665128deee3a86cd3a4599577716704339d988a0c30a4caad61b9e680eb3935fb51bb70136ffa217ec2c1dc93a16b33eb2d8ff5c1f1abd334b010b98b8d22fdfbcbf92f568130768f7f7d82214b7b97771d7ec1dfd6023606186c730a414cd7bdc8427f1b7e8a8487390c91aa4dc8db8d6e46b34a2cb95cc5b30acb4ff0c56afa47fa5ce1cb2b7bad1a31496e5c81aecf41afbf15c8efb9a304621ed621821831626415dfdb0bc132d018b9edcf3510ad06be9579fcc312845f3806428195339e90d9f594055f06a7e0f074294e825c0aa794193668aebeeb04698acb802424dd3bd633c5cefe84acd59024db666b609a3820b573d1826fef1c59d2e3fabddd51b48abe01b2a06422b10dfed93f17efe17b28202e70cadd4217a2e9db0404683b28c0a8f1aaac7f0f9580ea9bb4f6916db813967648265f032c120dec5a446031351d0929449fd98bc7938d5ed718e8c59257f03d73f270a4995cae2ecc0c79c5ae16b6af02a37da6aa3211c29ed1e86b5045edeacd25faf92b5e0b5a4a671026fd65ac4ab9fec7f8d6d4ebecf0fa2e92b2b588d26b921e05dcb07fc3967bec4b615e04df24fb5d9d402816664b556567669508d711e7ae6587b43fd79334726664f21bb572392a7de4047b8628cc0334d8d27cbfe9744876779bf2cde50859ba09f73e2591b689a8af236e3cb8add6ff5f87bdd29760c3189d50265fdfe19f75185801d685e4957d840ea2b467d8b48815f7fb29cc05c6186e0bd9592ad36b115fef03cb61e6d2f7e8acf2430c41415bcdf48b2d7b912bfaabb44bd86a29dfba58201891ad72438d240dfd01f92346822777e76d705bf2577d2be41ff7bf74223b3e4ea2514576283a882577e626ab5bbe3534d28c20d979badb78137b8e5a29906414eef08e4f9c76c62701b9991ea5cd63125e0b4d57d6ec39a507cdbd032eaaf5717d25ead02191a1eda71092ca62bb2b96b35e0f021ae2c86028518cc1c2d9bfc35688768f1cf67096c08644d469bba6e7f4ddf42e19dd1c8f2415eaee3b092bf98ebabaf86d6476ba7869d477b3d4ec8861734e97ce10cc7e829f9f69d74ba170dac55d4a673a90f26f80d4da0b0e52963f544747cb50eba74f7020d118f541758075acd59dae2cf2e0f936be4ec3dd691ab0d56633292fbdc04140634b91bb5ca7b7adb7c29d06276f635830956a53518d25bde16e2526375eea673554680b9f1af007fffa7d4ef207b7c6cc29aa41bc2ad4c55cb4d788292a0c2e4933cbf9f1b7df4b65bb57ffe200f2b05f4638eba97b30eabd926e5eb007d6b70b43f924d2907c684a648407f1b7430ae0c0f8feab2ce02b0a80389096e130c760219f950524eb34da1987b04ee5589e1aaecea6d469fd29d68648d32a2eb89e66728fd98ccb3b82f29bd83c64ee4ba2291a7759b87b9adf54c6751715134736c6d5c5cf55ec73935dd9cecfb9eeead24a8a7523434e77e472b5f9a88071503584e969d3614eca365f139523d5a0a9ec246854fd6a790c94bb06b2d5ff5dd26dcc232e42d12ba9231e7c71e4229f85ed42aa7df8afd90e07fea3ba9d21179ac630f24b6e87ec7390e9a28cbf0cd6dd87253f26037ced895211b833b31dc4cbe7f36b224755e51c88597633108fa8e215fbda19b389d91ebc6639934a44e35d2ab6c3d6591cf460336fe3ce372c277baf6a5004d7182745729923e2b4adfda579abc3c177f8327f2724a9a6e94da2a3af52b8d108bd8498d212d5e240445d7cbf7dcffb1c0e1e43a85bd1ccaef3e9acc56d5a123426d93de77f618fb7db40bd40ae8bad0c842c75edef3c3d01ba56647832ad7cdf6f40bf2aeac8ec7e9e39be4b75864a6975f372a9368b727f83a8b7f4f9d76b2d28d8946eb72b9acbfd463fbc00a623c031d4decdea4812fdf7819de90945eb198020ba9b3085b2a43e874b4a7f24d84b89c9b8df313621e427dab0b2f864825dbcba957842a9d189c115dbe7bba7b85a5faf5ef6be74875f67f5ca5637bdc7b87f96ba17fa0a4f145ffd156d6d16c569ff2ca1b82183e4abfe83ef61d0e6f3bd2792bd05064f9117b57706b9a7cf7ca06acea597a4b706b47ddf0dac66c435d4d71a08bb29527933e0d07184f0552bbe0539415b06441d3e6fe7315a7f9479438dc112983d548969a2fccf92251f7d62487c68ed5265da4c1628f73ea95766a9942f4539823e6478f0beecc285fd43ae52fa448b99d206a9e6bbd9c8f1c7e2706bd328cceb4572aee861982c4e90e1d8b405d9370f51ba0ec7eb5788d081153318e746dcacf1ba67f66a33fcafd30cd8527da103be8315a9fc17e3ec58689e4ec0860c366aefb285fbe466861bcfcd1ce6e165b6fa002725837d4ffab659a26d672317d23de690a3f1c9f788445b91533220ad97069f0395f897bc15de9a8841ce454a00dffc9a6859e92d4b43656014321f1d2cf6f04ebec8895f4ed0c6218e7fd7e8f79f2a9a6f36954386cd45d6e44a1e34a4171a2e123e6bb705eafcc6b54bac5892ad6cd18184b67f6b2362ed376ec3517250dc89255a4a95c17c7542dabb41edb52af4b56fccc67061e2d61098a18861fedeef201c1139f3df26467cc8d8f947866a02db7fd718cb6b298c910ec449916e6e6335aa4b9585603a25852d34ca4fb471285d5f87a1299136cf436d40d7017c6ed972f99422fb2dce5ae5205bc9cf2d00f27c40227cbacbc14e0b10884de5678886e0372c625434475379228c8e35a9dcc9377c0147b51619f41dc716eda97a732d483bce47bfb95d487cead218ade63f52d128575465fa0b8f693f72c4ed2f9b72ac41d05b27060748309e92f18f7f139faec9ef94c137a68b785312a3c6f0e84fc385369ec9e53572655a7a7ed6d9cbf72e198c309ef8d10f6a485e416fd2972051a9080e2baeaf4fd45d3d4b6df117f6de58237d678932c2ddb87f3323a7bce2750e9c767ec410d6abb0d8eee552ece8aeed80aa946a50b8115159361291493f94821af956b8034aee8587df9fdebb6048929d05baf0b0c7c27e0f14f8e6b926acab62392402f14411752c554a239d0882a4162a72dc7670c2203edd058942109b177e4a469708746633d5af54481fce08c992a0466dc03e960bc69c55ecd676699960e6e4efc053fca8e297509848ca34acbe3857c50128d03de19647cf44866fc74d8f9f37c9d0a027a9d65d20d0c925243ed0c47fc29d7b34bdd62b3fe88e3edbf6cfa298436e2b5a54f240075a7c49469919f1ad7e1760e8cf6a99f73233ee285e541b9a7f06f0a9fa1d2cd9a7bdd823c5ede9d3d017ea8c09f618174abed51f46853e4fef5cf42fc42ef936aa4bef1c9773be2be552b4ed98edc3d64e9a53207857e8b5a3caa221ad9c10889d9581f1c241156144c29b6ad502842bdab519cf5e698a68360df5e6668a18788925779db38be4701c654b658e3b5e30a5011acdaa3d8e4d984e814e0ee25657672853f85579c255d01908da6d3a882d5fa6b59b633915ed8ad692b42d6a630157d081ebcbcd8b44b42ad7d9f4bb9e1149427458557847c4487bf393828f67fbee585b90cf71b1a8ac0126fcb712d6d97b14c73f01e1342bde878112d374eb4f485a7d2470010c894a2977d22986218d6ea22ec1aa0c6c4336191391f576894126e9b186fdae2224311ea47061e8e0421fb41951bb2dab0d680524a44a60733023fad68c20a3c132252fa0f1d084efee60444083ca7fab1a7162bbdee29874106fc4e8194e9bc0d240e21fe88cf53c4dd9dcc37a3507f7516eef566406be11002c1d65076494b4616926632fa0ce9864454f56158376bdfc78a34582d61e75501f5652bdaecf4bfb8c80784a6baaf6a695492870e96d44abef02e7066ba9537ebbd8b8a86f56b163b9071f2238263a18e48478ed878b77e78cfc96b414bca9c17340379408bc5364ad92d6086127e90da3f5203096b2ade9f46252f8f1c086b6efe6898425bf5d611baa70b12b7bad5f52ef7bb24a3d677b277d13a07a6bd52e27d6e13490ff73e628687e88ff49f48d1cb251bd97df19dfe26f4fdd277b9dd167e44522ed54ff3662eee52a11526d2d3e35558d24682eda5af8a05974f0229f634c61c5d78577bab97fc932ccc7f41de22334011d1727dd4d59d7232df308fae61cd2640dfeb651761e807982b2749b330d6c1a7bf23716fcb78f9786640a5dfd634ab5457baa6ee6a7ca2ea96ae9b04cd6aec142db1cb6e0cdb8d326801c0b8ab69e0f8c9f87e3714897b28a1997da168eb6d8f4698fdb3ec76c11df90e6118ce5bef0944b12f7f567b756816c6b7e99afb0d4b49d9c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
