<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7cf00265c29c67ee48204745f3d6b96acb326f4eab3f093d8d3630ce7d771fb0036665b7b6ed2f941e49799611a9d885d74ef04c7bbaea14bdbaf90ec432b490a356142a4d554115e16db4c7fc8e0cc73af598ab5b1cb05dbc4994d22fa46cc68174135789c7f725f7a9fc5f91c019b4a36f60a10ea5c466d6625c2ba9176319a609c1be8de82f1b514d1269e4f45685031a86d8e41951de5aa9cb1e53eec780a041ea2ab531a7f608670f6a6e19402616fdcbf95d693519c46456e1d65dd8fd578f2e181d8f6df019057cdc3dacd8c9733049726fb8aed2ff66a73e8517f3852d1c597153d141fc48c8784b5b15f050ef8cc83b18e65521be78f897409c9febe85db7da89c81d03713272d8d3ecb5aa9309064c3146b881a98303d2724f6653418077aca1bc882c3ca30075e97c0170ac1f74ad9d5300f81e945f141d728c6613050c49f44f7fff18124c9dfdc637ee7ec704b82af53088bb6c17b308372d2065020116af484ba37ead3ff032895754fa41f562a029a5c164e0f92ba29059e115274a0af17245b0b5150cd640b987296c2cf1cdf0b65c6bb62acbf6abca82e68137fad83df9b5b30097d67a2a2fc1d6470847ef7ffa5b97a8b89c09381731e9837b4f7158c14940f1a7717ce1ee0071c10d01ea3764b089a33de1574d807b425dd42a3db4d5d7710995c7b41a327ac5fe2c2c0b36ec994b40de394c213c69eb448e69a8d5cf377d3724f3be57bad139e0d73d10ea1aaf4a4ba29d81060f7615dc0aa01d788d2d6eedb5ca04602cc1d37d1a747fe6af1bf431d36278fb183170f5dfaeac190633ff79c61c45783d4910b107b15f224e17a1270db7e1b6368905f3e0f2661cf7ebb6082bad7ded15d92a485060b6ac08622537e35360fa1dbbcf40019a27cfeeaa386fe50d0ab990431178a5eacde3341f56ea37bc0a8c0d7c7d9b7d2b21d9483b95e46629471c723139e9b0726ea406a8b378d90f5f99aeb81b1806c93232ae60d09d04a29b2182376e5b3bc549888e8d710cfd147e8b00eb08aed5843d81a97019818d6c3d347d70cca46c1d704d678f2d16ebf8a72360cc7fe809bcad4e36e12b375a644612571bdb7b6a98756befe5d6515347b8b52dff843540e71337385e73e0a1fe20d41999ce3987aa454fa79ae69c2cd44eb919f0f4c795e3b8d8cf98ec111d65357f772cdb4d90c90496938265c960822580a1a4304cb96d0c6c627779cf3a987dfd81ffbdef02b0d27c3c5c3688c9ea7d0c8df49a67209df6bdb91865d8c3e23c9fac4eafebf0b97a80816556be767c31c8f3df118c141177500013033ef7572076deb0b679677170ff8d9904b7ff5d45097ef7ecfd87422aad8fe47419b067c75de69809cd4091e691daed9ff2b3832353b37ee4c8ec2aeb8dcbb9c55d0ba2a43589b16cc53afe532ea9f9157beba136161d5122ef9a69916f9c70104e1d1fdc26c1f1593e860c900273f68c053f6f10e5896d7bda2dce2d9859ce7c378747983e33e05029a53f4f4936989f466e7be5448ca548e3ea071170e4e3017e25f3c2d0d7f8ba08907885749373bfbfcda0b1e2c225c44b7979d594bfd28d7f4664005c14b55c427bffae9528bd71f30ea245dfa772f0d3e70448d9fc44b2190f2ba224bafc10aa3390c6708d087b091db248d2b0c6a1a1a8bcff1cad52123266eb6f30a236477f449bf38f3134acaf89d321275d9274d834214794d4e832093b20f1e94e1c8ac70d88800d8420983eeefba9d7b769e045c68dc160ef930710cb0f8ad43cd3dbeaee7bfbffeb7a6c62fc6c8d9a67eaa76d96dec452b05a6cf535edc96732dc04e25b767fbf5af96e4df4e335645a3a71fab213f6c439807772d9d7783dc0ab9d6eada8b9e0c2eea72205fd985b3728a14f8c7f8929ddcebb9b8a25711dc97eda9c8438b3b21bbf0f138d2342ad051f37fbb9e7f33d7a0c3349ca539686bb560bcaa486c6249deb04149065644cc3d249f1fe54cdc00a90beb2f5fff76faded8787cc0dd0521be123eb27452b5194d2fd7032a03986b509011567fafc300f85e1977fa2b82cf5b409eb0d955798c99034aa0968e743e487820df70b1c66d2ee84095cd2cdb96b2b2b239c4163718a22ab798fba513c9abf1dc9bd31e1baaca85274475803349601f7510ba7e9c055466ba05bab776dd93e32a924274f1a8c505e36f103a715a7c373668a37c10c8199df481d6c12fa8fab79a010b1b7e4500dec736764a00eeb055ecd0569e61c5eee567698a52d8389cafcf3d76744ef7dfc8fad5a3fe69c2a0a5d838de60d8bccbd112540061c5055c3cebce74f6517cbaa7e004efd677ef2e9eb8f95d007f5705fbb6291be6bcc58ce34bed4993a2439d66180aeec59494e66dea4cab1eedee37a0f579eccd6b6cee41fdae08556be54d091fc44db487b568ac129da275ab96c096601d13831fa85e524ad1a8381071321379cbf3c2bbc732803d86751608647c2be8636ec67750cc064a752481f92f65b1d46704cb48a525efce2f9480d933d640a1180ef6604ecf196eaa17e6cbe2dab26d8b90d08efe95e04aa0719c70ff1bb8df2e1b10052b0ea60d2b18c000464e6afd0a82dd97354b605ac8b114ae3c327d86d78108b3bcb22303d5b036135a97cae00688104d3ecbcbe2ea6f0939d3e30f41bbe8340c30b3be27a28b389991e8648e7db49e4879333325048eb90b5eeae1dd639d8dbbb4dcea3c986c4eaa444192c57965aae9ab0d328e1ef3bfbb0723ae3145ff64f9a150f1cd25c76cb754ec27f3882ed94d3034927967aa4d55446e7a9310897c4ad708da4370269745367f151c413ca08d7b9406ab9151bc5e56550cd2270d7bbc48e0eb16808e83a432efc235759cc1b45b58323abbf38cd1d0f48a6f47907cd2199d2feebe5a2fb6cfc34c7e29668349a7468029e76e076533b3dc53834294f62af0a1ea09a3e5b9af4c178e8734d598cf4761427533dfd437529bf01a99b9d6aa405c911eef42910f51ae1d3f32fa759be863352cde3ba3a42823e07c28ee257da12018bd72d014fab2fcc2d074f68ba4645103a9a79adeaac9e61f544bf7dce0f45aceac35c03de96377d425200d0fc2d23475c486081797dd7a521218206323a377cd13c95d6e0e99626d8392d1980a0dbc96a03ebdc3b29fb8db381e29cb509aaa8e88803913d3ec4502da65f413685df3ca8527029dedbc61669c82a93c8bc6ea80b7e74645b37b231ecf8b7734ebfbd3ec2da1c59c4dddad6f2a45cbd201815d8e89ec023b678715d07b0588a0b7ae259c1e2c1d344ca182d3d1766282e0e99f789d894c5703d6ea615cff36601a7c9605ef51c2b4c1fcff8ab3e28d46dfc4de3227e39070717d65c222f9bb3ea96a42865b61092c6b3802475efdd15c49429e803002d950936ae4fd485c61f1f4b4e4e445949428030102ee24ee057c95b1fdf513a6424cf8232e330f17e4af98196e973eba886d478d85251f5cf1b956085678812e9880fd83aaa8f259ac07c1c576ced70f753d5409b2165477043b0c69f93b0f448932cb031bdce1d0d06f6bede2a51394abe36a4dbab380161ee9369acf83ffee91654b1bac589a30513b27662a122ffda860f3a3724cc0686bcaf0bcc817f796ed7be5b35ba062b5e33093bd6d255a81ee0d0030f7768a6c887dd4f4c60559907dbe0919226ddb5b185ad8c062f8985583849021a00bbdf10192a3cfe91cfddc1859a35511d35a2a34a221f987e98f087ee7f341adceec8fc28161bd0600bf768f75324f21d93b262042727a77904b5b70fa20cc192977a76c645c29c629270dacb763532ec15edd513a20bb928fc9b52e9aa3282f2d281159415e968bd5d1613ca69cf492d9948a796402aadc47680c933a1e06bfd3db1a1b841229b69ea860bdb1765e22b8d7944cae5b9e23210802a3effbfc4863d62810884b8bf0c7c9ecd46f534e6b33a6161ea3c5666a3c43c9d19e5bd89d12fa9b60903f1cff4d094944afae6986e3fa3a80c2a7051d18cdd75bf1763af7b2a94647fd46e63678ca56c8014d2816db0f31d053fb28c6ffbf3a08c43adb57e5f7dc3a15c4aa90902022709722d78a1bc742f4ce5484d4cb8aff472ee568d599e32716fafbc12fcc39b6638cea7f84219f50efd67459e3246cbea5ceb76c7e0c3d07058eb5b7f2a7980390ae1353dfa93f5b4e00093b5dcd44247583b2742b2c225b6208c8f47a6ef85957c86314aaff6b13e6b6d37f65c42495bd306bf101b088b797f197a6d22de8c823d72abcd40fa5bf515380db97a2119ec6a6a12fb991b8cc51ceca65146d795f51d77f5966c9e924daee339a65db5c8c1d2dce8f2e267c8e31d0713915536f596141dea6a2b6c73268704fe28d070193defeb6a228ab81fe7b4b29e35ea52ef44a5f210f277aa583ce13e7bee21da29a177295c097dafacb98ce25bf79e2cd7f4b9f68fce725fea2efd5d9c6e8b545b324fd7cb66ca342d120e00386bf3f37f55ded35120cd06834bbcd6b9deccb927ad438f9d7a98bc3b1bddef2433c639af7b5b041f73fe4acf869a68ae324d5e1503cad9bd6254407bd6485610ed1eead61905b247b71a2ff89b9a102a5266ff545e001a6b38527b695f6319f5f2249e80f6ecb00ea684e1cbc7e9aa8d3010bc417e75b08dde2bec8032464be34cd3fc3ad1dd6bb683d17601fc8b8bba0cb94770fb3f7ca549958ccfbaab8c2aa57d7a493893f5c5b8223fbfb6e3591d4413f6e569b2decd6a042c465357f28aeb97809dfa43954c72bc99619aa2911b603ca61db0de05f3f252588ece557de39684803c3e585a35362c84a0f0576419294db06ab86151c5af335dd476345e8329ca1793f05b57218aa496d4ddccf211882f15637256a4014ecb771765276997ec0acb17a0f85af52b907c72775fd19e10f969aab74aa080ef6e778327536254c1624e1887ab0ff00cd1d6768aeb9726c29ec6e788f15fec67443033068e9cc687dee2dcfc69cba2d6ff86152d5fed20142d2144f4ed34ec73ad45945a7babe3f0174591ac8aa5c95edb2f457c19eb8a95abd095cc3e973b14a4c33132d3f095f909300f2672caedbfdbb25b6fc93ed3db1f12dd260a93977b4ef349c3c0c7ae18d7b62d9180e1279987dff14b22579e75e75dd1b10b174aaeb26be7f2fb6a31df4ce4a4c6db786b13a8d90e2efd1cc1c88f3ef1c83e7c68024c91ffb06dfe1e2361ef9248d91ca648a4e4c4de005d8b0f7ac7a9b921be60ddc69f276911f5f658177774983a5a70db9af5b562ea3f5d261f4f561c0c8e6fb792868604b4defa1645ec57f8aacec4eb5cce826f7e4eff50a04193d3982b804ca61ce5f228d8fb2d0e31f7e306c5b0fbf4adc39ceac0f3b484fd384c9bbf531b88d0f62f6c83ad4a83561abfd746814fdcc0965b0c08372e0a931283d5a642065926fad8e7a121331aa67dc1f1185f945b1439b3a9d4b6fd163e319b4d5c5afa6bec49eefccbda59e71f8432db67df9894037ceef6647105bcfdc776839f44e62ef2915745619e33b1227fec62af9267f2d9efb61cbe98d8528942d545de0aed6d413ebc1573e874066e4a9b0c41dcf13d4f3ff7cf9f5557ee776ac967e6ca7ed3ac4a8bfa4bf336ae9c208a2976653ddf8be460bab5d278f7f3946234217ad0f6675df7c0ff1b9e2a904b2f6420c22190ecf8f669797ee6f4227f4a1aaffa53fea4b3d8b2190431d8fbff8fb8c0f13490c71f3a21776a17fd5376f42d58c579d501f8c067fbce512ab58726717b419972c46845dca3173660d48a54ebaf7e7febe2100843d441f439d1dd950d5df5723a50994f5b64c71b7720de9405d68c1d177639b6036a868290ed3c14a863f12a4a19e51e7494b3d1046115227e9bb0c08ed8ef0377cadbf0946551993b74978a96749f4ebeb5e0fd4f147bbaff48831a3bd106bfe656d2d0782373dbc3156de23bf5cec57ed2c13f8a8bfe303a8ef2f40da5b1c165facae6ac7cb7dd0e370a9cac37f237c3eab5c0e0792b82cf6d3b25ab2588131a825bb535e2221a65e732f7829bb2dec6bdba3bee5e3e1138a67b952314aba291f8f6320f79c0c729fcda7488d950b5a0de2ca397192b8c9425e22d34df6bfae947765d31135a4beaf5fb39c760fac2557cb79ed6d211de7b3cbeb2e3e6bb5f10715b840a72742e5b76b1dd5be92fab7b2244df18e93ef1bc8648974327fae73f2709c6ef6049fe98de13f2a511c6cdc83f556edaa8f2515f68dc351bb23b7125413370aae393e04f7ef88160aeb055fc2ab799640e73f7f0de4f0dd4f4152285801f85ebf7a93241d2007d03c8f3234c31dab0bed56e5758886d3c77b45b74f4aa012a5d69ede13d99796cee08c41443acba44dc915198f18ea98a23f72b33416241760f95531b27ea934aab13f61793d9477a074d587767c960f7ccf9005492f0197a1ef402d7e031376ea174a5ee52518754b14f8ed6ec21da6b46c7ba62c2480dd5410b14704fb71172115323c6a14331fd64b19e93b29f283d1843b007c48d99a3bef5645f850855cc915861613980a3eb9e79aea4f490cc3c92d926677b4479f645b83035a95c85f3689d5c26b59c5d596837fd7a75784ca9de454ec0cf1db5c7a47cce69a7d47fa34613d9bc2d70d1ff4c7ebdfe08b11a2f79fe93895d2cd6bbbd693927c6f34c0d2eff194f7194dd342a80632d00a8671b7cd4a23d9642bb4e433a6078846fe8d00e36d3a367ebaadde572eced45f5d6e7a67a32e59424f5c6abda9fb081dad40f0a25f9cfb34095f77b6d9cbd58240f6cfd1274e96a5ac55192e8240a14dd184fdb13b81e16a079d7deb6190b277306c0fcac8d069eb11a18b178e73704adb4fb9788845c838d91ce2f0118465c67e2c530a4b04652e37ac0e06da08abe6320ecf08c502b1da276831c8ef9b9eb79bbb64d6d30337e503fa2f383a41f271849be3abd7c9ae4ede1decfed9bf96cde4e356575d3579653e3ea0212c8e6a5d759a8657adb3330b1f49215820d43b034c67c7b0c88f70b5a85e1c8acda2f42964d5b6a8c82062271eea334274731a18119751049ec1977fa2152db49ed5becb14c803dab82a5e7ba68ce13e537d62a07cf03d851439103c4ae02e5790c47f7cc6b9bc90df725c8084da24672dffe44c72b32fb4c8d4a397b3da108eeda7e11b655f7a5824ba4162601127c8af48d3efd9bf74161b8cdd2d89a811b0ba4a2135be285e03206a7390fa56a908a6db19b02836140631616670601b9526da2d5788045ecc2d8e6957ee053e3020166bda66ed5f710ebc7d7237d0f126de3f0cfba502311bbf09dc2a19c491eca5d321b75ec1a220374459f1a857d8d66ad78b994f2506add7e076965b79b459414ccb7830486031de70d293dc3717b342850e497e106321755e357515fbda9357b0a94143e3ae10120bf6d918fee4eda2a6300df638f6d1126115a8eb9c2509842091f84060659dd481d4548d2ac6421476e8f7627d4581b7cf7ed8035fb9404e27263c24be88b46c0313970c6fbb891f65b667227ac890364a7fc1f577df70773d47f1ce15c8e9c68683c5b1fb18de7c4c0eda80878036779ca5e92f7863ae276d35653f49b86867c501c7a38bfdcfb72d1c1051ae05786cd999c2b1182ed4ba6d6516ad738a050002eb34460788999463155bec0b407a34bbd11ab9e39ebd9e51fe1458ff1b1596f9ac6dfc452ce0fca9326364c039f82341641460b80c72eedb82cefb250a39ef3128315ab11a210c4c145f8ffea8e4100d564fc1432726f42dbae463dc3b44fde93444125f39642b4a155ae775c1decc4c7a84c96901e4aa806810b87918d205aa5f26b05cd9373b94321036007f9c6de65fda8a79acef6267fa257568f91dd38d529f6661f1ae9617ab68ffa2264c2c3b889fc2885e14efdcf37fcabf1f299613019575b02050b3292f412ffa0ddf0e781588152891a319b6d50fef39384483557302d85b16f371131ddb3e1b970add512e7ffaad77c0d86cbd1bbc054c7faf620164cd18de14c56d96d6876aa8b2aa8fa7d86d8e53cd1958db1fea72d9f3d1cfa2072cb6e5180d86eac5e572ac78ebcde992090839884bb7d705ec24895297d10fd6d556b6063e06d5781d77f20965f10c249697d3ad0958da2ad6f14910f18011ba4e1d49b77d412c2487293d2f7dd7b6af6271a7def20fc97428c459184e956af232b22c58039f37bc793e4ad3102a1e27b33f4b33b51e56218c16d2628bafdc996c55b88411e7e1ae235f72c3919783ae44062ea5b66bd9f47d643a8ee0101b48ed55b26199c43e38e9f05dcbd1b295c3efab73cb2d5d822fd3f2611252ffb94d823a66f15c950d646a9eb4efa0a9a42b87c4965761d9ebd0b338cada26840811933706a48add96c96b22845c2f3b7a8663c2208f7b47e064167f19f5a0e2a2ae9293c86111b43e8364becb35b76bede527e0bf38bde1af91bc0d4be6180129b6f5e24087111287f41f3b391579ba5561f404b6e19c1738d08d51bfb79aa8f543bad7e5fd1cd6f13fb9698fea8de4d5823d9b6d4faf0ca29897477b049e6c2b7dfbb3be179d59eac44e119ecd37ae506f03f904b3f596c7c9bd497bc2fbe491cd9cc8e0bb077ef364edb71d1451077e0853cc552178c0e07cb51c830b1b0b28db583f8fcdcabcbc106c0815905106439ca5d281ea5f5677ee55f89e81fd595a288debfdd12678db6c8aaa5da0803ab61c0b8f56c16adf5a4fe27c391f9a4083735509be836aeed2e6e8da80bd4cd3b584fca43c621b7c0ef1121f10b8cba629ad105646cd725b63dce575f5e80a6ced708816739b90bbe8f0593753ad2fe3f1983661928d9fe3fbcedca7e5ff0a2217f4ce35e44a90f914fa91332bd67f558abbd2f3aa747daf4ed8f3f407dd665d86b194e5f566828cd431b5dddb40e56d79df56158d693032f06fbd514978410f604974914d2a1d3735ccebe9f9422e8dac38cb40e0a10012a45b78491ea2e0be86142ba0f3ca63805f03d4f40dfd8713b19d9a21ae7afa8587f5a3050db0282e3a2ad6946628472c28b4ee4398b7cb644eba3d2e97e3c3d49365736e5230e968418a49c2ab3e968061cf8e53fa3a906b5f62777a04b0ca096ab050d27e2befc61da8c51cc465a3c7397fa18257679861bdc4901c4696a0a98f2d6bd2cf0ddad9145c24742a07c44e0a15b228646fbf034e13869766e4f428ed75a40cf4d8d1a615a63c1510fda094ef33c6a1c392bb68925dca5510cfc4305b9c72d9b47b2e59ff9c1000dc600035ed394a6bd202b9a13d44e30a2f2a6935f38feeffc5de8c32ca5c5aae16f4b0d04ed974295362f3338a21e4eb7b94079d9a1b6dc4ebe5a3d562a8b15d56af8a340587bb12fe5e6811f08a401c0f897a2b996522a6fe3ecb0fccd1f265f43265782874cb91cbf14ece53911da8f7bfc71ab841381c914404be36f5a92cfc2d293a499226926abb67bc2999ccfb4ac7aaf18f84df182c388a5c93e57e37455d4b18f091ef7f83fc85cba97a5e8aa6773f167214ffd454d0cfb7d0287380908478a0a2d5bd4959b1522b72f8051307fc0b7c8323f8f962fa2656f1d064c281d1a82254b1da8db93cda3b50ecbf6120f7f8ff1c03c74dff604510b3d9cae12f49bb8ab3451b0c19d7ed58518b905b91eaf1234913a66e1ee74daba440312975cacbfd1fb069457bb48b54b0c2d65c954ae76ee51a04931453b904059f7912e27f18de81aa51b237ee58bac5441a57f00a27c420078c3b2e58020c7908ab98c406d361fb53a23bc7dd8021065f8ab2a6411670dc9de77d8686640140ea6da4faf0f0ee2fe4214e63379737d146c4a5180db09471ef4448d13a24595b925a479f4484a86bdd27e6ab961feb1a32a618f3cdab4e5309904e57188e0c6086c1297e7a01fa0c71bf89b0bd639f9601a6c6c5a7eac14726c6a08947788a7c7cb83d3ea1a596211e66233a757e443b97a68c9c00d4d66554d3f066d5c107a15f025bce08a4a17c583ab42654178428774d3660a28e63c05ae6229145dec988910da36a8e2b198e0a6628d751128d05c1039b2a25e8104c90f1c67b3f66ddc272e457a9b35ad7f0b22175e6b3d0e0de86e8d3b1ee657697c323d36f380374b9f591105f38810dc8430d7537a78cadda7710630c67cf19a8f449779e5def12e0e3f20bbed67602ae118abff809fea8182a590be367167cb1ded4de690d1e8eda547b9e20d049c021f1af79fc2a2998a434c4b470412cf3e3c024dbc53b30b414ac21a484d741e03ddaede07d62df43dc4d729a4d4ca1bb738769d7c04d7516de4baf9a3b327091ec129e412b80580c78131246f8bb2ce8bba31150aa9a91c37d25303b014cc44beebb4e52205ef65ef779d95cfbc2dae32e1065927d2467b585857098960836ee1fb0a4ea9e4a3e6c231722d569e93f3020ae21f7d539ee8847a9d66b11b044f88ab84a39b420d49baee0443db3201804d7ddb02aadc9dc403d8bb72f2c8d9da3396b0eeeb02998290a27bce21b6f2dfb0ea428595884f95039010223f4a91677630632c2e77aebedff11b184eaa325e5fb06bf1ed99b36fe7d45fe56ecb93fa124df935de6b073c8b4b9b605d4ef040c527a16ac3107bb75431acf2f1950a039ccc7dbe80951b93033f1a7fea23627ecc5805e74a3d411802d43acccfa93d563dae843afe8889fc46ea2ef73bef9bdff3e0e3da1901e6aed348e85a2288f02769c3f36d796de4dc141d6f5a762944940748d53e3e6e83f6736b332ded28a665c7e47eedfbb1468a4b7b94eb80994acc88b08f67db8dc88108c6af777125311f59d008bece3f2c0de57c3a59eca2aae15a9b7df64f158302120123d202506c088f3de4614bcb42b4f01cda4ee4e1c50ea108da58b48948297c1ae33147cf113acba28bac9827e61b4f629d81a567aa52abdafe816e2f2d7e19f44fff7515df21bf9a5d69ed5a7308f7f8f94f3e4bcc791823765ad7ad5af69acc365f85bba5b87c74d7b983b0a324d0d71ce88b1ed2586c87bf80f151a8e8e1c25163eac9fbdfd3b499f8f63b1def678d86d6067e52e6e1963d54efda50b0fc530536ed81c38692e39f6befea4dc86204e0fd410549ab2351bf20ff47a47a46a341a7f4681da5d71969511f9ed08237a1af00016852e39c0e0593290c74a3935d695dd484387b0475e32e7732f6f117887c7aa559f653595c8a35d8aefcf803bb4a29649e6d75e0aa4eb4abaffb24bd0a4779598ff63a145d51a0c2469659da4d59a8baa793a12f14caa027490441e5511f0a4bb4d45d9e9e34a8390e3313f3bd10d125116097a3f1202592a9c9b5f5b5d3bb97e72e0198a1ddee6210b38fcdf2e39287e10c54d5349b6aa9672da24468b1908ef7b21127d87f6c15f9eecaec10922b9f2ac6ab8030ac6ec133c53efb63b44b49974afa450ae8e4ea9630428362b329f94fa3b4503867418eb94d1c34883960d28161284f6020ed93c1299840a9e19f5bb39a4557c24ac2c2f72c7252ac9cdfbf085afc64b25de5950f42e040754149bb39fe83559e96c05ab1cd213ddf70ee7270567478bfbb565dde30f49fcc58ee31831691e45eb09a3f4b7dcb8e4928961a76930bd1d7369f86deafe399213bf7f2de09f59e0f390b6ef29d69c2e273a342946a8b0c84f6fc20c991b479dd9efd87aafdecb6eb4ba3dc9addd9df67ceebc73157b4030ca01f4d16683fa59c95af2774d3fc58a0908c26596c593ad5db3bb35ec949eaf5d2779a1d878a94dd9bd8dd0be3079b064138746d6531349f431d81c17112f2615916a3952484709b7dade46d7668ade2bebb62b718853f78a6928f709b7fc2653842d6ccc32f2e14fc8c250014d20c3ba42ec619cf4896dbcc3a8a80e19804a08f0ead28e6f0bcbbe27bdad6819c3a65b8827af2130880f3db570aab9b1956cb12ee7f1f882b07eaea48c64d31108b9c88f81ee8dd158d83aac380a2f7c776d3a93c70979e88b05e84d8656ea999b17c76fec187f96c0fcf6ec930e35772b88e2156e4605cf95816418002c4ccff360ddf4adb9ecd0de7cfd3aafa1cee9cc6936e58f62de04708776103614f026a95b42f66c3032621e0bcddf1badc479f005d2a4e9bd85f6485d260d262685ff774fdfc6025c4cd5452f63a6f8fc0863590d44bbfc6d4fbd97068c5b86e2e00e3d482e8e8f25d96ce0377e5c575ebec98f38cfb134c9e0ef506d80719740a52b6352884921ccd994ebce989c0027d5b1df7db5523c70d53a32db15e5437bc2afa0de3b9dd5df855c56885af485ff6e45e2cec883ab714e41662d1bfd996ce9ab1c8338bf013d6c7255b7bafda9f81356e02e6ea93244337e4cba103f272fbb9f1b13992829a00620ef4690ac88d83c16fa67bb3d19a2c747bddb7b1acb2ca1d5f6f03a1d2734c7685ec152a4c3bf26d15fbe555a9a1e9f29630c3df96a1441cf2516c2911a1c8e1bd3ca7b2d85a778ce50d15ff36c45d7620a313246bd46d724b4ec37656b0be9078fc42a98488e70b8cb3a8c0a28f75694d1888991d7b320259302dbab2f04800","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
