<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cfc7d4b18bacf51bec4d827accbbbff052d867ee7e9520b19af60b24b228315f1db706db3d3652a9073d5c643879d0fb841e1e3d71936f9e8d82adae37d7fe047d1375c024a0ffc3cdf7fd64e6b687caf3066f03f676765bd081089b3e00ed7cef09bdcf848743802c42ec855dd7212e6e7aa7f47a057265d8967b939325a58679bd10b4382f2765de33574a2da00cbe48ced68502c62a3d36cc779af1bc1b84dbf939615901e22b496311f8bad67cf5b42eadca88da80eccba1fb2803b9aa22038df96349e9a0b553bba4f50f2bd77445dd705750a2016aae4e72de3a4233bb176f734348a2ce783eeea45ec1409fc67b45a292b4eb8b4c50fff3470ac9e2e48bfacdf870e67fc7e3ba29383f24401c404c924e2ab8106f3227eaf9c643d91d43c17513341683cc42ac8e3ee4cb8d6d26ea2c8a13831a48f19096bbb6d18216ecb7b754440bb51869e3187e0d1b527350c5059e3e611d5a47852a3dfb186304a188e9dcdd3fcab198bc80c4b1e4c35fdf8f15828cc3a28ecade5b363420f4459ba8672757b2a6bf776b8f895a0dc209bbc67d9d7b401dc95224d03219a761e918333666cdbda2754d74d8bbce892e405a9fe43b67d98dbad189b1dfe1402170ff4646c6a3413c3bca17c81c9cdc176024786b2d3aa66f421cf764f045604f948ad0c7c3a397e4471166bc45cd4d57904f25989a9426dd82def7d171206bd13333d2c4a18d0c3ca83276784faf59a171525ccbd353d97bd51e68666e96f53df0c780aa2672b7a0bbee6471d79e3d9cb1db22bb2a2860f9f25610110b73466166cf4e174cb4cbf59fba09f9eb1a46e5abe57233c60440ddb0376fa2e24749bfbf91b408b76c821939231d8ec79e652f09e8608943f6f1cddb160b2c83cbb05f5e13677483ef8c72337100bfedb5d1e29a13389aba50a9f07b615e37476985d2ee347a1616fe2ddc675b6ce88696282506afb49c353da47ed6a1c91ea1f397125d93be4f0f85484b3ce657bff939927692de0f213fb0becf012aa5b8b03e41f47a4365c94ffcccc70b53268f3a1d20c766df2d2ead19a53177c313730d6463537f503383dabd06259f93d77258d272b5610b23b81b68c52184c8f375a14d59bbf51cb85b04d0ad28dfed30b1c92444bab526a03c41a109a7ea18565a63cdf75260673cebf8ba87a9a4441db8604837cca8c5bed18c0f6c231b21cdd97f129a76075170ce0a885df034d89ede4ec6133558824ce92a5626bf323137dbbf12b19aa7bfcd2f622e105f86552654f88b1039bcede3e0417c3f87a8410c161a46c97b85025f56282da391d9894410b90837750c0b01f02a230b20e4eb1227e8df906979680fc6892bf99778a78a7cacacf5262a5f3ab2875f6f25e4000ccb4a88068db5dd1a16d69b959397b49b6c04ce66d43c1612a05247c3292436cc9f8b21560c2d2af429e78c52c9535bbd8e87996a7258ff6eb0a47628b164dc7d4defeac7655369060a76a07b374dc0316640c2c8071f6ad747417d93ac80739dcf6e7f861324b1c2f5e857dd677193444be0c9cd8f9fef7ddeabfd5a74f72ffedaef0b5cabcd1f93dd80bd7f5d583fd0dd2fd2c79d574231e44f5ceb7203fc4e731ccc1cabc5b575c676ec6d6bd82febb143cfb30f0be796b69e83de916e0fbd61069ba78dfe72c58219eaad16911c432af6c4c893d05afd07befac3fb364575eeabac1ebb4fd792dc8f3df6804c67649f2170369497778a2e03a8553cab03cfeb26ab789272279492ad8e16a3859ea5c52cc6b669f4912abb04240029468f726b0d1a8ef9008fed04f62611d46c785000c8ef26f52752f99b85df6d8046e85923c6d3f8dc293f0acdc21400c937e8be49f94abc6380e4288cfb18beebdd3a1db74faabd68920fdb2269122be38a2b9a4fed3babae337c45153eb4954d8854616a116eb483af3f8c25885cb24521e69bc28861f5a215834fd194d5685004b3cc5a464fd8ce16adee76e9874c4e6df8132c19597388f39047c7295a93cfd03177e5eb126ec17b01058d5d269327e37df8bab95baa4bc92636350ccb622314eea863fd9f6253900a3ad7ad69dd901d4834f38eb82e0d0f059c3721314028377479e53645a5f871d37f14fa8798384f004f361e618f9ebe2fd50f66a4c075bc0308caddf7cb0582ff84e7fc4195cc656cde245ff0564bc9228614927d1fcdaf4b9037a5a372ff907f05bdf36be9c68e69278a7af64aadbcc98724ed602c1f07b442539200334832bce2b58abd9b0221ac4740296ff3a535b850d5dc5f5a832ae4a203733e404acdfd5ef3ba0e739de11391b204e2bbfff107bbb663e2f19147e53aea2f757116862d4a095e08f7f999a30bafd73f08ea903fc5efc94f18067d439d27b9ec4bed4be29f5b27bf8ade9824a267d89aab4e42b7ac4a57640d6e9760334f23534469520195140303f64b278bd2a302f9307d03df6791cfb233b3ce357594cb3979e1c4f8675cd1368455e8d06785c5f51998e5f20916a3153925456a6a639dcebcb53e6460d03186b2d5619c060df9908b6448f05481869451fd5621c33e7123063f78e9b4a17c27cd9a4f95a02a6e1f2b0cd606c0876d25bd9ec72ba200abe4ee692eaa2e2a118a964a2e21b86da503110dfe7445be7acddbed970bb4810c33f87b62bae70b4ffb523a5b0191acc36e1eafbcc13bec3c88852da8b7ae4bb13d7caab6449d4a6444cd7c09ec6a78a69ec48069a32e13eee2c3a38a404234b5b028282079b7c040855915dff3934ebf384942d441838722ea3d524c2018d8cddf6e55de16c9eec8fd2fe78d50ba86785beba6c78d7904c516baf0f554b0e4febc2392fcc9a29916f9b7581298489751dfe4070419542c9bc4cb56febc23c30b87e4fa456eec87bdf462b0608ff826a10cc70c2e5d8b5470da91a9831b3b8f157e543a7d31c7012d495878793218e9a4aaf10e72091b76071c592a0ca991b8048003c2d6fe776674f07181d2882ddf3c3cc05903bc08eaa9997c5a305ed7146f7afb2ea02b972d7fd90edb086664bb151c02087c4d264d066a7f7c1e88521eb1f90a6e4811ef84468393ce2d864f977faa3bc0955163dc0f54ca66fba87576d4d231cfd9125d918b9682e4e52673f6b9b4147cf7634bd447273b9d9c4a510056c3324f3294e212324ccf2194edce993d23968067aee85da6596b5e826c83c8e6388d9a1fd0f05ee180966d03c6c9efc5c9573dfadc1508c81288e17252a0bb0c6b1978c5ba6a6ce0351f7fd14e305efcc7b7cf8ffcfe86280fa84c19dbcf709df39070e1400837dbb0267797fc5cddf99eaa93423f7f7fe817ecb0b6dcca459e267b5af003cdd10cf30a830f896393956cb150fc864a2a1e20db41d8c1b9639f185851779cc90f758229fe65622d5cabd0f8bcbc512da29acad4667a596f07efbfcce38d42859c9d88b71e0e82dd1d60590b1bd264406fab4225ca56a0c3a060a263b63172356f4ca441cf1fc33503cc188d118f4adb4a8237faa5a81a7c2b6dbd731f281324afd8f3ab6547514d1eaa635b60a02498ff9e5d21aa1fbb2105ff4e33387f253862c41b327ebd55440ea82cb7600874641a7013cc48239b00147aab1d9475cd2b867111d5eeae4a7ccef3094f616fcbf0b1e1d6a09b7188f6c04b8a09251761e25ad476584801e9b5a4c47db747442b93eb14dbbf09005564a7296addbd2f8ecf9c28837f1ff893ae573ac3f31c79877a70824e5702e902b7b72478b0046b3272ac12b78570a3e2a6719826ea0bf331ef06c9b516960243fbb90d6bd2918d660d9222300dfb34670dcec9354d4f066177974aa4e4f018105993a1d83d5fa880f5e05611c4c643c8752606027b55187455429f847c1d7f312c021a0320a9a51e0fe11059580eb7560acc77641ef1a1fed226591c4907dc002b2e2a4ad5cc95f1eb3eb4a2b52211b5a367d10ebec9eead549c700d438dd258f3a29a072199ff5a96282641a6ca8b39370d947c55305ebc98bd3f0931fd6035836f28a25da0897f8a0da2a4806a6a5d18c3dfddcf8d0d4e39fd9eff623a992919a825895e69ba1a1cb7112bf8e3d8b43b81e3c174db2ce5e881156a68d6091b69591de42aa24dbe26aa3e470d7e09a737f5bea09f544e0cf06223fa31d24990df4d30193b2170c2b9c2b499411aa7c2a2103d77154509858920ee8b4b70e7140bb65e37daed5026f63e18b5b13c2f9d1e523aa4775012026e12fc36031a2755ab9b298f24d0e1092308b36e4c41cb7bfddfa296bc5f477f09e4336c6099b41d864c633b779b0eea156849a83c5746d511ef5f2e1d6c49745b2dfcab6852941fb33735abb2243394f8bb1fe14217101c43d430b7c46680f8a8335f27fd70b5d5124e71f406b3b4c007bca9ad98448e4fac78e06fc9866fe96dc06d6a492d4f96346996c715a62f17e9f822d9b826d9a8d85247d447cc2e8ebf6a1bf44df90f59529db13b42283d68f11e80310e61b99c62427f7f57978b4817f3d9dfa1e202f9c7ccd1fe54be7847f8c7e57b98285e7caca4789a34234ab127965cc57677d87b0f6c3a4be490e7e15e4fd08d8cc7102426893b60d1784b0d342674118fc5e0e1e96ce69b2913eb78988703f5f9dcc1dccb348c25e0107309a0f783d21970e164edfd242fa58c7a9fed11640c2cfbca7a5f618368fcfd729f90d78ba4db0348c1f1726002ae569b469b718ed36eb6b2b39e6cd97db89ffdd430caee120d3610a292b90492b634493be1c258bdb4e67d41017d757d17a2ab8fb044e9a252def750cbff94294a530eab4d2c117875f650e4a52a53608619487d663bb96d3f75cffc6b065b5a61b94d620ccee0479fc2c4aa1c740d7972260d524eb92cbd746724ea269732bab57ca5f0612de20642242349c6414a903a51cf27eb5d06d76d4849c68fad2527a6676fe2b14d823b9c5bc40a2cfeff804acd49776ae0f11e3bc840de8158a6354981318fe46b1a79a5666126cece50ef202765ade24a5b6d8c8ef7f771e996866a4e6c857281200c71fca3901780af69de00a8e6386984bb1928a16b093a3d3f2d006a3c3ded9ab291dd29af1fb5e6fe3f6e50a535b7bff25fb7f9edad809facf86c9aa98d17fef005e5042daac2fb421233e9be7ca61cca73bf9792de5631f3f3e45aede6db5736f8c6971043a5bafd465f30d4651f4b27a4f24ec63a298c736681aac8988b81a5a6ad1f0e6ad6557108cf63dc250cbfd594bfb2cf7ca915bc9d6f5fc0ff4053a7398a60d13e6b2faa1fb61e4d4f27e0ed5c104af6400ac7b3be6b4fdd3b3fc9bde2a0b9021c59c3608c530ea6e214b7503e2027d538b34649030719c6a49d1904ed24c0b3e90e440d2d9273fe25ca191a2915cf4ff894c767a85bd94452dce884d314b7f3f0b0f5f3ce3b24700bc610d863b1bdfa3537c993e589855af4812ae5add570cbbe3ad93596595cd0ef5e49e03160cb2f19861f769e63b403a02e7ae99ec27cffa1451ea763cabb7d39e759af561ed2739f6f1efbd039ca3b9d6e6310731cd5e219d80aaf2357d0440b5015196b452fb789004a430d81a33f2690277e3100b2d44adf937983e9c11f758f017ec71cc3a8995e099df4977cc3e9bbaab34899a14e965dc6c32a6e57cbb274b61a1e47a795291f751e440a975755b2733008aef1df437b9db5035c6617346d5064d3a7520463e8523737bbabbc38b9274652c696c36b7eae9336710b4d622008e53223e563fb300aa38c32b814553c6d367dcc95ce3a466d07d5a93ee7bc9eaae3bcfe18ba7803b68e0952bdc6699d7766847cf0525c6976775b2a0ac4cd34920b1ca2effb0c2c99b615646705084293f9bce37d91009f3cb7cf105f59cd1db8856cc2a91a1ad8b342f38620722dbc2f44064d8eba9d929a09a807a5a4540b6a6750e64894ab948f966f7843f615599eb295585d1738dfc2b16dcab5e1e37999e631bb1c30b78f4f42adbe23660ca0f42fca396e91a3eb85be0cc8a6f5ad027132f55c80b1f187a9de3a2fdd892daf096b4b4c80f66c85b0a3e5449f6c879d144947b9bee41e7b3118cb3bbe15f1238271aeb44bfc321309642daf1c68394820ba2a779fb3913c7b8aea3312d04ae7faf71e84ff691df155a80322cb5f8271d1fc6779d7d9e6a10a2ec25fb5cf10d98b23352ad702bd1d7a97598354dc2ba9efcdf8729b9ed269fc1537271b7a95ebbe8528d3e5e9428c6d21b3fcf5916bab7d5ac18d2b4cfcf90b1b0fb51b57057b21f7b540d942a520bc7b5631c6a1fbfffd0f11d984ece937fd563fb8d17d56b4240d8bc53b2ff1be0ef25559908ba4cb1553e11b09e68e3a6c94bd98887093cad52bc5b952227cb8461dc42020dee124a631229ade812c4161d14527b852c3e7e993c58ecab8507c5c41ab34e4ed24e101d7eeffe80ae49288b6402f1dbb530ec3909840c672e25589bbd0a8d612eb09d66d1d008a82572581ac375fea1abe5ea140adf832b4559a90067ea29c575cca942fca93ba1d10cec39141dbddb924aa4978b18a32da0f9f6ea6727485d1a3b21818dd21f143ea3879876a7f159792d5eaeb87857666540e8738be70600b7af6acd63fceaf170fbac7787c9796443b3ca0cceec15020d490ca3f64a1695145f28252a271e8fbb80c65cab32710725f575eeef034299b378446c1cfd8a79d958b2c3eb0e591aabcf675e8d62fe41eddfa0b7c39703bd63fbf17584fb9518f64712e2543e5ffa79af7514816efd3081d045aaf4993bcadf0fe3aa618fec0e81f186f53d611be89145b163ead894be329729bb1c193ce97e2b99525e866265e6c9bbe0eddcf49bb6f0a6932a2fc2e635d198765986d7822dddafc6aeee2d38fa1e567a80b1f536e69547e7761a9adcdb3628ba39ab4eb3d329fdecfdc88e9293df0737731d63786cdf000144618ef3df2b9b38548beb10a01bebd0152b6d1a752c67ebbe1ac62dd78ca7d437bf60a2abf4806130f5d6b2e0dd872a730755bb3f6d30f2c27ba218bcc7e2d55f26517e3658f2f8eeb6f293d801be2e3ed38aa8bc4628df705d70a2338101380346d227139437e047832cab54bed6fe984de7274a5cc6430d638cf6500a0874df70c13d2f0c96690925ae469fffa5fde6311ced52f7bacd6e18da9ed126f0496f420370ba7cb5001f9932dac765b331348ee22558a3e51cc931c7b96bbb2d7576d481fd93a15f08dd060294c5826baa01e44089651e8e5ef763e382a4814036b2eff7152b5ed9eb6ebbe059824dcd14657c523d009e4fb50f0163397cd8e88d5a085b9f9c7ff98692f4aa0400897c8a7252fd10415c173472f6d1c66a0f2b9f7e4c902a242831d37ca5935b63ba4377a0e92c63fe683b510c549b90c8b75e50f7c55c5f102947ed65dc4450af3f20afd81a2dfbe8fc6a0c674a986a392449fdcdc03ed3d776674578001d4d76d57317adaec061667ed2229c20cdabfbc0ce2aaa43e4e675ed3d40a2531b4faa2637eb30cc3156a2557608c25241cebd65ed02271282f677a6beeb22b7a67aedd35a4ff2a842f2ea6e574d5ed9a19636ffab2bcbeafd9e0c59ebca9bca37c3ea77595ff489e9ef71f5dc0a365f8bdea30151ec3f8c7986e3fef17d65da4861cbbc9ad94e98e2012799f17731deb89640b038a553172d47e3dc2f0189315d772356cd16ad9b2f7a7a5417d5811730d572aa6e84685d690a8d5f94a376662687acdfdf2d60d37f03e094fde5b04e261cdcaabb962cd881febbebf20cab2280891cd241b1dd45c24b26604aa1c8cbcf274b135253504d46f01bb24b8035e8198aec1ea6c18931f85987ffbb3fdb73b98c1dfa4a01315a2710756103eb969dfd9619733e52f6443ef7f5426bc8c55e90aeb26565a7f5edde16a899786b146d6b8a0cc93c9b9e69cd173c3c15a3439d62a4ff6b99b97dce0f67fb55938ffabd8cb996410d907c7ef34e88c8f6d2deb83da427ad645553350a1948c514ca98c1e00687be5a8a4340b2296af43c76a9770c78b56e9f1ac54f130d21f0445c26e0800c00b2f55eb478568251d11a6cccf5f644b6c74dec9330cd069bd13b175774bc480f0c11c6328b647366347e0720c084160e388b933d498b026ada34d91d84d12c1fce933245b565fb91e1425f894a6c85596f05e246539293041641bf6b2868b8a5ae516f40132dbacd05b0d2d184e3e26ca502c3e4991450ad364533665243ee4e3b3acf6c61d8c2ae6f18f2a2e47606b7bcab2488fac1ede535f06cde22bd438a32db52dc83b3123fe728b1e6681441bd9c8072512a360655be30b1c86a32e5858f3503bc98ad95231e7c84adffab7534f5964bfcf769fec95587de23bb07ab43dd24b7097fbd57262dcc7c48f619b23c808eaab865defe8579416d57b8c2e20dd545d86969942b0e70bb1009269676431feb985d04f140eb7083ce28ef8290bc6295590af6456d994122017806007456368417e293d4936567016914a9aef99d91f25aede34f16c08529a37ef0af750971127ce74fe238af15b05d237256598dffaddf1290d0909512b48f67b722aa50d260caeac823b56f7fb9d4b1f439356a704c21ba0cae82d9d187b55ed9f7accebf46e215f21993129a074ac7ca692d7fdea8f5ea48d919ad8cc12b1be880130310dfa006c8f741b32e1120cf176db524b6a0ea23bbdf292d740bc91ae7194cab88180b5485301f5fb30ac5ae6a2079a4613321b3f5df299a3b7b53969a6013314be065a831b04402afb885bed7c94d586a526eb9c6a16998bd8ccba4f81cc9bb5ef272a5086eb41ce3a475dff8e30abaabe6186ee7c8fa57828063b45e1f7c06d52d8686628fdd5f6479b67b1066b7a3825dcbc9b56ee7ef2dffdc2eaf7c671c83e7d3b9cbc8390ce0928d0cc2b257ec0dcd54f4cea3dcd1bbaa3a5a951536906aff7e9b6a4a069334571a8701f5849614c9c6536de9611647ac0b0d027c119bffd86fd450bcfa75571fe00d2d8852c22f30e827ac2e3ba30752973d0afa7b475645f136bc8b0a174fd1d2d9457b4aba30d41cdcee13a88d4bb40e02c65d4dff9c035247916b69feb6dc981cc899fabbb1493920470d94faa5123fcba68b51ac1b543d6d052fed48285eed2fc8517e8d8bd6251ed3191b26592c5385cddd95b78609869d2ac7f984a4eb7fe555410b39d8beaecb527d79f62519701bcaeae9df447d5d4a25443791bc1879c9e1d020a1c4b0913edaeddef0807b9c03c0909852c112edecfc8b1975b94b830bce8b3645c8fbd29492d4d7a7a0da712efdae8d7aca762e39f3c84d75eece5b22af160c6191a074bd9655d19c8fd2bf831d0029c5d976dc96ee5c44a24776b29796a3c837042b51f4136b6a0212b679b85ae190b4a479f8af638e538785f5cf7697b9b61f4d42de94fa96b0f0b055dfc87754e16b6dee638ac69144e54e6ba08bb93819e3d75c0a63a1121c77317d0109703f1c2282f2e2998fcff94ac167f04e1809dfdf1d33d815ab8525d779494da1a8241e306ba6b4a6ef06ef77d6756fd9e976d1d633ff59245d50a594c012c13cda6a3ecb3e22480e9e3346c62f2c9a7c74bbcb225c5b769521b794bc5e24bd402459302cdbdbdf30d555c5fdea16f13ce1446c8378f580c89ffd16567d47dc4cca4894cbbdbea7af14e1812c4751f35163b444c2736bbcb3cb696702c355f03920dd47d61fd044cfb298f318c46eadb5991946a3651b0fd2aea0929200cb45dd247137fc70b561920c4836d3cb515bcc5205a3cc1477e4d268e50d99eab302db1dea80175526a8ada7b5fc3b58f94a769a6b333af14e166811a70494f6198b3a5352d992ea76e03665b04c30d5eb3b7c185ff2319acd11d195dcb64c04c7ca116bc8834d6cf3066ff30551d393ecd51dfb05c2903cb6ee804d4dd2979bf01ae72ada2c851e1d044de13ce1bd84f624a347172f0dd23e68c1f8b789c8a641e15b8060a9483d17826eeb16db3497db94fdce23ed32faacba40d588f4d6323db7360cf0bd60f5e326011899b1f484508427442ffeea7a41a29addd70c896f02e8f5f38cab790d6259bbe2b15a6e2389c6a90838f9a8ea9fb62344a9accbf71ff8668913a2ac3ca70baaea9b842b7e081fd9b303099c48c4fad7dd631709c7dfd08f386b3eab117efc625eadc1da4901d2fbc5523c5309d3a8f7fe39eed2c241dda623d68e2bc3331d7f14f69c000d9259ab5648bd93ead2dacd17f658ac7f91b70843759bdc89a8cfcc7aecb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
