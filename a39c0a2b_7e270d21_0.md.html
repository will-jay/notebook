<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0206baae9c898d7a7fbcf018db174bcd5f8dee461eae69b1da73b7d81d728aee8000b9b341a8eaf592e9ccd1c2124019ef6e42f7ab4c70afc21c3ce37af259fe992475ff902f8a17e037630c4e80243387bcd3389c2c768afc528244a64bff9f25b1397374d3b47c8b140a4de4774d922029918124afbbb7424cd28d40edf5c0de21d2056126cfd71f00116708fd1aae3e69721fab6b622cccca118822ce88e3ec790aa29b09527d8eacd58413281ef8b3b19c8b4e8f121f5451afa538fd696d54092328260e017150a7e9223d0e9f8bd69eb8701c8a74f68b71504c3145abad1645307955875dab02755b5fd4b61a0d1a47132b434b69c691bdde400f2a92ddc6772070c286d54ed4ca0c8719e40bf1c75224de9c914b5eba5a3e3acbe618a56230786aaf90803c7ef065b2882a30acfd60ee2a63fed9a765a24f0abb77ee989df4d0729e11c6fd0321251150788e61dd9b0ca0799d1ef1f9b4f9f125abef80b1454ea50def20e84918a23b21a3e7f931b3e6388e2a22c4bd1004ffb3c470c1c31acb7036aefacd38414d0d5accd3f0a5dcc6aded26dbbb76b60c3c513fa048b9cacc7470dd61c67dc8fe252a7d6429e45bd71ddc3b17a484f0b31c8b8d729d3e75040dbd3764a10890ca2075ca69ffddac8ecda4bdee2b7e59d61d6966268b0d0eb55bcc6534d27bb117a2ab4c70901c75f2b164ab7888a25f70399ae697d58991697ab9bb1bf8884c03c7e329b5e5e0aaeba76a62fc1d4665784244091659417c762f568c0dec44bab6e795d1856aadbce134c5716f7c7e0879ded348c6c5b96b550869e5c3846113ba4da06f0ef1b77c8eb0e5ddbf7b291cbc1abdc9966efe95fff2fa3f439d812c9ea175f557b48c2c54bb6277df27962d3374cc5c16520c197a444296af4b0cb683700d232696fd6a83a2a94e9ea7d39b4c1e578c8c15a47f082956cdc5bd8816ae26f69a2fe867453a2084268644f9810a7856986668deaa40acd155acf76dd8662cf02621576716ec234974dc195549254b76131ad7adceaf7b19e19387727d759cbcbd361fbbffa9968f119f045f83a196615b2f6cfcb58d070616202d339fb3de7507b30f24e0fafbf75b8bc419b89b7ef027d230a3a735e941409e0adcb703f9886ac6cc6b51c47b77c507236d25428625a7fc87f6ef7a6eb6ee1b5436689a2888c785244da917c1829a4277b92120e987faff45e9e894cd9bdf7d50666f544d9b5f75475cdd9fad668fe1a0e8e268aaaab995cc3b10df63f91955b530ef4a7ed6340b67c4932aae02811204b5546771dd4e3ea27cbbcb9f18bdbbdcb0323123ee43ea1b92030eab11fc274e38292657475686d8a26142e9a3ac8251f784c0d88991964ca331d90c4d7b5392b08bb59daf99dcea12c9ea6271963c3eca1c8b61f506713fe27b20800a562bee6b1222a421c40dc68a6473744105ef337a285a6005ff1ab8bd1603c9c96b2174afcf17b105bbf332ebd2d10f8a639250aa04832a52f57f1c1511a409fcb06fa26f85bc45f38a1858126c75b4091d7d2df927235d8214527cb9583e02d2542176e1c3ac02782e0d0bd7c56bf0e2ed6e314ee2295be3e71dd43d19182bacc17b37302504f807a98e83e1972e4051d18896c0d40696c4559cf49461561e83fe6d7c21b574c0cc34766032cbf98ff98f055af4a3397c7b57791c48dc3fb6a036afc954730570fbcad1c9a8a1783144591a339a1cda7ca0335a090f537a5dea11946c9a2b9853e7b374750d8d47fd9e378174ae05cf48f5ed613a440273ea2f212f703f1c8f8521995c96b363f4020e26c45af5fde87c84f9cccd4b87341d7f1982e4720009f1d06bc986269e6c284087075e6ccd615137aea2b6d176f3d6e0e50e0d252fe13479e799a908a0be4f1de9ece40b55eb32680f06f11e30540c72f2a5bcfd7989328f1baecba8e4ac7450a65235491f9a18bc5c5fdfbed30237a105048892062e5d1762da2def546c8a16e102cee907b8aee2399fa0d92d15064e6b854a03e5a388971e175403a491bf3d734bf50f98abf1f86ca9b57f68013459a06e0d7ca5488e9d3881fc7ee762a2913e93e913d85a642dd1d7da77928124205fb3a2dbe5f2c3aa9b15653203ee5fce99cbad6a98960c105b32b8a679ebf7440b8d6fbe92b254e374f441a0fb5c9870c086dbfcb23b14683fd0c2c9a60966d40664bac32b17356a70990cdfc0459648a9980bca1c5a209af70cdc08757a3517421e528407e0efc726b645710b407f09c2fe2546dee95c59b4249e0d3335c4a194eae87861b6f85a7e8e1926a73d2149317e9f4e8ff8acd1d15bee9e1176c08e7e79e2f30de61c76634947215a71649c1e775207962c328e4eeb9f64bebb06ff023a3d638b58b2eb4a3bf0ef6b24b5125980c780db69e985912462cc28bdc3d543a82b6bbd3dc2b226a8e644ca450936081092568965af76a1db7b1ba18ac2b69c7481ad62f1eac2fcc5252e46c892739e12eca5713eca74bd5534b2a22305d39e6b5916c145137895e4521439fbfcd9c95256f748d735984624f9f1881e3a83ea3e682ca5d485477278d3c8f16d5a7cae9fbe148fc34b964a07e348399b805158c97ad06eaed59c85ffcf71f0b33a6acac962ddea28025d32d6fb57b6ae88150316de5bc52257ddd98e68818a741a26678ecde9caa8fa285021618a660a9e87629cfba2a91ea8dc121ce374ee471716c85531a4adccec4a6efb87b87559404da014f5651825b14a20783dde0589a30d2e8df1b0bc19bb510395b78fcee17d468593184fa6802aa42e3c1acaa9eb26877811e29c40d1c0a4748bbc990eb0a75794d2c1217234dc08903ac566595e066253471db591883ea050851b8a00517570dcc6a55dfdd9b0f84e11a8b5f3b130b205d88af52483541da69074a990e9b36914dc9c15d5d0021244a3b5d45225a4471e12cbe39623d7735a60eddc95a0d31b0035365a3465161d90ee69fdbe0afd5fc9913ac218e883d0123836e94efc2b19f02b1fdd4704e394091473d402b0dc63078ae8d04b654f4d60c0dfc08a8a12b92a47f53bd3b288cdb885fcd0a6a42998fe2859316cc0cbfe73e42097f1bf4240acf5ed81038184946b8244db96e13c1a6ea999970cc1e7ec94a32e0954d47d81bc0707dcc832cd06ff5f3be2d92cd2880659037e6dd99fb00f41e076e90a70279d7bb1175fa84132eb5a2aa0670479cabcd3950411206580e09dc6376fd2c7ee0f4599cbf158671af9f0b0419a550e1af51ff40d6c8aef657d3ff789007ea21baff89a016c961a5dda2a5f90daf564b0c4ddb56f985da01887fb2c25d75b1f27433c556ded79331aa8d9b75146017bffac7570c30b477c65c43cbf72bbd9b847b418e609b0b6955e6e09d843de6d14dbc8078f509399aa3cb317bdb9dcdfb279e97f4dafc1df76520cc812433891e2116c6144ddf716f07d5b43565eb2f6a4c44bfef642b229b4b8c05b54a9a5d4f85bf3ecc991b6f9b6420c72877bf6c577281f9ab8211b8fe0cb9a1f3a59c2eebf0ddfac9abccc583691b18cf0620547b1a10bcc33eb47dcc88e4651a86ac4bcea6a30cd10154ecfea0447f3785511a2958ffba2b5a2cd3f3d8f16018b374b42040618976b1be5d66586e36b7a6a6134860c9c2bcbed1e96a11c3f78acbf5a475ea408c80de38a72261c659eae4ef0a4ec9200b7998fb2f5946269b670a961e24f6832b132e18006ee4e67e1fa1cd250b21bdb08b9a94e6c0c96af79034b72ec46563d43921abf922a8618682f637ece20a99c39424a9f92de0a0e8ba686901abc794103af07e10cf671fd83d2d4d59132cab9673877fd81689e1804f2d6e116c341d7753df94ed3119025740f89362a002213f5c203464759dc13e9f05a39bdd9d09895ac431c4720b39c2f0db1f74b677402c346baaa3179e955354db10420e3ce936d7ef2776cb419f514209a49603ecff4eb2035d5e59f80dfabf912ff1b709f32776686cb4f5613e38385dbcec127c99bace42e5f8afee9bac8646163bb410984c60a002fec99649caaccf52a8fb435c3a825e9ce45c5ad8b35d6e87f3ee9f5f5f22e784f68e3c98a89feef4bd5c1abc006f1fa4d77c14f9249033e2b464c728475fb7ea0fe5aa82aa2349661f1dff2a18666ff490fd4cc9c9797524dc05fd239b58431b435729b517d024dc099f7c664aa4b2fa98f90b1cc4b9da53daefd871e3b7abda4db6b65a6ba866a35a4678827be1582a0b594932f22f1f8bb2b07dd160b2a7bd98278bc59a17b3e0c3a0e3a8687b838f39c7c7c06ed3194e61c71a8cc931a725d16c79422115e4d8af2dee7343742fac4a8b68b4785d255264c1f06796bed121273384182d3a6330edde032479945951619873ca5501320dc3fdfc66d06a72307618a707be9db286a02121e28dbd1c44ee11a37f6f82f761185c664408ffecbec9080ec2d68aac390e1c4ffc4deaf2ac6e8e5759f86c234853adfb97bb7103ccd5c21738285744ffa452e9161cc008e45b7d857d314d1f1822125db942c1d2dbc0d00c269adcea3bf3b201dcfd270ed9d880e06e83a06bd57014aa10bcaf8ec3dcbf57069374675f34e40f90d7ed2ff522f296ed70beb54b9c50681f2c9f52b984c9c9466c5c0aff92c8da6ba5b91873ed578d236f031a19c266bf900b5bded79cda7641da2d65d888c8d9dc4460663e4fe738e1de391dc5ee9542accd785fc8e3c68ad6a7d34f66aa4be7ea308d35a2e804dd575c77e9173afc2a642b8d118972eebc303466fee9f99811c272bcab7699255029ac5096265224d5a366ca447be878c0de163f42342c97f3a84ded99e6c9fd008554b3792137de0f1da8f6248f5be597a957f03c4f5984f0648a88e163a22560a0caa76414d72659d3d921980f70ad09754dafabc1d50631fa5f210c7c260ae1906ea4fbc647d7ed76baf671c6bff8a47a995b4703c40504d8d28ddd2564ce6f0d3044b2925b0273bf7b6a3bd502f356f4dcda01e9fa7e37e18ad38945fa68d68e685c67578da6bb0fbfe7d92ca31a1d52150821d1cb5bcee4ccebed6be7ee565b70ae1161790e562c365cc738ab99980863d6e38df674317e9746f8c5c6b09a6d6875f5e29b7b323d0647ee00851e56665c18d77ced77e67f86a11a20fee90d745cbcec7726d207203290fc45645224472dcc4705dbcb4ce6b32d367e1451961df12481bac4cd808e9e658dc491d76c1680cacce5c25638ef1d1cd6ac7f21ca8758518617def47947ba175ca6b2fde8264d87b1e718042bed484b2eefe4b3d31223bf9b2b10a590e2e8116072118870d363ba68db5f2630f482b52fa386c9fe7b28aaf60afb46ccecc7f243b7e21ac140609464d0802cc258200adcb227d436cb1e53fe9f6c16404855ca07e2ca01fd7116849d027d3cab654cda90713193178ffdc2583e9de271c2a44b114f466335162d2f5c69c0ffd7237ee1a0d6074a69f73fa5403d05dcc0a6a8ad2b012679fbe1af87dd40bf9d35eb9d8d27585ea7cbdd302d5ebccd83d7063152ac250cd72ba12fc20e93441a62a82871bf0634e71050b37ac9d35da2ba2a21ee11ffa9f60d0ce6c74ec8b6f83aea22aeb9ae6cd510327de3fff9a6c855a1d236609449d5543143074f40fca128f1bcc61473add90ab69e8d2f58e17b55dd80e6639a4856c8a90be6802bf8c174db40acc70b636a7e58d99976653d14df33a5bb2505ff5fbb5a4f61ac818232a85f4c84694a939f4655ad60342e00a456074a333a568e1fbc48f0ed072f5db1ba667f9ea7ebba692c141612b35c589fc16a0354440b0d36200b64d3f6cf7673777af953b9617a5f8e3ea7a14b394689257792f7e99ea2ea47ea07d9e2c40eb127edf0f4be49ecbdd617b2d0049b7bca72fa14134a867dcaddb7b5edcb4eba5624351fe0a5741865f08c06f1ec3ed27e6eb84c3323b4cfd3e71ef85ada556aed298d0f9c5fb8528adf756584f653185f295a62e3ffd006995b9954c87c15079d442a161ff94ca824902ea80c1623d0fc776eb67f781b98e7b44e918ceeab2f9b41ea16397aeb49e41f4ad45e8133917f18a59cac4dec9792427e9c57db5869e7bff2c93ee036747adfcd3f392f37a399229b2ed9d91ee885998034761f431412728bd99db221ec91ee3d5878595a3b26fedfd75f330bd82aeaf6bb074c4dda1a6d9694aaf1edb880e5fc84a20f508798326457360b7b4bbf91db9633d0d35ff222cd42b7c02f339625636a1c79c9ccc5704732809d239bd72438135f7e8b0674ff9f7755e65f3a5a43b0af5b91a73d7010393bfffc92975884b97160a92959b110d4f0c897eaf48bb1f45e19b321da5abc6d5b00f50f151fc76a2c14a42fc7d6a838496a5d3fde37b2b881f62412fe3b72ad4c67ce34474dade1f62e1db2984e7d30cdc09a8828606d1c0add7132093631089381885abdb19666d660a506ae665119842f057857e6105477d5d9f483f8db7185408023e384173480fca6e832fd553763a99bdfdee67ea0a07e306f75055016590754794d6fbffd7d42ae3ab3b8589d796f457201f138357c8fbf7189bb6c738a592ce7d4a1038c8b9b9776eace28135d9ad67a65943c3f6e62a791b6f6dbcbce9ac7b9e8c04a256df571b2ca3707d8994da8f5a2659e1f67ac75bc2d8355b20e1d2cf7e778449829675b803d64ce06de2447e3362beb630f0301f8f033f83e4a7e53cd896581f75da72c2e3a454d8da0ec688382180ae3a8f58bf7ae12d5e6947bd2e393ad26c8c7d30573272562c6fd01f3836fbe21d35496916998cfce4bb31d9d8e0696f1737af5300c65607fdaf79930e9592337e5cbf0ed5a7e1a39c0a65de09148b8ee88766ce0d4a13d59d05543c192bc4d13ae599079d79fe5c9c60655e62a6c86089964735e22150698ca29a078602811eb5ef99ae73a2ae25846cd6cc400af75019c0bffae2f1a93fa1bf629dec7a9a9a146f04b79244912065d01bc6ceef6f34083762c25ee630e9f01e7d48188bbe8518cb6180ff5cf60f36d3910c2a62780359ff25cca80745a57dd3621941db59d7ff9976993126902a186b2c481ab81ff8803fa7ae79e06aecd4f9efc6bec5dba2fe626eb880dbbb4b9dd9cb829e209fbb9f52a7b7380e60e97d6eb34eea6a61f4332a6c1ff665aeaee401abb6c4a5bfe9878b19185eb66a1b9f89f68ae800f1ccfb41829fcfcdd8c13a740bd56836b539276d1fa0c512f3bb5af03682dedfa14ae87f2f7efebac6a89782f7544a3bce5a2bb8f94aad9ceb1c347ea42b118dd95e934822070612fc519ff20502c53e51be9c8bc4d0eccef3ef862039a9b75862a589b5a858fe64ccf3c679b3e8414a8562eb2c0477586b071354b100ce43ed45fb0d9fdc2f1b0897f4385e2ddb1cbd581e345a1980aad9af1d06c8f99c6c29d371f547adb7be022d2cabe93583ff77df6c205b42cbacddb3bce66326161e06ccec15f4fa251cd8238f4f029b49de07d69f5566d223594600f50e60435a1fa09692b6609e6ac316ecacf16edee5a3bc722151f56641e7130828bc7b7622537ee732db364f7c146ec71ea48d1be5713fa9dbc4021aa577d9e976949aab6f355cfdb974b5fe04b11590d46c144d221325ad27e1e32ef0b339caa70945ab3d16ad5d71444ecf7d12c519d138626a563d2d4040c8678057f2f7434fc16ee43bce42094476936caafb4d447cae23b98165633f971fcc956119d33675466cf54c3c7cb5089cd2cfdc88038e6e14c6db977882b6b7ca7580b6dba23ef1108f25a19159ca74f0f25707fd862d80e69bed5bba4da00ef72e6c91602aae43d50a94d3330613224a571d4e3607803a0b7675d038e36a410a7a3f8f82821f5c4456ac14969c10c7a08fa59cc513574937c08b903de9a582f052effc781130ae83db6d981b916f16858a4b541718a307caa77ea3a6ec1bba0586719733aad5d73462353c5609d04a677bcffc0e0662d3da1782dbb00cb4f0b5794c92068412148557bc09968760f7b4a6dbbf06a7dd628d9620c3de0fdde6bbdb19a7683502b460216aa8d296283c62733b9c5d2fb845cf5e94ce34fea1e55ce7b7d28ed9d911691a859575928a54c92bafc81a7c46222a8a3f049c5eb75adc796ee7fa48e58dc7e6c84fbf9bbfea308633fa7585c52ba13676dd580bfebbe40e0cbfa3acc61b57f14a7e6ad53f1104039c4b0cad587efeccd2803598d6a9096c2d51ab556d515b3ae0d0059b28afabc64425b3c3058c31a514b7c8fc96ae7190f0287aa61a93ae65a444b7dc9c3cd733b05c2fb8e7963ec341d8729e8a677f98e231f13f2d69b2b5cf98522d4cffdacd9c410895dd48689ba9414ef67afff40607620859816b2c3877b2df75e94a6bdce73f615b602e9b68249a5f9b25867442ca5bd740fb5323a380fb94900e9af2d6d22381d446019dc004cd5f4149ea3cd1cf76c1bf882bef94018f31775d83cf7ab826f6c549fc39322bb582c0af17f9ab958446e174199e36501ed6211b535e099389c4f5694937610853b841619846d6c7b02f746f6dd90d799b8a99472221a33315590b0a92db6d60ef946a421620c9c191a8364cbd188ca9d6ff71919c60a6f41e461254a2a4e04d514f2ec563d919e35f77b94fd601a09b72ee1d0145cfe0f222ba6d5985fdb9e447b09ea4e3b06db50d7605352280e67fab39c2b436ec51edf739dabd8566b9cba1468f2d5aec0a7ed948b94db20f6895d18207c018f3e8613bd8e7cc59b37d6746944ad18965ad6ff2c55920a37ead677226558b0d61f16dbc883118a65256951a150e9bd6126b996a3b73a7d9b592b0adffb7de0b571b3a2f69d30fa2b31089a23c063a216555c2209656956400e1b4cc9dc4a195e1e93c5b07f94dcb995a32a588b23c98f81c846c5bb53888a4676abb52d1b2b5e0980730ec0165803937f300dbecbcfdd0356dc14ad85e98b7e15fbdbd886a97e9d547970cbd6e296c2de62460249628f2575f1d52beaecb48fa4b578e73e163e6232765a0c6ac11b845f52c6ce638db9be57fc6ff69ec1db1d5d191329dc479817c62590cd01171e8b8cb8467819b0b0a913eba7142b8a21879219d1187e04a9f7fb5a35496e7026bd74f321523ec28c86a73868817e29da28f3c10f6e9bf3a878f3c4639092b97eec49bf1c4be71722efc848336af6c949bea762e10a611819435a13f6c77a1fa003b85430a86b4fd3e411cdcb87a2a1340dbbe22ab4865e0a2aa03f0b3db8439e2632c58ce526ca4fa595062ae31a518fc6691b9608c77183d618490562c33cf02d4a1e7ab19ca65e5312417422b7093eaafa992ebcbfc91ffd633b7bffea4dd2b78014a4f7d79a4a8601233534d41a5c2d9b0221a31d4e6cc60403ef48ac44d14ea463ea32eb29b20118234a6ff83b2a4dfc9b20a2f839102ff4acd4765fe1a5b6b41164a6c68e925d5dddedeb6010ea0ef333e620cf424c953e342104c444d19162f1f9aa59fc7bdf04318affcf0c19d36356129cacb6f82b7526ff25d6d2746e2d246c226a9277bbe3ce77953c92270d64191540a4eda1884cb3850c094773853ccbb2d7bed3da978ae930bad58c3cbe4f64b16ac36bdf06b0c33a783af322382af53bb80fe4ce8ecaadf3a07d35548150652e1605e0b4ec5add6dbe39c9bd56bbb2fc958cf78799e3a13b451dca6ed0cb8111a8c5fc2339a8905a84bf7097317cf1ce5d894b54ef13828c89dddbcfa21e4fbc99e56a39a7004b50db81d802bd595cd6d6e78ac2e4589d8b6649005ba08e4bfc78abad3cf30d1f75c3ae95f37bd59c5b032aa7a54e2021962d4603889aba589102e5cd41079575b7c7e152639bf244b853dc1507f0df4053c46317eb26eef913b35785168201c296e59ebf0fd95a49b40a54ddcb6979aef36bb2f60511e3b3fa7c4e2abc8b731a6ada23057a33d74a7a1230e9576061c3321c5e661c92b54a4f8b3a9111d5cff702d57cbe5f5040c0e4ddcf1b6d2c9188e236671299352a9f837965d55f85297468eb75d78f32af23096c4d686454f0c80b4544f601442aaca3ef6922ed8b040f0439f2cceeca9ade2731afa76e630bf7da22cca27f1df07696773ffb12a31ed70f65be139ba5162074c3c04e1d66dfdd04ceb0adb1806f67615854cef58f587a103b551407a012c0c93c2e938cb0001ae68016f8bf977aa793078b6ac1ce9ba55006f2a21702ace928710300b49c43ed021498e908296a3571f916e42cd75e10c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
