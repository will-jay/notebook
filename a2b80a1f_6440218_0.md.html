<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26ff621c0aa43657efb2718fda4b69583db0ee341475b2440d8b35879cce31f0891331eae751d6e66a108a583c66f888eb9da348b1efba948cefaa2261a48807872c230efd910085af16c6faefed8ae5742d83d15b14462e50931f2fcac63f80be68e09cee1b00a93e2f380bbc8de0221e36b2e9b022a0acf804f21a0b2d4d3c5192c9268d9cf6f6dc5ce72cddcb7429ee63608bc6b4b801787607968c3b8bb4495353fd302addf3da7bb0c5bc63c00081a0516363197d3f1729084959e561ff8ac14531a0276dc7e69563a6d3cc39d521a03aabc0f00b8efa4108fb2b568e1fd5ca012adb0dc69c6282744b3815acb50e06e238ba0ca7a14ebe845bac1dd350876f7ee5f875b1bf3b4a797df230c96dc81b740a134e11285884fb4c5a69435a308f3577a24b73f0e091eafa157bf772701c44824aadb061f61745c01f59636e15e2f547048f5931b51636c0f795f6da8ae2851d957e896877542e9b1bfd5cc02a2d0920b6cad1c5616aab36eb547a69b3eebe18a12761fbed92217d49d2fafe2081d0b00890e72c909c3abd6dd3760381ca6c972f2033c1e8db6b2bad07163e34730088c8d6c25b56303558f03e208dfa687059e8a570da7ef9f7c3756aa58b82e85efaf209e91b166916640c8652be2276d2b1997665053ace40c58663143f64315bd2ff46f60427c3148519a238fc597557befa9664d3b87f3f80c6ccea1bc7e4e4ac35eebe33be608f7e67b4af21e55d9ee0fc4e48bb3a182e9451ad7b466510b22f185a73666c35bc671f85edae494a72b3f00574e02885f026af3cddb9db07ee6f34c7f2b930789972b9880140aae53d28a6f9b33a241f33c6ab9b73d53f815a06733da9be6d30e73ee03a5ba3107d53f5e730310c12a08625f5652dcde75f001966941c4f22afd7acb6514f7f46f35a624f750b3922bd4d849e677039e3fca1faf248e4169e54cdb1269e959c73834458e985c0a47af0393cd8248abc8c8479bd5aee42fae2cb6994f4a3200424bb7ff363373060087adab5242ac35b3c84a7c58d5ca8d9c08f1628049dc3a8a0347ae61cad805843c05feeb1f4d88a00f8ef55516217fa158cec19ea763a360f5abbaf1af3193d5203f821f8179b1d2a1c4fce7cd8c3737afd5b807c7a8cea27ef434fb76c220bfd801da725c758f81ece6314c2cc37742fb7245d36c2ab1786b8316594bd660a0cf8080f58bf3ee2b536789b0f1356d26de5e007b82357396b062d1efda7dd89492cd69a85089cda9735086b42d34db19a798e7ccd3d7f746cd82e2824eec70728838cdef7e29ea3665606ab2ded27af5109d7ba863510ae38b391bfae5df61be8df0230b2e482bbf858b73275323773e094f23b5f1922f09bc3547bb5ee365eebd3baf05c6178a427baa823b0efe02e74da3c6b4370949799ec81699f70dbf84e11af6ce04b65199fa521af894b079f9730d7861c04689da0a7c4e604213710b21dd83cd611c21d05a34a27851e3ebe287441dd6a794a03771ae068f3ad8d5d5aaf6bb3bf6d580016232da5847746f21c7dfb5151d384e11345e18978f47b20e5a268f576da3ecc0c6d062fe2816a09821a1d36c2554fb83a89d82a5962f8c5ecaac82a0f6955d586f50d05682dbc065f96d195e5269cf9c0cdde8f0e1b09d553d02211aa8346bc13388d431266810157725fd1edd94a630cd280b5889f2f076a07b7a1d5183eba79cf73d2190dfe3f0fedc8e7c91f987f5de8108b2ddae9bc2dffc3627c0349a78de4b81baec2707b9e5f45ba16e051f599700cdb1035c3976b83fcc5676094b49b3af33fbb544a3139ecf1b41a252d59f06ffcdda28ac9d466b421072015ae721fed7716128ff9a7dbc803c0a0408ea4798e9dddde0e9e44674127161a2cedf62b881a79585ab72eda601fc4dffc8f88d07ba2f35f4ea84d63463b421eb0a2d97efb51bca2df79b75a2d47df104acbb9f2f90a261ed3f4be8b89ee4138d1b3dc001b38e64d4b0d5fcb205a837e18dba9ad4e8676e1e9f93b4b7e227ed3322cbbd67adef9952a9ea6ca46fe2af70e59e5e945721c624a067519399af89626a810697a7a0dc4a00527ec9edff01df7a0b5efc85e71e734e794cb4c6ffcc24df8acbed1620fd8f0cd71722e55b410de1982eefb26d0e2a23ef8412d9f0a9abd941943987dc01bab029cedea69a504968c6fd564a9e2cabc38ce18600cf275a59607983063b9efe19bf230fcf4d6634b7044b1f11727c79b8345a6cafc9bea4ef23e36fe167788400a326e7f8ee2ab1b849c0ce558fd18f7752c4a945ad574f6591eebe2c3765ae8e395f07081ffb000d2a7ba7e1673bcd5335b20e334d2f8699dfcf740b32700ca5c5352447c25764d8c8801b0ebbba7a8373626ec4f09f75516a0236500cd38ec025df795a5b08eab00e0454a7094e53a3d99848a54cfeea60c835061a537e5a1b14717ab830b931232d4d4a262d484721fcbeff27dc7c84aa2619be2b90b54095ee8a3d7bfa3cfbddbdc9594eb94eac0ee882947091b77761459fa66251b64610c9f350f37df5172086ec48891d41b673bf233ed2f8df893815e6035b2cb7836e9fa609913d2a2ccff1c8b7e37390f521413fa9b9a0732bbb7c8a82971acc0eb9d27ba355c733d0ddbb14cd6dec2eb25288398f16c190089f328399bf6a33e830c49ae8506bf9e3f8446af4a03348ffccb748316a2caddb8b2c7ef5dbb6c020944cd8f5320e914929dd6b972047234222bdaa6deb2ac2cbd8524a71655ac5508e0fb7d1b4066d9ef27025e63bcf8ce9407a96046d03b51abd9450e2f77e4a379dedc41d7dc6cdaed4f7a4104d018368fcc086e27b5d91a2adbd7b987be6d894db729ecb11c23bb50e5742c7059ca3f8a1ec5bd2f87c5638f8e4e28f0a79053f7b9c5e68b9209286e1e4e285decd4a1c1e85594a36cb709cb079955d98b77e83d486624326f2e1086c207f0d207aced2ccf1beef3ddb7a21ba2084297e668bbf1993da27b4558a02883822f0e8ca72e43c2ab5d60c4cba3a4c54cba1d0f17969de002ab9621021aeb4d0d014571aabaeb035141e0172c13c4294883f443c41d327c2f32310a3f54c14acc2985bb4784d33105ef9afd54b6d0556282d565da2546f3f506a1a45bd7dbafafc372b0d2460873752e900a7cad298ef2edc028a55e5ba620eea5fcbc0d1c132a589eb832c8c4578df3a62312fcaaa4bd4ba49bc808f880f1b9ff9908b6f18ec02da39f3e6d979d36659557c7029a3da2aaa20271d3647ec8f76bd996082a770fe81b4b08bcfdc2b96c9b25215e4a780cfae66b97d2476ecdfe0965f8f2f965e3ad533670be97efa6c4ce4ec01b1cb89fd67388b032d5191864a0f7b478781d2e3de1f89171225805792f99a61734b9ffedcbe35d19ac8fd748660f23a75a59f247f7aa0cf3ebe10c9890037d2b650be59b6647ebdb9583ad1ef0e7953d3274d0c733ce9332e7c5ede7d368a9d77b0e5fa265dab73dee6d154965702bb095794ee6ba890d1731492c9efa0c9afe9f39f0b59147a9480925f3267e1edcc9daf983a93b60daa6cf5b23df913183ca125e613ec6c3457ea5eed4009dc264019c4dfb6acd28c164201ed1323c2d65a45ce80004a08cb8994c30ce77df42c56be6c5d50a36639e8809c931fd4caaa0df4c24e36372a1439438f5b75d3386fcfb721ee2cc323f2c454f476a7f21c769477d4bf3eb33e0a6fef72c8f8902974e670c5fb349986cfb88ae74316c7aae3cf0eb63640fb835ff7b63fa4dd7d10838fff2005f9c1ed25c6904377a319c7212984f7a2f9ec20d31bbfc511e3ad3874dfb0009bec1efa779d0845d0c5f91a663405c1df6faf4508841a72e4cee4618133f012b3f7450ae60092eeeaab601b3a53db8594fc6dec045a5f2e6228953c3d116d2792daf35985d80729dfdfc661bd86c70ff8050a6c8e620c92f272982fca31dde5e3eb4819753dc3ced38a80d74c36686b163e8ea2ceccf27f8224190ec6bb7200276d67260af2d74baf1ee592839d13a122b6fcf60d3895092db9582667e86ef54e724e83e84c0009480505c7d425e5f153b715695eb75a0e1157926c18be43309453d2b35ef6153843719bd97cf3bccf08ea6e36ec31c2c9a79d645a9d5e03dbefd1855351a0485163d59b035597db366bd938757e8a1c17fba47196d688421ea94889b5f2943ba6a73e977d3c9c582bd6b43a3c14858867819ce0d96138caec5eeedb060455fa7dc67b4439f4e4bcc8c7bcd302d13471ecceef296a557e7c75ed029b0963a9a193ff0559cc765a05b946fd71ed8f20d40008b987363c5775bf7a0df63f1c3b4eedd48a6734cedfec71d2b849577236ea05106e0b181ed6e2698c59326672e8016bdbe442d7bee80c30022d8fd4a55e03d898494d7b75e71d574097879b862985bd8ae986cb12b889f2b7c9b1a7aff28d8ccc7c5c6e47bc531427112bc879f3b2ac0f9d8de613c0b67bb919129b0f01b2a023d76d1f30374c1b232d4275ed780e67c4e4e423f050aeab74a33543196b29ad66c379aec917f4fa8c1fbc93cf15ae6fd26c6da17b2bc8087101668bcb74ea35a492cda63f4c86c561780e51b450bf30617925dda65c7d27a250c23f286968d0789d3462c52f591ae3e7796ab67d0f01256fbed5040765ea4cb49cc6257cd2b5727a1d1414de90d8758d5a4ef9347c41903d1b48d7dbb6a30acbac8ad2c0ccc5106dbfa445f41a5d74b07a14ef33c677326f0157e04198d915bcf515502c9bb8b9fbedf297e9019292e5a353f731ed8cd0ac24996eacf9c48e2b9fe033d51b56d56c6e898721554c376b1d045aa6295aeaf03b1d18b8e38d1bc4477587f81eb0ad2f823a6b34398e8d354dab46802a869cf52227fc78917cdaf4cd6048b8050398acb540991ccc0545446c802354b86516899acca0ee31b3dd90c0805e8ad6af142182f15ac3af687200d8092f3626b4a8e2b884796961d83752010b602e8790a9277a9bd67bf27cd20c67624b24fd01afa70e2c945a5427f59fd84669d8f18e98e0cdd47b2f79f1c5066896ba35ea68bef9bcc4cf4560dff45472353cf54756c44a67a95e83ec9ecdad1a66b949c7a70d44fd3c5aab1692674710416c553e3527ea7db70456f6572a182080cf4071c4d3a593d31caa1274f86e3bb5b4933e03e6d889e30e40cd0e3de5f7fa37fb6fe1211a5b9af2d7c71cb2aa8f66f8bf21259cf6d4fed8b448dfffefaae87c068f59d48a892745477ad3665d2d43785bf9e222bf21efc120eb7fe530b0a501388059c7969407f84b022b462152535ca0699b37ab26d7c6dff7289582e08c34bed59c5cc86866f026516ba2df57092107b9b567f6579de1833d5b5a08dff79f532befbbbe878065f5a1ec0eaeccd442e466b0a74d426760d644b952216f39553486b09676a75481435449dceff257943fc900848a7b8943f686d8ec32430f424894a6f63875fb3d9a4fdd970cd9dd1316a6ad55857ba3a871eaeda3defd87d482def93724bb1d3bfb58d150ca34f5b1ab0c158218e895267e816079bc788b22ba5af153d8ff5dd0906d0966274fe4f91978fee0b820d4f3812e5e45a1d02817aa3468af070d5a4d89866b63d8108162bf1dbebc835c45985c5ec3827f7260b7ff235c088a8b031ef6d8bb681b777329a303edf442ca8d487fb18720209de8926ed0306fb80064231207827b1c7cc147d6d3caa73becc93c7e3f8f609537f5569293470d3de411f48c915cafa88c3ca123f1e786ae42258923a19a9c45dcb3379d84d8743718439f6e9b20dfbbe66faae7a8834c50bfed0ba2d1d0661796c939c21e2d796e2c49a435ee9734311dc60e4f667a7558a6c4c3fffc1d83f5a75aa2fd9d48d0e2c912660d8b148c9f1860c7650772824af5214aad2cec2e459aaf2b987e36dc0160eff9306b454aab1c0a8e6a2196232e6618ff1ebb36afff1e83ca5479a0e061f151223a31fb06b74ca82426d5b8fcebb4403e6a3aec18d5e9b6bc3460d5addcd17b34ac09325728f502babee21e5e52296a914338cfa3a2709eb5e00087f02039969eea12561b8e77e4e2eb122f5d7349c203eebde277f311529736c57f15e361711e8fbf28b952505df052a5a1d4bf27099bf02608e7ea8a11a0726527e718c5fd9d35d5d029fce2fbdd9507d29f36aa5e4cf184742d73e1f386e1933dca507aeb093831ef6cdac48ffa8201efc8abed83c7afcb67cafe6744c45e374a49c54dfddbc1de46c1eb618b11282c37b3bf413fd20af20c345282dd33fe7ad08a6552d12f1c4a75efd403447c42f30f264ee01760433fe6c1171eb19b7f380e4e24b89b261cfa65f801d64c4562982d2ecf357ced493145f663f4abb8fdd9de898b870776adad13074e810c46512eaf8444b5a90efcbc89ac98c82967008075fb18dbc04a4d5dfc446b5e5484053f67df5e9935a51ab575aae226a514ab374b66e42772a3569876531fef5562f3bb237bb215bb74f32323f9a1f5e620b80d9881eee775fdb697c1445f4c72db763cf83309e067c0821497ae24b9a175740584a3057aa14ff467f0f2ab71459c5966d08b051323a5ea27a4060c61873579dcca41f4bafc22e85dad3fc670607f92a877471c37374a8f8b2be7650dc0265ae61be32f1dfdb59da5d31f06eec58b31f9a1e5ea83d628485a6d3f6eb504fd94a8f87ba718a05a6daba93a8dc133aa2135f73504d226195a4073edec6360b84c873cb09166b4a438600cc7f90167a80f84271676eac460ae92dd041d0da69e3511cbc9ca9cdeb8eaa3e034fdf95f6965b5e1fb9e5c6ed44e6a28a04a3036e8e2d06c223802489def8fca16e5bd23710d9bb7599697f32e4d46d664093849d7a9c7a6a72c605d2859beff0b75b9f9506f5e73dfba752426a6aacceb17485298c53011ed6ea590843be960bc71c50ceba4b33ad0b5bf623a866148bd5782811bb3a3371d90c9c326c891a058f92cfa5031d9ba87d2ab09fbf24ada6844b76d08750b7164b0b620779a23ad880ced12b92f6862671519bee5d1efc819df901bc86c58c5a0d1e00256af4d82660a4b8d9b496126cdfc4779ddb5b14dd94e3e76b9ddff7f62116d0263c0e28fa4aca9d83feba7abd5a09a01b4cf093f486bc7db2f1c33689ddb3f4be4fe5f29ef16f8f1127eeaee2795f016d4a5d06867dd2962ee15477984a3ab3055199f285c48e55ddd215d3b8e5c9b13e1ff8714ad4335b7211f2b501070aa4b149da623a50da1ada6cf98f4997cd77102b6b196a5c10989d7129d8085972c2787ad26e0cdaeae041f0407cf5a9bf14752c6735929dd127dbad7ca547ae595363b4da6171eb1eecd6f740092c8abcd2542946551466e68fd461fbf13dcd33b4787e95dee07f552f6232796c89eb6d03f346e9393768c8ac930fceb19fc4a261d14daf0bfe6424098e28e997f1a481561a61d16c729da46916b2346b86a5f7f471e73152faa6135d1ba74256e45467952f50d676dc17667f41812a80ed65b38d53dc30d20a9f8e7842ef49a482fb4cf556a919c9d7637713d4d4ed88871fa9add9d691c75968526b485975b3c67c8a0affd970220ec6930a2ff871027a24e68c5a0faa98c1fff38940c56bfc8af79a2588cd179e128821d8f559a9b5da9b75bb719a7cda353bd059d9d680cffd49a242f95d6812f308e70aab59c8ff7eccbf22a33ecf231a489e986aed749fe6a21fcf85a9ab8bed8ada0c04253960579c954b984fb9604753f7df2d9ce2b95c4948904533bd11b1de38d814f6798f5557f9ea1460f31d6445bde6c6188c7703d0f846ef84455724c7a38b3d89e7ae8d2b91aeb68c6a17b34e13165f5d517e9416b6ac49424331e979e7525b9b8f49af9be6e0ccaec56a87eab989c4d05d4eabb171c0523a832d08b84d69ade74123e39529f5262aa567a0d40bd4aa93f771ab4ccdd4d17ac51586174bf32cd429e24618546ad8f114400e90023f2f7ff9c51d80ba47e50b890fb79c6cfe11a36a41110ecb475720683aa6b1681abd66fbe3fa04cd96c4df4bb528d13b2880f603e3036eaa96bdfc865ecf0965db93d94b13fb978642bf301bf191460f5b3fe13217a57d15469ef780a995373afe85daee6e07bc37cc7c55a2b583c01b9c7c26d8880d4fdc5811f60908adba0c9b142f38a01c6e52668eb12fc7b4b91ee880616d765db9e4689bffc37ab5cf4c721c40f73255ada437962a50a13512b920e8310c6e1d5f67aefcba773b6489dbeb48bee01da0817e376ae7c64af97c4b8a5ba3d88919105e88385155e89581ed5124633d57dd36bbb428ae930b3aeaf0105c84076996cc089608df54cf0bc380b5a3dbab99d93b87c03ffd392023f50cb27878fa7cffde32b320a233e404ccc468cc4e1bd45ba2c6101fdff4061cb412b1654757521a27522640d112f6488d8aaf1c9aaf952cf5192cc02d62c1e048c13ce88d68f8e63a79cb335da3af886155d90501f160f728a4d49dc65beaee7f10ef9118e304857321d4fefb0d33ef9491611f93609fb0b2f5accf2cbf6ea2e29d1053a60c5da6d5fc17329760dd0d803d84e57b83f43e3735f867ca6c1c4a38d1b754e0833c3fc529a9f607e682a6953ce09ddef80ba9f53cd9938f870f2c319466fdc37809d3de4dbc41de318635eb495f33e2f0de22fb3c9cfd2a6482ebbc438d22fe6e1b7660711b459dbe997927a3ada6de0ec6f754b02cbf2ed87a5411ccb34041433880fdf877f32dbda02d57080416569505f521e205aaed99bba17bff89f6180f2053f8e83dbd554c1185fe4dd5c1f56bb4616367b545c075b46a2732a25e15a7b22b73a0f39b955522bdfd115676d58c1b3b16448c632a18b244022d76b0acb332ff5d7ee7656d0f8dd2e4d1e0eb3bc64cb4a8dd4a120ace6a3151ffab0961b702f26a7908a5076deac90dcffeb57c62535f2779d64dd289e5faeb6905bbaac9b8d746081f1537fb9cf505ea48bd30b1dec673696355e4f905df60fbe872329f6ff536a0a1c87fe6e02310c162e130b4495312ae29d26bb5e4a8864baaed0408450f16a843941348fef7f4440dbbb809e9e424b5798e59f4ce7a79bb8743bf97aa0bdaa100a2af74ab6abff6ba4934601b6b3e154fa6e06d425f00731b95cb8dfaab99e13b00b1c72af486efe15e76df52a2bc090f91689a7876cac2abf91bbae37df93d8da176287e7a4e8cc3c08e6512d6eb7825e4974b5224734a4eb265fdad73a664c2ee98a5a5d5eedd84bb24bf9eec63e15a9cd65b3bc0420330971dcceeba78066e67c0041465af8336146fe1d9dc92d12c5f5a2734ec8561c62c69fd797510bb8e73105aab1fc06819bd8fc3cfc75a9a634f48056fc120f4028c261708d5eca612b2d16beebcafc97fbaf24f1b0da116a4da95b7055cc9c3ac9a68d22016fd4aa13498e0da671f732d8bc3b17de03b0604482d09bca8a14379a32f7311d819b183d020510ca4d118c50b2b90fb861b61e5ea8d8e5707a95f149d5c64746ccf3c258c783bf5fad467e445ef48ed43ba0382872b83e7a443801b86182d41a7b99be0b55f02ae0ca0db706770d1f9a600ff78ee975c3618ae0ceab4fed0f62faa83b44b42c53f21145a114b3ef9e2b1ead0cfd3c3a4aad6ebc2a1f4c1ffb4fe8c53154bf213d85dfccfc2529894bc24c69010ab8910cfbecf03ebeb0b58a25481c049e8534621b851a10324356e494d76c2d734bb72e0a8134cb63f0332cbc461b725b62fa432561cf5383c41d4edb75b74b98f19d0d35e23827012f555f1951d7d5447065d09b456b4181347d6367f0046e144b384ae267b937107aeb96acd0e1b0d3fb670378c2c392c904efe848f9d67cfa37972fdccded55c454000050def63f9e1f385c27a2bc57ca961a986a418906a3f67d4be9be51405b99b74591ce0deb513312993f06bf459ee182b473f504d512e4e51c6ea7b4b64d11e03ef68f6922c9d5093cb3022feae63d789e61317eea205f84c06d93cfd9c253bce8df9b0e2b0a5aac985a94eb138222772fdcad7a49753f7f4aab2754ad9dbd7c192fc90d2c48bda33b7482c6f58ec54b99f128a7e06ade2b26b876089eea2c69411d9be110ee69b77eec3b9d8f7f42f71cc39f38d8a1ae8c849e6251a83c507aa72f262c1f65ddfe372453ca8d9b43252a88dd9e1629a157363cb3441ad46111f9aa3097e5103d46b8d7f0a5c0eddbd24549e047ef6e12643404169272d794608f8a0a8448ac21b3408f75a8b443621aee1c2e1942c122f24fffeccd38a6639f713948ef263bb102ac72c0fbdac5e1b7a836dbf9b3caa00fb6adde6c6a5c7f673d7a1dca3edb85626f3912eed51f4896295d36c3ed08c93362ae2b99fdcceda46c8d0e13cf2155bc2d515b5c1a166c4c8c27979b0faca3c40940d24569b2e186e4dec04b3dbd4c3d1cf8c5b379618138de0569acb716dbe028a5f9ce4b2953c2ca03b7489c8eaa3dd50b4df82895da62c3c59c6a817ab00b08668a978cc8b5ddbff6227cd99f8c2d9158581c0f7d2cd2a33b62f0a90d825bd23b285031263470a818cc48b6af8ce45fc54dbc18e7377f5593bb73c49233c0ff71bf7881db559bb1a9c81df8e47ec2a3a9dd81be6d1ec3ec6f74b83a23f1393ace6ca66e225bec9e7789037d819034b9e8efda5ced125b84098af28427cc5364d7457a2d19f2e787045f0f1e25bd8c2849a19205e7c75f9040fd16dd72133577d0c1b53f816fd4d570cba3220555f9b7e7234c8fc5fb1f7030a3536560ac17b24c158a3fbb860b5c4c452f4fef9a744bb02d08e2072e2d03ab88cb1ce2e79bc728ebd4b1de7919f24366f17e2a808b95eb705c76ffbb0a790c24c69740b89d47c7a17f5b20a5d5bfa19fc2119ef8fc24dcd5f388b29b562b6d429db162016c3b16b60cf6c39f7bcac3486c829e7842d089979e6a22f484d8fe0068e1e33defe024dc756249b27b997ab037a20b8761e16be67fc464e252aeb994054abd6dd78db6bbde039abcbd8565d11e3f60a5ba3ddc8222d87e5401c574508353571bd82f00c817a7c683ea400bab25160c6083a9df6715fb988b2ba9b300e85d11606dd9fde9e50cc90f97cd711b30acbb226b525d263e03dc4588eb4f748c758c7e06bc9723b9560a4d798815dd3b3b13f3fe9eb437fecf1fdf7d7b889c6eaebc2c71fa6a3caf39fe46e7e3fd968ac506b3b2088b8572d0d8967287954fd013c2157a0d7e99e5239f6d09dbfe824277208d5627888f79ade7cc87712c8647a50b1944cf297411aebe53b6c3b3c47cdc112f494a85916aa7a595c8d0c9296aa9b04b767f28b64e932fd7366cf3fba04e74a78418de7dcd52f0f03a48507fba3ec7bf079831974fedbfc0602bc9b5a4dd532d510487e3bd0364292925b35f361afad018b81fb3b4937bc0986cd71344c5d53e3b1e451acdfadd2cbb1904d11504ed3f60e930cb12fc77a1ebb657faa2909700ab2594d87c84a39b319745b681d766f1137e6d9397c2765c5c8ce141544c3fed0e3ff850c382b16483824f03a64a1e9261aa56223cd6c4243ea67d12d1f3b21264d3d88ebe563e4c16be44991a3a15892df996e08ddfaad220d9aafcc17719f1c1be4dc825dac502c9b0e8c26a66a1e0e3abbceed3521ae268756d1999ac171673d3db90c812cf1ade761d1fb05dadc85294472f63a3a46d3b9fd6a69dfe23f5a76fd5ab81f3d3b4aabfff01757bb1cf4fe9286bfeaa11de1c3ccd0e102661fbb65b3c9e6b9e10322280571b39f70393e749c6e29065e8b3681e9ea4ec84f3150a97a9deb725fec948488afa5acfd3918afdf2fda867099b203e30923e4d99a9defc84d7fbb12e15fcee99b83e0fad5c24be482391b399e8d26eb7ac45cb5d00fe93f3b73f4feb810550f38e7e33b7957ca18dfc580af8b5f4e906d6730813624c5ff37061fe796c044eb8bba01ad54d42f81c1a13b7d695bee5a73e8467cc2c78821d47a62b954c8251012737d4faa52223954d64ce7057273f26f748d2cd0553b123d123ef8f60b17e56d6d3578a80d4e954dfaf4020a2aae32d1ce8adf0c779128b071d3999d7f6c0634a272f0023625f8e8b1e90e60d59d4a30ccc9d42472fe0bd1a820c0d4f1775e3e5fa3998ff40b81da85fad2c7df7d654273ea923c1bbfb58470c152ab8d7996509cc497db595c4d692f311dfa260e42099188ca6969b1dad76bf53434297ac7169c32119db80557aacce816f16de6cb9c7e62b52d3b77219755d9e7e96c9268bf78b6af7637a00454e37b5c048418c27b12ad4cdc2685b6c2093ee1ecade490e936a8708d7a41af0f15a6ec778a2c3cca931b7ccc34d788c68c914a38eb4c76ebb58e3f2a168531bae7d1c5845ee3157f689f87ca1eb8c716c08505c9ef62923e2826633bb3e4e632847168316b709e832a34c7cc5834740788c121f3aef1e5146661794105d52613fe53731cea8af6736553de1570a6922aa31527caacb18634050fec2884ae03c8911b4e83c534e33a32e9ad416866f0b4a75f7d0692748b32a53e02d62e9c19941d6cd6db07c79ffb99edd8d54f0e38e492ff655341cb283eb54899b26fc22505d452aebe20f9aca93379f8e4f63852b05d01954fe0b18c90cbc4dab613648ad18386800febb49629d640d94cc936040df75d75d25d2e9e9d14c707cec7ef2aa0a02198d54390577c4c93916e0b8436eb4cd57c5ac23ee27e07950ef44c165d1c28885a1cffa3a208dc933957a6d01717554321b4b0f51cfaebf76a695934a69c92dd611c8c5794e6c0b8ef3b22ffc31cd027b0fb864276f4793bc350404277e31093e2a36930ffaaf608ff492e228cbdfff9e7c8c09168b20e2504b71ca4826609bfc76ef891820609aebb60cb90b8be01d60e91e94027257341bede912dc5ab97c5476dc2cb09efd7f0715b02d0d02de6962792885d6b8416d6ac1b1c58288b34dc8d6744d849283426dc093e10f1d80c902be5ca47212c2c7cd9c61897298f74041d6e0dfa7d154bfb47b5036b0fe86ceafb975c8feb4ed420396f2bed7d2a13e7e113948a48a6884440021823e168cfdd4c9c94d3114d7dd05cc68fee6c972d9c4227b9e39b74b39395d27e0a24b6afde4f32a27fee59825de9478cb8d48f37be11e730f1df2e87bd12f589b6028c900cd26ce0035f3c427271c1fdf60cc1213f2ae76c521021fbf9b9cd031e1f875ea569a5da1903a064d3496bb9bbb34d0f0300a920ac4f86c396ced59dcbed60a1fbd58baa115b80a32f2858939fb129095f63d10cba76b5032643c6ba3626170ea9cb9023d51232da7b5534ad048e973fd615928cfc5da8e9099e9a6c3d20e8bbedecb02402aa9da6bdc1eaeff30c5bb3d976737e4206d45683789aaa758a38f5cfc5e4093d82ddac3a184ca8b67fbe51068976a398d674d5ba2e0d7e5d0a910c40562a33071a9200aca283fbc5e7a1ff31dd608f55856a814f4c659b39b7754ceae991a30bc27273a115cdec9f9dd772638ff8290ec459a220019a1850b7dbde10046bb64dd514bac42724452ab4bbe16e8ca3908b0f75ff04983c6071ed889f15a336aaab56f02ab89cdd7c720dfbe55ada31137981adf68f2b3e49f4c8d2f615b05ff8e2877208926482cde8bb05fdd7a4aec8df954b3612b3d0a809663d14761a22713c6386d2603563559dbaaf5a4efc5e4b968541bf4009ea464e7b04f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
