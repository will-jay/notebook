<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbe41e73138584e2ec6177276ea9cbec83266e4c2c68a5ec34ba8ee3d53954442447503df19336fc59f2f9629f9cdcc1e2d35c11a53ac8624b63a77138d50c480d1b288300492d0b94986a68a7a491e3b8090154f7d312573ae90ce0d2058c090c3bc2e50b57ac594903a60a0125291a63303f3485b7e5fedc4ba194ffeb72b79fd9c0a793533b25b39a9d2f311472c8bda224e14ea73423db5a666c20b5bf72270fdd4a6bf38757a1b163d414246c74c75243d657ead74d95411d882b2dbde93899dae553a92c65929aaaae2f741f73dcaf020348a5857ae4fe8d4e3d799806c4c502242690c48acfd4d1bf5a3ea7d2b9750904b9b07fc2d0f924a8f930e2094b2b6429dcdae00baeb4eef2c9910b53ddac6abd8eceb7e82327ba8d5f61fb6959cbaaab8bce3eeb3aa18dd1c218f28a9e50d832481d9a26381d55479efe531e4172899f0b8f082e5780c28c5f8d65b0d771f3c6f02a4a5ffe78fd15acfc4de5e08fe02e3c25c3ff393914ed0a6d29096d9a3c7f7b56492137110b805d88d31346a44fd53fdf43376a97883e06723fc396a498135e043ef523cb5749704afe2c732e64cb9c99b4e6d3ae456595dcc132da4e0df7f9b4ef8590ba954bc7262373250448a86fc0903066f2b0a61040737f4fa3754e67d78c95a5ba279a8ce2ff53911c513d8a458fb6a89ba0efdb2dffb20da2b809358dffc4ed28b445f2a04e270785f964852c3ade15a34be366945c975d5c49f752bed4e60b1ee8cbb3d5d02103a34c6664a52019d04676645cd758d915702c692fa98f37fb8018cf3cfd9a398ed8f110d3c9dde979bc018095296df4eb2ce65376a944a2aff2d21ea49434d284558969a8f235ae25a6a4464a3cc8b55103106e0abf3be9fc5ba76f22ae7202cce8220e27ac5136cb9749fc1f6439a123b2a4fded5e5c6cbaeb99f0d5d6a2c8a0d4259e1bd2ffd479525375af99663c5323f265b3da0afb37ae77f84892d8551f92ddf4ca6aa80ff05e0d75f9f7de3da679f99b5a571dc963de836d668c6b84495637549704f824a8fe6383f3b8812d83b7abfd0f8180f42beeb5a26c35ae8029f01c1b0a38e4c110928f6142d630c0660a8f8c862912ed21a01c0d880fb8889b7e20bb99d468907c8ce815da4a779a93939d2249f64e39e6c3c6bf01b559412bf47dfbd4d2247467a0ea5f7dc315a6d26efcca8d52b93b423a2577ea707098c549b1d1519193008ba3e0e4c907443c35dd9bdd87c90d50235c6cea2801c19bf9450967cd5fd155f988244210d1cc10d0dbae9c81d1bf5f9e97137a595625debcbdd1288ae3de4bb947358cdc2464277bf4e46ffcc3a605b17bf7283d1e895bccb0c46806d7b6329ed63463693d970b1fbcc9412bf4935979dd4a4e4dedbff8f09550023a27430349dd3f700c03c80c91e06d727f6d7cadf01572e1b9ec9bdd5ade33850cb566255a4ef527a38edb2ad573d2c925051446cd62fcc71add187636ff42c831aac9aeb89b2400d08790add82852248462aa6b5d72573dd142dd88fafdbadbf4f40921724e202ffb9ac8c70f39d1cfc86edf57b0d8f2537ed5677c6866f990060263f46b0bb918e0f56ac185536b502dca71078db583f61241261e6ae78e5c260cf77f53246964400674068200de87f4b6ae339a1195b892aeba019f441f7487f1a0b65982ee06fad135d43ba9f2cbcdb42126a01a0a7bca509a768f00bdbe9e6920e57447acda26ffa7b5c745cb7218c8de07a95767b71c66837388d3d97175e165d6fc7b44a54b6272d2796538cba9dcaeb4cab634166f459daf7f4a860dcff8a0ab0492e5c57bf795980d72d1c76167922ed17608901fd3f01898e44d218bd373a38df3116b3d9aa77369352a1a4f0a38fa1d76f9e67edf9bb341ee5c4bdf5f44aa1292774ae7d56af6dd0235259c397d2423e87981cf70c5c1cd99eebc2068622f22135f5a38d317bf6deee497a685be1ac6105eb5611b331c2be6b0f8e230838182a569eab1742b57508672f5309a24ea79057187e4db719a6fafa997305b1b64989c398b7bf284c097b04bf57688775808dce3660632c234e01fdcbc78828f55aab8844039ae05b2ec7ee494be5d8e05de25f9195634d1173ce46b3df5f48a168f10d975d7bc42c5fb9c5f1924722b561a61ecfb4573bffb1ceb714fc05e4a65c2f8ca3cf0d27e328067d8afe9b73a304f6e2256b20f9219bbe38c0e396894213ce251701c27d544d7600a275a72059818d65c0b16ffeb4a7f3006c0592946dc83a88606e9e4271584c4d2d9eeae1379e109988caa0267cb9ba12f5b15f153d78f83a5d6d3e1dcd1bc641d9648d1846235d83616ad6dcaf6d7c350a6c543f99eed635246266169195cb19339c0ff965c48ed59fb0231735b7ca951c054817b7f9fd947e01213f91b540588bb66d059fe608c1759dabeb7a49ec29fae5f78d2b4e88fc77c8f31cc2467608f428f91b80cd7bb954f729b99cc6a57bbb88ed83ccac411c0f17c04ee560c7530245c262419941d2a23c28e56faef48525a1fae273915f75168b8245a25e664859884db292fa2d68784a48a8a83771a4fc8b8e537971459f4f753f2e2cb05b6cb125afc28e1863342062ff4e347e69d1928c19422a7a49be4b80f4f163aca41d606cb171ed250a2734bd8ed8fdd9075df4acf30ce40a5842119572e9d94edd341ddb4e40e394a9f95692f943c3b1e9feb0eeb2f904230eb544b7cdc19058e2331e9e354757ac14af8ef7953fef6ea77c29bbd8d7af5c007390b0f26e39a63c26faa8c725497bc01f647c047c0ec4d93780b0a005a0875d0bd72a29f764ea3c9ec762129bf121e3f8c822ff1635794568919a8658b46515475f0916478d5ead0862060bdf8451bd1acffd79403dd95e19a9235df19dc284636d21565b239d846bffc881f76138e8486dd40e33a0f0547ecbde37861df1c69afe6f19c285181e18cf10da314e4575e063cffaaa697aaaa7292473197a1541f95604fc38cea491b4620e6e51b4234fefaec7d0990d16f0a4a36a249139ef465f7bfc99818841b8ccfebdb826f67eb36db054626e53b6367127a255a8d9439ba30c512e158307f6bde3e7d803554b18bae5ebd594281d1e3cc1a0a95524e5b8e3b8e0f1c1d9de918983aa460a2156f4aa17f5be0fcbd885aa5694ec8bc8a81894f567337bf1daf770c23e3769b80fd6bb93405b21da5bc498bf930f6bcc19717a65759870a54e57908a5c358600e1d7a5688f107ce24c84976977b33c13f17780e48e8bae0ac35db5612b53eb2c2aa9341590f59e64b410c6d96d072be90f67534f56b3d735fdde22872c4e280a620635c93fbb789aadc2280f72803fab0234509b41cbfc2c7341c43f12e3fc97e73f59041c80db6d954c0c265d4ea298388329566bc876d3df9ed88510c8cd33154deb495298288ef8aaca0d844842e7569927f8d31b851370d8b7f1f7f3401ac8fc8343265f00d8240786986f2ecae851d554a899572bccababeed42e3f5bd6fda79439b9e9b7b1d2edfbaa4c5e636b76b8c66e14d9e6f0517c107ab200d9fd29d9987032adc472f389e22ea096c79ccdfad51889634634b923238a7fdc0fc8eed992be388eae55091fcede2b0d3d5285aa545b5825cffcabe6659a97e89cf47c1caffeca1af06a0f4dc2de157c7ff36cca7e65574382fe4e951565a69f37f7a8c59b14e607bc38001074b66306f4dcef9e71536d0e0bd3f6921c9d7b1f6fb25f95a2ae6177f5d00f60be9d6b9555412b174ad6e17488d73bb6421cd4932047f7c01700d8dc3d8ad9301948307208541e8b3ecaa2807de041e5ea41edf5923081949f79c9d98d2fbae7fc2f16f782d4c83b311b1532216a0c06420f4fa16b73f1a0db254568b22cd0aea4705d7ee7f077dc6ba982317a499e185326d75f1ce2389c57c4391d3037ceac5352298f712196bafaf61ba5d13b77ca2c1b5160d2128e16486a0a03ba5186afbd4031adcc529af896393b6c4bcd6dd8029f58c8e8971f47b8d2e54b20de1a9a80b986225f8da428402458a4d23c4de5e564483b423da48c0b3e8c7224f6ed215ade25e688626e82e9132369ff660c6a1bc927c09c10099fedec5c062dd65f48220b80e0d12c91f07bc8a43afb1d09e1d1a0359f056c07904d2b855d3e511a8b1b762dd3b819cd2bd6fc6b1267d325b545b08630d3c85a44fbdf581d4f6ded271674ad89ebacd5f815375a6fbffcbf098a9b0747c99ca8274b362e726066b6f362edde69863a07adcd3666bc6afd16054ffa5d6f1262e6b88c598fffc2ee2354c534b2ab6e2b480a37740505887abcd58e7fd20f3f78b34c31fafba2164244608f9f82b362dd3a3713552d23eeeb0064b5854ffaedceb95181955abcd7a3c3e090fafe410ee3fcc33acb7f3efe9e845362e1cfb3dd37087e006b9b0363b9b466d054e0f4b37dc086f4dd2e2a98b5590ee132fbad11eeb19ffa9f998878bcc1b14e3df7773ee85d205d607afde33a29f25572fbae9b42a3c47430dc06d156aab5c7891cca1f19ba1ca939416b65435fd7fdc1c6cd271c5f9c3e30c28b586ad2dcbd1e94fb0f8512efbdf0ebcd7493c6ef2c1ed326d2b6009198ebe37f0847e3830ce349fad1f5bf961f1a80da645666754ddfab412d784a0aea929089b92c5cac02da846784f41c27e3bcf1c64120197fdebf19709f6e0ba6e167e254dd7db807b2c19e293ad1cdfbdcab4767827720ebc51463c8ff0cda86a6d2ee150f31ea0de692c21414c9c73cd88119102c3953c318eac3f8483426f06bc21219a95d3c2d4f7d0fa19fc972507e76fe9095b75efbe445848d1303ad6569a66dc629e210bbaf8aad708048193f72fea7014d8cbd2ac485080de35e80979f87538fb27123853cb9c3fe26b57515c8826b762c1e0505c4ef3b75ea057b95e89484f0d155414e753288529f29169eb714745dd59cbaa9f798530edc8954f9e30ba7e06ecdd264ed80316efff5f746f69447de515f1ddac201698b851062da1fddb474297ca8dd3e1033459324bae84f7e955b458ce69d4a7afc32c5bb9ef87ee9433d68eaf02432b14f74fcc5339402496efc966c08b805cf29ac550fb2a206998bf08243818d3f572f94c7614208b244df040cf3fc493404d0524e8bde67fa167be89e5017484c84eda2838a4b4a2f205912f510813a2b51b7fb7d1667577447b62fd4595980ab871194de622ee9d0b50a517c3058ec132bb758cfe9624dbb7c9a31e3f27b43f59ae6c1413cfc267f174c9da8cde7128fac59bb8c1155bbade85cce4d8eeccaa398c65efee1e8b0f1c43ab47c5a2d63fcb0fd8114fcb3e0b09ac6975193fd7f7c864fa61452335c09e9fb6a41756545517c7a046f3835da3e7984907aeefd874f8217085df2378bd7b46f6be5f10f23220d848b32df0dedcc56012a90d07b8758fafdb4d6d453d7694245da3ee91f8ad5ca3b8d3eda97fae79eb61df34e77ef66a440563af7b8f00e1ff92416ac43fdc85caea4a6cdcf512ac4d482485c21a8b9db62b60f1f502d1c11c3266cf3226731f18e74ed0bc2d2d23f5a0a7249d5d829302b3600a49d4dcc48b190e81a190a1ca8d8f302d654bd2abeaeb4596cb9518bb8495407cb3b185a011e2154db84f08ef8119a6e6c40969728962f1f7add4364d0d2053a94e4566e49926b5795ad06ec089ed0e25672e3aa09be113355042d9c02a758d0e280e724e33288034ea4a64b451114a6cc24df8a1cbcc021e6e8e371c3fa3fef08024e809be8983883d3fb4b03b676f864dd68752cca5d0f78d5e83c3a4f705e41b61d966fd3fd9572816445283b476b963b69cc140b223f48fdfda391c73d30801d063e5a125e9f8da3093dd050d021a40ac068092faa640089889f9c9d34eac808476096f555d42a95a0df772c55fc5c29e39675c2a723b441eac5d0fd7b2cd2e4345ae77c549aac18b47321a637f5982caf7bdf6160e3e2d5b54771029d7abca58e4cd6f0e9d53f9f46ecd795acd833cbb8a9b112b04c0a64d49a27f9a599d65514d6e965434abeb057717e3af9cae48de12e237026b4abdd56c8a6c563220060265a61a4328c822002cb6c0fb9fb6c7d1be1daf06c750e5cec561496a41063c3598cbd3d7286ee995143fd28a82e6e5a8ccd4cff82882b392f2527ac16f1e84f9cdab422e374fdec2f3f795a1ef05ed040d851b471f5b2a9041e63f62573a7d3d6c608aec23c95bcf78a1ffc12377bf977a21e0cc8bec5186231ca943712c4ff12a259e28188afdb9fa13c168916392d8eae342d62e5a212651aefaea8a7b02496db82432533edaf8e3f467be1874b7ee9cbf1c61a33ad580e5464d110ce00708b9231bd43718a99cc6e997be841753391a187e468dd658b2a6024356a8b0d3c57ac0940484cbc5e1f5331b3ad5a3ba47a2bbf1430073d2c7f78fb8576e936e0062b4e977691951cf67753f9de5caf8054b509b9d6ba4cdf95af3fa08aa8b4c482f757a6b0f17e499fe89806605a494ab7b300e64db856f5b9f066f1af30dc17fc5c85adec15a6b828fdeae1e00fbdfdd9a5e32a6c7413c0dad290f7a5b6f0904dee0a251e0b22d141aae5bd5e1516e0f8b7d6f1b4bc56782af03781552e230902fb8709387b9c86075b4b69585ab28d11faafcee5ed36dd3fd09a527cb93e355f17e0e0b26a48e3a11d4817c4cd3be025c55f34549f7f50666c6b798f77345860fa7378732eb626166da8e1a1337501887c8ae9ef096c12b52551d97ab6e473a2b8d286b53d39789558bfcf24e7b945cd50345f6e0523f59620c5a9e17082e8ec3fb27eeb47fe5951bba3deb615bbaaeb10e48b94497b4bf71cbb22f10f85c4a6cc44959f6736d413a981c5fb3105fea5f72343a2ecef4b88d3b54ac968f3104f3cd4d95d65f5a8dfdfe1c443f309b0ab0b73a29c18070a716922b1a2e6b9f4bbc568904c5e3d5485d928e305cba992d8c69316f0f03305a416e831150c8f7c613ef66b1894704d87da1cbe534459375f6d419e88ec93da3ce583540d9cc3d43f244e013fbcba203878db1707747757a83bdeba5a779d0030fdb13d216acb03546b517c043f829dc11e4beb36177cc6205036bd95a87be19144726151226d8f83a5ba570ccbfa44534c8a00f6ac2731f6091344267db289cdd239b621d9b8d4fd7a272b2f09c5822c95fa43edc1af89c38eb813e051d2443307c383cf6bfdd725feccc9c4253296701fb3cca97bff16f6719a2cc150e183e9ef5df8bc31a742549b16bee5b0f6849d8429e3f844de6ba366c18287a8c012f3c3a5a0222aedf7f428e8d88bbf85b5dd9830554945ac3ac3afd34dbfd38b5540eae80592ec6619c726a2fd627edfd7e6cb1252cec198a46407d1ecd86a2fc29f4c1e46fdd2a1f3703957036c7b711f7349bc4a70a6f7396b4a338debb4a3aefc4fc0c9e6241a04a5e87db3abe109c8a9d9a0f37a6afbdce879e9912ea71b682e42f422977b8585d194c9522f29f48e6b86fe02f48810f6ef3bfb483525ffeb2fe9b75e5910643cc550b4f9c275f77165b0b9ec837b54973b691314d9c5c324b07d5b0c18503417253e450b2aa2f8d8cbb6d0b09433379ecfc82781b6103fe0e5b545781e171d96f88d8fe9206704a3fa3945a2372347686abb6cfba2a3f687d0985965dc980ddabd2203e5393e4370201efead1ac0c6a7cd8a8f490aced13e8ac2a2a74152efd920eb718b48cc5801330d05bf70b7599b1f8daae46efcc637116bec1731572fab120e77766714ea2bb9ab6c4d9593c4852c6bd780db6a86951d53a3e877ce2c22946703446c407831f64f3207ba2a049c217937658269895c0810f03fa7928820ce615afcbedd9ceef83d5ab9ae0d8f18e756a36a20681d42d34f32ba19a64494e890cd73fc05a02e7b70055989a8362f568f5549435c269f20bd4c93681aaf6944d41505d6f109f2a30ff84bfdc7e97f49f1df3f9a0eff184b1c4769a039c2c0bf1b906a72ea2d95bd2a19adb9c811f5dd8b547613535ba8cb9ce6f9e1490df8e26a61e0f3dc0df5af6a4f1ca8f981714173c6c85442ec3c1dbbb44bf09d1c6bd4725029b4d2e5e21c673d215e48c5f7789618f9d863f338cc4cedb60e6f9ebdc5c412804fd2d791ddc486816d565646de3ced973bc2b31b42142dad19d77e6e15ef57af1bbe505032f477aecf837695ec537b41221b0e43e69670062d831f3ff508587daea0345dd385cff53c7498a9c4dffce340843a9699330aac8342e34d88325ed6cdef8660c81f510cbd502ddbf33d51bd3447302aba79d3a9ece15d1dae4270a790832e76741c9d35d0538456faef400bdc71e27212df1cd1bad5abe319f4a7e22ead3c1d72f2735e06fe607ba744a94d310dd5b687ce61327809786999cb505a8b14a8bb5872be549ae5cf1103d1e5882337be297bf31e5726a2dd2666566a4143e5c00564be2bd8a6bf54d8f3af4cbe8fc26b41969f4fb6a29b6e7280e22ce4406ff21332b7bfca6c2e4b6f88a192f7facd7a7291f7846722f2ae771a45a4bbebbd6ffbd74e9951c74caba2a8d595f5baa34901b56aecbb75cb343d2b4b8c81447e6071bc28aff884bcdef74c9118947e3d2f400e83bb62bec26ff5775b60888183ee6d5bec42e7b49b7fcd9a19ddcc96a8beea4bcef8b96a3b6d4c5fea4ab09a02585de041440b15941c19a8b0a5f368a45e685f6af9ef2ceb6e5541f63339ad76419d7138c9a781ae623db7ebe6d7e6e324380d959ea08e994da4826e57670026b693a3e4a090e606ec08aeca7a0015e0595ae1412ac058231998f2dab85225c0b134d9e6a9d6e2bb921d64549cae2a5cc6a45300b42d108e70906a91c5bbb367578d6ed91e26a01e05794d9700acdd69c0f7c6839d881f2d4a43621904db9251d6a97cf04780fad57cafc8444378d36cd507d074fd81ab09be877e85fb7dab85c95915666b1a781a0e2aac5b4ffa3d833820fdeafac7944be43096074811a8df46639e42261b5dc7ffcc9c21e97876ba986a2baa733ce967c38b1bd033d4269ee305cc36425ab74b73fee26eca5b3241e8a53ac0aa475922ace3612ed6d866bbca711df90058998a10b8741f30b0bac804f68e45f53d153b1089b926f2994559e83a24e35561bb620e72c7af3a532aa3452fcdf82871b101c802762aad870992cbd72b35e231039c47353ec4a2defdb5936e0b893735c0b445d8f358d4b1b2b3d99cd70d6b44be4d718aae776d87bee7512b424f5be528655b73ce77d8367bd563cad67f96fb822f76f7392e5f08a5b904d9f39fc0a38ea9fab1d4d0e1098c073da47ccfca75a0ff737b0faabd4c0cb07e33ce571a7db3ec97b59f797dce6a768deb51310dd3a02ce28068cb05666e5343f85deb1b8de53bb98735ded8236721863d4603115da40c399bf1d6c0371878335f2552740d0cfb20886cf5043a14026cbedb986a617c2ffb9e1620afd9b003b674aa8f6e06aa6a2169233b50a773cc6b519582346d1377f34168fbb15d4080d0eb09e553a0427a41c486fc9298d7613ff65bcb95bd5d014b317f717425b0c420c1e386ac950f5a7b6f4a670d800a607c27ba3ec9d677eb05313486ad5cc27cd34794eac56026d464671fe1eedda2c602283279a5249afbdbd7eb7b32a7fe96d044ee5aae28f14397a36dfc6b489651488495de322d3804c9818682a5253b808b93916a584639b44d6e88b08ec03f84fde07a2cc4bc8ad9a7299452c9e680e8de282bedfef7bc3bdd326f1c9e73177a9fb9728f0d341c1deaa238b0e3a36a80f46bd4e33c292b7af6d211abf1b1973810e12403f1341d1d281a3526932677d8fc391b46ead8f83b97ee44603f47752571cabef6baccadb38663198304ea9be79363f05cdd346a4f8689c607e05662511b4ddf7b6196209c25ff8e0167587a9405e849831d3eccdf37261e6848fc14448afd81854ede42bab5f1a650620a2b195f2e556234ffb43636b6fe6b678c0dc37c3c738e5e7995a55cb8711cf9b86632a613ca9ca773720d8cd03ee05f168e046555c9e08a45c5e6556f80bcbf32205271c62aa8e4d1c1863e21665a7f003600e0d67c37bbc02fb1183854d5d6d4a489f20ad2ab69cace595945af0fdc02a8d89b4a20d0190887d44ef2aa38e7421134f8af3d5c4c9f177c0a10a48e70f0fd07d11247a14077b109353c14bde623d6588b1002131e0b718fd83c674e61d2585e485cae06e55593c0e620be336e174e6c2e20e0d1f93b7dd081dbd499f9cd6ecdb96aec7ecf5667a351244a878b011782377c73a1249b2521a2d23c8d5f9fbb73d414d49974eaa4d50059f9feeee476119c8452a5c25519f835c2b96c6ef02b732c5554c9a5cc724aa3e5a1443a7ac7880f3ef9795d820a0ecc935e13dcc2ed344c07475ffb06b8343c639c561ca2803291119bdb7e141ac48b7d6d805a01da000466bafa73272b5716e36f9470e64e329d73693397f8f35e76a9d78faeebd7efa29e3037945b30509c804190fc4a9687421523fb4017970e47498643544d73c6c20f2b5a50b43844ebbd4cb427ccd0a770d8f17b99548f9c5ae87cd772884fc8701259946d7a265cec514b4ee72d3b5ff5c17a9c27caf2db022e62c247afd832aa8477da50d5b264a90fa17f3f74083147be63ab2bd38c27e5c55bf4ca0105d1e95440899382397adb6c59b8119f9bac41c6ec24e7017728d2dd81926784f6432718fba261377406d8f75a32c0874d9c0be0a0e335c55765603d24adb5b9dba3f22a22f36aaac2fcf5f3e8dee21bbc8befe9a6af33e45933b2b067b0a2b12b93655917405ab8d0300546ad3225c17196d27c51b9a5eb6fe3a67b5133e64384dd9acedfaa2fa804a244cc7b383bab717ba2ee39cac2614ffad6612a9feb434f338aac201d4c9e5a4dd24f9acc04a2a21ceee6f3b79c0bf5b184b11807579efc975084a6c9d5aad36be2f194a7cacb713f59d8976888585363ea87df4526f3eb166779f0d3027f9a70611cb017d3b3a2ce9f28d7b27ba6404450299313bef7fc2498692d5966519052c64d60cd79b99f7c42d64f97f79494b06de7b43c78059955b0fbd09c5b2b4fff458d1750d66f7358824366cf01f6c9cbfe4c2d7f64b4451d8d1e457fa848f58e800a696dce2076f3204ab02d294bfdd2440720312b2a6d22b78943492878bfdf8c7dbc9ef37d36b99008a6dbcca033ac4eca6962f87dc09512ac2b16e8525e69c8b2f3e37dc0daf9e31eefabc7f42696e17aab8f9aa4e0f5c328c291fd647251c5ea6d79bca379d7351e69a14b33cc091b6c796de452a9219f17945664e87a59e78399b28bd719f2c36674afe138ba4bf3a23e5d36c5212a485d8f5b09a095c28fc35d7f4dc70b224114bf8ffde4622ef5fe0898b24baff04836be33d65e0351d33d3b4f3323490fc8791eee2d93ef296569648ac3a537b0288997f6d03629cb72cf01c6967c0b6eb5acac2925e6dba81d6670af0738ee0d65164029fbe58a524f2a47c32ffcb5d06a4b33960b1b7fbcd067019585b1a2dbe3e64aabbafe8618cf8f245c0117c5158b394e916a5a0167a013d87ff37f365717903f0b244f82cca4215ce479cd97649d16bd7114f4ac1478714cc8e4739300286f2e843cf1d8b97a644052078555fa75bcc14a02c4dbbd5e13e126416297da4f1151e38108c2b8aebe7d11d77c879c35ea51128841e5c529845ba5a28d267bc3557a5139582d843f08e966843efc74e43404099f80d9a91babf04a01557f4cc4edc81c71e2f16c237fa6e12387c14c1d98e72d265798bfec5d9ab76827095c37507bfc9671b3dce6697eb164b9fd3b71fe94b302de6a7d71b9df72a346ec54b5f46ba428c482c2c4f5662eb10f7527fb363469c0155472301839d04c83569d7979be6512b3eb4261d99066f1a7b95c68876414551815ef247eaf412eb37ced7e62d17c66c3f9e2018e371fb8619874fcaf539c73e071ede834963c55238c9ae47d5436b1ef9802f5bb3347886049541be702785d1844eb6375137999e1f894a191b21a1802ea9ef71a60f65a44e693181c3b0edd9ecbcf2cf93ab070295961f344d8eaa28afa2b17d4e3f6770175142f58bde0d180ec0a0dee4c9393ba45acfbe777baf46e4cdfad9c2ec21232c2a11dab7b59868ecffe6b234525513c400e169c78fbd6ace2fdc0af2aa9e6e3da4f57ca459d7699fb8d38724ac43959181bba07b7463f08d9a19f3b8eae4d91ca2d946bf6a6b6adfcbe45bf86797ebcd210619d1bcc761f4e16ada50d96f7ef56fc271bdbcf3f3cc146e144839e7e3ca59e06d1fc1bc0618d3c1ef02c503c744303806134f1b9ab7b39b38c1ad42332c143295243fd5514573fbe338f37877d9d5c98bb476095816ecfb3f6a5e59113f46ee47e5403bbcb07963232a9b1639fc484843a8824ed170b1f96326272413719c38f0b533dd420f6f224d8de00f0d36e65bae7e1283142ba956376879922311ad451e8ab491fd93a2fdf46ab8ae7c1b45a89b5b5aed4b22ae7846aabbe773192614600cea84e0ba5ae9fad268fcfe04b8e48a37c64be2d2d4426cf5de60ce78bc297dcf6f29ddd1e31485a70042f3e982aada1bcffded8fa6271338b295e9b38ba833e197773edcbc420ccc5c493cbd405c7d75b45c6c8c19ffd237958b92eecd684997ff6b8816237ee861e9d62fe9e837242eeb94e04cf28bf4393569ed8fd99abf85ae9282da68903a4b170744e640a922c118b1bcbbd18d74f8110718ea2b71ba39f21234cde5f7b8676d49f6d5b75c905e7c32d68acf7696e509a61001da73d8656a056bbbc07c3f5a21bb5e799d518e07835f31e81de7987404ae2f389f344acbf46fa01068e91ed3133554cb9fce29848ec110e8cb5a24651c9dd2dcf09b3a3768aefc3a56651dddf6024032bce714ea253866d0bda833ef5d2650a9255caebc26bcee91ed9571d82f95cdd2a140a765a3f5f68bc88c1df41c6194af187a9374f647acae01f05089fe6e3f7b5d2e8a40a5b5fd0c6cfdc6e5243601f9e3d79ff000c3e63cfe488e7a79e3ef0afc37138c7159d138047ec1d107d0c3cbe8ef040d07daa37531ab967950492084c454d25571099babdb4ee3056c6a4240230225eebcd3728d82a2e537dd60ff93ae73c47a2650a8130736a0a50889b644f283d0425d23f3c329ba3581bd2811a06bceddaaba8fbbba05a3e4d8df25fe660e4ef5a557d59c30540e95088544ea15434cf27d79f5d4b8dbbf118aa5c5ee1f75cfc6ed55e18254052600214fcca3a890db91de88d1ab48eecf2794cf28aaf8509e19e1c085aac6cb5fa2a5b17ae61ee46f27d2ed889a37477c9fa00c781e44636a09426ce0acfad7df39d1cac59dfb16731045b735a5cfb02d03a50aae38ac13fffed7cc0b9eba5042ad1f03dcbfa47c300c8c18f8ffe72d48a8674af4a1327cd3ee57e26025d9f5822163c13300c52b7f112d567ba48a1041af357ce45927703cecd94121c6176b1445bb63eba0b9e6d1ca4dee29ac190845d31e3c0885d5b553a940e76e2b95638676bdc0530550479fc0bcf4b15f4413695faba393423fe8f0bd8dc9bc5e13d13c8c07fdbc9f4f8ca4d25565a4a6ef8e264416e18853e9630ff50fbe3a80949bbdc20eba6f931ebf50542557b9d37e9c2b21914318e7441c9cfaf43e49f724b8a84a836f23d7ed27d9dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
