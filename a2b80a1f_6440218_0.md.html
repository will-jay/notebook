<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03406808243ada7bf78b580f491be1eb06f8d7b20bc32a01da86dbedd209af03ffb73a20e91da58dfb3ee7210c20b367895165ef3b61774df30aa12a2966cdb4e51aa637803237d8d1697b0c019a54eedbaa959297e22be6451bafa9611c65dfb811bc1bb2763d6ff90091c2c6b9ee3b25bade0158b351ae3e010c08ed7c35ccc76cd243f4c30c4826c4a973dd48184566fd5b18e8bb9f28dc3f43784c1a87aad3e6859be76da4c1655f9bb9ccd92d595ee09ba58ceab82f7dabe7da923795722a9ede9806111bf6f282e8ab9cf948c3127ff7d7806cc39fed580e491edf1a9ea06a7b9fbc5c458fd4b8b061b5032dd38c99bf683129e7131b8881fe250819073478a4336a8d818a8e24b913b3fa9e1d4ae72bf3ae03e7d0810bc1a0043de11434d24ab7c09b62bd645d19e3bf6b69c32511584721072267d4b1a21737fabf0653cfe8ebb4d4b9afca82512fbf895a5d847c9fae57b739fde2761c6de7f54b0ed662bc579445cef55f10a87f8141e407dfc68b8b284399799f6514b5078d0f175b18263bc002f028c5adbee70edf38853e8e4a722eb28365ebdc4906eecb414ac28f099a599f4af29f0f307e9fc5cf10bc9900a35d8594ae163bedd1d0171ae168d95b485d16344580eb6cb90145831c7c4213be8d7eab3544a8e553a42304559ed0d65e5f372708bb6e26318325b2c16984d2dc7e8a7836c0f4bb45068dd3ed176aa27949880d778ddf224e478f0758c89413fe354d38a021b45351bde9405493604d441ebc302614e4e7c983d240264b80ba5f9b90503a08e36f54f716facc8d0447af77e41767c89ff17342fc03d2a6f334486bff71cd9cde9eac9626e1ad9cf33eb7ac59a3a761b7c8dc2438c041062cf7d1aec3a2c2c5252439d1ef6d9cc51894607d183f81545dd6d8e5b8f6e0550019159c7c04d473218fcf8d9f61d72ad1aef1817d6f41933594f0f5df35ab9cbb8d154dc96ed5023c557bb3675353e903aad8686f398ff5f88396e11f38c20cd3b54648b526fe37f38880133c942f981200424d2a5737343b0532e72df2a59b0e532be49335e7408bec6f57b0a0e585c1ad1402be342dfc070d1a4853f386dbe9a869acba7eaffea40cb1084a66160ee130c4ab26b0c57fb2abaf1f24d34e80538b140b035beb843fac1564a0b10df4f1d6d33263093a019d4723acb1ba9a7be78827a5e7d938ac73a2e261f070483e5235230d94c933c829f3117c3198f6928dddee3122230735db56586c152beabd7601afc6ea291d47627ca990a1de0b00e66c4ba69739dcdc8b4791ccce88ed86aa7e0886a419c85988c91eb92baaad9169a39ee13503d6bca43a8dd8e492165b8e1ad7ed884d29a2302464f17a27745c7c27893dad5627f102c31c80b1232f59d1928cccd30caea9a02b978a8aec6602ff923abb45b482b0a5aaa5d9436cfc0b52c50a8187452f11197d1ff680f8b5ffe6828a06260718a6a9ba24c2c4415829c55b202d1da1062fcf0eb0f3642de1ecccf150b689f957aecf1b2615fcb220230acae48d5991b631d1c5b32de1b344e875defbaba2ef7b49f7d15f9ba59aaded8e7dbff1ff8e416ba777dd5e813fc9273c3961c386355667af4ef8bdf0c2eea7bf836f6e7f3eeca00055a8a0277405649f4d53758612737a106ebf6845129fd89eba80a13c9f328f841d6a909d1a7bd3dc99493af9bb77999077a49a03fe866afc4f8057551f54bf6706a90906dc7ea43041880f5223452f6da81953fa5152e21da87d24b81ebbca1f4b56b58bb4ffc9af8ce6fe0856b0d085514b73148684d565296d6b69d28b4932ab41977f096aab74546c3b1ec905de731224b0014f92842ca704a4045e43d69378d88ba6d3e564aaf1ac7a5e1dd5efd06765b974460db5ff598348f035aad23be72ef8dbe8378bd7bc3de9019acb37c48424feb4942a17f3c6b20c1d38d9880422ccfb2f2022521b30f76e0622e06e76b8088e84a1a1f36c76b137661235db6cd063ffdf0c17f1b22f991bc9ac06509b6e55c13e04a8271fc97b2bacd6280ffe6223279d6ed18448052b6bfba48b4b9961b9ca9a3501e14108e78c730bd1431dc76b8a75007685208115a5c8380fe9f14f18a4cc1917c832cb3c4e536459a3a2df3e1eddff4624798459d94175d8360d4a2dda9da02504fa2aa6ff89af9ae485084068bb9dd86b1c4b4d68534d3afb7c98742100eb2a8c213d4bc8a8360b74afce8f4c9609895f802f0073fb0bb1d6c4122a71895e2b119e508f0806e7a26fbaa7f92fcd5fbb78e652bc8c7c4372c522a38ccfe8a153272ed668cf9ea1ee1e1591db1936c2c58839134f19ce2a1babc538833bd1036ffd9eb789a141b9a9550cac0b94aa70597a151b5ba395dbfa65b6b572aae1c8ce4c608670c8db3a77bbc8c8606a852a631d627a52d7edd5aba212c4b6f3cb56d38c999462ae3c980e796c4eb3c0039093cf3dfeda371b547ad3fb066ca33c472ab99ba286a738eb97c4d863d49dd9a6b2430674e44bb9b0aa262d3f93905690aa0eba6f36220a57044a5e1f139321785bd3b19455c22025d4cc80ecd8cbfe6445dd248f5bf63e4491b4bb6f27e6d4fdddb95b472b47d8637c7edfb346e437c78547e096d85a86edc13fddebd482d6938c1130d364ab8da6f5cb00ff50ee95a6bd6d66b01162ab1de2128527b60d3e06e49f9dc3aecc092b3ee42308de202203c798d45005eba823c2a87efa0fb401ad5616acd9a6307bb45483f3b8d8039b891692f5ff1cace4b394c69d6540a5387c4bb13ea1d6b0a3283e289dd8bd327370b5bf1c3d4e71adb12f909a084556b8f25eac429e5ebad34abd394f811cd7dc5b0436d8da124413f0cbdd600492e0792662bef005ac8cfd810e67db0f47f8e4689de6cdc226a02f1a4d50db07e742c823ed154692a367872ba6e6f03efd6d329967df28b9165659454eb0d919217def147fecc637476b1d6e3ca9c713ed4da7adcc71f57096ae528a01b64ba17ca226a448f71f9505d13a443f28585ae30ba4963f9cd2e6757e48bf0a239c641cd4e90faf0bffdc1903548977175d43094a8ceea094c07d36fe74cb284726656383350516fff5b4b94f67e3a7bfb2c22a8f2ef26172a8f413a6a87f3c9a806d2e5ab2431429a2d8476178bec980e6e7c883e8066e5837f533f2bf696eb17115050b5a665eef28676ac4d618a673fba66c8b388575ca08b6d4d9d0b6fc36fe4fcee178c87a3bb6ecae265feaf4572fd70b4d762079d63e4133b52bcfc54652e38345d27fec61d4a9d3ee1ef59f87cc1038436a412a5a5217a813c23d22a3d275fee6a5814fa332ff04e0bc49c8ed9bbc949f1154ab300ed22d895a7ff20c3894696e22ac9239e52553c399f48d875be842730854d2e4e1710c937a8db72d3d72c849c5428f7e36bd17a9acabbd8cd777dc8ec1d02939214609ee0c2bd6abc3765c4592c07909cd2fa93445e2f42e3f947d3836671c22d060e75d93683d99d655febb4aac5b86e2b5166ec4e13e6410d784412ad96ed080e1ae97a348e0e23b9bdefe558f3f4ded31ba77e34712b58dc9bd2d546511d7cb8107add380020e540794da2105c30a467668a22990411c310e279071332a9b65b949d5708767b944887d4491c1d6b324dbdebf228dadd4a4afe69a546b1bba13da1cf8a698a0c76c442d5bce5e3b5cd7ce60cec63d2ca57525599fbd0b84dbbfefc04c1edbf37cf40556680ef41bf758b9251b69b1f345a260c802d66615611422981e1839c8fd31a32d7306baa144ffb0ca6abe0a0214ded92755fe75b8a3d5602ec3b59dbd39cd57e1316bb8d909fdcf5738b279187ae82c71cc99a3c7228852c69deedf77bbad039cbb130e0bf017fd66c87939db9bc95118c34ecb43542c0092779d1bffafb57651fe65a14c7fd820cedc7dfb4af2a2dd5dc6a86cd5e47509bcdf1ade2936222836fece0b962344680857d01edd0de16a38a9939dbfe243207388a12bfef3dd1e04972d0573d548d4385240a9a11350b357105ea4a2fedb99bd1bb15c14b43ead30180610e08f7a915ef51a17376808e31529b673912a441f95d3c75b9fac45cbcd3cedc8c84e1636ca016c393376d1d4e81fe0ae9b19a57715b3f05d0124f9dbe99c240922b5bf32a69463fcca4391f9c4141e33deb380f9ec7d474e6aad610747590027a7d31b5b918293cab49b9df453dd4ee911394f4eaa2a87dce4143704f8563a465ce6b1f58a6116386f60a8e5482eae8630b520ae16da3be2805fb6569bd17de29e60f9ea7c8d5c7d70110dc680f2b5baefa1aabb67e5d0bdd76f8741a38ce300e1c335cdd50fc31501b3360e30a24660ad5f007104bfbbff9990b551ecd6c76682e2bd234643c2faa4a94c1fdb2943d3d7c53834e6cf404e5479cfe297ff53e75d55e81ea03088aab48836c6f32b9b5fe629fe2e476e9e5e1657b27cb430647897d372d087e7f913f996512763d2ef28c1ed79d3d25d8693f6dc524cdce282390c07c8bf5ae235e679805efa283eafac28304395a24a5b976a3ed60d36735d72fdadfa8366bdfb8d71e2c7f670995610581710ccf80902ae24718018432293a8bbd2a70235a5ce14e70307aca3dfffeabbb14c3d0da75bc1acfd6ac4432e724750361970124740476974410175cd9c4864cdd515e10ddaf49121c0acbe643a9b344558327d66b1ddb44da2a065a04649f0d71b3f394295152eaf94ce2e788982e12b4bdbe902ec2a0a1114af82c3e8c164b06b9de96cff5866c6c1659aa4e2e758a557372ea2c3b12b8a7517408b0c3bad447a156e57370aadd788ebc12eb2c7f2c0a6dcc261e63eec145535560ebb9fb6b8df15a823abccff023e43192607569fc10ea809863daee82d707333e1f764259f66043151dc7da388719de03f728717b94c2f2f76eb4c5c00a958700834e94eb9450f461756395175f82f0573977d8e697c479a1d1306f9c3c1850fbd5a20d291a212351b5676b29508789f0d6898a283c617db7e77e93ce481f02f66e7f6f312f9e075961dcdee67f52816b860a8c7e600236ac6637824efc416a82812c007b481330bee972033ccdc0b1636595d185bcc238a7cfceda31d9cf94a6ed9ee27ffcfe54eb359933222fe34fdd9058af1b800179462f1052b98a0f8fe904849baad5fd8f0a14f609c490eb0cd196822f72d7ce920c35d6132a1ae4b7c24fd1c88c624106c64b9ad0e34d1a9f9ec477bb6645cf17bc5266d555cd91152356acf2a1763b46c06beb44e6ea7e4705440db5ee1f57eb5ba871c7435120cccad36c0ad9e433c73c5fecd4929531c87bd807485b251f76417816b7b889f2a881d2c8373ce0462ba2aeb77157dd7b928edfd37d6d0e041e386075a0a98ce4e6b88a7ab3d51990ed3217f4a17b83cd46eda90ac6715430aaf1b10941904ab8fb6450dd687984f727e05ad2bc1267efb4bbc2e501730a293bf64677c7870a4d60374765c289209b1fb25206c85cecf6562da24c0a657d333055bb7123f3787f5c2d842c4f454632e2de89610e14a6abc16d609379596575edfee4489dc9e54ca1bbf880c5b125f65cbbfaea4107e6d2fa6eb464b9a99fc5e39e284877dafc1e92a0f629885da1a40b8b671a9f80c72efdcbfc43d7b37168366aa7ed24066ff19e577b5dd8041929d64bcae228eac6c4666eadb3b62a06658cbb90f6eb5cb517cd7e9ef48ea8f851d005a2ffdb55b3d1712371d4726778008fcd786c05aa538297df630c8e0b4a152e5cdd32fcaed4a09bcc1d3c6f25ec9606da7275ced320dfc51ba9e84e1c9420d95d5d9d061c2fb3644878a3449957a239c9a968d96accc9040a66d0b7b3ad868e5e9baf7439ceb34bc36f84b4277f4800b4cd64104cd09ec1359bd764962d18bb52111fe0b0159fe6b2c595b645dbbb7b5d4881e7cda9809457f31a63ffc0ca0696483db6199b1fdff4a25200748b3f6c0d5c5eeb4b44749dadfea035738d56974dd407a9da3f5596bfdd47f086b40c546e87dd6a2412390fddc52b5e2b2b4e44400085a0b224f661395c912f13fdd6f6f11b580e3c0d884425e2ff2e4a965712b867c2386b0abe46d8fbc7d9a756790ec74855d745c14938241d5e46b6659e28365aaa7f957efbb0d382c1c4d21ae27048d327104454f4f75cffbcf02f679b3616aaca505e7526de3d4fdd49e1a889ea40b4a8e9ffa0e20c4f9e89710b6cbd5fdc8a9292b7f3573bb6fdaf4e2ccd0e2823619b236f2787e9617b4ea9207a98acec9c156f5e0c7568a1f74772e93eb149795683b55d1b0d7a00c4034456d1ac1e0d6d5ef03602e2435549ddfe15c601dda6a8080c29d309170e9b15018e6f872ce43183c41542f07b0648e541e26b41c568250ba2c1b76b048e5b3420b24f301fe778bc0bcc9fc2b8fc872c45a3c6c85bc602a7dbbaa722b81ce8500f096bc8b3596d8797a1ba84715681f41ac4c443ada075181dc25c65a72d3ad1d94d1a37abe4f5ab44b2d8bb49e606afd448a31c7c6c98062a7106324d0639f0f4b38ce738b3bbc4ad44e576ca08137df702dda7ab5bb81ab93eb3b2e952eddb6e653ee9c139bd952ef460ecb12d1df94990d0ff83587062ef7ef0f0894b4a30ec2b46e47cceba138b7cb8664155175ee9e08d3263a4d022d660d950da2959439aa7e2f6ff199d31f6224c819ae24909cceb9a77f638d790ef0bd53e2213f3710182fd85a13a3c8d20663d701d1c3b252fb38f80962b35ff91f16462e1b2c8c3e67cf43c2162637685823ceb7d1df64dd21143b96f3e8ab6d6457a25390e1ef9b2f390ad1115e8ce6ca819f708b659f30b5e546f380ca9b6ab291cc40d7019d78b282f4485ac29079838f8e77d09c3d0bd727ac9a0382279bf9935a831bba297caaa66281b2fdbe4d3d52b7f4f9b710e20eb72775dfb696189076f12b5bd4bd0a4188188215cf27fc7c6a2c7e81ad59c91747293e75e08de052afa5a2fb77116585eaecd4c6911a63a9a02982c2983b83b442592dadaefcb02e9e66a2cc769bec49f81353371d4e554a2b48ca4567b5a0a709acd33c2759958296febbfd15f8b60c8661e648849385c1c71fe43ff754ad93d329867e0d2bda306ed8391d68cf8b0dfc8c9360ec5fff0c302c34424d1323afb8e1ceef2e31239683eab07ac34b1dfbd8838132d35faafc3d75f07f63012efc892081cf254e96094a0685f978c9a9c5d608329a670c1008e178f2d65bc5b3693ab68649be8cdd12d925c16671fe305236162fb3ff04c44b05dd9b720c33705dbc4677264ae6c6f7921b3db7e6a09394fc6440cf32001e5a0d8bd4bb5643a3e46249a0e563273f303cd641637185d2826c156d7931f98914203f53b2db4500b56a9fd09a9208ff8d2f30de767c045a3816603dc9792959c4337eb62f7593bf6592d51039f5e448c1b432b6c863777598208697d10e3f851fa2a3c76a639cedb374294b91a38b5e1245333022d1c54b7c187a61c7df90059559cb6fd2312570c5875079251c08850c0a0e7ccd863b67ebb5d17bacaa97dc79cceafa8cfcf2a9853de294651683b04cf0ca13b43837badff0b1f6ddff16aa247f48b1b41e9d74362a51b28fbca8c44a89280ed53a33458944d0eb88ca634e4736e716e1ea9ee3578ffa722c10a22271ccb3eb3a109712f83bec504789a0f2f346aa4c9e8fa443d89a03f34ab277e68fcb1f5522fe2933b30b4773c10a4abfb02104155166d08f0389f5a7cd2a38d42d96948859bfe8e75d238fe68d8e5a10602c1c0131ae63ae9d10fd1f100c922f51f203b9691e9866d7c9ca45744ffd37ae554cf7aeb4dbea75aacef86ce9a844918502e9d7cc58a119eb4c47b6b800f16e42ad8f2a3abcb93043830690a1dfeaba2697adfde1c475e7d14ff180eb31065ae424d702b9cb5c26242328a74fec22bd488e3a528975cd4f1a5eb2e9ba12d35cfaf3af1096195f29981b7e02143bf9ba40dead0265c1bdd0388b67981a6c431320edeb54f8e583180a270d3bd601869c4a9c9878f8a190bcd64b63bb4af415d0eac04feba6f1bd725d4d8a8c64a030779eda70009182447be65aec2ca7f3198182fa25e5b0072c95351b8e41d9f75f7b75a74be22c17214f53e9815ff260f626174a98e831530d8cd381034c7a476ff7e476dd48b3d324de7cfdb7fe1b8adf54959ee15a7a14b95259bd993c20d4965397041cc07c10137dbfa9484059ab168dfe510005bb7a7e4f2283c50a7921c7a5b0242f0316e1619d6cfc40dfc236ccfac2de0503bce1b5e6ba35078c21fbe9d025d379232e85317fe6aa81b51f30fdf17c05a174594ace60ebe0ec209a639157b8eeff318b7b2526a7900bb20eadd278d5212e9b905fac93516aeb4baa4b86d0263a2616585908dea9b6c891627bfdb83a38a27020a68eda0e606454e6d3c771038e685955d4a471912dcdbb3f27afa9405db0710cd855268830b299b060e431fd407ace55c4b4a8f61a9f76b407416bce8be867d2b8d078becf8494b99ff1a010f3ca6731375b479d4cdce77f4a9fe8611eb4c7124c3dbf547b45c5f3ba7fc61cc5dec903bfd6ca32661ea8108fa085080fb95cff8285429099d836787ae80e5298ef2ba026efa418effa846c979c7e651cac228c47b2b6e7ebaf693577c0f577641dfc83eb7ae1fba86b62d3ce019b131ecc1983d29eef1d87b8254dd892bd1ef2a0dd172e0a11cf0a853adae1e9e6b5dd55e1c8f564038ee7dbfbe20653cd5de0212cd8488ab2e930dbe35cfbc6c6fbeb087a8ad5420618fe5522efbf96d66b33a4dcd44588dbc68d8c0ce507e48992148c7094d2e3b1bc69a708a0f0bffcbb61fd1fc5605fd3a7ff83b86a39d678093a4aa1b24619694d32b57dffc7bfac402c60e683323e92a9b4dd2f4e8a088d9a0772dc16fafd50ab9c81a23f461d7be6c387b1c43258b92d176e5646ff3c7190d8190386ffbcad8dd7cc1c46bdb5818f2a57503d8ed13dfcfe27505b94018b8bd27d4314957aa5afbe4580d001227d948842586ec12a29073a8bd65c0f561c08e382ff117b8b4a30f36776b9256d98022154e3590344cd294817c5c54b7c3a5db88dd292621a79fde43c8985ad727320f26f212287cc0605b75b8bebba701d41d7d3bbec4b6f6de54c96fcffe68a3906fbf89b2f1be864068472c08df4f64c91a628a337967783245994eafa0e8f7f9784873ce4b6b835a22cf6b3309ff7ea13703fce10ea602c70a085fbbcd23551f2ba66789b75c36451d7c7f07cb9cac560e16e00f3139adcf0935155a93eeafb38399595f5275624802f84615cea277937403ed27ef6c9037d0b1dabec383cfef1c4052bd93273c1047b98c54ec1f7908a3763dbd8b69661d07d18532145cac58f338948f24b3cafbbfcdfe8ba13a7d263341621823dc759b5658d712118615cc435101ca80c3d37af8d327daf76ad549add525b5adec6b855ffeb03278695cc66b1abf52632ae8545ebf4e26c89c99c4de8d691654bc698e8bbb4b5a8a221ba2406e07906314eb0887f5417e4a668b099248d801ce3a8a98e5cd4d0428118bbc1360801c3a545eae5276ac2481d122d739f4997b1ea7a81efbf719749c96c62293a323d11794a4332010bd3d69e0472c3a58e0a37aeb43852b0c6a4293c65a4e26c3e9d401df7d1738ced54a781e1e12fbcdb6d8db7697ea88f31622067ee1cf6ccb50b3b2c7e651fed26798041ce1148cc4a960efea861278309002ea674611da72f9c7f4d6172f70fc29729d89c2afbd3927335593095deca137dddb5567d01bce6c79d564866eed1d9ac386dec4853631b1b41fc2239744c735e1317ab9672980e01a93e594a7e22091ca5379da60764748413fb7df7e25673104af31f065442fb33be8b441063007e7180fcf4feafe959e95d6db3988fdb6b21f1f1f22ed6aa622a8141b21796f21b48466634ed7d3e68f09b231eb5ffd2015af2dcc0594275bef5be541615bc38c80420d25f8a42c95b0f9899077bb5c7fe16a4fe0dbf065211a25e7b7278a04b60c3a03d65509d62e0136a91ab90dcb3fa3d3b71dec95d0a7293dbe8f6c6d498ec261f2b9573a7d8e557eeb4783edf6b52c682bf2d59cf52b2795f1eb9945bf5f6ad34b90a9e85d8a24002ac16e4f738ec3b2fa968090c059d6c0bafe312b127eb8fffc149b39ae957aa15a9bf5f047932b82f256a819d2f18826b430e3e8e41a639bbb8d55e786a371dea4565fc39fc2bc2d51e2aec8e129b9a93e5d396a3ff6fc1f7c18126d4a3ca0734b2d9e05f509a9f14bda058f79bafee7ee23f0b22ba39f1009faaf1706f72c4c602c2a2b0503892386425afc5fadcc19d835829444aa0eb776a06c6a7c3e7d2596f4f5bdb3b1fae8eba1d907ce70cce36743e2793e66314fd6b2d017d5800c63fc7ff16c7dbddb33ddb5c73a7a3577727ccba7090560d414d2a57f40dcda954510198c1e8fe0b11ff99b1935107b176a06bf56931afe1740a5ff4b6880d0cc02f1155cbe03b8b1a354dac6aae6e949d7f14c8e85779e37429ba901ebfe2b27ce2d0afc2a509ad36096390885b194a6d94ae34d9077a9ebd1f73da3797ba333c00c96fc41176ac3ce67a269ea8b8ebf55eac3b53009d784732e95709dda16f9d9953d047865fcc58af41e4a4c17ea0caa85667505e1cb400129cdf7c3459502b2a783b5b4412f61fb63199b8f4ae6c77a4d03c5cb25a6b9d0a4f101365091e9ad4d5f74ea96f7316e6d29095bb15bb47e334017e2ac24b41100a228b85b46b28f8f24ed06b38d56de3bdc632e056fbbdca451b2bbdd150ccefac738c141e6e6c876c27e5e08c978577fad99b2cee06024d3fc11222b778836bf425a82f107f8058649b3c8f2cec6da98a9c3dc3c512308f6ab83c6625de9444ffaa6bbc7094abb914360810d0f8344bb200204207a5a82b0c33b2220f892e8bb34215c4bf0f6b957d3d5310c5e0b0422ecaca1ef04debed1d573f7f8351832e7dc64a62d4f4c3429cf800be4d9f841476f6f1605368ef0eb61cdbc59fc620adf23063f46a2e6456610994b74ee4ff785a38634f403f5f78d90e67280afc87a60753a4545ee3dcb2816c9704396ec194b8fa9feaeded357ff8c042508bf0042a6d6082dc59ed6943a420aa71e87e081dfe8dbcc57ace22088a365029e4fc9fc92c7e489b40f8dfc31304350a4d88eea45c8689c094026632ea0de06a1eacc042b4009b0bb8b9a0147b525193a7ad440456182a53a2949220b5b9ff0bff51c0def5e2ab1e72c6645c4776a6261c327b6908f1996a0214e90025171bdabe2c6e944cf906e42fc88f98dc994414810c098c960f0a5cd862c5a2f4b9654f8c7e27c90737f7776266fb9214d865074cc2bf889d5e8047d1fb4373f352307c9440b16b94b4af608b4df8b6ba6664c4f3287483a3f5963a4459e55528508edfe34530ba844c1aa87a5da196280e492dc4da742465886c4d8b954f303a74ed98f732ec6ca3bce6042b31572e2c37d8137cf4c41348afffbf8b09b788e9553f3c84586723f0b8476d4b0c7740f041749a9385ea04f1c3d71324e3cb652b7434f3f18e1738acfc6ad19a19b7dbc88bf47e154507c156bec89510b50c4077462ce970755be4470e4d58c70037caaa502105ac8f4e34b21aadd4a27b9cf73ae5fde27f0ca5c80ba1bfe9064e8da6e00621aa11eedba471937fc5b08f6ec8a2d1874f69744f1e2ea5fcd289003c374f2f372c1436e3416f99409eda2bd5e347f0b15b514402495fdc5fa71808621c133484b9eca5b8f0fabcbf8fa8bcba1b36ad39cbbd0175c84fe520df7a0b91a39be1225ae9970ba4cce1e625426beddf821f7112c80c81bea9f9b079fef4650a6d193170aeedc6dd1a5da7c2d480a21ca757c3b44c767d84bda919ec09e06bf8e9dcd3a104931f8ad6bc1a46a134c2e0f179984f9386a91ac9709f16dce79f478936fe50a4d3d933eb9b50f165606192d0b6530189e5ba0cb818b87d014927f3147fcebebfed57a3e138704c95ed8431778ef534086a4e7308e8e652318629c1bded5fa877bc4b35b0ef1be1e88c8bdfd0df1b135b5c53de157c226782d04b806804da4ca666a048c70f51ca723166b7fd792e0cb22e68ee319bf33ac184a850f8cec2be82e43564835b3b7573fc085a26d568b3a29d94cbb70be6e4adfe99a8bd944bfa034e0276cdb72ba8f4cf6f677725a4bccc51b0abbcd14ba0a3c159709a53d8a97de30905ce25616ccb6445a0fc9f35eec604b12b1831870033cde0f740827c9fe33b6085bb501820ae1cc6ca6d4f6b617126c0583036a878df95047186d3acd43a95c9f853810cd6cfebf23ad2bec9312ec36a2ca624b3703e15bfd8fbb69c556159680cf9002565abe98b92a9722b1a45ac6193551e0c70b3a9a1250c0b1996276b1b63a2c45b4787d4a6f04bd0f9256f39d623c4b89344f274325f023127e20dc17b55dee62caedbefd5904c683819bc65c49a4fee2ad58224f48979ceab5b3704b0ad297a9352d23c1fe2a3305e539dd89cd3dc6e2c813d7d19b85e641f17f3370a4b381e258964597147f727394062d508375d02041184b23ae66b1652b2cdaf4c66289f312dd9a782ec51f63ca52abfb5c75a61fb0303d637703c6eb59a2cd944a9e9e5668caffeb173adae02bd1133936ebca5dbd5d82b35bb7b108a915b3a0ccd503bc95425bf659d351d86f45d1a33158a39a2290df34b31a268a28941fd4cc189706b3d38e703fe9183db7a0073df6212eb63c883bae41a28c5134a9ab8c5fed88fc92d7ce98900f93956defc94bf88e99b4a7175642ce895b4730a4fe0655b2d234b1d85b8e6a50acd18fb972f553bec43e5be17b159657d08aa45b14052c5f00cf244d5290fed954878c6597e12c15bb172c96ffb10674cf47c05c59d539134225185e52fbefdeaa0c4ffd9ad32cb884a798477d160082310c97ac9fd5b06c764b2ccf4f7180f37f52a2f056d605c90fe8a83124a56bb03be07f4f89bd42ea2fcb7ae2eabb8f111369e941bdc577b0de00666b5571497322763f09d8ccb8ea891a513c531151aad9342a79084edce36a85d257c88d10a58f29db702910b595d95bd50bd3ba161d441c59c743d89648a8ad2648082430e11eb9c9ef625f65416b13ec2d7dfb983f3c07087b71ccc5077319bebbd1f7ba5ed6cd8f9de35d7bfc4bcc433153ab20dfaa0da3a6493e9e3b07d53eb210213508db61ceb769b65b7d473344c9d2c25a215357795ad7a5a2348cf24bbf0dc0f2cb992fced7e4701b66349647694de0be0969b439f3f30b2d477118af9fbe43a8bf3ea05112e61fe00787cb3d135ab5e71f4f4f2c8ee816aff90c60d421df52ddf9d9c9dccbf7c79faee5d883390a7f5667aa67e3c42ac930ccecfaabb677ee3f7ce5411c40080a1648d94b05b88876af6e435fc97dc706acd2f9d58e5d2c81b026f2b728266d9754bdd3c707ee9029a1c799e4ab3b59d25b0ec8e19d13267e6de80955f350c2abd658c59dddb50dc90bd983db48b846bda5abfddbe6bbbd5bf96c9cf975d8f4b944b08b83928d78279057aace344d76bf6af8121400c0279cd0aa2f4b14b3063c382d12b76892cffe6f9f6250789eb64a8869a21f3f113ef35f5ad96b03b16bc613a9b3a8028efb463f8cd837967b4bf05bc672cb40819a77df78cdac4efd2154d4b09a2d29a0989678d324e6d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
