<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e74cf50e4294bd9e2c3fcc868adaef2bb1975c96e0ee4926d38590b166909195603d858ef34cd01a749add7bb6e768d8cb21206c65bb4eb09d842c103879b22599cdd5cff5f13c2e346ccd46a25d02b4ee7b042fbc35a7cbe0958d1a6e8d06dee02c7112562e6b3382842b80f79ddf72559e844bbdd540f7ca75f5d588d8a7d7e7be5962d7b207d811121e8bf1ca034fe768878477c9316cacf93e86246f0ff592a8506794ec98a42fe706a85d64bfbbafa8e445997054885c01c5df7de366ff517d3e0e87f6094ca0fb4c20a087203cb1d9f46c2495c6baadbced9db36ff14d6809b2d10d6e17b60d935465328a7629b20cc367e3cb6db8751891dd9f831b70043609553658b0b0c22ac1537894f28c329469a8822aa91353f96c307d0875b74bf1472151a977728ee1240e93102f12a7c1adb32dae823614bfb15a17f2c2b596cb51a2390b1d27da3cb2f90b42da27414dc62068d1e02cf76f28d0a6aa5ada94696e00acd5e49365f9019698f8004e84d9677ed8a44314d9df3e7a176c05f58945cc488652effe543f253079326f62e9a47964f578e495747dfb90a0c064c5b991a738fb175a6490c73862ad254e1ecb725160cc4f3b6072b13ebcbe9eff26cf38b47c9549d73a0a13dce679c7b982fa3e7ae5ccc4abb5053b356b91bfe4c38417b2f04beabb3adb9dbaee33af71fb1a86e5657f9f606ba24d6b3eb9c0d19dc6149dd9848ad75d68b5439853e3f025e889ae674563219b39e7042f64c5fd9349f3eca270f4f9571c76d9ea618feddd8e0dd5ddee53aac43289bf1eda11e16847c139c442cf414bb210fe6109306a5573580ba52ff0c329c38c6264584644203bd91e8935819d26bab899f011520f5f9ad8db5ef2bc4600b25da7e6f21cd2fad69fd9a5a0e5b597370ef3c6a881d346e978a893da4178b4240816646c22030af3e7b46847fd0750da7414b24ee27dbf3295b913e2397c1421e748a22e347ab99503d2f5be0af87d79f357588c24d0117f9dae470c5fdb7ddef538e0d9e9655c863a0cbc872ed6f45d9aec95f007686262e35ec628c04e320cc4b97fd8b25bd99eeb423b87d1017ae76cbab598f45792f84d25bb0553e5bc1b69187fd191c4815e49c15a34a2efcdbb47641c5f316da65283dbf4ee779ceb3c76ffb5a02ddd16766e7d9e0acf287c07c6c113aea89297b4076a68485a5a84c997db791b3764334b497c9014b1f1b3cd45b83333264e99258ee283390b168470c27712616063fb1e41a0fb3d7f1371072d3dfb59944b9b817030ffe977398560b11f2949f9aa0602b3f0a6f1d489d746e87fc279fb9c6dffed5bfd8451094733bef467412c103f3460fd83d4ac33e328f5850f4df80bf6cbdc8420eef522a7dc599061d842e70d8398f28cf3371cb619494e8d041c12eccd1b7919f67392ea37994a7ed20fdc7e6d15e477a6d313c487d2182ce5399bd1ed5c17ef2c70918f9334441ce3bcf1a4efc6d1d3ec30816cdf82b96bd245647a71c64fb981db047b562921cfa89e2d408ea4434dc1d5ff7acb8eefc93e0197ad21e66bf021ce9e837d5f06489b34dd122eba69a3b93debf6add0cd0ad490267ca9a1cf575117f6b3a15b852c2d30b2b3d2d246a9a3758144b63cbf36e6a2d702d1681c6b3da4458f5ad62b3f4795feaa5b458139337199fc1e5e01d828be9211b632c99d2dc7e3a52658c124f0eadb019b5cd7205e0010866f242b0fef3226c55c921ec02960d1368d3d61eb03e86d4d3aff33b35291c6d8b11f35a3aba14571715f0f8c8f3a8806b2ba3fe320f9d50f08bdb265a520f5b763dbecb2ffe567c003143b4a43400491c9d99eb36e9e3867c673c4413ba2e3f62fea1feb8107202c4c3e76a51c9590f7543bb3547ff9e93215c9d05151807074a607b8282ab968e614cb754c9819e8aa219c357d46338df1a48cbb21c9b8ff3db50fb9d12656bd0deed64b84c941d683b56dac0cced473a41a4fa10ad4402475e5efee6444f0c63932f76ca07840ab999d70c8afe5e02b9760ae8b658cedf7b57243c609d939520ba763a5e2c29acf445a78f061ab33b9480bc0a6c48365f6a095f6d638e1c7d965c7feb843ef9c835163ad8e5ccbaf8601875109dce9b3674d6d084d34cc3e13dbcdf761d4022144f149869612319fa3a8697def13a809db49f53966592504f1bd22a82b2303c2d000a7753f15cf7399da7ac82d4527b7a9c43df6a865e50b404078d7bed5df5504e80d6ef6312adfbd8c270f8769d5eba9ab153f3a0c4c201b89ddbdb52bfaa549fd8b1923a2e4f52cacef0cbb5b5d81e77616bdf2906824fba7123a271b947663845bf144333b67dc21363c069ebaa01827ce1466c3d4b8b10a975e04bc5b85868ff4251521c4bb0e97a81f2267ea6bc986ec6eb942a417879e805583e705ce6fdbed425827a5bac1cf5770bccde676eb210faba10889cf47db25622ff7ab9b6cfbb0c50ff13b6f31aaaf5d528ee22e69a581754369d342dd461777cb31d3530923d3bd7a536a5806033c65c696af0ad84a29ebd1d18c59050e90906a13999a01aebfce0c1f5ec2889513109380d50b1acef2d50ac1f4a4a8ca9faa4e4391dc89feccedecb5758e7051e841750fe53dae875ea9171cc833a02bc259f91423e76ab7098dc1daa6f912fb83b1116e47764f0db738457025be3f142fdca9cafb78cde24918129fa79e82e0639681942ec2e1bceb45c996fe0b5317628c5f58bca6ded5c91cf141d948aab903ff646ac74b57ad630197569e4ec4ddff1b30c1488f6e10e481c55c97268b7f8f8b48d4dbcca84b981d9802ac25865af6a9dca524c9a2a9634ee3fed09947faf36f3db8eb289e54cd7ed498434c33670dd71d48715650269e8c164250650195f1b0ad346a091df54e92b7d7b6d89d33a6d0d59b29838ea1069ba1e950c1303ddc1dad40aef2ad69363d6bf990c3b77d961ee3718a3463bc5dc60a3338297d0890778e7c3cfe915a076881b9f299c1c173686906e49008e8885a606dca2c2e938dd7ba18548ba2c9ce5ebb36622fab3d7aaee5791532c80aaca3730a10ad562c6ef8a56cb676c76b75d63f8858e7bf9a294966c81e67c0cc264bc38a8bc7bc368c5d18a31b2137b5b4d75c0bf055b4e3eb36c19648739ed000a0d1fa53b886a4190e7d6d99398bfb4578076760b4ff1e976fae4e6b43485cbe62c5c7a6ba87481b7434e96724fe6b71b7a2678fa0872ed99fb8889e2ebc991c783a3e6b9af702a83a15b0146a9c8099167513e66c7358aac94a1eb6e55b9fad22b8f2743c2e0567c9540f4364964ab6234bc19816c3266da1a73739fb99825feb30709f05b9ce6f46d2fdcbcab0758b57ac96dbe49388dbaeeda3f41bfd7d5bfd51e3c7e0d1cf32bb0e0e84a5b4330a7f3b8b0a3fc5c8919250fab98abd94e2963b7db044443b34cd6605c4e86e48fb567c4e09751299a873531c3c7f4f67e19a903694c0a4a6643108304d58b259239047abe5df5c00705baf897406f06044b0469e02abc2aee93e4e7f2da2e291a5bf34c2a7d1576a051bcc4220026d1cec8bc0c0d8ccab9725ae6afd0e1cf809a7d9a96ba5538583e5c74640c99d4a42e8f71955bcd5c327e011660889c5debb9cd8f0f7000a54d7df0ca035d931134a51e3ed4214e450774c1636ce6e911c511a4633289e177e9a165aa12d02d3e5fb8a93bdc42f3d065c280849f094cd92ba759cd5e25646ad217bc20eb6dc937d27067d4f63af737233f06d90ebfb4bb00037aa5a22ef36a3e031fd08d2cf5ef82464361a29fb2e243f1f0b1d69728a03ee588b6b7a993e3a3da4dd1e025b6dc75e41cd95d973631226a90bad98d9d63d38c09ebe378c0fbc79af5a9c0a8b3bbd5410dd311c62b65987fe980d1b7d2f578dc382edcf6898f76a50a6f7995a2aa4b4c610601c38b7c9b2bfca2b3185883fec3d34d5ec6bf44de545f8550082b0b2d3598ef579869170f03d43d136a991977935341fa4ba42549eb18fd74e597d523d52b055cbbe89b066c0bb92711e8fac6854b95c2ccf990a68fe7f743baee2734042ffc87db9a74179443e7f022a09955c69990deaf0bcc310efb30afa9ff36ba1fbf934f102eccdbba543bf1918c97b31f4a8ac83ddc0429b5e5d30b6671a6dee35d71cfcc4b42d8b60ec0e74e501dfde9d7f83e8302a00718ef2ac57b911e42abb5a8720dc957c53dbdf5cb136c57d2d15eabafbac2fb2143b1252e04db236bd98c827d03cd8345fc49e36825de2b44d982ef96d8020344d98672d0c9b457807f725dcfabfcc077b1a21e7447399291f6cca27a7c05d4b9964cd15571797fbf529ae3df989463b4941e38615fb2ed6fc17dcd5842f54c1754387b4f790b36ce1e14bbf0f5f83c8d66e2a9c4e87a0e486f034552874f09888fb164f5e92ba01649c6e3105bcd14fb948b607cea119447c48587bd5756a11f5252109a73875092e54c25a4b77b34ad94c05256bb0c9af894e5dd0c2a24c1ed0108bd9cffb01423f023d77fbcf9129e139b0c2bcbea7aa0a01eecef6d8e8642554522d4f053e06c3fe1078f7c4b81e9ee447eebe08dbdceb7d471fc2b7aea4a217d457b5c0925741db2eff94206e3b5442e0c8d2c06495a894630803b091e7ba5703eba3a9a41a0b7f0ee811503b22f8f6de551b5408d65640876145622959d1295f78aeac819519ba8a9962bf33d1edbe5bcc37aac41ba1065d36b1d5ca77789ee3c00d2b2601d492dc563e25be39150f6960394ab66b2ef9b8e01c49decc2fa8153bd461892090e707ea1ecaedcca63d2bfb278c8208708825e877c2c31fa9687fe3d17352348388b25e207783334a6094d7ace7dec967c63d13a444327bcc8f0ca2d18ba7438b74ee04bc242a469dbb0b009712b5e8d8a140ec2f5a57eb44612440daa4b0fc008b1d7fdf5cf551868271a73bc0528d24f52e473a750e314fc5f37ff81a2499487c600cd7eb841a81d05ba3a60b669529eb9f88916e26ed2acaa8c2a03d8491783885a8b32c281c77c1f3f70bcc24ca6f50586ca9d771bdf76168738013c970cb5cf54f1fe90f1da0b6abbddbe5bb8752cb33bf520959a038930c9187e00c6f89dae2e280eeac78117cb532a1428c974a3f784dcce6f7e0f790804f99bd88d27016a58b1a20d154da3df8e99d7c2b33e71abdf4e19e0602b964ed0acfd1402084c9b80d58f8bfe87eabc77e6194ba39868c9390502892eec5c6dd2f9955feadd6ad11e1fc401946e646338216bc056a5245f77ca36f2346df2825c8306daa351ab10c454d4139df623533af00471f27fe49d5a1e2c0e9a261e7afd5ab27bbf03530c71daac7c1f3dce73dad14bbc72c16f7ab4b95bf5a77642449476113ccaf97faee1d97539d61970d7d551f27124aba594bb59d4d8db3ad5583f17e644533f3f5592282203170dd54eacb882328e47e07252c1a86e0da45fe111507b4776686e6ba326350a3eb3933f5d0ac25c4d53c585f75b3940447973c7aff45361e86c46ef1b1a150e88eafd1c9eb2d5bbe6f5bbd09f51aac3cbfe26d7828204af101230cb8f307073a8e65cd24102e2b314bde3d7f86bc3b1ee5e91df6c2adf844c8edb9b3772746885006b021e07ef7a4fa42c5f652734090c93488717e4253f0625fbe349c4595e53e331bc769278cd72e69cb160bb4878b8ced732931a29f5cb7de11821942183276f907df0b380100a637803b64501e575eefeceb9551724a6b08d03f82e99492b7ef1acd486916d856fde3a3bf0d7251256b5e0e1d88687379223165ea97b9b0ba7cc5f890813f33416f90e5413014e0e04b40afc6b46cc4e4845cc1abb51ed076986f5baca724292ed65b01aa75ff7feb5f521772ae4b3e808f4aa893a372d946cf246959f94f6ed5f5420507611e9f241a9e719818381e9b50512e004b9d13fe449251451ef8c489c61e828f2d6fab14828d89fc284d8a7c33a8f28cd2c45f8181f4358f05d93d5f0714db036f386a1ea018c11ede17d7e2dc2a4b90f38ed272cec7835c2dc8bba9f4eeed9b4de2f0fc98803037887866a0f8c7f26ac0d5e1f754d238693285aef445453edabafcd522fb46f854219f8e56c104cb714294891ff714f7871a9a201f009db1e094491da49a0da8dbe408eedd7efb53f0f6377aacf45f10bf7296f994821ee30ac5376f19eb4347b470e2dde1f669370ea7053d988bc48f9e603f4acac85831d84939e4794b196edebbc52f4d62cf728b98734e80bfacada376d44fdeaf47cccbd6f60550d52e659cb8ad8a43044a4a4358f1346bf2e6aa41d705793f2e31b1ada173a0978f10b6c216a83e120c1ff02b1de270788b3b1445f4c656eb0c10d38f11eaa6db8fc59beb6959dfbcaa71ed991bc42d4828a798b41061414aab096692b9e9aaf352117d07f6917a941e3788560d28dd197895f40aef64c08f7f5af1310d436d57bf46aa9b5d59c5f2d26a817c8772e2f5aa9c461d9fe9bdee75a0d7e4a0ca58034a2bae65a21404245ae11064e6afae7b19edaa6039c913032c3f718c231a960abfe98fbb2fda6a3cbabf654cbb4328ee79959281cad397a1d7eb3f2e8d06bc1b7ad24dae48dc2a9c4ba857cd23eff3542fb0e5ccc6919ba9691065457652711ded8e39992651b182ee35a050907759e44ea5bf646ea3ea3baafa3266764518fe3a83cd2e55918756dd6962d74f849b1900bdbb912129424e77a70c924edc784c4eff8df2ce046d8e7cdc1116acf24a40ef1aaba55de13cbc9fb88afa2fd18a427fd8636937434c3901317aba0dda6267f8718e9199de29b7d1a4f4c1da3019d08fc7f69a3f2046c5e91f0a564357d0f7ebb754993265490167bb7075fe22e206a949ff491ef1cb976b132670b7cdc47ce940015d1ad4fbe035edbbbcd37e47dd761cc924f4314e8c43be8cdc569024ae753aef483498e3c7c8e1c9f6bf00a1e0a898545e0af2effbf53de658fc115b7e61b26750c7e68ec25f48084b15ebf2b4397f9137078c1f9e68861c3c7541a1ec7e86a6a30f702ec5a7fcfe8ca0d5bad768ff2edf4dda30c2fa4b2be46ecce8c7047b1f0797f2a3632852df6bcfb6d73ba08dd65a7f0a6085355b79b79f8c8b63b45b47e4b5d5d6e5ea3b3be8a5419fc552d50583bbb0b9f8f47fa7e965d08d35f8d2637ab561994eff7aa72bcef627baf1b7ed14e2bb05cb2966bb3e086c87af057d99b9f4bd33b3591b8d3e3dd26d66dfa5861a686aaaf28173f079a7aef8ad46a55660a0406e21ed7e8a80eb45fc4409ae4b5563c0e4f4aed0789cd35ae1582c33dbe23103ee1ee797e41839e430f5ac75e6e8b04ca16dd162afc46e722d9bfa43e0576b6afd96b1dde8d63e1930625809ad9936e680b28ce4ddc795633f269ba3dbbbbe66a66792dfb66981c6441c44d9840e851724e2b8d0952cbb8ca21274daa3e9691e3dbe54070a32181eed8f918741a7f3a0e58cc73e8f905cd89021e819b8b8251ea855514f04857f357b6070dbad09753bd6f37db6f19c728da7e5f5d76a2bac0c56516790d613a8c38c098ec2f79a78fe75c2e7063b5b183d9b37e71d8a66912dc4625c92dabea9e9aa842f3344e3b36a52df374ee32abd78043c66fb6304157f5b40c370577fc32658430b3be5887ead2ead3c6e58066675fa820c85c5c4459b09de039875e4ceb3ebb790c47f732b777df9a22c8862b348d859f846d56a94031122c2ce1ac01dad2e0c911bb733e5d8ddc7b95929edcab472c0682f93d24d349614337228d8f3430d7a94bbdf31328731c4b5b954eb44eef329fcce4fc7b0b0f2707d67551a2655b45a459f5baf97a8109422a55e9c8610d6bb091763c87b4a2eb21606c108a5fa70a87c69078b77caf84dcd01d18fa8aa38d48b76598c9290caa36e74631ab6509e49f4d099a311ae23ca9be169ecd7cb747f7184f580899a650b429adc5cac39c7746ce89e4a5d3407b4bb1478b5f45d1d2c66e4eac263a1959b4a890ff79caecd23f6be073ec403cd1eacc24baaab8ea8f2c017331905dd4a85a4846e1245b60e90462260daffeb331381c0b22b4330c42664ebe53113a036db8782eb05ade21ed157b9f59d2f014424d46af247ef60dc44f621f2559779cdcae38ce41e0d7cfde2a1b844fc35f4496470e25caaf4b3faf1d11a7f9f0b1428728d0df2929d2d2ca20153bc919c736f7459682cba73b80c4872f3abb9cf1c49cd054e4a510a217b39e6b78f72d67e08f156495c54e983232e7bbe6cdd9c2177eaca4a0c0c95a81eb2e8136ddf53422d9c53eedf9ff2de734de9930a27ee07d30becac6fbc26cda275d80b1352c2614fecffdfd60744a54b55e5bf6267c0e97cba0729eb928d4f3618572ecb589bd0ec23d7458aef05fec4df8787ead8957c0349713d9016c829ccb4b80a2989d91eba55230daf798fc57a92ccd16baa7a8dea13ea74cc6b92790b6387dc1c79ab35354913fb44ee34273299516f439986d742acd2f5e145e2bb371bddbe585bb5754411b1f3dd2961137219246c7aa264f61914b6b9c3e5e13c4c499b57694b3b6048bf2d562f2423781931d9552dc7c00480ee65edde05d24f8007af397bfe10e675a87313b28c6317914a97c68e16aee2722610b14e407233f97be6cc6fc679cef5b93fabeba83c174c958aa2cc9f1ad845b2520560cf054b9b1b48c9683b0db14fabfe8cd064f100bd7241823637c4950d2c2ed5c73e66c546a5b5d617993f8d8a888f7f031545feed72ddfb934c855746540e87a2532e18d1d383f14b905a4f54cd561d4f038167e0fae050e9b34afbcdd7285995069863518d4b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
