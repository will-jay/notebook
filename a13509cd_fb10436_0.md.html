<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3bd4cc41af5fed5fffe82d676da97ccf56e35e46255532812a3ffb79905703c647c483589bbc5fe2f1b5c0a92f7ad86035f3b73b0e6f44e843a271ef802bc4986c18ad3f1ca3db487f969b80b14569e67e4f0ae2f6082ad0eb1d7da25920c8fd5c83eaff903d0a74a5eae81100fba028e1c309bd6e971d4cd9431051f1dd97d737b2c0dd180a1c6c6044eac13ae498fd605757cada390b9643b12cf47289a4d427959fa7bd3aea793812644ad9ed40c802743239b83774f2c9c608bcb8bef1409107b0e031abb5420d974d9ac1b3968d19f3ab9e29846f884ed387e3664e10789186613e35fc2218316c7c4ace8dbcbe093d306f0ce0d221834cacfd034b6ada2353e4496d338e84f01ee4c5eb59e474b4358ee6abf90b7be1f52b147a64fd3355a74b48af279fe470f564fdeee5acef59508a2d8f23ec81b6a13ed4e72489226427eb45b6cff22ee16eb586b8a0e8580b369add26a284f33b2335cfeae129e7146c5fb074aaff5c4161bdabe0b4ea286168b235bc78de2da2aaf78d8696da84189e80749d32d3d1adb1ccd10bb316d62c9bf13b76ff8d6b0ba5bde2dd0163fa68906e96f60b74ef806b4e42208c7ac77b8ce3939d20d2b190aaf9ce84f8c52488964d44b54ecf7401ffd426b39dadb24c6b8f34264ce593f9b5b2793b867e2a27900f7ef4669838fba01251b0305b4a587dab216fdaafbbbd58aff850ad2ceb031c6a10f4c5d8f53df211b559611011c6bc6be4d64ca7a3dac11ee43ba2105f32d1e564d9a4104de498afa102dc0afa10b41538868359e4e55d42c2dc77ef0707760a300b22915d7822f95631d59f30bd9b094028ae5fd0871cf477809825d0567c4915149b67474034aa7598d2f6eb7d426126951b464defd4353bd12f87104f793206ab2629ea561692b20d0d33a41cb354b432f24b9a5b8fba22b388ec45fca5a82bac74fe58a79bf3ca5d9d656a264880f581f608f52e5e8fd95c5c99a5e97232f5e95cb3c712e3dae3166de7bde3db6b356530440ee41c165262879778b8727fde0046b29ae81bc754dd0472a04addcbcdfbf19eadc0b535c0c72a67fc50429f6267651df1bc484bb20789adbdd6b1a052009298e2020c35e102c562135bb5aa6d6bb1ac693e190987c31008a3219ca7dde67993ad9f5c944f67464231057de02b66abfadf3b36ce86b1586341e27428683892fdf8b8da3d3d8e609d79a2c03d0a91ba4547c8c402972a7cc7a77d278e2b1006cccba101b32a49e9b9c489b3c168fe9a432c8995bf994247a6f028a7371aad409800025340e9b32e2b43adc12315d2ad0430592b23e5cfdae1cab0d70bb2d9e7f0501b731849c4db7c635ff6d697a3e66d6f07e2575d4c9d1cab94c3827902c8ee590227f99693733d720ab4f9e28e295d38944ab7f3a96d346f6400da76bb4786bab9a68a2e77fb8d8255c13ed66de494d94e4c7ec67cc1641bcd8e87190ef12ef2e8e3ee2642ae9bce9879e61d8b8eb929ce9427b51a2d748ca87c5861f411928e0dd6551abee726f9bbef7393b07118df435a1dabb340aad2dee2aec96e3917970e16657ed7ccc5bdc4a1f8bcaa0835f0fe950730a908c34f7b64208ed8d33c2907493be30f1806acd49e3ee1b698c5b3e83258c3160076b2c254312a51454ac1dc2caf525d02eb1b978951d7bca9f507b0440242423b6b854f42935c6d830b644d94d400c0846f1502a425c424c84da0c3bf049959ae0cc512732895d423915fd0df92d1c7040791eef96bb7858fceb04c1da8b0ea0302dbc93b6a5822a20cf33b574a4fbf6227a4d6fd6f726e6744e4097edda26464eb904b4337b68d870490de4769c3f3a08aebaab7659b9ac92025e02a85238e2c565c1e120484fa64dadbd875347c8e73a6f589e849abe12a1740a3fa41de11ba5a8d7516665c2741b10cc4f1cf5e9bd4288e3620cf59a6968cda8e564946019128b5b5871ff60d9d196f834337934ef29addd1f1a5b663ea0a7ce86281095f1c7587f8a19735f8c91bbfcc3a734e0831a707646979c1c819ea415599230f13900e0b48fadcb6c83340cf4fadd8d75b8f6d90d4683ae94ed4fc1f3e9d5f5ecea3f08531f7ae56db5ed0d465a63a951247103e46908f90ec91eb7e3187231f99adb0f8c0dd4592b49ac06d16341585b0823be2f4302a58a5e88381ebeaeb11d23a6c3653c88070362f8c92444a54005fb212e2fc3830e7d1cbf838fec79407a179479b0dc9777f5f3095d88e3e172c45dcda0c3b149e1faee8c43222869619f086c8d6ee83bc7b63557fab129441f7178133ebe974ba828ea2921cf0beb357bebf5bea454db7997f8f7f17f6c01e2a3ce62f07769ec72ff88e5f5d6066e28503469a86b0dc8fd2ca2915b64ac1c5caf1527ba7352d51d36a7960fe72ac653d28c06ee052b60a832ba7bb81606a2bd94178023104e6a9832d76af5237c3d625a9043740c840b5d9fecfc0ad3c61f83d223c398d4e57f6c65ddd1ed3223ed699a784363cef3301b8fd877c383c624db1ca85ba550a10811ec2cb4decb4351c6e6f641eb0e8cc92f1dd09aa449930e8f8a7e47b7d1b7c4562591a6d2bf809fc1c4a438852a95d0ab0b4aedc27a78ff47222eab9ce47cfdcebd074b36f07a5dccbadd5f3e90d30f78618b99ae474707af2190837318d9848a83c35822704bf955b9d73dcaea33a5e7326f40f11dc23ea2211eccc3e55e010bd5cef95379787900522c3b0d2db36044798a7c8bd84df203d0e03e023cb72f43ddea676335d7696b856668f601686f2ed4e882b6fadcc91a0ed9426a4665de29ebe0863c5c3d4e47c30e32eb30ac0b596581cd115ca2fcd6d33e2fbe2f350ef5c1bde0aeab9f8fa84f1af1cde96ec997ff70a7b8fd14ae2486038feade091572f6d8ae0e6396e4043c6264ce5e7d2b9a02c4114de26ac653442f0677c7e03b70d482dbacf2efa60ce1b83f81d7128203ee740d645599ad63b9057fd2af8d9af7ab5128b969b7fb5a68534f6a92e68dc6dfe4f3fa1ca30e5fae8b55e8c27254de011dd098eeba6aaec3e7b6d8f9e37a6fa5ecc2b68fc019a6af335148a7b419c4ae6d24ab9c0ad7dca60d249fcd783159518d3b32c78cad822e47061ef723388da8112ee81a8735f413fa8246ed78e6c9181183e55826c2a1651114c450155cdeeb2f15d4d741c6cd572e7a75f7f7027d883ee6b7301ffe03122e44d96d26b5a54deadc188ec9cfdf1b8e2a287f4eea1fc85540da4afc871362b26829ed5cc0bdb898e702c24419346a095e752e212cc5bea9b65e2ba453668d845084a2e8798d023de192235403bcd1508aa75d55553c776b8d1c33c63bb41dbe71cf7809e9b56d7478024b65e1556fd332dfd1526aecda869ff61a809c48fdcfb94b456d71a74ce1913bbd8a39ad542af6b584f0a66854f1a8c0c9baab710250c91505ade72ece020a0b86c921af1beddd578ba0c529c958a33771ebe7a04bd4526393937e674bde56ab460ed636f6f56d548496ada6c5772f6f92ac98987c7c5ad58a29f126cb58b3110346547a491343b7fe961f10cf69f87fbc05da9305c987e6b7987d099b8c3cc67823206ba035532ea3487d823bcafcc0a9be3a8ca439179271edef14d09a42ceff22284625a123f5efb92f8bc252ce06afea3c8970be1c439a27d6d15c585f62203084fbd2274da153677c2f2d9281fbe0cf801998d74bb3f564043ff2fb3373c5a8bc345b963f7db6dffffa0b6a25a5604a12ec26f8db2f4ba88536df8d5a1ebe021473635bbb27735b74ad13e477cb44cf3cc1213f8451b907aff9fe168a4867925f80c4f09777121b21fdcb693cf2fc62ee3800745df8136fc77ff50a710ba51ffbf4832c65e376cdb45b205285a5bc0d204586054243cb54abf56d7e471d327b2055c36652a102ae7b70ee48f75fec5ea5f10453826566f17568e83fd9a4aa4843def165da17d0abdc031dc79caf12398a7a3eaf6f15d17b90acfdd6feb9468e3e9942d9376df5cddf79a39173516a29eebb31609f6355e2ef0e8cc2b206bd4019ef0f406037388ec8ddc176565dbf844537583369893fc9a6bbf8ce6bdc0bd3daf4689f60958ea27a1b28d1ba429ce1c7fc8d41c06456ca6939f8d6b8b8ea1cc5a0dee2e78bba177b27af451f6fe97fd524f09432e39233cd285b929220efa8fc9726617049797361c794219cb168d15c1866fef2bfd067c0be111fecaa281703790c1ea2c8cf831830a09472e25822de37e0e41a358ef1e3634c1d551dd0de8c86792bef7f03d403a1b6ec31bd460b3a32d5c76b408875b24b476efcb00a6c4048affa42e48ce3b0c9cb2bf0b2868c4f82be9e58ae748516ca6afe47814c9ed6070ff2c92d630f6e94cdfdb3e0263b2f34b969a67bd72f339fac1ba162e41762fba2cce2c54c265fa026c941b07a3fc9f42ffaca1deaee1190dfc8e211e1fdc8fb911f29364139eb33736367b2997daf5fc4c4d8672de369dcda7a8753a098985990f64af7507e1a1de51ca9aad4781e9427574a9313188d6a98571e83e461c0b7eb0a12683ed0cf7881a4141ce720056670c3beaa6e9b82264634febcd19ffdb90e0664474a2034f427334cfc3f75446001b5f80ca85298b1bcd727dde8f9e7e0b8d5e67967c1ad89a30772f524bac23e29296cfc25685a3c02896ca92302b1684fbcc6d2bea3df769e9f944136d601aeda102e64d168c2e4edd91bcb2375e24536c3125fb893c8fa67efb8fe85db58ec8cfb316d626c6d8bb8a62c48afae9fca09dc99ad79ca78daf63009e9f2fc3d894ba38fe24e0c009bd7f3905d1ffbfdc66f518532d4e756b555bdbc818e7938ce8cbd7b4c0150d4ada508c1748e97aacfe3de5f80cab00eb622e6f815889aea13e45f202229a055b78d6200f0eef7ab1fde6398090d088dc94721349386e39832d91e9b059b97e979417e056cf0e22fceeaec9250a8de0d21a815049b6f08751d5712d58c5c991021adccd606b36497253cc5ab8cbbeffebdd6462869f76a7acf662c4b317eb84e296804152b38b3643138971c897987e2ddedcff1db7ac0c3aff98b0cba3a95819619295ddfe72a8c4a95604bcaa193039d5a471428476865529694d4384b2e538d8270407128cb16bef6677895db54ae3c333c8fa98894e739f325e829c5b3ea9452f0e4c3c2d2e1ada93602b4ad7a4a98c53b30fbda0639ebfb4973f1134b8c57458692b7761eb8a30ed9c18e86379fe3e1d55fda0cd7521411ad64c5e07e02c3df85a4eb4c4700d2e87c7180384bf243965ba27674f3a47ffd0c67f24d245474679f8f1a4d18009aa29c7fad72a1c33b4d000f92a4176f16f8b8171091db20b3bb7479dd64850b154edc3c7babbebf286d6addcfc9b0a22c1a3c8a9773b652a459acf01d72046ae51b9c2f83e2c1ec5a45e16ee4968bdf31d4df393f3a45baf9ff601ff53f1b46beb330b269d238ddc0baa3bb7721734e8956c94265321274a315028d25d9f8f1a3ec779422250868c557e2e78a2bc9850b71f2654f1b4cf07883bc03d4c61b343461bf89aac6f50bca10a43e45837fc97e2d7a46718f2907e75107585bcee32bbd13acc55f83bfbccff8c865c5597baabe1f52ed7d66b371d3aa3682612887d27ea6ff7fe89bb6829ddfe23e50c90d695a7d2b6b94b49020d8483f3c0046b4f98c26e6342124270d17501f09804a60b242ea4b86fbdd820503a408b47f75129974298d7de7a4f9d8de773378984b6bf7dcecb2267faddcf0cbf653d8b7c078dea99109d27f1cb2f2f10d3a29e66c9d3b5dd3fe05ed248165af1b5282a8326fac263f0f87292ae538e070d23e6022b2958885c2a35d2437572534cc8f271159abf54a6a4fb668de887220f5a4c3f937bcb225704a9383a17120acf6fe11fb035da663dc3c17184e7834e59ac485dc900d082d0e8769bc51437b5924ba0a9de1491f025cdac8efc5ee820e4adfd41458fe8c3ad0dad03a746d77540015f47719b1da427d72284112b41680d1aae6f5c6371ac81d9c746187b33e06a9b5e1a406c3f62ba7e00b001a27ab7dba8655ac69f1c98cf282f0f95ae3e9ffc03a1393e81894e6fb32b7504a098d2c6e9be7cb1ce5ff838376a1156766cfdc6e59b77bb1188e9ec962c5ae5af12cbb2aedda5de5ee7005da725de65e4aebdf70bb20dc33588616f1ce14afe38a146393bd75f64d714e912ea7a5f742aed1023a7f17e05809cb387b31fcd484f3ac86d20f764c3963e1ab151115d006893787d10e2219edcc03130e5ebe01951e5834e30cba281138e5b1a011c3938860920152fdba938d4c4d7d598e81046ca38ba4dd5968aa8d92cdeb41b7bd83e65b4c023db241835faff2201f3957f94bf730f7370040566c28f527c307683cab5eda02deb966aad411373f2a7e4d9087b13a4ca5f6e211f2d8e8891b833035e93d2064731eeff05ed684da010f81a5f7326497af2b9d2ce9247a66def001a384cb422e8eee200973e60a0071044f53847e15ae56659a69a126dee2a3e460851f152655408d3d5e126c087f1957ee4b19371f446116089060f0335c2542d8ffffa51d147a36f9182f7c949e5dfe3d2f2944e98f7582c47ecf609bdd315fa311f9d0d9d2a87931409203fba3e08e32aaec3471034a96c053c6bba65dca9ccc8f03debabf9e2ec688eb3e3f75fcd1b50b048fc0d2cc6f169e9b82e65fb13a41303bf31c64ef797df0ef63d2620b75f5c5d205e9473f0af0f535e04297216c98ceee8677e15ea0ff3c7e5ef3abe529b81ea9af8e2ea25c86a3050437289bb163c6c759b7fefe6af93c6c0fe9a04db6cbba2491dd797930865d5247c0271cf2fd8359507dc2d25c80eac3dd67bad0645794e95a25cdb45f37977a63c09b90db872810d9932e40edcc103a468ff21b3fb56f0682c0b781016c3e0ba72838451525d0f0d5c8e49bce57330af4c46a8593249f5507d040402b69f9351cba127d46eb00e17a64e40a22e10c1f8ceaa5de474cc7929ec30956458a6b96f8a02167144e60d638c3f75757e43e029d5263d1db20189a289507f827f10d5a7db552712766bed5a0d3aba78a6eee71585522d401b8a72ad7709a9134a2d6360a37a35c905140502e0159cb00992a59ca3654f4741d00ff36926446db153bc64f4298182d3d75ad891f450c92092c08d091c40931c61facd1ffa1a586e53ee76d81adc19a855b2d78d7aaa58c64c2e1f4c8526a77822dfd3ae1701af9b83bc212e7b1e586b9b9d703bcf1f67496657c93c2cb176b6e452380366e47a2ce0085e5428fd1fc258694e58452fddcaa7c3e116df81e17c6ab3f01c9489e4be434ac4e37556235188d63e1714d5ca686de1f9e5f80b5bdb203f8d428f6a594dbd99eb3e709d382e6673ad3de074c6afb7d2a52761c9ac55a860d7064120d5711476b0f140131fdf1813bc80a2d4f31ec633a870de874558a0360151b8261c6557415fcf2095ba77f56a4e26959f63ec89c5d0cacf56174d76a3034624f961688d71bbc0eeb179baf578b7515fdc2e6dbd9aefd0aeec57dab398efa48cabb7828fe36ad3ed51ececbccdd1bbd671dd9b1dbdcf457aa50a4df155ac122f8c2278d8ed0e63f6c6fb28e05511e58f5d218fccfe6fafc4ddf84f35e39f67e50b49de22796147b4fffd7e470aaedb7dd7cf8044f8756806883ee48ce1a82375106c66b6bfb6ced7c2ebfb6857b980aef68b01a13ab5a11527f1ca06d2d1ef37ab583e14e5f6d51dbe4053f4cfd3e7a88883654efbe9b663ec9b0411e795a77220bdfc6f7052ba94d7af2d94170f7918c7f7a2c8c6f431462868c4f8d48418b32ff47d4fa9cba871161a230b3d54c5155fb2724581321c06a3ca869c63456cfa113452030f174bfcce183256db72b452f7aec6c43e9f6bd3bcb61ad63ac6cab9db13e0d79a1777c503c6d31f2e625a12c6834e9cd68653f6eb53bca56207d5afa4e3f4773ff6b8489cfd61cb4882999a6f60cb9aafc90207b3a195cf509623c91cdb67cc77377a71d820cf91dc7c914460f8a557dfdbd384e408cc597cfaef0d58fc2035118fe676ee7128f3f631c9802be3b0d35d550e465f0a7d393a5701b97d6123b69731b20b3b8cd71293371f143ac47e07750ebeb12cf812fa62fa99e4bb8b81f0416c5b3f22c6d60e3f7c8f6f548f47c5800250bc17ddd301abe8fda1bf62d9143af9e727ca38235d7e42f5c67b0d1771fd8ecce8b544d4e9f0f16fdfecc9ba929d8c044829eddf18dc7c517467d1165014268839455e84ea7be60a62055c37e66dd6e0d19c39cf082cb36f8bd0bb2b86c969a4b22119a303da3712c380dd6b9e2b1d6b5f77b417e2bb86458a1f6e2e9f117d73d82f0a834b0f44a87536caf96485683c474ceadecf24cf8ce39c082834e7171159da4ffc0e2a3e819e7e71427c838c4a8c33259803f383957c0af96d8681b78e9f80f86d7d3e9a98df2203df30255442592e5c6c4df7458e04fe8d2f681275e34b9a9eb918b0045f799a8aa77c8ef2531d1969ad330a60dd8b64efe0c31e34c5fb237fb8009d696057320a297f61f62ba57def247e0abc8c626c426e7657c390561ba7a64ec16631a55a5f8b6295c73de14bb84ca52557c14fa39cda789dd48bf5f4991837","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
