<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8efa5c4ff55107abc30a19a6ebf3d96bea4446f97d262587e42f8a97add5585d514f71ff9e989e4facc3fb26e5a251425eabebd8e35b212f47af5e97dd8215d28e2e9601ea4c23a58aa8c2022e785e3df4db13a3a4bc537e3cd5b19d9ff69778eeb9f8a6f2bbe8fb3a78802949d214e0e1080cc6b35321b049097f33c3d6408a382ad7e89fe79c0f7d385bfbe75cc556f98e0a2ea3f3809b057603545494d25d65a90d7a2dc06c6cd788539966c78db1d3de2ef8773aa17cbfd69d6c63ed05a7560970e9121d31ef55a5606eff52eddaefbf8bf48c1dfa1c354225257bcb24a23d8b955007e6aec24bd41bec3a6fdb7121cb7137462d0e3873c97a8597d84872530f3b6dab639fbff368e684fc78ff59eb8d03bc0f79420502444617f891a3288392a9ea976ab7551d20c54b064a200617d18f096b2892197029b06dd6b450238c08d6af4b8852c75ae724ea5aa1638b2d66780782c682edbba2971bc098fc3365716ae689b2f005ae06c10b7c08b360ab425b598fb3c045187f1e50b04f8642110019142c2482f92f6b5df6fd37aec4f1329096a555942394fef129ca313f071364ca3454738260bd8086bd9299718bafe41bede9627e2ec11e69957dc4109b74b3323d95530eb5145fe03e80df24c0a2342d45e6c64318b0153fa719ea9dea948a20f8dd312f2d9af53598145ea6eca4d33a1d81f712e426f8c3083863f88fb83965f1e3a4a87ea8c2acbafa554026621ec1313bf29410ce2d9d181028017ccc1992a6b9ef9252dc7708b5bbcbe9bc4fc2eb69457abebd9acd10589afed098cfc2168df805b1b0c4d6fab71c945a092067ec2008a15d53eba1d00bf7eb8080e4bc6c6ed86ee976ba21b500b8ee55f8858925ffcf4defc9c86af1d8cb9ab8adb877d317f465abc8f4d8bd83dce1f1624d7151077ad42b860652f3bbd5a9552072e96007a50ef237e5bdbf56fd416841580e9256be842beb8fa404eb557e30585eaa9f0e03ed2fd1576e72978f2cc35ab41959ff4949b7e21371e2bbdbbeff1cbc95f6a77536512e08fda75d5ed8185c9cb20ec88c8bf4688359cbe4ba39d2f4e0e61b9db0fbfc6c582f5da1e221bdbe65d681f74f7a3ef1f9989c85c3c2ebbed0bbfcd2d2efad5cb7166555edeb313755fd09f83a70894fff719fe68bb48e66e99a23b8b52cf1751f47d683af96deddc55521471869893a68419c6b09222f7f7ec97350cf0097d2b0308ff0a8ec635c7f25f3df7cfcbca21884ee391e61822e2815c14b0ad4b24d236cd982037153f39cee0d7a1c1ef11c8173497dd96af07ddf4c3e91630770b31638cf03e25725b131440e954ded6e68ef70d3be4bd82447f5140d2d4dac8d2816bb1e3b80310944eb1b43c7734e2cab9f6792331e58e3af883eab60eec44339db4ba6bd3a19fb12257567a27fae6b51e5d15722df058b1d26f73d6accb6b3b6bd3eedf8b500a23f3b8d6f3b1d42382f71859d5a7a449e5e15f96e75b8751a1bc209fb2af6e1d70e3dd6e696128a94e832a0f882c02268386da25f24b5959a567731bcebb2c317e418664c7450275926fc8db1afc67827fbc608485179b8d6c2896140874388cae97fb224cb47931a37f4e59a1264d1f34e2ae5826094243bae74fed1771c3ebb90804982213913853ac80db503ec802b738d97f75b95c7328e3bca49175d04f42d19b3dfb3f71aaaa28578773f32eb5db39a995dddb11c24d0e101d418e57656df0146493a4d6134a5d52b3169ce4c5b1670b72bff642acf11a7b8e39d1a42d3863a87f458e2c8403475fc4c53852b5a07153bc8e90fe5d3eace08823c989bf7f29075cac61f8c1d034222b7b938d4129d43636c56da4a59c866406edceee02081bf6302f72d30afd03bf87540d0656b3e6a4b73a112d63b00386d17b002028bdf07a0e6cf9f9a7e8aadd5ee4bf046f7d09666e74f50f6d95e8e3f60a546d7d7bcae605cc3cf11258b3eaa5a23201ba987e00984add1c7467cc1f281db8ac7e84dd657e493199ba8d40ac8f159d862e8291292a4e13ec55fc548fe418833fa3e07cb282bc591471f13d2fce34375434b34f7ff198490f4d007afa33511b911468085bde033648e04a7363fc37e4df6fd7e5a82ecb583cb07af2ba9639f4d9dad76522a71f7f6ed2ec4bfe63a84989f2d77d842b2f88166b3322a1d9f1b7217fcbce79e76ce1adb37f24fb8b78a0a2cdfb208d76139e8e868cf787371240205a982d415d795ef6335908318a01dbba60053ce7a7267cc9fc5933417db6c95bb04b3fbefa5c3ccb6aae066946abfc321cf8a9ce2beaa38e3c33ed9ca2268001edce76c0f8084c4ceae93ee52f6f15d76389781036277f5ef95807cb951a0d83a35b203ff7c222ecd2dbd83d3443a9fb02629539f22491af5d64a968b50b874977853e6d29e8b7cf2f6a6f9a489a9ae93b76a2a8be88ffc9bd52b4a1f5b87788f3f114dced04e80681aefb4dceb600d3b8b1716be98508f0c0d10b30853b104ce4bdbe15202fb1068e8dd92113a1a8a11cff39d6aa795859d25c1cb2d60c9fd14540cd295604942c83684803f3c78f92c6bd5597b2054bd0a71f609d56e547b6f14c431546769be9eb8360c9dcf2f632db69f0c3f0a07dbb6b78e47d94cea751708101966bdc4a0490630c85383368c92a12abd74253f31696dc823e67a72b7102e017feafb9380384e7c76d6815e9d7397a658f662f6fe5f1b4364b2cbbafc3fce5b3edb38ff5bd9dff602597617e77c434847f6c040cc5c2b350c6de9f09f4d83c8a3dcb0644610b525d54cb68a48619b9ad31492320971d57106fc73790beaa8ca52a6353b9a9cfae7e457f37bef0b01edb72dee9cd547603b4c1176504cf0b6e271e6517a8f3cd8fc64b83e16d81ce790832f34d5c8c8a8dd025985817d379185b2edd6168e7e8c40d911e19e5ad5530796c0601c953ce11f07ab0b6c971fa19fa3f0b19e2f2cf2a7eb0404b284263a97081007ee499302d7864d8858aaefef7829468545c64e1f29e4957406feadfa7ff2b1a208290962404891db9f0513314c7215e1e2ff4824a8f6268de6e2c66fd02c218e10dd7acc72bdc43b45bea5d8018e5431de864f312c8ab2ad439b82cb965b66b56514c4b17e7ab1c977a2f41f4fa4a116186b7710a6dbbfdf864029eb0a056a865751977ba444ee20f36f80117b1eb4cb43d97c1290dd73c493b42a7947147244524e637c7527b8ffa189d0129f443748112c3af5be42b47f071427a3a2e7d25d152951d57de8d310cc8ec7442f9601294e92797447c79fe78dbd670142f6a4d6d6be14462cd05713eb0e233c9752f7568a0d9bb9bc6e0d583d36efe37d151e456d1954e96ddfaa5b4b9299bfe8baa89814a7b116aa4fc716505dd938c64df1351a33bde4e7a2c11dba793f028f95788dce69aa872dfb65cacf8344e52624d23d2c4f2482ef28a361c1123ca1ac4afd65a83bc0676b51834ae23bd581d911ba37be8d4fd9b7f2a5035942589f23a343bccdabe7fb40ca9cd18a4baae4fe9528b3babca8b26661bce44296f1016af081d7b34c0d2631b1b24381ed468b667f7e8082a857c139039a77cd6a2530b7bcd44e293830e2325aec095089d0552128102fc34052db1bc0bd4223388b0721e01d485341717e6d2ea34798cf12f82e94607e53becb8549a2583dcb74fd6e8571a532649b05f5c71079141c72c71c7a2e73f8250ecf6b1cc872637850c42dbfe6478492ba3277a0aa22d45a347e737c668b57b8e3bdebac9aa1fa56cb9ff2ec488b4f8cfad2db6f59c42db3ab1fe223a3c8ecb61410c014046d0e89008be1017d6fa0ededf47ff87d6346ebf78aad15fda14d8e8a2897511528bbef3f648a48813a687620aaca6d9b2876c486f3e3335e038fef4ac9e581b7dc1e514ed012c894fe27bef0aa5e8e036e472c50a9e020ffb3030a7233a1970b97810b9affe2be90b4bc4119ac1e48d4c6de0be82ca44bbe40219e5bd9417786f7e5780af81a0c8c88a56e46aefb7cce88f1f91b24163a69d2ee7dc46216fc95feeb1754b17a7febde752e396265ccfc9c2ad1f96da945248228935ee4f2ef08653a59c4bc056fa2bb4616b8dcd2159ddb6ec2ad006b743b0e23cca248e1899d36b997549ff2a5dcffbf420d626c6f22b8c3a20a9d9c52e9dd5305fdc4d7b59419cb0edc4e3ffd0fd544abbe32ba39b9bebbdce0924d3acd5f6cc82902bbafbbd5bd925e5d8023d198f92e770bf2bcd52311ecaf1e78cf6f3222476848510932e4e01435596481584eb449d4be4e0220c45377fc2440d56c0c7f957cec4d52fd966726e1397d2a54a39b288b9ca49c22a23a8aece65dfcb59a938e6e3b950dc312db96e947af98bd785d1574e0a3c01efaf4b7811085eef09f53198842e2166eed8df11fc612006687e5a74958c45f886af986d63a4a2add32e70eb827e48bcefcc7af65cc9bab34e6da7672d9b82100fa3fddb9706b530adb7bd87aaf3daeb5077005da82d9b7d36f319aae42fc1e7facfb8ba7917ec966fc6eeb6d9ce32c0d3241e5f81d7a96eb9db9a5698468cc13987ec13796254c1207668e86ebb0471ee26537c818a54329250cff76d589830d5820941eaa2f67b0b30cd79806d50184e55d0a79a50d55cf78663fc731a90e663a1beec79944d2a1ed7b0c13d594b5f5091bca68917190734c01c94fe73c1ba25936754159089f2a5781bd274540f5896db58ed422647d603c54676188eaaee89557c5fd05d5b08da48166c8597eb7609df9c18846430e3f918aa5bff8106385edbfbfb007a52bd412e577abfa91f166fd9b520d604f42c6039958669872d8f6bca81bc6c8ccad682df093b4ab0dc684b2b4b95f04a8a95aac881b0d2a3d8096974bfac9b428a4837923d6ffbd3d445231d724a5faf437e69f4d506483de62ba027d6390b5b0959cf6ccc728e531db08b41564dbd58276d7ffbfe3a0fd8fdbcabca9a14db8a2856ebdfff9138b30b90332aa4ed56f3bd05815353a076952692feb5867ca9d86d7efa443c3cae422efd517a8a09018306f7f8ad1a4d3a29f75235c1687cb2eca717f3c079f61dc4d1db67e6c50b2b2b0e60bcef261519b233040c1f39f9818666d1636e427bd095d9447c794c4b665b92ed1142ce4f21b787eaf662a75fba166d706c0d891d7bc2f93e52c13a5ef6c881c8de3de823dc3bd6bbc0bbf4d0870dc54135b438f613a04d38414049f9afe459eac22b9d22522fa325d541908ae226903a586862021df88ce7cc35950340b4d09f68329f4c825489bac6718163fd74218c42ff0cecafc848664b6ceddeaa825394450aa1ada92e0eca43fddd6be526802780b653b779b13aa44d44cb2e597c37de0cf21efc876cb20e962bdc262d16d12af8e6f7e2bb30340e13c04138fcd58af199c6ffb6b6894228b4fdbfd39c3b7ed6c75ef19c7c894d0a8ac4b97be82d31455a773375a61cf71b617193a561253e33f13a121cfe966adc5d9f360b3248067f56bd4c4dae0bf9347cb73db35d43040d295d8cece8ffb6d259f9ee7521a4c4d177c089c7a7dbf76d9abb1ac1d5795ecb28da8e3a9586f2f01bde8f4da442a8923bc33b2085a9b196954a50600423299dc155d67c3d0f6a9b55dcaff821c236bc3ea467e61e5d848be6370638e5ecde8524e5198984890f7dc36da2cd6ce931e954770e02225cd3a5282ee3b3f2872859ad0eab61b4b55b57de7ef7a32e33f33d9104a19a808a7f673b446156b55c38f7b701a6b478eefd97921e4ef0b40fc80b7493f212c16991bacff943389554a85cc761a61a05154149fadd2bb944141d080d968dff2db6c60fdb6ea6022fec01c5d46f991c2a60aee9d29e1040debf353710182f4ff81aa131b52f689f4516859287f681380d8ba73af6b7693d125929cf0a41ab7613b45c3a0187ac21047b1c71b4bc2bf3104ec0c21c670dbaa68b6a3a0c59aa59d0b833db2d1ae07a9c6e19058026b6f850bb8f937a1f94f076bfd8f9cd64e52f83270b227fcc8c2933fe2af25c833944f733c30228c82f4150476c0ae6fbc8df6f6f3a40cd92b42b12ee7b7a97a6c9c811d5084450f803cb6bf7726ba90c5592511c4822e0537de40eb3e5e9036dd0545b9932dc7379884d50356e5e8b896fc07084053fa143bf818afe8b923fd91b2abfd403c4e70f295e7e0865bcffcaea7c9618c576479812a89d27df2649edf3c40f5d9265b1379e7b7258bb6f3da6c8c18cc9d17490ce659c9d8fbb00775c8855c4914ad1b1981a7acaaca8652af5ec0c9ee47534cef8291a3d1c7be8d2e7804eca6d673794e4b1cd70f5ffd27c244b18b7d0b1ade5eed7e07d8c3ff3b6551201dd8d701ee1de331a6a4dd608dba16adc047c4ce01901e7d2996d08bc98bc6130ecce3d36cee3b67fa7fbad535109aa6fd18c2d25cdfcf1801df81566649627bcb8347f040ab9b1534901eb294d71014673a3562b979f8cfa424853eb0f255886ce2c9c6906fecd65d165675965c7f9a651f6e75493f77be8d9ef0f3a23c3391121e2416d519bcfded88ecfd39e2978ac09e25a7d8b83364c7964a4130b867f2922721fdec110aacccd44949133437615794f5c54c5b656c482c95e34ec17f2ac3629c895c582536763bd85c42b510ed293538142d9d2b6612ba23b2a9770669d826c72f9d12fa6eed4c89063bb29f11aa5e9d519a7a1e7b76546db981e19de02862713c0932ff2254420545995bca40c09f1fc3fab18252290abee57397b5e1a5847c5ce7932fb37cb2d1d167cf59a2099d022ac123430f8d8c67dbda01774f7851e58703a30e7d7d1b9e4047e200ec68e6a5172303702e998790fb3efb5547e87145132c9ec38a520f953d954ab45dc8fb1fc619221b214b42e2b6f1dec12c0830c4dad0041acaf02acb2a8584210cc77f2077dac81f0ddf32fb92143710187b444c7c869de1c2f6513413800807b465a8b9b4741fc572f5ba58f1c673daaa0f70083c794d30f0b9a01fe308a8db3bc69d1874ccef1c2814898a5e119a987a666952a940934e1eb2e07dd107c668dee35a826896185fb7ea88fb4d928d935c2d8cbfc29dc8c7afd48bd1ea4041670edf37929a78dcb269ed95628a660af00605142b04933d1c2f8962a1fa294262ebcb8b9f137d1bc4960c04f4206712b3c24d67424759bed1948ae04e37ab38020fb39cdd78bdb2eb83a0647382a8a3fbe8bae7ff682d1f105c1f5c705229373663fec964d406843ea3277f760f6b6c473a5a1b067fd10fa92024fec57ae4ee7b49f75a32f363f18f4c0c72151d69b6dbc9d720b43871d583b37f8d30911a8635f99307a23bf557f5cb3d555f883cece746ef944eee429deee076e839429562d556bfb929a8ecc9a12620764af620b94f13e8ea6a74820dd619151b2c6daf9a42c14ae8d3ce07100a73792a7b82c76c923a6eaa37c77a4dab734f381cebb37e300a2c5750e3d3085e781e92a769eea5fc668fdcc844e7a9c01ec9364e20a99e3823ef56887a984e4a49ef1feb836da1e52a7ead85f20bea390ce149fc007a5a2d6eb14c627ea4d843466355adda071e3734832ad9508b2612e61c8ca5aeac5f3ed3d231a2328df7ae667f4e6bcbd6c0a5a5a296aa3563942fcba791ff94b8319a7476225c1b9ab9826cb88080a8710ab73a5c592d29a0facbe4e21ecc378cefb82dab9e0d6895ddd4fe05014ad0b2776ef6958868c323bb0ae5bd589492339bcd0f7c4e38196b54d5a6a376d9e47499fac26b3eaee63c13e037c46e40d6b426e4134e0533671d0a12fe213bb429a8b887fda68d2106142e59727dcb335ff28d18919bfe92f4315c53e798c443a62efed1ad13fa9e0f7a2159eaf3f9c6c61b463d25e05abda56668b82030a4b86f1cd82620f28d4867d8d13dc32b826768fcb0cf05a72ab603d4b50c7d6e8358ddbdae23998410d4e38d619cd4d1d21964f8e2cb54b6b245adc64a8e20e589a63dd79bf95200e6b8a98d54dd1e2c59afe6a3582431e6ed8b78af5fdc2faa49f88b06c399e36b59ea738573057382851319cf8a9b8ff35542e6e5ec2bf0f0685efe0ea33015e33126c0a2372038dae06c642b05be92050dc8ccc7f733bc77a900a9596f6974bcba5002407f95ae4899a35713fef798ae74365b23ed743e5fbb1d07e38c0ee1f1952f815c39ecf2e8ae237dd61341614aeb80d6fbc5d6949ed23a6d8fb23408c87bc04419fdb2a1039293c97298ff65707acb452c792d87d1d80108c01db7f912a18c852c3643d1a7f9f392d7bb58d05e3a92c3f3d77ae81b4fc0b5153f834d00cab490fd0a171db67f73453aec4625b2ac4c30eaceba9bc358df558464667747777bbcc561a5e338a695eae7427734f4b77966b1aa4890d2780740c907706ffa565ccc323855ab9a7c23e43f02d90d9773e73c5b898700dbf60bd2da24b301a7eb51f83f641f96a175615c642fc028cb0e3b11b827b0d014b5ae65664f90ea91c5896614dcd3dcd3711365271e154a0083e7c29a27c32c3dbbd8f15681a9f4217beda87c7baff4b84f2558209ccd6c1a6ff18eacf548fdc78ef88164a3b25f2623c88461873a0de13fffa644635c83c253808cc460c53bcba31660bbfd117fa0c6b7293b4b61d767c2ff25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
