<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"80bb01ca7b7ae483d8e386499edd738c3da147555bf8004626252c7fadbf8d893f1e3b78024c39d8d3e0ce323600d72e994c5c9d971a10a2713156feacfc30c18ae0d3cd3b507c30f81075d54279bdef0fdb8d355c6eb12669278d4afecf1269e836f19d4c8f24f82cd244aed2a16dd4f870b284d459bceb6ea1e25d768fe95db9e005637533ceb6635c204e9c757fc1d2cacdb9f7a87ebe20280bd0f82f3f3dd8ab75faac463984a8144373163dffe0f344ab8f1bc4c27ce0ab8dc891f06fd6da22383edfb85ae44d793af536d9011365661aeacb34eb7e9a5ebdf3d9208c1ef28123cff163e1df677245a9c5ed06ae5be07a51a9999c567d9031d8dec4a10cf33e774c014a8516d1d2ca2a8a86b3367fe9a7656c9a08d13c854eff2f47d46d4fea161699735055cecb1a1e9e4a37315a6d6e676de57e94446ecf26aa825720022f5f55c2dc5159e32e80e0764a6c09befe59309b1aabbc175383dfd51bc4ce9343a7bf96d814f91dd08bf275614b5a6ed15275318ba84313e345d43569ad245d7f03c2fae32900c20b9e588592fa1214a13c87f0d78ef383b534197274dfda4729ea2c8f40a17d86bae9045d8d34c3274a9b8e9fde2a56c1753fa9317fd9542c849a7f10727e8c86af73c70933ae5e054d77a992d0e21774bd65aed6508f11b8bd1934456a37c4aece9b5e9062a3c0f9be400f79714a416827e25f46b5f3cb8b001235e9a262ad188989521c14ba016226e87f62c01805e761b087ecaa9af03db8207e738aaf0944b6fc935238711687f43e87b12dc8ac5810c1043265fc1daa0cb27c87bd8af5be56df8e0399c44b79a9befa3ac19fc811622b669e72f996131e03c96daf2994802b8e55e8890ff7565c77f315bc8ac945c9f9d8962cfdd1091c22007e66a7323e2173310b47bd7ec8026762b444d5f94144b8872c102d2e0913f21e6287b453d37a50d3672f8df96d998357f23b43b4f15be2552f09a1b1337430c79ad0ee1a2623ac419ce7320053ed40d731a7df11ae9a68c7b653017ff60e4b298567adeb1d54f5fba267e350fd3d2810318dccf23f6550f2457d9611486c0da99c510f7683b6181087c5aa24b05e357bc2d3da8802b9388c7889da3d6253aaa9725d19ec419e7e1ef4d8879e2cecd7062689ca7dbf75d693495388c7ee3f333073cd4c73ea77d5ce0f8337a051250fbd43124cf0d9592fa703c39242316cc5817f105272d6aa89b0c26649497d49b0287dd62dfad3866445e129af107e5f344fcedd648b79b5d156d85d897c1b9e28ca8beee91b59cead8fa5df5d8a48832cec3512fd6b5edb518e830390ffaea9a60971b47862176c6f3607c02b03eb75ff5fd7493ec06e1c7716f989a5a1762ae1407da4cadad1fb7697f7015add511dda83d400340a3d0b8358a6a5ca0328f954aa6298b884b7cfcea70792c335e7a11fa7ed3bfb51e8403012b2c2e22ef054595b055fb314c14a142dea46bbccc319ab31b54f75b8f911398af5643d7967cdbc9d8249f6283992ad10b9b072dc9ca40ef73cfb7254421dacb9a23c0ca73e9928a647f8a0c18e04f586d8821fb35a3a10fc8ce8592be99a95afb05143954abc96c49a5dfead4fc0db2c7f62a94c0bf6b54915b05f4144d4084abd9f7cc9f946f49801bb1b5dc302cb7cf54a988aaba3d64211d8108be82f055d7fa7374823b92f8c020bf8ad05b5c42816cd424a1a3805ec00a16bd82964cd12c060610d320fb041ac4cbfe4017a80ebb9623428be1b98e3bd52493e892b4f0b561956a9664d6aab98a6fe27e71f4bdfead2738bd5cbcb6a1ddad331e8c280f4c9759941f87b443fc821a38aff54bd915f45b9d1628389826b199834311dd0efdb0c783d1c837de54d0e6c9419c01277f3ed4e573aebb627bfec68c276250ebf9ad60324fab1cce84b2727ba8976fdf5d0b6121cffa8383dd1821b488f5dca6ea62e1018e00dd0967c225b6f6acfce498b63f330448801666b481536cab256cbbbdeb4fcdc046bcd22fd1a5e3ca6c8918c66d16a9766bcd54d1168db5dc84a079277085360f55825d37be408686657aa705990e2a2fad9df09eafc7e5650c93e772aa58a2b3a118b4b8791627f27f6b0bcab85fa346de323d6cdcde9fbfdd5990ca830314a7aaf3ab57b5e7a9afd2d451abd5132cdd24829089b8a96244b25768680a1fd019c6c2f875c45dfaec17cf618c94d2cf7263cfe1d1025a529f4f6d98033abe9d274c25944c167f0de42afc41382fee19d99852667f23472d6dd18456d47f5cb3af33fa53ef6019b04bd51020461b633bb50e55ad36329e6dda6e2f2f811a5fa12b79b46210aad576eb3261777e4b98b6acca09348a311c4ceb29b7038aa8fb183e8bc8894c38d66fc2f80b85fba5596b0a2c58d45fe7dc0f8821850556398824a852689b2537759d1285727e4bce03015f8678895eecfae662759222beb3907e4f57e4395b0eee8e06e81f2c39e3f3e8a6bd7bd4144b1fa201147d0b3374f29947f072c5ed713d15699520f2c77a9c0575fd05be8bebe53aa0354965e3b33fab75f3bf162be49008450de00c3a6ec5f48a8dd658b992c0bc07f62ec61702b60eabce5623bdf50ca3c40914d26cb49d8b310d1693cde98d4964fe98967511e01006df1f2041029ec563fb2fae1c9515f5795348589abf8e61ce07305039285665d7748b7e86fc48b224ec51f041a1ce8d10f3ba58c5e33910e07ea09f6538f6db4fded4ea9fe730c79b8a036fa4c6c88af6764c6fd53b53d80ee0c98f2866c0fb5a43d7eef79f870a96bec96cc26479ae3e22b4d4d9e1f45efbb66d00537944d51447f631bc795650d0bbabff96bc9a3dc0ab4c04df089f7efce4a89407df731a500e388f7995a6593bb6dcbcc2f7aad30c8190e8a67e0de985116869087dcf89bdd238c9336b1ae0256439d7f489dd1f4ad81817aef7be5440f4efd4b946580ddc946a48ea0e6477b508e856635a9ae173c9d16d78dac7fe72f248588f5a8e8f3dfe993122fc4d71fda4272db5bd3c9390b08697511d15a3d539a010dd2fb13ec8c6e8fdefd9e5d649694341a26f790d3051b6c2b173c4a1eca02dab06ea6301b127924091908a6cb306b9aefa5cf690aca235b6cb9da6e7d56d054488e9d7ac341fc47a49a0690d55400950c99e019bafa06c7a00f6ea39525e8af2a38089d433ebd2693a880d4174d29b8e3a9681d0afdf19686666137f806c7cae6b4f3958ed5d96992bbda5868cffc2dbb3e3e1d3bc303add29b64244d00dc4313ac9df68e886a6e33c74c38abf6f2cfa7024bff735df258c2375a41e75699b022e8d8e130e887224a04e1a1eb97cb5fe4ba046a41887c4e3fcd12ea64e716ef2d026b02b768ed8a4b85033e59cf76e3d668d1d1f96f4adfc880345892a134b678c2cfc4b099efd90d295a186c75db986eeb80e5c121b6c43f39138eab5023ae6335eb70d9f20bbc4451e9a78b7ef0b2318ec682c705d62953d83374ede110e267e95c3e337e0de6ddb7d8193bdb847d7863c30fa75b256b95837010eccdfc7aa05f3bea6352531147c89a07a9275e90ba66e3ddabf63801ef6992f75fe4bb514d6d6624c388047bc3f61b0ef900e543e14ae0f9d1eccfad012b4f2d5bd79361cafef177a348ba4f03837ff8c3907d87c223f6d15a82da3faa8112ca496c670806c377796523a38162f60f2f91ab95c456ab9a0bad2376e13d72765aa9ad0a00deea3d000c42529d6a8b41011953e884dc26eae2f5a924c23e87829cffbb674eb1502742a09942c54e23f834ebc5247bc61a8d947b1fa4214e72f858e4cf671111f9b38b9ba97bbc4c585bb62f287f689732131a86341b89fa17cc437887d27ce4fde0064675b506349895491098c0a12d28700c1aa18046917a4d036cb688aa4ab6775fdbb94b77e087b1b8e80022aef4900a349ea5dc20257c161892e430add5ae9d0111767c4ea61bef051fd0f85481faf48e3aa8f1855409af745de630d904297dac7d86da16b0dc792a73c66955e6a53475debce7cb84fbb89765323381c1ac0fa7a78642f49df4b8715056c51356736fbd07617a46f2f54b8e5eddf3030d3bdcd674676dc6fbe02a71b7a518c8123b87b4b165f2eb5f09fcf7444bff389d3bbc541e71e49a8dfca703133dc44ed963842e1504d92cf15e7127a60e8dfe32ce707ece7f9a054a7338c49effa5576c8cb05966f8ac98275b5fe3b268a464d3148c62a208b4e1b2b928a5d39f5a27b08362a41ce5078531585a73c7bcbc80583f79b96963ed7248028b17e89685ecfa5d63619fbc5de141cf8d85039a8329e02bff60fa8216f08014e0c5171132c5557bbb331740ab7a096f27f223621427894e67c172887280df6a3459961ba9b33de4109849ec340b3d3df8e1fe04d3886f17dc544fbd83c34e263a7bbe5a98e72842b3aaecd20e13a28cdb5eb7d4b46ae83867caae968ef1b487a6f1389145122b639f74b9714fab76a4156ebf12db339beb01ceb3f0caf6438ac7b4c13642861d827876bba0e13bd7004cf9328dcdb49e14b7716cf92b96c679853f2cfc6b396a924bd5f6365a1df0b183ff1cc6d0a2cd61bb4410e8488f2989d7de3a98b0d6a997147a83c2f9247af9ba30a30890f8eb2bd985be454950a707bd62ae7a047b7777396e7e6a0b4b380e1e2a26c28cc33a37fbe2e4ba023dd527aabaadf60c47232b8fc1570640df1240b6130d46074fcf0bdd582eb78a1f91f572a15714f0234cf4103743b75737830ac8a51fa26b86c0995f2e840ab3fb09fb29ce9ef8fbf9901ecc2b2eaa14044c8802dc26b2bc047e917f09fdecb0bb2a4be3b3ccc6f1787136d79e616e21f48120b05d5db57bbc42cfc535c68943c43abf2158493ea5e05da6d6e20bac99c60006a2b4baee26570faa92a24dccccc7694f0c0d65397eb0bb3a535d7ae35ed1105e1e60a7ef99fce7cf9fe5278a5c14364b42f75951d6d2d559df301a5a4c8cbd73590801ee477565c579dbd860d2366326cd295d4e363b1fe7fa0a75252477af23f7af85eb1ba3c504e54d6410b4e863956ccaf2c8618c3b8cc0627ead1b64c6edc9e9f3df6491bdb3b787cfc1731d31f3836535242f69e3c8adfb0608866051ac80b121e82f10ea895865df70b142a0e5e05f7ea1bd12ae558a8cae6d6a95b686d7490bd884d07c1428cb9b0516d816cd8c236d00946db8681586451e39bdb30ce01d2d2edf77612c28b44903186552e3cc547ab8646bf80e0f858ce8cc6861c969a6bc7f3ce619e52748d857ea7416a8985cdbc5b651277b1b999da7a9190668e6eb4567b5142310ac1b4c4590b6c4a96750b26dff99bfd6bd1cf2c4d619e266e4e1deb5590b6a80be5a21fa90d5ddff0ac7f0ee481e2f032c4f838e7f6856ef6c88b1e030dfc11f3b151ad0846c832ffab8c2c9a1f804be085c1dffb319f688922728f0a6c7eaa2f027836f217056ec2de52852ae61a16295501d80d71b7517e6ce9fd0f5fdee347cc3df067b4611d92027c826acd7851ec8b7b787faf9c699a4b20958b3fe4bf4dfec6bf6c1b8f26866878d5119d1db7476480268c3e5d455479aac08df2948bd75f48f24dba3fcca9aff182b6f2221243d609ff88941e752e290f8dbdb5dab359d3d79c9699b540987469a40db1085f69fdfc3d6ea774214358b755537c3407fd38689851c89362117ee486e4582db5e425b9ff9c47bc5488b3a8c01038521201046fecc8c484336503634aa839e76e38a3523f5aa3443f70cc4c4304f609da1e1921da20ae8118d6424878f276fe0838524c7bd16c32e94cffe8a68870be9aebd88db58eba3ada2e328852ca47ba01cf4662c1ea575ac9af324072d86553ef694cc92feea8d0fcd0d37afd9f8186b29059da277b476ce82885c1dda89a9bd76ec7734bbb147cfaad6dd91b141ce24d548e222672f4e8f7828ceef79208d002a97775b0c360ee3e5c789b48e20d6121a4277ef1ca640b91f9d32e0299153aa235affce38ec5d6ca56d826ac6cf1ce9e9814120fa8c906f63f85f686fdbb8e5f11347e70c9c4c0458593d95f112533736ebc1016f45721f915b49af8f641bc0641b83207e20aec4fed738bfbe26f53e06ede7debb6b4314d1f35ffec1a3c3e07530449e165f340c42a85a177bd330c7f357002fbfd4f2228c8e93d4be6992a1d78dd9450a7af1767b7a3031ee4e0a9e3596cdaba59306a874c8308cfc4201e6fd316c573d4787e0acd0f3476581be284bbd0ee0f5be67ced41462843dcb8083b21c7dba8cdb6e013bcb0f2e68fc92ed0e86bf0db79d7771b5b4f675fcc002ca7f95374d9ef9c01934588584b411d06c6792254aa012b7f85912b2c802ece3dee239d11874dc7e226be77a77b44297638452d86562c844d98452a75b5b973ad2ca61dbea8c90dac01f6ec64c903139ed1efe3796b50b231d9651c209e32ec66a4318daa3ff72f1f3d858330a571d9c9298d85ba93af743b252be719938e9568e560b168a81b806e8b8b1df886304d4da74cce732cb5bec6a28fd34fbb763ca44a30705a72118e27c1b0dd833092f8c151ea3598633cc66bc113453a8d6b44b18af57c7c07369eb1e0412124461412f17f9e6908eb54935d78eb80fbad5d8955d60afc2c758fd3cbdc34bef64164a4e770e2011c1fa665b21b8a8c19c7860d1b9964b7efba08294313ae2c34d799d8cdc00e996e2fcd7028b5a32f38f4d915d67f51da42908daa2b06a299e2cd5b64eb565e48483f37e2ba610e22307d1c4c4eb5bdba5a868a407af11602743a777b95122d849210690e427879aacc3b84f4dded5f75a3342465c5dc45ce76d9f7e40167e7cef5af024801240395597388ef4426a0a45d01fb16339aa2cc142208f2f75c73fe2990435e7de7886e45c9e1f494f6d1470ac3b1df7a11a176228c6eb40c940b6eac6db142eb9e4187903eb85d889b0fbd09c59c857494aa38fc6d12f807a763d78c1565b084703ebf15ac8f1960a2b76fd43ecb47b8419da7e624fd87bd6a4f7ac4be2d5a3c45d5d68e9e0ece0247bf84d37f824606247b2aca7beab78d23b0008d3b5ef2d4351b1215607989284b55a9ab1a1d384c611b2642851aebaa581503e0e366fae5c29050b741a6c79f373c398a162858ed153cba4d50f5ae0c99ed75d43b4f5d8a1ba296bbb90bcf8b04fc884b022bec96814d82a8616f7819b80e2752df485f7d0025330bf429498cf59391519d2855f7558a2c55617e377a2443839f6615ac41ecdd1141baf148c98de3efc6baebe64dc1bed52ad18720a6c88a3d54e246c9bf8f149e992f513ea0db5c29784da72e3990a588e7b5f2e2ff54f09d00416c33bb46bf28ec9a659aba235b439c3f0b46b6947e9d70131a77d7ee9dcdc87856fc6db99f573ed5dcb5fc98134463b111466c7facb3cb64d88ad6078489e83da40978ffb610af089d52e035c42c3c693de18e2128b6bc16b6d8134149b482a86d25b23ef68249a8fc4976ca37ffe58944ad2db74356eaa669f44607783b92feb3ea84e34a26a089e8fcff21d1143012525c5e0c875f898378517754d32e0e6feeb5a46baecbecf1fa0816718b3a6909e3d778151eae17ff5a6d8b66d81fbb502d020ab0d8db26dc2cb1d7be49692670df04ed0fde2f14c71af3baafa033b5e0360e53cb47b5b5537e9c6c9d8c3dd72be524e233a890815f528d78724ad7aeac656d7a612e8d73db3eb0e0f0079dc69de2357ecaee64640d13e1fd4ad5225fc2eb52156e8901d96b327293e5b1a2bc63a00fdb8abc6e4aa8c296e123ea03e3cebb21790ec0885f4e7fc3972d4a817f3d0dc26072fb167a6e32bc5cb382e8d4982f980dfc73ce58ee14fb4f6478e4dcc2b627ac271a241d7afa98a00d181209da7d5fd54b911ba2b3433cc0f88f1b34005fe19ea3dc45c6284f97524e67a85ccabc96d072ee1722d0caaef2eb9b598632f55678cf66194eb3f472760454a9ea02b3ac311914afe8408b2eb2e5aacf6aa24759f65508615e9133e8cbf7d9d9ab2755536859c568e477fc3bd56d938858eebf399aa1347691a02efb9b02b288d009cc4dbffb3cf77c9392a9623bda7444988fae7a60aaacdeb3231a21c1b5ebe7d378cfe21c0ed24eb60c06883e082629755cf74b8b6971ccfb05bde18b0d41ddf76e32b4109bf2344177fc09b5d8a188cc852e895ee7571a60fa6d51307d42a31644066c6cf2ddaf5ed6dc0b1a8124d61f4f378b0b8d76f6b85db55e8c1ad69821100002639c075f9919b93d7669ad8d50e766078670fd0050f2271482135700273cc431cee31c0b589dcc077ca3db181e21fad722befb33e08a05a81f6f1fdffe086ac86a43bc8f4a98c473dce31d362311b3a84c4426833c8f2fe885e780b52d7a1855c483de3893c15e7a3636384b62118250384434cd705e82f98904f2f379d68bbfbaef87852d4ba74344f7b5ddf154e1f89768553b9d5d028a5de4d61697f23b1b2c193beeb276940ac36954d9f609c9be899b6de0ce42bf65c7192826d39861c23567d239c742d71e842f052f4abf77fb44262e4d6f04ac1a059aae6d4bf434ce76ba515cae391178efae7b61243d4614548d5d11c389a1003da8388ca94933abed3243ed2123ef26db55350a28816ba8c3848f444e343cfd51be9224025f54c6c3821ec2a48ae8d87782f89cffb7717d6cebc6a6c8a2edc1326aa185ac1596cfc47ef59b5f50f564c2bcf7c7f684e12021ff7b0ee55687e1492fd45acf871689f3fd52b324d28a9a3984a295da34b9980d230a5f04bde0e8a85bbe2e86eb6ab9e1482a711fcff95b45ec61d4e551a6efbeb5e565ad5b855f7f709cd49b4dd2129200fc7081fd48ff1406bd924786c93b9195025a7aedac2e6b7aa0a0cde7d55623e0538ea1256c15ccf005a466ab6a16834c52d4e11eb6bf4e489973c9b086634b2fbcfa8e3625dba006f0dbf7dc007e6ef9b3989897b45e54d1bfc099e28f99f7eab258e2274fb18f3f7a8a1b871d65914621983403301335040436760ade47899d3ee753069066c78d93fdbc7730b5e32e70cb7dc91fee212b0a36bcf40c41e2077dec0414f171f4d2d27529ea1cfcd308823c5287516378e1110d3c389173712e8cfb8b477c2c79c06e6fa987467002e6281c231fe1917a91389902240bc2ea4684397e0b96de578bfd2c09cd574e2e347b1eddc075261beec17cb0bcb6a906a4143b0ca0b47c4bf221de507e041717155e26860b5df0b44a8bb2517f7deb077a39d06829f846b99e50472f4f19b6c786b07d8247488e58b2d917fa2b8a3c57495c1e60cf4b78ee9b428d42ccd8a8e7e07ca6dbdb092d05da7603764a68935b2e0bbb021f08099269530e2f290f13155572627f615bbcd13a851b10823b07ec25a5a00dd76fa8b63676f5d710f891808d2ab6b45123bfd00446435036741f1e8d6e7ca071fac5f559f8bf120a73e00e2bee33bea1a6d4d1290f24a4d06db19b9e43c7706c9ed9ffd3751af701fe84b59d550df1f68721bdceef4badcf29eebb709218f382a4a5348dbf7c4ef0cbda6281f935132b2dc17fb812dadd43da9dfdb71c92d03dc6ba37635ad5c604bdf11abca49d591d50ebaf695bb6080faf53c2f678bd9a3fb99ef25873bb071ee094549d94d63496be800ca48941a9cf6cc7e7f84809b5d55126e33431c4f562d762f209b041e15ca897f0dbff4f0cc543aea924b444ab73f0fc534df9d477090aaf1722193b67eeeeb81f5f36bcdf5ecdb8d1978bf6887408cbf056dc489e0260ae40417a93314245d099bd25e9a80284ac2814c37e5f6bf107e22cce03d67277430375595774e23bf06ab463919821f5d213732a11bdc0c65c2ce37a3ac09db9c4f022dd5b34710ae3fb75c544790bfba223a736fd24560460cb5585c807cb3e520e6f66d6183209456ba05caf9cd5915d6f53595b70e469dc416fc7e0941e69e77f448a4299e172485be77696dc7e0150b3ac83fe814d89c7f9919dce79cae25c1101e8c24a6786b36e451b2c2e1f2fb69272e638851babb02ecee67e53c26c56a396ac441659baee5918d9b1b6c3895bf073a7c4c6b2968ff7e5dcd8f6aaeb7fd3f5d9c0ccce1c466b25a919b9a898eae15aafdb07b76ed1fe00e1a20ed4f5a706bddb3df496b66dd120388","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
