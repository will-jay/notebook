<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"596edcde10cd3d265530f07c52a5d83c54f921eee2fd5621f5e44e5b15baadd5abf31db3eb0a136bd291199b853bef5fa74289c089eac209d593fea94920bd90d97b33758e9aaabfd12dff01dda25fe8f1e0a3d98e494c9ad71151a928638979940a77e0286ace26b17ef6ab8499ad67d27ae3f1e61307d0c66652ce5ee33c968547d1032b4449aa04594162a4aad7be415b2f5f036b44c3e020ed765d1ac918db819044e2d7a45bb37fa8c3573484bbea87da215c2054990b4fbd3899770eaee3fc8c9e3d1ad3ccbd3cc0ec34e1ba203d7811e52b6257ba4050208aae9ac9f36db6795cf8348705f24be5a92a69ad4063f6438294a5f4de6e43e870c7302765c3459fc152bac73d6b4177a864aa4e5c84368eedee904318fcf8083b45bc77d1ce2b3da59bbf3f032b1fe325b6491ea56cb23712191bf410de824fcf7dd9ae9332e5bea25a89ce4a236517c2540976238913d531f515aadc4a0b65ac54aea5148cc79fb2dff3d02385b9ff92c92345baea4913be6c63bb1c5589e2d58aeb8a26df499035aba131a578bb53154ca6c23f356f4431de1566db47b4aaffd53a942460905a38acd6171e0cf0c0e6f5029433567394b31be8d57962c9dbee44b7b09fad124631f03fc7909b1eb131c8eb1e759ddbce77975c8d7f37b613dcb39b46e5adddf73d02445fc690cfc84fcd8892a26bac07eaad8fc3bd637dc35054da5ab5a23f42b645e607a92cec8cf21c434182c1d7ab008dcd1a67137922270c7a6a361ef8e73f187de9d353312f5d544ae7efb56afa64c9203142bd51338adfaaf4973cbb17fbb21a36323aeb4a62c3f74c9ba99ec1a574edc3c1da9987c7e2de6ad5953b5ef341011e5778efefb42fc7e5d1f34bb8e3dfd7557b52fbe9855398462f78fe794be557b5e1425fe9f1275ef9069e74bfffc68eca90521098e96faac41ed0b121ae3d63f1413f223bc597777bc7046eeaa57474d07bd28155cee1e9700c8bdd54a3924eaab5f9999d0b6531b82b15a4ce5c08ac02e25b6642bc9589e671f473015fc236d20764e32a031c76f79dd98accfa370c0f780a886a881b7c5359ad08bee5b5a1e89299882d676a5adcb2653007501629729eae491253d72b2518f69966f769b2cf00dc6897202e892ccdcb7a3d7690caf911991fb148e15020a67a979b61b819010f3c4e262ae54f71b5b6f79e84b38697ad20483e4438b2b19d734b0d890108e89faf6aed2068fecf9a78341df551f4298eafafa2328503a93fbfb83608fe707719b503db8645fcc761a32b2025e4e736a2f36525fc93d214342168b7a45b05030e45195fab5aaa019a9b68ae209d8dc17f28d27668f0045f1363e7c21fb28a07db79dd5f42a7dcf2d800110b7198098cb164afdf552f3905b7594c6267ed7582189fa2059987a2bf25bc445c59b558be52e4818b26b44ca74a22324a9e2c737392ab5ad7ba07aba6f10b80678af8d625326a1dd40ccac64d4b70aceab48a32ea5ed3923926e9416a761614fa01c235faaf26cf79b8fdda7f73998b20c48c33b9fa74c6af2ee5a0ccb4546b87bfc911003c60e7046ff7099e6975f9176b3393ad88fbd997576a4eda0acd525da140dc39122c6a10518d1b64dd9b18cb8c6a50a35a9365ec7e213a38f417e55729ee193d491f1659014887bf3ba37988a06a78bd1959bfd337e09aebe96970e9260a7ac809feb900d70bca19ec3a1960753fedf77a54b73f2041f0332d04091728ea57e0a3704ca677c4b5069e88f594c2ff3360e792bf30b5bacf9c8767cc3ffaf1ed4a698aacb3c5c933f385ee0231e30ce07e29d815da2c095e647b801499f67707e773e74376915d65e5f6ce39972685b21a2263ae15853488652ccd77b6ac3bb2c40b3c0fde5836b519bc0dce1a14d5f87327c799d397cf32012733a9e50d7a019edfe178f9ab60d5dcf2c4face7e7c299a4af4666195a5ba3699d385d1b82862e3035e308d9e43850940ca563a57c7c21793a8b03627e20e0131d3fd0e806875eeb266d60567f21a7aac01e03bbaa70871b96889aaf10cb85299121466a9841555825d9a1b8bae1b6ac33a10ac820e1d7575844a38ab9fd25fb3378ffbaaeae7f7ce94fba6f3a4c7ecec83b2ab7c8efbcb6c851bd94622cba9138a65d8a47603a4cc1f15439336e403103b2673887f83dac47993d8e4c23607edaae9bc947d00c4486852699929507f29e6d72976dbbe23d3ab60a5827f542664ff73d416d59a0e0870e59a9f0b6b8de60408346d35f57338c5bf90a8ff354f36df615800c47be34873ff64d0cf7c6c060c673bc944b0a4c470961f0e0c6616b4699f425df9e9b0635d628add1f4e164c2cb20b67d87c35a3f2a3b12d50f5be14eb920e2ba3cd64d824da3700eaf6621c7b2e79a325b3754ac9af6e7dff34cc7f5dede1943cee0aebf10a75c46fdd5f3119b699badec5d46ff68afe2d2fa45236ec427382797d7e985ca0765bfe597e10c965b728affaaebb8cddaff3b95e26c9a19cf6b11011863891326598ed81083b47e6ce094fab1e4a329c46721a670cd929cee1b1412549e21dbc6969c3b5d8066cd4b6553ada98f62bec1e6addfe6d011dde79512a9bee2a9cc6eb09d3302f2d15ed1367267e1f752acd4242bd7f21d567ceeeb415422e6a1098dd5206b88505dc8a26d968c5dd02b1c77014ffa974ad4a96beb1aa621e02d333ec6a0c75362df43da4e085933b0f9974184e83efa9c9d74c1c65655ebfb07fa31aa49337a39e38c4a0c60a3e0771469b98d6997bcf38477330abab7e1e147f7a20cdcd938311f25dfeb6408f1d4b2224a8fa2ea36d7973db49abae4fb3a712baf503ef80e0ba6fe08f14f2ab95d132fcf31db7d9fb5a975928b23d3e52e6e24553a86ba229db046a18200224866d2e66425a9db914a44af08dae40a8bded1949282c8fdb342cef12c47a8a1fe92975f4aa87c723c0d71dddf7004871d72044a8b00e4f1e4ca9f28839ae5fc592c8a4a7363cf8e7134459581574514afaf3f75c829bb921753908c25806ade4ad9347d563877c34bbcc7cdb4ec94199285214865768f8dfb6546c1e02389e4499410402d2fa3e0bdf6cdbee80c87cda9247c6bcfcaddeec0d0786e8ea09aaee85107fd651be1f0797cda6ae284d7c4cf914d729bcf026d4c7d2cc08309888911df08d7835e2f7fa3cd6e953bb7b42513aca859cd3e0b1a489b92c336c8d5f76c09c9ef9e30f47c6f77670af0bb74739254db07b80aadb7303938a902999024414ed115cc296ccfcc0aa865d76d6921f4541843d87ad87de00dcdfb8b17fe33de9f316c71e0590d4a2e13ecd27345724c3dd6f1a0040e9bf799159dae7a65b614601c7a6e0268a4a87045c6f9ef4875fc8bf513b9eb9012ddb667ca7a03af1624c3f5cc5d1c44a5bba36ff32459540c67a39be9f84aa1c40fbb9efcfb4ecf30deb2289d2d07f56acd996a97785b8d99cf8527e708ddbb25526763c0b4fb423336d9c6208e38dda8e17d5cef11f1821ab39f90c049cdb8581ec4fecb77142ee6cba41c5c38b6cc3ee43c5cbc00ff5395c20620bd35208c91a1d59ddf4ce26bf7fa0e328b311fccb2fc1e1969ec2d5c064080ea94001c6a79aaaa2148c7d4e81e3c2aa946f8cf9d9bbe617b650963495961cdf228bdaf8b8c6ad1e2d81a5de018d03ec2dbaeb834066b727d5bcc9223f3b6be8acac49489758e605366c449b63bdf7f258a8ea0ac2886ac56050df9ff6f3ee967097f14336f3542dd0d45a4301800a3e7bf1a10441a83ecb5784911c0fb42ea184c1412cdf612a18598df8e1a361b1664931468563630a3f611a6f5380c42962298644f309b65580530fae8ecde0d434780d14fac986f538539e579a1472748a4cf4d8f56e2f17a80db2f635860ab38f26d8755b54c7e5988a77d31367bd7ec21d9af0d0dd144bc5ea1befed693355bfbd47eda69893b1c5c7872c8c27e43b23d35e324f5874ff5a1b4953f3b9dc098d080663c12ec8d7b49c05228f9b1b8264611d3dfd367f33442bdc89ae633f4bd4e138cc617c56b260fb5042df98b371cbaba37d26835dddb2dcc654b0eaf13544ce85a886dd016d6baf154346369d9144d8de93ef80fe260c708f739203ef1f9aca5ef6dc44907f896f8e187ae0c4da928028a61580602891cc59221b615881f8343786028b182dfbabdffe89eb0ab9618a35918c57d4e3752d08a50fa77ce4c0f7d267761dbd2c38fcf22061ff229eb6d63c41227c95dcf2485bec1a26b393dbc2c7f43b96ff13ea91c429bc9ac87724f7543baf9736155e4121b5708c904294282d7558b1b33f56b4316fc895c04cde916492f9b16afcb68ff494a8ba32f58085b883387c725686078599d4ffa20565718f3808d27043a3916a8bdc22b3ab99f4a47cf30d631194ed97329717e74fb6f0e4fcf795180c4bf61f90f2fc51b3c1791e771418abfd856030fea1ec304529782560d3a46b31d9f85ef3b2890ee565688beb7e9a752aa23a4fae1d4ac26b35e6ed99046788b897b0548d407dd901e844976a7e11f0847cd168e8be6d77b0b1736f7ef7129abccac0b6da9682be71438f6104189edde86ecc2b02428c165ac812e9b7bcbba4bbd86f7b4a36ebabb13de91ba13382cf997db59d9343454e7ac2b55bd43de9b4e4a09ce51812986aa2cff37718ff63e9d9756d7d8130a56f7a7566b1b74df45f5fce1d8113785ccf66d771ef1da68313cc880682df84a10b8b2295ecf9535a8cdaf05718cb1781e9a7680df2a5f2f7ce7c34ea3c98e040144e89468186b915540a4d6cf4dffa06dbe2652fac65af35a58b0dd331ad91af231b7f84150c594c8fe8e243b938564df2758795446574a59b4d135664f7c6389413f9abfeddc521eb8453279b597748d8abff30cbc7018a873c5da62bc00d1264b1fab92ec3ea8ede92762799c2c3f2f9320a0d0b5f29fdaf0e8e98896dd7bc55d649584e9c08687b2fd6aaaeac0a1d7ce064e0088fd94188b86f02dc95d1995a653a36f7eb6f7dbafefe3cefa8158dd1308ea488e4f0f086625d08b06c6c707ed5e055a7287809c6707713776c87af404ede3e1f28566fd8c63233b3d3671b674684a19043d4172c4cdf500e19e580fa02d9bd711e164d670b0ca28ea51ae5224f338458f589735d01acd32507e025ec67891db27289b529d40f7e669e1c594ced4f02f98c087f8e29ec173fac56b3745a87914134a4a644cd10b8cab7c5e46bb59d43a24cd04a331530bb5c85c84143ee81d5c74496f89270e6bf47d36b14d2520e9585907d4090cfada8abacf3a81394b5718c7cc824fc240f91376b3f1af394d07f844f49d44f916389c3af6a219094455e5d502a8d070864cff878299e2b09f7cdc6554ec366c8c3458f018eba19f2dc8f2d1328f1bb5940a4c8410e52eb5d1a2be22eb7a84e43826b02647935bbb213628d0d70eac0d05a86b5a7a65eedcbae3569a7a234ec54d83a8136b9e9fee029bee4bac287655359e7d3878579a4f23ed67d613fe97d6fe1690844221c75a7ff66ecc6a539bc75e9a5ff79fc5eab2e65e9f9ced84b132efaaaaed9d67ffe66061d5708535b5b7e27a1da4dc250d59db78e1d87084150bc507e7c3bfe1e07a098280fd9418e5d26c6cfa5d5b791b87cad8619902b704f6374f18c3d61f95186c6012bc52484f9c1c525cdca1d1538271ea614e2d96e2e410c727c8fcb09f26054a60c9ad36c8c155675ee34d2fded49ff0dafdb2d21dee88cdb59c8aab86ce61d39aca5334efce7bcbf980d265554b328caf0e001a2477ddf83df8f4f5a51b9e7c822c15e105875ad8933890d954e09fa3725ba708f8da725c106e94026e2796e972b27948e3d1d1c2967cc6bcaf52ff8978e44f856526c1db9c4abc64bab0a0664268cfb44eb519a41afd36f7b63f414ebef6162addaa37468535f6c1f982eb6d9b03001317ad457169d9ce43e65b8b965c537f950cee388ca88f42f8ad687d673024f8587e153064cc7d7af49107936b8f3a6a2fba35253ecc37597b9ab0303c8f5813eda5a6aac16beb6a075f3d7e797819673e3118edcef56d5a940d76b47808aa9ea9aa0c299420f7f411ad0df03547cfda072242477ea71ced3bc1cee75e7078c279fd9b457a711f0c1b381497425c32afbf8402cc5e0a12427d5d4aea4b2b720c7bed602d17dc8818dc396ca881683183d5d6827dd25c591c172d4e43f3e92a15d95a80f9211dd2d46c01c3545a271a913323ae5857e9ebb29f1520f2d723d0bf2db7492f3dca574a74b67dfb6e64cfc8bf31a9796df963df8bd1f6457fd2a1b43665504a57a373d504502ba00f2eb5f9f3fc8602b777a04abdd44876758f524c725395707a5b601a7cb0890e3a708d3f8a2306d7f19f2760a3161ce8af4533cade56945a353b14b37cdef397a39e24d8e2de6e101275c1fe84bc4de4e27ef465298a4edbb242f3cdf14ab2514d4032a0789ebf7164cdb76fc4537d6648988610b898181953c103f10a9204e44e2940647d0f0bf2686e556353b7f3638fda38e76516318dce58f3da51a9b0aa68f8789238e34029250d086d994a6e9f5f1b0e94444fc4f6b1231b38bf534c62778c8b731bcfd74de003a6758711f17f7aae2339f0848a314a2568dbc2065b77d8ff329c2160406448c1a8e389f88bde05af3c89fd35efb8b8267d3ee08ecaf6d15866c6908e19a29cdab3180ad2f758e7fc0486ace71b614321067d07b9fe8afe858a69e0a0d13964dd6e303e1cb1e71ccd5c5643f4df9d6496d9bcedd64721ca28247241ce456de8cd2073eb9256236154dfff2dc91baadc3131f29e07c5f5612a02ed28d3f96c25324536c19270f18d555c327f6dd983c6e931520b1bbdb15e6e54c4dcf2fa6b716d274ca8fb227537b26ddecea7f24a4d0e3d0c594be4393bf8b4e143ebe3ffd697085b90539685a1c4d9a4ad8ff7c49ef5911291a05cd708318f6ca12e74e32917383d4ec1bb8ee56543d6ad96596c4cd0c6c8c28274c731434829e5b9eefb38b774d52bf6feece5897da821266505ee9181d36bbe44560cd0441cb286d4215e130484659b8e7b83beddeab777fca626c1520b3c8d48b555af3ccfb2b3ece7cef2ecd381960139c76c880976eb4dcc4cdcbbbae04fcad6cd0bb3c52f1f9908a4096a29d7be552894120a7e53aea02ee24099010eb93ed2984493a9f891ba31053aa02a29de106a69a087f3b61a129ae687254ed82ecdd388a2871d0e5abe81d9bd017c0dc3ec8902416ac6bb7dae6cc54860325964d5be395190ba16862643a1eb8d75242109aa45f0618b125cd3769e8d8a132d820b6c4a931504eda669236aabf565e6d3426ded9fe34a765953a1cde6b6f5c70a6860461d4844f89ba0450843a6e8bb0b6caff5cc93e0dd8b5e8be0879309a35fb0bb905541864c8191e37b547188af24cf3cb3f0bc8fb5e2cc6352b1fea963cd06db3386c845e14332de5bfc64bed991880391934be2e60253e4fe74ef82e0fca2e509d971e9dedfa4da1781c82e093924e9142dccaf40e92bc53c27730a3f46fba9740765426220d20ee26883fb97ffadb230f837a813818f3507bd4ac821e6a1e646a9f1b89ffb84784e0a0433da050d169016486d4191526497a80c9a16ae546ffd26be23cf98c66d65204d030669331bdf4da1c2c7d451d8b5a062dde492255f66c1685b12e18b5386aa1a82ca43c11834f4c591cd6fa1ca22483cde2bbbdcd3f423552094a14a7a389a84be5c6b6c425ce742ddbb520b86a18e331ae421faefe9bc0de9b618282ccfb5217e28c7bdc1ba5db9e1f35b273b1f48f35545c921acd5b0c1d30a1044aa28e5269eeea07800979f476565c1d1373c8048d29e0e8458f27a65262d29afda9f8e6a85cd4f96a66de4a059cd2b7c94863daaccef4726fd53a6ed65a4cff5aa1150982a61b43e247e330b7631b536ed1a145c47d940eec78909cf0a4ee10b51533f01556204efafb1969e11cd96ab1d8f6c36762b0ec61fab173b665a185ab56458ac76fa4638f523717a7e6c7e0f8fe8b442ad5efcb827b7c95cf5b521bd8af8be34d80038ee49802cfbca21a0f8ff13d66a8460da321e3da4ed9d69ca6ed34f4003c12101ed278060060261367a9a45374b17543c36ce0ff233115ff223c7950f17f3670e2136b3e22fc831b984e0e299ab4deec77564cde166ff77634799435affda447131f9e9586e72c1d91b1a737220acd265c42f593c0960f7ae218bd6818422ab647fbdff3fdbf8db2c77492b17f2bd8ab1844ee63e6d920ba8b513c8e3ec3edac0c00a3c0f53040bdeaafc3f62943f549663349cd3cc08c6cab5b71e920056578e29355d15de201680cb40d4ed731da9573aa17a722d6df4882aee4fd0c5e482d2286032682dbc9bc566d82daff0c1375d40908f5350e45958e5ffc0e22d1275dadb834c6154c775d47e70c7b7ea24d7b4de34df68b814c16c35396aa14573f0c1510915b5cfeda4c0b99a7a488bc96722453be0be4b3e2781ac77dc20e0f448c0091658b9b48eb5a658350c0abe2e8a0c81fa7964a5f37db36e6d13e81dfe2df710725f5b2c32198a619128d7c6bb1e6e01499b5b98049cd6d48a9d8d919ca7534d9ac6c350cd41b87066633921505e6f53aa28c0755659bd00aa5643b1339ad9786f391138db4910782cc4e1b348cd8fc7572a8050d350e85f525fac4fa5f06fdd0d6670cde60574120923dfc4e4bb3be16fa7f9f3bb2b5bc1fede97ea7ac52d18121141d93e179acf333346d9b46b033602d8c0ae7bcb4bb7a821c2957787d27f862d046b44a43075b1ec99b7b4b64023099ab3dfabbca3d70e34c2ae0ba1d84cb45f9d3b83889f4a37e86d464e8c0eeb456c84e4cb07035cb1bf19287888fc422242232dee83e8d9d330cefbff167de6d6673031fbbeb813316c2a68360412eedecf27e5d3a3d1fd5eaa74048f2198d5f600b1ef7756458a2a73c94c85a4ea5ca83e53ea37f2a63439855944dfeab716e9fec09585e26f758729db54403a11e882a1204e65719685c4cc15c3fb80d5c50d0519f5d7c288a22293a9f66cb9df1734995c0415940b495dee050ec141ac9cd546844d10a6002c1ac0ad63e2b8dfaca5a4a2ad993e66f445720874f54271429e762cfb05260c2409d8c01f0dfc9df8789006f07874b385ca330ef6cd8e2f5d7c96ed4e0ad73ed2f9ad3a05171d25fdfc057eb494aba22d3b433af7663c2c95279e1eb90d67faf9c68796aa18cb05af5977c4e04b2dff927931cdcd271bbf432f8b80d35aff8bc6a520b9dde90a401b21a026c9aa84c00b1a1f5d7871e896e63c7b8183fa963a205a91de83a289ce96bd8604e22d2e0d8286ba5cfe9fc6b92ffb550925f1c4944f85342284455b43a45d6dcfd317da49cf0ee537bb0705ce6fac82b2c78c4ed00ec03458fee7d923fdbba666e83c5258138ed25570e667e0d8696789659805ac2b7dcd4bcc77e5f0846d4956841f1051415021998b15d91b7840406a5d7659baca05f1967d0b4c407e83f671760cfe8dcbdfcb3526c0043eef236d860a834a054a5cd7aca354d09fa67a21dfd0097c22f46d7e762b66c497067a88827ae351e35ef82ef6146f1809c81cbc8ecfcd00ae0cb58b2f214ba29b8969fae7207b6b7c933356a249f3d4a3bf57bc88291aed5f8426268682e37d6aee4b376a173a9fe18b652287797d2fb045e09a2695634056ec9e5f85bc5bcb36adf3cef88efb6955f8a533fb26242cff78a128b155530a1de478e3f707e8a27bd82069644fd6da64cdf9a7321b5f8178cf8ad4c5f7902818199dbbf771230ecf9d6855a60bbba3a541ef7a288369c2e1c5f64e6c5e5d9c5b1a04ffcccf7581fe3ba42ff6620011f79ecfdf90e7dfbda46c49052b3bc02d586ecad0825959eedde88b2c1a3317e4e4860dbc278a29b5b4742aaf8e483c9f5c796870833dfa96e906b67febc3a2fb4fa017b9fcfb7fea38ea1c3d672501fc79a45d22acf7705fb9d295ff48e0ffa7a7794347e25f7af5d7276c138571349803407d5a6a4e76231864edf297ff7824d681930f8b89967a4bd1ce8646807f7080085f43d7ef07942ddd5fa83ed045f6cc7933fa68c8e5cad3516c010d5404b504954c1e896e690efff137f0931305817f2270c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
