<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26361d7d36fdcabd3dbc8c4add97c7589f1441e9775608e6f960d2e4d4004a5c5d80b62d0727e13942107adc21645d73ed928ca30a774c02994aec07073c8bfeaa339d0b66e6ad4b8394a559478a1186f56d49e413db709aaec1e055c9d9e006505194a26f882d8f9ae5b9c5250355ed8bd73701d6993bf0c5e15d2bb1d9d83be944c39c064a186cba27ed634e3d234c539c03cc6b41914f1807a1c1f1c3e7ae39a1d710a3d41f525ff7b077e2603cbbbd3db7b3f4d9da66fc776dddb168b96de29a29c718b43635836343ab8c2a0936ee8cbddda044851907b157a0600b18cd36616bdb9d7c37856b2c683a82d2315edeb91328f4e4fa133a555ede87ce6b3ed628c16bfe116863946d05ceef06452fcd045574d01daab2dca27e7f209f702db4dc5315af2da26bd655555218aa10dacf3930ed86b2d8007e63be2434a234248653de4221c1c5ad8fb59d8ee379f0a1650bf4cc71e56092ed4899196d12d3b877f3d24f98e068c58f0f6c9ac7c2f21d4e73fbfa847f3237a45c13cc0d67dc0ed8281c10af94c02f34ec4a083bfae6ba7c36fc931bf21f564c39f90d614fb6e7a6fc4179940207a41917ac0616a76c90c6142f72776dc4a3147b8cee324977fbe836746cc3d1344dd5a175eaadc53d3f7d24a5ba9b8920a350059a4f385c18c0af373777062193dc7d4e91fb41f022690ad5392165c329d5cb85cc05b467dfbd17290fe848eafcab5d1c49d5a8a0e60b0e395d8cb9b886f1f703b628233d1577410513ee32aaee8a40d99982951bb8d373c51a94c2aea109e1983ec5ac66b6a25d22d95d8cc96131abe0838168fd521fc567f6522a15b012e58dd45619f137d9a6a07534609a13492aa2558fb6b2407349bc850414b5c54daa7858aab6e65542156053d612d5dce57490be978ead290996a96cd51ffa234e3c1d7ce9118d734962d921fc14b0b430f2d8d10a4cec5ae2c24312c1862def044146d0c75ad7c09fa1da2027f285d3d255e1d0a626ba7907b41a613cd0e9bb481a3662d84260cd7fa6a795b99cb223e71b6c2a8b7664e0d86719b37a4d32091aa8cf05683976b5c020c832e644be155cc70d141a268e703a6e39d827495ca5154a17fc2cc8db0c265afbf312f6f4bd7552f59cac84f52bf0a9e7ecd4d3d6f2ef2c09b25bcb93ebf7effdf778868e8c04ab1aa00af6e36594029f9856b175b37cd4d94e9855d0aed433704cc24ca4d47aa1629011fa86d2dab1d4f21ef5005abed2407f54e1e5da26012693007cdc4188d06c7f389c7076b0f003af048c4a01d8541cd891a53752925c619b6eeaa076ceee0d57e2fddfef73501515f86b46fa9e00af417f1c54655e89bfb240cc9ebb6c54221c8333839e743f4f6bbbcb237d55b8ad5e2ca6276ee2495b0430781e19bd2e5bc06ace864d987d24c5924779d9ed14b0a2defa82e11cc20e62ea121c8be0446deda973698929eb0505526ffb1925692f113317de050c9241bbf77bb113315fcc121fe7481a835f9463e11d1e7152e069703d9fd140f867f20601a9fac01ad3a87200109f72f9fc875ff277abb7651bf4088399f70ac32b28d473add28848bb9f9614825fefb86f4b6168a3cbec0bb374d86a17f2af407a658f069bccf4de90597e46cafb3ce1886d196b03e6d36390d0b920e4a5e1b0301713cf93ce66d2a2781ccbdb57d7b2ad8cb83896041647603b2d1e8a5f47a417891d7192bc18bc2af059bb7a289ae84bb4a86b61c9c2f8058e4bbf634996f34154512dd0bf5ae7fe785fc0f5fc86c714c356ab40d8ffdad333248c162a9d1118b0fac57daa5595f989f502459d2a1649dd76152046f7b9aff546dc11c8093b62a332342cf2fbddc583e6894b730db57668cfb3e33a86de5d2d9ca3e4d42a8d414d1f598aa70e30b328745ed9cf118e79d049c45732fd46c920a58003deecfc8c32d46956ea7e5005ff29421d697f7fccb4662caa4c8bace7bdf3b207b313becfac3e54a5c07aa68bc4b25843877a9fb4270d04ca3da2edc4c8f3c8b8962343ea27fa3957018cf36e10fc4523deca19cc5173efeeb22891d0b7d66d877ea03425d5f1976439d37a6cf5178da5e01d376d66d5e5b52098fde710479fca948bdf7a58cdd92c1c6e7f5b2aa52980027c5a492cdb23fff608cc14b69c0073c65be4a2e4d12410b1ed7f393c1b4bbfc02236c6e7baf99a2c6bd15095c482c8a7eb7fe979701bc53a1a2eb9959f9499b71f28fa65af2480f167fc4d34932d5d4c67ca33ff745161467d77c8ed7b97837bed36cab6207115fa896b43cfd83ed57e9853b7606edc70b4fd3b420e202d9d6a200100e67c44b5cf814af4414a48759f158fe9126fce5ad13162c117dca59e1c757c57e874c02990cd6ba3d4a0f2e01da0eca20a27fd93a7c084a01d34048145ca8863d300fa6af08db5366188bb6aa9b08176b0f31df2ec448b8a0592f9f6bfc35bf1339d8f86dc23e54fc4874874a840ea8be036317c45ce7502804b33c0d6bc290426937ffa90085cca53602fb53de868ce7ce9db71ba084647092d1712c093ad48b5db027d6454a9a99422f16da8908ef1342d7df315b5e9f0eeb341d57fe3a8e1473083cfc0c4f5c904749315745a21d1507ce9bb5329c1ab1ddf647e0752ea9d1bd37c73502b60d5ac0dbf2eb99278f629e3b197b5052bd990a812f91434bf120da4603d06ccba1068586b65c637bd996a6d214910633b2600a8b0dd3ab3714410279e8c451ad02c2231a8c7ea66e956cb764c4d441897f1af088bb56f8d97b5e1cab8aa3220679d93da0bc837c21ec796feeb1cdc37c1f7bb013cf6ece00b8a526720dea9ef27402865cce1fe7c1c5c208358c0c3533138de4a82f94b1b8d6a57b9f4e18e479ae521a45d94bdfd1038a29001af526238be8165bdc9bbe6bbc9b6fe89dd4c15721c04dcc946edc7fc874953a502bf22a8f9ff540565ce18b75d96d62653508f3a075458eff8dff60d0c345fc23a493474d06c1f247e38a691313da0e3ab0f608f03dedc718891188d4cd807b9de005ce8b114f6249cb6a7d92023bae45440c922b611c07a788699c70461a0b5bfc09ae428a4e6ee112438e4f9f2dfabd0130ca1e6889fd3fb73061771ed674ebba6539e13ac279f11791aaf8b18d8bab3799b9b68be554748a0074b9562c50be088912f8bb9b98a5e1743207ba10ee15e0376a1fbbb4b7b161132743ad43e0310a47db05e97b1179aa929718ff1347e755a21e210cd21aad3e62a8b48181e489f280ba7c3225063c02f2a30739ec5347f4bd0aeddc70a48b36fca811ae5a38e29d60fa9dbd38b27625f91959b1ab2d106901682c6b12cd8c087dc23bc58aa29d4024ff8f9b46cf48a40a604e23302f71f8bf7a270a39b3819378dd10b03eef57a396844dfc154c21734b3e7a05bfb78aa3305fc896fd9ae2f24ee8c4bdf1ad01c6fd0f95fc9b7af38d47e49471f7cf85931dfad6f840fc81f6a92063ef5d79647333362711677d1ee2bbb44c8085c686dd7a9bc9531de581b90dbeb51664648caf3333687758ea08b1ff76f76a1d1b1abdfd0d5753624f869a57728856c01b689fd090dc22f7eaa1410c68dad7c3958cffe632b362671567785ae19873f565df973dfca41ba48e75239502b2d79ebfd2810829aba972d09dcad0955b8b2df4331a50f0ba1887db790ab70c20705ed6157b3fdf0ea220c1c0dceee845419540c9a0fbd94542b244fc3516fe63d8c7e600bb67822515face358258304c5553020dfbf563ca87d5ed2714631b68d9552a022222f42c254f325f2753f13303b0d5a55e13175b7fdb50dd35c51c49a7a7223df08a48a8ab7ebd0cf8b865795d171cf75a6aa616e8f3612d0e0da101bb5974ec39af459842a93e804e26dbce8a2fd8e9af8d00604ae60883bb3d66d13a4f4be84bd2f9fafe37b1deb9109ba4344787a0dce8820fa8be39b4b0fe0d98e92ec6cb1cf0fd9a61c4468cf8271c8bb21f2fbc951adcb234cef81d38b0089deac19b68c8854d4bd1c745ecf59f9f3064861bd28804d10932ed729b5196a8c2373af35b48e3126776bb356ceab2032e7664d2d47cb52ddc3d9c95f88368359ca4ac93562dbb11e6f859dca451e909fb4021a77dc89de6410f5df36db9a132e370ca7e9987ad509d1274e6b3edb0124760b32db79984b0543670a4197a080a088aa0e74dd847346658809218d1585404e783b2f738ad632e0bdfd1b767a7d8991d316d8e1a9cd7bb2f98863811127b900fb7c6d5afbc8e9815e3cf64d1c36fb45ac9db352eb641e9d18dc1f4444a2ebbf8d87249b59741923047e9d1ece85188eb2bf33219e600d6ac3d4ae317c3cd14eb5cc9ab5cb5b63ca426320a45300fee9fe94979a227e194bc74cd17eefa8d23ea2e43beccdcd3bfcd8869bdd52803d79a331b94d6bcedc7087523da1d40dd1c2f69eaeea3bc98d73b85d56692407e0f14f6c0279924bc2df75161e04035342966e9b99677a4ae62f4a0e86d7e2b2156b1245c0517ca3966c2feacbe420571691d1be6093955579494468f70871f3798fe48594061a82454d44c5c48da8b8e11023cd3c6b8fdbcfa28bd6218218d2a51a9b513008b59cec882f9bea2ed16cce05f80852e0e9779e8f36ac97c77dfa3cf6f64f9ce776646b54323f3a7bc181b24a2216cbf43d2a069a68cd122dcd974c36f102d22b88a8a62b5eee8ac23badc7f9f555aaff77f05d5d8040dad691387c0bea7044793ed32aa19311aa42634ac948916674f24edd3e4565d47ba66795c9f1cc2a7224bb8146aaf34083fb083db3d2e1e72eb779acebd185788b92ec1814b0cfe996c86f97fcfeeefdbca603daeba51bb8ace4b4451c178c32378f72273b3babff46bee21cca1b9c6f7c38a1d5e2a97d62aae748f6aa0bcc6b38f22266f8365887b076ea6fee01ccd502516f660a7784f6ed94f3cf3831779369357bff0ef07a8782cb918158e49e9d174f70519dc352762bf02325c91b160e55848ab318ab3b29a4ce29d14be104704eac8dd1beb8176fdfb35e283d02ad224f527a471f4a3244b21f7514018ce4fab71598019e9704ac83aef0312e06c7a25810f782a661b448a1f5d8c71e7342fd6a09541f0cee6abb1e7a0c8ea87543e7f822dc2d09f26697f17aae65ff1d1e335a1c904005eef1b84292f53702739a4e806435aca60ce556183c580218533e6f96dbef88e1a5c89a0e6d9ee248a697f8a9cfb8f28d9fe525485d18998b8dcf14a1987a8f77ca8f0a09d2ddf0d02302d913f2ab6d2ccefd534eb62405474074eac449cec02251d6d14ad0be4c83fc59338d2414cf1bba82f4fc3abcea9f6427184d69c2708605eafbb2275b8010fd2b383a69ea179ea5fe6711e08b3d17a7a39d8515ea5e0a7ee576fa7c57b4e6be0cd9bbff92b094772351ec3dec8c46e906d5e6212dd58dbb1d369b5a6d1c454e7aac10fb3d2cff4312f3841480be8ca83ee50143f704e03ec814a351aecf98d7092a20ce398aecfb3ad4a07956acb04f55eaaaa3ffa65fc7fb3d39e73d332f7ee27f1c79dbeb2f21af76672f62d8710d15def6396aac4d13e51ea0603874927caf903209e18560cec6c6d972e0f794d6d8b3ec465ef369bcfd215938b07bcee21d590a50c80c73a79276f84f9398e39e5a05e76425faa9a0b708f24957d28dfadbea423fb55acac77a3cd889dab5f7cfd4ce4f9b77ccfb48348f69bf07c2687e1aaffcc6ddc46cda6c355a5a0a0f7ac8608bbcd94ea3466f277baacae0d81b4ba6d075c53629a1bbc971e861c67a7320d85f8006aa20e068c5f9f2fbe363502beffbdf95eba4bab3e7266ce1c553d77a735c8289f69ab6fd70f799d5a98cee507dc303ff5f738e20e52fd27241c84f8edd0e17b669ac1b520074776765636e709d7f81f860c2d0816665384829e2162c6577fa2361a026a29f3d673929051b0111d5f0474a3ac4b6c8e94ad9e7520b917851ef3646ae4553b1d8fe51394274ddfffc1c97a15f8b5433f025680312405ad51066f94b9a38e49855d29cffed519ea4d4c8b3f7f4ace0a818cbb04411b20e9afd41a0493c6f83acdefbfeda9a6de897f953787daf550f813b1c2aae702deeb511fd6e1e1b248cce3cc268281d205450302072e6c8df59e4305f30ca38a8ac382236351f94f1be3df26d4967f1b5eb475bc325225466f4704e92c006615a9b3140d8c6bd44da6ff42a181e69dbc709f310f7e632a5f2c820ce94c7f6fc554699aad5a457661828be61d188545e52db28b3ac41d2ff299636d66436193971d09f14d194f637f5cfcea06ac54e278e0e5e192af80e55ff69e1efd0fd42eda52e1a3d3f2a8e4151488b7af7a2fd0cadeb552b4d11805b32e7251bdab4ea5342a2be20fec04f7e2fcdb9ba2e1b46ae1cb2881b844ac6d19a0818f1db7fb72370c6315455d266fb4371c9f5de548e6c905b4e486153e6277483b930326f93412af77e51724c7392acb5825dae75feec6ecc7126556e027454bac01e01733044738f5c9a01b655ab3ffd51ae73dd10143f9b74665affb8780dcc0d88b48dee850d22bdb9098c05f7087de111149ab245517234d709c07557677798d54cee180cfe06969780df6a9a484fd7089211196660d13cf9ed90e73a803256a60cd732403f4988443a27dee62318fe1c8636b4b8299a0ea3cf0da9575e91fd205bab4e49fe8f058d91ead84e3f7c349784b8dfcdb34bda4a5437c3299d6383e04d84951d35975ca322d540787a6ca41928ece4e9bb418b978858ff298fb3c65e5a95dfee4f6fa7cdc13fa9006b351916cd62408228d0ccc6f87187f16ebc1d3eef6af8e35d3c8cef5cddae649b8326439e8054cb8abe1475468d68854a1981bc9738c89ea704c0ba22402b1172f751d7d27bb223034198c786b697021765e6cf0ebce45049847177948f73c652b62ac1168ca8e1038d49af33cfab2294d7de7ba55462cb0774c56e1d3820036acff9b570c8b06a94db6686f6a8534ed321ff7f86bc5f7385d27dd1ac7b0cf47f240aae2dd2f197aaa7c801cd2f1e338047bae403e76a557142eb6ec567af7e24ac3e5f2a6ae07ec771b1f689fd2bf018e0e2f6b91f37b66c03a4534966bb42cdbe189dfb2b5233315d890e6720c21eb3963ba5df5c3eca3856f607e357390d2a2f7f5b82063932a9ab88f6f5cc9fed32a02a027dc69ecdce34c0d9c31a9f754a2cb1e64dabbea18bd703eff0f3e9c503eb6ecd389cd86531596611cae1625171b88a9b3ed7a0d8752c32db061c047b7fb67e90b68979a5f006b54d2f43671359ffd934bf61402f7c8d2242111947e53600d3ce1325f5f4974658979deec67eadd3f70d9415601cbb744d389bbae913d7047e2739cb25315619f5bcbce8b81ebbad06f4ffd47a521a13bfacd4246136b2c9731b93920c61cf7adb6f6720c3e9faeb3b937786b0a104e5dbf95fcbc76ffc70ee9954d03674057640fdda0ac952ac3a2bc3764c658ca7e64173f2967e1a90c754a8af70a9425583297425dbc935850380b69e35598861a72a3cffb07524d063d14d304add6e909e45ce79d68b7650f98bf66e9517d5c500fbb8682e2c4d2819816be8001e727fed3403e150d29b6269f2b165f0b7b2e7d580525b7187b163dc22331b45a5beca0838dc44c17894f4f8d8370a888a41e621ddfa14b72cd6846ddea13a1ef0f45d690304799bbe51cddfa0ae1951677f4f7c9b477c8d3275a23f909f04ae472970b2057a72c779ec41fa4eeed7a958769e12cb3f89a57d0bdf31adbe3d194bc362e64a38afb5ea3d520371cd324870093a04c89977572525af65a9b13b8adb7ffe90c99bd34c9f67197fbf3acf98a64e927350641eb96bdd852a789b6d02e634c75989ee9b8fd4f5aa193ca1c30d8adeaaf5deb383ac70965afa66d29e645f3edca48b4ca5aaf3dd369059c858f52a3f68551d469a9eda8b8d58b60e4142612938124043d096edbc9d00dc1adb27821b1bc1afc9f58a49cc2567e5fa87f67e994340f197e3490880635db40babe7893a5b0edf7bb928c357f11cedfdf4b86b0e1cbf72d26b443c07b3c13649405c2504652e5c58d9e4622466bab8d7dbcfcadd28a547e834083ddc1c846b1a33f04efa2e0208b1ea0f4afcd7915cc3c416d6104824a714862c5730cab534def9b67b4520e3060959773d62abf46e18a50b95dd1b69cb93726b197e544a3bab4b8063bc5e2820557bf0efb0770e698c59540bbae13c37e1ab7a37b76c332f91fa72dfdc55bf8609abc69b3b868d2e780bfed1ad22cc07c73616daf764b93f2c2d89596f96938dce5949e85810959a64b3333ee2185b6eb7f5e8dbd9cd791bf5e8a10a5d46a5254b0acdc6db0258b2d4efe4fa46201221eb749b970159952fe45b5e83f54d5dca53aaf06fed18ee2ced84ebe1958ac2838f94a3a87bac8b58a9b9c346948d57898f4d89adbaa1a89a10e6e92ee07e6f021bbe5a5f36141499ad138094cae113db30047b082d285ad128643a98c7215eee1f9ec66dcdaa82b16937d8fb14f20a58ee8103f908f693d7707fdee04088aa3d5dc9ca054ba37f1abb570c45f8a60558f16a48754f55f0ca5640e4c60d9c2aa60ead634c0bbbd243cfd62e0f2339533b704b154daf5e46e84d255650264b57d886a6e1a8360c4653f6421caa1b46828f580f0071d8cb38dcd38aac592c4147bb6d67057525b99771fde2f2f4905e261b999e69eff8e1e3ec4a9471bb0f783674fc24cd0d62ddabd9e69bd9ebc5dd7ecca852610efecb4bf5bb58667386b57c825cff875cbef414236998f388abca5040318eda04237e90129a97097d84bffb4020e0f9f8e636ab43425010a41bb657f5f7a5c7c94fbadda0ff9a0d2adf2fe69289e3b0157285c0aa797e179148c4599d937574932ea0f47263cc2f2e48c98551989e45ce152caaa2a1af2c7be4c4089d8816515cd1df913c96a1f4957e3e35bb82f6605e09dd4948ce97f4a1fd067b232ea7e312277d1f78d9439ce9d958427b51ff34ae9f5fcbd77383da755a1d4ec86a99baca0bd93e3fa69b839c9bcf29b6729ba85d73e7da794c25d6505e9f8e887f3296839b4fe97a2582ab2b269ef362af94426e645c327f9ee6f0b5f217e3928a9c00651109cf38b311444c21cacad7a070ab053dfac51510602c942abd9c9434ca9f5ecb0011b1fc9a5ead021b4aa37c5825004d9926d05688b98ad8be9b7c1febce13b502746c65ab5d021765fcb3e7d3e593a2e63b4b2f606cda4217decab01b156993937e6deea1e8d5e260396cab6f23489aa9d9ce611f2e937cf55410d1bc971aed22715e8b9b17a9409467454a073a7ffa65e0668320c968e082924daa84486659a4750deae8eb694d88b5b18b3c344cde2501b84b84057de785f32fc8e8ba12ca64dc69d5244b183689556e5d34525cdd313f43baaec771ae7b2f79883a72275a2ee68eaa26eeab30bd8e618334e26894c9bdbbddc4ddb5ad3e5acfbc6179edcb2b5da2b1c29e666c70a604ebedb0fd5d31e97d3c4e7f032fbad8da7be982820aa88cd9c2b435714fa963917b55ddcd72c92355df67cfc16f9035fa8c80d1d00f10019d4e553d6befe23228c85121016fcea43161392ac837bb353ae216e46a9975d625d54c8150b987f2a793ed2d9e09ab323d34e5b45c4ebf1c36079c13a2b98ae184b1de0b2ae552cfb3e30fe7d41150fd41eef993d4662ada7b51a8dd0e1fb2d0e89a0002ebfed4e891bf803ee84a2051bbfb2adeeb20b6df311433c9b38685c1ebe7bd064be4f7ab6a770d452e05ea3294015a6d185ded8359a56593ddccf49dd55a691d8c0ae7af125aed53301988b11158e8b8a7beb79f15eb6beb97f9562d222e991b44c98118dd5739eed0ce0758d65d366d286f04eadf30b3bd66a71fd791a88860eeea2d7bcffcc63e35edecd4e50ccdd4506bdefa596807ff185ce30db013d148c58d55609587df550b1e9b0507f5e94b2c1adbb6d6c0094a90904fbee3e21ac2744c4e30a8216e337414e7d67b6a4d8e7a979775803065bea1f113eca4c24a73e7c376926dcebe424de7c4660e01772bbbe014455691a1db1fecb5ad4b6207a7f13030554ef745d4363184830f60aeafb94724a9efd6a92761513276c32d5ed2affd7fd3970f34cf0a4904","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
