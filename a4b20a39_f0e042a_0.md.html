<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06cff492ef016b4a2c9b987d3633ef90f5f73d15021f4333f1f76be7d59b061bbfd40cc11958c5d28373a04f87d101e7042814de5f34dead8a49b793618830a9ddf93b8d670cea24ccb9f873b3287f2927f296b6db2c3e5c92072812ed1ffae7bbfe3cedb3bdeb58d65326630e55406a3a8b6d2c43afc979a3270429e15ba20ef11e4a238b8374a633482194e6002ca28d86e78bfe618b6f34d001480e2e6c2f703ed940abeb73a21182699256b740d909926880c4d3f0a0e7485c8549390d57405c0ae54f0733274e1d5c35aeb4c1c5ff3fe4eb9220197b85b73a4b3b060168dbc80d3ef869ff206c94873f8a929d93612f47e897e1fd6fc6c057ee68a65b7d3b2af367149c66126e6e04081b78d8990ce769f7c2b97f15bd5c850326c903ded995c26abed59ff20edb7d6c9e34c8cb17aa6e5c3bc56d804b44e7513c86d274067a5952d41de1058a0ec9806e92b9fe0633fd8c71d4fefb3b673e099aa386b176792dc2c196b970c510d5de5b68e69de67d52eba1406838ea7792b5d77b74c7713e2c8509ec00db6b4da07238c503e66b27a35df41a2cdf8667d773671a362aa530425112c3295992a0418f07795b134b5ed211ca9878f8a33ef8b85a4654f82e4cac8cf589e62a62987a818fa7b5e7397fc0e0ef3dea1d1b5ffc2b71ac5dc3262fcfd50f11845d80eff8b0431424695f272253361d75a70ee3b54e2a7b50824fd26c8507fc872c842bdd3f5fb7e9ef864eafb8d2e72248af1c600cdb330fa6eae23c764b75cb24d86f1605d66ccb2b1674ee08cd4de2f1bcfc162e7c7af0c428d9c12c3227d119ebac9f9e7bb95275fd84cd5ef4816ae10ab2f77342c8f9e8d3184738fc856eba751f1d93daaaac35ff782bf18a2dade02a68077d0c820df09944455db7241728f5c35a59a990ed131130d56682e1c780f3c066fe96171bb7c0e205a18a39867b74abbaaf6fd3662b41fc098a054dd3410d6f2c6f27133ba905a2f5d58fc3a6a05e6023b2209a3a43e8628775f0abd769fc868f43700f2280a8b64bb5907d690f46ae259673ce50ba8f8d93fca4356934e5e7d9957331bf75e1d937313d48869e97ff5b176ad9bae6e2f759f589c4d32424ee68e4d47d9a305335ba074c6b855e8db756ced2436b69b239f536715cbee6c9bfeb4549282e9bc98d9b9e93de614770c6065e913b67870ceaccabadf39d8e3a1373d0cba0e4e16e00d576e4e27af62f9b469b0815402819e6d7424988e5c7f8aead6666af8cb758885ed157af952ce03bf25a7b0f35b041e4f3d9415103080154f1474a56be1253c7a62ba01f3a75a1b50c2055a6620e898b0b0189ae329a6cf18ba8dcf9bc9cc25ccb297d574dfbc5264f25cc63c4b7022a4146bf3d29d5034b64cddb0b180426c01ab9fcd8a88653cce1e1c5c76d89f4ca3a114d45b9de219696a6b34cf014151f7037604e15512b76d39b15781367d3975790aad9fabdec692a5233d7f30a3d45df659207ec1308ec748e4bd69083b74ded1ab157884f24760227f3c8c2d3702b278a3d171a805163417702c0159fa7f3561a333da5e6fa9c2d20754f4e3f64977fe033bfd8aa99eae53b27095b109b6cad1225e3f0d8e174d40c1cca59951b08041f47514c0c0421bc8e6d08b8696cc72c8cb4437e9d15fefd530531cf418eb02b28a34be0f44aa6a68f9901e22b0fef12a593824c05ae1b1d82e6d7f16168fdf480a06f2188daf806dc671511d36ee699efeb68eda6fa7c28a0014c79ff93c50eb1b3b0ce0672bb2e171da861f8179d6b1abf5918e043402f5d758693388a210110e6d01b0650a2ab19a7680d8f42e5dc7449bb6837cf9b19da4e13b4359547ce2e7d3e14842f07a3dade6009a59909e67a6ffac4fb847dab1957c35f0ad2581baa1f8b97445b73505961b47a185fa19bfc9311d0025e8f1fdeb20a7496bbc90e84c5bc78b9126f60c58228eacb7fbe1d3a83d7f96f1902c27e1695f5da8464ca905796e46f0a7e88c8ff6f302ae130e6fb5db08e4455e8ab10a36a145d1e3a3b199d78e1e5d97bee4f3067555314b8daaad83b1a94773edebeeb42cd2cd4e4b7eed97aa8768c2473963bcaa4b2082da162fdfbc405618aa5f5ecc4bc6b940430033c2343f97dbaeb8bc6742ac12662a98d37d0e8e5c5f8ae995aff9b6f5417447789c5dc9abdf002ba0a70d1a54ce8efd7be9867657d39d25cb6864b2f35047ece5159f4ae61ed9bf1bdd0074e94a5ff0aa9b18c4a2ef363911f5f703b9fd204ceefd4d3e74960cc413856c4d2c817f2114f05000bd29c9a70d85214f9f13ab2887e23d60a1832ea852685847432ec281476b7d954272204e08255d4c69c86e4ff3086a7f28a5c9c2d332832a8c06eb154b56df04fa0c7b55940fe97cb73e1053092e41886b01207e2eeb367cf7c67b95e46efb116b782196997fe3eabddd32ba226aebfe02849eed860698f8f7188505346d6b9d588450aa979be3f763112698ebcdd8da4776dae1b0f2beea3628abb51599c490a17d6763546afb638bb6f8c5d3464e1f46e9de605af6a196738485ce4be3e0e39d541bc689fa5b12cfdfb7cc2d7cd3aa15d34fa98fb6eb169233529f4741b8b00c4aed3d3f92e7fdab40a0a18db9892ff88762f777448d74e37cdcf0fda1d5338cd5a17f952ce9a657e33ea6aa157f97e8fbce23dc278eaba7f8abfee02455d0d4e3cde4b599bb5844444a6a4e8cc487cb8221756a75f7724f1c55c6e96778364dcfa35c4fb1328ec4905be74a1aeba2fb6d4444d98e2e33de24fa79047f52e10ecabb701a0c672fd381701125e8c9440651e0b3531ef832d17dc3a75f312f752d5864c585ea6d9e643be99dca5b8f8aaf5d46745fc94721d6a4065fc8491230cfcea2b1af45ff95af629c8249eaf09ccdeb31bad7956289897e5a0b820bac2168f129ead7d69a4231157588e537472eb23e468b177a6ac23b4153b05aa835cf2bcbe71c791f7ec9c68f9f06966fe12493b5ff77cd0f39a1ffde84edfcf335b329a6942a54de7b6a3511c2afcf8464628ef62117671d5c7fc4bd59c01bd2c65fc012d336749dcee1bd554d1ce2373107ecbc8c804f2e5143d1c25903eb52a52e5ef087b2214e05b1ef4dd4bf32faaf0954c2046d3591eb475de709bc3cf5775067f021039fba075846d028c4249f1f16f087481cf35cc5f207f61e10f8cf2d86559f44a5fe22a961acecf6a6a859d7631d1a7285afb23f7911fea39ea11847d556d27eaf2a0b48e462bc57e8920343eb514374dec10974cf37020e1cacc0322f9f478cceff6ec103755874ab556347326bb570e941800e71c2af18cc29d4976eabbcb2e2df72f67ca021101ca11485d82c5b23ca69739b3c1d5a2352c72c05a71be064a3b3f05a7bb27f6f67f9a3c5d6e35575d892d8b46868d463e8352744950ae9ddffa7465b60d03e84e94ee4985e70977f1a44c4ea84e3970b043bcdff645edc015785000e1925b8952943caf456cbff7b0979fc552e786aa19c596d8aea7e83e024f12157b8a62158fa1d5bc541f9c7e01a11d90103e30358d82cd482e47ccf503520796ec508d986fa072a238968a9351fda5c96c64999bd2894236f5f9b20890b8028b2564cd42e7ce70ef6b9e939213a6dd7b652f13aea082c472a40f43cfa5dd1c6707991a167c8933a0a4f1f20030d2cf4fbfa387256ad062acaa71c6f25ab31c6f5a8ff6d006c9a26cfb9ce02167d743c5065b56ed600e0dc2e6270520923be6eb1af07df5fcbee2c3c44f497e71d77782162a43ce15d57211bf9a91ceb5d3b1feb8746212062517ea7ed59f2da3bb6d2113bdbbf1d90768eabb5285422932422da012ef579b51fa2b8a04245bf5552831c6a5ae6cd97f1206c1b5e013b1c3b5f45063a26c71bf9ae97fab687f47662072e40ec8bd26384a7e7721e4b4cccb921ea4eb3c47ad6eb5b83eee44f04d4ab5b84453158f44b718468e608ed73f60056c489481a0e0d0ba50f3f1fba5fa7c2459d010549980259a56c969bbb6cee1fc679529aed1d0f0adf75522142f5911c3bd22c7ce0b58fc1569e62df3f737b742bcdce2b5553030049960cb9a9b2a0ed39cb30c77eeacb9aa9140a310fdaec9d736a4e8541a25b714ac9aad20b2178ad0c381d6104d92a3b7a2bf75be9c83ca40780abbf7b25133676b5cb8938ada985a9e5b1537c2382124188c36002b0eaaf841874cea2f80e943a4cb5785947f7abcfd33bf8fc95e171f39cb2d644a8e9167deb8501d3c8f4b9a31c0cc0cf3071bfce13d95657140796c4805075c2ed2dfcb8826091efc4ea3f49cd7fdd51bfc1a86719cdc0e99ec79c672f4ee549cd24df5c05d84a48075c2522435ec380051ff6d9581b128dce55493b5dcc5dda046c8076f4e53128b823aa761332f000debe119dd05f96ebd6e9b631e8854f0c6ef89f89d2f972a34e8fd067dfe44ddecff00ac2455ee03b421bcc44e3f89d506f9bd1405eff56417643e99d6db381c96278746bf15a7176da58f38504b028f4840d1dd65c1802d90484c0e1c01c2ec34aaea86fb9796a72e010b7ad64dbc1dcc387d573de4e18d041edd4061b820da6e99f48420c45e9026d1536201a9f74c8bf4e8a27fc43673c83865f496f2522d10e42d441c7236402c7dfac93e61545f45ca75ee3f1954610949ece503bde9b90c7f0791cc1c220bc48ead7977a212011bbfcdba05471f53f97e847991dd7051e4339aa6c1b61b2226d676554a3182de8e5fdc99369fbdb6c7efc3ad0e2bac578dad026a9d2230438c7948eaacc9f5985dff8a285e5a398de499198a411a3da7a7495a907f70ff12e310c774aaaa8eb0e50f35b74f0a1859dcf640c79586200367db6d90d5e8e37363a52f7524de628f2e1f9f1805658b356a2419f518e6f56cf80a1ed3f352357318922316293064e46d0319ea493ac07e6da7c32a545e8f200262459550c0a338dea1ab9ea461cf12e2104cbc6233b4f31eb47083ab00a1f95647471592cdb688bebb6e3d3951aa008f144abfd71092c0628e6554f246a116d4ee6f37537a0856b56358cde85d2e5533290e901f721588c40e57ebb5d2e1f0f4f7d2e87aeb5b5f22f4237462ab060d9c36ca67e5acf95c7fbe58bc33cda711d68d57103aad2d5943486195b4ea88d784822a4c2630c957ef3bc946d4e85987a5902e672c10b9ad94b7e21b04f86ac72ce1adadbcdc8095b9b675a9950c4189c3f5a2af53314a6c763a1852cd9753d171ba6675c48981d6c2975993211b38c24a7506a367df682576df0c0aa52e79d77cbc2a27f7d1ea474cd2a5c1e5d3dd0d7299cbd828810022525ce241d8f4e3833dbb7eefeed4d612d85a5bd79e215dcbfd9d1e8cc4afd127afd743d83a3a37198a2ef909cd063bb4ac04fed2eef862844d9d896b13b244d7328b935026d866aa7d8b9e7df3f2b3753391edbb48ae23e465890ce2b856066b87707eebebbe7ac62f0c8de1db567ee8f6a27d184a44469abef732e3142b1d832db6f0756c4cf81dfe97aaec1cd3a0127df09755523680b421784026684237ed4caa9ed3ccbe7ad5e21e6d08a05af86fbb613dd4d2747662d67e386be878ff5ef1d5e1fb7c72901b969f56c09d28a5da6fc4e4fa9d0d8254dd004e4ac4f166a944e058b89b616238c6b65419b2214ed34c37a611c47eb3a23d5e1dad04a6ed7fd2210a3fa18191e73abf6f751dc5d52ff4dd3d17531ef36dc76498eaed244ac309cf3df970fe5d0c2723314a4e881af915368f2704b63d98e622dcb216ff9bd48b80c7080507aea448714bcd3be4753372689c66b83da4d9b1005189fce5748a8ab2b26392757937b0e36fb730c958a77cc52cb92ffc7077420de7cdc4d28de9efb8b0116afc46109d4f57bc19db092237696369ac76df5dc12fbd8b9eb9750d96877e710ec22b47245e959c19649524e8c37a8c727ad47c43f4e60a4b77fa274cc1cf9ae5cda871bbedea0f072e7d4bf3373467b3d12531af55888bf7dbbf8fb3d123ecf4042f5045ce241cdd2157b58e589880e0058a30ee362c6bc12928401ec55f92739a48059317ab5a57c6358ca2377b6a51c6bf447059c83286fa8115fc77a780aaee6969034f040c3be868c791eab85f179614d1be7794231af84ad7d6838085bdff65b1d76638c076107c5e8662c173e4672c3427842686bb3d52c5f105e0207df38b41fb76cc1358018e8c5932249a440d7cd560661920082a36ec5054cd301dafe927e912c3be5aabbc53427dfda1d7d81f9978c0e02bdc23bf80960ee997f38d736fed3b376b55e4b5df30b58124ecf8b7cddc8c871cbae848a03ec43edc3c6ac09206186c020b2d9ff95ed0358770fadf186e0a0cbbcc61f2f21bbd52e7dd6f85223887003a084150aa8e62ea61c8bc6e5d5852bc41660ecafbf54f168cfc9721b3d4ddd814aad2d6a3a17f1223d1d21099f162bbdc22c1172178246e9fcd180e0077ddda37668e0120d4e3d04faee10fab6d70b6c1f617efd47a7b6d27dd4c6274c35d8ea84223d4e36fc2463a5a9355a4a62efa6d8974180460be0269dca635a244bf28a9e039b3a80c8c270b7a9830a3e4555ed8e7ec77830dac0e710b7e67fe0e67d6d83e5a6d98af7c0a47af01b7a20d64597bc6cf8fb02d802838c4cef4786cac45bb268269dca5268fdb79ba83b7a25e318c6a2274fc200f4b2f335937379b167b488e20c031ba8c1bda860aa2b42ce21a8be66a333b3b47b44773abf58043908dd5e4b5c9d56a99be6b93e79f13937004f1f9d07eb840d065edad6cecb18bc9f24394c93104472df8584bcab1a7eb3459e57d0cf20fdbeab160a9013eaa1d75360068376caef6f3d821dd95d0d48d1220c3207d73d27875bb9e82f91a02d993d539df444ab419fa516f4c9b82a87f90980f0ba28c96aa1f043753a0e4e2cf1270f513e7e4e05fe28ba50785728f088e8d720e5f6e25a6e4351f0131912eb07d2c4b63a2df929bf9176b20fe3096c0f100d74b733800a7220b611d684fd6e680297f1e88d0d7680ecdd247da82c5c3adbbeda868c6970ece721f86581b71faf3f334d97d57370faf3bccc107a956eaa789475deeeb7587be82563682d315d3a30b9b1e3699fd40fd46d48206d8de4b8e735d60a6895b684af683a135a3e323e3946b50f8899a91d72cbe87a497c43b60e92009054eef2800b0f5d436ee541a1de6db6f8c1e4f0e925231161f6a7e812998dc68d9a5ff198f50f7962a9be4c6300bbce04cf47aa863219d82745393dc584914748910174277a8d5029cd020215eb6ca7c4d277851f5bc0e9a4db8ce4678e49c3289549dfc17f336305f0b137811e273e9efd18afe317f09afb6de5fce173113caa7db0b47eb5d365a41f85527bdf8e0a549715806fe3223036243948364da391e22ac9bda8acfce328e32d111361bb5a7f9ef1223ebae7d55a177db7d1dfe7b448fb3dc1145b75c77c46d875320d418d3c353e7e112c8a864f00057602789432e29f5a31f37eecb370d097ebd178499a02676b80f95a40d2ec9bd268d5abfa0201f5ea763801960173f106c286a1d090d6b5f2bf47ec249beb0e98e10dc6d686f9de860761474347dfbdf0d0efd2fea48caa5e49ac098d7e5f4766bb9a58b78dfd09831ced87ca87ef6b90b9e19ea21328b0d7bac11b6c1dcace0ccaaf5156f935de3e67febbeadca31f558a498c69e7c69effc88247b1f0f81f8ee51eaecd802f60151db14670634c6606272baa4e7490fb296be6589504be311476594272ec63b7bf621c18de77ed776a6a19526053ca160b907235d884ad3ae3f535d72d288277da7a3be48c6f0b67c4f357f312ff3c8dc2d57b77812b35bd0c327b9d40d19e8590e51a36d0553d84e5ae77f3a6fda227b29b2aa0f66abf66ff1b05f391971fd60259d8db1bd318d04ca0d8a3f7c0fdddf65a0c325d9f75a933d1001afa44edc16df35e401c28f4a4950481299fcd38c53301d613a77d67afdb9fbbfb1c20b9ad340b9e0f15f70425f9ed0c159cc6ca7ed4a16b79f89c87a5c7dfec42b7afdd3b9b333b63b7ddee9f973bef160d482c5606ee5cba0ad703dfc232318bd2829871123156f40e677acea5f722a866d6baac2dfa7f8892e440fc09726dca05e4349c0b3fcbec32005800681eb3d2d1608dc02d5773d830ac2419a85f7c2c48203e7d9efed21c16655f2d2e8c3c9a19825cc78eaa9744d90a6892f7ddd50ab87b3ebd904e1d8bb5a04cad8529d13c55f377a74231dff295bd45ca9630655081f42eb203a43b0736d13785f769d18432ad1298f60daa0cfcb3f1203371808449dc667c4a065f94ea88df2a86615085fa6e9457d2f45d36b592ffdcea79d66ab9709b813abb8b13d19bdc5c8181dbc3d391cf88ee75bb0970403a0f7ca066d0c1f0c40abf4d07f4f50eaead871cb7ae40b823582356346e02d12dac8f7e55aca5627533e88b101b5226ae40e8324230cc0bb401d669c1078ecad84f0471dabace9db7fc6f44137020095ed1ede5770625565b0e88e4c3f597b50a369ca811df4981989a74f3e0b613135abcbc73aea3b078c19ed2173f96161efb9100ccfbfc7036ccaff5fd6328e57b0e9a0a147421e5102d4934cf46da42f1d86741a1b83386f87b0f8e81945c6cf2c0cb66c795a13d924311161d37f9b3cbf5b2b3130207246f1329d56beaa1ca9ff4acddfbda5e101a97718eef7c22fe26b328e941b8f517e4dc9490177121fe7c612ae7d750253a398e574a4c76e5a89dccee75321d4ca2d1ec2e4d2e17e33783422295a66720fe0dcc96e6f667f9a0f1d6d27b84f4c45d641eaa226b3d7395b249e3f93117c2039fa1ef55782e775654a36e929734ae2a7ac200fe0cf26655893071a27edf14fdf228fe17ae2df9fa47cc5569059e8b1864e92431e194686c31b18dd4cb8416fa1c47e7bd2efac035f3ec7540a191e8dafa6df52b822edd0e9c5edd9e46201ec4d0f578ee043bc74de09bb52d073f7e8bf8ac96a7c6b65fe81f1b8619ab5e43c7bd08595c583bc2b9c9845c909e109e9e9a883c366e7302276004580332c8e632224378d42ca8f43bec31d123555a1fab03d1984a91d926453857553306373770a7e4ed4158a58ac47ab4871a533167d2dc6fc5ee757860e0b5775511f64f96c08cc7a4b0ea5f2698f385848526777b4285313698d85c8b2a4e56c0117866936c7156d09501d70e8df296231d8372c7f0391728f86b1f677d5eca71b8107927362c9c360dbb4d8a5fd393252662078f7bf6fc21256b21dca17921392c92077908ee57fedaf2e36fcb07b83c34d5a8ad7bf72027adcc31434714e19bae88f895d21f27caa94af1d4999d841999214b32d8c9dc945a1e155a991e6662049f575bb31779b0a6dcaea66cc5da758fac738930b45ca7d7c5bf6868e1896b7843316ef17d1bb3871122414fd0c89457209e94ca8e6baab56387fe181da1b87e3bbf8a7ec7b88b405f7aaf7d0a653345c18eca813d356afeb62aaff1a9fd51bd812130f5456fc0184a7eebc417e227e1d95d8fca3b69b9e70494977a1600748bde458a757aabf7f9c8b02df44c5014397837fca064850f7ae60c09b7031bab4889959be36f0b3479a36acec9c7feb5e1fef4944fb43cafeadd20c9465fc37b8578a40dc9c2ff3bb5cffafb8dc0ee8959f039c84cfcca3e0365fae191bfa406a3190d5eb36817216cd42bc76b9164a6e4448f4b526e538b7e138d78aa22e1fc9e95cc86c16a0befb2296d2a712c1a7d727233c809b078e9fbd7c62f488aa71c5965b12edeb1e04844634373378ebe65379961f43d554514128a9d606b61ed6513d5076224ef3b4ec7fb2f4bfd40b40c48cef3e6968a2ba530e59289605cfb117167418cc27f8f27d536363ef3d62507126637ae21e8376c4820cf1fbf5d6c85f98153122c90ec87f6a927471ed4cae9e909d1f3ae53e8089c5ccb5b67fe6dadbb9a8d2d8c2fe19acd6b29b3a269f6dfc18a4a224e58af1275b73e77b987954f51ca8ed1ab9daeb48b3d3a7e338260abd84df64b2f9fb30a0ec63677dc55a2197a675c2adddd8e99cdeb9568e3a73e5f579fbb5b074a20644cc8b978c44451a603f66fd422a1fd55adb4cade436ca7b28b1c9f3a98586490ab75acbb3609675d8eba035c01f312d5c83ace6f1011f8ab37a36c226b1fc4f5c4c840b2ca42be8a1d4e4b1661497a59ed069041b84d5ce0c58ffa89f58aef617f6c68fd90e7462eb68a1d71af1e39f27e788f49c30d7be10613e5c9f6bb7c7afb6034646e87d249a5ec9e160b05512a042478bf6a080e0206e9d918778537b63caad4ab3cbfaa47e9d8796c3c41216c385279f24c06001ba6af5d57a9320337924ce710c04551264cd43e1c713eed2322b8f4c2f27b6303f41e22af12c4613a34c6faf829fa46cf1c96eaac38f058fcf08420fa13384690ad07e134074aec14e71432e73992550721a9760da00c58229848f8945965622aca2092a60064fe98eff11c9de7effd20fa7d2e5b5f549ad53d6a044df249bd6f4c987cd3ee89196cf20aa00a1228928c92b471d2eb7afcbb74b56272077349e7309ee058df4b46bc6bb9a59de37480415420d01337e0259ebd7384c4a2c3fdd1389ddd0050431314e4fa274632bd5e015c72b4ceafd00badf0aac92a25532d4dc30348719d0040b21e750e610341c8393d66ce64ac13537e212eb8d66a87b8460d64b12dab7cfe0303400fd3aa014537e0c01f257643e648a0a19869c2b73c837dcc113759cf04ebb7c78cc68757f6e77866a8fb8f59a53ab00c52a9f3f58a24fcc5637726bb931c250596fc1bfb8bcc84c529e105456454987ebc31ea2218bad7ec4d2e4639f794d5f8e3b0e0435e456dc27d60827df0e38c205c53cddeecc6fb07823579783c2d47161cf6671778bd61a60eeb5b04c05813c0d86f837abad05e1e050449e4d1d5894d2e3467a5f94d57bc607fe3b189287cd84f1414531c476c4e1d9657933a63b7b96704a282a990f22867ed7243ab23379fc419e121ef00795e7363789610c15968369bcee7934f5b511c031645b7190e62369893b0e27f1bcfabddd5ce09411fd61151a2e27cef95a37061204d8f6d57f72540826057fba597c28eeebefca6f1f33d3df08273ac4442fd1c55b110aaa5c364e31d2faefaec57b94d0f2ce48050d8f5a102ffd135f1c082233a4c34b94eacf11ba809cf994bfc61156ded5d8d2d4ef91c8de39ef9a7bfdec463248967f327825a19d213b955a4aa3b986eb7fb8e7f3376c83377bcc5f639a97a6d92f3fad664816ef52ea258c70684b19b687b6409fb2a03bc6f2ce767a9ed3e29a02198bacd496efe575c049472d5580eda41881434efc90f76dca4c0d03f100c3115b67535dfa469b61ccdaeca3c757f63491e8391474943ce3c35d517a1d239226c0f7ac05a854f3f2e8bb982cb42e9e6325a4b97cc296aefa92b62b36cf0e6b45f90bfafb22da0ea748fa052845ee5f8eed05325e6e17780aaf9922fb87f3aae27cd7b8f533f88a2c762b72d6f0a4a3de17dbad91e07326b304c056c9564eee25c71b0c0218806736f117248b085bf2c0d122f3c33ebc7329ffdf9bbe073efa878e2bfdbd1c13a96fff3df15ed75730e11b0812ecc140a8293040a3ab7886a12dfa260a3d81b38f96b071d55a11a8783d89fb6a51a1881c63fc7e039920ec7492e6f6cbf65275552f0e053b499c03951a0ef2545e8fa1d245a74bbb456fdfe689b3c314f7883aedd1af82a362d8aeecd1fcf52c4bcbab512419bcf609777c4a7d09da760c90cadf53c855663f19872c9c21c5c576be97e05ac757a69c909489a676edac958b69997b98c29a00a87c5a83fa718c6587a88407d674470e0e54ac5e398e9460a7e38fc08172cead2d678e7d7c43c0b3e8dcbe6c1eb844142021867d11e9d4d09e27596e4ab53bae20f1619ac3386c0345a7684d7db2f9113e25c06b91f10a874734b513b030bad1dc0ba123d63087201393ee2cfcf231db616c115b96119fc41107252d174b3e15264deb12aa70aeb88cb96c9792f56fca29fdc5ac77f0b7669f9896867b52dbc36c79ff96d9c6ea87d781ead6d7b4c1550562584ff84db1d82fc4dd4a5aeb8629206146e5794d575f225c690802bca8f0ecc7357f4685a35220f09c8c5fff1cdffc076c93aedde7f98670ebb508d9e847893072e13e659b1658e99486e1afceab5b460c80598f09f43b281bd3a68d666b25171ffafb24ab3744ece6c42c9bf06dfdf619d23e4945da19460d6ab13b86353053afcc9efa6bae7e5b08092672df40589cdb89d05c318e440e8ebfaae97ea11ceabf5db9b33d5eed79b6b6e47e018bbf03f4d94050fec26d324330c20d009056b0a39370616f78b248ea4ed4cae4534a9b33904be0741ac9ef2941d35ba19c38d5b78dbb871683a3f0f9a3945973a99c770040c3f1684788ca4fdf05efbede7eec2ddda686689fe0ca3868346c2f44bdc7b3f4ee5d3ec612538a559b0fb37872015444b8220f4d8edc845b9b1f07589c88c98243b1269e50e1016f53831e86b25c4391a1d244307670dfce42bcc96c8922f005deab6e247f022b479a184207d544bb70620c8b5618695e85ba3612c3d1060477b439c19313f8eee5c0a2a1272f200a40a1d854e35788c68f20580462a09ac7642690ce5a0c32192c0ba370efd54fb47e8ae87d57c06d542ddaed9792832ce2ed62e9e11c39cc43cee1d5dfd117cebc883830a84354dde240c9c8af701664d88e984727e1c019ce7ebc0c2cc44e13bb35e41600919b55440d848d198586cf81d683aa8c7d158de7bbc9298061a28d16ba9fb3606379ed68f3deeee05b09ff9bdb8eec1ea10d80410ce14d1590962fdf6e58647c97d92e065d0145ad1efa03b64cd70a083d532bf448a32d4a0707e8da423f335004af717fd520fcfd23d9cd282c1ddc141b0389c36df54da0a35e3c620fdac33dac4a9dbda4ba97b34f4648a62c87b59228462e8c5914d8ec85e4e1c414d692bc85091c8be3a5ae9b781bec4f7d26112ff60e905ec023fa07b24870a1ba0ecfcf6827cd10c085801c8e23083ce04e622bf54fddb8f480970b1c7c6d609cfa4fb3fac3d550507ed439e8ef7ccc209361385cbd14271d1e04f52ed0fb7dca00e4879a23dcd29cc14791f17caa37990b2e3ff5d3c54601c81c31e303695af7d6fcf7d4a56887f7a12041226d0157b3c2ff75b12e1cd9d5af13b93fdf1e1c06588fec9cf3eb05085b226e802503f5cc4cd899931cf7e7d5baef3ad653dabb906fd775e28d649cc6659d195e56427e8917df8b81ad3206cb488d4273ce9e2975eddd066e057fb599db082c9325cd4a84e9371d448193a69d64f96d68374672849ed26d32e3d0bb19ba804d0b29205ac4b7ebb21643ddb88bbc001ef977b5c3cdcc2b195d99231f59f87145dbb43c0aceb66e1114969409f1485464190ea88260fd0e4a8ea7351f2f93f15c6091a82622b23968842d24057507ae7cf166d2db56c99f34254c9a42d9717d40a6b08f5bad244e35ecb1aa65d30a503467389b1c8b8b22fe1533f3ad3c07ff6c5323976ecc4c991e3c06b138cdd295b227fb048e42bdeb16dc5158ed2031898a0920c3f0ea41da42a81b6eb80741f20e02337f6f92a63d55e4b307b31827baee27d5f7c2f67647f273446ff30d52ec8c4a828d825b40caf30be74b4d0dcd7d9d5e062d0873fee58ad66e7c9e8c8e90e7d969c95abf98d7f789e5614af3a4f9daf9666ea30c48792b462d58cbd9310b751e6620d950494631f92f03600fffae86542a7b97269b88eaff9cce1515d9017b65f7bba245156f7c914432188c08adbf6ca05bd50dc529f0b31bcdf7d642841a5e6e52990118","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
