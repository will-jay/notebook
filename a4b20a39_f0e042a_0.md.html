<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ff46d15ecc8f28648c0379a5a37a5adf497cd6d09dd879228497b29ded7e50a7a90010382bc5c06db42cab98788e6284a33c72c7463d9ece5832cba21dbcf276fc081630d7862dbc803896c2e6fde1e31526c18b427bffe92cd48c9390657290c6654ea9e19f7514a7a8b10e791fcb4ac8979832d7d56b09ba765d352388e9e7dc43f0de0566efec799d7d456242b82ed27647c8ba7e5d4f0c35762d4fa3f6e5cebc2f655545f8b904aa9edce782dab73c3b2889c03839bb23266874472416c18bce339c4b3aee16b4ef446ccb20a23ab5644ef04dd50d674fdfad1f624131c48e0dce5668a11da7ebef3cff49c0d7701440b2a149c72c85750d6233f2b41e393897881d89fe8c9fe425420b88cb7d996c9ec584991b7a04fe975be96e06299b45cd62c30f7d2c020d0694b677ca75a9f8e133fb8c00683d71c2e959ffb9b7f63b144f436a710c91f84ee02f3500984151611233d8c0076aba03b8dc6a33d5e0c305fd46048c2f2dd72ef6d7fea5565156a8c08b45849edbe2e9189786fc5958dbb9b0310ec4c3f5ab68ad6b2ddf764898288e48dcea8354de611b07ba817aa5d0c2b879d74f0a574d3375acad332afa02cbb00fb9c6812bd305856372c3f9c1f314415a530c6991ce03ad7e96681ab0816219540437a4dd5df4ca29d482bae23486454120cf4e2611b9e9f17b8f882dc848b3bc254d2554b92e1b13f30f78261e610f4265cf135847aa19097ee821620f63f0eb36f41bae52798032ff582514ce1c4204776473e6e352ac430a6996bb1ed269f19545b91d6555cfa6f8955a2ce46ec8f31144238e342e1e1d98063e0ad494a99f3a11abd45e9e278b52c54f1d6e718e030d2b5b0f6207d567cee0fc703c8ccedbe58b88631b1fe3732af0e0984b53c1daf69373c934bcbcb5b3f633e204d9a9d305d2f6700ccee9c5543bd4ebdd57c9b811416d6b4ea6f2e61f71cb01a728f85182351fc811cada0a40e0d805d864196f7b84faa7b49bd59899acc00dd2ae0a6e8cf89501f2329d1a6f4da9492d2d8ebbbbb5a512fc3bbcdeb5276b6a9c1b18c88795a81a86fbbb4c973013fdbad7af79960d8b6da585f45f3e8b95c59ede4db9b8bcc166ae1d3accc8f34f933a6fec1bc9d50207fe256b41a904e8083044320918342ec148be37c35f8bb9e9cbd589a5f499c3f034eba781d506dbc1f4ca6865dfedc9f1820898f23bb616f5819f00fed361302214e992258750a872386e2f67d675b839bc05d15d3f1051f174ee3d435cc4d65f28109df4140a1db80f7b7d86881470fca794a012649ed317f6ec14324ea218bc457b3472df670f397e81a6158143d7e8ebd96394766c119d064bc6a9da9b08d886c6c15cb4eb1e7bdc6f41a748f7c08df1d2acc4e7d034b8d33e7b9326ae359fb2eacbb5593db0c0afca1ef2545ec5d31447560d8c3f35a073036ad37151f129abf50dc13e3b9f231a25eb2c2086dd6cd6aa465749aad7b506dfed5429e8012ea1c58508009a718ad9915c94fd9d58b717753647bf4943440d42648ee177e7cd2e5684392a3d3b053fc942a5748415fd6972a7684cd089110a852e87f52dc474f71f0205b15d75e83c15f9386efc35c39ee3e0c2f5e051136ed5bde3aa1d72e582ed04bbd2c147cd1a3a46bada599eba0d5c19e44d214d685737901bce712dbfc9fa55f59ff23f1526f1a904f809e42569a5a14f1f11d10f22b46e1338ed1f3648d70a940e6bb8af6ba15490ccc7c24a0520dca467fb2dd7d49540f746057e261bb5ffaecaef5f0cd087cac51926d1239d198d1d431a3e5cbd29d6f7e5a39552a0ade8774dc8a33e278f7356f5f81f79a440e70f817630ea69ed6caacf8f653ed0bcd7cee488993af88065333d75dd8448d6bac06bb63b93fc4842f5503aea888f70260c2e471d8e51e04fa788345129ab1c348745775bda37edc40aeb5692f6447bdb2e79163ac190f5e4e19a6b40ecc93edf27aaf5cd47b4cb4144bdd7a0036a3929157d4941abd5f0dac0cfca74907f76a6694f7ace7eed5f9613b08e7e04955210f378902787759eff5b6f58c42d41a793086f64643f6c62fbe35e31d35d4ba30a958f8c0440ddfedaede329f447cbf7fc561ae573ba986dcf1d7d4db520bba4f378f548db918def9dad1f5db3b0cce1ddafa0624f02f8a2175341a6e0d65c6545d6d051515e37ad09437f598b2cdecad0190134ed916b082efb28bb2aa1d76700dc2edaedaaa0e9fd1193e4eac3796e3c85cce3402c08d27f1dfce0cb3e15fbceadc570cc30fd5643b0b1f55a44d22d57fab0e68802a01aa7265e985397b98d4d3aeb7c8704268b2cdc2b3949fb4671d94e8066787b0d501f950abaae05ad4cc9a0fd70b830236d3c4ec5d6a611bc721b26f91648766fa5be43d021b2ecdf0605aac3784be7e76d25d0ccbf073c97b13b7a33d2d63a7b8d1b47482575d4b45f3c0489217c07d393eb6a1071a326bc1d35642a578aeb3a201d732d2d7c3b62fa1917f053b2129dba57ac6070fa9499c1a7691899bbd5929f8009c1e9a3704b7c4ced9bf7351f66d02937e4ca83a8df11b2eeb1ee471d86fc6450a76a3b347c97192ca9878d6f7b1fe8772031c598274bf8d822665602df7d47d8f7d4995cbf9b9d958b3002da749232d053161eabec3cfad7e97d52f80844bd86bf35e1ee756bfb32a1ce7ddef06038a20d0ebfa9d3f1caf95fb9b5d00400cd7094ed68564ee56f11eaad9818561adae241edf4258f1e8130bf712215499d0e8d82b3cc25f6c8530572f4132440b4dbe1a88f1ed09930e313784ed4aa56b53570e82ecddaf45c0fdb9467687119d69e514dd890b628a6f501e09da6d332e49cf99ee8ad4cc8746ebac93f95704f85442f1c421804bc0ec3e4b7ab330e77c511cf4c43e06963a09f89510ec3c05c2c49e4c321f34eae762652b91c4fd096cb8a2bb599a6a87c38142f3dea2794aa0be4961afe74c6646932cf3e3a92a7a2cd370ffc69a25684dce9726b8f580058fc5a3d41e0c14f32a3f63f92c0516fd4da35a18b887e223cce3577412a6d0bad0838b73af2ab46a9045abfd949b316ae4ce49da1090b92386cb047b1b768a2507c20c7902d4e3a1fb8a0d4009efa7c1c878701aea72d09d39e23bb4d87ddfd5cc7d0f004303d77f2cb8ee1d7bd1b62296d4f634c03442e028d468a631c088b45bdfe1f905daeec2ff0cad710fd243f7d24146e6751170b4bee6e505d052b2291c7110e958262eaa3af37bf51a2cea472a1a28e17dc48e19e83423152c78570634737377dbbf2ab5191c2627f09aaaf73db8801a882a8f8866e728f221ec01b6195ed7ee96f13809f536a04cdbe3f20bb35f5e862b6438cbe14da3e904a694362f0fa72fc51f03f4c9911b689c060583e154d11403574ef689fd2fccbc118f5220198e724ca26d9f067e86829f7412b77a4c4d15b492402d2faf831331d978ee9ea0554f2f74936bb532139af50481a233f55a628769904abad3efc52f8acb4c66479035956d12a71de7bb108826e342cd449fd19b79ba0669ac7f9bcc143366d9942353f5d35a963f16c11b9638115c92276bc18212a2ef482a63bcec33e32862ff442eb7358f9d748ee283c942ca0384c4ec6e0163b0b8a6b67501d6127991e035470b750dae4c7d119e11ff9c3e185284d5f03df43dbf3830719d2f09504866aa62d855749ac873f4473c5a1ec8d53af9998052d0b5a104d80bd08cad78ad467b9aed5f8193e41e68a6683f6909f5f7ce5ca82c66e3dfa49831ad340a2ce00c057007a1e4e97cdc01e07094014b914df96051b9dd1ce51ffe07d1c5b1cccc838ece2e50237187fe0d54ee6208919a7ae9b4f75cba830d0cdf4bb0286cd18e43c90a421798dbda5bd2dcf27639e07dc206a4f937210199723770a3d7f22916cb08c2d9c1eb3e8d698c5f8fac454fccb1cb5e9c222af50dacb0f2ce240d64ca375a5d3aa8dc3d0d0bf37d30344ae52c0d13f83d601f32de0bf5f9347d822a34753f28fbca5c9c6133ddf8cd58f34f617b7087cd2878333e7e61eff9530f9c9183427efd2a957d742b007d5a7af825bb239f075af2dd065743f08871d18a9177a042cd4d619b1d1ab54d9ab4cf55143d7a103a814d3eae1be9c46c013e79f3c2379c10b73bb4d1480137187c93208293801501b63ce17c2ac51d1960a5be2feeee6c200ec35a8e43dbe52c96b71ed35499cf61fa15ded69a4ed5d259ad2106dedc32083fbb41d11a78143a36d1cf8c312cc110eee097ac35cd532c02546f491aaacad9909cba25784aeb23c188b05230c432c6bdd93a9742181f110b9bf3ab8fc6552229e848d007d1c76d0acf4983ee12f36630f9dd7685ea519c7fa0bf86b92b9140b9ad1be129e74602af5a559663433418f3e443cf5be6998158f2e42ff3f56c852ff84794113b554d5b86b5dae61246e1f3175bbdda7fb950910eefd48fe1e61810456bda4f1ab4d7ff2796e93dfa1bbc882583308fb7b8851f2ea962148e6cd5f9898f126023d33400d7a734390dfa4fcc43c8f0411f953a23b8f44240254cc864f614d3a6d483dcc6149726872533341b8a7feab03f0bce042e08bfce41fa8a9bcc8878051e377ddc5c68092cea4b5f220c2202b29bef35e37736bb18f280753b873e33af54efee259f7ea16f6a5f9dede8ee1e1c33a61e876329c5fba89adb02a9ee05d7778130992dd29703ed49f6612d26f24a73f3b966c3993e4b458b4d66e76bf394111608ec9514f727ccb7a7d5efc5904e1b2c67736254edf0bac525081b856ed6932bc44d95d4c47df89f86be10d91a8747d4660d8d7a58216a7cca6066ffe246c2d1916e207ae714d7c3220e8eb3c1fd14b9fca0c5f496a9bb705d344ffcaabe7b45740a3badf4e365ac986a61a4ff08e3a415aafea4c7d964011e0b07fa5945db6635e0d8599b920de0cce9211d38c54eb6e071242ee84310f3688f56fdf0764c1346d06969bed72abba1f46ebf962edb8f63d235b706e9c8a7ce06d6091e3def270cbdc7a33202f16a98ebced4e3b826e20271f0c4784dbf1fd3a61c27a22f0ef3460d700cc74b76b4aab8c59bd0e1b5ee70c1ebd87d0641544fabd27b5183ebc0067c9757e52ded5feae1d5e7c1d7fc9775cef4b6d7cca430bcbdb7700232255590a0196fbfb8a0e13ce72d46c837667340e7c1510164ff66ae78633c4f3b85953aedfc18ce7231dfd9df180b91f1800f0c12320881ed15e074fe4bd3c5be340e6a5efd3ea02f227c7e2b54fbe37cf34bb364d575b7e55df8aca98dae8f4c754d178a820fd7dc34600e48a83b77adb90321977b6353911cae2dd181cfa657559da7c33ea1e35c19eb5921ec5a7f54c744bf33897dceba8319ac8a15a6933c259948dbf3cd4f4a35d7ba28f8772ee9d79277fb166c11bbb464abf2c038c60aad97123410fa029f91b51241c940bbb75974a1083865726c3cc7182ef74e6d2d6e537530ea887c94cde082e343e56be505f3b2d880db6922b4c87fd3522d9365ed9090caf9f1e3611cc271a0f045d40d4d71373b038b811c4dfbaf597f16be1f08c55e46abb207d0a1f799f92d26c99fe5779b03e38bb53eb91b989b76896da931beedc315a846e2dd32aee837ec911f04544291b5d8e551fa78441978867d2f6c71a74cbf167daf7073a400eaa757f8ffd856c7c37443ff58ce1adad87c29064beb6972c69a9c6934a84a5bd7077f004fffaa03cd3eb45f92e41fd713a1d022acf5428b32740de83c0f6626c97512a6ce355765c97ee97198a2a7a8b260f213fe9be275863473dcf576e6b89da2f311ffc92e19cd4d3917732c9843a554f9158b14c3a78db25214da12ea63240a511be968317f1cae91e5a3bdf461b4f90bfa631be3756b86ebe4d9853945710fede62572217d960a39fe4c51a5cf6994ac80a0ffc7f2fffcb56893aa78afd235ba6ca5853819ff6cd86cf1a29d21f225d0599ee0c796d92044e012101968f3c2e907336272bb7d83fabcf1a0107a19f1d9bd38f04f823daedd87cb8ab0b7d0e9c06ae5829911c1264bae2da545cddf63db4c6fc3cbacc185bea88e0a11b9b0b67009ddd9303b46bcc607b27f4cbd4a99060cce60e07fd7464521d1997a39913dd671a8d6ca9c9d58439bc806d68c014d91dd02d6f1d239fe79a8088461dab87a78b4e24de28a4a92469adf75b734956b7efe17bfce8260ca70857bd8d569c947e95dbd1afcf58ea863b2f26872a0179a2e827cf192cecaf9186b5aa41fc7bdf16f5516cd909a6d2afd01c4511663ae3f6e3c37ff5ea74365e5257de9887a08771658b81a03834b9a4f24f8806ebb4e824c1a1fe2a8ef59acdc461fa0238150f70fdf31f98de7d848d27db8079ad7dca2d1b8513c78d9a7e8c17872e9a55cfa593f67a5c63b933e61fbb3bb4f5be8503da0cce36ac2c478fcca3ee91b664b511e9669c9496293355fb3f73715f116c5a680f496b0c2d33b55545dc06e363f3b12885ed1854e8ea9fd516440bbf2df179021d6f13022a1ae077fa95e0e92e4f7d2b5c940ac20c370bffe5f75bd3c346d6b95106f21c0b3ff250b82a0a140829029acdd4102e0788b39db912b5214cbd950500ca5405d468f1fef5f4cd982c19595abab09f163cf56fa088160d63bf7af5ebb9df28f9e38ac91b4912b7816993571196460055c6c16e61b93014e0e3c1967ffba3a8f47d5e7651b07fe587f6839cfbb81e185b9ca461a612d838e99d157455bb4d2bb66d119b0751503b2a9f139c6e692a91ad19e18f9c49e90999c631f21df45b181fa7053ed8b3f4a0d9d00c810cbc76eadc38050281410d7d06f69547eaf7c105ed104398fd0240ec180bf285f3b5a2b7b61e18a9d71e8b764990e04de0d990a09e55bf369cf580eba173aa68016ed00b382b8a876b9e5640970f39bbf9f52e845c65759607914744fc9ad9b16106036b4bae04ced490c338374838476e474a48ff67d559698512e4d2e4ad80e5f08b6dcf6422fcbebd602016901ba96c35a2d3534aaf4c49daa59f5027d5e0c51e33249b4ab8374738386b14b073f5b628787280ef2b889520114649a0414c301e06e1dd55021e93ed2b957857a1178d523f7bcaf750b4c17fcc264a3700ad8a4e36c96bfe7e64cf08dd2bb218ef88762340ce49982d56cffc8e06af2b19ccaa3d0f6b1a55beac688859180c808bd1554728e6e28769735a07d0cb629a893016eba9d4f22675f34d61220d8a5a8ed7231fe370021680c68b085ecc54c72bdcfec97439f34fb5d8f529a988db8d79e77918bd32743bedb3ce0ca7b0ecd23d71f50d7debe980b81b1731f338fb92717cb690c70838a5562daf83036b7955e65dedb3e273bf9c6837a42a9cd4a48c20db7f1e7d0155d2145607314853f64dd1e74f588b1730f2692e313e21cda78a9fd994de84420b631461b1dcc8b368b7e25f8ac4e36902d50c9d37a5fc9ac4792a5340de53a4801c62f377dd6350fe14f5a07236d2efc6e805e3fd603e3bad1b38cf88e8bab3ed9637a43620a24124af1e4c5e31a69818b59d9ab16726b54c114a23b7bc0930fd8a7611333fbea2ffa5606b8ae41d871870635009f83f296bb506b16c40a849a2efc9341f08ef7a1d1ab22b0a5470987f004d158f3ceaea087ef7eaee9d922871ab8205e1ebe32fd2cd66736ee683eaaada4807711b98ddc307483118ccd0ea20e073911f3e9b6b46c726705f9aa53f2943bced4e8fff09fa003bef4e7e6aafd3a2c07f564a84a498c381aa9f4b12f261813474a9fd6d7112502efa5faee49e86684b8db60191f261074506b724bc8f19537a26ac7db4f401b9df7ac6f44843943271d551ed1739c436f23ca12f17a976dc867905bf30d4fee3d9af237ed5197568541592db5be72ea757b0c3b9668e3f22f33f8e921926125fa312961fd726f78b8e5bb77acd3e2940470d87726f6be5bfc72690323f97756b1c5777dfb380b8d76d18ce9f5c1850e2628014d3f1999f3980b399867e082d5714b4f4681cf802763b377bc7ec9a8080aed5f7198bc4f2ba4157b715016e6be54f5d441ae3e23eb4e182716e109a212ce1894afa32b32a6479b19532b1cbad213522d32334fa77518853db02d88a5c247c97099bf28543a984759c96bef18bb111f724bf5706580a299788fdf9836134339569f9abf131f64d30a7ed4fbde8c39450f66bb7241335dc0b69c629f404dc3d67edd90f9111067b1ee87b781e3e2d5b4218247ea3309a7a3e12ed82d97fb62b38543c2a4434825ecf6944e2a566c56a5b8f340c7b065f492dd1b0129ee029216d20bf941b2ff9e1fefa2c459db524b6f417ff99b6aac37eba3df10fe7e6a964a4a4685e1f86ba674b8d78623df553b442c8989f89bb4169762fbbfa9a88af2a1da2b893a1388eed0f48fc06f86ac101f5e0df4f6c7d1aa64402d15b0471f371b3b6f9bd760265330ac027831b25e20ed7f5cb7ecab77abba9f29df9a7648c592e9b6b1c071cae2bf10484662ddce6083e3e1815d4d55c908e817b365af05c860733640cec370226e96ea71b3e66c2ada9de6ea415f745149eb9aa80a57abb6c000bf70ed966a99e3c0e2d07e0a9125e06851c4ee4df20ae76303f5552b52582f5e116aa2a4dd1686ffe6cf38bb50777ca3cadf6d62d723750091bfe7b905161f46b594c7b3a380829cce0aa4b39bd026515cb8232a2f77cb5a9e4e9fa400a4e6f5dd8e63670e14633acfaef17319b195ee2258471ebe0bcf8a1d874da78e867664d2a213981c778e46917652899adea31a429f49311c8d04195b5b2cbe49fea7c83d7a1fd65587f288b23263157acfcb1c25692330388d1f15ca0b880d5e4fe69788ddb67a52cd2e6f41f8da3f91ff09391bbd8952f4237cfefe7adc20e5207a258261bacbecb30c0243b843f9fb96fdccddf627bd730437d19df8d4ef9cd993e95ca922740699a0b287f78b4a3ab837aa6401f4d2d584de962757777603ada045dfc1cd3513b21810f78e9494cc4903085312e2353f04a0e2e5d8f013793a6fc96dda01915c9648ed6993ee85eb01b4292281c5379a9509d6148ea0808fbf6f4a5bf6dab44de766f7392f1c967e5224eb1a32acf08be2d963345001a56c4ba21f94b95cae4e4029eccf483c16cad0345e7fbb0b35c3716575376206da14be54e9bd7e4fb63a10ebbc1cbba9affa2039cba180a1054fd3e6bab4802729d6afe9c0693f2e27feae469b28e557e0987c10f30669347743693c62c5d5cfbc1fd6e752151f2057373c889bb4e138de721a8a9d10cc698a401045bae3586540c8233c78ce9ae06cf3137d4a5cb362fb9bdfba51be148e29c29e5ee3e33c12cb563878135100f66d030d94020f5ec50dd8b7780418ef29a0095a9309b7aa7f897f9565133c817af7e1276d705baed23072e6537b92996cdc2e042ab34b46abd666d0f9b9e5f867aeb32709a6ca9426fef5111b06d563043e47150bc312ddbce7af0e3b67aaac65ed6bb7691a3571eda390f21d8ae5a247e1e05efc160b5ae396d9f23dab3346053ca573bbbe1019bb339d0bafedf9e35b35ba41caf0bc49d39e590e667b4831ca2a9104badbc025208c0d2867c948a1a3b1b23d4d9fe3f33c6d6fac66449331da75dde03366737d740498c041e8f9612514fdf8d40384790e67610eb2b53d872493afc2319b3647c0a20a90af961dc8d9fbc3eed1c438350c9f191a79e5db1caffc0aa1cf50820bba2fbe8dac9be33bd0e8be7e1d61ba40c758411830bd5230295ba92fd53938dc8899ba034aa9c6be31e911f275823fff16576e400e1f9b5960203588a75b92accd6e0d3c0fc6fb071bebd091ccb18a03ea629087e0e17807e6dfeefac15a70141cbaf5649aeb10b2004413429544d05639b7af877cfa513fadffbad597d6e76f717dcf67b66b608da4c70d02fcf1f66a9a8c7a2f38ce7f5875ef82bc328aa2b5d6867e592137790e1e54047ad20522280cac6a0108322ef7bac9c729698b9bbe277c236d8b4b189d83369b3b8df556ec66cfea76ea4def4cfa7754a0b755d745a880e85f70decde49661029185c350c124b6ba358b46f27c0f9b5d9aaf8df4098f75d6b81d482091c582b6ef95b066d8ae685842e3c812983b42b6ff1499f9573bd871a699d5bdad42ec61e176cb4b23b9b17f0c6b3c93f1025c61163af0f6c40c4cbed2e6fe260d522dd56db245895baf58b0fd586b56680f781a271f5b777b61d6eda55a5f227c97b9ff73e703904896a88001500722f24667d524738854ea5e8a01f3ce7ae4a4fa55a251e5ff662019cc955358b804fd7676d18a820797352a1d3c2bbedd66d781d55eac2e966f8b203d42095528cc3c490c2f87fa783ce510669f2c2dd84a4554c9272b4df94448e5c5ed61a36eb75cc2b43fda1346158b2d2559db7e8991f8a08e2a23537e58c1af246dd96e4b2e50eb278a942f2ca2266b5d57dcaff5e939621e68ea0973ca98e5a16b6b2fffe4b543005e6cd06af34475b66438f6949f8d8ca8930b88dd33eebd8c22e0207224b80c4ec88928e4d3580332a3382842c6bc5e015e6c195ff987c7b708b4d030d9c1996d6aeb90188e727dcd51ca7ae71e7c62a8f62fd64d50efebbe2c932eafef6ced8d30859c32b638065fb503f79fbd56c83d8fe8149a50cd0d1bdc1e5675d47887cc8ea452d35992bbcc26f84119e1cb60820414de34b4720700e7f5b63fcfce0ce7c6b896ffce799fafa6eb3d06d4f689b18ff6769cbdf138774f8dc51d73ef02fa141fe2b64ecc7884067156e77e2f7386694d8c60db4bd0dff61d0b8304c6970ce68dfbd8b1e7ac3d8ac5e409760ba4729c65b783999d53712b6a702d6339bf7894ba4be2f5bf4fca92aaf3612de2f845d876476ba695891fb704c47999ae4b99103bf7fb595763fe0e7c2ba93480dfae1c64a24e05b2b0da8ee6004f14e117b4bb753322fa5006273e82367d7349e60f13aa5593b689497d697886413e4daa1692f4b237bee1e705b7ee0c10eb909fd7aeaef161a0b57e9db4d550037312855b5b92d64ab89cdbcbb1a08bd123cd184e2b1427530a50c55461785c2e72bd2a94d3ff1e62a990b5ffae0217de3f83181f2c71ad999e131a30e9c11364136ba11936ad21b4a574051306df3629244b86d1c9e2587a7e6f8da34ce74f9e39567eeb36372418f6e0c6dc4f827216c1303f32a6a3d2a5b5347cd99fa51e55e07bc28f32aa531cfd8da5126722414ed3435a70342196ab554218973c58c350ff68850c22211d9e36ca879e4faad7cb7b96f008ebc8fe36bc1b7bbffed973782ca4db90a2bea84c089708802130c23b32e24502dae0741b791283897ed07b68503ffb0237525d87fd0493b2b307ab187f727ebb08ad94109d3af690c153df59d90cbb5731b38f5b8025acf8943c0dc9d678db7a869a4194d71b00af07c98382b9b7db4dfae50976fc05bf0c9f7e196d4b7065b0075d1f547b65213d874d3f916b04a610e66356077517b8e423cda1d8eca5e331846111673889061706f77845e9abc9d1ddbf94f6a239011aef82ce8acc8be8cbac5c55809206020a94e4f6a2bd3dedb611729f91f487df80a6e5e073d1f82c174fca65bf5dd643f8bdf9b77b6546cc0fe4ee8d0a84b97d71b5bb3521006ef2e8f18b30a326f35096139e7b9dd8e66bf09403ed40477f6093e9d67c698c21d8afd714a2079ce9d0158d13431d1a47da7ae3b5c949a4d53a039ca37ac94ea44661d465cbdfa991d205bafdcfc6c45c0aac68a039b25c5e5fd731750421e37259127306c3b2ef9ddf06b550b8cfdd737d553161fa207fd3d75fa7821a415e93a61663916b88f81287660f53c1ed01ed30201d3c81418822888adfae6926217dc8e3f6fa5d182b6adda03f20d86a55e015dfa05fcae79466fe69c8a470592a45289282635fdb4cc136dab31e6e1111cc8fd378c371c42cd8f0bfe2d4bb9dc182d9a7fd4b883e18d60000e6f8199d1469a8b233629e6f3b752749d6cb7a9bf21f9986701fd67b3b5d8e2bfdc9f882d2bd2cea5bd126fa2151c8c838ff2b0592fbd362ee0b28a4f4c56fc2ff37a3312dd583647078285ccce8fcc273ee463ca892d6f701f67d14cd2f3ea163555594eb1b2d5b3cbafc7fad2aabb19f9846c01cb81e7ab17e4f2e21017a54cd94d856ed751618fd0aae4ad2dac32e95aec74017491849a6eceea5634010094b7b4ef998345de707279ef5d68560a44c728acf9f0a78d8ef24dee6762e587bb8eee389d7a28a2dca1149400a14e4baed611e3db42cf9b7c797490bc1caf370526c7d174457562efb41b566db96bcd355b9a860f66b3519f41e9aa144dc915926dd60fbe3e7c6540a67581cb48b1b455219dd5412d631bde094d9ac8ef4ee15abaeb3f045c982cca316e21926efde1b2da1f0fe0561fc8a326e9d46ea6ca1085ed8d7ec78e65a9141c5acb57667e8ed940052f3dccce09ee6a9fe046e89657b052189297f04d032d0fc8893d1e099b44c8bd609e1db6a45db73b8c8bd67a9b12ebc54102a39d513bef3ba6cb28c9881f06bb373a5825b76d61de142ae65a12b8935b02337e75e002003a4a2f3b87507424cbce9719caa67ded339a3172df115e5d8518dd8e0a292d2a3cd6ec54b204068c251dbfe37eff598c73879aa4ec25c076d07780f735305cb93fee07fde616f60087b2e9e062dc0859113123371f6f8a3f5195b49c35d44c6c6233de0b1e27f0250ccf4bfa385b478fcdaf9c7120c107787078c1e8627292c7b89f29cb0f973a145e7e32dc8d4243e5ee1be7474235617cb60b5014e62c237e0057a0cfb628ce88008f3e7a79d4d83e5bccd4b14f7fe29e8cea4dc7122eb7f13205dcf21abb6e997f5a431f87ab621e1f51f2d3cb2df751e43ba3c2eaf6569a5dda60ca8d955516cebfe354f173988db98a01783cf192386be6d7f78881b6f3747463c68a8d9f9bd942ac6722c32e775c48efc3433540b9c9015750dbbc9f35609037213504255170df100cbd45a596a009d73e45155a5377cbc5ac162222dde19cfda001830e1d82b6de0a8b55f5653e4d44803268e385daa14e646afe5552efb47ce7883b072cc0fe5a7c29913d151a34fc785a40ef2e74ccbc2577d6b599b7f145a73fc687c4d2aeeb24d1d961e620ad900844314cb7bc953932beb903b6e45ffdfa2ceffe5dd27a8e9d98ae102500f7aa4c71929644206b49cc922c46596544059ed1531d00893a3e38b55d0d2b5812ad1796619a0de92db6319a95ff749adee806122811696ca90e13abdc381a49db02941780f92094a19e6daf733604f6e8b147e3eefb16f05187f4e6f2fa7b90889f804458899c42262cace0754add05d04006e63a6879a13b8e0237e8ac4ba10fe368add093b7d376b0ababc544822cb7a7c716500277febc3f0eab4b551ec7bc6ffe4acc6538b2de528024823fa2da9c3ac3216ed87362fa084701b0acd9607fd27015ce91252ff352402d08b6675a43584c69b4de98539b7d1d2b684044f5f8e19f67ef3171afe0487aadcae4bdd3c0986fd6cd2db79fd11234e68046ad1feaa03afebeb9cb5f12379d633ee4d2a14d1f9e2d87e73a62c175ad06eedfdebfc559e73be8a8bb7837d79711eac1fc24ca594c6c078523647094e45a31767a1dbeddf6a4c210835519d45cb8309110d6409d66b675afdb83cf3e49c45a6b46e887df8026f242a5f45a0243c857bc2eba4141777ccf817c2fd3b5eaa0226ffdd1edfdd90cbc4eb0565f96d60a7d3c83ea70dbe5f05a18b8fe8e9ae30b99950fa537246d65da13e5ddd12485428f1f1e1c43962b81d450ba5928754e4f2ebd935dda610e1efd39f756c52e5fa43a7ec7f888e6a2969c27bcc2d03206805a15e09f9f2e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
