<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a2dc1ab215af5a8e66131cc1b540120355174acfa770b19eb94c00fc3ff4a79669328093dfd33d89c6c219796397530275754d31fb962957ef0e84171c662825af32c2c4aa5ae6ab0478a5d6f474867762a4dc46b893aa891633f9e10913c00be5c7c5a829af34279223c67cd54958196e119221be9e62852a80a8b8039e1d5d8d9c96063e5f782f82916f418eb500673893424f07c00486bdbb0f5c820b5ea93d87504a641f3785fe087ce5caa87d9b35b6847a70995d4f63adac61d521d50ae2ad0c6e34755c60ae270fba6386c2f427d4c03c22499e2f332f726cada0344b8fa0531894f9013f0459514707dd7da1898e154db0c8224226b41cbb180c63147634fda0f19357295e22a70dd1d69554f1ad096cc7d4e45035a32856d3376f0b45de8ca5f7823354eb05cdba6c53f6e74fe72d9c84fc7a595efcf37a5a29baec5151b55a374ccbd61340bbb2dee20b90c92313afa8b259bae99743be64421846495c5aff24113affd00b968fab0f3d663c1101f2c51173eaaf06220fe9ebc4ab4515a4308374ee9b1d03f72eab681ec4c5db6073c07b74a39fb64426fd0206a727f9b680016f840d9d61634e86b9d32a8ddc2744accbc0bb58dc7e3a4932396f10ccf7c262bb35c5fabb85e179162188fd29c2cc4b24dfc62efceb935575a76f5ceef69b01142572cc43b044ccaa96df7cd8b8136ed06fea9406dc7da4e939ecb173f8b73c0b5e1e2d08c6ae9b58350827365ba70b2904729f8f607f2546298480ab348240049b49d8a471927fb57523a1aa2cdec3d58f23a3a53628bc58d523c7b5cb56cfc87b88847df8d74a7a55d31aeb267da80908895764e54491ccea3e082b099d1b96eef20762091c4f6f2e5bd7c1b1ed2e07fffad54c685bd580f8307be7c1d39edd68a4023221f4c6e25b2a35105c6b286fd3c880f28006689dfb63a34e2c0e3f221cf6f56e748f8e0fba1515badb4dd431bea6547a21322825a92b2dc8f9673906f2df2fbc131e8bc15f39a07a7332006d73a99f621255e845591ad2881b92707db0d0503f18de5a24a8c76ea1dc532fdd2c674f59558fe51e73a25086a7b82b7abfbf0c4523755d9bb85ba05b9903065eecbe7a860906105b52562a011575d029936edbf09e1b270ddffe7f910f0a631e0ae4aef2f9956486dcb2a216db5ae69f754bfe0a240ac64cd4c0d29d03845d433819988c34414b03945f7257081c771756495bc9120f01c8208cec3076b0bccbe4f5bbac66c5d8acdee90d529d28a6b2a3a2616b1cc47f21655cb98ef3e3452009781ae332da5ee7539ba16befa21046b4bc8b7ed056f328c06d4b1029149b32d16d97a70c9d0c75497dcc3212245d1d9814e974a93852f8ab1ce6e075d45f84d2889334517c374a9be31690f140a38f36b432272c9fd3c2d167c087fe2c441646e7881293dd9f5513d47cba2a2750d1453ddf3a80473b4d42c1d555fe3c225f5a032aec7ac3a9786170c4df7f27ac5274be80b60b983c30b91b449b6226619986885881dc31ec6575d2f05d85a4b7d587becb70d0259634d4b8faa8a51e0c0e1dd731aa2a048813daf982598561722c6988f5c692232a8b4327acadcfd01014b265fef6181dc8a077f91b22e54d57c8ea5446dc9a622d4bf0368251c9d7968d47bee086d241bd08754691e5ab409aab0b29b7e9bde6c320345fc3bba0f5e92bbe553a1962eef6bfd9453ea95c27c99ddd7cda48b9dad0665d132465833232634c6d519c84e7058b562e40275136b8cda4a93dea5991c7e0779e076fd4a2bcd76b137e711b2ae960d3765f691c0aab3ca7398aaf73fdce67372b3735948c66c320d5386d435bfb57fbdca72e90a1702f6770318c71aaaf9ea906d3d9df35f499827b126dd3d2775307569c837ee0326241e614582187c5de64adf5ef164296a719c237e235876d9ecfde81e3ab6e49521c088f26e585097e92c6b941e9ccf4439de6ba2dd3d1bd5190aeb1a219dcafe32857f22fdc626e2408336199b7d9047f7ee2075bf8d57b425eec812dd21691c2d7bbc303954fc883cc88b1ec78fb45140b3cfe2a9daabef17fc5ca76ebf38fa588d13620f0b3c83764a6f06203f8391a8c4dde124607fbe0b084e953fd6623d90489a6f640e2d90abc302d18839cf2c2c74a7e0665570fab227faf00f0ac469e263004efcad9b4af71ef3071dde213ce5b642a8d756a888dd7aa8028ec77b1d98c1f3843dfbaca8577a0df514e51208fd316fb68de3912f85201534e5fde6e34ae7965a13e8c08e0d0e0bd73f212e2f9ecd6f83ffd1f258ddbc65ed328824ad37b2a38318fe0721d0fa75e78206b4169b452f9bf0e4c4f725e8192574357ada814b29d3018725154862ecd9b0c408952d415278dc074e836c4bf829f536ec578ad4dc3b9111dbc5daf45ea18ed8f22904920f520045dd0066dbf926015a6c7c54e360b47329443b471d776557c41cd6c201b0874189711ad5a85df26b3bf1bc01bbd5e3b275bd0fd3b3d18d7c33bbeb86bbed6d6b6c81ea9f17658fba66fcba1d53400cbe3be7d009ce06006e39c4fc093482380eafaa8baed83e31cd4a51f27cdfe1e2fdc9549bb8b12a4bcaca69073147ac2b7b73b5bc456e27528851f9b391a1e74c97f75a41026f2d19a3ffb067ad6a18a6bb09412130521e2803e6ab89391e39cac87b0cb6d3892a2c201bf4e2a9bd8de4f21fafa88a02c3a301057a66c5331584b2f0c38377f3815e259f6bea983360c66d0a201be8c959cc3dafa8041ed8a7caeb777a05cdc7c67f2ebf929d4f1e361f2318f441b0e4fa1a7be0c18cf86e2fa3b323aad06aaae17afeb1fe4c78dd89d76bb585174783f6de9cec8f9fdd42f3a34624419d63ec74d6ac7eb47f120e8f86b9f6c3ea8f79ed7a96554ce3dd0b6015de59f26e10bad9040f4b560c09038fa717b9a7f84eb8335c2ef625ac672f52b8a987621105ee650268bda43cca86e559cf064a004c3d81891793d1988193ef12e3462727c7fcfc801d3c9e69234fa3c34d911a6dfdbce85d97388cfbdd0c6a4042a86a51838f065066bd630f8e1c556376ef5ac89a9d42d38b1939b7cad6fc6468decdc3c5cd11833cc2f3b4ff0e002499df02cea757b97a04fffabfaa267db9e5ef9d750e6ade60db39e08d445288cb60bf006cfd5bd6b2e45a4da467377ad8bdd4a281739a038c5e344c057ae4d4df43519e202485c9e77c7c6a5491b09161419d8454d4762170b7be654b17d75177e86d087c6a909ff8ee90eed56c03211e0e922fe0e50ab012b31f924e2211e69a68ff2cc641af13ef266f27ba9d65f7c4cd84a97de47e7ace1416ddfd79275bdf8a2541dd2c170a75a2c09e919a09c152806f18bcb031ed1125b2c04885d49af4b653b49ceb18217306eff72f4c3cae046fc198ff41b5ee3d18a83d1d3d6dd27c0db898fc2f9b95fa4b58d0db8339a7b463ff0eab1ffa91fa6db49dc95712c0bc227c15bcb5bda5a8e25d01709b576a4953900c0cc3b345da32b4471dbdb7699da7ec32a021399c5993463a05f6127a35fd446fc3b32f6508157290480974863a8dbcec2f28f253b34add945904af30e8a61496ed6ae5bdcb60b04159ccab8951da89bb43f27f1c80494bdffb8cdc27732f4b4aa371d1a3ceb4c3ea0c8f183bee16815f6d12a9d8c079cdfef16bb6691d99d73c2e1174a343abd456a3654ed474cea5a34490f2d7c6523bbd7ca854d096cf99ad44515d47653b1a9f3e581e2915059b2814b48f5e32455eb7db82ca6103b7797464291bbc2e3a8814411baf5c01882fe7e466d3c1e8acc0eb8d534b8e9790dd29dd455db63d3e5e066b260f2e64803346bba9dbf4fb274800e8ffaa9cf7ac20a10898579678d4ae60494f1df82072d0afa5843d8a5909add53ee3094a0ec9e7fc815305e304f7f1a5d9892802ead2991906fdec20b5908cc8d17a16fc7c91c2c51f5b6393ce625d7a8bedf06ff75e512e6c02e0d5a5c42bb7232431d3aab91681a560ce5c0499bd62068b82717c8a3fc80677a0ec578dcb4ecf047fcf3544a012aa533d70fb3c0c173080587c9abd3470c56fdbaf364875632becacd3fbd831d066c19517ca9eece444633d0664eb93c7155445807320f7df67acfbe9af9fa0ad68accb2695e33b534f34998ff8c3d9800f9074ed21a84ba34ab513be404b4189189295a1ed3ce542f3a0fa8ad6a20bb8fdfd4e0c13c630763ae9871e3b995a421472b67c46a6055e8cb02f42e92744933d5f3e92b802660f7ba2b1e71f7d5c73cc1672343e7627878f8fefd13b943295f070f9e882778c40bec1b1d581b1f91963eb7a01e452ca391e1c9627ec38fc16a6cd17d7a3157561392f2577d59b9ec4f9bff1a0375a3f381ce5503a7d461f25deb8821e7ebb692d96c4ca7779dc6c600686e9f2edc4291028eda7df58afd88edfeabceef37668902657d3d7235fb573bed85ed4f9f9450272a5102691097f5810f979ba40e08c50a8e4d774bab88369078dbc55d7ccc14c15c98f0be831e6a17913cacb77943fc54e9c5bdc8a2917ad574af5eae9c06228a28095d2207d38489f677cc03a69acbf216479608fed07e3b6f2a2384ee73711ce3cf97c13e9b38c85be050590ceb25331b1a2e31e756365b7f7c42b19f387c9271d0315a8eb2051bb8abcb0d2902904f9b37b0b9ebd04c8c6a3e33b323b78d9d5a100f3c1f396bce2e9921de9003cee6b4391e5a2a817827db580b35534503cd268dfaf1583ef0d2a675347ac7885446d1c9ee23447e2a1341f2d4adf0754156dafbc4da81a310306fda0857b95d229b0e63f110acbdc794c2e4ea836dacb7310592cdac01b3adeb1c1f48e86f0a51ca42a7df3e6b2d23643123671bca448ab31e49aa33ac38989dad6b7698d9f844016e45fdd3e9bc0ba54f74d4e0648ec7c7bc57ed5639ab9cb1b046a58eb183fbed875a197bc1d09ff07a3f0a0f2d82536bcc8c9a89f7b36257ffa9e3b98e15adbc1ca601151bb084924e657a59409631b4c4d4e755d0910abcc10c4c1af33835f5fd0b8f29920e59d7ab7274ae315e2b602dddb34639dcad34eb27991e81b9be443fa96a110526217fc0a0a0d901e0039453d8ad849d58b2e673451448b8cc83a848e95be283ec325c60e4a2aac3a738e6908e04a975cef0cf7387cd9141fd99df1b152f7045c97c1382418e4bb1a576dd43509ff39fda531e7df947c8fda908dd10dee9dbc63f1b83a89335fcc8bf514b6c8be367ce4879170f950c8447e3679e5ec04574885d6734c5ebcdd64127620b0603c528c85bf14196b1bbd286f8e41961c3d073ace5c2780ca1402986a7e55352cc17bc97c6500d1b2278e3349f67b1c2312c9eb4e2c423276b532c5ce3869d493857e59c703bb9c0bd30a708386d77add5507fcc0bc0369453f3f83896971d8aed7470c9b4254b898dc182c53294e54e87855960aeba4a1a0dfd785ed225b267da6ce70e49850b8d048e56a51863ca872d0b868807d8132fe488f37488c6bf3ad9c1323a43aaa6655f70e1ea93a0593b0f8c2fd54b31cba4c9d155922bebcb3a7bda653221764dccadb5ddc28620c977e1facedd07af411cb6c921c9ba72309f5e8a0a84aaee29141505f8453ce68b2dd2b25d5c382ec6b9e1d3c7c45d983af9dcfcc929ecbb88bd76a1c196bfdf92bbac0c97b04c87aa6098f4ca677444e3ae4b2fa1556428c6bb129b6f06dd3cba6c0c6b5a89846545e51a40cdc76ca4fa87a6c11be08e8c4e8fc0471cd5fb2eec0e148f8dc0f9434983f655ac7bcbf61ce56b9f761c8834334fb18be7dbbc71f0cc6ab03967c0ec661ec35d7c6150bf1922e00eb32eed8855648935e12afa08f6f022e148155021e2e0f39c5acbf0d1dbcf8e3372b010843082ef7d0b6bf690c0fd675abcbcbeb258966e7dc60c9093319d83205daabd90dda788d232eb7b9094f6b8807f7040c7cf4fd107ebd06e92d3503d14986e3bd21738ad5a613576d6a9baf17182720fea172a27676b5cacedaa23ced10f6fb0101069cabdd77b6ac98d7f1c720599059c4f13913678743f3a9ae394c961d23eb6b36f9e688cec7e6d35fdcb90d02d5d5933f6c496c88dff5142cf15c425755aad92bfa0b12e142bea4bde9913572ff2c18f93539feb6366bac03f75a54d8ee702baf2717503e0934bd365b505ebfabb88a71c08eabf585f482a1bd52724a19f760a0f6146b6b34140b801624a7904b4f702e629e411a7d73dc446f7eba9bec45657e4bd58096a1f74c9c772b63750619ae6e0094b0c048478c1cbaaa7c496cc061be16a34b0b3571a30fb81ba747980f2a8029a67badf0659852f2d11e0b2f3f64a96f0f2feec4cf49863fa21eb1cd91012e7489332c2b4a203b2b8f51db0a13914d9946944073e54939dc2a733c36ae182e8c3999e461df50986c5a6f52d2b3520442f214933140291c0484817953a789c6eb295954d37dd63fccd2783f03972ee6333071a306b561e365bdbe5127d7ebf343ab3897bcc14975239279fa9bcfa9a830a1ebc92f80f2814fffd6c0464afcd8b09f080624ab75ac4df2a35e0fbfd14a1bff38583f2319144991dd5a618619cd51d71501bc5a7c1f871935143de41f80ec8d72e9f249639e6607a55befae5aec9df0a93d54c8fcf42409721254000b71e39c9abe47a2a37bbe3ef7616129ed4555bc8e560efef8529d72929246694f2d24bf0b23b899143f2e8544493c6e491df369b9b40b66f9ad77059b0df7c319bf2074fce15971b96debc73a4aed21fb15833522ffc97bde661f8822ba9dabca15d48da56679e830b5cb1719a64dde7677851ee854dd10f4e8516d258ab7c7c11fe36fca2f6f760b6d3bfa85c82ba28819d3b69ab0c79ce2788793c00f6440aa58c1a667cb1b37fff2d7841baa8ffb3c913378f4176dc23caea88155fa3768b8e5565082cef1258cdadfa8aa7e097584d66d1efcb5aeac4a3495abffda97f8c62a9b4df28b40e4c61cd8562237e395a398bd8876634b9ee05662c0fb5b8e8a79362a4ad14e0e767ade8bdfe03f40d1b4665c963cc62b8c9019b6ccc5188dd1bc527bc96f9ef254e6fc7693eca18ec727a5c04b639ec2acd5ce15c71ffb8470a93ae1971109f98ebd3b4bf53213d1572e1ee60b4dbacca3937477a4844c6f93b0b8be2fcbc0df9733abaf8c3d1c5476919d1dccabbe7d24d55606d431c0a59cb82f401cd5a5f113f9916b59e2d0a68fe6ca272867321435923f3c8326db40eed4d94471d0d4a3308a3104104bd11cb18f8480a6f2a9d96d89665a96e5d39a68b5c3736f9ac8985802f9bf567595436e86d0611f975c89e505548c6e02cf1e69f5ccbf39c85cb9c9da13d00cea1138f6c89785a7367ab98f378d7d17ab0389a2377e28461052d247f13507bf88b3ca711beca587b93ec72ceb64e5c8a6a51a172ff659ca2ae4244edf37aa1e8cff00b16628bb7777c221cf05e5771934f5675df8c85967628f6372584e7172fa1a532240d8285385306ab8c240bf06c732a9ab7041b06ea2bd4d7f9f239ad8b3b04e0dd06bf58462f8b5c6a6063940cd559ed5e1ccf372dbe7bfe98ad9daae5d13fe8b1642363a056ab212b93c69554f7d26d34ce6c12aec89b1230ba2ee4cf045e4983c403b5cd9f6f9f173091ed4b3fda2d22976569dd3368188405f31bd837c1284c9f60256f518f952bc2c931bb91328635ad71719db6f4c6ee6e5fbec075ed5b602bf4ffde6abc758772aabd5f100381986a6c49359ec2ea378f589c1686d3db527b8c7344228f13d397b7ed625ffd82c317c7e58145dde4cba63eea4a5db028a8daccc17909974fe5576768cf315b4aa83e158380145d29f66326030a74e4fef17c7a48fec4b7501624b109faad309ac88d395cbb73ff8033cbead9ba4cb70d9cb2a14fd46049245e848fc4f7a0ade8a587f9ff538f9843002e9442411402cb1f34410598ed8db5ba93a96bf9ad0a209db0848a7485b265f2e20887355a7f1429e135b73a55aef4012987b345bace227b6fdd11c2f0e54c47bb89906b08357824d86fac9f15e01d7f4a318c86570e84b12868607068f9ce622e4956661912234c024688ff9b112aef83cf6111212f2e939ba0dfb71a26c05add490f056561eac536a3c29baad850f4d07764bf7171ae9c2781f3114fe727ca190aca2a2a636d4057155b8f642eff15d6d55db6aa2b335a81f86f38cddce94fc7b9dfde18068312bad605c4618e423ae63975f5dc6ae1bf3f28b057222b8e35b259721b8b0edead6ae887e43d080a8ab3e432b0f535b4b524a25d6c4c5a745e4acf17be469ee17e75985f965a4c1a40d8fbc282362d77b6d00ae4f6c0ec84e9da86e8e7b59bd6552eb4f08fc80078e9d9bd884ab655f6215b7033741f2a763ecf3e0cc7b6dcb292916d333d842bc4c73df2d0a7b683443f00e7d2491fc1da6e92ba1ac30bb68c6926c533b960a98c1664d905236b41b7aa4e9c4d417ae06da74866f56fd59fa208e424a83d2847ed1e755b36cf4a9aaf702bc000adf429136ca0745376fb5f5ee5f8558102938b93a817becbec9a9045cfb6db371fc56d74fbf3f50b7bbf09813bd029f234c969525b893cde6925ffc78587b2d9cc7656bbeb6c2ca93c92744559a994a42dbbc423ac8511788615e8f914ca045b5a5c31f5db697f48a1185498a0cf6e26e75962373f4aa21177f56e872f4401fdb808d98b022bfd02b0c2eefca40c8bca3314295ebf038ad6431bdc6e7f1d6ff03ec5dd8b57aa1bbc51379da4c2f50e47d3b8fdfa5e52ebd34920362afae16524d088cec5ff1658fb48d4812358e686ece0ae2291ce029feb70e23efe4185adfe0a906d0ec229e2b9474227620f0e34e031903feefed418c605becd0f1b7ae7344138988d59af26d1560a937912f17ba474c32df585f84975a68830771085049beb061842ab1d6581cc961c5004251b456df40d49d3f77838e921b5ff70dce8087fd78d19911e9522c6e8a0a0a60dd0354e884f6c0be0c0b31482a89146c55b2c19231419f3808f280c005d7525de0b50e12ca3d6b249006232330a434e3cf67871337fffaa8ab15c985d36f3cfd12874955a0924f62acddc19d7ccc72433af2fc1c5663f8ec37738a52bb86e900f44a36d85f2eef958fd688294fc2364c6a3849e8ec3ccdabf068a6ee8671ccc667493f46e5856bd100b0fe2eb73e7a71a666d3014abe3b86d34c6e01950ce88d39afbd411b62e1bee63f748be1e26573f0c6de85c3f6995414555029698e9571da5cc92debce09286ea80129b0b4ebe1417ad374a8182a95ed9f45252602d08e5a02068823a535cd86b3fd5b50c4627dd2b459a37110a3e5615957702873ae2d4450926390e033e0b80744ce7f39e479e99983308ce42bb67ba85f2a74df8d6f6cd5aa01aab5960310707bf8081ac44f8b12f344bff1c8e3d95a34dc4a6f307dc9becdc8652c2be0f65c54a48c6c1a1cd50ce57638bcf7ad8802ae66283a529d988e7f79e06d5d23e3178e53b3537535d4de31dae7b84f411a7af9e1f64ab206dd3447a9fa4b90e63a79944f32cb8665585620808ec0310c415853ec726db8352b56c65b2981edf254845a1d4faf14ca895f18e592ca813a8b92b200f4fa5cb736a1c13166ac0617fa48a8043d0a82c7359cbabe6e133bfd171626fd89f791d0ce9b9f9fc1227509db64016456f1ed070c6f53bf6d3eed6ecb05f6f84655da3eddf9ec5973ad1b5831c983f2a7ee8e8e8ebd672c25fc7493159b19b42f7d6f4eca7fa4eacc6b5a0828b3b2b964cc3fc6c32066d340f01495c09d70df0ec1deac683cefd9f77ed107fd7c8ae8401d3b70059d0f1b909077cfaded00ba640eb44582ab3f1d805635e4be90f2a57bbc4664c6a733964b1f3ec29326148d661ea24b8a3c8a31233bafc485a2cbb1846c98e6680ebd23f58ea6db1b136d2264e67bc3445f33267d9680a6241fd04f0203e26c1ae803ce10c033c1f07eb8974a652d5a666bb5ef892ac721afc09be46b20c5202fd7ea7e4a00a8fc66ca5d3fe1581092dbc2e1820cab50aab0d2db0374f59ee36fe01dd8f62fdfc800c1f0b9fa02178bf9d0100b4521c34504f71c6b26e1928a498120dee3b9ce70139dfea805c84d31c6513dd38fe37068b8b7919df74de89a5cc49713e8db62cec590adea49f4c2b64b4082e0083eb681564049b2b2abed36253f24a94bc804eeda90691697b56158146ce52738b7367dda87255153c24c0d5a2718e43a18fc26bd7c464f609eab2887fc5965233e0d53f474c170445c08f76e8e1a80e0f0af466281a53af4cff729ec480095380cea91fad2fb0597d00b2673e319a3674110f157062e30460f99043780c1b0c317896ce170944a8e782954b13d72bf7596a8d5de3af3f4296f41f901f772f8ae907cea19ddf314a80c46e4d2ff17e51be746d4f379587285d15170d6c405ac1f4e3f7711dfcbfbe7c269c97dd33345c6dec56f99f92d8517166cb24e1f134f3356acef91b87e49b50668414e7f172c724721d15e6ecfcb0b6c61ad33bb51b861776bdbb600014c8a1c3e24e3b6b0e9644cd1e3a61410580434e87caccf377bfaacd4df9d4a5faa5136b7e4cbde7da29aa00eaa2b792e6c527bec93fe1fbccae1b08be742bddf9969679af70b913aeda34c8c01fccf1c35e5bb5f41bd4ba29127e0d2c0a66be0539f2985f39aafe441f7e2fe693a4253f6451cc31c83719f072a5c7e3a2eb78fb3fa6da706401eff67d6acd5469a101632f3ed03c85d57061e6ce8b1d279a457efd92f764387c8ba3a67a34c46857e939e2be98cb296ecf4b8135df82fb308056bb252947107eae7d19cf109496409d846de5e566e7e3e6ad12ac4f5155591d336d99e0a44145d764c799426d243314756730ac1baa13924bd28541890ceb1abb57a137e0f0496fae6dcc283b0662e4288b8e0e6d246a07c9e760daaf83f8d60e6f02eba3c15633213ea40ae38aaf28baa532bb92e3a3abf9f08351cc98e002c05c4a40cc1f555a31f36945651dfc3c434f53c55cfd8f8ee0490f7eec545ec6562da75b15837e037a02ae8222bc49e37649a023238d362a7a75080ffae7a5c489a7ce9c46a369078a4593c75e34354f05de5fa2e31d094fcea55b829145de4a18f2b32176e0712946ad5fe32b3b6f036c76d4eec6100bc7284f4dd56aeb27fd60df807e3e558caefe99085068a8e8bf1bd4db241c8e6f2c8a311f37887916fb450eabf5bc39a59a2bd37038deced8c029ce15c12521f6f904cc218fa6232ce57d8535c3405bda66fec31699c105add977e79b1907f8bcb01504bc11b0273f3fe6a358adf3858aac6eaf7aa143e578431aa0cceb4b393373145a9f4e39f59e8b143e3e14f379cab6d6748e91c4e1766607bf023c87a95776eba86f7393213c4d992675ab1726bc4d98ed46e4de835c899e69ff4c129c46452165aef5352c6627498fc4f6c779df7a0b5cb801afe887da0be5b8c51d84f1a2287da358f2423cad6ce07e0e3439f53e441f57e02f69cf7dea1a6bec83a453364cf9a2d7f62f31f27d8a37c0e85575dae51f5a7f049f0f113e2a82ca02885c0214c430aea8d97753f197f9859f83605dd50c675019f3b09b59fba285ed759e12f8d848c2fe260a02c2d5cf099587ecad6f6495000c35b6ff48392f6424b6214ce8327aa23c3aad6137b645e40253106de26dad766c99d5d772dabc1770e879e2fd112ab6990bebebaa7f8a9187d2d3dc53d5f58dfea3269d1a7723d2403f79dafd635f7e4113a43b1bd9d02a448036ead4ee194771b6ffadf991804e953519a84427ab8d404c41e49321e76dc23dd3925d2d63342daf1d788588b35ab97db493a50e70eaad0bd928dab8a1934a0b91b831604f5290b86e42b1883c606b7e1022c7e6b04216a78d4675161d51665229625906acbbfe49c47a536d231a688c2bd5ddd0f5d74839ac3c8db24fadea4239d1221c7f63baefe316ff3f4fbfc0653c0e6a87ef0a9fa7888b086c65e15c743d43520977810305bb823eef9c9c1dc7e348883cdbfa466bf22e9e8b0958801298e2685d2b14ed512fb2892ab8210f5f32ce9c4dec0972601ffcd3022cd6f8c82b7972b9e1af20e6957cc172e7c66bb9703227d44e4a05d2e5f316ce02faa6b2b8758a11cca9ebec51b6f6c45976345aa4af84a77495dfb9eb3b3644e1937fe5ad5304c708e8d1110991c735d319a38738a1ac6302ff37454ddcfd16fa59750217df670248e98677a5334ba160890ad07576b20a763a1440556eafd85de13d3bbefd078a587ae8b485f0df1dd4be76f37defbca064f53cfdf6a41d48dee3080e50ac46673ea09f49e60ecb30b5731dd6800f398e60b0fd0da4702780bb42d18d9d7fbe6d7f559fd17d47d3c11609e2a6c0e2602adbb2d35f931d4a43a64daecd809e0589a4b0cf38d1613068ed3620c404857a0273cd26691d160867fcb6d3541fc65196d6a7d83300b979574a904843d129bf8d747695aec57a464b36dc4c0e6d8e319094e8bbbf40352e9a33f5fed25097e53df9574f34d65856990011e8e0c25a18ddca2871fa0a63c9bb47a771a2387b1b8a145149f4595344daac71ccc8ac97d367316e6bfa9c9556e67c89018d34e0f1da3f05cedb53ec71c5408d6b684182976e6c62636e48afcaec19bf841cab0ed28688c31d767bc44271ba6736fabfdef5e25c2b54c79e02931b74b95579ea9ec19d4788304c69eabfaceccd9cfc74b56e2c015c095f8fc0575e57f66d3955000c740d6fd793f9b6ba8262733697148587cc2e6399eb1ef16f04f7f281aa1744e29be256bc1a79c458b14a8c93f03611c75936d2f6822a31f96a3fd7ac1d21a800ce7d87764c8e97cc7337a2993656f747c773f099805cbbfab214c69e2a28657982cfbb8686bfd699cd180abbaf43919d270f029fcd13b5116a4463eb7a6700eb2948a92c00c2b22d1867dceb5c832216d30221a607019bad3c1edc483dc7043851b24b77084ef6ea7320eeb0a1c2f835f3e043334c55ca84c766712c0cc22950e85dcf5235e429c0d0b28635e8ebb7c1f79c77ae303614f2f843582c63923fc214c3a584fa38eb1222bb0e63fef06d39fbd794e5b971276ad2ccc9d6e53e64af7b2a13aa0a5cfefa7146819f1357c143bc1371b667fb5bcaca1a2286e5026440d8a33d5397653e40999b25adb7fcf6b5837156c56ab4eee4af4af86ecb29a55565f8f0c69ec7a63910dbea2bafbe6655095da08bd6114dd8e113195088acad369e6c47616ffda0350d0dfa391570e239a7a801ff474372aed20149d497eea17bcc1fc33faaf028aba5824e4ce1c859e7a08f2d4388eed152b6e18cac114ad669b18cc9232dc08f81a9924d175eb343198af9e6d6c861be5325347ac4df3ff98fa4e472e2a924515b1263650f45eda67fe1eab52d7ba89f53e3043ea5a7631ac2af969e7abd34616b1caccd2c0e0bcf7b3dfde270154bc9cf295611218b6d4f42f62cce6d5b2ef5917e88919f9e5060adfa9218d7cc06ba153e8cb4bab43bc6fbe2e2431880f02f0b124e088ec053d6d0aba160b017fdf86c0035459f732fc4e339c4fe81ff85326337508358f3bc152ef210bba361f8be1e025e5c366369913c2122b2e977d29dd892c7b63c6531847e7b7d9228eab4f2aa5bf7e1a91066aadaaa023e68db4954162751e96781399fb100f3727e6ad3f1a0430b72eb799877b298d96e008a45a25c70964bc0115d95e0ad7cfd76faa4c88c3bd9c84de0eea653a36850424481bebf13f1a7d2ac1d1765a82a100c200491b916d559647e5330cc76a30d7d4f6466c6a98e52ec533580edb22361641115c269b62492f075ade9da6d2e9120d671d28c5a28666d001ac39","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
