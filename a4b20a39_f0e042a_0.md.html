<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8aa783473162d07d59c38a8420cd9983508593a311105616eec528fc284c2765afd9dc09a9835364ac02d5b67045413e4279f081ab2965a2cd1c8438991ff79c64ecb2ae3166ef877b7380873816da03ad952f037dcb5627123b6895c2aac296e44b0f1d70728cfa27511751fdc827bd0b4c2a308587bbcc9e1939f887ab2850a07c4c21c46fb8f488ee76d60d17b90c504e73ddd209b57b760e70667027e8b5ec9ee49be3c0140605982cb439f164e2396241428dc4c6cb552c336addb5833debd255a621aa966b42dd5e58491507f5e59568a0ea43d27516d903af7503d0562773bafb32c0bc11df66cde64ece567c83cd96bf28d10bca47afa73bd7d21b5d8209311df6992fe371e8ba859da03d2088434dc96b29898a10a51f8396377a022dc4847b4650f24b9f7f7fb46ec151dc9ef3791c895b98e01062284632fd36f5cfea0840a96e95502981781e957e6243f5cabc983ce5968fbd7c4644fa32678d9ed84d2518f59c77ede58421bb10a18219fd3c5aaae98658778ec2ac720bbe0a22c0bffa8c38a308f873d97e6ca6aa8c905b847e00c9a4a880e2028100d52e2a692378af0ed4e75092ff87d8389abdc7deef0aef4ba1b9c0008e729f75e53b2061751f9600c96a5cabb397ccee721359100fd1468c20cb36ae99b16a2d5528ae29010bacf5b625b5cfc2b8bde5c9673a77d7b4d62f88ecb4bb20fa5cd9b7def1e2685ca94b96afffc07d6c9efa0b2b26e835f4cfd4db39dd3907ea95a2d783cbbc882910fe655e472009f540fa5953f3ab76c02dbd2511daeb03006e8757f27f01c6dc665bca915efb2d28d29c2a8f650afa3aa1317db3de87e7743e9f82a2db77c9a749ff685af04a7c970c9ce8895ca637778a8d004aca7be5e70cdb5ca2177a5b82595a095a296f8d35c1f1721df9f0ac35c65c3d291a56fcbe317054eae6a6b82f9a1b101dba36431416ba976aaf78d209e9820bbbe4d055748eed59c711d0d43da3db4571c396e008aa43526c407f466ad2e15de91adf775e250757266f7397ee3424c2185a60b89b1b64bdf00c06c8fcd4497184e4b3c6d6c0579f87fb38c3021201457662fbe719303d2a67ee5d8e65118b0a15b245b7d5bb3d3f4d9c671ff5819a9a9bacf1b3af1e1601e371215ccb3499e389196b714f6a4ca86236aa2b62c98e651bb78e212159b7874045367c052bd51fd5d34269327199af16a4152d9f656d3ba3ad85b1424102245e3b0c7d25b995b7295bfa1e8c3c121b4a3bb2655a700111b5a5e8145393fd4899f5961cf139142c0d9a9970142e1150c442a09a0e4802b11f8864078463c6088c274e44298ce74c614c7d02b414c36f8aba1051f338807140512e0cec0a033535a96bf798ba9eea4aaef09b6a8f38277ec1b9732545308e227ecc318db34f027fb7e620afab69c841cb42866afcb87efbc3d946b66218ef4ae7603e9591cdc9fddd5165962187f5cfb511ad679bac6359913b49547cd0a1c37999a0f704709c03dddffc448f6cdd1234577197f9a228a66c885f8e308b20a0f5f7408a6bd4dca1ec6b95041f48f32e1abae888d83619b2674e7e95b752a4db52da7a4eb69128f7e932e9c66e7cdb2ad488a99f94a3eef557684773d1acd105b70c98bd7341f37d6ba2402590ec563aefcb6e5e9d04fbb08b044425f3ad1c6272d4291bb9730515be9a77238a32e0c90b8c947f14aef10d9ad7cb6758b164e8d16b60c53c96c72b82a8eb20e4d8464d15ee4268180746b30c07c41fe73dbd60b5c932186dd7f267b99ebaf8288f8b151d299fb7e399eec5d87301d68d30b1271e1d8f684a811a585ac8199688f6b480a4ad4deecf4d41dd07aab229b6c296dbc481503ac9d64bd77a99c04865a64cac88563111ca6230c42e6f21be27c713047d9003b62a4dd0043a1781ac70bc9a1dbcbb3bcdd66044fa51aea6c33ff22e47598de433444576c023dfcb6b58c71b281142e3409e02b39bcd9216073f51b88c8cdbaf85499e320612eee166bf2556b55360139e0342213d2ac92af37196dd4e6ef673d0ef5a2dcf7603920f98c03d7b951cfc95806225cceccc56f6e375d3713078ac2ca7ab48ae8c4422cbc33e20bacfd89e4988c56cd9048d786a1b50f6ffde8ff43d7669ba4e9e6827a7af05e4c9b2efa01c105d5e57bcc9e22631f8c635ea48aafda97b3d83fbc29af7ce71a1358431585b3e11423a8292e0f04ca7cf184ab6b28e70f3d5d253f877e5be5092e26410397ee11a1bd7931b4eef1dbecf8d801e7a0f3a0eeb023128c09a2c930d9f1a61040d22f9cd62056ed6fdec9b6a75c1b89b3bfab9dcae8ca669a5c3ed10cb15d300da8b47c91756a465d595fe3e1a3dee9fd94b3be83fdf673dc2abfde6ac6d40ea9679eff318beebda60af9ac8d542af28714ea5453ada31267911f03280007fa0f2c0afa0d4b197363217f47afb50683bf3978109e6e92940d2d7d0a0994e984131badb761ac966dd900556e5690b6a89a468440e536ef8ed06c0021265e42f56ddb7d0b864224a111b69762389aca68b1ecf54463d5d876deb655785bb8272799907a4ed5fc2fbe3f1b34279b4bed52d5d147846f4eae76106a36c9dda811a498ea4c6ea6ba8b791581ba3b75fc57b6b1840b1a228a22f9d9b3218c3592403dc6bcbe7ab7b425e11ab4a7ddaf81d284cf47564834a7c9e53824246b4222ae01e3ce5ad03d57a0e3442af5d29209ebc4c6ca666ae4afba25b15468bf99a2ada1ce371b6fcc8bab78fb406fa8d3b031d8e40dbf9047023e896db165c40bd7935f325bff6713b4be9b2a5a80b817d90382fa8d43da67b29475c3ea1c75ea13ebb97fe9fdefb412c4c602a0d9cd7a38b5c7b44c6a3c8d77cf47d10cb763301cced945d0f27c685619db1cbdfe015e781a067f4af3528f4c990fd045c86bfa1fc3a1631face644df2bd3a06641f914785ff937d621a7f2296f0e9bb75adbbc9a36a9803309d8b801c0d069c0bd1ef892e664bf85196b504f0d5d7896e7562bc108229b82ccb7a4d5ee00e0e8503c728adc2c2f2d31b7b54eb80a666221525f4f3cd006d225cb08ed3b9a9096bf2966273c9853fdbf2aa8aa3623bbf2a29980b79f224d36c4ef983233e50b4b1ab603b2e9aff2bb9b7b46560e6b0239ca2171d934196836be3f56a1fa2dc2cf7c0202eb63a16bda4dba29e16df64d17cad992ae4c542db86f4408214606b70ef9b8dbaa834e35426de2ec41e5dc20065c7173acb0392ece1a4219e69cfcdc1f2c8e820f01f883c0aa2ca7e9390027cb91b939a0073157023872227bc436e606e5eefc8eef1145faf2ca88af6106b6766d2ac7029891053459bac741a1c3c7b8698f307c5819b403000adf7b1c68352db4028440ba403a7ee7f6d62c5fb9f11c4b87d61a972f8f56fe5bd9ff87bedef3fa446855fbbc8cb062d2b2e6eee3992b9851d73614fc8cfa8f89fe155557c13733fa754e1bacd003410669bbf436bc97bfb7cad4ba6beaed77b2c467d89e39440cabedbb4f1537c5115560be8cb991db81a85cd571e805fa6f365e04b2b328d164321c49ea5ad491d3852f4ddaa5439ca0c78aeade278c2e01bbac06902d8d7ffdeeb63b18486228db7947517ab63bac20d00be516f109879ad2f32a2d7405317145d62d42cc01f26a4921053e51b926bf45ffce0e4ec9d9fe2ff0d632055bf02e426f943eaa023d608fd4d16777b3af12f576f2cecffa824886c3f713b0696836aa33b9628f5467a27de0a92cf3a1f2ad6d7d1fb78238ba87f91c36da8685c4928c3a2f4ed2f21b910e22baa1984a0d52c3f5cde5b158646bccd9902965bd9b4d57d987786dd223b852298c94c11ef40977ac56df60cf8a0e2b0f651d81a88223c741d304f806e63ef0b068f9fc4967be028a0b2983c85db26ea9bb2114570ba99c5f4a35da99c500c385c898a1300a9d4cf63e5315fde7c2078fbb17554fbdd28279ad5c44050735fd4617ff36203274e0735d84d8d22cf4a268a45c7a2f8ecc4b1bd25bb0ea3883e89256c6e152ec32533db08516bd33607fef8a255933c814f8e66e3d358ea35ceba3d25a7e51d63099ef7c61d23930a013178a4a02b51456afd9b573e71a0795c324ecce920dcc0122aebe7f05441f183e8cd9a342c693d2be1d49c912b29b88b5009078a655d7663e86653d9dd52b44ef60333468a7005c394af54365596af63964f788c6b76f0ba4815ebcb31749043fe8bfcf7b6b74e581bf26673900d85a3061c3298ca560de86a9f3f7d0522470311d222e0646178675541ee982da2021da6defeb665501f961928ace998ef3cc0b6dd6f26ac7819b7483700638160525fa7338813b8b62c0834438ba7182284de82b4029b2cfad4da0671c0f25cbb189579e9305e951da35d7fa8c20cd1ba8ed2d4345f95f41453a86116f31c33e4787482a123adea78b23539773172f33ea98e59af4911333962e8ef27bb734ca667e290f50239b0251fae9285f8ae5b94dbcf3b0227a1702bba84a5824274f368b0a51707bfbfb57d66b91640f8c33a8dd786fe9cd503afcab1dcaf3bce78a4240f13facd6c1176c97b0c958f1437a393788b60d60ae8ffc2dae5136a3736b42b58b4dd1372fd7f8e2745883a72860bb4f2167d3fe00c776c902f8df12834960c14184e7eb57e74a73608d0f5b5796f50c1f2843e8ab2790f391b46bfd137e52d01426fc8de2f18fa1f93b4c410ab4e78e130a659bc7e5117377041259855548bcfb9a0a1fd184d120cbc0867c99e5a21b16f884e84665a1b8bdbbee7f540620efb757045ea1cadd29cc1fa594ec3eacb3a15cec6e20da46b4f594d8dbbefc5e68573e745dcafe962ec265ef14b9090cdc429e9f9b71b862c1df0c136c5f89db6c5ecf5ec823dbef84df4d0b7907f15e3e883af5b43d1ec378b5b90f527868017a07992dd1ce2e42bbc6f5b472c1b5fdad94f6a04ed887c6bd4dba9c3a7e78b9ae47ccae6e8fa0fd85f2825e44e4027c4fc4fa80de447117bbfaca9bf94be4c1ae5f9361c03f877d9bd550bae556b05fed5920bfc469a0b3dab1f8ab6db100f8e72d67bd69de5345b63c653f633e08c834f92f64e5561942b8757e64cd844092e6234389318a78f4e7c18f3a2b889037d31b0c5becb8956b6266715bb62cb264cb43ee5da2dfad2eb8a2816b2793a2f6642b67d26aa1cc498b851270f15882128dc9912a06f1e3bd03642b10cfdffdf08edf677f0ab892f3e45788e11b6d3aa1515f13059591b68d1b80a8ede407be5a5db31a8d18e802013708ccac31d975b2d7287849a26ea936ec641942e91f9757dae515b4334de763294e75403d11ccab80f5d7a826188523d8728bf1f33f1b200ad8e1104cfb7819702a565961d686e10995118adeea09f978d19b8891a442de4c3c1288d28e35d119e75ecd1c550412b2158ea1358ccaf7d2f7cc9066e9dc69eaefa4b1d96f51eb42b702bcc8332dd6737ec21e13cc4d6814e0f000e52ac8e43d995e165db92b3dd4b423742c3c0dab8bbbfc1c7e7a94fbb1ffb88d04102247d6cc1d07bf34a38e00a87f4ad2892b747049fbb2ff4bf4f7cc88fbbed319edca5a47bd934a238ad2c9ae267cc46a0703d1f754fbe425bd84fab7ebf4cff4afde0411b572c950d5d44a653e1aac12e827066e6e1b999131262645b919a158aded4b074bdddf414506d7205e4b7df7c39b93fc86831b737bd3a57875b4c270194efaba6e39935386e57b500a544076a89505190b9c1e93aef27a78ffc85b9c740d574ae95124da93cd502d225f1f1b6e5f758da5f6d8d601bdf05b8b1e02312fa5a7558ed51ed7886f6aa3754098fc63a96a7c4d3edd151575caffb2ec8f356828ed4dc32867aaefc770b361e416e21eaca2f86fadbb8acd7b0e42cdbaaa7e4707e03798b68f464312556cbb8bad5d1094656f1bf97bf80674fe41ada54a91181c0fa4f0745cdabc0b13d6ee513f74d96e0f525b724c33ea16e0bfac618b01c416ba5dcea748b7b80e3b1af0817297d6e4df170f2dcc7bcabfc4374bb8320c1e087504c6f6e0920a4108bd6ccad22a99e10acab80c7ac360ce00fa4d74407ee35795d6f5fdaf4ccd574df53bbdbde8963579b4c37d34e207b2b7a168d1e2314b7f0ef3e56b43c794e814b6f53b7b7aa903272fcccfde07168770b0fad2da46b3fa1343f6788213a3452a01fdcd3d63ee1badc085cbfca394c1947f22e6d66846dc8a80cbf4a10d5e997f6cbc211ee449643e26cd4868418d94defd605cb21158dde2bd0144afb8511dba4e4c943f0f0b82724f00514ed31b3bdca43314ce532f9f44646d11d4cd3b4844072afcea553258cfc55f3bdc5d9ec78e0dbd09b19e720578c05ff311ab99d23a6735ce901e8e150e2f2bb1e3ab91f83a9a65521cb622ab866005e5138a54ed5ad6c221dee32f4d534b9319f61df02c6cc391f435852c7e8400c842fd2189608034115695dc1af63c32237b65ea845ac250e29f446b3cc22a65f1aad0385331264069885efa3aec0d7a312cc01d0e7c893b9156459182630497b9d8f2db75b2e6aeb5bab0e652ca80ac7f7eab0d6b37ac411652272b64349e836a05f6fc074f28e9bf74e397ddf41d48e514cc2f0970f5d502ba8ee21dc96b64a55ce208f5405e1170801fc9bc363da11f3743c2fe05b910aa795a69470455139de607c8edabc540b492805257c341d9f1d7ae25bb329a671b2a9a2c9f135432bacef80fa3e5c6da55b84ea6873f2121250c4e97b854515d09790b39d698b129b8c83333eb0d10231426c90926695c9e91947b7c4df413ddc9f9251ecac926a74520bc354638816eb8ec8e73b9f773f50a8e0e674491b78907459b24e76d9724e0f9eab65526cd054e1a89e81af31396a3d8391331fd29ce5f8a87f060dd5647990bd42413bb5600e5a884594497565016c9a44601ab753a5d48d50e5fd7fb9a05000ef576997ff0b4f252817ff2ee7afcffcfe5350a91740758de88ee84fcf17dfc59d269a3cad8bdfbc05ad6cfb7caa68e5849737da66134c88eea96593ce3f1344eb60c6e81348dda705ba697b8b5f6dc8513aa66113225799aa003986c139846fd0205df5b609c4e348d9f1279874135f237d8f3c78114763d6bbb5a6387c236e291cb9faa69b6bbf503e3bbde630eb05aa57acb710a73707979a2bccc7fd304b06ed383be38e66e8d10e3a7ef77d6234d8d7dfff948fda0bd0f55a1fd19fb1ede72cc8a304f9aa7159842a6a21e2a88cc807cbcefeb704bde9ffa44527985fe3fbfe3de133c1ef8ffb6c6522fcec9bd5b34811513eb4f718cb3da50c7c602a4b7f98e52b37604379021cb075cda91dfd09495c4ec3743c4785551342b408c9bf8e1c5d75f24a4eec603c4310b6203cb8760a31966a655edc3c840764b8cf49e99d1054b83157a32ae8b1f4d275b2541169897ebadb90e6e78fb869b1a68dfaba9c76a9a50e2077e48e31233be9ce5d164e54ef3f3eb49dd0e0b1ef849597870f4025413e75ef4c71e5b162199d0096f17ed10f3218a9a0fade4ca38d6f2594b6d316f6c174643190601c406b7ffb80ba8eef3998f3481711723ab2b4a21dc7ac41cab91efef646a00a0fe47e7a9792e44711536cfc041965a12bce2a43fbda618dac7022a48191d2ff47c551e8ef020de3b19b976d207c3e605b8214f5b6ca4dafbd1ccf3d99bda8b31098d9b029cc91a065d4b2c515864dc2052f116ca7beae0cdab0688ab612734a677e560e4e3a24012e3f43c568e18093fedf452ac4551fbf2c4890481470ebe8c8d77c940d50b310625f672f137d145c2761fade7308710da72673bc354462f4eb733284e1d8a5e5b1476e86f063f26bf7da1de6269be59c0e706931a1514a8462efe38b1c42b489b080cf81ed438f2b279a20d09c3d3d45c5a516233e90662d50437e2ceefef26732cab723b509b99de80f917f155f092dc8e9f40742577d196e97a619c9ab45999ff03b193c748d6edd0282d62a7b2a6791e92a228eaef634405548b77eebb5804b8de491aa380f1021a3c9dc4e963049102edc4e5dd41a362ff267d821e347b1b5ffbce2976a77cf687cd6d86d10537c21da79ffba821f56605b97e0de51df9455d7f8d436b61b02741025bed0a497c2eea4db06308350cdef72c5f777b98271769ec0f904adc6f4b53c3491fd4d9d768db33b161a29c2a1b109234ac9c0c0501b074cb65980fd771d41a2a001c81726a02cd5f782737bda4293c1d855ffcbdedb6387773044e025d07265ab743495208158d75b9018ddb67a9c0e20d458bf7eda261bf2fd110ffae50a8f7601422bbcdc05c836ff36fd1dc8155addb43f65f47eeb9e6e3768deb9eaf235caa515cf090938488d4d66dab7ada2ad26331ab5ff37806ae68f993bc0e9cba6d46fcce7f3a7f81a60ee5bb1f6a4c3b1fcd41e55b51a88f1d20aeebfda7de42855ba768f415b65f11cf65f0c333f8996184753542d65264113a7586e35ceea860f006cf47bdcf012b89829e37e608f3628c488767fc603e48102655cf9a1f49281f3509cf0a0cd7bbf39b2604bb784d04ccd3d58ce32cdf4e5b62c75b8c4df4caf6dd52a630bfa917f67f450e4ae5436fa3e8edf831fd821680a571061cd9e5961e3ebf92478ea4aa3eefe6b9e4185575b1d6566cdaa324a6d4af93b3837ffb75bc22370e7acb730a7c5c687549b3cb0e567c9381f26fbb8d3af1698d77066fbe84a8cef50a6563a2d651391bbca413ef5af11caded8a83ad024447b75d8af4ca644571362b2d22fb6b5fd83f7063254434d73a7f2725e6eab9dbec521eb8d5715923432bf8060db05c21f4c89f9fc9d8a433b7f2c051344300353bac835a0feb2ea531f8fffc2e1e48174c45ce273150e5657fb4bb91bfebc4d309f6c7b0b4bcb52390e1d69c4ad23a2a9a1bb48a342ffc09ff75517910ff4d67114b3b9dcad61f6997c208bcdd5c1e2051546111efb424d4e86f4e5bbc82ade8730cc77d3be27bab2b8b8ae553da7f8be11e8abd3a0dbbbe219d5ffb5721e672d66eb434f0ca4591e5c1314f73b7579ca2c8f22b59860ef663a5303887b3a3031635b17f7c694850ba292e71d0c20757d39abc189e2537413ac3c7dbe26106fbc83e4681c733cd40730d85ee4c1bd2c23d6866ba76afe8e0d9c17227d0b23e7cd6b452c12e1dd93de5400b5319e12e5f51c359e2910b3509f9291eaeb2eb2b643ba64c15e4111d012986c9c5a9956b7b7264e1f88e4c688c8ef9bc41578a7afcf493e7231c0cca2e0a5992173a6175c5aa821e9d5ef9ac6210e68f9fe30c47dbf544d814f9c99e35d86b512f17dc0f55ae69b8a4bbaafd4786bf1d94929e85287aea5b0e0dc979be25104bdcee23431565e411bd00ed0e03c3f2b87470554b42bfeebc645afe63aef935a833058c42fb0bc15b5751a366e307f387cfe4054dd7800323cc3560f65f826de9f0162c807e8785df852a7e230e719f401f6a5bf72d49507f1e691c507930cd6dc75824bc2e0f2b7f7aefbd0c99f665526bb2a46e84a4ba3c0bae806513bd6e494c29f86c8d14733a8394ad3e5b79541443741b7b741d38c267a59373c9f70aabc0fac7b5346ea9dcf1470d48f927fe615798ad0d09e4fae8d6996374bf84ac6fb2f9844e71ebb427707abc5baeaf2620d834fbc2ca6a835e78e0623636e4e7e438cdf6e4ecb6ef60afbfc188c065cf74a70b497c4280950b2d1358a8aa9d7c7b542c7346e38311098c7a985a30213aa67e6ae07f70e4163fcda38e6bbad234e311da8333a690a4c2fc5542cb459d368838d8e995731b2609c0de4ad3b1d73a88cc20dbcd9bcbbff72e91b809d8779d5bf778c033cc109155ebec2316f166bcc2ee8545d61bb6cc1e53ede3600bcac505c04f15ab44288a060a3497164ef3299c02b91572a7299ba4c3749794aab13d7ef0d25978ee1b6a97bdea6551ba9d9813c3f9c105756eda0c3ca4366132652e38e365ebc5bef9de3c5664d159e3de80d1e42db5d173ccc55ddd20da7c2474fa2626ec522c54f6ca788e452a5fc09d603c79e10b1b17e6af02ad87e8e02e5011ea47313a44ab70a64b331542676611de5e5b988ab151fa087eae6ab3d45579850eba93c9c2c199a4e232a0dd4b19e14970ccad89e8290aafe1b23a2cf6ef24cc7e110ed232fb26ddaa2398600562d500fe119433ed8082e33e0429e1aaa8828f0679bb582abb6a3f5940250b7891f2aecd89fb8540aad8c7a41e223a437f950495b106d4514aa2166445614f663ace14d89e4c89f14c56a2ebb18462b5125125a51f91dea4b449e5d3aabd1ed113f8e0dacc3db7628ed4933e0972a66cfb6fa200547346fe0d336728e6d9ed02314802f8da5969ed7460ee4082124d1d65b997836b0ff9c392d83ae25f5872eb4bd950e7a1c00e2baa8e24f4c12481cc61fd04b70cfdd360eb604642f5803950cf8574faeb60d220e2f740a09d25c5506074624355290573fbcea867b7b804195b3c319eee2a2095ce03bbd58f21af4aa5b7a2fbc5f9e13c823db32e4d8d42d452cdf764436f3b59bb1a31c7ba0af8f8e2bb50d7728e7ac26804eb0f45fd356359e223a5c0683ed17584e8ef43768dbdaa8c75300867f32d2611dccb4376dc3bb0994c8bfd54f472bab079b2859e76e0a5dd019f3d061ae9db6d09d0a047d5c087ee011e3f284e597657cdf1f505c78722a3b3b8a375a6b941ad7fcaee87bd083c0ae179570d468ca9492e6132306229a7eebacfd34b0023b6a1118afc34428158bd3f0780e14aefb096ede40d0e7ab6dd6a609affe70334d0dad1dde230765d40789d09be547cc54c1b4850b1deafd225e9a1711d3f3236fe3a34fc72e9a2d38ec354d2dc12c6dfaf4a4e6294fce7e481ff8697062dc4db5bd1a29a07c12b89665874679f48f3393aa8dca9f377837ce43f96945c3865e55f67fa651752ac56dde5dcc7af7aa0c99427af37376b02a044be5a55d55ec9e441fe425529f95a0732fe79c7bd4b9c02f3020531654f271285b0f47bb3496098ce943c3ac58b8a342d3614af6c40565882867ae4c5206d06ec2459e77928aa2ca24d6226f3f26a7ce31e3cbc678f07cb06c925e8a4c7badb4403e95f7d8acf1d3b1c680cea784065b354e9f8001912546aea18e40444ed26f8fb00710e1c67bd9bd004fe43d599aed1a9f4289f117add57752e3be4f407de3525633fa3d5236a48a998f201e18c0f7020265766fb190c79ede18f284b491dd6e2b3a74e453f62b2963d9220e7b96ebf832735a3f7625f7f5a87218f9e1085a5282eaff5abf0ba74b745f326cb5533e52d948921794aebde72ef6f20f98499b54d2bf07c51e9ff35fe7d11c4f4c385fbb1a0c8d8522285d91a909714f3ae1515c9d37b8880d4dd63d5195d532f8e57f704db9c56068c6d091960e4d57de9e5308d70cc6b0a462b5a6fac28123fd949a7a26a5846523041368e14e4cf2abbb7f9c3ab40ebedaf620a0798447e63e1f6bf5f65c0f0337fae8febb57a440f9218e0a34fca728f9dfe80b822e73ffebe47ffd361b3f4d6a956e00f000374f1b8913836a7027fc87d97b990a1cb0629937f1d7f4c5c3473b8a4c0bcfe21a57a70c5b8236c8ca21c45c611d321b6e175c1afc54838ec351fc168b7d40e2f8d67b29d132f7bdfdef92ae441d638efbf25457462105b64a88b530723c10fe905946c74404afeca36b2cbbe0fdcc4854e2c61f33f43bb42627f59e0e52269c2d35cbf02a3be72c1963677625e806cdaa11ccbc199827e96348140a2472f358a5f86f1a24cab4b5cb5833bd92044fefe876d4d9d81ec497921480c34c179a5fa113d6aead4b14b118c39cda371d76163390119e9b6151c99cb0c1c2c3515610316f8568f769161122fda2c15d7104248ebe39b14000a5a955e9b515997b170fcf056ed1a9ac202660234e51b99b3c0bc980c3b0592c5ad8f77d5a9e76ace4b7cfc55924a9aa1b177ae34a85a26e7b5ed92eb5d78459053fa88ca7065b99c23d2d37705f4741c5bb3e278adc2daa099c3a157abb02d1e6a95062599492cf80de89e95db37b655b0f314ab9d9bbcfc627fcfd5d3defa8857096ff917016ea556e95e167b927d2126b7316421f56445da5a18b7ae98657389579a5ee61d764512092c1974b50216b47d5f5f17e5ef0d8ff8bde489409e94681672b38f1c959fd9dc0958572f6b636d9357c24a022a5f10e669199cb553a75864fad54acd90b09ed2f0b239ec658ed3833986ae48aaa192bc7cadafc2bc69a248ef610afe0c16660c0ce3c3b0fd228552cb80ffc3f7eff3b275045355251be0d65658313c87a8618ea05af9ce31e1b373cf53f96201477d096d72198722ac22625512b0105cbafc2a0d1672ca4f04d453b2d18b474f18d62d31e6242135e6f87316ea526cbfd6da1c1b99cee49655f78b8d61b55074e4c645c0e8f5c51cde471a96cfb1e2e3a11ab6de53bd430f2a6f2b3d797aa934d798d2a9923076d49ca9c622c8871485e9502aede097fdb907d090292443c228fd4b29bf73a02f8146d14db86538fe4d62570d041425a0257e0a55bc792e39015bf4d9da9a2f8fbcc12d7cb69dd0b538c9708defee8dc0ee269607507aaae06448300af23a2981fed1cc26620f603d63bac28c107aa600ff2c27b14fa76a76d62f348b8fa8e16b0f3071ff2ee2ac1ffb635e3b472204230cc05a3c2272393f0b2f2418f6dac907852a95e80da14b979939b4bba112bdaf80c489901554ab4c0e415b0019ed400fa61a4de3b3bf6f11f431f84c6c482b98f6364c7e256222c97fd53989939501fad7c76caed826d74a358ab69304da6bce2190876432dc21c1355d6bb77881c86ab704edaf9cfa7a6568cce0f6edb7891773a37b77571bcdb053a1b7ef0d58b6e884344670a13253cf5d66cbe19bd3eb1766fbc1540e6cbab5d8697d497a4d2ecd007878121ff2c1478ea8bdd167fd57abd1b028e7d7b29e26a042f40f5afb53ed3f5af5738af8e1b6e8552b8ae4cac6e5fabf1057406e1940a28b37071a27f5f6e4e2f82b5983d063fc1448fe2c9b9d4408eb2a0cd1a304ca7118879cc280058f2d680dc19c3778af14c0ef22a2fd5e70ed3beb22f1bad409d416c295b09852f1546e347e9df28e5d592193a8eb19e0f26756ad06f3e6dd2d6e05e709edf5c0cbfb1a77c69762a15e05d5270c7665b161d67bff7b193342a18b6efce21bd3b0b0f1038a3accdf43254c3e63fe7440001fa4a30da2215e54c2f0fae6f7b951eb7d86ffba73f2fc9296053bd85ba8f7614fc497a805ce45999c47849e30767cce748b7b8d73e2c8b47b3b89dc7aee964494a09a9ca91ebc1dc17112dd0dfcb9b011a20f71458071daa224b4b4c3eaa8f6484cbfe6cb38b74c86fef79e5eaffb235ef354d050106d13f393907bc4425e2bc0a10f7ec21dc312ae63f79b6d608df01e5234bc29e74ee4724ece6c78506e96476cb316d732662820604aaff069563f600e4e23a7e012cd614530473377ad2227138c2ea479a48d8bfe49d05bd8f42be5ba46e5c73f4ceab5d0095f0e4b1862cae53a09217ee4baad8fba11c7cfdfe9687c06baa25a740957b5761c5d6052606a822ba1a29725b4e6a048cbb10a98f02b525cc01d05105a1148c912140fb1da50f7789b034ad7915c3e8b5d73eb1cbf55c6be46139456a07607340c5500273ddc56d123141641615162f9c6af1bc29a77f48698bb3c5984758ae59cad7b6b4a42262048eedbbd8fe2c17441945312b7f335d7661590ffca6e1d41c088c27cbaa5103f55d1b27b8a1be8f669c1d9b4cac7463c2cd7a05491b0ee459ba609d4f5b14e4d5911fb4e687612a27554f58a7b2dce473c166718155a8cc1e75d4dee3a32042618e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
