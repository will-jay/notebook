<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb4a44053b9919e488444570dd11dd1bf4cee6766525955891c17b1f04e783358cc0e6883c3233de356c39777841c84c7582b232c1dcc7d64f7d877dc6ff67082eab30a3fdb4c55c6a77935f02ece5da81b46ed2ddddebb6748f67575fc8c7a9ed89dc41808fe0ba6ee7b7746aba530341903aa2e85de1047bc6ed21418dd67c35c91574eac09bd0c6b94c73102f2f16066d70ae183230ba4e444aac9c2c2958b89b28ba2fec03479ee4abed2beb9bbb7d21fae9c5d93171ff8ea5f53a8c28f99533b7b627e5500da379137f49347082c9f7cf54b0cb04722825a5dc61e3a4778faad8aefe9faa3fe32b5a26cadef3466b7632718bbf7775920d6f20170fe3081c5af95148b7ab2deddb1a9d378f17dd50c10f261f4178ed3bde41a8f56dab5ac2c1c338f6f0ebb1afd1fed1be4f1d1ab8ca9cbc37b6c0dce2b7d759a62ccf8dbb621ac0bd532338f47b4bb1d3eb77939ef3b1d6fff842ac120bb164e8d02de7d1198eac0fb2c281f2973e0416a64f471e0263e483bbcb4cd4e31b151b001493f343a73ce84e6fd5a3f4a67bd646e559626397cbf7a40d66aeebd75ead9de7ba1e9fedb7a375854caa62051462b035b339ee09493436b1ba4b1d320ecdbcc2ad1538bdaf28701dc6fde162853f8c8db056c1f086e64d398c70f4ee13b26f70d8482a0f841d271ac9ea3a95fe4ff073507200c2bd3441ee6e906dd51aa8017d905778640efeefbf7be5639b449c8ba9d23fd7202f630551a46cbf76496007c5b4ae26907a1b151b7e239f98a56e961330fd70777aaf08c2c6837d1b897ba9e1168ec9e0a400af45ee6efffbb98aa70f07fe0d24e8a9b523377a02e8eb352b589254cdb587166c2a6508416a243dac5bb92a46d542dc9d40b95f52f787d9883801d2c93ca98f319a1b27078a6a4d1946fa30318b88845f2241e20972a73d28ce4e9c71a08c16ee4727f3f4def19a7bf3dd2a1ad7d501ffc810f24d7361d75ab08b6921764c7360ef7301db7a669cc16706f492428ae693c1bd34c7dcf5739f306278a8679f74ced09ae2e17d824dfcb365ec75fcc968920cbf71bc89338dabaaff84b3cf3eaf31b2acb1de27139197bbd0d1fd2e192c4018cd2b356738d46ff6e95b48b63530af77949db4fc628753169f0ca7fc9bc7f73e384169377ab80a6be9a0d564d2a91f2c5089c01f422c8239ad3697db4cfb49f0f5eecbbd9c4f761641ab6b62b8ef7d766d0889b17d98ea952c49233d6abe13b3a4543069fd4f5473825c778b094b4630ae520a4273f59118e773054ff1303fdd772408da386b5d07b621872796c3b405dd1844c6143d44259e7197a5841bd36148ca4d70ac1a579daf962ae08dbcf8558a5adf3a0dd4117dfed54906f0c204d8ebfdb67cb2b2e2a3eeba3460b9e807bcdad0363d1cc1edc72d3480768fd6d7e3ee77bed07d0c79727d597ff18960a2f9f937720a92d3bf9ced4814094e7568f7208cee2db27dadeefbb19cfe77966e24c0c7afa09d03c406734c9125eb996c0d25bebf8d11a3cfb214f02afa276e51d5025a4bc189eed006f2f9f4760600c2e8df3621ce4869b81a466534da8065b92fd08fbccfc9d23b550f8b04cc0ed782d71a10eb92ee7118b6422df651624c1617414089c7e1ad30344ae54d2c75b36c12247753902ed213055bb9747083c87cc92408791329dde1109b5340ec16817f0f10a9fae40b8efdff4e1422b301df7d4b2a9b3b6b696b86f8f75b9c83b356cba1aa8887e8ce910bd233c2e4f1f513afa21e09f9dd956c2db8cf7bae1ca177d99a6b42092289e9a1b30637b09c74a6ce434b15ad06fc2e25a9ff452f4a3f9fdc4b0c617aee5a1b6609d909a3e366785f6b9e1de8ea78e88b54fe68ba712688b6bbfcd6fe4f5faa9ad741091b5da43d9ef41e5a1f16b2104ca1441655e3fa3efd402cb6d5c8e04f476751aee73e3287b8a70d2c889e47835a146cf8644b0904b391c829adbc6b482b88b07667eabb24f15be3a50d715cec03ecbd84baaaf25cbbdec44afe91c548b200d6807824b16fc5235c2576d8a2eae7e982f6464480604f72c26fde3a62561a29b1c7058e5214c7afc6625b673d6fc5bce010f40f2d818e8b88d82286a079019b440dd1f58d050f72177991e2e2f44972ff010747df8c13964510d2ce87ac3dd16520c51bc672d97ad486403b1528630301ed5dcb51e3c0eb1f925e6f44ecd697f66967616edff6671426afd15bdc77758ac2f7afc0087be855d6faa122841f552ff078fabf4fa6cb67c70681f83c413bb162daa9d55cf568599a5c545bedae2cd338bfd24d3d58517e514381c4e62842bd944e2614d8f738701bbb093e48a4a9d7073210391a2e762847250e8f968eff5ac2c5419692293d4dd851d05dc3d467a343e1db5e49034563732e893f0dc7c32e85e046bc317fdb645c9c0d57264d52dc1bb23a513f811d658d3ebd66df00b5a6401cd881589705d27ba72c9c96c05660b7b7e479ec7ffd85d385fdfb09529dc7e16285504a367f3e77400f54c47d3f13eea9957ce16f423a9ffa8c2b066f731e38d832eca8a684bfcc530ecbd6b30c19f9a3519c320fb8243b9242535770325b8214070cf559add89eec7f331bd837ef01765dc6cd03acb230dde600a4ea302b5f70f769096acd3992e11fc766548423ecea675e613898c0c96b4a8d1940c00d6f3b1a32edd88f3fed51a0bbff4c3f8ecdfdf51b0be7f9394e74abe031d5c518e55303231c6dec376c820eb7d55446dc54af20218071e72f68091560a3f4856712f388fea1c1570be3efb276a18ad16fab88df5282cb24f370153d4d631cb209e40a4c0881492b13994ded5d4dbf604d30de514401358f3114409c530a426791ca4e79abe26bba19b4cbc2a9f5e96c072905d9f90db5137f5797a56b67888b9d41d664071774fc4e8b65c1687fc6111aa6da90eb4d586019af26ff54b03f4a7b74c7b98a2ec3e4389921f5ecc70f02fc9de35e5fbb54a31dbfab0e319d2ed58d487b26f553fe907599218852ff0fe61187905397bd88167386e9698a9b6fbd9c6fe06fd210bb1b8486ed5f61dc0e3ae058353051c4739e177f59bd5a6d92db9b01c3cf49bc11606e37f354f463f2006323ae83496cbf4fcbe0010e7193b0361a3240e933e47af8d2d09ce739f5a3e301449d1ea790e8f0f8ca1d0ffe5688aa908b3670ec15fb011ee1245ebe3d9c7f03c62cee2e09f187ec4b4d1a6a2b83b185d80ceb67ee470705d4708fd73f5ec67f8debeb0f07cc40ade5e14fee5fa97fe31229d547cce9facffbd003ae4a28507505fcf002de9644f27ba719fea3f921bae34d325834437d8c66565687e9d28ef646c4e93db61d3c63d727070033b2b8ba7d3565627daf15e8c02bbf90c209ce63873c55a98fba5b1f0ac85aaa586f35d1faf40766e5c814cd5946e3a1477696ba929a8842df84d37ed1d0f10c97904d846900f66eeae4c417ee7a548cfec5988450cbf5a87918f2b2e51f029bf2e2c5e4de66e204322ee3a1f004f6e3eeaae793d4175ddcb6e3d86fb7aaedd9dfe6862e4127e2a4523d732b2c154e28404666c6d48ffec5b6d68c6fc709dc38d7c0bf95807b93d8438932bd980d6b38c68f55af4685b155f64da28e33c7d916e3830e2a7d8a0fdffeb5dbeb76dccc94fa18f7f5d937e9a1bebae21245f4a00f82a770b7e3d45538e310fceefffebec25b62c240391f0fcd956e8741ac41253e4c7a81fbba211aa808c78b4060c2a13f0db7484845669bd0c9980388de865f4dbe4d9d62f7432a0febc40bd7c0c8e4e60daead2c38e6afe9f84faa0d2c928e0a3977532688e99f85b1cec47a8bf353e5ddd18ae7301c378ec815876796940244d6c0ea77fed8706465590364109e36b37d5bc9b10d696db990380b31d135eb77b6400ace740b4ada165ba20831bf98c3b0d54cb50cf7c94217be86d8ba0b23dd5d4ccbf929d6027ec361a2fe8351c15d50c0882b928e443a7e26b35845d4bf949ebfa370eda2eea4aac09b6cc0774942db4dc744317555fb5aa2c03eb8e8c733d5468183a78e206479d4e7f42d12a296819e805f2ccb0f7928c674761cc69315528e213944e587258fdb9120c7d2a4d4b79966f72736ada0a2fc968a25af116aa813e30d0a8d142a5a52a72606035d3e0b13b5412cda0056cf3f91e9e00e8940fb949d99f0c1598a1be60d59a82ff16979d729508d4e70747b954cbf9cf2b1738d7b7a3eb91bfd5a2728529cee5f8bcb416047b5784d9ce56830f6f14fd9ac88e61bf7b1966399053833be22b034f96315e31c5e50a1e2e6580add2c1898e3476abc3a0442b28b8cf5ea4b7c942e6f18c8f84bff92fedd80ff3b995d9daa358a122464c46b491913458f7b0e91fd65095f7080fcc344da70750391c26a608f1f56d2aadcd36e339e6e134721918fe7c0cedd43cf118e273f21b6f71bf1c36bb3292710002feaa166e8f8557cf815dfe16843c9d8600eb48e3decd9bbc652b75e771b671982063dc63cc4a602225cd897de0d88bb331cd380d588bf226ce646e11f53400acb2ccfbbf9a6eb854b01f6e32cf1d7a1f8d8c1b646b49af74411e0c3ef70ae3520a724c01b971b84a8619fd224ee6efb1ab31d2ce422c8b32fbac37163d5d5b0f78b68b5535b3e73cc0147038380d76974f2d8fb9bcc7674deeebbdd32846fdc5f739c7ea4c30cce5158d14aa652c1a00ca18b09572fc5c94edfef507780fa3794cb12aa8ec091981e03e788cc5671dc825e4fd1d0fd81747468aaf28a4aa4b0ffb5adf5e28feda76470ee578476f3c86e5e8b05877c93c0e8042a5f330c5e742c9a439a8054a41e1deee48e07654c596a264529d89749f74d62bf023b491bf3da720b17486cf706f3f790ad8c43e0b05b9f2364219d49cfe473fd3f5e9202528d0b0ede6286ed6c9c6d76bce4e50979a6a10d795cd26e68ce9a1b73e29b5cb52a7eedbcb1af7a4c2f2940fafaa1bddd3107f56b1f40512e0fa209112efaafc42e667a43f472002c29ec70c9263ec5b6dd7f080b160904bf59aeac810eef5209ebc8a34c40a94be9fc5f402472893af045d5c969669f5cbd788cfe4fbc033e759d16550f86ea081db8f5fe3e1d5ee9e6a1ec52eec84d2953ec0a4ff96bbdcc5ec102104d42f8d1535e1419fd72d4ef8975473f7c5fae05c43de4d17c36dece3194543220d232731ec448eb5fe6d42c3e30fe8758de723a623b0ce37e0750d6c2ca6a7edb8f4dd054b8be795f082194b61d3f746bd24dfe38df82aece0e599795c20b436b21f04be46ee415d469906ddecd2c734e85c1f525d51f107529d38e283da8b4dfcf8ab25efb3fc103bb7486745dea05df8029f46f9dc0e104310fcd3ba8bd22d75b5829905ef6766d1058ab43d1fed171e5897dc9d161d46c01d5bcb59185fa2ea74d42e0b49db6f58f680628a925a5fa67c09b16f711e2ef7e2d05caa1c8e807a7d553f4132c68c2073c72bcf984a557b974f15a7ead4641c1f4956f4f9eff5883470020bad06421130123134f8ec2a8aa1d96f183c13e0599f5fd25160fecfe7dbe8a120e500de8912faf69f12b4fbf0aea3fabc5e4e4c721821bf87214b650637cdd55aa9a9309ce92674359b8c7fea6bcf9a351c1e227cab9598d83bd12007f952c2bc71e33c5a5fefce4ef8f8c6c433fb602513c8aaeac037faff0350ada1b0d11390e20d98ac26023f58febfb39bad8f60da0a7646e1e77f7d3b9dc5392d87b73f52a792b0a70a66a6ca113e3bda7ae49aad7806059a4319fe3922ae4d7d9b2101b98602869e18b24ec8468ff9238558e5d7c1d78b812ac430e1aa2690267fbf6186a52ee1a5ba562a7b2657e8e1a064b834fb19aac577ffd4d373469ea5529343e4394e72a662eb6ec0746937072c73fc10730d03e1ea0eda9f0b9c56c9e9517ada849b7d2e324e67ad43b46324b24183cbe7b2c1c815b18c4b8d42fc97354f85f38849b1f0367b477155c76eba25784c74d77ebfc780544d581e8c79084728bdf9088afc61a28575ec87fa476e4bfc84965f444517309c73904fbc9b7dcbac901c20234aa58786964d98c9afc91985e2244bc875410c2409ed7febe38e3a26d01d8736bb9384b92a39b0fadb28cd56e44b33ae00196edf1254e72054fd20bded31c73c6e23b84804db225db9721a18c68278f21a88ed73f592526acfa8f523a6b818bd5c78aa93da91c2c2e6a8c359649f374788c43b0db730862f2b311a3ece72efe9e692a204cbcd576df6a21481481f7d4363178fe416b407bff5939215c7829b0ed324465051aae29ffd2bb713ab8df75672dcea380103012d3c26142b6016d79dca4c83150560b190c1461dabcb2c94758f696603eae21a4b4c5de65020876a9b8593e5d1fdb1d590965f3a9e09d15eda5948bf28dee813718d1f6210418d6c513b4dc93026c9d6c3f3302a6ac7805c194dfee0287d38f8714ccb5c93238ef83a9d2b88bb717e274a9d26ff08409b44fd87a2bcd79b34cbbeaa0e24a70216377bc1fde337474397afa57e4316b5319666bca4267393dd321a274538e725d443be53e9202542009dba7745815b9bd09d9df7d8e0ad7a568961097183a1df05116730b0a55f56c678502f6b3aa83006d14dafcc6e2169550203dc9d385bd212c79c28a893c33be123569af8d6a6a5afbb84a0c502edc65c321d3b21d006684810b8a8954eb3f6f3e03e46e76e6174d2b8402e6772d28b5b576f607094b3fba7b0158e15db3ce03c022d8f9b371a00515ceb63bc3bd8afeee3997b85960cdde04943fa80b75dd8cecabd909f79cf274bb194ced59b5f3ff3be74d1df3b1a986cfb5d3023b45c7eb788c7ab6516cca64deb9ae06c5ac626127b5fb93ff16e8f890f7c0cc60b561fe701eb9293f509e2598c8495e31c46ab027e485824bff2fa2543a5fa3c27b7f099f448197dc247ada907defbed7c1d3aa28bf6efbc127460f8ddc9c0a6661f8091f76a6844e5a5468b55d4bf9b1911d0fa7ef1ac7f5c2c1f3803225912f5ec759852ec05fd7b86dbf8ae16a9f3ca4d5cac0fe5cf7008ac81788a3c7ae23088bb92bbdb8fa6ec18e01a373c9302747681c0f3db6be96b556a2b0e73ceb6dfdaa3f9011de07afaa581d974b730cd909367bcab83dc1f5db42a77a89a66faa108daccce867e59d8075d378f5324a67f0324cdae3453a6ab3649df3764acace8c859edef854f6db8003e1bc06cd77bf07afb6fb2176c7c4b370df45daa16d99351c48a3ec8ddd15c10ac566ee6daf309c7aacbef71772b316b62ac8b2af6910fa51890493712ce6a36edf1952aca395b71c6383b426e82ed075dabfc4896ffaf2ed563ec94382f9a29e2ddff2efd334c3e14da67d17e4a3e786b8788583854935287f3f6e0e7852d7798172e395716a1c6090cc5335c65264383c44ddbb5133a5ffc681461d290b8fa4f03d8698f00f31d42c98cbc74e172c2c129fd8ef672aa816218260e96c78a0f21358f027aa806572d40546963dd29971fe510416d9a90775a187f0b78e29c5731704c71524d4612922c1963c07ba8ca69086118383a3f3192d1cfae1316b1f0a02848db1f54d01cb0b8bdee89e5da7e74a62f1d9115ecf649db33793c1cb707825d777d25d9e45a6090cad22ff1151f458229e73d880fbe381c0022456a1bd29cd14d67b2dc05b3010c9695224ec500852fd11de5aa1b6e7f38da5a103d47b9acf7298a7f16c65698513699d4513b97d3c904b818c272fc6ad1771f3a000b9782a9d571bf7c9af27ddc0d46fb1604efc2bc465c7837678f3d3cb4874bc521e60db579717cf3c09cc5cbc0c1ceeffa75d1c1530ad5589edcf530ab3e35423508df9fc56cb798deb1abfc58dcca1692302748ea5edf13b98d3f44e80774ca9512ad47ad8d0d7a32ebae371494f85c72981d8a486168a4d05ded47535a535e44598e25022c7fce9ad255204a063965caa1909f29f78edb92b596394ffc02911672b393124f572284e7c9075f0a4337cc26413d5363122b1bd4c855edb8258cfbb1826eb86c88d7b72f9ebece3b4f43a079dfff4e9d282c597baf2b67a1a3d345ed6f078919e3ccc0fd1b6f9fd372ed0acb7b36d4c5f8dce6ddb0b7b95b3094989d697ae56a182aa6603d6028b445ae2ca37dcd64c833bdf5114ba96be2678db386684c0e4b963071caad86b2095d0e0b45ee06576775614be7efa3d30349f68e8b3d888a1403d3c9d4e31dce14ec892022c3fe6b883a0900660b948b8a34c67040edeaeafb0a3fb377cbcac468a496d6e199f206a285c4409fb2ac387c45794890b1e9e1c3668a46e4e05636cdd6cfc0c391408430c2c0728ca9f85b904ee15906471434194110342d0a5863ca19582a0ff3de155276294946157bc1ef00a91c828fec97a5acdefdfaac52fde52cb630e849737d0576a0786c0fad2ab22951ca5b7b260cbcb09e4a5449694ec3766c170bb589793ff949da18aa25e3912b3ef905b26d48bd64a8331addee98e5fc169d5671117a6486e5b5672f08a148cd2b62f996b535bc5ba8b68fa04f1fe6caade589dd088f6e92039dbf6a6569500ba76232dea4992f127536e4c7937ce7d478bd7587a03a4585afba91542071797a39b610fd4c095c791504fee95568ded2cf549eaa9033ac07133f99deb7e53023500db1e6f04a60dbc9940723e408067a6e171484d031310b59dbeece11394126bc8ebd93903ca3e97bf20e0e5718c564338787b3bd77a843fc5121130ccffa0d460752dc1f2db082b4320a29ee7ecbc7c55974974c8303eacc638454e5f987bffabe5a9fc8d4de3602a8ff2096d86700ec85b57ebcecb9ab351c37195441dc2662dfa6d6915cb75e8b7c0f63393e35143ab28aac8b19875a3cd3899ccc37c5667549613df8fdf68baca2e53f38c408397915a56d21bfdfac0b6c17113805ed44776644ed7a652859f0294eb762bf5197977a63db3787a482db2aa98fe56b27501cf02e9aef23789359414c41bcbb854b71b09e0dd51585150d4b66d5c773a3fae504935f4fed6f587520d5445a568fb5c2eb0e5936a86e3805f59605b43c78c6ec82d1c90266097248cf009af26630dca2c48f07ae44e2b9c7f6fff79cf8793b84493c658bf912f365f8fd95ed8d0e7dbf3c7bf3d20b935345a9f31c1162b8f1bdd7a441b6fbce8b18048b4cc9aaf4042c0c098ff3e7d5e32c14394e3918c671959d51789c03c3a322c685dfaa7f146f2cb5ed082c14050b302bfd8f4a41ec325df02c9fdd618dcc4f2aa870fbbb4821c902637f4932122269b9d66c16621a09f285dffb3ba70736e4d5ea45022cf6074625f5e120dbd914122e63cf9e9d2999306ed31ca92cb1bb16ac161def718f0ba217ff385121c803e32e266c6f16fe7bef8ac49f594959077d72b291cc58cb1d8759597c7828062a7143d042db30b5ebfcdc6fd5ab82a1081ed7810bbb4365a9162b08da7383945d81136ebd5bf2c0fdab4d49b72a944b9012e6aabac85ed1e4ecb489221e1a48d5aa0152ba61146a902e20d467cc51ada94e6076f7f558aab0a9705203b5fcdc09d7c8b6c6441a266d586a83f18f7f815658f5fc8eca099d5c810716557295cc6025cf9763f619e66492f4d09750763ef9326043fa2cf526052d44711bbab2543fc8086ecc51ff06cd59e6ae6884a2b143d2d6f90b4489552ff08fbe8d0cbe77091c749a7da4c6e360445ee6db70294e60fa163c45c82fa63b913a80fed5c140eb17c0429f902e569d5ca327ba06ab51e33ad45b385cd128aa76fd09a7c7a0efa1d5701be1e5a3a28d835b3414667d88a8f3703141dc960dde25b62fd3b7e03d2bc5653cd2e00ad9fec90126efebc2e3975fb359a6c5d17250e2b9d4bff96aab9721f97e0766b3531487187cfc6290b2a8cf78305f82246adb6a606566bf95abbe806b0ad3d411ee6c8c2edf3dd0d9d0e3a2438832aae77132be983a9e69dbe4be325cb5b86ee1c053aea5440f6c43b4ca5eff85febe5334a8bd353a686e2a636419f8d07534a629232dfe6bbae811f6f837fe9251d46538e5bf27053db7fc784e83d30c6f7b73cfd7757053c0f489b08f69768c1e508c26c0989dbbc4279756a5b165b5f61b0729f4a9f0d838c154749c3ac21252113ac4a22392060c25c7ad00e31ae994261a6c13d9a7f059bb5fad61e408a106e1703ec7161305c1ca588deb0422dd502d822ef9818a29acb85455637d51a0376588cc36422bf8c32a87b3c71cf56477e52896dca13b466efe64075518e0d1dd8e8f295296bb5b9a531a60ad1c800cb75133905a14df636d630f211d8b8b0330615922c2057a7a1e701d650ad3ae2f5986ed8239c94e3a864594935c40148c6dddb3878d06db4ad5e5a3aca60ac2e12f923ec8ff74d1efb8ff44641c4dc37a3121bb7dea33f36b1eac79cfe6c0fce3b6bdb85a69ca8fc31d18e10b6916396b6a829f55614449692f4eae2e1157c757da6cd862bfded4cd52489cf5d80df8f312f06a6878ba8318330210a13e0303690f7785c4e49651240b694ca75835bfe42cc2c3847be3545dc34345fffb1e769202c735ea6a3386fcc40d90616726d1680303d3e7188a12191ddf3046d9997fb1cdedd417e62418409d947deba08ebc053faa1cc41f90788dbc6f5e951ac9ee273bd515b48716b52c45a3fcf0952e4bda15d20a8ffa41b17e2a73ad7ac45f86682e305ce93c2f45daf34abb52fc169fa43a464dbb64b41e2e2a43e403f313a82fe0d8b75f17bed22922691ff2f353bd694d9edc65e7efe1110df070e16fccdabf1d08f14ba32ceab2a1cf2c01e1670a316107f7a8df23be343ec21551c1401785d294c496ac4a335c6d8fa0060de1152d420c768a32f1c4c0813cd9e300b9256b07646c95f73ed60149e3fdcadcd27c95df44bf811222a8ba1a7641cb2c09a8ee9a0b59b6a999724f9314e3769f57cb088c669a3e61a0aa95028058802dbf8b8159661a9571bf4378bf8fc6c921a1b35cea80bbff191090a4d5b031c90a0035c7399a2ebc0a907996d7472fa2f2f73bb9147cb8095d97dc5139a1a5827c02d7759e06683a2a713f3db1d768fb89877fdebd8c69c9fd2024aabbd5bf82a50577958d9acddfda4da012b88faef40bb95067470fc1a3f46eb21b2a2ae22f277f8778488cf27786781b55c87350ecd9e71ab47fcb39e3680825efb822390686fead96b82edbba3a0fc2fdc99cad69e08877e013465ca3c98e4ee0ecc4bc2605fd74f025f97e21974415c2a5fae71293e9e5fd5754350a6c588ea1c1e9ed5f5afa4f88e64f2d8180e01cb3a424ffee3c2b31437e0c2dbd23d8f115c93046a543ed2a6be8d023370e15fe0ad0663734a135892468b237095bdf1a403669b5787ecfe4265b52b938b8dec9091be3e3b392f2ddffb63674eda3d768eb4c5cd28f9e8c8f71a2a1ca9785e65457edd13c46b0f875e59facf814a2193de92c86ea2056137e89fa72381f4e8d835664e9fda36d646069702dd97a630c0fb7cc847975536636c7d882917a6d8c3625396004487d4475bbbbb192a13ab7145c7a4855b124c63698301194677af58170634d75f2ceccabcd420c918ed7eaa289934bb02ecdae06e020d775c54d104fc335ec94968f987c89e20dbe6adafd5a9cb2a2794115733a2abfad1685656c7ffa47f3f6b2de89e8363c4ffeb01c6e962cefadb0ea5fcdb2fdcf08568034ab3b3fbc8f9591181a5faee1418af0e8649f3e78cefcb48afa5f550db64724433607fa19716f7465a4005d72ac382b91133be7960996679866f25287ccdaa0436ef07b99b360926129d50c3d2650049dea4784b849a57b0a499e46f3cea5d175cd42d546d43d270d13ce76a708aa080d75051ce8ccab398e721806eee8073af5410410294163aba773ff70eb1b00eb262a2b396343bc0724b1a5392345fdea07f8c11d7cafd063123e384f88bb2267c231eeb85d974caa1844fca821351aa06b3e2228645aa618ec7c2123ca873737b7e610989c69d30bea5b2fdfad7c3726583a2ac03be60aa1f685b2d1b9ae8e5e2e8dbd226dde1ed0775d11dcb30686b5574c830f743fdd2cdea1f4ce291d18c281f0cbbe094275b0629175d9f6c2320d6564f8463cdee7116e8e57b8dd8e6dcb11cb3da5ef961323da51d9a95347662f4d9d16cd9974c0d154c9aa571f29c095ff38440f453cf94b0bbccf581b96ed4789099a9fd1ff47e0889edb62d40da358faea6c63762bd5a504faa6ec3c32f823fd8253349b5045dd632a8716443a8c042d2b02992cf5dc7917258d411c11cce1940124a1f25d924000ecf9bd0aa6bf3669c4dbcc14b87f4f507848530fda93c6bd2dfb444daad887e81b00036e1893f40b711dab933b03095f061dd047e395b18bb7238c8d4319d3c39752a325c263565a5bbfed79a05d71afa062cdef3a54d06e5bf2008c36b42ea0a2a6f6da93b09b7e18ccb58817deff0550fd811ae81cb8137cd95f9e327a1db11c1f9d9498e842e5734f27c4c57ebeae2a394d1b395d57c3000f5ef05e4b278749030d89fc6b3471184909b0c6a57bf393be95f2ca11637ec2bd01fe91049bd5e08758dee03064ea349ff2c44db2c97d4d1d6a89f6268372d82c5f4e7b7e4728f0df92ef16e6365a50531b37936636cc093790a5c9ce604f026c18f813fc55724e055f806ed8a9c5ec8bca814e52e4009fb814a77b2792b72e9a48b58a7d12eb04c5f997b51db4e60f75c029be5f0bd16ee4ce957372f647c926cabb6450affe6bca938c9a5cfe5478ecd64262d61384653822b54b7da73d974e89dc7cab3323f9c891fa1d8d81f944ec99d48d2dc8c60579c72f10557e4012001a3ab1c4986b0179ea418da12aa9b05103c6e00ef4e37051ef3e8feff881028554d2581d86bf40a41ad20d17b8e326900a799db663dd964d1daf82fdb49d9d77a995e1942a81c5a13144b472c7cfb3f5d6f3930daaa2531162e16689b129320c4b5bc9992506d670de16a947960aeee05c2f4c0095137660f48c8229a1b4cdfd38f0c97ea8918d0080f7b6239626ac9a0fbf9a977986831e0ee388a6424f493eb61cf553f453b555bfbc13b5253de621f7368bf9dd0a7fbb7a0faf3a29ec174cea4c5d2d4fe168980e4bed874db3a73c695ea235c4d545a89d7ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
