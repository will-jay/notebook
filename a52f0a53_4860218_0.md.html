<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78c3f19b035e73cab98f8c657651db9d19b9a87b3e5829f7091f5eef1c3b17a73febe998e54e218ec529ab47ae1bcd9d8be5bf0d71c52afd0b9737b70255df3d1e90638eb75d573409990489ec721c760e34518f6ef1ae5045ed2c54af23e59090a8da771b4dea09b35a267220c85ae6ad5fa51cc13e0718f5ca594ec08b21811657fffa3ddb1f39356d6a2d036a6c4b7f8ec868fcc6c71b2c047d4528d72bef111e55bd86ea7763bf91089ddb4f88d3ba432150de991f3f8f5a4d314c05fbf110cb5b9f3ca556c8ee9e5454dc59fe65a84cfa3ec85186a6684e61d33639b454ef9c8a311dca3f50cf3a2b7e8ed6ad58acdb1f2013d99277eeccdc99d212ab15ad1fddca60ba40111baca05cc9504a893e1c4b23f544bf5453654206a974483c28c5f805e8081d20145ced9ee3ef8f5ef56687ffb46721462cda25745145fb30267a1c81fdcb5ee175c0111fa5b8e838e5c8dab6167668fd6c5419d28ad437d5d9c5b26fcc3b802c30918112a7f2c2dad9853dbbdc1a434d505851518bbcb47413b0daa88f94a3ed1d94854c23735bd0235a4176d4f8393b788dad670556096f7a25fd1b8de971e142f49ccb2ec307066cd7adae6d76b811636af1a9e454fede4a751b0e4b4e42e7d6652354f801c6c43588754d9ee4f097238041a820fed9a001b2b866c445508cd8f90561fe4683c94beb912960527eee8e351e03e19da6fcec4134ac877e92b50837982617d2aaa2475f9d0ec06234cd153eb0677a540bad6a283e7dbaad6321c0b37bf4eff5667cd1d018bb4c93b804d29669f0f0900183c553de9f60e166f40a0b5881453b324aa155b065606068448e80e53ab7372c1a5e978bb24e0c9f625a9591739181be5411e43d97e7f998b142a41d2ac9cb45617cc3fc192c93f8d1b3a06a46e8861ae6e153694664b1de60841b2c60dcf44048db9efaf5187e91986a647aeb5fb8b13f24da423a2d8c89fd3a7856d7af9161e58a1ca3df7cc572a50cb3c18688aa5422fa1f403f05bb9f83dbebb5fef9f04eecc334663a5d83fd29dddbd11415fb2eef43deffb8cfdc780aa44d98e473dcb5d59834010c9d9862ed66f7662f2e1e291898ca364f48e1c4af03921e3c6d2cdf55aef59df3395719bffdcab2d5fbd4b20ddad021d0f83aa5f22ed3818aa8b9f55ccb85cfac35c5cd5303ec74240cefe3e360adbc92db648c6698deedbe62a7ed227a801ab0b89150d9a89fd5768975f39fc25a5e93040a700d3065fe4cd22d1bbacf228adcb395beaa14090bee7f894cfdcb11974db08a2347103f21fa53b231b801c4e2cf398889ea8b8c73f139f696f2bf6b5e7fb9d3d2567e77979f55038d58c6f92e58eb45d49ab2c782ffef061a65deb8bf5ebacb69d5663811c3d9606c420bb63fdbf92ea3273cd3e82219232dd7d56ee925270dcc753c5e585528fe9a246daf1fe811df39ddc7a160449e598cae83baadfcf7932936a0064b53fa9ea9fde68e28c918493c95350d54010e8913185f02d3fdddfac82591aa7b6a06147940095d4d300ec26879973882cce6e22704c19caf0f1068c340d309f9a876d803db77ccf30a269443af4f8e9bb27ea8a517b9cb1418986f5c74332e23e78b8bb2ce2f00d914273aae6a1ecfb1f0110dc63f6886746a517f1cafe0a501ffc558a570d5a839291f8aaa82365eb77e1f6bf81a2dac81f5d2585d1fd653210ed31b31c5c0b253fc5cdfe73e8aec4f1948cd76ea488dd3efcb9c0a741b4a982cfeec2f7acc853cddeac26f57654d259a844523fc87ac9f10e3674f4dd664e57290a3495ac82d558531762002197f89cc86aeadf7052cd21455ac7a422113dabbbd0a8183ee88e7e56fdf3b8c416e46cfe58f46a4eafc5c3976821d5b5a662244e250dd8d070bdf8aa66b0cd6707e68438796180ddee49d62210a9a5a39a481d21bdee478f120da1f59949b7b4419f980523e8daff82924d9df49856a2921ac48ba0b3e1849d193365ebf7260d7f9d83ec4080df107310aad0fae815fec633d87d48c18416091d774ecd9b4cf6159c1dba19ae46a623af394276d733dea3e5e06fe5e0bc88207a5201831025d1a2639a88ea0f4fef17d14d70a5b9bc3724c1cb5859a50498b71045ade56a625152999305d47744124f69f40f94db218bda82eec28fd169245c288b02717d7f4d58dbbdfeea2255537e7e22bd309803d088c19aee4445e8427ccbe4812b58dfa65cde560b1ff8d536f7c623f0f9b6d782e2903d761f9412f799271472351d9f7d28480fe890f3022b57a6bc8c7c09d0872cb8bfb3578d5d1435723ca127d44ca3598ee8788ea1f3e1e2bd013c08018022e5dd76aee95fe3ffabe4e609cd8bcb335b8746ab471a3d70230041f7ac807a5f31b4908dfeb8eb3aa74030b15d07b3a1211facc0ff78c6ebbc72ca5511bf57678f73be747c4ff7565530eac40188a6c9243e88d861cf707be07f9ff188bfeb437ae0c4404d9efd174f229fd4512283b67c5b531fc787c9fb13905469ab6fe61ed31ca96624e2afa5ac9c55a206d985dd1842b1fbe0c8b8b9e933801aafcc38449fca1ac4a7f2f85814d9c2703b7cd4ed750f06231301b67a2651ca7734e026c45824add274673afb3d33d66916829e5fad19f2e7bf1afeb7de413e9050155826d287a31b933c4cb1d03d3977d9c4ae8d1721314b45d326a6cb168584f2fa1beeece6011ed89544615e5d4c297742f1f8d9609891ee64407478f087c5c0c83f27b6e9512a797e093c6be78ff5f0e913d94bcb733c58d1082a5014144eedc9d429284cd991e421aeb0c7fa2175dd4be7bb51862bbd88dc49d6cbd96846aed2dca67fcac205c1a184a0dc210ae075a5f607e613f7c1f2532801d3dc8b15c2bd4f79608a841f7462952abafe84fdc41aeb2aee860192bea85f93e816c8abc67937767811adbc1936ea9c500224d8217828c206584653f5b1430a137557ab92b51d5fc1cb0f72ee894997136683ec420f81a4702d8c7935daf190c73244b4e20303b67d535ddcce790a310357e838df902cb805eb5591c03f20ce7ced34908edf33d81c67e5875232c9d07999c1cd99a40d92b774f1722018c2f6eeae76569bc906f761592f6b38879bef244a9adc58822d852160988371f98013b07881c563b4ba8902c11d43b04de71108a093d50e07ffc7b26a51ddc868701899da4d5193499e3ba4bb8049c4c8494a4c5cc0ef33bde99fdc994c349dfa44a0f3e820db241ade5c158f9dc70e8c6a3564eb844aa848d379c1dd5a7dd6f9bebb25d6f43b339eac90f228d233b5274b2d10cd0bf4a9116b4c69b14c751d929d7f62e054615813cdb246cfcb5c17ba57041c3548831a533d078251e1f59d4a321cb479885a8b79dbb783010f1d77db05fff163b63de3cb60bd72d9419814f56748525cc2f52ae458bdcec942d54700a40b27efa1dee8f7f0a07a4578857182036d684d9ada366b0d4d58a584076e123ba6653dcdd2c3857bd84af1ffd423d1cb7a10a82b7b144315a15888f5445ef84adc099cff824035edbfdf3147efefdda0fd9b24356bd5666e18386ba2beb475d6037a1f811e98067b3ba548d0fe245b40e43d7d1e92705760c769cfc590d22d7794a14b4a2b68c8d1561bb91b65c97aa840b8fece67ff00d06864983ab39b7f7a072922f53968136bee76d39c82dff70d2d2077b5fd44189e2d4fc59c5567509d0d0f209c4bb927abb013d887144bfabcaa0d2aaa28ebb73c2efb6310d7eb4860405563186126964888d03b308df0e8a3bd2c80fac97dca6ed8227fbc43643568e5ba9016210a4c9bfbd651853762162079e145acf1a37d8ce29cb659b391e6d3204bacb56aa79c4ca88e10e91641deaf6d75a61acd7fa1ffa6c50d8a56986c38d80fe7306bd28687023667875dcb0f53528aeb7c5124602018f2f8321ea671ca28d547cc47c64758b80ae5253e639fb302867cacec4161c82b3e9988532dc675827fe6bfa9ba004b6533476c8d77e6e01e2d06c76cc0f6a4aaca4c4dfa0f9e38cdd14ebb1afef328e91b3c4bf9bfc632fd375b58d4d007207830aa679e63f0646f032c2d1b3767098d1ac9d43af1a5923ea6aa982515d15036d886345e82857c695d40e0ae364bfcdedcd477f31623bd1a3a35eeb76d9f5db428b6c4da7c88217bc10f189eff5cd5948879b006d14b64e331bdc40866a73eab7f82d65bba3ea8165b58326d308a52bca12ca092378f7d926f6f780398907da1f643509d2e910a1899276c1bea6bccd0cf09a5f494392e1991f22e8b568ccc021b5631d077dc4f8cc1c96080f1644b6669e8bb5e9d883c5362b7d2740719e4cfbaf63e30ca8a060e235268d53615006df0f5afa23bdad0b4865f904fa61cceba9c4e9a79f71ad2cd7d222feec63b896a735d634059f2cd064c85eeb048afe09f035fd0602adf54105d0a3a17ee375d71e1260df5ae0c05e43aabc559cac5b8008c915d441ab713a6859c87ff06c7237be9207a0fd375456f351df969974dc0969a28879fe8ce22abeef55c2b6284b88f90631c84c3ce26c2f3603444c5b7a9f47bda7d8f66e7b2dd6ed4a1f43ae91a7bf45631fa1cf57fe6199877c357751e2f0cf2f9b9d29a5f653520a2e29f4e72cd3e6170ea52d9b50d3eb7073486d09ec3316edd40fc3ee4d8b6c12e60c38bc9665aa7abf01526b2d986f85a51d53f2f52fd65b66795ab25fa8c1041484278c8ffbd13fad4cb1f28711960061181127bc57c13c2503ba7eadf9abc7a72167d24befa4806ad805d3ae01f4bbb6f8fb6a07e21c49d71352b37b49a27a9118d3025e2ac341b066e64a41a4d8990d77992a0ca9e52322bdbf29685d3528086d33e18052045903ba6339d5ee3dd21498a2e574b1c79cdf0a33e1b626f9ee5a47dcace405dea994732a27075b66fc1b3b64d1d946820a94da74bc500874c3ec309fcd95910cfb2cec65be1bb7766b7db48e9bcc96c56f0d43c2b6d1cef63c6b80d39af3ebe1e676ab497c843b24462ed4e046d0f5b5f3ce91abdcf06c4345c684a96c3be46204781190db464623c61ba683d3b7692cad8c1decc96f0542c72cd9bf3a499bb3e630a004841508352dd7597704bf3a00206051b8adc622c3277c2056b28d9c9f26a5a82e6923212c97f68f9b3dba94efc29fd8caa21c76083ee6c832293a3b5e548f3ec47b162f8705fd064c46e7aea99108e0debe1660552b863793f108d0e0044259e128a9b8f32682419ea773a5f95c122e6fe1343cb25bda22c887e0145f941f5ea8cb579eaec03b841519df8a1cdd0f0d034080af69be7415afcf8d22cd00ddc09934f24114f4dd1e2225cd3609acf8ac83ece8c2d33c20df6d40c8c5cd37690167d56bd834ad19706926212d3ef3dd16109082f880b09feeb198f3367754cef7dd1ed78d147773588a4e8e677c3505f452b9207875125e8ef5752fff01f076de9cdec9a1b1fb1757abb824de9be25a65362bb10fd9ad16f6d4e3ef72dbc26808a2df15de608ae492830dc94c7b22828b9284d7be35a5cbd4843c8cbe58162afd31d60001c4013e99cd4383bbd9fb5f990e51a2ea015cc1141ca82b4cdf66bc1d1d130feba1a02ecf3fdeec565376b307e0faff5dc13de8c842cf9db88eca68954c0dc6ce38d0f01d4365089f841ff637924957db54158a7139aad515a663132ed7f0348a9d2cb5b0fbcecda82a068bb96eb8a830c115590cd5a9d221509758b4a2b1c5a8b8c92eccc3b0eae99995bbf9f84e3f67b8243c9059ba8c6766b046ef3b47e11d0f492d95bd35c965d247e58cc80004c9276a7cc7a9b29c880354ebfaa676e52f0e7c3304166f8f1545cb4aaedee81014265bfef133527ac727ee7ca9c24c09d520ebfc35b108033e9c7a13ef43930ae942e69a2530937efcd217021d5f4c048ef1ddc9b727a5457a01eae300bf079f1a30750b86f9399669e3466d670be5070992700fb918b05750bd318532052fb0cd90fe50e72eb6b6358436eb11f5a305cca236ac383f3d99ca449fa95f29fb52a272edbaf86a3af18b6b383f8144855108a2afb1e9b35bee96427cef7ad228f0058e1a81a64c498fec616523be8e8550b4f783c8151e05b83c526b3bd2ebdfcdc2d22ac036fccfb0a4992596800498bc9ac02c0e06627d7caf5d32c3b03878affdc42e07b1d1b542a12113d21819f4b9fcdb9e685b92b016b1cf1287f2bd509bc93d3622def4139b1d2d92a1509c26775443368374c9cd7c86f94d0ed77a999a6c4367dc13c2320aad04753689dbb2e28771eec3290de004b21eabe0aa56e59ab6744393b38b436d2da774d7ee9b4f04421a32ec18f9b40a6cf40db76d190f744e6be7c8923b292ad314bae9b0b09c7c74b170987fee87e6dbd3ae979b8e95c23cd53c9d885871ffee01f0994ff474146f7c1a2db8063f8fb51fa8cfd3ff88c3f7d7bdae20263b0b3c3501dcfe50482032b9a4ca97cac0e8638a5d3e939e920b0e32ff15f2cd799482be0fcdf7659e23efc89b0b4cc21a48612800396c7498c0a6c224b981ac1a214169397ee01a98af31b9130ac1f062f7b8dda2b0fd60345368dfab59f3274306267681fac5a4d3e01e02702715c0ff6a677fac343d5ac063fa639052ce2cb39d4091e5895fd741ef0e84a28c2f5b0eee25155c465fcf78935fd00104a6d8513da741e987ef1c41d1a55cee7367889f76b3decf59f1ac378e78b9b741721f2ed0534109d229c53e7a5343e78d3d86812f8d0a752f5f54fd9e217de58842e8cf5045d22849629b4f370d7293a9d1a756e2435f5158a9d48c095678f0df6730f9b60b5b5777cb5c8137fd786d2c7531afa0aab974c402affc51a7d293bc040d73f38916fd470a148f04983f408c655a5aeef444a1350ddc908a5f2285b900310599b6ea10175cd2ac0cc7013aaf16395bc930e86bc22d3dae92a5f7390bf0d7681027300443f748ee70464afe0637bcdc3583e847928ef0ab65e0296284ce9c26dd68da13abd98f5bcc3a35cd5f51304264e026255a20dc2d717fc0e34c53e8502b358f3a4448ea3dcfe5747ba328d9535186c7626ef21605179df4903c8de2a70a5801767ff7e6b45dfd111061ed7556f77d6d95db81097ecf29d9bb2982c7936016c7b0ce8f14b4a3fef6fc85293df7abdf6cd6e13aa1436f336058f6359dcdb4f745ac250f21d7e1e618de3e8018015bed531042f87dd81a2dbb61f84367ba42d642b2b3b61964d1a070ae3a216e4aa2014a8e26a3c68c4e192e45a55b8cc69815f89a9771ba4acf07191b132bd78b744e1778abcbe874a13cc2237a9a046f1cb9e5f612f08e72e3d0483ed9c6681f540752cbee62657ce6fa194d33a6ea809f04a513ac8b73b0267d2ccede6459629285ac75d2634db8342f2b8474141b681f231f94dc960b9ddfcd85db858573f1667fc63ae46271c8cc0ddbdf875faf90e540b3f6e330897a8af81f71f1ff4abf89e16fe5d9ac5ae15175b9cf77554c47d7495a15e512f7a5fc80179ce9df28a8887fa63859ea342970a395e59c5d28f77707ec620d8b8bd9cf19bfc61cf5e83ba6d45b1778bd8ddea3b335b66a56d823bb3159881e43471b992a2ba0dffd27346b0df050fed710ed62e5cc03ca47def9025bd995f8145ec50a52de52463097e5012e1a9222c4486da5b124343cc4f6af0bcdd1c4ce3577c8b4b03aecb58b8a29f6600cd4fb3fd65e40633cfd9d7199d31d926d8c2513ff54100d20a162ce9a853e8e8aec71a03f2513b7a762f69821df555c4b28eb24b5b9bd7d02e04fd3fb6dec75587891863c0598884113011d6191bb45b4c2602f1bdf865c047743a44d3e80a768ce8edd75a5fd7a747d1d52cfb26d29ada92f378d9ef1d9c4effc8554653a1f3e39ab1e924c0b7fbc39f2fba7f156ec35b67b81828501be5bb6eac1580bfd7f3656c81df071247b90fd5e713e7df5fbdba52ed3378c73832bfcdcc2627d2daf5e5a2d22da687ecc22096f5a2eb20dc1a841437f42dca973818f40271793e2d5c984648ac31c6d1c359ee96e816f53cfb91eea68f4f28dd1e3267bf2c631b191bdb2e2d7aedeebc4fb36c40d372392c8fccf95a140c39a75e2de16d7191a2fe58a6abcd950dce1bc57f5ea95e4f452d7de3b89be39a5d2ebcc71c4ebd9b902dc4cfac7be24c93af622c9b32930e7cd8d6b912c201ec9665454e64ffabc68c1336974c181cf0e268347c81761af874a960c67b2839fbf3ee0a747ef9c86727bc342fd4dad74232993afa551a475c44f277a281a9ab6ac9916d72a95961a65d89bbc84fa567f98fcf8814cd237e8e821b857081fbb3ac1bd65063b5e6f07c14b824dae1a7b34ab45b206d3ad730a9804a757c16c53a92a0ef53e2f433dd949d54339fea99fb27dbee1a15edcd437a4af902668917878743181a87b34e19037812c1bc45f804c358b08687e0da0da5790b8171df03cad87dab91705b4f93d42d99489a8369649a3e21a64773da1643de435ffb54d7da8a7fa3698e05575be2e61349072dea1e05f0b1da04fc0ea11ea6661b937d09d983e87b2b72d0fe5e5fb84414fc14d99a2bf132e4a43603fdaa040b63ee50d64721494d5c26742f946254e8627111c52cb6e34308c8dc54cd55e4c44fced9c704dc073a4f235c8d6ba7a90d7060d83e4dae8210bb2795aaca2ee06ce3c37838b34892c3e2fdaacf4e3ab9dd77ba85f17b33f5f494dcefbf2fbb96d1c8e32be23f8cf8ab16d11043ba61b09a81111feb0282174c077f68a697c236ae9faed65f0fd628a7849a66850d92cb4cd0e4e7e0b63773af5f38041208f9946c5f97009f5ad8fcc847db42e889ff83350f5dd2f43a44b749d794532b75343fa7eae215976fc70f9a0a20b9df31e586a8ad59b4e1237cb555e4a33f7b7ba492bb4364ecf4d3419401deaa19dcd9ce195376c2d1beb525ac5b4a8b90c50d04b20ad75da03bdc56af420882af3611855f46384597c624169c4f667a650b571722d7e519251c0eea174f6d97a15ef18b859f07aa60bb2c9fc3a281e20a47fc59d4f6851208616105281697ce36f499bb9de98ba147dbd958531f2168edce7b527524b6234f3561e6df6ae89bbeb6b731598d9877a205fbeb58a8bdea2f312927e7b2a50c2141ac8454cb2685fcd36e9f2649d4d470a6c6840b8796ff52aa88eb71c3f4bff60ca7085cd73a5a22a379738d23da5e989fffaa5867d8c08f8a5c8096d8d09641ce219c2d00412aa47ce72b7d76dad4f1394b8021bfc89858090d0f664c513dbe3c93bb15eaede1a4fdbebd80fb1da29ef68d7ec375607b10e59dfa58504d1ba181d2ef58497a1cc8781334fbcfdf8331c9ddfd090d0479b1afc06336b3d8e61d6b749df3a86210c41483d48177165061f6175e412f6b23590bfd386f8ae475e5ec081eb81af03f9dee76c43a8871fc9e30e03c25eaf1b41e4f7a69fe5a9f62bdd482131a419e7f6f097617663dcff821793812d3d8a81e8b549e04b20af00f7ec007f673a2f5780a49c513dece1bf70fd3e2cebd26592a4cd845f6ced2b285e9a2c54c600c2885017dfe7e8b0a8a97c3a1efebc9059a1378142df90e43375996921ca1d90feb6de2df819076b42ffc9770dcc844c2f6ca3695b477c92b6c0de89ca62da1f1299d118f7c6abf10f48c872c6fac64494aeb153d5a9c6695c30935e020548fe7b0d69fbe04c40ebb82b0dbbb731745d631fcd47a80fe143aa9d38a4c63ae0fe3c245c5733cbdf8aa5f91f561e456442624eb0c85e9c08bba3900541096382f5d73ce8833924aaf705383ae7f10b7534839e9c714b9b55ed81ebb1fa0f1d1ead06c8d2ccd20cc4e6af2d4b5ddbfaf74ebe6b1e4d52b711d8a016bca3c07b9cb3a508cd198dccd342cb0fd466370cf17541b72fbb131d2632ef9d7f9de8820a93017b4fa8ecbb88cad845575386cac5903c876a021eb9c4bc0b1f5a7e8fe437817fd600b0d871e0714246ab18bd10640de45a82080d39b51d018257d48d1fe812a079b83f005de217dcf459f0345497537d73ecf1d2de0f4901a9eeb88769c8e910a39b6b58ca37ad26cf5d4d94309cbe9540e34a67bbbea7b8a2667a3d4ee82f592429fc01897ec77e08a82a7875c2cdc3ae934bcd8063265e786a750f93ec0f2e6e419574427c6a5bcc0d6c1f027acf5975ca3bdca9ea683924c8976e83d218cc84a04d3a477235f488955954eb00cc670520e3aeac479d2cbb8f69bc33fece457f0363f6f09a2a21669d4f19ba90e1449ba977b6a946a85c676b0bbe9ab7269a35e2d161dfda2fe4bd72fbe2ad46537117fc5d0da5ea8d86e955860b746826edee7f9510c969afc551fde8aaa107e8f0a38ec459f6f00f3fa0b55f3d7b940ffa9bc45720d574319e2def578acbd04ca6c8660b529e546bda211d21d3fcbf58cb136613f3cf48e5fb13983184be09dbe13becc6dac5fcc3dc813a5a41c6400cdd1e9d0df39a526f602fa5704be82044c13c971b53f1dfc14109f227e21650c17e2caf7ca3788e10463b84038451a512db754142221d06bc835e4b7bd1af943ff21d3f6a642452471248ffd31d06750d57abd4fe1501d4f094ec37947a7e625e9894876cd68aa7fc57ad0ad7cd1e653940742d54ae13d4c034005e502f50308e5d4811f7580eae1955581254c21266359c216043f3b2d1909ddc706c35de6358b2e3db4fbd7fc3e914c1a93726690327ad1aa1b8fe13998d5beec5952c9eb0100899d4a4af4141a69fc05cd2b66cec41757b66b061842a4f8c9795edfc81d2415c83f0ebb3c03dbe45c982b152f2a3a8087ab3b81ad3817605664b1a94ca778fbd94c61cb9e69ea2559d1f050e9a1cdde1c40fbc9c6256dc6362105073a20ba108ed3498f2861f266dd9c7644eeba25de52182b8d1c8832cc126a904ba4ecac21e5c9ed32d7178bacbd19b950cad1604e8e02551eb109abc2140817ee8475f104820bb55d940e8c579473add819769065592f9019e58927553483a4dd9762018d21279f0214c8db7cac80a6678d33ad33f314310ede73edfe73c2d12d0e80ffaf8cb2b70fe737b9da2f20ad20de2766137dc0a9e5ebef0e95fc69f8dd00c30529ea91ceb531daeea9c465b6b0a4808048d3e5b38363bee98aa7ff6de3b1aca2ed81a52c210fdc60b0290678e00c7a8eb444888f0ff0021e35c3145857e61f597ca66c2abf3e43c1881e239e273f4303df9200cb9de70d124576043942a936c34a9e7b4fa23115a6a09140893b2f69b66480bed25d3798bff7d31fe61847353a51fc590fe7c9ea3ed7da9b7d33bb7eff98b35a012bf1ce4498d36e9b9fe0ade23847cccfe2f6cb9f4dacf9612c7cce8b261621dd9d44db7db8a23c70b63657cd99e570b16e12faf22bc8d0b84acc72ca99166963a69e6512a75fa1fdcb0af5794464f94fbea2d593ba15b764c3b8a6c11bf1d004bb51b395b8755e4156535e5658bd6bb59e32bf57eae2d8faeae8962c06c67463f7c44a9b01cedb7816029703a186a09b1ae4b087d5bfc7494024b39690ba0a6bf780b7c32540daa201fc9cbfb17ddaa5efe51f9fe77deece68d891346ee2d1bec07bfa12f0c3ab676f8647edf7ce54ede2c17b73345550202a97707553bdd2238a76e73a9854e45a5c97dbafdfa884c0bbd34c444a80750f5901d183d0519d8dae007c0d370dc70253d6958614b5a04c44952d9890caebcbdaf4d96af95f24f24be6d4abb5f73a2a5bad4dce9a52c60c10111033772d0bd54941eb071c548d562f735467beccbeb9553d1675815dbb729c7cd6d2d973b1a7ba0b1cb3a223dc4e4f0a31d8247a173d7a12ce08ab5764e76c180a8bcae6c6015005547a1ebe6bcd7fdeca132fef638124e52dab6484cdec66a725bead7790df3ba1f430f86fa1c8804bd6aad03d7572cd9550ff4a3f85bf0d50c6a7433f48d0d43fd43a056d3c21550f2623f2f66848aa86d5ba8ae9e9e99fa1215db90316a2e5c02f5938f83a5778738c09d93a8a6df57c08cd746991078b06530e759c0941d962013e1f9f695f2ce4d202376d9ded2c8b9f974c015bb7681e6399fcb558a7a4b3d9b04883c985ff897da95a6c7af3879a0989fe563bf042c2c328f62678d6cb41d3c2029395a49ff0f6c76dd92197240cf39a9582ad5730e899c29e99018cf298443f57cf5b04779ca924d7caa21651168482e53c06d55b2dc87d42f79eda9b68bd005d0eebd578f92fe332a1cb702db9473ffc55bbf5e8fc47195d01f2aef49e218402e2939b58648d36ba1b7c2fe63104b0dec43a28c371182037eeb1a5e120b049bd2f1931d9a0d9ab17086e1c02f181dd6f18523d36bc95c20f135c9988613442aa5bb5fc5fa7c869369c0349d5043c41d2d8c95238060d65d9d1a3dab4a55a2c893789761b6077cb98a49d3d0832bcd37972db3f407267656ed6aca9ca3bcce133f15de3b7f2c2138270de5c7e2c71ff556df7bc04f18b4793ff111b7dac0c121990fd8067e931a1f18f08d7cbc38e20d6efac2bbfbe9d80d960cf10614c4b88a4b35cd33394277af821737c616caee17d08f032f14126a0d3607a6fa42232dddaa13bb778f505e5cf91267fc417d775c5a50a011d1bb1cd99ea30c897b1f7e91c7cff9c6eccc51505c664a84e2a3d700e17f4a56563a96f22c57b44cd6150dd8c2e984f8e4a9d174c0cda1f7376bccbbdb32f4b3a2200c03cb3cc8f0b6bf1d50c083de8dc0b63dfab5bf306f062ccfd1bb1ea5c235522d9dbfaa06738355a408e1b3a0df426c934e4da2d3ef96a14961f5e7be365a729755923b8fd4e16a7650a1b0d44210a003244bf0b87d1b90b9f707f3489283911d8e11a136957914ca115dab4aefe5e7dcd23b7c163cf6c399e75f75b577fc9759649a8261742ad6c48d8bdb49fffde78721b1ae906d51b77b92b99b8ab1f9bbeba858700043b71328129b51123f57745b5b54d95b3840e63f11270fb1bc7e6e62031984ac83a162ffed8236334aaaad57a95eac9e32351647375c75b600560037e3eb2702fb47d4fce0b5f5de214f7a578e7d4a63229bac34e8b782e12892a67283fc6f4c75427e8265da8b74b2c4ded9951cbedea9d116a05b469d86a786dbc96cc2a7bf0a9b45cec2c8d463e511132e9abf8bb4d4ab5665c18806557c348d902d6c14514842c61ab1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
