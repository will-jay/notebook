<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3d1bf871e490823995bb9caf0036efc3efc41af1656aea727e53d7692c8677df8f8e77e90282c65c4608f7e0f3590edd6de116919c29ed2260310a14dab6f06a4ede39cafa47c9dc21a0c81bf963739354d91778ddf050e52d899f890b446376fe9affda2a6d269f4dcc73ff6c6eeb49ca0983be5e6bbe9b7cc8634a41c05709e895172db699d6a1fe2c02739ebdc89537a2bb0f618c53062379cc4f5d02059f438df2bc49b4a6f30e2cb1798b1667710f3ec7aede0a891d38fc1cd146feb404cc8e23d408c9e76255f226f61b951bf1b3006d756a7212f350877a2395af6911cd3146c8b977f40d4916175680b38f42727d528278de538fcc201f1be9465d06d8a8216fe4463f83907ee860e8fe29451f994bee7e4f5e6481586ec9cdd6dcb64b494785037cb31b945a5d7e07aaf625bcd8ccb3eaf5a56577d7bae27bc36e94b216926495a35089838a450a061bf269dcb754a5039fa2752ed350440f9e16f0ac1a6e612deb5a44fb678371f487ced6a14a777fd83208a7946af0f738c99345f90558c661371b77b66d9ef428574936b1e3377a4c98c5e1ad9f70c3d2ba68d95518fe6648244d10b32d5d747195e827d649f9ebbf75cd53de30c145de6abf6bf36c33b416bcac8a3a20c2d76486cb52038a4bea7ce1d56c5c5e877df9a470e2fb2a376dd75194f8e40287591cd8a2318bae12f0b3d197b71818cad98b4f969e386d18820992b302ead0d938416528314497bc245de1688d84803c0a370134f4ba871e9c9632c990a62ae06e4e282a8f9427b9b3a34770c91f38f1a23201bfebd71297e2308bfa93306857bff785df635948071635f5732820b134d5a6cdbb7f846ef2d90673f317f27bc0e7780b843a97a93510c176e30e86399f28fe55b1d230ea2247abe4511883f9dec438bd27bb39830d9af47aafd4d4dc1fe659e2b07cb736a678f12583ba50b748cceae88bb99e08118c4141a405403b94d8e42e60ac4b932c7293a223bd8bb29b8b4c986103f45ca0b31dab84150d39721298dccab93e11e0bde64008a2a95fb2f62c94d871d93a171f0f6a0021eb4b860b9ebfc62cd93ad72245eb4b29d334a771ef0befff25e662668afcd277e925aaa5b34db53fa10f954d5f50abc939285559840db79d620db79eb59f717019a4966664d9cdaf2cd6ec3e4593ab0f2a956f6e86a51d394241a60e817dc2143f9c78a6de85c857b6e74e8a08a1301b46beea31e8b896878c5adca55e4fd99acb57f40b9ade7386ad774b71dbf63bbbd16a441584f2e6141a1f86a9623f552e239c2c13968d44962032db22844d1d092aef29d74bd7be65589aa6186ca7fe82923faabdff5ef7879187d64315811c693a03bc952c0589a4ec189a1c0d7efe470736576dd730ac80d2913cfe45f6e22ba10c394e19187d6882137434776cba96074e94b4ad4b63401139a552a5e7456916c55d47a3710b45bee3ad0a02a868df4fb59302eab20b3f4beb245375d6d8e0938d2a4a27d2992425262166854bb64c178ed5b8fe213bfacc52b5231195256a223c06e1efe1500134196a5af29ec4af4c82b30d0b033196349367cbcb3df598eeedaeb63c729e05e4649ca007cbc1e406b308750676e66cf3a7e1ecf284237a6a60f95d64f8686000f1dc3f5fbee3482aed59c0687f612f0cb66c0d1fe09da95f75cdbc3fe25e9e4fc4b44122defd18c60b28b790c70501a34aff56bf55a5b14d2c3a19038c23ae87544b9f76a9e95a39191db864dc9bfd8142be856112479510345e245483211b728dcfadeea841756545a93433b9057020d8328cc6837b29910adc7ad6703e6f1f6949e54fad847021deef983dcd2cd661d9cdc0039451e9a0edc6460ff111823de88489d9f19f4d8c0201a2c7abe40da241b8c6ac1f0b6ab0c542eae7dc734c985a2110f09ddc0110c64a07bd02a15613d953fb1a6c225c9883e958cbd40dc2dfe6e6a40f3931c32ac7e0811dbbe6e743b13c14876d336b7f3d9ac2735bf800463a5618690275ac9df9d07b68e06a0b70cdfbde533a63e6a460feb965fa68b540bc7284a7e230cba798fb1c901047392af59131a017a6526b4819ea126fc7372879bd951cede069507ff1ad146d113d94b1063067eea6fceaf40ed79cd258978716d249526771467fb30cbaf68960e9433f4500700673bfeb790187c81bd7b27484015921c3d6cc69f0b8e135153f5d22b2db8ff61349461f4edc738a084057baf6340e74a42f503bac6dd3c764231618894f9221b501ca6822d968115ee55af8243560f9821ef0413c5bcaf3645c2d1826584a1236eb6477abff93017bf0e6258d25fcbd6abae4f95d3d3ea609ab0f51498edbedeefad2720e9b8c708e3271724888621cae02963821e88de4c54443eaa72a20b5a70d33f309b1e154739135d8c1e5856edf93b21d7b1e699aa5b1c9b75c33507f7b74a154d02c570dc1bf98356273877177499f02d1192bb8d842b5dc8d757b8352d45bc150dca8bdfab007e625584c1e26b3c9e853e39735c5590573d9701765d93003d6e5455b27ce2af7a9305a3a66a6febb0ae7e7709a0b5b1982c6d03edcf02769bbb3505628129dca340d4f3b9a21bea7e92152d248b3cfcd821f08b97b5d16dac3e8838d4d6fdf69c3f886d421b1cf21aec9856f3792d9acae16b1508e11ddd7b21da891acd08bcb3dc026395341bf853383deccddcbd915bdc030616f00b0f9646c311b4a84980c1d27b2f76ee4546785e73c265d6aa43df22c503b68032cf2c1ae6bd88bf2666afd3a4cb2c4dbba459e03b966518bd7519c4c66dde02a2ea0a3841952c9cee3983c220e7919207f3fe5eb0164e39b882358cd79fb478caa58f9164049399cfa3118368f460e010f487230e6271b6d5c3375f0bfceff7d6bcbcb30949f4277906257ce6065f8d60f232d8a1ff9ac48939d8e329b43082bcb7bf8bca122c7391ed0179f28364f7de931f85297df1e061d67937cb0c94430c0c86ebf96c8087513d76688a59b11d89e33b9c8b66ac9a174ad2ddccf2d3d1187c802e88cde680f785338378bf0bbaa1e0a35e69aed3b3453be2ab2efe442588a5628b959ebdc6a4becd84d51822c33319fccd6cd4e60c36047f35f93fb3ef489e9764724c01db55c2a77ae282006da25b6e9925356b6680cffda94f4d1d48d2467f1ca7d90cb43796afd35b2d1bc2daf3824806c8777e306b91df8998cb051c2423dc64d449e8b1ff377095884ec2bc750d1435c9bea11e0520d2215c152925ed991ddc1c81019c889495e8defac57eccc6cc6329f788c81c6ff17ba8fe3fede5a36b5e49799987b4f9801e5a51699bd78968f4b034e017b6b3ea4376329f05f05049d63d2475d4484cbdfe53f5af31208222742ca4b0d20c13ec8e60a981bc8bda8652e1fd496dda41861f48948cd9297c3e2f896093873cee4a9de7398d1a15fbdb38f2cd4dfc9b8d15bdf76cc167f43637e6a5bb4821a0792b7bbeed3c35b4956adc94235a96d2c6f5f082b2b7b17e8171867903c86d2ef9e27672d6e326a043b0532536899fd861ff2f80fdd07a500b8d6c0f5b5c7421231f2d136b4acb8a7987c2a9df2881501f18ca1de89918d16f0596889047ef823ef5a26b2c7533d0d82cf3bd953b7a9015ea73e820f72e2b14675a205b2ffe18696089cc1072811801b8a2920e61d97a02e8e2099b7946262d276f4e63882ed91ad211c7aa8ca99f57fe057c32e7024f1738e0e50d8011369aa4d88765e59b09c6e1edd47e11b846be2cd335fc9303d85a753c06888811b29e4d16a7d8b8f09dbc6b1d43ce742d43e39a8067e684fcc63c2af5889b51988e9a61f6556c2403aac356b5b109781d4ad718e9c71de8d952cf068173bb4eab3952ba10b3f50a35b16f3213722f7b1e263c2ce031df747fb98b5315c0fb5f9c4256248640a8e559702b968d4bcf69076570d6e037d850f5239525133413e391ebfba86ceab6541ce92d83dbb7019ae3374dbc2ca537b83c4e722f2be5e9117782e454d197625cb48d4f62031007826b2a7fcde69a49f2eeacbf2b3ec87f76e8289241d6697c64077cd4f51c0771c187060de936bc9b81263f0043aba2443146a753d898eecc35c85419c0ef2b0ee02accbbb56b16c4d1bd02f210b1fe28b7af9ff966a657d4f99e530cb5ce823ef588eb0c1ae27f47cad69627b4a45d47d48b64306a929a302ea147630037d9dcca0c0bbdb91a26441b22652efb14a6aa38a5bc6945dd6cdd8fcd7a0a9d1050946bf4d1406d3a79dfc007438f431389e1e069a7b31f88e089d485582f9fd3d83af6cf865a4fb181c7f77b6611691b0588a56cf9aacbaa7b1bba5d910f42e735a0d369ca0a7883189d2f77449d836889eb7d2cb9612b4a66dfe5c63b59ed838ce1b80c69d4f652103f66a352ecaaefa6d2d56824df9c91d0baf7771b0965870fe4067ba4c482d27009344e64a96fe54cca6e28fcdf668c8cebe0a98adee0b2ded9dae2266d687dfe32d514b39f88948085d50f3576e3759f0fbafff887cbfc7ddc5104bcc6eb2d3adba6b5e57be6990d68a434ce81ced8695a70c8382f97a059851ee0bb1806efb2053a365cc948de63ff5b3ba53b9743d71f04c88dd1405effd6c97b3ef5454a8c8b6b94fe264a1545c33a805524a1f95c8e4bbe0b26db6f67160c8121b338e764bb8be69107d80d3d760e8d805a261047d74d5657eb3b657622fe8c5a51ee763643700953475125549f9c3cf43389b2e671e9025c9bc447bab7423abc37bc98a0ea186c7009f4b6d0076ee1aebb65ef67d0fbd90f9832625f054dda434415f17d0287c1506396e570c1f0a9c2019e1b109a9d649b34c63fc4a0433aeaac2ed687e254b2fc08de7c5953aa6bafc7318081da07161cf25f74438d7cf4fa7f859955cdb51a5c22a9c316a6a7d8a800c6cb4b3f9080f396ca13066821477282cedff37e5324a1c3e8617aea9ecdc143608534a6f8c04d15b6b63cbef339e74bdc8eda26926460c8aa1be0ed1c7671dd8330cf807ec682b6106a1403fba338d2eb4f0c528b39903935cd77305ede457479c5e1d2957367a2bd2046ee6e422c13b8a9f2ec70623b13bc8de5c863ab7220de62417f2298d134bea573bed1d26625109f7ff85d6c2a685f4441c94d18971b8e10c15278dc21f4f03312a54919b3311004c5a3dee8a650462bcb104e779d4c920a47e211016d651965c987a90b4bf8ca1cffb20422e677bd348d329857409b6ae755fdf556eb0b4033fc9f648431b2badfcc5f5eb9dc22690b6c2afa6a94f9388c93a34991d57394e3dc2b475fc6567d05599bc1eca1ea46bab8aef64b083200c7d4fbb836a05216fb4b56bf01a31d5583673dc909edb0870e2bc647cb27b8ba78a6e934c0193f69eb56ae4bc0fd3d1153ca0c22824e64cdb527cf5a661b9ba752c9e3c1e7f950bea755911a27a385a031538ebb92d36fe3e43ae67927a522a4d68290b3f9b639fc3b077ac519d6fb0304d3b41c78abca1c24e09dbfa959f2027792cba79393690a10041cf8301419ea58221bf4a018e655c9e2ae9210c5a1e944ed24b2944ab2b0b4b59608ff9301946971070b01f280f5c2a8da049fb44f152523bdb9a3dbee833f10d9ba8c83177d2777155f5768d3014d8458648801640bc162f295d08dd1397a4a6deb623cf5dc46e854d6e31be7b9eca29c14b0d5b59b1bb5205fc8392e0a3c9f19e1505b6558e0158b57cac5f19e91dbd3f7774eb82a5e7612600d93afa558ce57136260634ab5d5c1a913643b49de2c42994672ff5154ecfc39a7279354e96af39f0f9db39d5b2fdf813831137dfb96030bdb0ac8091cba73b3b6f48638d14104272f507237057923c827c2c6cfe4c78e8685b36a50bd8ab771f63f27a9a62fdd8d99865404804d10431385de0bb1a7f7038cb06cfbf9f00af6e721e03ab2a61877360a789b098f0bb2f3d9f24ab594780adbe508b53ae23edfaef49362fb571a380606e874fc012a504cb201a68ec3e637bbf5390df8a7943759173b58757d1c61020c843e73dfecb29de21d9d8777b48790b8b42d16ce22ac58c1bc0d5c3c7f22fb564fef9f178cf59fca217ae07c7033820640e92d6898bca776d3859d1f2d03425a60486763306c33bb3f7b580b748cbeb90d91b338265c225083844a4bbb0ba21f34621a2085f7d88bef8b54447de7e2c812d664f1d0a1bd085d862ad7b88f3d4162964f7a962bff61f843dafe9745d9a56a860c97ddf7f6a3c36c16dc9a259b16b366de14bd462b8ead5d9967b0cba37558d273b04875e857844b48996fbf87bdb510ce205c21991b8c82c087e54ca653a5be800834e1e859aabb4fe2b7fc790921271f9b908049b50cb3b34bdcc4b80df17debf104f3d742b72cc2695b0b7eed04d80a905ebc6e4f837ace049ed94d61d0334a5143e08f668bf1a2d1a3e021f5f0cad2ffec23a953397ae2d6af911592cde6161253681fb52c3dc3b7695aa4099f39622088a57d4476c9ffcb6b14fd2a597bc0bf258ee2c362bebea0ab89d1c41531e4290c15802c2668df1db60b4f154e6ff66c778332c0d181d32dd68217315cc32c2c900bde392ff335f8a0c9e44371af4d3eec073ddcd6f91d22a141f510a6ab804657a048b3714931e9b310cde415ffce91343773c8703bbd91f57e3774f36f31812037f5442728dacc811cde4e0eac2ec31a5091c0d5229d00e6b671e5609a2078713504e0c0524fe557afe25123f57d5a818c89420c7ea894be439c52a66e927316ce81ca101515223f30ce354777eab35cd8927edb70eab45408f76c7c8babc21c26fd1e1cb6c60d6abe52a9d92add3f4867c1f5770f6c990cd1bf22ef9a15c6b20e3d073cb4255292d75976f8be026b96907bd626113d7fe134821a2c3f12e8554d0151fb3b4756f5be65746cf1e013e915cea98ec0b4e293ec2cfa1de103c4c29b2bfb55d81f7865bde3e8cf7deb2c70252aedaa0aade2e565d475affd062044c1cfca463b0fed807949293b1c58010156dc5b199f18a54128cd0124f63758fffc035fc452dfa54834b0568dd6d2a7a7a6cc30f858c1ac6bfd852acfa997fad6fa08b00ae38f656a15fde23ae664c9947fd528fba04c53d66831a27021301bd771f03b89723675f98d74a5944ed8b0c0f5459df578038536f7fec305d0a84934e4bb698682e189872a9d1141daa5bbfefda6ad8f9c7b848dc8974de674f73352dc61810a8036a3e5d421abfdb2425f6483cc92937495bb94ac87d5c7c4946f2caec7a00084898f38d33f63a376a231cc4b822b379300f3e0f470c65cd0900b22d5b30388ba64943e40d31b64f7c076b31d8248af7e0e53b9d0d9bd02661d54c43a22cd256b9e7854475b7b6aa7dfac7803c891bd4f53324e4beb1e250906772e965ff453c1abb82391b81add3b67ae7322fad79d24344228beb7401f8082e42b7044403006426eecfcb4737b3b2105f2547479483626487baec236d0d895212899ac1c1a0a01d61a953d2f75cbe24ac4566e534a197adcec622972fea97cd0d0360387216939a100bd72828df36526873b2523816294ae3b0f203a61be873cff52f9ae4cb5e3c5764a42321a078285c49364863b906bdc7299c3a1bf8ae40778fff2b50aaad4ff325e68e41829c50e8da27a494a9aaf288ec7062318d16e4ce7cac913279f263afc8f51ba2dbef9ea63d6f75217094dbb4baa108b90ea9a7a83d87fe143c9b78e9b5a2ba658d054ca55db05e88248757d6362ed5a0b80d5049868f0024ba10f1ceefbf7a175368a5614e6eaf37625eb3ef22c467e993890e1db2b37ba907fcd38176d11ab3b043549dc6439d0cb0638029c08b5f2af270ca8e9b225b275a4b87f5a6f395eacd3abee3f51f4ae1e8c61ee520622a3b2d4c1ed2bb658e70c2b753e4e983c3fd6cdd77153ad91724113f53648e24447c8ed6c16cb32787a7814934911698db5b7b9193e511debec7a8774e70ccd728a8894cc736f61a2aa4e71c0f82b35cd190061b5e2e88870297b3cef78e94979d2a73a2bd84faca35fe6c474aba9692255317ddf6db1ced5187f7ecd4e2007c05172bca3e6074c7054561b92f01257497cd5e337fe90d32e9f76ca19a5071dda7500ef97a12873e8b5c77f6d4bd3d5d41a6d56cd9a248643615a74f8ba3ada70f7a77f4b8940e72fe3bfd65b45f7c6452fe654b5ccdfffad82ef8a394e99d9c61dcecdcf49709f9acdaedd54a8e06072dfa82b3d3df7b1b1b04b78032dff1824a3afa6643c0f5e45b0dd1a72965d801b62d50c255e62cda8b4a6a6b4eb92f45f3a1d4995ac1831f894f3a90c6e49d9c5536a7b66a31a86d2c98f61cc47164d6ee6def190573b7fc5988dee2d9a9d560008987e52d7f264469c8f6126deaff5ebab3727993fb2064bb9d8b853748aab00b07c3be9e71623a65834b814a9453530e08776946bffd71ddb72e18cf9f2c1589f3d5fafe8eda58f4675f9d9a0518dec2761368a3cb5ec9958946968f5c3c80472c961c60d57829cf36cf88865cfbc1ff83432340306a88a0ce3c8b71bdbcb424a3a69b60d2adcd774d7d6366a04bd4598f2aa30f08ae23c216f33e898291247ff094ffef0c5c3da0fb08bfc5fad0fd958127375d60e30b9d386ed3930f61f6e1f074de04a1fe09cc07875162c2d5432722a2c60804a0e69e988b3b968288f260edd0bea0456b83a6bf4dd6c5c91c5fd6e66a00ad7d4e84021d77788c4da9dce2f9199e78e808248bf16b2c14b84511f6344952d6ae64b529ad7cc55e54515f7db2171dc2ed1f5ca34bd293f52d2d663b328b21e5550defb203d3e54ac5774d7fe33e9acd3528aaf33cd87e68b9adc97dd5315c85791f9ce204cf83061ec4f16d311df236dc6f229af6b514c8faa8ec88e889deee2dd2c8352757d2f031026a4d255d245e8ee998ebb098e4a933ae8e38aa1c419b67995bbdfd2c66d46f0a3b62266207e0ad8898a5a14d6753eff111fc9319e49e11a24a45e57b989a99e3df777a4ed996b11053e4ece4e4e7e355929d21c0f457dc462ade3bf503b1cccbc59b2bd324b3c203b9a4b3da916fe51fd221633731e7f7a21298fb767e1153223fa83110d76b648bd375ff957f9fa688e8e2161dd5a2d09d79377bedee65191e89977067c3e78dae3affd843c020f98b2d0efce7f52a0d88a142253dfe7551ce35d0b89d438c32a74f5b28a87b709b1dc79b6a55c0d1cb6b6269984154f71f5dfd4398e91bca1369ee04ca7941a5a835d6a3411acb24714b9d814debf471c524ffa3d907e1cea7cf47cde666c61b8c04c825f65138919a75b26ff5d9fb907e9e78b1b53b2dab9dac7c157100815cd3f835d55cb1ecea39d227829ee64c0424e95f621aeb4dea54a4d040aeb40b66b0f6941e2737c48e466e606b3ef3c26031b8e686aa175a2dcb79fffa7b7f370e026ff4df6a7b229306a0e9df2d9007dbb11462d265e2cf37dbf9eb7ee6495fdb96f167179fd318bd182e5733d02ab8de4771e289b1163bf8fe895d93f22e83a6a9afaab14a4357c09c83909de56edeb2cec0ff78c624369a7edc0de6584cef26b53d751ff9cd8eb1b838e561dc8e5f60837090a370e8adc7f93f77584cc5797b34300569ffca74048b6f20e287e3e51d33bb02c9a462be4634e6bce8baddbf7d252d17706cd9241b15f0c276a507a71fbf7d4f2253cdda3c3f09d1529831e803ec3653403b0ee339d68b19a75562f5e4c3a83a6c4b67cd4b47e03d47c7e0bbd83471e8a112fac771ee174e7331e5e0661ce067a1ff83c14b513a5da7b07869514b63bf0210d9e0476756b4f14fd0adc217ba24e18012fdaa69416e067b099a7a02d0c519319eefe05bb5980344c912bd2441235457e0688bd9f4a395a8acb44726c17a03757cda19fdaea52cc7aefae2658b2b2cca5f12cbe4157279709ca8792f7812a3758b5420a85f14b4da77e193e263975c9d52454fe9e101c7d3e99528e417412bb816df57d7caed64db328cc4b38921621592e3595d8762745f693711481bcaa017ec3ef95402e69789efe3cd0f78ad2fbfe424c4523207dff51b7250a66f11e3832ee4b1a418f323305098eafdf2467faa2af60086979e8c092d79a05bc1888c9e72e44383e4ca0c07d8ce8211531b5d44570fcfa43de7f2eee7d3853e246ad947a74e26652c620183eb581b979f2b930dabee0577f83512698b9e81c8143f8b2467d052712828e383dc1e417c22d64d2e347b306d1fb62c5c3a874de0628563eb6e183f9e3e3712f429687f8c15eff8a1b4704a03c2966ac8c51eceabffe92354123e8470df34bd072cbe2f8e7d6c7dc92c64326cd9452b3048a72ef79025c58f567d1f01a9dffd25fc492a0418e6227169f36863ad8fafc1030252d4f78e227a9343885502260b017ca845a6fb3678684cf4c0450ed68bf387648bb43bb84aa90a1ededee2e7bcfc1a8cba8af4338f66539f818ec6d08ddf237c9063e603ff12617500fcbb8dcd7c31df0d112fb9629b79e5a21f4bd7aab0168ac7e725085d9e2a02543a682ba38563d41418cadde739bf19e2a84df889b016d5059d0493430c391207ae63f9646e5f9713e0930f7e689b3b3d690b7a7589c43474329616ff7de9c23bd4f14ea9298a632ab51ed930774e208f4069d8c7eeda02f4af8cf4eeb27813797c8178f6b29b2f3abaac943addec4c56aa1bfc15ba33cede81136f846d1b48eaf0ad36c8279209314d650ac620eb63103b72fb7b2fff04fb4c08d278a9f6012005f256d7fe66be2ffc848cbc55f274dcb1944e62854a96c57cc4b1fc3ba5388826dc98d8a188b665bfbf42358371419106abfee854b13c837397405b581456e0dbc4399d015871c3e1abda2aa35bd7e4dffab04ef9071d270fa3343a92480b2c6968da70d64ed51a35275434709aed3a083cd9e0959c52307ed3efdc0028e198508e032cc9c1cf5e213619c3c2adf7f155a32a366a29f9317d917a5c13ebd421125aa20b8a48ea64787259e69550e89543e9311fb2456ed8fd3e818218100cdd455518d4045cfe4e9b3f7bf6c847acd79a4a633e24836d91df8b85939fd31b2326d2311b389f6b8da68d367ca68f7cc68d7f1422dc66909caf57799722987ec4eca94dd74a3ae1880a3f6e1e1fcdeff75e2f9466f26057a3b71b4dc3c7eac0b9ab839a97a1cb7f867923bafa533d2f44bdd5944fefea5581dbaf8a5e85c33a1e68de4ad8d2a28b116283bf716e7a8eb43ed9efd400c55d10f4c8e9db1bbcc9ff30e8490cfc0cdb39f9b42eda97fb87cfee2fcc8f6c63d838569f902e2f26e8821afd83c6f8e7149f15dd1cc15aa9b1a0755f84819ac963943b175ef874cb1a1831d3ab4a43710bb61d271888d36a09105539b58ada7fb30e96de729cee7f2d30ac229d87f4270e94b4583bf10b8a0488977af1bbbab0229851667906185ce2ac630491acc072acd22ae05826c5c13e3b206577d46a5bddd0e1618df7da8add7768bb41f2c90fcfe11e57b7b65496821d71196c47966ce4e55ad0101865d6e01c4a506c2e722e3b9c37a1df8b4f32a3c4799490642648846fc95fa67866a5c0ad9488cccf9f3907c8906ea339cd147a022a85762199ffc7fea1ec4d450f9314a28c6a9e8199fc0212ceb6f2235f5d69b1fe74ba601187b35610f23765130c017baf126d73134347241f53031fdc9919b53d9972b4f4eb94e45a7e71f1cb53d43fce13b906613777f287b4413f9113eea9fbc44ab7459481eea88637fa8c273131935f4faa4de795cbec3d7bf5b963bf0389ad3693ca149aace4dfd388fe2b0c06636a3a2187da341a22ed4021a7fa2edbdf76b38548c42a640927782f1ef0534a99d7d3b65a2b1640d288bd67f0db5f8e8093cdab5c6a645ee901f85fcca714f5d1532871d1626a29996a09242b68b7d9436957e294440cb441cb0fd14ff65c266229b8708caa8172e00b09ad1aa2c087151b977db25c5de0ada37590d163b48aff7117f05fa1c2c3576bc73408f4f0b67cf5b223ded0feb5b4f2f8bcfcc1080031060124c74819d8ba970c6b7a712c06cbb41b53333122103e6d4e8b56239d866c90d6ca473c100e647c2842f5ccb852b61c9f61102603ff44196a4eaff7b2bed71c1a526f1c622e7b6045849074a819e14930af084391170f2eafe2c39796d5da47b3dc2bfd3201ddb1afc522e4e145c11467949c9c38b4aa4db61ece267c1eb0e0ff6c6be6582a129754476ec9ef4b027b840f10aab799f3cd8b12be104de6e260193f100cb5a196006b6d46917dddfe840d1ed1ba682b9bd40eb2c2f48bfce4da98e9a1cce2fdf1133c2abf7697bf54607ba2911492a65e13e32bd22820de55721f0138cc4d32714e74583d002b30039e83c8f4dba83123aa80c2c67ecdfde015e87154715792d81317ecf121dd83dfb7cf7d12342303253e607dc07828a42b1783ab8c5f909ac05e78bae1fc50a2433afb8e34b2361abeea98fb4b74a422a1d9271db5d9abecdec3f7ed5b728f70d14bb3c2ca413c5b789cd65cf43437deb231996d06105414fb50c95342127a7c0c8b943682a57cb55c726a709104483c2a4d6a3021dc7d9a634eb26e553c05e1566ea457b2248cb7e216b7d3ce892851856683736e40e3c6a966c3a2f6a79dbd928ac4892fe3e01953f6d8ad8efe9a5c5354c990b781c97bf989204fa6f13353387d01deaaee1c180f09dc58b1841219cb77fee5b582c1cc66d60e86998027b623a7155ee208435c16ac1dcc0ad45603f80015865b0a4c0c0cf17908537b5a49806aa13c741edfb8461ce49255211bab33f395ac9b92367e88327f2d6c0e84a055a63497a0080869e435b0ccbf8ce35e55f182249261b59b713208053a710111a0129c77f33d63e97007b106ef2780365ce8348f3e63f1c1a618ba1a857cc98533008ae0be78154a45d1de8060344cea13068fb392d887d42bf867dea2262e70b324d0091eab19bfd00c7ac7b99c4075a1f9da639295d70b4d17192ab17e1965ddf187731a64efaab631b942e1bfb233a0b0ab71e567b99756b816a02498280bd3e9060c5e6629c38b8e4d0bd129d3c916afebff46685dd1d534f541f413264f6078b2c032c5deb1fc48c0548171270012f7685422c1d04a87fa4371db27755d5380f1a17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
