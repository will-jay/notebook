<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1eca4ee1e28f6bd61fdf30ff6769a89210fca6179514a4a0385f7ba6d452f00cdd2417d9d0c5f246964b0bf0c6b8b23da136336b474dd7d6c5f7058cc70a81a422bc41d9e6cc0fcbbf2921dd00ac50bee47a9f166dd68410967e837c2dba013b9d5a44e727dcd3b0bccee7cf50a38cb17f856b3ecb79e7a4293e04cd205626a761b6681a2e277bd2beda8b5b3a610ab933efc07e10ee482313660fc1fdb14ac9a86bcc5f003d9b74dc836fea21336c54e24313b34d911c0b350f3bf3838603c242d369be02a678b6c22b8a1357bdca1aef4369faef60b5f0c636ca9d89927a603e13f8714e21119c55b5cb84b245c997000570052b8fd25208bb4f4a02a6953ffd3cd99a71ab790adc7b44aaa2d1dd13622f01dd83ac8e903762b9e897bf805231dd53d18bb19d7cfe870faa9cef3a8f4a395d9d6855e8f7ca9984db5b8b72538585f2a7c3eb93b51f477e12d20708684890daa7216c875ec5eb3b14f27a55a68e2678db9bb9d0e975daf9b52162c07bc4878324163b0675a303265d87c4161e812481aa9454594530c67e38885b2d6ef4e9f440e8f8a1076887635b2252c46fd8b68de27d4bc42360796bb3989c72ae2e084f441ecb32fdd28dc40b8a615ab1e80728a43c63d2a3a1265c46b8c85c3a8b0f6d64401e2894753d84714e31992ad91fbbb0c6db4aeb31cc65dd66c701f7ba0f61a948d7d83a419a1f091cb9bf1bbf0d2c20ab2be051efdebc05865c58119bb4d94caf29d2b935d3c4088efa1b0be958909021fe00af6aafaed6764cf5c739e42860e18804db8bfbfd725ba8d604c033fb43b91bf7fdf8b7b3d1e6218bc2d30ae8f619774d1bb4a3f8e11edc3e7f845ce42f30565947e9504afb10a3ac2b19be639c21bfc0706a8c58f6100b516073c84a5e3445e908ad0ba0c89d512d39b6ae2daabd42ecb8b57f5e68a326295172fb2a4d29dbd7d9f7ed16486466d08f7a1be68c1e6b813edf9eadf72c9e6b0a807f52339c702c840c932851479a568eff69868fe4abf3d1fec35c55eb550c1907aadb1e1a39e18ab576844187f5248efd1d26e71f3ed8732c07de91b51174a81b1f3a9cd79ae783f98532882a1cc95c4d2026a6d8c07c1486b45ff9c972c72d9f0525787762a2df0b34f13cacbd1543206125755ca0ac7b2f0674fa9c6a9bb411ccdfc4f81cc0b4a436fb413b8a10001babfa4286a487dc003afacf6b873fcb72664cb27e230cf1f51272f999018760857457f5c60af0355859015c2d979c5b11310f6c7395d847ec143a47ed332da0b6ac07c3a02753eb74ff9af5638caf7e122dfe28f794472c20910440dea2a7f10ed88b5bd2aca9d1fcebdcca36ec057b0f98fa0c7a5b840c91388b61a5b3087b2082321531d652cb17ab60ad5ed9a096d536cb29289f7222a58333ca3760741ddb9858a014862a5fd3901bad505cd9faba3197e255227c52feacce68a223c499228324aaf08973ce51844a7fc08587cc0a763a3b7b80f336f2d8127a0ca42eb9eabb721eba463e037411d2b49762d6c5f6f4cd546e8f3edb8b5b89cc550e9d5ed8a788702d42c322ecaab683c2c963f1fd700f1de0f9912cac84339081c3eb289b670ddaa1f22c37900b65b0ac78966c0c09b1ef66e6915d471cb9004c4b055ad08eb56f77fdd4c8c4a3e430391999b33d563418dd94ce3aec0733b97850676c0391353ba6b9264dfae738c23e915ba2614eb5119e791d9ea7185cd3f05e40939aea4134fbbca09fd4784b01d489aa742a13d7cc7efacac5204cf8d276f219dbf299017c3f895a65b67ea3c940e4485d5a2bf07439224ee70f97a2527cea41394eeb99b236bc7560fd5911dae1619d9bf7c71b2a2d10cbc71ee8967af01d8a2296381d308a5b418505883a636d15e15be71d1f3d4244ca8ecac9a87f8b79185e46649b72b16366b565f2b2041cde3253f6a831664db9b01a4bdd775b3c113fd1aa40ba01529b5c02d7eadf076b6b9c94eaebbee42dd4878605f4d52c8610b023fa49afc8a63b7f9fd61a31b9ca47948adfb1055910b417f0f322617ff7957d48e3a5aba5259f7e3654579a971d7a6eb0f7896dc020bee9674f9462b865e10f7a35edc64ebd0849b6a5b5308a1ce9745d6110f4ab04c05dc8fcd616b9a1533f463f1aded811a35caa8956993de460fde67c80ca3f87574373524fc3da640b7bb2dcf82dd28c709461a41761135845e2bd5032ec112a96bfb610b651a7fe955afa5576ca87a9eea8158ac3f7ea61d8fc0832f664faf5e618447623f74399f98e94358d84834dbfc479121bdd4942b036352792278fba4ffae178d433a8d2f09c94d80c484eb77316c472fbe1002dff55d171d50e8d93e8e873f0b1b48eb91ed13ded0aaf4a593d7664489703b541b31d38608f66c3da268d246a968affd3aae69dad682b7ce46c98b072ca1930512785cdcca6a95fe89cc65c542f13f749d81fc2e82f2f12f913708fb314b724616e68d2f76d599f2ffb1354f4ab7a19ae9cc88ee8cdd0ea2ef46a708a414a66096d721fe8208b64ee88c477047336404c21f75f7db88984cb0d53b9a040c17e5e5ea56d5156af4422909c459478d9db71c22ac7c4bfd95de17e61b5e7dca373dcb0aef582c52cd51dc92d2dc1c53c13639ce0bcfed4b6f20c650f4cb7fa1da9d76c7b98fd82d302aaeb63ba709ffedb489520912847c912f4a1daffc3d95f929840a931e89568959c5b51ae22be76c773d01043b2f6f631af968510aa078300a66a2e662dfa25b1bf35e713a9ef5fb915e33f3582e3af03b5f9fbd8af7e1fedd88714b07392ee76e3dbfb4a2680308a6e65e88b7bbf8ff422ee62ff31a5c212a613d77fb73c2fd9c04e9ce97d0cd1857311b8b325c1cc5b07a13fd8516586bfec831d2a7c308f86294ec78952ae1f804c4d73579a1c6cb4b44aff3f0402135f1dbd32d1c8256674b041ecc69d856fd7e7e72fca3997add2a77e60ef1d546aeb466c5e3c61266c4c2a622905e835e75f99f7586c4fdab581badebfaea416be5d0595bd96b53a5598bed600862e793aabbf898d614574f7d127026b71a641e5a72954f5bd0ca414d9d374333521390124cc378f4dbfa32e2e50f75b526363d0a50cb7d718c9eea139b88248f423c095e1ad59f6857b2e24a7eca49408938ce3e41d6b168193cae9ea1134f4579a3a98833ef86a6b46f11bbc4b743c6d55afd90f4a3b904aa48511072397873d454f1ad5ee761963dc5e85c4cc717e06b598a27e39a4748a888ed94e4ee91fd1bae1b8840c5ea5298742c9e39e9660bcaf13e88576cbdfae56b46a3a6cd5ce5732ba5b407366e087d577a59fb99fb66c2cf93e5a02a359b51e5c90d339517dc84e1f361057c87e9042d0df6c1f50c62f0f5b026d7b29c86b8f4978950218f14eb573f78e3c012904bbb4c9c5952afb1e3a32f22034e00e167274b412eb1107a403136d8ea01104ad580e76f2c01c83ca10304aba2d1e2b9c148f2c130f126d58d8f90df03dc1a3e0f95e464d1c89aa3e76c8c822a8d8976c9c498114efc6a81fdb6d613e4a9d8ed65c1fe35b2aebfbbb69b84c317e6d9e71470660fa7b6051bee5a54c3380fb30e2f77f4dda1b09d34f5b128fc6c2e6978afbc5681ec8e24592c39b153b765b2fd5f8b3845c1198cc7de685984ed9d0d85325af2bd5846cf4dec524e1db41236e782581e8e56a40a75f08e6271b4cd990cc16c8af762e1698b1bd05d9d94d71a6e0a4f69a3d2536f2a37194acd80f1ea71d2a01dd53f3b3968927a031c8ed41cbb2a38ef0d9ef1a1a4f0f2d8abc366bd28892d38708c8cbb6c18f740a715735e9b41839be4fd2fc701ff0584e480ee0adf27969ca09ed7c942524566947788f4e97d086c8915746cca380dce304dc64453e1fd8ee075f973946059346244991b9aaf09d51646241d45a922386ef84ba74c7372726b2078031d5a58ab0dd7c52fbaf3cb52f3da82ab9a48b9b48d1fcbfd59d11fbe4af99555fe59448827a54823edafeab797043f56075bf90894746eba615d35998b96ec9f1e34acbb46497cc22419dde9d93320c2e13c7c4be52eebd7077b909d6b2d872729ab9f495bfc793d394fd785971f845319be6918409b969a4a70bdc4469be7706c8f9659e134542c7ec6c28730c474292729aefd922c0aa9f6cd9777f7e62d62b8e8e281e22a0ea0635df538142b47fad5823144a3db3f81feb886b6d9d5146da9d9d54ba34db0162e83500a302ac81e6a8266f40066eab9f1b8014f4f43d50fb75b27024e40fc2ef8b0c52f77f1ccc95310b0ee1d3ba0833edad0dbf4a2346eac14d48f22c2e1c11a9d10a08a58a42819b66f3fca47868472700d8b0e1f4461656e3cb050017d446ff2bc72f4310ca53de37960d38fdd6c01bd64544f47e736e683eb8e0b2395f9071ed065fb6e9f5f23ee1046ea21b7651b1056d8f281f3e9de7d2964b086c10595bea6da846de331a9f0653552e3ae66130afba3cede907dd97f368f67198268ef3e8c50f66e8058ed22bf563f3d066e531cd21ba2f6d08eca6c7440d8d0ab3304b359e05f21c9fc19415f3e24d3e980747360e2558e7c124b8d170ec4ec5bf869ed24d766769fb9fa2e46df78a48f873e3735de942eaa9b3e6aea6b305831baddbf41d378a24aa0b3e5c7e7dff7f50a0b67bc1712a1f043cdd45d1e8285cd446422f84a5e2a0cd083d2a03061fd75dc5660de6810c3cc2a39b3115fe34599715a2c541bc6aa1b0829865fa796e926f6b3cd722032f48c334787a65203350528875d74543303c8b4e151b5d8787bd842031e90a48df4c38cdb800025bdf7c61401cef68977c3a32f72b2b6b1c0f0f93779131071eaaf253d0b73e4f21958ee87f15d798d27e15ad14d47dbf7a713fe027a36306eec3be8fd29b28aaef1e246ca6796458efe432c01cfdbd54fa2ec4cd99a8c42873791e41a19b68cc2ef4c7cecd85a9a826cf8a4e4f6bb214bc91b64ed1ffd4522aa313173d4140c609d29c551acd8ea23f8078c6f65f8ca2627b3af0b309ef72bde4d39f98a3828f48f1fee28913b02dc6d958472ec988436d6c2f3af7af55f216913fbd71ce4e797ebb77dc2b1b58812f0a64a0b281e2e5c8581a6d47df117ecbe687f9494340b59acec0bd8c11388353df77bc27fa36cc4178aea47a1371e871a4de7ddfe06cbd9773283c7118c8666baba8e4621a74a3eb15b7d3cd51f880fe4b2325a8812054158d8e6c5d84096eb13bb6ec96807a5aa6d22c204c19b2cf106543f9fc57734099adf172a11e47f6b2f847395e087d0e8bb679b8f8b0de691b6a7ee59da00fb8fa7b33e6f2eb9caf91540a1896ed0bf6b607c174c01e90a8ae1deaeca8ca9cbacf932c4bc9fd576093cd4f8f97de6a00569ccd21aaaeb08ff740c8d10be38e5ec15c2bd560b869ca34e999ae8ece5e48ad884947e09c9b48038634fa1f8776a9872463f76a22b05097d8527426b555e6371d9b0e2b35c7c4e2acbffce0f6a2811f5941c5280113fed777bbbf282db13c70296732084a6c9236444923f903c1cdec7148e4c8d57097c9e6daf7ce7cf8dad69b13c7fa0b19032b5fc1476f56a27bdd07d8ef51b4344e889ac7c288158c0b1bcb764ac7b12f1546fb257baccb40c0deb156cf4e184d430b1109fe635c7e4549bd0487b7cc6e58990b184b548c936e0f0c2978ba31a05caf7f5f53cb6f9fc680a2fd8036e2d4aee779ce14a40b980b48ef461ed00b93b501b62dad5c750ae901560c926e486397340e824ffbeba1b3778796fcb1aa88488470e8f9b08e65e119577295d43518f7e66575cf89fe042ba0a3cd7937cafe4fb11b1583a77acb5b6b14695becaa1e6ab46d7e6cf5c4f6629091d5b3bda6b4ad96b6f23e74af3978e638d4d4bf1edefefa3cf377267d01966b26366bb5ab80b3e1d523f76691f67fdb80351feeca5e3d878d050451951dc4d30a44b4a931e93dcd6434d6bb1065a53b470e67a117ddb3d56ad8f8d5d1e1907f9aca0d12f3d213bc89fbd7281372b955a3c5ee04ffb9cd7be519a3f29d1addcf3d1aa86d3802521a8e99104d7359723115c2f679c52695ec6afbf29cb1758d475a394f9b6bf37c4a09e0cd60a3484c7b057ddc6a3a855b683b1f054f337ca1e0448b4554e6c6b7f6be55d2e267265e66afd56e88b8a481f62a0dcd6fa2a671e2d3e4283672fcf28fdd16a400fafaa0fcafd4784f0c44be1063c65a545f50eb065aa026d96e3bcc21fe3142ff1512ddc0e2b259ccabbf54e882d11f8bf4fcff8201a9979c00d936cae8da82ba97f95cce88495a271f526923e28d730963ef5812061769685643f63744e5579f0a38246d46fbf2ad25742ab3675f89a9158c7a88f74e76f7f074a1733ce640e0078c86293b2e166eaf2edb54a5510734a7b885813102a1edf63573c0f3e346930d07e3774ea70dbba0c2924b65b30a1951ce7801e1df02da447193de74270a5d030bd68d30070a84625350a7eb25126e477aafe0d850b81536e8b2677153e61ce58efe82e4c1217380659cdb148ca767344824f1490be972ac4469f3d6a903c2ab6245544ff06c4ae283457322266e65162e0fb6fc3f96a7d5b3a0f1238aed83c4682f58595c7416f69f774ecb6b45f6612fc2a4a91b440b0ca55e8000acd63c3492c41d8dabfe47d80a94328d5fb4d907a5c7dff9ab0fc1c6405965ed381a1d917e90c3142d8c75d5b47d8e1804ca10942a8a7b107c73cf381d17144586b9b8bf6dd2aba28a44d81d22b61d70ffdfb66a58cf101a592ea8dd1ee4f87eca22eb628dcb28405eff32b3076e3396c83645b90323c116fe0eeb6605822c1795e249fbfe362e8d0a518b475d539a3df67e7df365cbe4fb5e6082d632e969b7cf7d2bcd6e733a69896c53cf942b2260bd3f57cfce9b03b6a5763845d94803408c0caa3ef110c842eb8c13638c76b7348292f547b8b891de0e4cb74f7262ddac9e5242a07c27b71e0d316c9c82490b6cbaed5260cd8eea6c5df9a63559f645324b684e7b121d864f2578995f1a2c71b47631d5201a46e84f04a6163bd00be022c781606739dd1bcf494adc28616e71f794bde419836b31f7097296fb9282bd02cc8052f4df5e53e2e3bfef682afd01013a1c1fb2105d001a6955fe473b547d1d9c06f757d1152f188a265a67d6351135361b63e8d7b5641421325fb24f65785a3d06dc8bbccc08c6ed4973282244321b24ce934471182abb3c5699f5e3e0b2ae52cc10bd95b846391beb8ebe039a1a10508c4c100715947b4240ac31692ef63766176af3cc10b66c205c08816bc9d442eb3ff8a43f9f58cd0818ce0aa25321bbcf099f6725b5263d910db2eca663ade4165cbdaf3af375a2137ef6b260f892be99833e4176b1aa7f45828f404d31184d6b4a7227422e8925447afd6d3dc787f16b0a423797d1a0891d082d5aad3836f79c9417b70e40f2b6d200dfabe048abf43c584e0c0e3d1eabec00bd1f1bab74a0814a8f5e57d0a0c210edf5ffdabc72d80021794e567ec2e21be5529952a429977ea18c37da87e34a03ed0ee76ca58fbedd87e634ff781832ae1ba916c97549e30ac25a5230e8ab192ca4ba907c61288738a936f1152d2d7c1b3462eba54f09496d76a5543dd867928fa359ecba5c9e1dbaf7258c0047498fd4a234c837905ccca4fe45aad99a758eea1915e21c785c5ab31a4714d5eadafbccd179eb2f9ee231115d7436c18abe47871cec6dbd1a78ac583fda1dbb056ef18799fc7f14ee5e20cdbefade92909ab015caf65a91d267b20ea3a226b48c3cff340d4d8d43f2be837fe9c36e9f22a2e19b0613adcfabfdf4c5c67c48ab9c252b52a9838b055da6d7049435f722871c7248d7f590d9cf8cdbe3547a1aaf89557b1b62d59932074f87a8e1513c09d7b0140a985b324ef8c95ce7d70460bc2ec03b9438bea940c54a3324235b456c1c3077b679e8eb100439b92e98326d2b4a0716ce04e4b2fe5d01a1a5b3d7e653d55bc3970f7ea1b5ebf055f117fa1fcf419e06ac1bf99e73ee52c44f2adf1867d0ca285b0cf82e882da518765e9cb4912be5539c918d0728016b6973faa8338ae419519f02736a7e1601159e00a9618a2604a6542a0b6de1fd8eb2f3bf14bf98c11bbd717f51b3bc02d917c402b2c3468d586b067b16e7fe4dbbb9eddeebcc0d40624bc20e6c6e344a0735e6e5eff02d2188e15cb155bfbd2365d87852c5e2d9178573a193aba73a11c1c02b74f9dc741bd72574b57f50e480412ac97ca17bfc879723cb2789a265a519bcb023bc085b20283a804f5778bd1a7b03c4a9ca1a74e3a0553d72734d270430c4279711fa2ffb31695170e4cd29d20b550480f502fb5a85a904ee207cb06665bf56b43035cdeab0514e04a3ac3f84beef5f79650418c267b0365d60e0da0a9c645b486504c66bf0703590f0cdf45af37daabb7972052cdb8d3afe9794a3f53bda4445d924994969d012cb501fcf08e0cdc7fd4d0cca843b89a173ada0cfa1d0fac2a6c9e7925f132bc6015d8e5e240084b6f7509e1b5df16e9391f76079808aa1d1f2c9492ae157111357dd0579dee22fde3c0e543af6f33edecd3b3f635346ea4fa1fa789bdf666a1e8e8a0984b7c6fec3d3c20a9129dad98ba926253abd9ef62379fdfd81c603c9a6a1f8bb2489f02e04ba81e175ebbf15aa91249f0eddc8c8534198979322ed69a17d16345b04f5a8386d8b5166d656ecdde2b8a4d22b9e15167a8af477001cf1ce38a05ec7f01b19a580915e9354638370fce690faceb16414c6b54fceb58d6af65ba02c762402fe1a122b75a40d630ffeff94ba0f274ce13c2bc0570e540480e5940c5feccfdedcad7ae238ee893d7bd6f8c8ceb6e2fb1275e83dbf925a53432837401ac90b916058faf33c88386456f58c7bb6368f850480b5882726e673268192ab903599014c62258f618d993ab3948c92dcb06c475acf9f93b99af418b7bdb3578624c35053611dc92dcefa60d51f92349c7058b8032b4c02aa18428d9eefc7cd48a5053cbb14971db3331c1f7c9214ba64a1fba1b5a82a5c58c383804354a6e6eec9605776ada5b4dccc6d45370063aea4eebddceef5b2cedd4b9fedec6e010da1565105235a9d539fe9890792f7c9edd5e5cb2545d6f1c5fa19490579d73a252c0583523da478058b95981451545a191632e07b2dc9d1424da762bf5d4458c25a56681173fef0ea43fcce83f8b1ef4db77efcc78282682a8039a7232727c7580a4dc08f240837354a961472056c52839ea1687b85a52e885ca50f1657ae06d7888a4cbccbdee59529a522e8a29713c4445143fa9058e9b5ba725b01701a721b406784f4eddc587760c78d1a69b03f17c9c5ff55007f3aa69798d256deac9bf77ae443df5fd9d8fb524cd9cb0b02435622681361e7e3d00b6e2161fe951492d06d9dbd8218492bc78f156d6aad35e363c5c4667ffde3c7e4888604aa09ff5ce6c6f9236ea6ef1adb788b220da3c64987daeb39bb8ec731683a8e3037fcce43b7563f1a9e531c8b4bc867e3d3ccf7ee96a9ab4f9d1df99aba3e160d7a19b2232ed0c896a880cef533f2190134b0c71ea9cc03d7ba426e462b3e23e49974119ff4539467c590bf01de1ef0f4bc94769f31dfa48b614f58f48876cd697f01a42a6a399a94b1f5810e40df12c6cc6d015e5a84490e0efbf7541c9213979e3ee41056f956809df31f709c6d42b9c45930d38082fbdba93e0e41bfd5e951d6fd3309c8f86e371fba5e0318db620ebe51ca93102c448754b4a43bdee9c64ae2cf2dba43a5939ca935bdf8d85ef88fd3dcaf0beb99309f4eef4856db347e97662ad6283dc1a55d983b6fe7c3eb9985958015f18bfe111a7e9f6d1c39a0b2d896364bbb299434b527c7b0d29e5a69ac7661f05c405de25656f32fb5001559fc86e6bfd943cf4191f948ccb683193521fd28a69178c9d457115d3014c9725b8c59b876e47a843a57aebc9f7c9c1bd631582d26a47997244f064400d92554d59511da54228cefbf09a9bdd149687d97076aa0d9e7cd492435c88171698f55e64fcb3c8476232e9d8de861d6fd2b65086692384c646b346e7ddf524fcf0016ce11cc04ae8c7026fa057665ffada68e6a7774dbc86096dbde8b447ba08633e3019d0ed015b7c8dd5bbe7b0e2b4f7e28aaea993b2a464d241caf9f20aa2f77a7f9f18eff9ea530bd2a736398396375f5d7e9982e3f6b27ab87b91814bed3f9e104ffdd9ff97890a3a639793a6c793e9d6753e0b54bfb4b3493150594cf6dbadb2347314c3d71d44ea76965772948e32c9cb25c6aa4856d94655d34346f52f5663737f8a56855c6c78d3f66e9ecbf401cbcb47ac4a0104364cf02c2803ea8211fe0c9bb45bc1f5c5c131fe86f1b6ab3b16ac0ea5ba702f809be59831541f9bfdd4ec7a1c44d0858a23d3b78df6976398e9cf31852973688e0296e103eb6239dfb207018d122962a8c4f34a59e19c949b32314ab0266c315eac0b1896b94f5afdc2c9b561e00352e4addd89a1efb76cfd69db97910aad1a11feaf8b8fc16d20945520f1992bfd926f0a9114785f06272cb8233d87a332252b4542201ba8ed5232182ddd2de1e762e419e2f5492a2ce8334be033095a115e50c36f7c1cc42761f5ce7929513e2d8e1c3acafb349f1ac6c217508409f9f17cdf8c862743c8265c60f43690e13dab7ebec59ea4c208a107bc8c0b395fffaec36d10a89494d345fab79278c59d3ae608b1f34d9352e687a833eb7b91451c95393e339e28d2c686e4c7dbbe6cbe4cefcd352cb0b79de1914a9a28daef44cc54d716d5d043fb958191c2ae5ab7eb7955227bedd5fac1acc9f6cf42ce2e2efbbb26d27ec4b70fe5ba7fb73bbc55fa7aece8344e7e03ab6ca43cae514cc82a0eddb8438b57abaf16a8dc04e18a14b18a0b608d6161f3377f216b2b906db5ed65aa9dd9515d2488ab0690d4831607f83d13d7e5f657c41299050f06c56837e3942b2fc71c944ed7c56095ebcfcce168d29dc2f0300f251c9499b02003df1684952e0edcc5a7678ae5ab6a7b66725e077b94d6fc9f7ff31d12e31bc4a9c38b6420127dae920ac260473f5ebc2858537edcda98cd93c86c818cd5e24ffa163347c77c6cc298de80f5143dd6e5c18a17bf8064ffd40d1b1b38d2ec454cbd228aa9cc0c92d0bd77c226aaf9d21199cdb7d6b66e00d6cecf51f8ca8455ed379b447a36c09506bdf8f5ce3aee4b3aaacd88982f8664cf62fe39a223936e80fa7c77d93c475de42cbaec00dee62b942eb014830521f157663b4f3d7eec5db718de06e349272480998821e3fa9c2ea29e5a7e7dff647324d363159fa017d8a56de2f9c5d80a45b5354e139e9f2ee3aa67095d94fb64b9c606ca95985e0cba1e83b394bc5811e09086c87d8ff1a77b9dbbcf008c4e2a5d3d6bf300800332520489b7ffe649d05036eb7a983a5902690acdd1d83b31991c8c04488f55958f13e6e32aaa36053d6e0f27a1cb213cd6acac7ff3b7b4741ab62ad6f3909f0c7f5e56cb4dbfe9a8edda5b3860b3bdc9cc94f592c35029a84c0c48d0c2782c3964d9ebd491c41e69a01b59c14a94592f3ed29d8a9ac62090769da331e0db59acc081bb8e7415de930d704923bf31cc88c0513aa7cb60a838f4fde3aba1180e14c6ee7980512aa6396a2f86cebcde0f0feac5593e91db88ccfc26443f7d462a9d1174df04635ddfb9190f1a86f994a436fc8009e66188f92dc622b48e1665d5dc71d6ee61a8136a21682149d626a9ddf4c51631972f06444fcd57f1308264c0dcb04a0f9c8d4ddfb273d86582047938ab9fc6ff7f254b3798e5dde35e2449bd9661574f9aa9ab7d71510d171b5977e6063c5043aa221e39b85418d59629bde00cb848438d3556f6ab3458615dba51ce20d43b989f74c40b35b0de2d3983c4ae7880a5e91242904c3218938b8ed7e640341169113491c00b9ba1078046e1127443728f3317a859f6e83febd3e98dec373a00a3f8cd7214476eb24d2c6e74d46558030c1481934fdba029928a6d20bc816e2202ec78a83aea31b54f2db3fc120e193faed02db28633b1c1036123d24daaaaddced3a475d881bac58edb051a72aa0fa6af29f61215668c802790042c1baf9a85fdc1e40785eb01f5559ac6cd2dc71fff4e6a76c5ee9e564a25d2f64cbc119a6431401e8da1cdcd8296bb76011b0b8fce30109f5b0c04c7d77172acdccd9c40d8ee237bd3351063eb81753e9b3453cc77b90281a9a944f8fc2bfa983fbcf976f8aad9c94b66ddf70304ec349b2c6c1e9256883ed9db0961be2f098bbf06872e8051ae1c671ad902b3b7e7c3a823d89b8394e737bd79540c447c1a4ec1103d95ff0a1b988bc2388db8968df7648010155a95fdfc2a22d6843b789acf67083d196f53a98d0d8e1a2fe9c0c3fb135685ecf53f268697f20e5b340f6e631f11611739484886e0f78f4daf7a4f5a41e9a2cd56f1ad0e36996eadae05203e6b9ff2749bdb8b6c30ad390e138ec1cef390008cd77ab35122477b01bcba2024f65984d57694bf90527e87ec77b722b22bad3841bc9bc9391428c1bf1de6146dbf98d37a8a4f51d22b9bc3c5ce2e5e43e34ec704fffc672e3ec188d1f16c12a18198f7b65bd12676f516add4947172c0be8e95186bddca981187ebd9a274a207122d17690cf0e7be6a231962a6c4131b303362525995c48b72fb58e4b6157b95036678d211bc235ec83601d230695df2be7e8e347de7cf5ed45ebffa2c95172726f9764717659bacf585c1554a9b4df316653f5ec7c274acca71cbad9bcf914397174decc49ba6885892488cd89ace486aaa3eee25d36eb7ce2e567609e17706676846bf1625551a7da811abe84318b5ff17ae10361f4dc6f6f78055a0f8d3d146667ca319ff4c86c2b72037011cff4b47ac7ae76de1813ca4e8b436a52975e9a92d11e63404c3324c1f2686bcae96e2644fcbf5a0bb9e5410e8f66b617153d8eae1c9b2e232ad002665ebf360e442287a93b3eabd43b0dcc9cf5ae24d09bfb7fd90ade38db42699ee802a95152c4fd7fc6d90fd13e11c277a47b3d209c365924c971513973634ae66914ec73a49e3a414612fdab17d47c4a288f74494299a36744cec90afbda5eaf41928bd8946a75","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
