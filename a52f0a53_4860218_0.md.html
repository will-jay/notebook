<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"379b3b9a3cbf4bf1ea18c76e16ae2b2273e1b8df4a0a9421436acf664d272a2d8dc265adf2815d959b7e5bd5ceb67586dab84efae51394891f0bf0a920687f42157adbe6245844a55092ed37acfa2b2bd6376b3cf330a751af9ca3ef506c21e442ccc4c2fe0fcf24837aed87c1220097378a961f3b465ebde43705b5e2aff4a9eacf714ac4b7f54477fa0e354b30c0cd90afaebe2147269616ad475e9dc595bc9562bb05c447c8e54b033af280443b151eafa85bda44707cd1ce35d907e5c2382602fe5ce2a0cbcef96b9b9891d0a6a5f6354db3483462606de7db0cec9297d302d40f7f847b5d5b24dd85c2b8ecb0b33bf679b8af30c27027f00c43590fb81dd7c839c64952bfdf45f9c16d8e144c4be1b2000082d4e42fee5e8b21bc319e6f68784900240463fde218d0979c77e23f8471982cfed63bbded93e3a6e8d56a0fa3b58d6a996e0add83145ee024a814c35a3c99251a008581ec2acf5ddd90faab4e49831484cee91f40b52af737eba2a3ffdcf1b10654aa2afd4834fd454187c84f176253ce9b1b46c698ded4102bad22018636549a37e8dd7f1af6c0c6cbeed121113b3702a6f9ceca995cbbc1e1c326134d63b66e8025e226efc45c710f7204d5f774b845a064a8f5e28ab8a5eca3af4968562c7718da1e6f1fa14e9613288018fefc5433495646954ec91c73179fa88da96097712357dee5fdbea00376f347c5e9b343f21b7f8eff0ceb22ee108475584dbdde355ce50edd760038943961cd7b346e95f884c0b1633deb195f4a720ddd5918affa812d9f94576e142f233d51ae6783aa6757e0147ebf9ddfd7ba1acc8745838db99eb133a762401c452325a74b7c7e3e2668817d56ca556e85aeaa110416e2b2330cbe29f7f982254824202f688e0de0fa99ce8d2ad754e6ee7a6ce0935d817ac5f4830745091c0be03aa662d718442f9e9af185a7e2750819f48c99569c9572b05390262d2731a4cc1aacfe3cc07520b59b5cbbbf2d4d97d8f2fa5b91e354edf88e212522343545440ccb64cf177d14cb5a3ebcf0f318bc7fc91dfe7328270bf384ad254a2530161a78f63121c54f3b923f46384666d20eb475f8b5c3ed72aa19797bcc704e428445e8cd1703e6cbc796c5be10f9017e66e8a65d8055315a581f8c256b96582219b73cba44a44da9c683dcf92b4b8be24802a18b740f224e5d8ded88e34887c71a7cd1a0904562dad165d2e13bee0f8c87dc721cdd4a1a8eb916245e3fabdc2cbe8d12c3e0eeedc02bddb096e5dff1193cfc7b9744152bd664506d1bb548f45ffce798f0fb91dd4865e3cdd91ebf9b44b782c264ce2b6aa4a9b79d9a8816dbececa53ad2fd3b045610b5c37814c614f57ff18f78d5b9c3fdbf2b8e9a1935b763c5e815d15769b272fab1b80e3dffd367de443fe32c8223ac490ca2b9c9b2edb0612d31a80d4c94d630d4f1a9e2877abdaabd8b218a1d63f3abbf7ed9fcd99f0d90820e416d1cf880c26af1d63daf3fbba7e0ae27b8b2eea2f56c1baac7b76038a8f50976dca73c4c1bbc7f8c96212d67b8382de53ee0329e85c1e2d402a70e63e1df3c5be76c25feaadbba60c372e558387dfeb751d4a36a4ee2dcc432f5c9b10bd31268c5827cfc92d13fbf816bc59a1b755a1ce971c443ff074f5b15833fdc5f58a108ead58cb8f188b179c59efefa17adb2f43cdaae366b7dc6729e5cd28db3c6daa1c9c89c5c8991cafca7cebfad5bace37b115424726701446ee8984a1d53afd001665dd57422a01ec9e8f2fd11dfd7eac55a0d0091905935a7370a9b64e1a125fa1c7839acfca7ad88188a0443cc724ec0b28c3813e2df6dfca71e1d67195fb6b7edd5bdb13e50efe829e115755afd9ddb70cfeb4cfbe02c1e3ed033865c3f0c9242c0453870535eee7c4e7d7a155d7ca2c4e1781a2cfa8f9b8ac3a27485f0f02970f9278a291250aad687dc0d67ed187ac1b9e2256ad511c167d9bea4035bd06465b587ca4b765feb5b32faad6a578ed4fb4f9331ffa58d33b9dcc397e5ea9ba8423be014483519bf0829f9d37bd32567cc4aca7c5094b0171c5029d4baaa6b0a48c5a3da19fc1bfd116c1deaf182b288255660884117bef947519ea9230878ab79eea1caeb66862f708dac562bd354c7ac9a0009260470639d97820fb93502011c9af3264f3246b643508361645966c0a7a85da29f5015c64e5f9c699e5d5eed67e0d0666bcc99d259cf2f5bd56d32563e13188f25ce071132762c406408b84b86c0a8ac96e4e7bef608bff4b9d3633783683a1e696c60f2f111ae494368c2046db94ce1c03e5485b3e77d1b0c448a2eccc6c0b798ee441dbfb8d3a5e3033e844e8d5bbb6fa9535e851cfe6a4549fc30c431c245f596e4df53217672140cc1f13dea5da80d1d7ffa0465e1c997a4f84eca4a9e4cd5bf8f3b6859ee587cc03bbdb29714b1d9a379c77eb20cb43a88a332e054392fe1b36c83d55a3bad3a41cbe2ccd524ef1e58086a90a5a4a02d84d8b6c5cc0239c90bbcfa6b31c07860dabbb52bd1d2f6ebf567fff17b76c335ce0b8ec8de477e8ae9a6e518b2a9cdb8ac4c80604d62af576d1b44b1de0ee6dfb608ff142e72dc4bd3fe277c6773ce87a4215c7960d4acf835f90930a57008614247e3f00985190fc6b560c39947bfacad59850fc25bd45b49ad0defbae9257d1783ba22b47925be78cfe97a59ed7ef581295970356a5c36d9064f20ef61901612232e1ae7870889405da1a3dd880c2919ada32f4106577ae47200335ac37ebac6f7d43cc6888ec1a24e2710c0b2e507da89c500935bedcc19b9f0058105ee8da418c56d6aa606c64b5031cb7f53c9c73e5b98b8b3e20e84e2f439fc00e54ca70e9ed5f737b730c9e1136b92b824e066f1c375e279fa908bf1492c0a7e32d5220532e7fe0e3442ef7a26acb4c3d8725347c85103bd7e3274224ce3f36d8d494235c0c0846ccff0aef477bcf33b6ca368aa3646d3dc5b37bdb0662783daac7720da2d8b157b8a24ae57fc82c2b12647c1c87dbd797c61cb604e17e1e6a9df20e2634233c9a238004ca020c74ed87cfdd1c3d51ee8717bd88c151a33201a1601af7d7d9ad7497a4c34c2c748f3d0ab4ca8fae15b5d900a5f4f631e4022d100c1c90ee0fd6ddd0095aaa326432adf6e7ae5df74f1a239a059b5e634bf22c5093a72e77e2da375b6c16eb40ea66a88e70672e0f26077a741a545121fc4b1a01e296fe36e2aad7e55daae705f907c93e5d1aafefcb85aca714ce4eed4d23f7c26c0cdcd18fed682dfefa02c9c5e88e6db3831cc5ca1dc0f7c54d0f14cf99a644b0e276a1761b0c558051c74b891d2860272f78be416682d9c4f0657f37d1428f9bc9a5eaa905afe76a694a32e0b4843637370f814d5ec18da23581554625969e9c6c87b93548ba73b1148b641d30727191ff47cf6ea7628b3de6d1115482e2d7a3f1b9d22780fbae41bee4a54123029aea682524d36cf047ba64ca3a7065030936d8f57373c3377c187ba6afb610b52189e32042e62550837b133a4aaa7a557efbc1ec6573cbb763d5cdde4596727d18bb56f6a705f2e857517f5959b40c818fb0bedd0e1ddf2efe10020240885e52f7f22d89153d089cbeca41a5cfffa5864020d5b383544826a974fba01c7fa9252beaac288690e9f44480f9f49dc96eee62888d32c3b0b01bd0df84932dae4da74b338012d4ca3980a8175b6985ea7ed094c822d98e3463215c3d76aac8b88e084f1a3401f5a85e26fc812119504717278dd876efbdfc0faa7b52239d93779cf06aaae8a2a968eceec609e9d1635a05c7cc6bf9be1d6a7e8dc878a750384ab8a157dd96ca2b8f6e30d0720cfd84f10dd2af6fd5e990cc77aecbc6dda45cc53c6c1ddabd8600f2cf40dfcd51b942511b4b8a8721716c8a77455ab3e87e97ccb30f39f5ec1241f631ee7cc4a49d0b13c2ff8a690337f6124e57770153b79baa6a64dcf56b54bef458b34d299ae2706423577a7390aeacf832b23df1257276ce877ffac8b70e67ccadec80746189ad5a8d1dcf6068e99d681121ee5f1850fc249c6773ee2c22c9a6b607197c02fc234de89c155525e21a725222dbd4a6b8dfe013449482e1a402db89d6f8a2ca52f923075bfa2a1a2e86eb4e1fc219263302306f57ec23ab72033d146931b6c527a1579809228300f60a863cb106be5ab8017422ffc6cfa7a2d8130ce27b1f5b90f4aa33a281647fb91f75633a91bcc486b4dad835221d803b2694e378e183bb52c28c31b3ca7a74d57c07749ea9a9df6599527302af9d63c87d9373a22140033618a35af6e526f308dca1661c2bf0b921cff832b498987c9956559af66553025accd36144db685466531095e8bae2cea651765215856d6721c05fc429334d1bca4057127f53fa90ef946a4844772e33c9e2eed6ab74724aa421de00af3542c317d4a33f5cb02f810fccabb783e856aef589018fd07909db65776c7efa0dd578e78ad0bc4655735699e2392a89544c657ce6922fae44eb202b0579fa82040ab5eb6973f4d8753793675c2df3397062bd799bb885ac5390e8f49478ac5addb8aa70a028903058406a028bedfaa644130c0283ef7dd341ccf48a86c99abedbe07706916a7a2a39330f84eaabdd815b0bfc8758af38bbe64f4a023c25aef051607f70128ca875bcf0585d534125769f3c37aeb89a0043f4da8532664d54fdad0859c8558280fc45e0f5d886e529ac29095e97dafded21bdadb4024b994436c9712782e0cabd027d0c104af0a3b5e7fb0827f1b5e80363fc62c92d49ebeda02fa7286ebd0346040eaeb74a63f60de4c9365903dc266e717b6d70f0d9c9f6d7f445cbb70a08c4035848a73177d0a37b81cda62621087f726224214c08a46353c4093013bf53a3d1289c2a7bc5fb137bdbfc5904a6c2fa683e78f6397101263b7c48231674fdcc60a62ce30b446ce8643827c97b712452e69a12e688098efff83665b4e4a5bae6ee50b07061f81b8e2ac7cb967bf2268c71b426f87659bade2d3a32c905fb1dd64d49d98bec9e9f5150ebf5314c739b580eb88c670443d7a637315942bc85ef7466ba31940e418d5ec1b38dbdb333adc030b8ff8d3a7ec13a8879eb66e44c14d6868db19729c0f1b1b19ca3a5da51b71624155ff9e24c46aca944406e71173689a22634ccd9e2718721ac83bbd10c1061427df85814e4e67d8eac0e1c22b2b960a1f656a0b0150e2b9c2b3b5f27ccb288cadd00e07178829da73b15790fd54d9b15396b2c155017f113f61bcd2a87ff0ba67596e267de4c0a080df9eead3538f7277c288a04c9199c4b97b962c627fd150c6464279e4747d4cf40d859e0cddff734d817f9dfb34e9db079be3c00993b5aa35740b37718ee79813e2f1c9c57711c5ad12b435a1bea6cf9b457b4ad34722d4688e498739071088303489b012742e6c4068ef624ae94062407a53b88a26c3e60f389d5467909087059708603ccb96799f3451026cb8cd3a3cf0b1c41bba6c3273599c0196d45939c6b0c89b94587c1dea34b6cb7947aa7c2187d736d7973ab0a2666a0af8492b1ca67d7cbfac78b84732d55d40ce5887166fed495861555ce1e1d74c170411e6b7318e7694292a209e75667b8547a0c984f49be3f239ab8816df3dce4822e84189e18a9af52d5a23e0203488f4543f14db4b3f0a94652e8882495f4e03ee07193e92c8d7a12ebc5d9255b41d4ba8208433b4fb0791ba0de5efc5432e4cbe4caa71e4966c0c7429fae0b7bb501c0db969ea1430bddc466572d11d1fd4bc1b67a5b80d4818c256d4cbee1d095a12b79171a5ebbec650a85f3a55eccf9fdf8464c8619c7ce7d5280106257fc5aa5f1e0b47a679b8e349531be58dfd324716962540499a3abd7a4d3ecf0f7909249cdb19b1743e718443c8ec37818dd50fd42029c59170d3f627a5eb6eed3da5d19698204eff4e3f8293e5c2ad6000871296bae2267225e1c07428786264d084d296872e1cf553015e61b7b18520135a5b2be0cc4beeca52e6f2f73492f86faa42b0a4a42eab8b1ca37997c0aa62757fcf1eed69e23dab493e3e354dba8e2ac0627b56dac805e5d3cd07980123c78032356868abb787bbfd5b56ee93034d985779db81e59c28910a7f5e4251a2e3ceb5df826d662c8f3f71fad71fcfe772dd40f7f5e7d973478121e3db2018259c6002cabc7851fa939977d5d78ae3bffa9f11116754b434309b2d88dc033f530f904c9aba39e60cdf08ae1c78af10c9922ad9e2d2abcc415e3415fbe3cf8f04488ae5d4fe45ee913adf7b20a011268c0559fcfddf029ba0d7532116701f8d4096158409c2a7dda2295ce9335efdd4de801b45b1a7d0d132921bbf3fa872644283bbe7707468b3d58b5bd8438ed781d6a1204bab7d83110100caecacaa73ce8913d99ac6c41d59f83f0b13f7bc15c154732a7be38eb08c6d355a32834e28539658bb3e309ed5f46f043a226340c710e431d54555b5fce30af0b6c08ee61365d3244c83f64b96bd4b4ac153ecb963538910a4a480fe2cc32113ecf581e908517d70bf314857b5f7711a357f257e11222b2dcb8c71dd76652ad01f0a8e230ebb753fb180fe61c70ca3db8856210c9a019bd760a5151417c35d8254c3e9ad90a92b880e03cbbc2c9d056c415c60b2b5043a8c11cbd0fb907e4a0b83ad351a37c59feae436a4164cb2f5e3afd65b5820933ef8895cd651f6d5674d37cd86e436ca8d11ceaeb29085e190425e5fa74ccf5d189b1821a608ac82fefc7041669964929072596b2f3e3d52942a78205f2030dc883d344cdc67c9b52af5692d99258090bc8ccfdc5007caf62ab53df61fc2eeeddc6981576ac9d4984066f1d2e57410534da41f4b351f9d9e836736442db01bfe4fafcb740b60de77ab2dc2869e3e4c58a356606d317b470ca5f9d114e1a9eff4fd849bc47a1f8a111fdcedcb65f972baec04d553ccc4fcad8a539887c3da85754eeefcddb0b997ebf3978e34a06a06942315b449e96f26b61837b429e639fc11110405d3ad99639ff45579a40312a9d927501294f0b0f2ec29301c835aa9232f9d09e24f2aa8a7521b73dd1dcdeb049464158d0e6d04c85a7862e86afdcfa1416e7dffaba14234107c5be8da6c8f0f87437124698eff7fb36c4b7de444bb15024ed855859a3287ab335c1feb317a3958271a92866faf5be2c28c7dd2ec70d196dca8392c06e43712ca65c48bc9253cabe8571a10eceb252a0a5b1cbf5f24a0263c1189387dfd6000b0c87275e3b382202705e30dfd967904439c57a877944389a556873a387d15b356f2481e62810315b5a6285888aa516b028b8d2aea9777c2ad17c654f7b5010f1794339e1cee087d1a367d240b1c39ed0fb947537bc1fdfa5a7e2806da7c65ce506c29c5afcfc13907e05880f1cdaec6e318dac2334cb9deb49192ee7471fda4a06cfdb21cc37c8c61c5364339f9b9b282d67401ce71469d9d87779bea92349c9effd54c39901ecf758d2c5ad271f7d3b75de61b5a15fa513e019d5df03930b6b38e47bae4b6f34e1416aa3789ba19c541eda3d7b2cf1a81e36b072fca3f60e400ff53b0c5d318425310f0c36062530fb3209f340283aa50c1533a29b84e6b631324107fbc92c5d3a6e9b80d5ec13ea782916971e742d028f169d33f0153f75d340a502d959ce378febf6f2f6523df28477ef22d896971c4ef818e8dc9d903f9ee95bd5fe3989b389995c9b7efabeb56f79eeceb39250b3ffd8ab65382afe474f55a93cf9c492b99c3526dd9f477c4b887b52811ee2baa6c1bfafca8d9f6dd6bc8127abd5f8650a49eaeeff3ffc586d20dcf3a9e4b5b195a406f243821446635c123f9755ee0171e0a4b867c209b5949f64d7872c3ccb1143982af71227c2695caee2fb9eb51ec75f4f598e692c421331060124dad5e70927f52249861a47f02d1bf85740581832cce9d56da98daaedbbe1cf82941db148ca83015dd506f221e7685dcc5a2439070d1c4ff1c9327c846142aaa9ac4e9f45f5ff74009354ed016e0d298ca3f496607d3aac2ff800c9a51a20b556e64f7d9d5a56c20ae08836573f0bae568af3eea368fbefac06476d907bdb189aa50a17c51edc2e502b439910f53da54380a1a9cc942c2f29ddc85988e57cc35e77ee8f10ed4f8893b1c04d8ab993c4a69bb59fa09c1790a170783abbc48f36ad687ddbdf13628f4072707c876a9a16aabce0d9698ce2a2ded3b46353f533727e19c4e3e346b6c4a617aad2effb2426097e9058751ad6f10e2d1dce2ac1290716c7be9bff2ca596c66cf8278ff04292f7c357e201753e3a4abe2d89fc2a694869aa054a582190464d9eb7200d70b77486a75cac733c80a9ac8a6319ebca776ca5229fc2f83b663cd36cdef85b2bae5b9174766e79bd7b10a0fe0451784dbe1591ceb8368525e034e4a5516546941ae674057b0bb7703d8232127c2ccfa177249c833a53a01c8f073aa99fb7d7e7d80438ee0004be676d6d9f50f30dc26a1b3b3dd6c75c1a42f9c9e9f2ea7a42764994936ba5d0698eac6c159540b7cc0bfebe4f0dfbc87ce71e0e70171333dfb4b44e7067107970d62fedd808ed01e367f8692c123664e99140c1eeae44f700099dab8784a48d683be51b42c3e269b3548b11538ee6852c7e19611aae6f343086f6e725034d9d42cc29bbd308b7a96a89cc0a9b9aeb1b8dedddf2cce347c1b8fd782b63583ce2d30373ff3613cf5d503e8124c086aadcd041c57fae26a92f4939a900e9d78894605264276243d1177d0f819e02b1587e3ffa02a52a06a9b2f60b652e2f527fa35b9eb7432b870455c34fe6a8addb135836a13e8da5d7d5c67cbfcaaf1f38401474be7696851b1de1bb7e4c64b018ef48092c457b49db3b5b8e104f2fda847ec75bccf2949923a2ae1cdfda16d962a7d08a6e3cb30f3bc8ea5ac3ff9d8ed08cc43a5b3de300a80a889d49a17730389a51562391c966e58785cf03ccf3d220ccfe29ceb10c67c5b7800f0a0e9e7bf78d37002f65ac52d1427dcde20be21c76dd258be2bb3e3f5c0aeb08721117322431d0d6804c856ad4fded789666bc1fb2040eaa15703a641497907c440b29e0bc6ccc3205b8705c2d6b682eeb790cbde832a5ad0ee350e2ff30e707635c2534b7b8d760eb1aaab0fb4609ff57f5c6ceddba7720a48ee397baced6bda128bfdb3b7bd78e49b9d7f943aaedb6f9e482eb3377ff07938a5fa65412eae81e81882131a323e4c47283b2bfd7ae6c055878ccd215c9b4ebe1f3e4490ebd1a34837244df418851df4d4b1c0d8b40ccae2bf17cb4f3062aae9bab88b00f8dded4927f17bdbc4054da0ad17fdcdf23153753f99a7553aac3fbeb241a22f4147568cebd0f685634c9581d6eea3ec3de302ad5527d9d6675b251b61fa02006499e000bb6e307c7e06fbd867fa04eb0923704e1d088dad7960d762afc2bfcfba9ee947cdc3bf0e0ee4e4026bc772a38b95320862627f9ba7cf2cc26f2dd7f98e3c935ad7b09a6f6acf11d035003a0a9da4d9f24dbaa69d4e0f9dfb406daeb6ee8b78a6cae4d113cb30e12fcb59ecb0a78b520b0c05a5a223be1e7100695b9710de7b543802677163fac25818d296d713b349955ebdaa61ee6c004dc86dee88e6ed92eb2f7b67d376cb57988953458fbd67406221a115156df182ee4d3faa78dde755d4c5288abd1b0e2501f02bafa6f2d603ffadecc349a3ce8b121cc37d1844ba7965ba880316c9d845350eff12739a98223992d5fa862d07f14459a98b4dd0f619be1ed62cea0579dc00dfd178f08e46aec2e54d134391530d080cf48f7919097c73daf42f1ad7f9397fdef1ad44b02bb666cc2a3b59a2c90b59b9f1adb887bf636aa9ea231fa06863293754037655be11339abc59307d0efdbc091aff067409a10166d741f596b6217788c7c92542ff896798a7a905286937b52980258783aa59b07debce914ef9b479962cf159cf7e95205bb8a4154c8ce2922c96f260451e85076694f82a9abd62c373e05bb9c8dfa88498d81f7fae66d5d2838728b864eddc37aa9004884f49139757198c17cf1668b64668a83ee7e43db1214c6b9ef1e0841fe4b75505271de45f5964fe51354d469c77e8bdbbbedfec089370bf89d1c6eff4ccf05bc04e02261ee9bcb3e6eb7bb233622f30f0843e9310abf3c1d177fc17d6b89014da294814b399ea0bf3aede1d724197ac698d567ede7f70c2df936f1de924a806529bfaad2a48580ec765459f9648d0053989eebdacab350f8cab57fe8a3b18500c1e6ffc4bd15b85fdabf8b4b31e2de3c737eec8d18dfb5bda0a11621eed1a216270b487713e5042b4c4aa941f775025e571203b36b4ca90f84d105c61585f68bc00aee1ecaebf5655dd6137fa910a8a55da18fbd98177e72b37336d306827d99511becf65ef97a82ead6016dc47d963c00b5013d911d2ff6836a4ca1961725b302f0c02f55cec720999b5f7d3b7efc50cf4d269ee9bfefee877b93d5b7bc18555874b25bb345a72054719d8438811b478d44eaead5fb0cbe60907f40ae78e6ec876ff41346832b75ee23defff291c069d841f94123e4c7f537f7bec921a97d8fd033c2b5875c1e4f3b04dc170fd22ab9fadfdcce76c00f9cb0b730422a2b736553b978ccf676c5e15664c81d89cf2508b75139336ff7623543fce77e05701cf52d74d738242369cf36b9423c95e00d2d7e93f7ddb52537433b5a43322dfa7f3a05bd5b6c2c8371ff2ec9b4ee5d2f60be2b3d37fdab114325b8e55fd7f61dff6f5739317a13a1e39307ac97654af0dc1299c79549d7d4a3e060326bce1473cd303f70a3cef397d83af9657fbaadbd8abcef985419d064d1ad684fab0ab234d7e7b3082d444411cc20d9102469610b6ead3b0c4593721da4ee5e5adc13d2d8d0ce77df478fef921e89f64b3c2c288eedc967ed1057f1be90ceb1cef4e2028753650aae1cef76ba386426adf20f5ed2a0976ed743c1487a4d4bdef0e6665a9dcf6a574aa65ce5e4d59684ea75138a7059a5c9efc41ee878a51f3adbbd5c53ed7be494d7ddd3c838123c6cca8167f27ddcc9eca84ef33f4e1c3d00b2378fe06e4711e93cd317e9b12137029df22b2d1e05e52134cd9b340880da98f191e1709a1c701769011962fd7c56a05e5d7f3597a499cdd46b260b61310f7e3010a87414fa1b53232f2ea7349f6390605a4143b6cf7fa2d64733ad6dd624044a8d6a6034a4650198bc9458b67ea512eb0be3c3d44c9047e021f4af54ad0b0e5bd02c0e71ab7079cb3653499f76f11ca1a3a06c7db48972e4fcfe6c9ea06792449542ddbf1861e27fed1c4afe03cbcaf9f1924700c4f7e64742a362f4d4672d4348ea0dd68aca8d1be9d62792b618f230a7177b577220d2bd4e0e54ffe695ab902f31379a6958bebe368d73058835123ec5488c27c05d06f9dd4d67ecf51183b68df675ab34467b31901f58949bb02fd4e710dcc106b73ec3573461e80f6b80dd9637e6a7d12829bb8a371fd24bc252c37e39a6acd6cf5c674640726c5c81fdd6d64f837ac4748d3aa91cf018cc78cdb65e3c18756ffdb649e0101835c47b56e24072d777a0038fafd55ab8e1fa8aedb1767047b92a5488f65b191970bfa0fbc8962aac40a75d94e0896458aca4c5c2278c802ca22dee38294a9955b6897f06d1994ac31d350f6e23af82a1085c2efb518e34f7aeb7b85f83254a0111af8a423fb507480e981da1fea0e047f803cc94f3457189beba329e9bc202750c187a85bc5c4c6811167fb6c836cf3cd41bd13187d372893cb7e5b56205101311bc2e5a12d3f5ce022328e09be402f77e9db0f27fe44ea3cc25048733f8132e9a56bc92650a49db4a18191a2f394648dbe091e6190748898032a3661f9a008efb3272880def2295b5fd9110dbe496cf36624bc1404c1edd6b98c78b328881cf3d0a41825b8bf1fe8b173319cb2d5c7c2ff3358313739fe89a1d7390b7a399b06618f8037d875b45f923129e58bdc8543ad333091282313f9279d83dd3113c3abb027a16020b6ad63ba834a424b0da7bc0d1327f049d3ff3732de91b02a900fc5a911f11a1f71aac88b252f53d827ab1d51078d4a0c265b0dc74730f6863c7becaaa463a96a473ff1e61b70b3316629aab8a5190e55f357fa2e964154f4e86a5dc2c92a898d34eed7d4a4e1203b99cac9192e1da0c07b7fdb03e4c100c9f3039b57c191ce20f0523b71cbad1d567e1c59f60f03574c7855637bc23ec269fc55083cb10bf89eac606a8cca2c3fd189ff2d10a80f501247179bb462af1774c7dff7a4535f7748a6fed1d2e61a2dace4739b72b5c0ff4c31dd5b5fd5b64163ed746ec54f78909ea569e545aed84dcab2f31ace71249baba1e5570098b92a5c7b42a584a24721ecf5b19f4042d2c78c368be2e2c2e92204d5465e2fd4fc3da5eff4df58d6b4570fb16c7bf21564b93e7b48ab6edb41ac64176c69be4991107c0d79e033ae95ac46eb9ded3f615daecc7cb012330a3b12ae7ed75b41165a6ea6061b866b254c843c6e0b0b0870cb2cfeac1ce9629a6a6f38061f4949806a9b5201f6c390f7b2025ca9b63f32e1919fcbca9221606837c731c51301f52f3b26a07ca71b5533de489618c4cce6dec804abca6d97a654dd27ac53e511f5e36e8505ffe9a1af739d2f865cdb383f901cc3f0473bb0b7436f840ff52c608774d5b556eaa852f6a9f1d312ee5f9592d8297feca1bc84f87db93a947c0b81498d8e26fcce8130c23412fb09add39e06bb1818b501f8a7b3f9cafcd02bfdfa5e7b8983772082598135cb5cfb49a0815462b0565e21f079dc9f41d7492457b9c2a650a0d9c21da8f9b435ebfa3a15beb44e50ab742ba596ab200a8563f0508791c637c4a6717cbce2fb9d201002dd53704ca09ab3c6602358a77197a19f2beedeb11f5633cc1f3a9a23d92cdd7a228f43c3ea01759a1dc80471cb142b76840706930c47d64066cced87baccff9e74e9d7087b2a5e23a97b8c444015b5e036188bfd8f8ca2405213d7163c478ab258fd59042c631fdf4e49590197312346f25cf4b1d39d9e18dd1c06ee7903211255c06f2efeabeb770146a20e6c169ab51b54a336bc4ac20b982243e73303c028ad10","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
