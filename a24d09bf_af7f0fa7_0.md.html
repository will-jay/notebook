<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6ab09578a47fe47266fb72ab8763427b4829a0ef4dad56816097ba984930e48fd47df0d810c872d35ce5ab1d9f27094bbfc090099569ac2b1c295d64123c78f1595dfc1c3d16db2d4f08e52c11f5345928f3069135f96c9cc21dc0daef7ffd86ad1fe3f2d0e45dd7685974da780910d153d0813954bf85cb7df0be0d43d22e820368b44ee3e41c8930efefbbe917545761e74dbc18acb39edae7d24597a0c3d3c076f8cee4f68ecbd707ffcb3318f70fff86f79fe8b7e9ff9de04ac4a927ac8f37635827d933c50463ade5764883579bb8f745fe316f0de6f5d6b31556f002af33ed776243198510cb6ec294e365bfe2a8494ae50ba7a2ebc05520e0f838bf32d96b66dd701ae0eab3a94987dc14b40ca29f867cb1fd2114a27e44aaaf580b2fe7b3dcd1663697db9a6671a23ff4fe7574c8aefb42b09606013150e13781aa3324450426aaf0223712a608b0ad546adc545f289fad272f735f2436aaa772b9c67082e52b131b672f8ac362018eb70c0a164d117d56260bdea5e7741e912ae25ca3a8526f68000a66ceba13a7094ea0884d5b11da1b78c46bd70ac8a5c994ee27e6311e235fcd456f08e05eba1752231c5e1b78e5ac06b49576df543cba6b51204b8c0ce76eabc568a99e79d29dc301d1e6c4e88debfa3d12a94c79bda87d0819629aee204a54d6bcdc5aa806d203237f44922358cd80a5bdceb0940f6f56f06113acf64aa6ff8bf83b8f540e5d2a96a0fd7c2a5f8088d8b96ad375b45a2b2c687826b0ddd776d3755bf79da6fd66267c4aafbb89901d9183c75c1d008d7c750b8269e4fa977e5c499d03756c37ab36c5072a89b1d52ceb9d7060e3a6ec51305ddb2e4490fe14e47bbe2d9dcfc73574bca28ea65d4b479f4875dfe82903f5ad977aa089b695794b45175af33641c6492cfb2bf67cf7bc8c5088b092e172162555886286b99968315297ecda22a85a179086e9a73db5cfd8b3bb7428f1043da6c071b6574ac052ca989b5af23acf467de53ada7e2b5318e97b622f62a6a59666db37b4ed481b437da43b8223e81cf4ccbfb860056aff68d7faea533554eb0deb75fb7d9eb9ced73816afb36c5b8ed2c8a9801f3df921675af45f220214540e180777c3edc3bd6e477bf3f76f99a8271066d15358642cc027a974b20aa8347de0215fe5e8b3ccaab58133169984333a99a94a74e10cb148d6531d950bf3da41bc06c6642f443816bafa40eb2f1c226a8574dfbe0586d8d0e35bdac9b21bec1428f4dcb2d39702ddfcfd100feeca2b0f3be631672ba7ad90042f819dae4608f6622cf3973d78fd4b4a26697aa305035bfdf29382761623e4bf43b61c581bc2f993f1de6a0e1a8c0a9f772c342dffa511685aab45eb24a55181f9a62542c064b6bed007b97bfe4d26194ee5d74f25046d3488d8728ca8b875274199ff3e2b2f2d9a4f5a73ec51b151432d351ffd48f41d42fbdcb4451a64da67b7043b11ba759da9aefe8b586e65a32de1af77208dcafb20300e7558660cbe709940754625818a0ceeb2696a54b46dc85367843537f7de952566347b7327517164d968078768cd3e8eda3f75007d01145498e9658906577e28f769e8f12d44d93152e82ca9e77a443eb9d252f832db87e4d150c94d9865f9729b43632e73c4ae0d9374602b5cf0d86dcd17554e56e07bcdec65dfc1f31b487c6209400c0ebeeeaca6d11d4da5ff8ed059d95454dd42183ea0aed9b54bf9e3b6d28991438b16c4e933bc36974490077d09e90fd347cb409bed6df5948b46b5d58f2c63d967c3997b59ba527b55f132da3357076ce482e7c639d7db1fed8d6690421cb978cad2cfbe8a5c4f61bae2b08c7ddf9187c56fa51872869820e0e89bb030bb09d95aea871ed1f55d65f7e66552c60deb57d0a954fb16526b0928994da352fa5b80dc84d176302d7113f10ff07e0a77a24cef6c61a14190c7602d2f19bb9dec779b3dd94340c97ac6a2e76752ad53bc8ace4dfb0110f996c0e735a854dbb2bd56d9859d97bbd97c61d54e18692a03522b4358248b03672858da1909080793fed0a2649ddd8caeb956b23397e0be61e2b669fa7c9d3e05c7957c8f67d43c317e49e9402c790f3e5fe38a26bed49a52511f66ac0d5e590554e8716e8b3868e9bd933d0b191d62a29f60e7be2ffbd4ad3665e3e4d0d67ebb6c356b2d0607a30098976807543143bf3e7fcbe03eade52599c2920d0d784de7e474eefc5bd3605cea61e874c6a0ec41d6ba46814c4c156f5bc1628227e5bfd4c4f3d7fd57ad488e626755bf344a912e20047ec5a1b67489254013728f820243600241dfae5fd4d59f51b1f76849a5f00e053195d0be0d4959d1aa9beac6d17cad3e34597c63f73d537f5fad6a0d121b60f897cba690edc921fe1f838057c51adf300f128594f32121a4f537bcab0d38fc94d0279391351bf5fcbafb255a2f276eb7f61b6d1d15379a06d1fe478e18ed4530aac890f9028bee12c9f7e9985f3161a30c5f6ce5842c95e3d6658befb0eb2ac218a0c15baa234dc9427664c55c2f369b7a29a815cb3cae974ca73744448edc5ceeb145b94215bed9e2c6b319d6fe368c4de88beb2d973a71071673b1cd07c453eecc0b0ce68d585170af5b9f610b0d7f5d5f9725f9ae1c8499c0c80566b24ad27c18a5802ca3a88b5c99e541e5443dbeae81f639f61ad88b60ab2bd3ed927c0e316d62f01e8abed846e95fc84cf1d5d43d7a42d6dc4406da1df666326a6b16b70c3b220076afb1dcc0c24c75ba65eda5a1c4504f2f1c28f1a9cd15d96edcf2b0a1ca9516cc6f9de8e668a2bcb8e9efa9f3b17841f95cb1224dca594600a44baed2d627d7db872cf029abe36ec6197585b8db38a1340eec682706812add2801d4de998bea3f9721eeedd7216c530082d4e8f0d35c2fbe8aed30af8817e944268b4a28abc3b2b53ff24e8d1b49ceafc3ec474bddb1d7ce886b15166b969fc8ab3a1709f5ecc5e94c1094e0a236769af7aab09443bc070748c97c45fb6c72a6efbdde48a7b929de3051d70cc1ab6be59963ee94b0cecb4c7bce1a51b6d262f514a13556a8af75f188c15bcbda58f2c37d029ff96ce99ef2da944ce5107b856dc8df3058ae72001d68243b6c00e2a9bc1e49ba5ac8009c094d0918cc0e3cb5cd35d8e7566b73b50e32cf5bea05e5bfb7646e6dc1afbb9f0829a08a5684d10357096b68028652b5bfd06224da647dd1db3e6fccb99a4573a2bf703cd33888b9c1f78f7d8fe64424af3c391edaf58db53c84f9e140260a064ae0804cfa440bfb7ea11221ee471cf40e15db885d76f5b5615bdaad20258260301dff1d02621ea1017e79e5533506bdb800a23e813974c56ec539a9021f9714ff9c8a5cc7974e57cd89e80e2ed54503b4eae2c3509e2209a9cc2fdcc374d3c4e85fa63ea76ffc037510474dd46b8fc06f06a2de32a2ab6e63edd0d0a5b0bf30bc0a6c8db8a2cc851b71ae642253471f1a033dbeff9800d878a6df20b3134bce28650f396751dea0323317e6281fcde7ef076764d609e28895c64e3972b315e3b05cc1846091da03e468a3ea0f6fdb0775a537e2b2f99dcaffa783b6fff9b430d1bdd1226e8d78203e7cece6d39818af96f123dd7e7a06b440881c5707552781049321fe4676be4b70748692e732681f98e6525aea8df949f850a4f3d719aeae19342bbedf101417e51f52e9964dab6ae714821c3d3eba33ce9ff9ed9a80b2c71b5ce89533111a2219e908b9214015bf6c0b13fa4ae09ab202b80ba39857935ae1a49b8baa354a760b87b93099714149a1fc20ca0b5746a59356392df54de13e385207bb2e7f61181b4f387ca654ce3900a798beb191fdf288bbc477077e4fee2ce4fc7db17d285f60c76954ff6103163e9e7cd8b258bab8f857e8bc251e6982cd12ddb0649b1a337c95ade288b5fb8dc96c5cc66ec9246dc2bc0f2c3281250ac8cbd15ecf0893c4eed6624891c8f3d147b4ed59383f898e240fd56fd88e951cb8cf27918bff1006bfc1216740d3bbc88ab67a4b9ac3508c0efd58e86bfe6e4b5dd9af941d806dbeae07212d6f5349414773c67589e5dc0d5dd3dd7c0fc5136eef4be85418d5f361494cb09e68ed6c10a601fc340a970d499f2ad8acfd6bc007baab0e3496b8ba18ab0c4a3a97d2c5efa75bbbc7bda09dc3979e83ec48f6ddc582e1d826eb8c1193d891d8a3548ccad2288d8a9228867258e7dca7b7e0d73e1b6f829e51ed9e85d5602a23fc7c50546bc610a365c87ef6f2173c69669e437b27f9f7002afb5220eb7c631117024a9a8ffb3ca9a734b5ddeb933d0be5520b79c7c8bf7d86a6a28ef42c9c1bb60a827d189dad67e61bf1c53824ee81853e96b82e9b50986699e884f3f1ebac8ec18572ae1a02e09e2f0843b1cb0207d6a8174fa42347e67fe841e1e7faf94e0f62a3640b1f87c3ada6f41d83694992a153539f38d6d8adefb61331c6cd02629c556b4e70cf0488756b457aed06a41e7cf79340fe67819d44c180ee7ef089ae4dadd60e138f2ecea0cc52a84ba786181ccbd6709907b244cfc5b31f4a577d4836cc3b57bab4ef8cdbb0b54076c57fe2ffecafa1bdae018a8e3428cb9a75c617e411ad5bed7108f8535a7044c52d8fd2d9a6d2577733defa6593d9c25e3c2c147f494ac4a6c379fd15ea2a13d252af4368853b00184dc6056ef0a63f29f73798ab7fad3a8c993825c308945d5a2972ad3d2352d2f24b05f4f27ccfbfd7970ecc9059126a5b496a1e017351a1a08a2bd0dffeee0a75d2d6ede3e4253bd27f9e04b5aec6e397fb3ac2992c2ef7c0f33fdb09aeb649166d7982ef71ea988e36a76dc5d87782f68a0a356d0f038afc01ffa6d890bf87371ef21049a3b822bb4dcacf93e923568f753c36450e533b4ddf595a13787f50a805d94b053e0149e2339770bfd3feb90993b2b9f6ac1f190699f11a10bd0e7e2fe717e7bdc89e54c9d641aa0b5f32d4f1f4dea38c9dadc5a003f4444df52587d8f7b9b11fc1e1337eab306cc50ce098742bce7823a111ebcefa6b3c193566e499db8fe16961cad2028ccf56890bd2dfc2fb42c6353acfb9349db426aa635fa2d9059c533058a3de11c3c58d21ed7846cf8fe82c82a0d3ab0aec5869834eec3c731291230ef826518a28c667a61da9dbe00dd734ca526235e2c15a3d42160edfb91a7bea6cdc91cc05fe88e491a7a9704894b657a8b18557829bbb7d77c847a69cbfebe5b3738e44c96468f1af4a790ac44ad612533a295511f996ca64665fa98cd0392779143dd7d9d2d37928278543b9c5a8e8a5de7a26d8e1bfd1c308e6575288686635168751984943a14dcb1ecffb4aa4688f5df90724f70790e7ce840c48bcb99fdbfc37658e3eae83dfee5251f0fac9804320af90152b3eda7cee070cb841d9f89d815274ec996fbfa93ef61a14c6818ef9ac1f6519053457437a8dfb798c2da9de9b2ad93d4ed18ca196613dea363ef61acd568f00aeda900f5c32f9bce6acd01ab1a4ca730ee657ef25247be3c655e2f21b4b3f8f7784b66a472b7500bf1a7eacb908afecbe1de18c6109450f240316f4cf46fe68e2b2466e8cefa086c9961b25326360893b65abe6060fc881b0b36cf0e8418a5c47a7260f0b270631ab66416a63628a8052e7cb66c75041af44668cc6fa53c29cbc8383bc5cf9a7b59e317eb26a1323af73e1b010b96c4cde69ac9dba1e234d65559dae49d341aef12a61b5365a9d54c10fb91a83622d26374aa9314a469ea70cafe32f923b4541a2d332c39ff802bd3f185aa663eb4c3a7ef09b665d162166c5e414ef5ee6945f83e30761e7547939ed725e05a914096ce4102573314013cca63efa18c2fdad6ece1f5a8c9bfa801d6b8db097e1434a28f7f0d3e1fe87d64f903b352289189ec498cb832a97e1995594c04fa65606d4074b191eb2b9898600b5b73b11cb065b6645c912ad05f72a012393886ccf5d080daace1616094c646cc061a797df328d095fbbf024cb50c84af95fd4a69fc1f2e2dca31e7423759bc4ccce929150a2934b5951c00bba1f773c76eec86be1b9c9638b3fd53dd6118412ab41ff2ef349e77746b8296b8f14f19a151d528c0680193c4d0512e9dc46ff90fc0b359c0295c2d82dfaaf819c828dd100471a01040588c7c85983f5d3d46b4b598969b55e2bc1836a3002221b5ea3dd15897bc11080610bcc9ac7e4950265c597e537821d1d24d8a371ddbe7fa933529bf5381c03c150f70797607383663c45ad2948767954b18c51cc345fca9c8b39d70132ce6d784e971f9c2c9bce63f4802576b88700fc98522f71810d19dc355107eca3266c540b0533ec39f7566ecf21ada6e38ec20b8ded3954cb20091b08fbcc56ee10f74d22a7891d39ccd67329f3a1144f4fa9098777d3b56d9940cac1aee9e55fb7638dc2d9e4a049c92c5d59b35536d1a5802185a43f8a24aecea8dff404567f5979700702bee63f6e69c39574e63c4f75b2ff903cdc416d9875909c5e5c62bc484aaa432bce2cf3d4f6845d1bb904a4ed0fedbdf1482d58043aaf11ff0cb81732efb3c9da25572bb9e8d9571c3996190127b4bb7587b59506e109957b3c95df5c32dfbc07165ce029dc20a5371a1b2551b4363f981e7b496eccdd40f2888b7db1c0aaf34e89ca228d309881bfe3cf4a27a219a1534af5c46511c4d43eb26df0f3c3ec42967e8973e8aced6a471b71b64776dde799423570ca74bd76c8c5922b5887e313d9f5a710b0d63efd968830506c3465d0122ec4beae98db3940e98cfbeda0d3a8d805de9cddfd190359b4112bdeee1e63edc8f60536b62f39a574d69f005a058b35bedeb15cd2bef652e19838472ab37045b2cdde937f0f3ec6a0924baad87a94d876586e0447c25327ef8536ca162626791438293ca7703aeab5fd88bf716c49a5b87c6822eb178417d8775cb781d4cee868c7c91877bd0d7c48138de038148fa4c45a97c03a3bf1b00d168a3660bea6af11532af6545365b4a908b2f3d97ab27b2c12a34032184662f8ab08a8d96b26fea8d0fe62c79eea873ae07a163dcb0404dfd3eb5b0702054630a25e1c21d8b337923f7af16d9c0c667275d29f22249e2ff751bca5d8b50d3ff98840f4e67fc640e70143667b835ca1650b1b8fe0623659abd2ad5822b8b16800a110173a787e1866d4c2229840e83498acd7f332894840575c5bf1973cb87b3dd11c6eb18a7c227fa496cbfa3775e0be9b184de71ffc2d0b1ce2200acdbb3bd0cf9c2f78f727ed9a9337fc128b628da14f5bf96159c99e3f0f18e5171e29f4485aba032066aa4855ef69a9a2a9f56d8efbc7e3ce097b2d8304993ccf0957f3f20e4fa7cd9b28238fc83f7e7fa8d2e53161ce47323a2f46f26e4426639e18513aae63a4f2cae37ca656abb68e1482ba52cf242b58f9d23212cf24d56d5ef8debf3a20cc133edd0d49e22e3fc0e9027f994517dcb3d9c25590d12212ea581bcb371b24f1bed8c1b187ee6aeb37a67bceadde72db5a6fb98f468194c74db80acc8499cb6b5eba6c500c0d687331cfed5e21ac1837ef1c72daf5632ec33ef25ed479baabea8457b72a54655bbaa95589ddd30fa1dbb127117bfaa01a5d8964a3229c18ac520a5b8eb11845cf7844bffef46c0657c73affd1f8a7685744d776037c81952d64aa6bdf6c83bbcb2617ed77cfffcc8527614f143d51365d3d0e1c9688bac7a5cb8efd4e48a4d0d858456603eb0624935bfd563c120a4caf35e8f8921399f606650a584593f57ffd7316d018f17b9e4f13f9143c63eefdeee1319a84bd744ba5330bffd836b4827b4b758159ea250eb3f5989573e6d1db30a6b2b06d39eeb4bb58855fce9dd600f028046ad45638f8e5adb1a5c4e47d9d2a2b89c281c4ccc3019f65b34e6a24cdbc121809f7ffbc8df545c9c15978661f597625469c9dd7fa740dc11dfb69f1db1fe859c98aa5ac8016f8c911cdd1da1b6dc13a1dc215072d9af2678aa7570abe28616fcd799fe33718e4465d7752b927c88b011132f7f204c02c9e4798007b5ab3414ab83b527c441fbd87915806f6e386a5419dec190e19cfdca2df6cd3217abd8f9fba582a47c7f9d6eaab6e7b930b9ddcbcd7949147902d9b348f2780dab42a2c7547ccc0ee771b0942810995d023c719e148cab6deb73f45113218d918eda3a26200903afb8f0b2dab450eb2237b415d8268b4799da4be961113cca16e05029f7e0e7702f6d9b43b7d6e9899866c09778a6dd5c01abf85357b6e825e4c6b0fde260d397fbe5022a75801abfe1fe6f494ef30f5e52269c5015122f215c5ec4cdce36f986d9548ac75da7e0908bfeaebb1a832482ba780d423300d87d6d57ed20ac636ded77f4d9afe14bb12a7bf1b9612cc6e9783d8471deb26486660301835bfb908e9eb47a829923792a2757dba9f0816c68009ce68c14bce86b93c41bd338663ac1d3851b3d283bb6845b161d691e6c2ea3fe669f985a3411be399e18c4780c44ae925653c0a6fad7bd29a93bed52d78e6218875329cd2c5af93e1ad598cecb14fa2fa2276dce61196d3963cd64e5854214c5443876293c9e5851170eb2c22df5f8b0d6ae3e0388cf5550eaf56bf8a75f951797de60226cdc78dbc5224e84eacf174af94243c8c526d573896a70fb653f16ec466c9aee9a1ac44a99a0ee0a080a63df102bfd6d40b02beee56635dde7b610a30ccf7c468778ba4c25cc8609bdfbd1a90f6d33802fdc6294b61d42c90be81660bf5b5515c836e673decc259618dee0f9bbc98a98f53431e1e0ff7639c11d778ab5153ca1aa87e30181118661b9eb4117e3c3413071502a2161581099d32d77d6cd4c71d26becd8ac6be8e3eefd260543884a69da8b37ad8d32443aece9a70abe2049fe3b3d72c3ae36bdf6642befbf8dab1debe41a2f15251e91ebc9a5024531717e265813f12677a95754d7eabf23058d0f8285528a18575440923e4bd2a0b16912f448df1130e61bcb0a3e482cf748d384dd062c99e7204f2c1866c043492a98b82f1761496b6b48ce3dae846142cb1e847fe7e2644b1489b099419ecafccc27c11d6713d0371f0193041ac43ff9479cf6397a395a21b6bafce86ce0577de784cd6f93090595f47404adf870c2e1d2a762e29c1cf919834aeb5de8f3dcfd17d466b71a09ddea8b567fa8cc4768cbe307bab0f3c0bc56178b5964fcdba8c0e5bfe19eddbd2a5cc96342bf4103032efaaef0a0b4b038bacd6b8ec9cac760baa6627e7a0fcf3f51f984cf4c9ee9cf5464b9e7d837c606a1591e09558dd9b46d6493320bcf766b221777d29ac463392e2204c72e8d6fdd774dbc7cbc7667d12b8f1ab0637535e3c4b72ad53dca01fc89d6c44690ced71efafb863842d675ce799b988ce163e3e9317cb80fd2676f7f9b66f7ea83f5673c97db96","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
