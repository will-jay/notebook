<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db364ad4363f9de89a0de00be5db8e68a41c0fa3560c404e1cb45a01a6671e80cc2e93bb79320baf1c6e69ad7d5200b31f9d5efb923ccc48331eb024e4d676b9f05e9a1b3d28127e2d920687947fd97bbd806194f26db8528b102bddb48d47d97e511ff8541cf6b1eca820aaa4ef95edc05a4699bdb4f7b11f61cbbf839e5377c5b1797081be47a050c5891863bf6b339497ede23424c260f1a5499eac2623a7d58150495eb60c3b7611eb2a68c39e1ee5b3a4da0e186ff1adcfa4d9720fabbc0b94281acc023e4fa3b66fa05a91a0bcbeb7e8e5bc3b41d18f272ae1271753792fd3f03bd00228f3386be32e65f49d9657b0224a30a98ab6e3d9d32c7c19e63fafacc0b3912e8c5c255bf47084b017d101504442ab0bf1fb359998c7dc27ee79d139aa384c51a43a0a54fece8f005a82b67ec3baee21c2c60e850434394d1ecd49597c2831e33783c0896032f972cafdb36de2333d1e563a8075a2f8e6b076c178407111a28835929393f12944a6d50f3200d614bf6f8722affea0a0fef03bd5f517d3e443e4c073bc082d3e52a1a14395e38035350986a288b2bb97d5ff2c2a53f828e642c4ed997609c329102f64727dd98d3d935d7c8667688095752e5e90926d46085dc9799ea264b4d46bf5b0fe9e0f502c5a68da692ffee02b456e18e3a40679872b745f19d16a8a8d2d07267902f5ecabbccf66154866b3e9dd201f2b3dcd3bb16cfbef07dd4d7a8f5c0c93d68e12c32e3128b419d51a3b387771447bb1888be64e3085f088dea445e329a4c12159187c570f93cb7309c354329b2248e55433cd01d9aaf621376cb5241f6b949471b95711c7209ae90fd9ddc48487f8a0633fa396d3605549b928ce70ac2506681629d9cdbf62ab8cbcce4cd7a5bfd86a2bddce19d73f8b91bd900d6e81da9e27db70a4123e7e1e04f44d948f92c7315d39c6ba9f149a4aaab49867b94b65de0e38a9468bb390c1ed88970b3c52e4e7d4a465bc2abf85e344b5b6276f6d8734622be11657774698e8a6c6e665efe11e07e31b09b3b6da330653930482b95e2c9b9a1b155fb76b867686f0417db7842bd141b145b0ffd11293dc7e2d11a8dfed62439fba4a44367c12675d4ae6737edc56a6432221873c866d30f818d4c0320a7c4a8051a59a94b54ab9d3e380168923a5802ab49255d43ab50a83e8c17e84e824d999a6960025d9cc3e21d073cec79eac57760b6e747f804dbacaa0197e4a903c9e8c3ccd9844a659e76d756ff7d1f4e190a5daa3143c2431c37003574644b76a2100d1333d996c5e4bf62d27424aa5318f903104515e018fac7c5c387216fe93e7e03686ba1e6b3c88a2b20121a6d0cfb5f72075db036af0fe4539b85bae239b739a615d30fdad8361353381368efddb688e3b2d8c1d186b2dc1285718ab6aa508ead69001c7c1e1be380d8da9a151491b325ca4bd5b1d8f6b6bfe1aaa7785b959b3560adb49a0296cf9707bba2e8062af050fc8bc717252fcc39e8515982939c24c24a13227f31956808c6abfcc33aeb1074125ddc05d2606542567a1c491bebf4091ad6163aafa09c367ec6e5437ad76404faf22a205ef034f2dd002605584f73cc971b59a253688c0eb223bbb323bc100213107940e5e47b47289ee7a302fa6bd8282b30f5f7dfafc8eaf4d9ccc70b141013603f203211ef165321874ffb3b40930f6e66c2531d3dbbcef595551d424dc40deafd8659dc3a390a79b10959fb3c2869894ac9059f51878d2de7027bbad65701d6b89c23c07cf64729365684c4736156335a3abe7be68bbe08910089ac01e6bfc3d06a2422b39d3b7205e78529c1c856f0d35e042a409bdfb63103461a2b3030da1c635b05e164d0766fac86eb111ef50d2bfef314a007cf5c3c1f3f097d555fa65f2111bdd14dd4353a74c3d600a317c0d5af3c57043c7bec6127627ec2b4aff367744bff3ab58df0414ec15dec3f2b7a6e73b1ba14533914fd3d0bf519812fb0cbbffc387bf6c33eae6fa1f7b6c55516a7e4bfc43035aa68081ffb73e1a6908683c88488d2a329efa76e74a2fc1573b43d571c89c80588060c2cc09619d6b43019fe0a29e3bf18a955ef62107bbc25e97ee45bd48ebf65a6648b5de808d99e1f96005ee21aff8c9c409c988a6f8af2b3ce0ce71f2044037bedf00c22b78ff75ca83cc1b8e7671e8c24911be790ae0687315d73143b82b92de22844f6b0b77e3e09e657eebe09d3b7a04f2959619076348256e76b21f98cbff1986f33b1824874469692a41d1a38ce080dd6b9c466c3d6ce0b59cf2cb6facdb73c357dbf303d1624573f6abe67d9c29b7f9ce013227ee45ab892780ad9a5a59bb15a5d9f6f6aaab32226ea39b31873aa1d8e3ae173dd249cd75f46606abf05f1eb704aefdb796b016191e72d99211b89d263a9991935024652250acc2dba43f9030d259b7036433e9b54688671b622c56f57bd22909a2d2cf39e86a7a025954dfa0f17296f2dc02a6b8bffd0efcf9af01046d5a6f6ed4b9cb07bd3bf47057dd81d453d1b12a7b13e23f4a728ae7d844add9863fe2dd48e2663d89717e74a9e89fa69e5082a47c9eb8ef1fce87e3fed6dd4762707e8c9f9ea14fc003b9b2f8924fe9aec807b17c63e07352a90ca3a98d79497aaf14b7391312f12a5a899bd5e85e5406ad9304134624b86646287c073d7bd19589c7ea33a9f7fba2d1b1838c5bba24cc3488c4f9a8844ec71dabcf02104f22f27ff2c0ca472bb6a0be86882b4e3d83f0b088e9b23bed7a85758b3875bc9804672a67356f76f5d8db3cd46f6c885917a92533a35344a883ecbe7cda3943056758c88e18f61302fd7d9910af8f62dbe38edd4b25cf1b44d82740ceedb15bfec0213dc77fd402b8e89ac63a06df270c0080a2af1773d7fbaea75b63478327ac637ad966b5e6196467cd4c24e03aef8d4ece135ed68154cc55b5b9924e77d7880dd483445a7313b5bee963ccc0ac658eb78f3da07258b07a4f29ff85a0d2d92ec7877064489905fdc195f9882ac42f0b775b0ac7149df2cbfd6b7cd0bfc5ba264d0310fe278bbe8c8ccb4866ba5fd9c6d7d7b7902eb2b5cedcb0b749890598f9f5d115e0d8da439abc0fa7ef8a1005310c107bb0b3c07f0be838432c7763982a013324183e19d60b84ac2c413048d62bcd12c085b352d6616f05b475a57fe8a1003502b63f84ee5b634ba2cef26468775f2ffcf76feeb8e3e0ac177ed371d57b1cdab219485b07fa18670150161f20985c1f8a24a18a5c5896dc2c5f6b793c4f7ad722c0e2285db74c675fe9f1a7ef21bd041944000cc80102a21cae8e0741c620559724344f6b4401bc59b86f222091a7fd504cff42ef8a3352bc7d58cc980bffcb79ca0a6fb716a47a78925843b851bcc9257e00c5faeeba354e318412449f9e5dbf4ca597019a3ae68a9f4da34adf60961d5e88e0014958d607c6e77ed63d247bfb2c7678d4d5256566b517a78944672c280966bad9157a7afc9ba6c42751d756b42d0400baca3d64afe3084a4ae771e51323a6da79e9efd148fa98f550de6a92c289be5a600e5b5d58aad0fdd2ac446ec2d4a18ca9c273baec276e0c4a0fc9ad42ecf3aafebade52a80a4e686e3cc38930fac566e93b2e660788a35e4831a48779ba178fcb26f9856bffd612b844bb8a243a4e854c5088cc80705d9e1cb3476c0b7dbe45700e3f5efb361197bd0ad600c1d607ddbcae209207dd7be5deff967baa4046a35e7a3b0233a865ab58077f9fa9293b0e50078babfa8ea3c402856a4c1cc0e71a7fe29e1a730cb88a94abe3c2945735ce6dbd68da290f87c8de0e250f45eb149fdf567eb6c491298062e6779d4a739189cd8975905e3a9e117a95e50e3f9f7ccb9d0d81d562ca92ddf51c6f70859ee51048f5015acb43f571b4d42717e486c35d67d24caba5be581a61838a3a6b76a5caee488874e7aeab55455b8a37ed96403e02dfca5ab7f08abe7f3c2fb984426cc54f4bda4fce54f2c6a36922d385808b09436f419e51a594a6456efc4f61736cb85ee1174971eeb03141062086b7ddb90e1072daf8b18c409508c0f41fae50dd56a4530d84f7472296dfe4cebfd42aa8df9175910de9ac3640d0153e77166df21a458b4524492b1a8421ca9bb81f6830ced125eac6c2d43543646792d91410b88cff90ee28dc9443ae47254fd4047e5f507195ec2ed3ae89f46787e47d1e102c563e6e4daec7e9dfbd2ce9141535d210414180f46180ddd140c6a3929b744a0475539011fcf8ddc42ccc83aa7b97f278c5ea33cee18b5aa91ff692ab1b3c21574518f3ce88d3f0b1069b49ba1c29ca5d171ff0ae70b2d3ce0dc292681be5e30461eab7397a3b3d51c2e2ed490ee1ac6e5d0f8aaa9b33708afa3614805078d889c43890c103ef66cd6f5678d9fa804ff1050ce7e77104bf5d60ca5db985a5972c2d72b2f89643eb91fa1c7946175eb28cc850b0493b42d99491ca0b36cca40d5c6c39c65acac51d0884cbcc816256420811befa26c4655547634e6636a7faa0eebf0b22dcb1441fd5a465974941ab3239bc5f5426b6bd001acb024d0df70d6cb4c9405d61d9b3fe58df35141bf658d21dddfcd2bf9352320116a21b1f324c85de17a23c9ab68f386ceb0b9349d82d67453cea9afd9abf2d90ec81e63337ea735a1e9c857ee90fa1ff742d1703360bec548b27e0aaa963fa0df9fb7f753aa2e2cc70afa777a80ca4a49e602f7003e1a5fca7f782c3627aa83eddab8e6d91fc786519fd5d2a074d5f3f049c2c1c78dc9bb911939950b54101961744360d701abca8a754965712fd8a7d6fa6bf40da7daabe2a7d0093f110449707de6ebc9fa58ed1c85f2b631e0b82be9a9906b90ddd71d89c9b37ba12c934eb9cda273adfac627a3b4ff365d32fad9c8db967e17b24ee76106397681a06c2a66d777caa8382aa8890f7a3686293f9a113758de2763a363bee0fc0950799c2c03f0f62eaeaa773104c6a063111b3a2c74ff5ed67520252b7048026ac8aac9749dc43064fa0a9fbb040f5eb98a2440c63a29a1e753f7f2d427fa31163e52c5bae9463287a1d046f6c9dc6723addd7784d899b11f28a231ca1b3c123d9d99fa769bd27379dd3c531eade7132e0a47c3f7dcf165dc5290761046e1c276505bc028adf67a69846e0804935af489555a6f016f6589ad4d319bfd5ec2033d8d8af85e3afb0760eefc417894d716fd38c8b4c898d925fdb33137872246660d376232dc5b44aada384dcdcff7a22b536a2338ccc6d82cb36e68f3b04ef1500bd7bfdf50606adb8d264855828274d7736be85920c37d6218ea5b4cb03944dca993e208cf81cdcb25eea17414749204bb5057eac6fc0c450250713c43df3339f7fc0479594c595885defd00d41f2cc06dff3d29d8ed21513278961a5157252450e3ff75eef0a28dc4762071ba28bd5ab689b2ef1a83d9d3db1f2a41be042efab2b1da77cd0dc2d67094a41bca2f0006248fb32ce87066bcf7769c8f6849d4ed9866143a9423bfda868d3bb526512dbd01e1e469cbcf6589cffa4e473fbfcf7a31e23cabeb98d2535bbc8cb5e5d8aa7fee683336c1da8c4caf2f8ea5f1391e155bc1b58b315ee74e19549872b1847cbe5d0a4f497365d304b0a7258300b1c59d12258e11d958a358d3fc23918b87eba331ba54fd0802379a3a1d6cca0c6a2f0d05ab9c7974eca70af267317f8b242f3828299207c7628e88eea73d09fdc6cbdc7e9e1c3fd8427c6901514067b8220ee88c23f491ce06c17489340edd5a329c70af835627f0e78b44ed35a50f9b9a4967cee16c2d7e0599088f88d05edaa233b414e4e3d346b96ac747b29dfc5d107c86b561e56043cd5be5efd7c0f0ce7411fe0ca75e357249dde6f9cd580a6c25575cb54944d079ac8c56462b6909ecfa03482374f2fea37ebfb0673911da1ef572ee21540aa41b63e650c38343bf0341ebf977037e3966f7832cb5c1888527605ac190a781393f2f9d394fbbd0c4ce965f9d82f7d619960a5c7c4e37b43958c5c4a0a17b5803e2fc1da2215bd522b6fe633a01b83a77c11e70120ed85b9fac2eb0a1d6de73c33b9514ae74d23285808dc6b461619fa8d0fd544b625a6e96ffd89674fc847fe0e136df25853ef75f3455ec847e8591329e5a3834175d1132b283752edb848991eb983e12f6ab359bcb8a1d4729d635289931ef74a463bfd5a1f389ff20e076d40fbf42a10053d9b724b8f1f9e71b84f1bf3d41c26f3e9658e0daa9c9a1ce21df53eb2b47c4da2ef76423a3785ed6dc85256e64c85af2521b9d3a26c37d4baa0acad80894da1f80b470ac66e8adc7e0accb217a3c7ab7d28c00e34dbde3ce9ab350aa1b149dc6da39d4ed27366490e05092785b0eb70bb5c8396b8302632595b27b933f117c1ec689862ef7c329ef068b06fcebed1378c3d8099ad8e786c3e9627ddae2e7869c71569de38d9e7c94a0125557245b79d41983884f78312d089a0c0be2d2fc62eefcaa0fda8bb820f3773f06f6dd112eb59b04effe8a2cf7e6ea04af64e6472acff726dd95fe5ae7093f8840ed85f0faa3e0ea89b0b6b99fc924889fdf39730d7d7782926d859e1eb4e8f0d7a068afefe5c1568cb5ad62b9d09342df363945c632b7fedbcb7bf2a6a73aa77d02ce6bb6d0330811a158d0979a4d6eb289b59fa923bedf99ec4e832ba16b0baae9803fc452c8e49ccb142baba819c2e5cc708cdbf2b72783809517512ea67ab2908e7e026d46eea9e0fc2dbf9423050220442fba51a51539e450928d8839f50f12071078869d53661dc25b224878757869b2ffbe08fb9e4ab4b9cf2fe73bcc3e13ec8fc2dafb864221664f09f85fa743992b8d09c09e81c6c5fc658348b8ad3a7dbbde7b754cc86c4786e34753311edfea4f2c74a2fe231866f729fb6a8935506c5f199a4efcff0c10fc21fec3a0c75c1f0314404137ca413bee46332838413ed7fd5bef60e6613be5ea3d2422a34135ae66dbaf1bbc7913893c8255dc9fa8cd2e9fe4faeb32bcc6dffe7271d5260160b6e53ce5f9dd7e78f91983f49628957b6c3c78c57bcf9e799f6fa81f8769837c819f38264ded58552e0956fe8e5710be8205b7eaeba22f5e8c9ef569659bf36112cf3b8c97a866df1e2daa653652a7e9ecda3c6dc227b1a7b821b8ba0de80c041b81661a6d4b316ae9347eee33c7ce2043c4ded535b3d90294aa4b4c7822d07218240388e64ead5ddd619f8c6909c0b96ab85feccf42bf28822f4906326ffe1605237f097760ba384aea3c03ce734afd1505f17f3009eceb4ed926d5d04c2480034c75c942f3a6e6e8001d22c49e09e944f1b15f4431e0273757a0cf9ca3991f1e618e33b97796ec8fcba543f28227d94f856f68a47247a75e6e96248473d11f2842b8db6e0b133bda7938cd5d50396cb0caaf84638bb413048ae04b5df0d83ec6c141494bc1c37d6e9a4652a11b49779feb30de1a983fd61d69b933e8df14dcd98f11a9dd41078f2bb597823bbfa68afcfc09a66fd08f56b18362ee69da4113f351b376b64a9540a03c48eba1523a6f6e8a8be0a02a6594d268d69a1ceb947b7df08c05d36fd3a24adbd7f92614f23584230ceaeec8891ecc0c6c972d31717679bc93af2090cc585fa0ceb6f778120295efb13a81d397b97a508fd6ce9ccbcc8fd53d1de9ca8f3b3386ffbb9769301ea07093bb2e661b6cf82750a5c7aedfc78aafbc4f598a89a6da015bbaf57f056feb9787d2d062fe67931310b924c309616b09ca4f8bd88431c34e7d1406c144fe27dbbdab216c3b996d1e3b51d670076ba459fb237ff0d8628943f2ec19a7f05d0d63fb0a3a3f2919fff728ee8186d47a80654f1ac2361bf9c278388ce8dc42ec43487793afeb1f803a3ba8f0361d5487749e6bdd725cf941e5ca8b532f6f943f4c047b67682851a2525d3fe7c039ae189bcb4070036325b7dc54f3f794fc7ad924674c54039680317da3a0c22048e5461910973502e50db8783ce7a3ef10db690bbf3026ce72825cb0c147db2c8241dac3c5e5877ff21317d3dbf38177cdaa93ec5e9adf3c018bbf595334802bc93cf3b74cecfdb1c0aeba45af7691e1d1eca3bc883d5754a7dbeeea0e73a5b979c94ef2c54b851abdf4e93b90edd7279f412dab65ca5a89703aab154002da85367a03f72fd0bfd90a8637ffb85fb3bf5aeb0c5704971a565453bf318c20a10d440028a1a9aa57826c85dc5c8d20fed9ff42e7f270d960f849ba739253787630c1ac5ecff4dc04e98775fc1e1f7b9e7051ce8229a0977919c056eba11c464ff28fa2236b28e3e8c98a6192d3031dad98e917c3bb72a0c8bcfec393f00a47cf786832cb026f44fcb4896ff121996eadef5f33afd17551225718949887944b28b1bc4d85547e944fbf94a2c78d3e8acd04ff40593a9f7a5373481066a29bad99bda16634ac780b1a00974e3a14a3c44ff8266e979a539e36e93a85f431b97e78d09962c244abb1681f99701329d11ef11c10273f66d23859d6f8c670538007406ac32ce4b999b07ef9a195ffc4ff85d9382b2a418e6797299ddc77a7d9e2b53678ee445bf92684199b95b32e2057744fd9d5d2c67e91c36bb68e859560042520d64b4241ba8fd6f2aca088b3d676f811aef31c684481da4d5c74083940fd152517c296fff6598ea9258b1b3afd836d84aaa7157b00e32c5db311523f87e47a5896f2b7532aa1faf3bc46cbdbec6f827016adccfc453d66c315defa7457951f6074fc6cf8213e06735b53957330f8b5e481bde27792f2f7cd51f7bbd37d9b065abad020c92b5038232d7bddf6075b0d5734b28dd3d747ed34fbb5faa9f5de43d821589345a831d4ef561f2ef0b382340119f69f7933632e6d9b60d48803ea31901c4666f275159589a63480668ae2e0eb8e226a74786e718e0d79a1bb25601f722a9f4c5d5aa73967e07be84506b01ef44e0f4da9fff673b81db6221f6c44633c217f1640e08519046f945343633e4146b179f327508e852de418a5fb3dc8524f2bdb5342e4ef7815432a978a260fcd7980f8138a01025678e540d6246ee88b5a18eb9205f79a568028864e26e024efd3cd0a0cce5399cb23d6738ee49e4942b36e19dc690528dc20f985c2e8ef12e42cadb2ea3363e7ef76986f8e2b8531c93ef033458e5a07fbfd872314d3fc837ef5b8af903e6760b6d3933102393a537e85ac1341ea4f80a2d4c3bea3f25c4d3278dbf54e618f774a6f6d2bd2c71f0a6b9ba58680d4cb72c695c98a1193ae275f74a660fad03d78a23972fec653ee9cc2b54e45fe2b8e22e5588f21065bd8444315977fc2701c583c9c72aafc4e71f2cd1a75a5f250a6ed2781c6490dd9fcd804a5c732c15c5c0ff83190506add646ea6a0c014c6e2057164bb63860335377284d3a09276f4e2de7739e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
