<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a4329f53ecece9e1dac70aa7c67b569d999d41de723563ea32e1a6145d01cb1e69d513163b0b461882a89e8398b6c57897a455a43c7eeb738766c6042f5c27e2563067dadaaf0f44af28d76326628d24b55d471dad6d3fb1fc533d87ba43f71fcb72561178f3d3aefc7d8ae6be8892a0162bf940777e5dc8da1672667a4d9f09bb2f2deb047a18d6d726b4652512588546c4c3d9b731981699187aa9c50655e49cb293b18f5100271f1d7150fce2eed88dcb840839bfaed17605a5478cd05022d37416c84349708accb5ac050b8042a48fad120317ebfd069587f0ab0873ce5b1010a7d4af5322f0940875bee402f98c309065c60c28d909aff6b45764db9f5bac0a3a757e148209a68d467a4b329a9b3eb8ce55d13eceee761193f6e821ed88d26a512987f4725a54b648d25f4696a621599b422e8c2aa0d8be53ec0eaba29d3a2657e12ef92ce2234561ba2a2c26b3bfe1e28acf7a718481c4223854e2189bdbe1f38022d1f16e63a395456c545d1dcf153fc521a0961577161cce4fc88a0e93704180c3090f47216a1fc07cd3b107ec2864d2b4f7bb924bc8b35eff4c511d7015d716d6313304d1f02d63ebcbd14b053a5d2d2c7d065ff10987af086b7f96e9a57846d4ad19ddd752d98f664cf1f3bcf9b261007d09cab618e9199ba2183ef3a304c1ea5fb774bd844fe29e1d58675cd56d72f23c8700a2cf1369c0dc261b78c913ae69f2de4445156b0b13fdd8290fbc7f7fb88bb4dec2e46ff6c9ddcc0d5ffd31a50e7416c5b41ad53bf7c17073a39f8e56109a7e55eb122c219d1e2e645f37416aff3e8bbc0e2097c8c0fa2bec309f4006740935c37ff4618efca220cb6cb6a600f0ddff4d50f247307d3e800d61e025c37eaff918d4e89db5d05063ed6501a9da530cac232bfb324e9874a45f589d5814fe8556d85836022ba9fdd66eb8301f8d04fabca7a09a283ad91656b52a2ab986f5cdc7a9087a3d7d1e2fe0f469936b3a872c0031f2616a6896f1c81f9230a56e316a7bead79b47f618b98a3c04c7d4c6e0949b9227d2836baf58e1ccc544f169d6e1971a0ecb41cc104d74414b2053cc607a02c98ef89d4175e0d0fb0779dd54f65f18ccf5a0e14b64b8fa21e968ac39a74221a8df1c43fc557406188a82a49cd90256fca8f25964979e43b0504f17ffa260fa27c6588d9d27ac1e1e69bbc54b67d16e15e1c232f4f80bad9f3f4d74a562f4ef9647eb5a7ad61e7b4154292ab967e10bcc0d5f796f0295d4d5931706a801f54c30a671ad5007681623de6124afa1c9ed8067c03f957aecf45b65d90c4396197ccdb4685d33efcddd38183229a568554c88e43fe1f9f1640c2dfe76599b8b5f677c14d814722a1eaf989292297633016f744f1965f59625f995015c61d039f60cd98f6a10890f56dc20227de63d42d5e420271c8f44d1c6f53be48815330b3bbb8e2760c7473d7b1397d425b04c6d1449cee0304b8cefb3dbac1ab7082a8375f6c0f767c67ccf44ba72bb5de993aa4407f2fda1a0c51f7f94f47eb4a94c810743c7a59236f557cfcb5662769b66e4e385d388e45832689b1b333f2975f7e09f60bbc265c6d9b5247fcfc812ddd4838120b93c2df9827f83022401f867745bc87d0dd01d3258cdec57a39190f0eb30e97c20631426f9e29ec3800b3f6b8cd2211ef9aab0aed7b872974956ce9d64668a7f2c1b2f534794ca145786103ea84895fb84be802e204a6810aa08521c504cfc53b2725cb29c7bd13a0094a7348ebbb7ebad98e71e2b2b2687c5f43b7c4f8a67596b32748fcb3c1613e5229bfb1138a249f03d2a76b29a75edbbe1b8ac30ac6872965d9fd83396b2088b057ba13f4c118a3980d19e8da632f14d4bf38060b5a43fbaa8c5780833cdafa1b983b5b6cb5dfda05ee90c7904e0cd95e36f43b2ae872ba2fd7eaf85f3d234ecbc9d4d55b90a1ca7070eafcc8b432c648d1ff658f7ddaa33c2a767c772e5b3fbb01b2e6635885986e6c20de65fca00feb8c00b38201e8f651078d2ec213df3ef7c938d7f3d299e957439f4bb5ee9ade6b9d61b70f26b71f44bf0b51db954bf364ee3a72208fa34e8071d81e761900b1ca704b710fa9a4912e0599b774ff0cf4ec8450b5fd93296a87969fcf51c91dbb1b2df5375905d747c973431479b0bdf55853f500fc0a05c2781d493b5286bfa9063880fe6ec41003361fa3b9560decda530e67fdc425a6c42105a3429f467ce685024e56042bd135fa593084aafeff6931e93a4b840d478ef108f5e5bcf6a31222f5076f792255ea90deb0b5be12e12265a04ff12d1e581240c6a83554476f0894c51a468467e61d8cc36869959a810654e1c8462a9bb2eff09ba1fc3c19dc348bca82a9aaf2aa9b0a2c31f46efd977931d2da1a2e109f0ec45c2ae2e85df1793e04cf369e66ef5f13cde745178849e02a9c42ccb3b0285f98fda6f3fc05eb7cb03b20bd9abc54c5fe52741820b55ed473763e46de0a7470c6f0ef97c55ce48459c182e09894b43152336069d7361321c873d1d721960a4159dbacae8a87893f0b974322104ade3454f9d591400ed04e9047072f916e582be3cd8e4f192cdb73eba90423c2c9fdcaf46b1169467096feb5a476312ed085c7a3a95b36a321ae1e227191b30e2b6307eedc8ed72ee63fbc0a786d1f04ec5780b09b745368fb55640514924d9dd03d5874851d34fd7c1e7712c58ee73024b4b2422ce8ee9c5d5f9d5fa8568d0e6b9b632727f0afcde41d8e1da495b736d82852e7ca5a315fb15a03db47739659874931d7a2ea235460672947e743088bdf393d25739b2d0ce471b5803c08b2542bfd12d802452f775ceb19f043dfe8089eaae7f343ac088260829e6ef48e706b4f41753b878bd8c864f5b3439ec15c11cbff9cad6e81054903491eb1dba8bca8396f8bb379a4f169001308882048af575f70abacfc97200ac356f52f9d5b95398145ad1165c712a6db64f5483e0d6de938b04bca7c2460292c3a1e81f14ec4be7e7e1792ede77d7796686e7cc70a7ad3b3a816cb01852c817dd2346c0d73f557e18a3dff975d8eb3079c2d4792684795f346b0ba58d1b1747eefd1912f2dc68b967643d960e941aa6831ef83edc39682244399f46157dafa9d89f04264147e2f6b284898e28ecd24b090d7d730cd45ce23c35d0a026654526b31af96cb0243dbeb5f22e0504dea8448a8dc052ee5c0a96deb88bfe51c95c12cd573b762b6b78b685ff539920cfbae3c7beb96a1b423162b22c2447917881f5946c77bdae91f61ed5631d52b4dd0ec0344433e3efc408aeec0ede61fb27e649ffcce2d4451dbd901fb9471fec2ea40019ad1d2b509fe8932f7855c5441afb1d60ae22293cd293feb0ebed9b1560d4db4f818498b24a690ac0e73e7c1bcca4e8c6d88cae6e4cdedf46cbb190a60b7dc4370066e9c07dac8dbe9af0a613354d1302aa82d1b1c7c91ee80a38be403bc8636487147b84b5007a490e2ac0b99228f3fee9fd2ff38348b0d0b4bd5340b39479b79b765f544c041a34938add4aad5d6c4b1ef1ab3664d0dacc8b6fdb4c12c2d6d42ea4c0c39db7bedc223f33c7c86cf654120ac862e1c1ffbd473590fc2a30a90eb168ffca18605e4ab2a6613d3994c25505085cdd47e519e7d9c50a6c83b76d017a6529e9dac10c711dd134ad41689f25d9c9020ed81a0dd7fb84fb5355b001fc9cf173c8a31f9e1c062613186b73c40eb1396d4051d3bca236ccc608c53bb0eef9165f54b61823e1c22aa34045b6c3a371c8c909e5022d4ba4a43d825a4bde8c4efa5840713b1429b79d20764f142e4b319404da578e6e09937f0b4527d1633a619d554d5dc4d0b94766060b25ae831782d93a67b26783558f5dc1c50f448301b5e786cc401ebb5649deae57ac66b65c59c8dbf33f26f62e72dab0f4cf75aa02c6459117a68d956662fbc5c665148e0b4b6fcc172d14e37cd6c5a0887d93cc45dc44a12d6fd37aecc64ea1227202f3ba91d879b31dad6d7bf7d8ae67086e8d25fa77d9ac21babbe4c3592d7022d669badd780e00358b8cfd7d27baa003e62bc60d7c68a1cc0f0804284144779486b27ec506179e1e59132237c19eaea9b458606b9b323e88728dddecbff21d6c0335b1d6eeb35f4aa3ba90e013b72abc53a03974e00cb63dfaf801a0e03692e16a392fdfa1827b1b568b15ab13a1624a7f1809b79628b5241bf0038db76bad9d0b81007f1cd26684358abf717e3eac5c1416a78c3dbeab9e4c44e2356142b8a8197649666aa56f84a5397b3239e77e99e50f3fdd6565074684eb0521646ad20683472ad478ad473b7e743911beb5c4bf02ff3b8032df58b478e2756c1ea0519b723da9be3b9fb61c1e48a380bbb69639cd8aeeed3ebbdf67e2295e4f5d9a532f5f509509eb6f252e3207f17099cf5ea6e651d86618d2b601e10efa211bed26f5544f5f46f8392306b6db9da93d678777261a0c83e2879a732f589bf7097640b9dfa9436227d2774db19e4584f14fef94b19f53749e934ab89008a15cd06fd8287f5d29b5bb5305bfbd884961aa82840b703037c1c1b8a242b17c8e28df24fdbbb4d4a3cb496ab1542956057b0cd8b08b1e353770199b462a5f7ee2fd48c799350ebda05999f761521b2e08d42acab1b25d4fa12b8b0ed426a36b94b1c126b2a810f0b47bb2915ddaaa6356035772c4024ae1b76b27efb15d525d96443b88043df91415aa8be8743482f70fe2474144efca74fff42ba50978681e08fd8c5a0c967a0ef5afa6ae90094445ac076a540a877d21bb80a79a446c71cb2725d8c3d8a4475ea497b2472eaa12643b05b302f619889893ca12c14f8e8a85143977e5d6c15855411bd9878835be4a3828e1c01c68575f6c3abbdd2c4702881b382072122575ef23edf953950dc2b63b9c362e4360b9b63e014997059903acabc303ae50cd77c590f6d261195a494511053f3621736457b16acf14fe1e048d97b0c36f22ff8959891cbb7bb34939d53382acd1deeb4ebd27bfbf1957144bfc66178c8c0bf06dd973ecc39b2b24e06e9d27d4d77e1d28ce513188d2acf514fa53ee80a650af6c4211888e57a9fb5c34faf70381d3aef68c41a48060b7bf908b14020b252e5c91086d833dd2e0886c660af74f70071c3cd754f2c77dab31b9fe7ee85184180121603b3157ea240584aa4851f49f773caa51d73fdf6641960e7694aea71b29ba39e23266910442f6ccb7275d4195bf069ce3697d10efee817af55fcc09f3f68e376945be0ca0c97c1203a9a2f6c354dc5ccd4ce2294017eaf94c127a993553950a0d8c3a013f4eab5c5ad2c41f907ab3242147824e8626bd3948318176a0e7c41242e819d722a2ad5867002e83dca90dcf75dbf071606068a48ba12c5b71780eec56ef4ae1c963e3352294a8666ddb947dab266641249fdd4660004620d89ab155f1ea18e84eec720b98ba6face85fe7f893f8c815ec11f6756aac27b22a0417c8f5d865c026bfd17afa9b5f116ecf2b12da2d9d62aafe24ac57c551de946862aaf4dcdd479392b9a3a59b05b619a5fba0c3798743c68ff56fe14f4a99facb92493ba18d658c838e3a4123a2115e871c2181af0dfb42e0a7b4816e8fd0fe33d544218925f3c277ed55c95bdccbbd8724054cee0db83c45ddc696f5b641f6b28c088f7aa877596402090b1795ff6cc6bb0db1c99fc0de56f7237e2954faa25bdfcc68b17df490f7bd056cf07650583f65df96ace32d7362bdcb76984129306d94ef6c50c35e16d0cdf6553cf70f1e9d7c1c37e0d04e8678d27354a3b0b434d36f5d59bbbf5782669644d5ea4ea5ee7043f19c9e43771deea40d0491f282015452c7542774d90cbd84f556e3d2fb9d697b1d0816d9bf3c9660b7008eb481da5f2f4b168c8597dcfa58546cde9db097b52c22ab050af943a1846ca3a61f822c2b56e560c1279b04a0800fba587287e7bf347c308c0eeba0a2dea912646bcae72a0dfddb9f224ca9c5eeba6d9bd9339b70a7e9ab171568d8252e668581334e1060e960583c1985233cd954820ffeab6a80f7edca040e4652bf85c89a38338faf8ffcaa481cab976afe77bc9811034fb0fbc36bff640aef77b9e846bd3d05eb42e852b3921233d78858ff37a0e78e73f6ae61d156a1da6e2adea9df78f2cc735d18dce73e16f1ef1de8c5990408472e63d358176352e816b4d19de19e789dfb18d4bc9dce95b2d10920c60c2d28910ce699f900f9603ca2bdd20aab861038cdbca6420f46e6267171259d8cadd12c1ad5d05cf044c873c7322bd4e4f275edeef7b47f849435f9a7e063f0b6e31a6faed44e8498595aed5d0d73066036ed320b7b967acfd238205dae8bc83ecb3736954808fa52ca4d5e20b0f884d208342c9c4f5bde5bb417d775fe8b1e654a9849c9b9ac1386c7646f8e57bd4ba50d5c685ed1d49c5706e5ca02609d4ffc1bbf645128258918c4c2ada1ea3f61969b9ebc936943c051dc6ae172b37fac8256a77383c50a366ef9986fb3c6f1b1d5d73635c3d3a88e84d6cee796b7b870a88c2a44516c2aa6f8915975affd472fada021453820c78f19b43d3955455fb4bda18c3492b2fdc70a5e25e6a78ca82fa6b07cb7bb39bb8856cd6178de4d9396acc6024181909099bf352af623f23172f11e1f0d9efcf9a3ad433b874932e30ca19afb7e215288c91bb2d39488c0e10890bc099ab5f533488c7490d5f8fde41eaf7c3e6dfac4140498b74f2cc48cc4adc5cf23f3b9299927d2ba3c866db22f7a5cb701a79f71916fde5453e4682b8bc9509c6a9a6ab304f4c4e69a39bd31e21d6a1e0e3833815f774426240e7286269523f8626bf49a60d382528c3cf3b4448308add572f6fa159cdb7086e4f8e58b1b01d29bb0a01371e6d8ae16be9a7d71b4774c7662402d17abf375546587d5cbc4458a3af3914dda2e7b85f5a40d44c8e187da7d9becb9f2c6fafbd166c33c46901c267b3b7bc78605ced184c28b5d8ca0612b567128a5657c19e63bcfeb1bf7e337f1a2642e8d6ecbbbba09041a219a30939c1a346ac2a7c3f46dc3e987c2330a43537432deb41634201630dca4d2b1f84793de3dcba48abb1eba89dc2819b24b4af0d3fc8294f9cd01157e056a39ce20e7465679fb7a3404703fa41e2819638b6708809a3a741cd0f14bf2908f56b334602557c57e6396ce896af4260905092e57ca8b5ace4a5abf7aab58912fb32e0a7e9f0b47aec4d624bb69fc7c2f968fb376992d91c05312ca899462b0d83d8d28a629ea904341d850035ab5f424f4d4d64191251f248a541be1aff76f08a37b0f368382a4d129daa5250a106ad2d8a96b168ef4879e1c209f020cbf0162e7df24fa4de187ad39342efc97c5c6cde879966fc729e7c1f336546d708b7f7520f0a067c87e00f875a24803bae687f968133c3fdd53c8f1039913d9eb9274d450e99fdf314b60b880c95dbd298c69aeaaa8f729f018978ef496b710dced1e390d43fa5e04ec6bac2607a3457a201054d49e5b0d9b6d5198679f13bd205781f33908eaf9e6149b4baebe9d0c90885bf651037e8ee3e82325575a173651a711009499af197dfa9c2f9d7eb180e01a00c5cb726031180a6de89c03582285b0ad61247afba6cf0eb8ff3da22a2795a13b03c58f8cb96932dbb54140bce01ee28696b27d5534db840f8036cfbf902994ed9f2bc8131f786355e9149d0fe7f7c5501c4fe663eb83b808631bd59f3a460f193b1795fbee38e263dbeb22d3ce5635afc6955b63f22b406f8b24633a54e3665f83a338a9c712fefbd89b9c91af296726551fbd7ce14bef8b0348d98914cfd02ade69a2ede27036dab8b49306982402b1c39a918afd4a301cc0a6ecb5038b32e88353d143ff3568e1d4157d24b85905fa71434ff4066d24b7c6b530e9018e882142b79f21c29b6becca674b0aac7567144c184262fe8ade675ef707465f8c14b2a0a8e4cc4988f7ba21b163d0c6b0ae3c64c89478f6a8e207fa364045269c96fd429cf3c7e63a21da62924373fd5d859f84d1c950869a3c18d399a2ffe55177e2a82f920a9be8b9494e72cd46f6ed0dec897ea38bc1359bb17552267996c9add0a0f1ec3b78c263e07055752fd9d256ccc91645ed534eea2bc3b0f33228411812dfe5b989200a666ff3e4906776517404bf07672fd578446a4e121d4f8d57e5fd64e965e6ad7159a3524da24ceb0173adf6e43588181600fc69e0463843a2066702c70463afcbec943f606071963140bb5e10dcc4547f9de1d7c1ce04427e812d4346b3906c7170720bb2fdf05f3e45f5341ba9d39617f48718a0a55fca4f30b85f96911ac70d984c80b35debacd7139b04256a7f5182c51b61b4a7d711bbcb134dd9b04287e8a19cd80485e6f1fa8da17bee7d2d3c9264907f04be0eb66d7dc310e95162ea13f41a9254df72ce1032e5083e5f1a008f0a2d9beef315b631d8f1cce2184fe7cee3eee48dbadb0a9824653fe606704506c2ad93af6da777f1292ef21dc550f8397d6b3bd92ad97fd73b18c07bf14d1a2ecb36fee9c4188b85177a4916ed7fabf79490db71b5f8323e8df7be8c93ad69728a52c11ac0bd7edab95c0a7eb903c0eacef86a34a342130c20dfe0db96e66015f50029c098938cb81aacfca7ccc51ba75176d11c125e4304293cb565ece4ab47c9823369b80599b912f1a908d903d7f830a1dbc04d501d91e6f3452b37658f4af30dd10cd8885e8dc7beecb07213924b66c21d3733feb103dec0ed74583e25ca3f478a588f6117d6df877aada276796949f9a2db0345e2d6750d03117814d4e8785864263cddf8321b00c9fc24897dab8560457554517faf50129ee514d0ddf316a1d336297477286d43a72c7f8c5436102386f80ecc0d709158fb99c798a0cc5944cbec5a3b5d91e7344814f9fbf3f40d4e54c931cbd18b5fb8c2a92391524e18896949b4a9c1e7f30677fd0953b192f1fe347d822ba78313dc83640adf4ee1c35d9ebb3fdc58355adedee0922de70944268a98b1113ff1d1893d03eaeae5b980ec38735dfd7f835456559b51ce1f882b196f47fd97d16b7dd2ab32402ce5db8695a18d9c61e5985d37e4c3986f23d1790349aca2ab75867e1f21ab161093da77ccfb0d60173e78210cbd35660b6862b0264142c8fa8211f047bba2735bda22776f1dbcabc55fd34d9d0ff003d5248842924ab69533be6f3abd200ae299ad05e9d19b4da5ec1b575f5853993e41ce7ab81d6fd6adf03cea8116f708e632d3462f46bc227c65bfef170cb68e6c757b004d0f6becf3b7045f20b731c9acbbc3b9f632ef5bcbfd1e36d8a012dd28d7269f478ed6c0bf2745f74c0b79f6f4b3496b1c63e3ac070c4f18ec87c8b110f373a7fa3c234803deee7b79630ffb42ae39d962183c144b94394e7c9fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
