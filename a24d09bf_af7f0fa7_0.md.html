<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d68d1f036e2881eb0c3df2f64e7b82cdf99570798123287a59cfd0652ef3cd94c519a189f3679538b646440151e21dcd758d678fda49695fd26ad1685b19ccc8c321e5f6c2f6cc8ea48708d898a9c59e35d40887f58a44aeaf2ebf4569510d5cfc8d6671aa3c569116a1f5c10726738d1034def105987431f9348a8aec728aa09faf6856cd595280bce86609c70e7a3ac956dc203ebe2c0a1202f99c5af14d03aba6144b96e6148d157575e13d36eff5667280a004d9b61c27fec48109d2ee41e34697c2a6c239551ba98c92fa31b898961e1daac5e702cedf0b393d65d857b1a8721d436faa756aac11201cafd8f8462f426fe3de507fbda0f5a64e98fcf5016a085923a8df7f753556a1e1d91263af673f4e86cd6abf8586ebbfbfa625cb2f94358e1534c336b5acbbe49438649bce12b45eb3e50e2d2e14621fe1aca979d3e1f504c9cfe1ce58d22514f73fcd6a146e4a22c482043988dde54a2cd90e1e72a86fac571e85701b8e3d0fb6feabf48d83eb82bca7c197fa324b4286e218eba2afc7193b84f87a727178296af663be2e2d19766540d3c9467664dd628fdff87e3726cc0fb95255cbc65ce40e5a53342d1ff6d8b51e5f48f0be5806e8d9efe306a8c57991ac7c444411a7c9e8491007a5c83c69d4e911924ebaa2f61ed777d2b4fac143442922c92ee765716a6781df9ee9f82a03d4c3d6b93d90b452a84bcf5a2352a9cb965ec1d0d0cf9be5ab36e24a8f5b24f3a258099b61d232782677967aea3b8fcf141e2cbd5d51bea56b5d1023b894afbe1bb9bff497cdd80a77a1a5d9757dc0b498ee2eac337d34c714efbc3be6a3224d06f97ab128fb0cb9fa86edb382efb99acd9d36875914fc3fa52281b3590d159765126671caab0e530e19839640813d8a25e0f948f89732ade59f9ff593a6198a1ac8cee1894b61070ea8a86fa4d5aa7ddf7ad580e58994ff87fef829e519d48fad9e32cb2d7444dee26554c0cb3e8a9546370dcb1f56103b7e9ab176c1bc2e9aa5b977291435c875c153a1e5a0876b1d6e34ea022c815a5e2a24038da0b479dae3220b7b9bfb692af96e59229f15cb2f903bf4ec3d374bcf412fb4a0b87353256ae9c6b7c0113c6c28aa036b5e9dfc3677094d530ef167d5664ca879db56424eeb5c40c3ffd1115b358b481dbed029f578638f1613a6a9222b80bb9e8d82f7a65dc97b104c7000cae239fe577f8a45d49fee51fe32bff2accc330e4bdf29b27db62800a1e95ef8a36e46b073d1e3301bbb32b68acd0c787e8f822359b119644a1429935d99fdad8c9c64ca860f15ff5fe018be103c41c535836efaaf997c6f20dd771d39840fb4a23ed6a0f5fffe0f97cd6045f5882e56c9e47c2b92198ca700ea87e1b7b9547ae78a2f6f6f33add9985a898dc5cb063d09bec3a7ffde73fa6f5df1dd3e7ba227efca3133112e079022c86ba91ad22259c519ce2d42363b24c6a9c717140a1bc67d889705eb51fe97da879d921315680005182b2884ce6dc8bc7b8d2126f45d1b3af7c5eed92afb421b1b50aefc27804b7f8467d6a74a92f7b61db77dd62e8a92ff8cee6468996c3ee0e5e54d47684c43ec2aa17eb89824ef7b64fec20b4d6e90591ba5de0378e6656bdebb8cfd80531a26eec94594a9ead0aff7280f07402911a90b44474b842f62365fb34ab21d6d2a73bc9c5840ba469e5b659b34447b63f328e6ae57519752548a49a6450012fd06158f3074324591d22890b54f1868bf0b468eee3c21393032dfe8b4498edfebd9651984806fc68be26512f920de798511f85947c136b67853e61130f9f240edb43ddad8caf692352a77fc91153ab6fa04afbe4016f1786688457c1bad6999a36d246756c6f72de9e28e874c691767378f30490e469d594972869f3f1f0275194a96cc4b36de70f18b5b6f640df38e9e5fd445eba072c6d84d61e5200c5d549b70e99d7a330cbd00bb5ff1c767232d2fc8aedd058b0190bbc0faa47890fb67d8ab7ead5ba29f29907ac10d112285d43c96bf8403cfbeb4e82d6fd0c06d093fb09b22c2b1b2aa3bd93a738d78397a0abfd768d8d5bce9f0818196cf501de3ae9a1f67a00ff68917b157de7508f804968abdb65b39975fafcaea115611d94bfc5618281fe385da5da2074bad4082e9867404a8bf5682ee4252cfcfaa85ba8eb34364a1f7711fb357622a8b06d69585e5aac00f409f284228c43dc584bd1776908b9047509f12c117a00a946b3626793a7a7d80692df43367f9a073ed675b6f3bf3ac8b63f90c6c36080ddeb7e3349b11021ae60d5683e9b96d1122498e6b58199331163a2a9a3fa5d8100e6addb163c7cb3770026e7b82a6157acb0d6e7ba4f9127ebef146dcddcbf02292a48f21e873b1be7a1ec66316053ac329dfbf50509f4d912738f2c07d18b9638248efbc78c28b6d8189066cef56c215c80cd305fdfbb4ae962ac26d6fc6d01b7bf43265c4226ad885be2eaa0b9ec216d629c0720343e671ef9f39284bd65f6e5cf6488a455768a388d5a9df3a0427c6583e6ed3c4ffd0a4bdd4867e68d83d3598a7d9ffc2adcdf8f10f8018f11ec4950ddc4d757d8749917216196397be77fbc931aa6dbf0fe269614317c77a6c9eb4b9f57cb0440bc0a0d96ef1a705b36210c18fec85b2b861acb2b069aacdbb09889fbbfbfc64d847ed5f943a2d8ef06ea95c22053ba4b6834e00dc49342445525a8b3d74fa3aff837f4dd5d1e781366b65b4de821ea45e39494cfac4e7379426d5051fe184b8bfad55df90a7210a61345fba76bec2f88327affc57040b9b459fdf012e1538b11606bbeeba7c5379f38e34ba17e6b44244808445c221d85321a32c63ce24f1542b111d8d9cf4496542a9d102db5bbf4d2d85b40f699257a6c48fc3d45e922138a261920abf17af7c6553e3ad520680214c4c5c16cfaf798cd64944788589d2d975935b4abc1a5a9ae52b25ac49ac2135a2255451c0d83648fd2bae1ab9141b750bd39e728794e57d0848b475d69138da853339c560c08c066203090cf8225b34e40f0338af52a182427ca8a0e57249f70b790a05364bd0893dcdccd4882cbb274f057d2628e744e79031ab7f8d1bd56eefcbbfd0afa63b4a7f82ce06983d5212a820cd5a033d9cad9c1642555036aa4beaf3b71b218dd7e128d087759904f9fbf7caa44686bfba387a1be3cd854f828d26d91d6a487528bae7b814e3dae7d5cbae74a0ee133ca59c56732764382ac10bd775ebed4fd0739c7f0a267c8a5b3a360ebd17775aa7df4f041886c6b0fcb90487066ecca07556da426ffb92af395b2cd829d82c81467f5232edf01afd92ee5487200ebb921807e6a1036be57e500177c94945a801100863b0046a5ac12ef405a087d0fcb08aa019a661b81689a4bc309276ea31595c899c5de962a6fbef489dd00643702cdeb6a3c0e03f119e7c002f5394dcd66f5edc01da126e25386aa569aac69e94e2d4cfa91135857aee7aa2f9af48762f18a7b37de3935c12cb79e6ba399c67893f477851afea8800ac1ff5465f60909b543c92081c73af52a22f07e0ecc8de45d9a4e62c263767e3ffb562f1a891785f72dd983bbc9bfef975811eb6c31caf61c89b3608052aa4ac817dccd2712145bba98cf773025d187bc0421d9fbbb971480c7859dccc80e1a44db17ab7ca37da2b0ab4d8fff2966fe2aa532d1e9e79f1751ecc808fdfa0e3f78734e4b1ec46730f8a7627dfda2bb2f2bf2278bf0881e6bc31d830c645e6de18087926411b87cc6d1a6e5eae49b42458da5ada1f5ebbd7612c434741e331e09584be179d5a3e9e523cf322b1b443c825ff1787fcb3c613c5e3a196638c6ce821bc48e7e23c89c76ade15ae383d7476473c0f0da110840aaffa917824c3976cc0bfd4ccdc9998b474ed53c14ebf1fe8c6100d1b7e8f2b661cf3c61a9bef973c38338a98fd1497442e3c31e03f384a8308550a42a08d366397756fb6a0cc6ada2719d5b369fcc18b3acf1d7ff1c3d27c94790970948b0895a9dc9a2b3e9ee8e4f2ecfbdd4f88336aa68b29d5edde2a9a81f408f81380aaf02c0a83c4ebe4bf0295b64d50906dba32707f10b741dd44e8cd1795ac55d4d01b5ced11ae633a46022f4f10e8dcd256579c5a7677cfd3de660469111164a1863ead2afc7c59fa9c46125df48305248fac7a884b0a1859c6b1f313e1d79190d6d683d16fff8470ab0f1128383acb1476b1f9ae5e89fd274d37c773d859293db9d1465f6c05042b82998bdb9d79364cd61ff97fd8052f87dd3725818efc6a04fecae88eda595b23ef0fff286d716c2c06754bd44248a2d28630f95fee3ce2d541cf82f4ca5de840d8da91eb088a0e13b0eaeba18fa4943849be3d06242770b74e58155bb87448e1a1adc77ff825136ca6fe78a97a0bc87d73794e7dfca2095f5f9c3a8cdbf692201f3b782cfa0726081a819e5bed3328b07a2b28b1661363ceb8ae4c48b6d1e19aa87af12008d96e869f2939b6ac71ee9ac87c5d71778ff1d3c727ec69ba428de4d922fe68c584ccabda1f2f9718d0881f429c3f4b009b82f768ae9c7b34a679f217669bd526e9ece1485c44cf44110be0a2e4aa43bd2468cf28446f6aeeec8f7caf4e3c25ee1a46a6444fc225d72efeb2035e77a9bf7080f9a4d0431de25fe99db132bd5c71b4d1a7eb2395ef3bbf3f4e688fb5c5769d71c73fc811c293124c7f0c5030aea963c7eededd993d3ea5bd301c1c859e0fefd0b9f3e6a7e09ca23767f1a4f2411bf09d0e4d968ec211922dd11a509d9c2ab12e67ff6c4f618c88fb3129f6dc8758192922b4eb527659c44aedc8947e3cfee09aa642c6a5cb4a51191ebdd77f72d0ebaac9e414174ec97f78d8fb4a0d2d77086c98d4dda50ff115f6d086d1ebd4f4e3474570d3615fe946b8fac13b434e7ac0359b779711c6dd1d0a5e1cd0da0c0036c05cc4a86e352270cafb78e0e19f8b02a25bc76b880d33f379ba5d854987759b87fbd6800d62048252082dfdee8118fbd9d344a8cc49a907a9ae73bf46462d74876f8e4a0a42a43f5f7c8d87233193aca6fa3f3be975652cea658975ac82a4d8904c4a050ec351fe5a0c73030677cb8ecc514a14bce9c3593b409adf482f6672b1240760b3a81478a1b11289d7e337335f528840ef375469fbccff8885e87fcb52c989dd5555bdd08563d328cd685caad9e6ce9172c9e9b6c5eb2230af7832c8fe97e64ceda3e980836df4b07d9c1c089638251a9bc1d5e9bea83c89e174afd4f23d6ac079f6e94edc0cabdc402718099876192fae6f585e9f0834ec243cd6a5826de177c22840a2b55152eb873682040cbb49b21aab410faad8fd25c2044fecd83466fbbbafd0482271d1b28826847db3180f293d8a20fe69fec50fb174e3abde5361426229034e7cf48ff77d0cf2dad1c5f96b3dfad261c7d5816fd2661193d99c3210cd5911dc46d95be913d1bc2ffca3ad5a4bd6b62adef0409fbeaa8350924c1d57c6a4ef8f9b1f95685cc67d930747abaccb41bc8699bf3f97f387141df602193a256491e10434609df78946fc37bf78f457009bd2e7bf6d4138de23d0c32c8d8735473557e941b0c34103e2a5c744c76fd741e7c598a6c4229b4f931cf42907f1bbae1447d72201176e3affabff5f638bac7145387884e6c22e68bad495df24e41d6c91c6c869f652c09e6b0ed6893634f3ba065452b7d7af9c97060ad69be24cc58d131e6e8e66a322b9d94b3eaea03819e7ad016fe406a2e4d6d8356ace8e00a296af52e916249ff512028d43be4ddb61a8737611138cfb20587a3cf6c347e50f5a8236d2e6b591d8a5d648983530fc7676374bef16f04d6498656447356a53cca5a9d271bacdab08dbf783060b19af7090361933ccf9c4d1256ccf4c80664105fecd99eac7af670eaeb963be1559b924a1266b131577faefd5dfe70c4fda78f75c465087625cf22be0c94165dd2de458083608e11a156c06646ed743f652695dc1eb9f416f233a83602c31e9f32e1a10129ec1cb02148c241b6db1353fcff79c4113b715a24ad25e63a73b4df03faeb459346f718052384bbec24446c03350527288c78595ec3bed4ccf7009326c98b17cb76f4c7aecdb5b226b623906675158b2e5e4d931add3b61b15fd2d614060f6e2a40c4c753e97cc9d5396824b1975170b7a0f1a362c1a47686ad3d323b4b047ccd45c9f3eeeed7b6c143c14790813bd11a7711312f0c0331c389109ab0c8d31a9947ef3f9d80521dee6ec8be50ab1f1c6ad5e056645b6982ff7f3ce76ae3c74ab7754489dcb131efb9f59e5a54ee5bd9efcda95ca01118ad49401e1bde47f1979cdd28f5870b32b703f093a856f254ff06d6cf9afcd51ab33a263939aebec7a920687fec20e13888f586cc739337d93834fd64e5d8207560676f398a00a8a2f0805d1c77580ebba50d26191fdd002cb2e734a955f0447a2d1ef62e4d6c829a62049d52be6ad9ab8a23806eec4155f2e87f5be7e220e39632c9124daa0ae8cbf4b1ac5e761c5b69e439a5014e487e7981140cf1a22bdea7947994f34bc05789214964130e1c9811c1e2d8713d29c94a2f2a1e9977da88109c19dc672f59833e705b875d928a5702fe7066ccf810b86762b845f62f15108733f49e274c740222342aa026eda14d4ff4993c833157426b9fb276045e429c43fb309044ae84ff87e354e124f4b9a2e6a9084413420bb5e333ca684b69d08616fbc3c67f6db2464dd3f544cc3befbc7dd92108bd2f55cce29ea13a415314a15472c136994b8c0669bebd6919e3e19cd5158b98f8653a508504bba249cafaed1bdd0c66ffdedb52df7f6533f06e2c7d00d73c5acf45a714deb28086389580a495f8edbbc4098afde0bfc0d3e16caa631d65c3485131dea69b382ce77d7e4684c6c19f94a2ed9bd23340db8b7ee711ca39fbd4555af8540fee414d06f37c67f3e89a27976629a6c46395fed03ab70e919bf07141894681d385a35439b0c75a6e653d5a28f4c088d1854b5d1e79717a8ff435d83b047bfb6104ea5e4b75aa5e65445613f1b201b03dafaba2dea448730d5ee582742c486125370855f31e361ec727b1f0b29cc54d84f1cc5a2f0aa4eb8639bbf49b5358a00bc7330d87316e44f3ec7793940c7ad6e9abbcc150580eae457ca332f6ea0e85ed061f1598ea6b01a72e0a6e1f0d9aa91640999aa5e7584b580665aadc31b87cc0e394ebe8d7b4b0ceef349e8c499e2b0fac90efa271e30916c7dac7e95e1ee5f17de6b9b349806c5bd18c51de8a0d4105152ed277b481e7f98af98141ae94f83f4e2d4740454442c6f21acc04da1a51fb9c897397d379dd17de156eeefccafb71fe7649447d621475271ff41b2e5128e42da0620852ecd5fe7667b5cfa18cb13f1d545d2c4f687f33b4943cd2f52bf189f98afe3da955d561e16b5571b052ff81b484ee9fa905fef405a7dfdb37fd9d989dcb864dc24efb4c2cb58fa3f433332f31a447750abbee47622c7283ad5f7702ca24c676fb7acdc9c7eedc75426c3c25902e3f2f4db554d8858057b66c5e7178649bf4907bdb142f603f449f57091c62bc94a67c6c350911d5c3503f40b76c89b7086978031048309dd7ffafa800490d62a62e71a41e042cf5d285fd72faf75128179b895352d3d797b819ad7eb214d7a52ade7d9d4faec5e9f820c704d5b9c92454ab677d5a0fe0e1402cfc7228059e91e62ffa0b60c55970b012273dfce9da95f788c62cc8929d298e6ad1f01d74d36105ec371135081435ad22ef705347adaaa56f07ccd0ebaeaa14aad90d66edc8b28fa1b342f793fc8a08ce6e64d45b315921be6603cd6abe609b9f29ac519aba1cf98eff9a9ae83a63d0c9ee3a0186f677f46b84a089cee8cf5e0cb79704b01f58bf252e85e5b9bba7eb042acfb53ae00f9a24264141dc5914cca740d3300740b3c39411dd8d43a9689fde307c66489d8879e909dfbd4f2e36e1e8d7291da3acc4335652f814ac28c4c2f2c9d52aa086280fc2e784fbb15b4e55604a98432868c233b8ce8b2da6450eccc93508673332cef79c054c5c2ae3885e4aa52cf30fe55738f71ef4b7db46a65702d26d795e1998ef7e6f02103fc3b69278232dc560fc32b59c6c4b1af90746459fbf7bd5908436ae7a7d81c71fab06ace106996e8723380c18bee47f0fd0559d56e184f5f8a8d09e9337a1ee20c9487765a1e8815b0d73629d4c1c8f641ce99a4fb740af17b32dc09e4a9b175d3ba47a6c2234fed7b3b4cb1cd19606d2d338955698f98dbcf910aeeecc5e240409b3c8b0d3e574f0085b461336a7cb8fbe50b1aac1471a99051ac4323d039bcd3b5a1aeb4845f0646970302e8aff9392d7d77ca298bcf5afe21e715b0306118e9f892cc6d55ab645c59f004a3b009ddf2a28b8e77a39a76649639ed5efce61f1f1ad8a45291ff244e8be8e0a342bc3b31ad11d2a8a8aeac0351ebfc4d3d935b4a58a2279d24d445018e3408141b8acdf5041a20f0f78d9da048169eca72fac9d27b76846312dc1c77ed593b230e3fa2619baef19db96a8a50be0b325882f42f1d670f74eccf1c1b5bad31c301322391d45d60b050df912323aabe984df5c9e224a6bd63558e09645c6c0b5dc62e19277a4801fc571b75f129241ecd6103e91b2e2f7dabbdd4ba96984e70222a89c375481c5f6d10336e48c313c656727af6c03a83494545c28123451b60285d3264991d210974716cbd8b352aedd1e6c460fe5d527adcfbdbb2a98e3ba717aa914033c202f4a9aae176f7154275f9f443f2d8ad1559bf7405b6e5e67d5aa1bd69b52fdf841d27d30b358c2c9bb1ff411b081049d49f011907a0a8f53a92ba8867b665294d9a5e9c2ad317789d4fbf8ca89fe79218b41650b45180927d2f41db42efe310d0961561634f84623c148298efda7d91bf0c7bf9c2a83d30cccaa05e47188c094111115a057465be0a981e8d552f64ea790f6e7ca725b5b85954f1c34ca82b9ef873796fa1ddfa3123ece7829f0ae51c97b84049acd50c31bd1f6380792db7d7847fb5f35861631692a4e193616e153753ac62011cd33224605cf003fbc2aff9d0b011e0d96c3e269ea53091525a2d8ce8b4e61d20f2f56c6fc62e3234c55444c11796113705ab5048fb7ae2a691a961051d9b73776d138413e909fdb0c9ecd8b3823434d81ef44861c49d5298fed0556e3508545e22ea17b16b04b001a2d49cb8f8aa44f59f974c73b82863c6335790a99dfb176346c111fb74c95d702e9dbd5e8f26a395f5167cf4ab53c1e221027a5012f50c74c30c82df0897a648e53c3738372af2e4ef2930ddda24e1ef055520561f75e184af4fe3b208f9d82dad8a5a8383b1c6df4b3c14e35bbb226f6b0457a980f760b857d0f7b66c1f8aa323c5ee1f5d7e62f428038ea74df89f813","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
