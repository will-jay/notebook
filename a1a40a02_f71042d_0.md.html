<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52ff7ccfb3ba02f732fd83173f676c01005ea7ecbbc004411c91ee36e4d4d97cc97051e04b768abd3c330f11b57f42988fd6190d7df25a430c397dc69e3bc758cd5f012eb2ebe6798dc9c6fdcbe7d22b6cf4959e410707c4effe3a8be97a363eff11f26cfc644ae63f23c9771c1ba54f816f7e87b53756a16f22187469fa014a18fbb7131e8784621c4430a6720da61d848ae5151d8ad83061a2af839ba1a3a9cb412cc5dd9666e14e9fd422ba0b001138fe0cac70c5b5687bc264e8de8ee96cd577e1785fbb17624250b1ed18555e76537552b7bb2ca91181e92220f3faa960c1e558d3ca76ca1ac3731068b90b550313a601eb368e3c8d3f160c768306a5f3f1b26879d914fadf4b6f58957fdbc5a0800927a74782c81b02fe2b16c40ed1f7da7055345bba12691ab102dfed57f5a5b96345b62c75f3507929e2dfa5c0b598337cee0587bfb505513f0c7c69dcb498f175baafb669be57b2bc31616e55722e8cfd6c144c0bc960262e219f309fe0dfe829d8863290f880c5d1892ea8f2acb965b1d93ece976f79cad07a9bfa64ab002d60ee243643837469cdd8b3e2c0cc75c1dd813bf6213eea45bbf3cea4814f8fec4125e05c8f51cb0d5944ba224f1bd517a36c7178818d0ca4a7bf16f5933f6221e7aafcdb535fa42f444a310a66981b56134eba83ace30601bb2c057e0107783c94f8979afc726925cde9d64eb0a55a7e2201b0209b280664da4062c2ae82af8be12491558c2eb4768d16302c4a420a4973788584f1bf9158f024d181c37058c0da8ea1268900ffc251def55aeea210858037724ef317275bacd34e3391a8891da5c57f147f29e3963894bce5fd8bf3be323f5813e45296f08e225c4bae1b52f84218044574983a39688e88497d49a22b9257a2572751246fe8f0111a3501df35cc340e64611f3ae0e66b27f02474605ff88df9e45671207a9feca9afdc292d5d414774697cc51e1806ae503bd9f8c6ce6c0a6ecebeb069374fb7560ff987b724659532e04362d9eba80b6905ad7d4580a3c3fab9191ff866193342530478a4881c18350afc3f3795e12f9290bbc32493f762a2e8e885fe57a8ad841b21fe7e16839fb13cdce0a41f8e6bb02506adb406f5905fe83b5338d78b59e2191c6db461daa0c38c7cdacf1cf929cdaae15c3bf075b9d974025a5aa0193b512aa7c11a9cf240f253cc4186d74fca378fceae410484a0c5efa0bdf01fa96680daf8ef40012cc94fa3506f9ef96d1d684f8829df8119759c0fdd64f031a2b264261c75f376658b538b43607fa1da2367ac27a48a2dc271bee81d071c0f821fadbdf3320cd41314c11c38677eefdc69e62951f6b3744becf8c0b168844d9b94d31c858908efcde66eabfd66d1f4b4ee007fbf2eec270093e331e99b6196e2039531a07f2d9d1a998100fac9a6686d19e77f73c0ee1cd8459ba806e4938150e160323b99b98d1652b93ae7351e75ff7c2e02b1925f1cf59d86669a809d2a3f5d881cebc928472498ed7c1dc205668b8df5398e9b7ecdc12bd5ad14637ad295ac7efc2cb75214d76c8693334c6c38ac044693a2e87805bf781333d7f24469848cc3cbdb117fbfbd8dfc02be3abbf5fe53765f15354f4e36c403fbe2872e173e19897d8dadd4d5e877059d2c9710f38eea0c96328c9bcee4308224b947fe2d39223aa5dd10301770068c55573800b6d06df201729564d177adf17cc3aa4c92aa596ef9601c40cd732430ef17272134f79e1c300e97ee6aa64fba392faa5d6c71ef589f8dc14fdcf0e0be7e74ebe656ea771f7d0c996b8c1eb6810e199e90092e4a00a27dc9c3b5a25ed61387f89f4d7166b118122a8fbab13c006f0074df7f64ddfc25d37ca34c4d5ceec00896a53bd8c1a7f6483e0243b45a6090e628f2c405af2cd4e6033d117f0972fa0a832ee74bfe901a65fa66f39f1285ce893c964ed7ceab2e22f41e8c5d13d7bc73e5e5266bb6eabc865c58d547e56d59dd2eb2321c95e255750c87ada4d921fc5856d96d3c3c22260397a5e7f7e4d2661e9787c76d84acc9f20e9722a18d6c70e3448c0e416e860987cfda6cc0e5c4ec8dd97039b6891c58dd62916c701d7e1dfef6bb09a529c220c659065e2bb5e0ee85c06381935bda265bd46b8acca60844d81f2be3a0c18b65a78098edd49a6b3b857eaf122123422ee388a1041ea462170c5d7d01174e8c600222f8b815b0fa4fbd84f9024bd65f0f11285acb871fd651e3b99ef33f936a220bf1409e4b2215079c4fa90cc2507c7d8dd265b12dbf4d8b39593c96826082beb2c9949bd33e72614506f717cbd8490f7c7be768baa8876296a0953a06dae3979f0605547fe603b5bc04a19b321a0aef28d53246745de7818176b5896cea7579eb5a93ed82b18ab44d427605763fdd42e161cf5c4ece558cc1343d599d31d5599ca8e9c2438ea8fee72e099d800c64f286cdcd267c2e5f4a01bb2a19c7f2da2b8344555067ccf710ad21d848ee713bd30890fb58d1fd9d83781bc3d2097b9283d5062f2ac5a2151476cb37d010e4d2140b63ef958dec3b3b695c24856189feee89afc070f20571e0988d55c8c458a2b6cd399fa36fdfd2f17d7f4437d847b1f51059d80cf085044f4077f63339e33e3cd1974fd3ab4feab704666297103dbb44c8427e7cef695d48d26ac99b564389f835f0d803020ed1f9d6dcb7d615a43a864a3cc0b6a796cd7f75613c64e424cff40373107427e42221481efba79cec1d7960f4393ab9feab497b92d9d7eac5637002c6679e74739d5234e64119430c0067850834583af3eb04fc10f597a458f83fc8803be3e24602070a611c79b6125b95a9c1a87e488e8237c181040addb93b55fcc22f3c55036b67789171a1e7fce3e9a12bc7cbe3ff0fde6bc546232d05f0a12597a49a5a12a078fefe8634a18906f2bedaeacf9379df0ca411a493444fad470aa859a7d2075c6df08d41cbe8eb06de8ea4c445de43d66635c6ec0b12451dcb9254a96af5cb89aec56be81ee5486944f7115beb930c31455bac32c8a91cba4282789a43387d542c788ffcdebda8b25dc2bbef5bd05530a00a6ec3c163148fcd44e4cd27c4b99d722ea328d875f3099784be5b5745d7f4240bb84d68f3577deba8372adc5ed9c4eeeb43ba9bde05dcb1fb8b33afab8334b96a756fffb97c39510650b67100eb6576092e6ed2073fbea47fe1352bb90c4931da821a10dfef4a618ac1c47726e00d69492fd752a6ff874fd89a6c465b062e51feddf6b3e659a6a9deb174d1656a52834fd15cbfc722035314ce205dce6e8a97f45562b956096d15ce85fca5217022844624122434aa588d00b5e05e42ab3bc6a85080a5ae09aae4b43b6c645160722656afd6cbde3518560b54dea5d5b55226b51bb7a4de08f18b191ae389a64bb57cc6509e180fc58e3795c8562c224a8ec41ac1163f2a87066c40cbca6350ed93d7807f6f97a3f7a2669aabc52c126c55361747973b04932ca4d5f884ff8da6a7a2caf8395aceb3ee81be3276a2146b062e95432dda614d1ba368584824eb5b71aceaf39c65eb195f415670db19090737f90be03290e73d6557c2f5143e799ad8b6c8ce27816e7b8d1b06828b038d85c8e83fcf4aeb9df383cab57a58bed6f1e5fc8cfca086e41dd0c4cab29c72fdcff8fcb2c5227d547a77869b40463b8da7bb37391f2c617a4c0ca2c20579c31b0790af592745e07d819a877816c4a80b5ea5c2e71f26541abf163406c818258eabb1f4625db7ada8115fb407fa27c5b8f322f99b6de04a885c31b53e99aa88675cb3cd00a1412d8f3e0ebcd3a17d6d98f15c877310127ec8d040dd5c98e72e445dd62d65fca89111b1c6082a9fdd8d1e73011f431b73404151203044c1a58035f10a6bb5d8f0b970625ddc97a462114fd187ceb3ebb141ca7e483a558a3519e1e45e0638152919698cccb755d747f50f3c5d4ecfcf1d546136c90fc9e15d584a51ad12fce8bd39d8a45a9732cdfeb6b12e2d598cae646493c26560a05a2602b3b9138b31d84cbb9ff2170b48eb825ec29317caa6b87dae5d0c015f5b74bb1460a28d284aab9e8be93176844055fe0ee0f3a30d2025022432e69c3217bf57d2dace50bc91c104756d644c9b50874431a8d80c50f7c69fb93e630ee38ae95f91556f821dc565451f4747c470b47bc56b48030a3a2ee637b65fbd343aa81c21d3d0cc9bb64db7741894174e730790c7cbfe41497da195c6724d791aecee88ae7cb1e2b5af4fee372e5967c20d89dc7bbe6fdce67eed88c9d4e88c380ca46acc4ab61ac6f7bd8a9ee131a36f425b7efaf05e1173be69744fe5e483db68c0d952450829b4f99647bce91c5a23edfdd07b2112aa6cda18f55d6aaa7d04733e3a943e9d36e9f338fac2bbd5ac94cc5ca5be93766340505065f47910a439c7e21435abaaf11b61e5a5506e0103d729561979c299482674d7662ddb48b6453faf04ebf31e2931da4b37e5f181498b55fb438cfe2c99e442ad44a65cad67fcb33802dcdc3485ff7cbaa94b7005dfed07026b23db984a54b4697f04210e65b4693692c6dbc8cce5185da2ead5e70de12603ced81631d25ae5268ecc5534553b65d43474195e76fb5cb9e777ac3946af18d81a8cb439f3b0d3143a1411295123e5c95b7540d273900e6cc9e47206e4bc236e53bf0a5f13b0b815f79ef9afc23d0af1c51b901a974bdda4e0c4e406cf18cfbf994c7ae00bc2265d676c310787fac28989c6217c35eca443bc9daf4669081b4c80d4717e378203a336b35bd4b353a5ed2229045141e9e59e7115d1cabc88eaf23eb3eb9beb7cb40cde9ef7dc374c6a6fe748a29e6f523c499b04462b35184caaba5edf0ea409317c8ad1acee4c41429ee09177b6f8749e45f9a2488483d6555f5ac76cd4c3ed95bf7c90c5f3b5e6022104b70af80dc3a65479e1b5a5a08e15d80c0a692e4a5c08acb0d693825de16d5920a9bb76e8039312e7daff5164e946ff313e268f08abf3349ae7cb297fa40c93d10fd831114394ac30367bfd9fba7218a90a2c52f3856c4b1f4319eefeb093b00a94ce1ffbdeb511fc2548a40f778bb05c09690d090d265dc3fb848f74b9041cf71dce1d384283c32f1161719937f17e7a9a94502fe14ea80ade304e505f065d5f9cdf6f117c0b1bd8f5c21e68e1274029ca97b52bf19b6a35aa17b34279833e9d7ef2ae2fe33bee93faff8f45882ed0e477872d9267711777cf12846b43c54be8ab416dbde7e2e108e5d971472dde726d8a7d4fa43523153ed4ea3fa6914e1c530408358ffcdf7ea42dca41a025b21b66b6a659dd580a71fffe2381c5c81c2dfc47e4e5df4d54dbad5081fdbd022c56a3e867d7d6b8638aa523310901878371562c56fce632e27d75074a6ebd2b8621fec6193aaa633cec341ec45d03b06962e4d9817f20488e3aca908da7caab9ea9647a53b5ac7bb24f30338e394fdd585d3e5eeb6feeda54a80f72c704482a36164946e541413f4cd2ff80e148f5cf2de96cdcd131a4a58ee2e26547852cdc7a23fef0a808a18e2b99ebaa14d07fa725ee6c8aa4153e451c0d59548b29be40eb0fda9915a698ec2cebe4e7ab0b1bf31eb27b4378d4d7fa2275fdd2c4ae8f20554c979f5dd2d192a576e2eac53ad055847c30e61e77f0f36232d084321ddd69809703193cede8471a3fa62df6376ea1eaf9f3c8f811344d7fd2286ee55aca6825a80207b094c7d71c180f57903ed29eeda8685fc54c32a208cc403ed86710883d1143db0a8d4b0f441e3c7f5cacb600d96d0d3b12040b52fdb63e9b881b4cbd99813053eaace4a1760e9d8a3837de1acace11717ba1c2d1dfa6fd7af3c6e15489bf6540b5f758ad78d90011143ba4e05631971a4175e2640164f0e258dac187efc8525e03e5c2516db2fff61fd2a6d8ead65fcf3cb5482898ba24e7fb2b7b517d7996d3fb9ad56d854f4a688057930afba1d3eaf5268c8e387c22b82e0275e92848256bfc778a324bcfbe836d73612410677f7796993e4e1d4ff935cbd58d528d829a63faa6eec7941c3e3e819a48d82ce570941604375b325b2c8c044ac97f40b8aed53364c0db7b0b7fb5b96c8eedffdab2d1821039b9407c86b705c6212c33f140a515132d2ab62e46ae8fa5b06ffbc8bab11c4519044a871c8ca8a552e1e45144dd41c5eded5ea569a207901e53be8aab37459608009f61ee3b5c91e531b5d4accc4c4eea72f159687a4fb5021d7e48256281f1717dc7a7fbd5b7683af4710f5f283cae05f55238de479a9e553e84b9add41371835deac3ad7f9b5e900fa94116dc11830728c9f4bb569dc3fd2b87245dad5f56583c38b41d72587e40e4266e6b7e97f4eeb09d5b408bfa8553af716764ceef5ec580be2bb21728e4330a2a3fb889160c00f263d525976423c1898d44969055bcbc3c721d2c8e340a4042482512a6cae2cf0194ef33c2b656f34f2e47ab86027bf84291ebd513475e3dcf2573938ad96cd6df9434f2d8e252efe25976484c4903d07ce18bac7992148ef668a093580340052124b35ecfdfa4e1f66800ab8925aa28ae457ed4100665288e3022d0c3fe6a29ace696fdc0f6ca91a83f20c194fab0dcd4f0673b4e59fc9f2b350b06c1b1dce27d425b715bce2f3c30c8b333e049c03e3588e33a9cb13a4c9994a8d6aa571065cd9e1a40d4b3f40e4e9222b170a5842c638773794037449dd5ca0e9a6e6a2ba9893f14d721bf267f9ae4d51093c712adea4723208e3a67390dce68eda9c358bbd54e631fa8c800bc8d0360f3fd74d33b6f67e118e9e4cb7274fd4cf2c635ef1fa638f9d526a8b17d1953ddb319ae92a5b98903174a28189e0ce509bf332b7f5078c931832f52d1bd2189cdc44cd7ae3a2904c83216c4f1be05e476f5524d652b127842b2aec08386e0ea8952beb1ad3e108f0cfbc63871485af0f22a45a4ee4509cd6474879195026c390a89e7f43baaffc4b08b8d833118103450817d46c4d4e4f055debf5c104df306c63cd4bc8e413bd0c6d5ddff8819a645448058354b101f51d625e1268d336ff85a9e964fe908a36b42882f3d6fdc31c8e2c7a3621af9d8639b5f338acc3272029169017b16966d836249966458d0ea188ad3dd9047d79f0de5f2c44fc001fcf25b2c4c72ac39b95779385feb8caccccd9949f496e375351ca05ae15a80c8088c6065df9f1ba37afa571055c43ae45c16b33760a2cd2c99f4246db42f59f2fafa56e49cf2fee1ca7c220a3e7f4c24274081e47b7aaae50a3977bdb8d2a04f73d6bb8bbd2b4377afa6a32f79aaf48cab1254ec06b6416960f4aa3269a715bbf8954122ef7af508a4cfb1a062fa45f49d30f5c7ca016c7e93fe68a0e3c7b0debdba6c0c4d70b2dc0484b6344e5ecfdc56cd04a411306cbed7eed745dbbdbb0b97dbff3085063fc7526e087bc490857f53db66e3d1fcaaf298f8e6c03909067e5aa64a0f1305ada224713fa2daac3ec60dabed8107ea445cc12ecca52eb1646d0992f51b8ca801cb04e6615bdb34b77616405c6c19b3374f3d8a21315e561233f344a0fc61caa28e063e36ab4ec3772ca7d8725f827d04fb1c013ab1ad7aeaa4bad058844bc2db7af903c7df988c1b29e1874a0c0e090fc6886cbd18585b14e395cdca600b02eef569a268bfe59c9bd347ca5b696711957961329dd9c0922ad80ced414d93b2403d401b6699f1d2cb03fae4ba7fdda5f48c3d36634324b2fd2ea1b25bdbd33d6febdd6cf7788c1c7d20ff90fb65744c32baa90ab71fc48c23623d15247fc9b6dd3074acb7a0039852431a4c80c1efd39078231a92e8190336815c994d7cbd6848b582a8cd8d2577f7bcb32fbed00153d4e9e752cafc7cb5b2db3f222071f889a7dbafbd8965f679d868956ca7b2e58466cc051f80b716f088b9c9185b40e1aeb2537d48d79b1cddb1c74b6a1e795843958c103ac2db5f608304314a074820fdf682a5dc3970f4d78a19f9520e641f047001923845291e12d33d399aec91331a11c8ab604b452f89ef2b62c6f7c6ba0c5c69f5d26010177413a2806435d270fb46d0b21bc057edef46e0a5bbeb2eef4cdd663fb5b6fb54051df3ef22c6e4ba10ee8ba972bd903d7f463212f0c156080aa28d375efcc2d996144f8c14935a0339c20ca7991571eaeb9134240d0bbc2f6718f5b5773fd27e8507fe8c72e0abb43bdb672d33bbc5b9054f0521e7bc9608396394cf091160209be21fed2d3564ef3d7c8cbf45b6a09663e9c6bcb9251811bb344e1857f83d4976d7a9638cb606dd8aa3142c3a39d2b5a4460a8eb251fa68987d055ef725dc02532c6924dbe24254a577e5a2f098e79f9af8391eb26751719ebfa7e3d44c9b043fe0f184179f37a20af2232a207ecfef916dea7fecfcd7084af86cf4303a11d7280f0aa058597884007e362b4cdec0d8411375b9d0231de145e30d8098c9db2092fb76edb00fc3184d34b3d0f65798378497e00a5c98cd0a824bdce205b538770f164b5ac4807b4d6642d726064948bc711b8440ed26ae84a364ded67620435e7b87e2d56ca042527a87b29509ef15f638ca35713307f8af80cf70ff227ffa0582c22318a0ee452a44fd2f98fe1af8a8b2d769d2a681104da0ee2ab9de514dbb2af6c67ff19afe93a27b195676ec6726f882da691140fb383a3cea0e4a4f3a308a48dc8f12671f7975a0f69178675d80271af36d326ecc3b69edd33c7936aaae8accb3c4221741ed7e753e16159f7b4d0708188e7ac6239c943f60e1a7ce956d55214052e977655bcebb82bf8554e12a9c48ee189201b140df3efd58cb055d398ba8555ba12fba63b0973226c90efc18d76d9f19153144dbbf9c4be8acd0485ae0ccf0cd5d97a40518d121bda0c09d8ca7102a4205097d96bfe5747d2d89ab4125de8eef854894486cfd448cd2b497547f945cde8b1d9b940d15dd939e12410e84e8224c56a2e299d2bce604618fd5c533722c7f7b33fae790ddc45c24cbe92d9b5b681f12f480c8f8bf83a8c488fb99905121e5c446c14087805052ab9d2b7723d6ebf308b0376d7bde688410268fd3c15b90b4f443cf26d2e85299d52d7c85c7c14509f649e80fbd48424db2a2d5033caa4b28134f500f775f59408459d3fcd57b2eabeac3de9bcb7115d7107869d8571ea4011a2df7f92445424f99b5a2b2beeb5725c058b770782ff7931069be3f0da429c4c3e880a2ec4ee7bbef91f04ed019739a6385ca195d7a23bd35a2e345fc33127f622cfaaba86f1747b8287f6ffffc40971c7d491fb8d4aad3eca926f11b707f4aedd1480ee80764f6576f764a2fe9f86d3949000c22d86fc41286a76134ea998e6b3a4b280259e2062491ff129fd001cc336258dd0a2aa5a99213d5de62db88b5db4d836531792451d0b7bbdfcd0e10a0d77a3a30caec8f42b150c9b6bce644b4635b7e5f148e5edebb55c640d68a44cb8f465f5efcb91ff9b4e3f7dfc3c10052e9c59f2a6e01bb80e8945f9b792a33da388c77f9f38a13613438630a76c489a163cc86097fb939da4d4ba3ec021840621f72b52bd78dbe19a31cb87f03e005f3fe06b397d74543500079311814ee93270a388dc06fa99c22f3875f986081ddfef1589a459316a9ac4711080b14cfafc795f32957512ad1a6c7a556df3164f372059972254d264acb9c7c4d2dd3af086eaa593ee535611b3dd005317a47b899275a834364a3b8cec98c7b8a4280ecba4e07395f364f6757126d8c01676e42653a0e91602d8635ea03a683ca0e0e07176ba60d283a2f19919c43122ca0ca48d8b091b5bbb3ee7688716787c59b247b00e3232f1c501fe6501ef8659c097e23345f2780d7ca9fefd5b9dfdcb7b5afb6e49439d9c64350f13ba5f6c5bfcca9dcda327593a80fc061e6e47876cf33a13c6f96309ce07e7823202d9026595d8ca4a86cfb7c26d15d38a0e651ae6d9c7c71410d54007b43b25f7651e4a52d03dcc667ad4c2620cbf172787dc14bcdc4ae2d2501894a32a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
