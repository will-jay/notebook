<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ea151685050f471a818305083eb7de840019abb69fae1482cd81e404de1ecac5aff4fbdc012d6419d16230ec63017a783f93c2d0672c92dabaadb6882cc43a600663e249036dcb3239d69677033cd0061ad6e32277c3e3a5254491eaffe35a1d4ed879753af552f3dbd795b9b5829f8e0ddc1a23a5a20493aabf4c851b08fe40ceae5143226d99dcdc21d7b944c265b2cd2273e2c198ec1b454722d5ad1abf01328a7643075fe12913136a12f3aca561934f420a5817886ab62be2cb3c3bb2e644d0b8f5413c0282c8ef4dc3613de8f602d9376db95f58973493f10ab7772811948f6220def2b33a8123841aa489b8c0b2f913fd379f74239f590b46f910123bda6426d14a5eac683614d843d429dc1ca8066bda1647ae39b1b668cee57a417c77e607ce001e438f362ec00652d5425f4264b288037afdbd938e449143c7bab9892a867ee5158ac2b43999a813bf9cb58c84912996a1366ecfb63966a7e4ba63668772ba018823d1a9e7abf65cc83d3abbff696bc8a6b517e54d8e96cc1ea15201f3e903e6063d6794df36796f92d54a3e10063a536643cc359bf55d803fd2cc3fe9db6c23a2c8383b1d4353938b7fa7252b7a09e5a284e0ab159f78b526d134f1aff5e1adb17498b92843eebfd073c88155255df1135f3ffbc7302b63f31f3ff573390391ccfcf0a22bc69984f55ae1a448b55af659a304c48cdac9d277e544d46a0734497584432c7e4020541528a3f4c08357478946c8041495c4c182c37d6fd430962fb80262861e0ef6513ecd9a6a883b962b23ae56b4c97aadfd9afb7c1773eaf35d4889c7131201731a6954bc644b88420c88203ee04e0ae4c8faa1d1da2d1ccbf03a935106739f4bc02d38d645ad5b5ca1063b7493a880792c739eb34a53951f3c334b9d6f9a45f3bed8a49725dc66f4ecb185191a932746c175e2bfc76df4fc2e6fa5b603aad04a4d92b7a08c82a921deb8d51aaf0bcddf4a923197e8d968dd69e6f1a350a1e6caef9ac7bc0fc6703b74daeba686fdbda05a3ef0f479b85e90c224c687a2c5f49bfe1e3251659402b858f6846ec6f53644e7bfb8a46f752f605658dad2b153bf1dd7a6cd9987ae8c898b957df653a106ad79778ab34251927879bfe632581e97942eafb7eb5c2aa0bc7bf511241e650afa01cc2226a8e301b37db3654f4bfda79ec4f9bb8ea7be52306e2d49c7f4db885ea98c72b413dc3fbdbb24fbda3ec5a98459494d2d6b1eedf897a8f0a427f495e01832633e163ba0e3a6d5ae55ebf21f90ca009bef7ba7d6913b154df709785b4ded3b7abc7dc2e53675e83597be007b1f8899e8dd243f6c5eece148afff7b223e8508162a013b8a301edddb22551a54ec0cb10dcc0a12856eb990899bec16b8673b2e7dd14d07e90f431606488808d746ba29d8b29fc8421abf5c670f47fcefd0964f94aa76876e5896a459f679fb95aa7493e9d47b1a150b3d02cd05ae636064c5aed1b9fe23ab3ff8ed5988eecb6bcb62a57a4da2006aa80921a48e9024f8e85ca24bb9e5aceaf1b628e6acf5e76f521dc77e41c6905187d93c90326a6bfb5bcec8baa1603dfafd5782dd6d097254495f793342321e93b22a4a8a10873f699e9bf923a1666225f76e479930047c34743703383a99a7bccab0345c8e9d250e204f7aa0fb12001a6a8b60526f22ad96fbadb26f4c172021a89e1c6369c1fbf1b0d18b45ce8b32e682367b84572bdc61f6c640189ee01574278a5e4fadce26feaef68741e1b7c550001cad4637b92f4249387db336f1f674a3127984432ea4ffb837cff25facf7050961c8553ecf77d1f56438d0f7f2736a60ddae8d6a391d912c3b73e90493dbf8b5e72df1036e2690de4445e924cc2d4c1855e7c2186245259e7ad8970958415ae1545932390166a3173cba33ed6b7e7d1a270af31010e806b2c9ee3eb8cb905821bdc7c277f2667959380c17e822b359a08c0a4e0c3c27c9bd3ddb1a2fe1e71cddaf5df9219aa857acb5da701e3d2e13b678d3909362330489d1edcba55987380515f730650aa59aee67acec8339d910383d689297e6328de53439c81647682bc189e15ee35ebda796f4e6694171cc1f3264e1fed384cf2aaca88c522fa8c1906a280075e63301c499324d31af4fb5d4f1a546ee3e4038b4ca8eb3adb22647c6e2d9dd53b5abf25942c767ae7012ac77ce9241d5e83e7b410afe3a79e994649f8b631c7a4fe9b1bfd3b8c615a2f49325f8c0256094af6a28a08c72373cb88452d75e8735c4c61b96e44213a740db8778c5ded65cae5f43aa93995b9acf91c656b80f3df1e1121f61eb9217da45a6f2ba12ef5a54a7c7a3e45eb272ba28f4432a2907f34a15806633b23c8c4824ba2948c04f043dc58b2af5ba5f05ea958fa779d9cb22b825ef566a79298a973166cb23f1301a948dec0ab965e94253b27bdb6d6f980d2347ea31ed00bde73ead18ec56b5a19f702d9ef2c53d78c176d31f9c079f48d306c5716aedbd5b700bf2e7e016545d56810906eb0c5899ddc893b47f022cc50ce59f297408837fd640607eb698825820eb38e4a1c698c63d626587fb4fb45dde5b94c234608f6253f99a52409307b43141fea0cedfc72478288652665de191b686b973520a0c01cafb48f5869445c8f2ad5baf56ee12415611b674899bba0b4161eb5a46034a09ff7672ef4c237df8b7e0e91c1ec0f582046ad5c55e7137d15676540108100bc5cb8ae22c2d655e32d5098802f567f93391165f38b0b05e3d0edb7bcdbab80f40d0b49cbd2ce069480a9e28cfb499644a1b62d5b7c51f87c996587af53068681a933c928196b57f9e8599fdbe0f803d889a3b12b93569ff4685a99ec7279f9b34fca43fe3f9ce860d5585945282c1b92eb321a976ed73baf2bf752cc72bf33873b65d6621b2033f6dee3f14f077d7ec69d5ca7943677b8798a2eb1954b6d533860d0bc3d1ebb8837baf52b57034cd8994a4ecb2099bffb410b1fcf131a507eedf9a130b454adcf8eca0e036732333a64852a6413fedb28405e4ac9d3aab30d1a5a268acb6d0c5ca7e8be976ac8965ea605d349b9b720bd0a55511bea54e02b8a9c7ce701ef98e3a24a467f065e8f3529677f5bb7e580e3532c057fa19b936d2c2806216b7efaeddd581033ec0d01178c39f1a46884065413801d7b1f028d8f510d9edc729d3620851e5719691323da6afc7b587188169dfcf70b21301beab2159693a36a8476de923920aef53ae3a30e7e117c897e0ee15134df5fd53acb1b01714cc74eff704894fadada17bfc2a26afe0caa18c2612b8000abcdf2f057a029833fe1df5c5e550a9a9c7dfd08971faf20523400d5333d68c83ea263a9814d4be6b8aaaa015ef07a6de78ff234b50568d1bafb0a88ad829444a0eacc5fac8f8f7a7f2339f6cca379f2339cf98161608d099678383581c6174ee72a795f3b0cac5c6cd39df3d4e671307ddeac5a82b1f07186aa19d4c976dfbd16d113d07968dc74cbe75a2e1dbf89746748b659ca92d06807945cba7ae2a4977a4e97b52bc15a41be75890e628e282a51a19a8745c005e4f504d019a2734a87504ae9ec510c3a59748a451f9a98dd9d933e07d9726e55d6c8fda095b0cf10d64d793975c42b809fca53ef84bb42931bd7102b29a3cf4d9331ec3817d897dadf4afec20dc4de23ee0c9e846109dd6f733794447efd826dd0a34181cdceeb8a89b3fe9fd2303463723948daa560083464ab0d8f1f46c53e80181d3444eba1fa8d629d2154d031c015184a4f58ecaa1a14864a816f63bdd4c607b765bf77532a38bf680ff1e08f66c4bff149ef2aca0aa087e8a09ffc71977ed77ce77fce12c70c3eae462f89242db20f7599cbcf5087761ae2e2371c683e244516a47c3b15b582b7170970e2dd0f6753892cb9f72aa0d1eb02d0931b4aa44a08c4b23f1852acf939572f706fd610ca3e5b3f7853e9254e24c2e73a8a53889d7c7b14e523717f19599d7dc6550909909f2890f4ae999f7a85ab360528fc24381cd47f20da50f84235a7676107e7931aef9555f896b69d0324a8bae2cc48fb828218a66066687a50afe28609a8ea4d100c9a8989f179f9ea3bc236ac37d9240036c4d46def952c90486853c7fec767eca3476ac4b6d992e0064d6437a19fa0a212f6cc8b1d5d9dcf4fc2742a7ea9ba11126ca30e8fcbe2cb764839dd5f3e21c192a099b1bf73654c80fc93962c9c62090cab91d0b1b69c0d0012b380b02e777bb56a990b8ba9ba4cb68c8077f075fafcb4061d809a0aca11e19ba07922e81da05dc476ab1a3cd3ba233eb50907175ebe30579b18ad8d14e697df3d8e585055f43b8fd2f9df9202e6488144870bb0db60d28459d64abc0d29c5fa475609a3c32c8c95f67de8d3ac3a830a2b89b1d364397134f142319a1dee7c5b24307da71ea734b8b18716f96193aa38b3afdac7a785622c6ab1ad6f17db288f217a7ce8b7521493ff4cf23fc4cfb81848d4e76db84cde14459f6431e1fdd560b6f37320d5b36ba5c7949b4ff1a0e68479ca16acddf9c195e437d7afaa86acfe2aadf6f8608bb24b15529faa4f6ebda2a7f10a9a0d1bac49f5a49aa4c54a8a51f012b739cb479cc0fac7190878e5d836fc95f0e8afa2b18142fdef0a74610ed4317de7c8d302f9f9d948481c95ce26530e407e4d1568974d1798b59d46a29d98f392044f8aa50d2d64b4d7fe907e92c2defac87a28498309b3c40bf32c8446fa70e8f3729b5727d885db06e156d9eb687c80f9e36ff208aa9706529c2b9ecd4b3cfafbecb0dfa5fc3c791a9fe736994cac1ab35f86e9a080ff32f523a9ae00153dd3a8d74c0a72f9b2d1dd7d8ef8fd4edcd7b72a3498717406c9a57c44b4d6b91d50fcb6c293c97430231f45795b0176791f1efd4d1204d2c85de828d1844cc39b5f7c2da0dc76bac6849617e88bd8340b807c89ab5cb770b8ae1d3d3dc2968d461157cb595a6e68dd27d1dd0faaff4f9b126ee33e523a8ead438bc4194c7d2f04a7bdea63334b681515d70b8d7d1862f1088c69bfc2e35cd0dc09e8f99d5013e99fa53bb95965b479d69ebb7d3270ab518b8fd875a21f879e6c537dc8cd18fb043bd07805c49a6ef721fe7c6621ba6d59781e73abb341d421a157d0919ace86c117a1eabde52665637bab6bdc937ed93bf3d14d1ef8bc87ac9577e2dc53b3f282052c19be578506fef4d2086ddba65cded54df55f33bb356129f5744dad1f5ee04c255a4452e86ae6445f5ea9fc99bf9b7f4c9a4d5ec00127c3da5922545dbc30d7e38282d7b0be7991e879b62a2689e2f3f1b92e5726072c0b934f8112b07e34736c687dfa554c39b281282a23a580aa7c3cd9ab7de9d746569dfb58de7c355a21af844350c6c096a9c2023630b0c272abe8188172a56e384b1a2159c779d7bb5326fb98147669329f4e6d6f9bc27ade8c0c561e0b92a0fbafb71b05de294b1413910adcc784b2ff8eb2bd426eab8f1a45fdb0c3ea254257aa8a0e4fa3e54eb4336e8c94e7ede515747166a7bbf028a4fac73485050bbf62c70c5eacf1215edc6e1de1115f8c993b1956c58f6c817db0c266d59ce0be3de10dee47fca8b103c439cc4bb65ce8a032205fbdaa2363f853bedcc455a37d2c8cc326d4f762903f3451a9f7fc3bfd815ccb22975b6171d20349f819ad471a1e61d499066dd011ca3fed3a0630996fd730afd384bb9aa50acd9a30c8d3e59521206745c847fd1cabb6d83b4c737b1c480a3082eeb8fc9968d48b0b9c3500b6e1fb5a62dbedbd285131f8a6a036dc0c52ea4378249c95c0205a93a8818d5f5e19094c59a3276e5283c4c32ef8cb134eada32c8c84d99d5797b6632e8149480cbe82b3505caed2101afd416a48c3bc23f89a596fcdb463080a62b918b6c8edfbad33a3ede4988ced3ab62ff4aca5b8cc77702c2f32a3cce9c79e8b58a9f7dca170c7e74952c4ac82c12c612e705cb92aef3b515cfdc805cedefcdce4fff57806f05d7202901a5281adbfd21d20ef9aeb68439b26e94d1de64abf9956248e894f8ab6dbec51a330a21cbadcd493ebc234beaeb8c67e95535e7abce041729006e7d3a4cf687a64cc5e17c71516dbe0593668f4f6a9f0175c81d1611315f39fd8e91ccf5cd128abc9e53ea6327c02a0febbecfe12d16732e9e5930df07b552f889e2fc5bca342dfb1f9272df7079a267c261432268216ce7f77ed41359cf2574023b428c5c2801a40c8c5da2cd16502aa932635a86ddd64cce2fca110f4c8a6195be094f984dd73577d6c256bb783b0449c5791e8d21ef57bda57aa6f368843c36aff10e789661c520f736527304dca36817ba319ad20ba512c8d4215de60b00d0bfc9767e06a2dd5e282fa40a5adbb1c0a608f51bde271d43d2542ae85aefc61260edca1d1a53fef65056e77e0384dd421599b50fd37a7c7a70ae5f5cf0f60973bea1fd2129942c2098b8fc3425348392a28b1f26e58f84ad25000139d5a33dfd9bdc39bba73c4085ac9872916dd43e3b892a92c2b49239f166ea5af85d730ddaef53d058565d5c98787876b352b3e4740addf797399934c13c1bb0f8f1268bb96cce7e2ce6c6019c0a22e3f2c4fae6e1996de134495074b80aa8f3d59db5276374c1074a0507c52b267afe3b74ba481c19edc56caf39b02d361abefc9038d3bd47747b666a9ac9b96153f560b4e3aa3ef0a2635ad3de82e0d572d27599bc07fcbfde13daf23ae175a5e3b6b4b8724674c9243b7e45a42a85c37abb8f190ebfc3258761a8f04a1ebac6b241f0f58be3e0bdc16f8c2f7da8c22641686c49c51c55af9c4302025bcb5a181d396f521d67d50786119790985d94f2b8f04c76a62114fbeb9437b243f0a85520de949c26d1b1f5aa1c520cc68f721acb047ff74d4c4682dfd4f19284a9e13120f60ba55d6181a5bd0b7a4f0144cb9dbbbd94ed33fbd83ea2b41fd42de9df6737378477d33e3beecbd22c5d3a68f503679affd7341cbdcfc0f480bbe0c4ea38642c131a36b678ca2cf76a38964f677b962a2ce9b815723a1b1772f9b4586d6fdde9371e8a185d9efbfe7ed04829c2db44c2b3ad7fdf82af3aa361f3818782de67f268aa907bf25f5f96cf427c0602a8006717789544119fe1efd9629218ec313336b8812a9acecd6c35b7f8f460b108d19b05403682c94b97db158125f8924109ab718da7066cce48c24202d7f77f75144e07e7a473ae9bb380c545fa386bb6e86162fda834444a3666c630102114acc423d953512137e3b0b576edbb4ce1d114941ef50680115b7ba7e6e201e873a540d082172a8b9c02d739bc0c98137811811a17467d25cabd57be362e378d3e6403e836a3ffa044643e7f4444052fa3f700d3888ba4ac925b1de42be9d06d03dea5cd99250c1c8d11411c00fbce7d8286150079547b14191b6d7ac75721f9d9c8ca770e17d29bd661f6866526f427f519dc68e5541349e3bc7c296fefe797fb6f9b08393be35586fd1a21641b2e6152042d89cec729b7668f7777c8f5708c0f678609e41aaaffe7fc55f9ce9e3db8cdb8aae826bf6038973f19bde49f1f9ff0df068e2f1eb962b325b0863853e99996603764e77757bb64414e0f49c587792aaa851dff33118230745ff25a9df55cebd8bbb52058358973ca123de86daca219d6c94b063c448f82294347f9e196a20b40111067656078223e9f28cb666420d623c511a936cc67d5b082fcd8791fc55476211b39482a71540178795c3cd289cf0840463a8cb04b17a8f1dfda73dc84711ef95feee47a7b4f4fa0da51ca01e35fc991d585d06245048855fd2e17928442c21bac70803871c988b8f9a4654798d6d742e31f8272cb78e6b34d5ff274a30bcadd9824321e0b8409c4689f311456626a6ffff65a311debc72c8c05bf7b2ef044e0e7430516e76a47f1f7cb782b9e0aed9a41f956f83b685fa61dfb25760ffb88d63ea47579e0cf50b944c985353b1e29ef6c7793aff944371aef4d222c08660b53d838670c13e53642a067d69b5e2d2035b9aae779072f69fcf62c2938ee0ec7be52b474cd0a32c3011e6260e901d45830ff22961b4b1f9f97d0d4413d66f35bfebaa3e5814d1380bd08733ef211d8f628b4c9b0fd178807e6b81aa220e0b810275a783e9103801d0a2cb6a3f0f35c54d85ead56516108e72cc67a17ad4a911787fc2e3c99bf7de376b27cf096bb1a21b28b422ea164b2d35c4792b55d17646f833e9b6f9834a30c72e9a8164cd890fd604010f5fcb4fd54c4edf69a0ca41c5e320a2c1684a6684504731e8cfc903ff1286493b582d484a1a8892376c4fd1ed87190be38cfdec3dd78b9624da07528bf29b5df749b8506eab0d7cdcb8d228cacca867c57067bc7c07f4652488b93b855dee8ace18ac45bf793b24b01ea6b288572da07b65d7500ca5400141344fd875a0aa3ddf53ae07d4f003cb2381a8faaea4730abd7d91dcb28c4395ddfc57e76b14b2b4f3400b03876a5b273ac2f8689dcfee7550587d11380ba049943b1d0d4a9f8551e313ab8c47d756b42e7bbb42cc63e81c9bc64f38e5323c8079f1ad9a927acddc018e8ad910b06e2b6c055931805b2ff759d94c31d77afd173d5ebf7c54e9bf21045ba2d43b553da68f1377aa26263ba254c3795590cea1576393937e4cba2d56fd2bc35c1fa9df5caa714b93fd90220947eba51a3ee78b692859d94128d3d8a94b3bff8ac862004d555c4d13b9a9984e3f68e4556e7fcbe2c620a7bac42f53e21d87be564727056d27cef94aa8dc7b29c3f0981602dcf49663f912130d3f5c43a81e65781ea351e23110715581e4a276718295f02dcd2a88a2363ccc823a34ecd275e51542be3f3f0d00a4b157525d07623922b891fb4cbfc1af530f06c75b5184d051ad79f08ae3648bef63f524738d3677d1684d2e241e2a8956cb46187984ed2d8d02d6d68ed64ad9e1beb8cfef4f8933fe08d664fed41958026d608dd1f5bab7b48edb913d986e56122a6014c1708e087089cd494acd2e9037c9bf079ba3218f19d1b842ebb987a4d8fee3f27e22756bfc41b5b163f0a35107f70e972923f054a74a64e1bcb0ae0f8c62fcf2fc8ba50255186ce8ce911799532b049f5d25133e268a92f4e5dae0f197de69690ff8aec324f277336a39bebca24bdf9f1cb86f83eacc2d34fb35ad15f819921c3b18eed81d008584b8e7edd8ce453e4a5b4229ab430ef32cd18a2f15d3e6ccf2b42525300bf2c6eb86f5e249fe7637cb2de4410757c6ee391f97a6835ddf59e3d7cec3d2567bc409ba89a67f583e5a9bc1839ad306c5789d02fb5b5bb7cc0a398e608ad8c5962442431fc49322a27a5f4c393a04db3e65bd18743df896c2503a35b03e7311acbf9c46b5897ae0c3b0dd29ecfd019d402f8dae8a219ed5623f3e772c9b81c1fd4c55ed03566803618d5a787bd6606a3c596f5909e12a27d7257eac3752d4aac2b7cf94567161bb41418fb1054d8f23b601e7f7c62270ea263d73600a8c108f645e1eb130d173e38df3bb548f0c884968151b092f0c351bc6e4d546ab5e9a397c6d1642c6f54d425966c5b60d8f4f7f7d26ad1da6fdf046f8451477c3e57f806392704ab6f1dfd6a68c1a1ab94d24118a5f2f697b49a70a26850d4dddc322d919b267d80cfb96eacb987b98a9f613f4adb8737f1256c04c36cb319c8c649efe50c5634c567097b95d2dc30dac7e8423fcabc0559f24639f4c67400624132851e7f77fda9466686af643388f0e9e26c60058058061d7583855efeecc5367c4acb41e96cbe5b536536b9546aff84b60ef3870ad82acba218e3236ed7af3af2e9a9439b52b049426285b5b4173d251552060cff2fe4caeb074525c66f28e8802f7b38668c1e60b07a7bc5cd9419627fc74974bb6de967e2d36726a90433d2c70008b4454244dd43a0ffabc569f96b6eae090e93d4f1a6ef8bdd8b6cc59b026087c0b858c4fba6d5499f4c6be172ece332991ec3476699b5c68d3fb01573e2d0fc09b1922","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
