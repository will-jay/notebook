<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c91837a6f90f58cad0dd45292edd487e79d538612d6377e5b4f45ad43ec0079d397bc4b44f3555d4302e4f10aacd5c5c5af50e5a304b3deb55ab6c5c2ec95f73112fa6b701170de0875d6d0680c4e8e229c82a63d82d9100a407fef216a36895a9583dfffd23c0fb5c9d6f8440cedaff8f42a51d74f11f575a89c044127e615f5f8c48fb5ed7c59a6c2021380924fd6b930b57b4fed75ef055ff993a8eccdda975bfa0af85e57ed3c112f794671b1948f202f615328af5f52ff811164e59007a64e2bce06e2089cf4e82cd961dc6ab7872206320f5cb48d90dbbc132d3dcf44b2f42a408a97d6fc3666bebc9d6ee3937318803601dd2a23182d063dd21f832d2cc41b3bd51ab3fe21567889669d9e2ef295e778758ae8f51f4af941e81ac4b333b2a9d1bae8eb949f11a5e8c19371a1af4d66fc0acfac99c3de6b0f09a7103b5f927fa635bc5a9e1979135ff1bcb464127b39c65ecc2ac36076a4afa577b11fcba838ee7ffc4f82faef4bba5f59ed4ee400dbc0ac90b5495c36d4546ec469356ca776f75dee8f2a7bbbe367d6adf862d97e3b22baf32a4af00085a76cfbcfd304398300db322033c9a5698be6fdeed62de5b15847a2ac8d2fb19f0f55f49f3d5fbf551203323284ed073c21409d67884dd437005e0c821f0b3edcd154d927bdfd9ae3c25e5265e8293fc76bdb62877b9bcf0f3dd95e55dd48a03e1b2d8dfff7d9d9769c3872e31ce3aadc603c22b50478fe6311a4b8509c42dd7cb45936aebb0d9c695daf3b67f6be26b90900738c100f11fb148bf26feb5575325bc8211e745f6b3e6fb799de13ddffb782b4b63ebdaa1a8e0ccd34b957773560d5e1cf3649da0db318127a9b6327e4eae3f43cd6d6c63858ba41368185f32f226b493a8c74b63bc19067063ee96bf93d22855124a5b23e4b6f08d117af8d4c9144be6c28db010a1def818e372b20752c8594efc8c7bedf9220da5e10004051b843a5277b880d9f37c11b5700ccd532bf8a8e301fd11f95fb23bb71fc5d5cd177888dfa32190a6fa927f550a16f4a16cad72c6ecd8732c265f4fdd58d693858bbaade7517f736d43f1fda8a3e6c82638b8fc3b7403339741d66efbdf5970caf79743304a5d546d9e8abc838de163f0b722d48a0c09dba45c12dcbe8c4ff77c01fb5cba54883038c42ddd38764563f5c3277d1d5beec265f625d6e76e148970017f495c00844a4930d44ad0963a5b4094121e3164fd8c37b7fe09a22ed1df92a69d2a1aabba1db650846dadcb76690727d634563ec4ffadffee491bef487626d39e151c0eb449f1d48a65445360bcc1aec4b075ecf886cf9e672f3842e505a0c97c1e9448a9b46ad5a1d8371ce097112fd58b21e8c4fc0c61ba8657b8f4edbd18d11f479a54afbf42aa01a23ff312a3cb39c84cfbf0c8ef7f94693f9107c4d7989545bea574129756c809b317b05dc7b2133b73aa755e169bde3c7b7a7c85ebd9c4b6b133eb5d245c7af92b4a9a627085fcaee5d3d5f52cd5074fd60ea268c2e4251fe2fd804cab010d2179e151c5d8f212b458c5eb204b91d8933f4323dce199650f54e2feaed36fcaca90d89fadfb465bd470b2f79839e38b8647d659529971babb9728dee065c4e4dc8eeaceb309348a3ed10b48e33e6502549ec5b9e2dc10726dea8e58c6247f685282be43dc113485b45acc5f048534e15ab0db0ee837f9889a64b9fac42b3c55cafa73b404d2c0a98fa8d6fdff376acdd681f432a07de876b54b0c05a3f345d9f3862cee51a65415382d7b513bfe4d7f759c563f67a3bf471393640e155a79c9c34d0bcfdf488a094b7e782881d5345dfe33e94627db41ba734772e88ab7fa554705be12417744f10b8ab603a11cbeb035de487782e5f597579fe439efa9c50ba39e056bb52865e219892f5c821930946d4020fb016ef820b473c7abd48beab2463f527ccbe1d36cd8720d9c3118c8f5ad9eb006703af853d8e4ace8433f9e631efa1b2d3e7518f9d634a36e2c405476213c728647c3d5328ca3fbec9b25934fd87f3aaee321e166a19487edcc1d36c18fcc04c970094d3ea3806202b398d5f2124e66667b84a39157ff65ad22bb1935ca8083d03b79a06f592b4d1aeeece546ae60049c693f31cac4f0a90d2ea8fafe960638b73f871083be5d5e1de0e92b1c754c9a05620fdddbc56cb2951ac48f2157e4308a8daccde7b5adbfbaaf3fe7c9f90dcdc528a93edb61d137aa7c21948eb622d9f15b1c8262b25402494ef242c276aae557c378661dd1ef4bb89ed7c7b8212493883997626281edb30f26082b5f454bf7b8898b386caf11fa5997762db5258d846701edab52a32ffee07bc4d876ad755100df1ec456ff315a1653aa57d3fe651d1c00518ed716904c082bdcf41ee90f6b32c28f7e825d81402f474b9615f7f7eb48db1ab98f72b4379b6621cf68b31555f9b0077f430b865fffacf9e91ab4fbcaf3babbc305e53899644665b76b6273cfc1077644769231ba690bfb192c7b06b89bb8871a422d28d9193f88719ab990e727738e0a3cd778313825a69f8928759db8f6a565eff5294b56cdc8eaac7c25bb92f966ff11421e5973dc17f0a771483317a83d451baaf5a162a3f4fc23ee609c5948d5df98d6827e5fec0b499445f711ac2135856162abf5d3fae4b9b3442145a2eb430ddd88689a494c88cb63bba81449b10b2cbe9e7dce39d1fb5ab56b7668f50b2e5290fe90e8e450628e7e3ae21b73593e93dd810f8a8128362e3093cea06491cfb1508df78d35e4d2876a33e4a317d5d57af47b0e012628c085ec08b799daed4d72de22f85e6cf358b62921e535d9664b911dc2e741af7056c1c3a825ae4cb0ba79426629dcc33d07517ca4fcad10b77fa51cac74bc2f5795717372d491b9a24ab6b3b6cca1b055fcdb2145e93337df9cdeca0129af7253fb6ece49e74ac08a38d1184c0983f1611b39af14fe2a3d957881230eea7b7271a4df1472cd1832310800e0fa383f83eb7f434d86309f8aed39fa0e3b4e56717df68ca5aa24849f6efd1ac991502c44d05f32c49728d6d141f8e92cf6ec1c51979bde2a60908fd65347c3f5aba9b7566ea6dce6206c8669d46e1ffddc8520ae856b69a2148f9f84e2cfa5131fa6c9a9ec0d67897eeaff662e1af510740fb4e4a61ecb10e7f3a1e0544afa7c78f21347b065c1a7cdb481b45be053568f558479387da410d0d9dfc49c2dc0edeb95159d9e44f148db2e5c2a8fcae7b4a438f88df28625c5420bf63292d6b8591fb1ab9dd66c0486d4a2d4756d865391a2bd81e4a64e0e85d23c63bacf040f20af7bfffcc3ec650db0daa89a233a99f1f0c99dfd2ff6c2b9077eb14e980fba9580f7e7d1cc69c7868bc55b48c177e8b28244d5702a960f5ce5a75436ab5fba27b126707b52b10204a365c774d178739fd97715d399f8df50ef6b694cb891319c53793c212851a78dd8acb3301582195b3475068c340caacfea45c83beb39cb21955919dff0386dfa4418fea2097b164361599519011f72b477548cea17d4b4acaecd386689b09b9cfd33a19c0c663088f4a61610f8952cddb2ed0a84eed8b575aef66d0f9733199d6c8536d092654c613406213a7d9cbcaad8cd3bb5234a8939f32371ce340b123de6dce9d50f2c9c79662d0fbd77fcddf4a390d2f14b11fc132d4c1552bcaa688d253948fee76b3e8ced43627bc0c68007f2580e5ebfd0a299dcb1c82ef31443fa4e8fc34e26a0263847e13f0a03f2ad46ecd51a62b2632c38d71b330fe67a02f4fc43b8661d05356a09c520cfd8c514a304ad7842d7c56a8d640e2bee893088d438980eda90ca9d5b35195806b51d7e4639a188e067340e545a060e6e89bab6fead00109762c80f8b1bb3506fcce92f6416e26611f4372d8c122599955731046f22bd42a9cc8f9cb555c50d684d3d55c4d98bb66b54d4eb85e7d0f27d31295e0c5bf209be22aa989e8af3b150895d780cfceb20f236e6f2b915d751b8b823be269f0d30240b804a2eef00067153498b0b6ac823a06f9feee5acbed12026a584ca5734b67db3860469c8f9c6764ce8254eb4964fcf65968f2639a5575eaa2f95525ba950002d10ccad248b13422797a4aed7721b6773a4b2752ed5d81ed006947f85c2a28d5c3bdae624f4f30e78a0c768e57a8d3d3945cf24593b42fbe4d230957fe905b4a8aed4ac6d9229f5e8b6d15d6fe8f8322f6661cfb9dd83b450a7e371981f0edcb80112f3554f749e7ed9e064cf35f131160a038c76baaa92a95d2f2aae27813364319f50925b0ceb31d814deacac05812f7f57625ff698a93f5ee69ed1127773e9e2d9d3d94fd5aaf8be387bf9c05be603f1fb9e193f9bc6ec288ce671939c51b0920dfd95c873fec658a4ead9cd3f04dddd61a1c8e767066157508fa5cda76fad1a4cb1ee347878ff3ffcf09270e2c8770c6fc8f3f6b0b78b846c21653e142eb2ffc8609c15df20aac54aaed187c6638cf2726c30acaa145b66e216c35b5155dfbb0b2be654f4a20c46374fbbb5d2df72f86bffa038ff10c69520f1adec62efaee4f399b99d1d5079b42bbf15a7b29564dba96d7267ac859606085008f2df3d0a9ea72f8307ad90883a28d79977ae0fa5ef585ce97c449fcd0d94803afdb8b9c6ef6e30b0354e37221e450ea1542aa373d93bc79d45bf178eaeacb208c6dfde1f2526315752cd0e89fb7041b65c055192874ec5f024be86e6d859dc83265c608ef4f7d3c718f9fd03374f3a1b307d3d54e16b9159249e1ab27ab18bf363812ca9c4e1667093b587e139fe6aade572f21a2b5b55de15cde9d4b29632a9dcdc1ae0caa6b2ee6b8b002c15b2cbfe04e41f24bb0aa335bf353d8b0b66a888eb1f68eaf5fa259c2f6bf71c85a7d29f05cda083c3d869cfdd72cb6e53ba8b449aa6ce42c124cafbeb350aa78ddbe0f0f6f882139ec3dc8752776d8261e4fa9d8a79d046168c3acec512a3381ae52bf68ed4dfea713093150b8063374acad456777e66cd753309a793a81a42092f93e917427d8411efdf2349ceda7114329df523d989b65031dd5945f03770b5d3a0503ae9df32ce738da6ca069253bb160e82c7f6b089cb76b6367ae449f41dafa6ee46a10e68d8e79f90d2c3ca54acd2f9fd2c96d932e2042cfeaadedca727eb91d04ad76472cc391b1567603f479f120a277ce67a88b1895dc61013171e1c431b08fa405d6d02822664e9f36fecd714704f3eff4541d645375d00fb2a2aa9615b75175f642b20870c9502693e07b0ac7199b5674ee927c9f84578138a3d024d1de9481bdaa25ecffb5662ed357be3eec8ce5be08b52a02a38f200831bf96ef7d445891a1aa23999bf3d3a76aa5eca41cdc79ef67dbd8b079bd524bc62051279a01bf0241e4493c9bddf619e1e0f15471196768a9bcb999e782e629914a2c5c14123ce3350eb0582f88ede586d9954c615c380c9f818f7e3313994c1901bdd8398e48b28bbe8255a1616fe1102ed2e3c992bdcff6aa1fa33160dcd08454a3217a628fd9c4b1f1e57db50389efbb2e7342f1b2745ea599663dbd568a3595a43ff37af6b0a55d03ac8a0e96e33900e5ee6c0ffbb0f37fae4159b3cc481c1d3446954df355fa78a60bb0fba143a9bfb54b3b24df61cdaff6e1fb5e44a72f2b4bda122b67f22045018998ff07f651086fb4d791dc11e4a1afa29fa6a9842199ec473930b533f52c2fc0c70de3de5512bae31bc5b98419ec34f0aef533b64167dcf3910542db37896cc3a287b9e3bc5ab9f943b538457e64b9c4731fc0f3959286414a2f947eb4f28bed2627a6a31284f99407f1db7448e4366fc97fdd6342a050ceaa74960ab618dab8f4a688850e2c9fabc383fd67a673a2eebc947609fc250b0b5fb35e36f66de0f3368ccf061e566f3b898368670f719506a54f36a219534198a90dab76f0b90ea298c506d21c08a38745f87374dc7b1453fc57881ba728b38e3612341cc99383da27cc26b651a52bf4e233913d0e5e7eb5922ec62a1a7a0c966a85224e0bb03845e689da5648d07ba97868927426d3f5b49c0ce9db777d660aa5223c71d9d3c28787fa454a89f0cc5732b669b436c3aeac07367cd3173ae769d9517b7ad14a547112149c96a7bfa9e9e4b7c657145f4769aa34538267c6e6ef009b7ee921bc7ae411ebfba6266d6188cf221148cacf3e1534657796c7ce30ecd8f6a6a9fe6912043476c6375485c575490d52e58dda953f830ddf23d0360ae5e49268015b7396ff18aeeb0d8cbfb1d12ac6e4ce84dfc8626fd4ee095c33f7cd79becc593db0cbc70c6c9505386f473c689bc32be5c6bf55c759521c4ed05cee5bb03bd4f6efe4e3dab4b35fc54382f040135588c66da2ef4161fc5d0c4e071e4f3f6e7fe4d1cbee2222b250a779d9d32d2fa2389266878dfb6c4026fa67727a8d84612d2dab339833bc0f35b791e746372ad2310803e6c2fbfa4ae2a01f204c7625c7f4445a35fec8b51f833528b7722734fb61c87c2faec52e125d7859029d7db8bf05b2ef068111c9038a8983ac27017ff0f6ebed245b3961e00ce8c8615a562e33c9df1b6912f584843ea0ac28732b8b09a01b851deb0284e347b1b1fc22dea2271e6fcdfe8722516152065160552a935c9dcf63c25135986ec4da7c7b7ad8eca354f411643b5518db41c40e7554213c5db4f40dfe71280de8b7109a2fdf6c587e46469ad8b02ba6e914a4950a9f0a82627a61544b2141c7f7909269eeeee36f7052f7cf81fc5ccf5f6b402448d8b6379cb7ca1b894a73da11e5ce96e39d0baa1488dc1f3062c910a38029d74e04c7409081bab3be75d705b5873502978b1d31a75f8b9ca2f52748e55145e569f2732f7e5b5d57a5fb3397d04fa81bbc9ebbb91422b9729f5c6016ad4870dab5bf14d4daad0d3f7f2b962eff4c0992059964cee067bffdf9ee65eef03b35d65d785ab141e6cf02eb17182e9825e1bf4b26eed3ff8d901518eb65b2d83c33f8c7efd04962c60674bb080684c8c4c3536d32b51d0760836b98c4d83b7b4e2a1be1d2f0dd3ffb895e5c823403efbde31c46312fa377645b8d911ac4b64dcdc8fa27ab4ac24e8b51a01ef780cbbaacd948d9a128972e0a6999cb90d1b7b766b27a93769d29e5d0555cbcc772166d03d403b1eec06cea8ffac0e46db3a17c76e86f97c370efa51ad8cbd84866ca081692648a464f87a65e09212870e7970c1e0ac40ea24c7689d73674f6c51767279898a5febaa6b5103bef982c0bd63754731ce288a69f5902b9b2f9cb230fa88bf21d6fbd64382e96c9f088132221972e97154504c57a450e0e31cc9ca81d696338159be4f162da810348c97f7de1a3ead04a73fdd738b82d6a4add02d7572767261dc67b3d10d65e9468baaf450787bfbef2565f7c8c4ac151f7f9326d607261aa43b389df893a9df10fda17e5a0fa385bfae2c8e572d3f79753659a52572efe67d3c8217595f28b7c87f797885a95815007d7dcb87a9a54779842ca8bf22cfd7f9b74c97b01438bdd597e191aa9b7bfaf526fe57774ce094ddc42a1353841279022d220220ab1e9a53237a658ea4e21f456da5e9ecda4d5904b4d5f1ff6d0ac9e63229b6238361b4d76ba24709621ab7a32254239df6cd3c9769769edb66675633f9728fe846eaef5e21e14ad3da7bcb822cc2178a54748fc0affcb4b40d0a24bec5cea43862c306e3b40287570736bb4c8160b57c93afdc89a8160d911b1d465d111529e3404885d48b31f628e8bd67257040f2bcf0c5c3e2dad32fa4b05f27e1b3da9240ccd8a170c31ff6303b3acf14569901721f341d9b87d4466c17363ebe7417fcc957b2052f3e7d627125c72deeebd03dc19c46be4813b1a17d4b5aa898244569388c2b1c91193b05dc6f5ac5e37a0f7da3b60ddd353d04454afc16249e082299c25911b8ff7fd5ec9c233ae13fe5d778e6743e0833bac7df0e18b1bc48b3d84e68458b7ce4f8a63dec4b298ec13f13eb5d7e5cc2f603ff2ffae3021213cb1dd637778666226d3d889adc9dc30e61119e3bc32ee792a51d3903af395aa2064630452b621a6bfb472f404475c39fb47e5932d88af7b293fef3242466bb080a02285f76a5c78406c19c81ad7930b577df8e2a4eb6059df0a294fd8fee10881896cf8116e6a9a9c46e99f24f9539dbb51a01f7fca8eb396596b89cff24eca6af1230e4348b453d89cfe24d38cbc991ff21f573809cdc1534d62cc121c56ceace414ea0a368b6193c3999f581fd1fbbd7b49003dd1474dd26b21eaea4e4e43ad12b9b182cef8697b46a4bee46037d2dc380e2664f534ef5ad508ed18584104d681fc4739aee90170adb97bb927163c06b508c1d8ed0f8855ab72021a06d055aee6373a07c7cbfdbe7d2cffdf0448b5bd6919fc51c25f61799d13aaccf1a00878ef90b047c7231b0a9b3fd2eecaf21e51d1c958e4b0095194e797a52d3f4720959988d3f85ec19aedbc94ec70e0fa62d7c43369ac167d6ba19fa875aece580a28ba6eeb0800f0f7c446decb9b889541d35e3c37bfc074d78645707ae7b7ac795186a1fe178827457484c2101bcf4f613b582655736140326345b108256fee5b4c14222a6e15b3daa9d63a08904b9c012d7520cb817e460a8cde5330f35320aa4fc02e5d541885315a1a26d420b0fb14ddfd94a4166590a3c67b2568bc834cc636dbebb23c95ce2bfcbcdca1ee9197ec7ed274e601ea433ce6860629f5879bae7bb857e48d11631138eaf6525624976e4754589041881370d70d5ce43fb09621b45ebbf5e5d06e2411ad969fc61e13bd03272a6629d339ff64a0c8997e9a51e6742c0811196b51ab23cf600d4c119b172813a8ca3a032d5a9167d8dde16dfb5c26e4fabb19171bb5532faa126c9b4a9e2dc0cc428ced04d1eeb9c9cafa95bcc8a7e859812682f86fb347e67eaf36b9121116250fd696464908078c400c8a5f7e933c9883d87babaf6df920665fb41d30e042ec94020c127b08ebb66ddba48433c61bae8be57017b1ad9ae2e30aa2b57a1c260dd3c5d90f203461ed0a3e9289b18902e85b0ade5eb9346ecedbd1b9153f2eddf981858771bfcf256ad820804116ccbf117c53929642d7dccf560195257acb63fbc3866877403abf8b32e2a390fc56716e981732bf27a548928158c5454bedeb91ed5e725f8b0e752352aeb0c500c85223d551d5e08aa3306993f3750d713991dd21217be1aaf921c7ae48a981f4f2655e1692e3e173e9cc497fca4ff5753c99897ff7a26e4ccb8cb64fd91df05dd99982ee847e768783e5964676ff426e0255d66c01bfed0b080562753a39ba42db2686a13eb7d2293118f166c36d035ab517e5b97289c288c2fcad735250644341b9a85e1750e720c13f95ee028588963910b6c73a3d9a0b5fbdbd13ca69acf68230b29e83ea5e409fe0f00a86902017e5d61fd360889cf09ba7236bd4341de5d61900959844c6f7ba9b142b0e021e3362e1969d080a7f024a5c91ce9e94156b8b94cc9cd4dafcff4cfb14c60affe503800256d444b75396bc3910a4098fda426c6dc2ec0b234c0bec17741b6f0daf2ad41e2b74852b613090a7dbecaf3f2891c8b11bbb45479cd831f8e63da67a270991067338f0e72b719396c32074b2239a20504b4aaee93ba8259b4bd2b8bcea28ca4c8143ff4e759c4bca7babaf732646688846897eeecf97f896c25358b87861ee26ab2603a8a0d1d040fd30d0e317b8dbf9defbd4ee30bc9fd67bc01a309961b32507cb882056362a58e62894242cd26442e896cb657ddfca9032e60243013e33f6b48c8b710cb6bfbbdbed514f441bba09b9150049f6a406084375997bcac565f1a207a46554aac2d2fe08bf4142a5bfc488b3af7b2c18bd86358ed53267d97641175506ee3ed45e71085682f4f3e19d1d0a46be34227ac8b047d57c1401c87fe81ad63ccd13a22d1ce0b455d588a32174062b99bc6ca879bba622ce28ddf300bc1f12ef410e2295f21c44aac7d289921cdef6e072137ac6857f361396da63b10680955dcc640103a0afb9b9abf978e4efc309dcbb82e94824ae5b3688cb91384d72ae7a67e593b032a7adad2f1e5a0c14638f95bcbd41e607afb12ad51b1830d33cedd34c64f7807df5173728490ce9bf78c7a0ded19c5982371bb9e1f271908b15f232054e936be1afa18a08a15f67926d681a3ab7022914483a7aaae4ca0c97a41402c471941f9f262482b50135683ffe00f4172242e540f78658fdb4e77ba275020c8ab22f10ca1b36d295e0ccbc9ab3ddc1ea5ac033cf1c32b22a64de80ac3111abd3f31a5d4f951825b0e52c032042b7ec71bbabb6f1b0cc7e61835e5ed8f78b5360544dba3530b97fe35530d98af1b7cafde11cd0a3a778a9baf8c85505dd30af90d9666f9a89638568bdc54cc03fb9a79fbd3b181d73e51791ad7ec39948ee5aabdbfa241fb5c0d509a639b524eac666f0c952372bc282d4392ccabf258832b4cfd83dc5c3e1d405c436e98b309818132dd5d09e571d62558c5288c1537088594d6fb05690cde298bc1c8af3e340d3c2c7330b86bb80c90e6dd7f4c81b5af005909f66e281cfbfc33fae12dc25231bf2d482800e84cd7683aaf64af009ec9dd5c2848996e5797e15b428709754184647a3ed7d6c28157808a171cc20c2f4e2b0bb9b981b2bd6099bb61243fe845a63e4206b6ffab5bbf74665c59c249a9859dc5225a0fea776b17da461136a17cf4955b33beb23545904dc24127206a70d6dd207457a493c2b23b9f62dcda4598ec89284c07bc00715e1ccd1e89625f1043cafd4e59a0a147078353bab3a562eb4055e4b0ae33ea9e809a7161b8cc0b8623e12b01c0efb7e4f1e623de6c3a46c5b636bfcb2fdfdbf463137c6b9ed0d2c22dc2698ac657b6955c997a8ac2bed4fe5f933bb668517453de64bf2baa99faf5bfd69fc9d132f6f6c9eb576df0aaea134b80320f59c0bbce9f0dba673a46ddea8115c57cb1df06446182421da8c2d43090951b4f06588a24d2e0f84a40a7466a700d92573e5ffe68501f9f74f42fd27cec4e608f8912262cb7d37a8ed160d65c1d8013b1f0aeb4491154a9e2808404d79809bd51edd0b5484efcd02e1f0d1bebd35f3abe3a40460337b1488c419613da75a0b8d0e0d2d2fcd82ac7dfa97a9b9c1a9bbd5d3250d832ff1d1551726a54e5ab44139dc50d85f17eb61c2b34bc32a75af1f6fb0c273a9653304ed3c89fc69e5c9a563c6225260ad581f3a6378cae029850cbfb347af44cc9d17267e083febfc26a1b8891cf4744d56b064537ba7bac62c5f7fd3b6791b4ec48741fc93ea7d938fa9394f21e040729e407c5eb10d7a374dbf515fd4ea22cf68ec230acfbebc53e9687863a9294237f6b513cd19ae39e460df3f69825bacaf9a6509e4e8b1ad31926a6a968d260785df0f7c0b66967d99c8c53d7cefad67953d5a6476f5e409245fdae4c5ca38d8f83e072fc21ee70ee900700bd66971aec73758d4c851acc4d5c26b67b622030d086bedab19d09181afce61c5d0b490832bb9f3753f0c52b57240e54907611004eed6c965962800a3ef2c3159360035bad8a42481d5513e9cfc6eabfd2bda3e0bbbb9822d02628723e69c36d93797c9dc1511ac62cb3ef449b890d66f5eda058abbce643a41136ea732b0feac456b01e95cc2a3791d7e74d135d5865a7f99b72f6fb0a1b3458119cc455154a465c3b5af3e2c50ca577ac1bfe489528ed7c52a62b1b34dbc7bb6867faa65f6916149c5322ec70f66b48e02725144f2e469b5ca8ace0b30804eba518f1e8570d54e6ba6e1b5e40906210d8ce3e7079f0438902e4c4b1127a2837ea33407784125e91f746171134bf7fd582ef87d7fa3ea0aeed7b7d073aa715b1c883d5821ec0ae4d3d2190719facf3a4fbbd255066b1467b565f9e3dfa0ab780c96d1a4c7f114d4acc1eab7b5cf31392cc9ce8627a44bfcd9be995079c2427299a27698da9f5b07845fa1867075d2013867cf54e8618d446d5cd4e79863ad772d300d789ed1d120a251e7d76b5fbecaa0f5af11f7160c2531551190062414bd7062021331e5932e3a6f77dd2129428093d963d92953c08b2291dbf13a8b880291bf37c46ea77f8db229d405501c71cbe9ce78ea562973ae7aeea03f83438d1032cea68c1d5f9b9c440fa4449fcbe41cafaaccf01938847ebda4850f2faf27fd7dc818d6bf310cabb539d45042ad3c35dd7065ad8366cf3f06bcb4b24e9c0bdb6ee1f27d8235de89cafd418004f5fae8d1487733943cfa5be1cee9b998759a28c8790238fcf191f0886aa92b21da3845c2ec62e8a781c5ffd4e1e6be633dc908b1e9528adcc5d87e247facfe7597aaf6f5fabb1b45b2fb528668f7f3e86b9719a5bcbe4eeebde6de1434f3c10bf0f316037ebeb0f9df8e4c8e1e4755090c6383214c0eb3360a05c30737496e39fcc57b46c4b40413ed733303a119e5629d71cff8151f366bea69fc465728ce32c77e72131d470781b3473f793cdc009842cfcdd94cb664dd39dc00d12d74eef7976f46274643865b878e0f04ae6f6ffd63fc0c2d7f96e5ac30ff08abdcbcf663ce057d674e6c9c65b20ad0eab07db1f326f3d3ed84b7d5dc8fcbe71dd17ddb2d6a1c5faf3204bdd53196fe9557be69c1f2dfda28216f0a2d8e5fb387f807dc6937df2dc4f314c3726ec615751243c7ade07972bdf9a02236467221c5d993acdeaffb284954cc52450818910726438ee1712d772372bb46bd5f0e4bac8d2909b9e52bdf7f6722830e59c695385021eebebc22be0ca0e3d02c535fc722c468fde120219c03b6d3bd347b7db8c372123fb2a3ce68c28e7cc27f6087f26c2ac5f753ca3417f41e2b5c3866b56796d8f6905ae8c8636dbbda8d779b79e1989b499ead5bce84fe257a3cc8f38fa311927a124187dcd33135608b3438984c8b406710d4626bca533f68fe903321a3ae2af7f7d97cc90c351080fc6431cc3cd4d52111422bf10d9950430d39a977c62be22875258e9e4f1c7dc4c1ff94a2776b19dac4a93a586fe5b07a13f077893db7786627c33908c55e79103f9afa9302fdd8868ded33cac8834a778a35a48398118027111cc93da8ccf9e82c4effa5ae1402962d4a1e553ffa07737371eefd0da965ad9943aab709b34d2d056ee0e3db0c1889e3fae035a907c297bc9978d8e6434b5b4d3cfcb7ddd960e5a0fcaef9b6771d021fd79d5f0ef167c00ba9af12cc481b9c107dd145e385dcba9a72ddcbaaaac7e32a4dd5268b99d09a61db40ab5ac1ffc4f62fc037299687b8c0b6a9244472c27fc094f874e8e232c180144ea96599f90fd717ff50ef1361d4558d67f15ae9337ef6b0d08af085ece95bb35bfc1b695e5dfcda11f2c7b1d76ce409f22712b981008c8881b9dd785ed5a84f0e6d9d3eb9eaf57753a4739dc0e4420b4f0dfdffe42fd41e0f17d7604b822fb650805e3aa8c7a92666f0041ef3c13482d207dccc610b0f07425ed6d262df861e458e93da236cd595d684255cd28ac456853fbdb7eeb7f50ecc651a2b2b3370202cd39bcd05bbc75449944e6e58d24bac422d10e2751468f8b225cfbc7a98a26f5926c5dbf6f1b8430baf6efbf2c582f98132f87bb0baac550b8e4db89fe8a324898a91d3fb0396c3e21b08e3235e7e45ad7fcd3f958eed46ac9b979c2f264338a413bd426cbfefec189e26f7c288f147eb3d3d708763cffb238618381e596c5072237751f06b1244e1143682670241c91210cfb13effab871dce10ad3db39b7f65c75930566c836796163c037afa702647f4149f053c2d1916b37f5eb7735ba99d76c6000b0ce9c28afe2a3a66c1d20f06b0399cf19d353491867f8ab01cf142c46c3f160b433c9c16af89a3be784b733957fe1f113e843ff68b5114f7893c6eec403f46ecfa904b4d2b02dbee17046faa8d645fa1fed2de6a34e793659af3c88d24ffae94c0b1b141a28c2a87bb9349f08044d5b31fe11a3e33aa4052fc9e86cba226d22472332b6f7e56995a295c3dec0b81c9c9a1685d2c033146aedcada95f0ffc6abbae0ca654c667d1dedad0f316471d7b5b33dc7e32d703d89a2f7ca5debba23a2e1db0e46ca25ca133b9c309efc956cc63bc8b70fe664e6e9f4e771de99a782cb4c70b1b80b58f272449097f39ad42366eb2fa6ea79024a9a5d165d2cca2ef24be32fa76e2798ea973a0247426aac9c330ddaba5f952adeab0cb06af4ee77363291c0fbaa90d5890cb00ae42416c470280d6212ad2787ae45a80155bd72c09192b6253683379be64c407ec4d768b73dfc7ee82eb9448e69a02be0328dc27b7c315798ea3857ac9d778868b21b381074e42e0d39191237b81c2c51198051f55b60d52ec2a35b35d3cd2ce1d48ce9a91907c06a0e771654cff6b1c57dab565111d65211e04656800c02453e7be55ffad67237972e8938382b3e2af676e04bf924e5c14038740a7d8899d5fdbdad064f4a8f45787665deb36181e4edf33b23297db41712266254b371aed1b8023d85b06a2b56d7f50ef362566a1dde03e18fd9b21f02eca703efa6f54c9589eaa0c8e760e8260f46d4677a5df1d91ae797a7a1440f5f270479fe7ea0f0adbcc1625ef228153a503b04ddb3f21aa0e712087b8e2e50416dd36eec25a8d4769d3222738cc78f26174d7843368502d6bfbd1dcd0447693ff3107844c5a5a1386f8e2dc2d810888cc3a7383a9baff4e116921594952cc4e3e9b1b58563e8161d04e8d30245cc46dbb14685fb100840f171ec378c08bd24ff3363f1a4e17235a1417d5e7e441cdd7b33cf208575bc235daf3ca3be7ac705ce0aa42a41a9739147eb7f64c78a2de07d1ab4303e47512c63b6314d468687742d4155b2d539619a6d2078b9a2ed7a152efc4e515b28642902bea5dff5248cd85887addd07b6bb83b288e128f9049bf1ad869c84490221305e00d0e02cd3b11ca522a938a9942bfa77efdf7ca22c0544424e5b4a823820fa30fd65f0ed35b4f5199dad9e7cb080fd0c5f8ec31f75da0a35cbdae18027ed093d04393337074c925ba1ac8981b25794dc1497ecb2c6d89739bb946e09214ae01d77f1366b4cc4623b4bd0a0f37ad7f61e8325965db9507e98e40e2f412cc1c9f280a93eb0b964882cbaa0d286e7dce06e0e1d420c17e705e40bfbc680f78d2e1785329b607f26786bc291c952037491136b8fe8822d576a636b3e0fb749baa7a40cb23efa259f4977c1af8d401d22c2fe765ca837e6611cc37e3c6673cc894881ef02e0e99e3b07ea2ea60609979dc46dc1947acdb5fa1e33478713705f79cf7f68c911f560fdcbd9f2a8e1230772a2699828901ed3bb5419380fde3e963e5d08c41496e4030b80b9327dfd6c8821d57eac299bc7955faf7a35d34774225c28c5e743ddd50b40a6bcb22c2cfdf4722130867207f13a01f444b61803c0b0f690cf9c84e89f42c35b420b55a63be784c4620a3bdf81a385093ab4e01f726cfbb83bf38c0d94422dc9d87ced88aed0fa61142198924b229fee2cb0273dcf0e1a173771f39d1bffd2672a543cf2271886be9b54605d129e21ad9cdf0deb7feab6d7e04be75d8b18208022a416e587c8346a63491c0a6ed2e4bef7a2d0db46d4310c0ba83b25a9b3592f22e21ce19a6c39db1e30b98af2927950846ea6afd699b49f9dfd75f9b401ccac67bd43e11a941836db01a5183c8d1eb9f253c28cc28714daef6b534664350dd4830e09bdb6b2b8b3773806a27a39c553e326de68d84e31338abfd561777ace7642ead155c1580716c740d37edf6de100fdbd3c4187240396d10884a3e59d73184f38aa7b298e4d9fbf7de30080ecdc706d2da50af4a74fdf2aa5d58ebfce430ae40d746541e28ac3d16b130f22e830a445ec4b72f148f0590d3025a0f5cf42f9fb859e0f59a20ac8cbf5c4bcd723ae2bc37a695fff0709eb037573ea8e5bf9a468d029b8afd83cafc6f205b886173e056b648fac9a60b0b477809188bf325d10ecd706413b7b83b593cdd090c92dbbcd6fe2c19eed7b26b944c12e5ec12e7b4726d27a2281672465afcceaa13754063c7e324047ce577a6feda5bc3c6075581f7fcfb71cf6c88b318973e643b93e621d2aa7999d22894e9402cf2d4f7a4ebb9e200540e2e76f6563ad9b0d0e68329002162b2d19dd3289a55eb021134cf41ac1ed919d4df8013639e8e56f5fdcecf6cb9bdba25e51818f7c93595a00a2cc7e614ffb65c54be2f1a1b19b6adc731a1186772caf8d3fd31bb0ae8044cac63dac0807c18bd8673f3853f814263904dec186f51d51e0214dbe415b37acc1fbe3db9cc2075cbbe35e58b212245f25d7c40a4829badd0be11103bb08de2a1069e55c371d12a5c31f211f86b7983766116a13d39f6e3f79cd4ff87268803d6322a40359de7b5026c6a57f975e7eeed5c29eadaab2ed606b80f70e77215668d43f8b20c920136808c035517bdc7ac993d5416680c1516c688020cfd8cf01c84708e0fbcd3785c60d0b8b66767c9bfa0e2cb6bad75ceb6b816525bf5d85d48cac11637160e476542b0da7791e5f9b4db337dbfe2231b2c569ade81916a76cbc1df4e5fd39d100c8707754339e737e657fc2bc4fd240d46e4f1c67e002d98e1842cbff1780d0949a5bc9054a50f46e58d709e6fba94e230b2caa9f83c310ddebc2d475346b03df03afe0dd03776e9b451e8d25f8e5d795fea6ae7539e8b2e0654f141dc4fbd136e08d61d0ac3b077aba16f2b21e2e1e2513a4ac81fa8ec95b285ebafa8c45f99fb90f542f1c6051ab2b643e0dc82a0f18c99a82b0ec78c4314327357025c4a11a2978be7d396ca1909c860f89c1a5f834cefff3071ae373ba8ac33173a6440f1c51bce2df39595a38b09eefcf23eae5ee57bf0678267df4364912d3d0b62807d169c084470e192cb074289882ad3689eeac09a31daa377c892aac2fde67eb13e8853e8b31e365b32164f53035111c859df7eb543bf4221607053c00138006557150c2ce3fe9550943fa122f47f17fe2eac503e09b3b8e8db383f38395fc3ba44701257ea19260e5c793e90732979de1cc4c9d4bf3507ea83565a3732c8b4972f47686d3b4c935d44b59cea90fb7101767d1786b909fece0b60a0f0a0649f5dd1b15570fccebca2a2983f67ecb36fce51e53b3c4662ff80aa1d3421c6cfd78f77cd18272c845dc7c07246a06a7a516ad3635dbfcc5eab37832df001592c3dfd20fae40196d2c65dd94","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
