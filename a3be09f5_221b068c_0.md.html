<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b02f174209a22b71dbf2dedf922861f0a11dd7cc8d799f5930fc160550c4e939398a897237cb784af6ef560a98a796ae67d376818ea29ba5f279d610d9a249fa64fdc8d972ac63474424a7f8833ad1d1b505558d462ac7f555f473c25d4163730da6ea4c7fcfed5b8743ab5437ddbf7fcdc269961a66e3cd9d006e2d71bb94e8c26feb4fc224fab25440e41919e2ba29270a125b86ecdc28fe9cde03c83bda6ddac78ae5f93746997f49575de3acaed31d44b6c724aac7bda80e899b3e31b3d856a520ad9a5c4425d1b2162e4158e050836bb036b7467a024e7253da316e3f81b9ca5e2c4b3f29bab6846aa757407e7fc1a4317cf84f76ea9cb8538023ba4a3fe247d0d5d0ebf3149f74864925e7d05c598d154bb44d39d62a7fac5cff72488c856133fc36b445f27d0cdd394e04b409bea739a34d21d01dae89961631d44668503e1e672e9e99865c24d299f7e790a4f6d67abca3f80b99d41ac65ed024681390060215c4ef121796c5cd64fc3e205f7a4a8cc1b7f9fea4c1501f7c9f33d24d276b0b3e71bc7f1f129c1abcf3a16f64cb9e991eff76dcf2abe9c709d607382a583244995dad2aea65ebc9214820e339da5ebdd247c6f3146fa46288697bc3203c704ef727547039872d5861bb7270a8ee4066426eb84ce55b639970bb1e43a7801ff00e6fd1ed3ee7653b0c14fc4523966596eef840240619d501d6fdc2268de9c65034618a2b95da8c74fd190d0686826ef742cc35411badb6dd5fa67bc43887b7d5bc7f01f081b47adec1802c7e745f649166a47d002032c895b1935e844a693e7cf6d397865b19b27dc9cdd38781c613e768e3ccd3e35362e097f2635ea88ef8a23cad6e754750f64176945a7cf667c7732ca834562c46ef770809ebcac64e29e077e5347be3a58fa5d8c31f3cc8d8918d9fe32dc1a89ac8d0683fffae28ae67ae027b12d591a2206ad68fe54e9b6468ca199fa3cc2a7519115b0ed8f2c1518e97e53d27be8ad8590d4bd583cd42a91d8c4b9a8f363ccdabb40ae2c06862be921ee4b85d0f5ba7b16ab19010d4cdd2764f3d57442e61206093f581ae77c7f4638cad4555b9f91c0f373c9b35440aab5dc45606bbdedfe7e1d96f39680fb6d8b536c238f3610c8c2df767a05ff18d774cc00566bdc6355763bba3c4e93d71a081289271e36b23353444e05d6e2b763164b751ad01f4784a86e619422fb9ba18fb859f44a91b68ef339a7247bb5dcb4dae78c1e72c1faffadb61cdfffc3b4acb4ab7dcc9ce0b08880be09218a39fe8888624277a38a315838e205d7bcdc7bd985b557bac8bd692c73889399fa0f1197d78c7fe1a8515a17017fcb33bedb85660360c1ff43fde9b393ddb935803ab7716282d5a450d6f8476419d2269a285a12df62aa34cf1adfc8ae60b543f934434fb4af2efdc47082c35ebae4f4fcb8030898608fcb74be85c1570bdd1f97127caa7d1bbddc6cdc437d7821e4a6229eac8faae987f3d89085368cd3f703f73512e03f98ca60ef7c8c224407318c533855a3361a475f88e16bb0dee698d8a4897cca057c5740bc2b0d46897317151a420cc0f859e8cc0eaf5c460c7945bee39ba0f9f46c6e3937c6985f537243cbdbb08ecd99de327525f329ce2da7eba0d691fd6891f55299a2cbb54e460c3aecba5b12cab09eb118569aca88ea917882e8bdd3816a2fc44bb59024a8a99f17ed7728936b5dfa95990f415523ea1d87fec1d1a5a6f6b00e8522852dc2ffca88a8394e6b9e1497d281c371bbb94de5e06422a904d9cada9d9f825ac64a3405cd33de8142a34e27dd61eb0de87271c7d1c8bd0417011b444b1c1abbb5df8ffa2ecdaceb6d6a06c0def92dfb15e0efe72da04e3e77ce6ab90ae3a6aaa0ce0c79be7f37fe4d0452cb3996eb265e21b13aeda8600730b2723a60575f287c39a90290447554ff54ace5a19ea341e53247ce27bb6a6e7df37eacc6826dd4472decbf61e3d12e00fb293cd1e00c55afc96f522b069b77a87a9da9f572ddc01fd638e011542fc04bcc6a7bde26e744db182cf24c0fa3c7c4f6846aee09343475b3fa83f8aa9047d728d5a01baad45065556955856f5768ffff85b26b2d1077afed8b26478fe75d887b2bf52393f2071b7823aa35db1b45d4bf2fe11cb4b537ef07d2a67a07aaf8345c1d225e241fc274f16b1e43dd54c89214d67dd4e3681045f9a8cc0675b532426e469182b3a7a344194d8954d56c1941ee855c6cd97ab6969d49358a789357e424c943474ddbd95e335ce52f0311e10ab4b86a4d8d39bf7aa8a0dfcf9caf1dff49c94c66a7d5ba1c34714a19ff155d545448f6e57a751bfc1db04e536d92d9f2712a54910a4e65aa513f2086e313c937640022067e3c7a2fb8543dfefc8f61df137ef25cb800963859c11bdab6fdfd10ccde7c1367d07204e2a28a5bc9a590380b32fdd314128e15a790bc71a9b3a13cc04709f43ee4cb4f49c52104917d84aaf26adc8f91d37136a357898b1a255f20d8f3b37f5e551768f59d2b22823f857b348248ce2266be1a1330a3e987e22a97b77465e4b2ebf69d9ae4943fcbd64bc68c80bebee643bad8c3a8118ad8bb29034cc841864a5ce667f0a81994e1e6e543e960a4b673362fc909ab03727cdb87c68f5eab715285f0d61d494215f6eca53bac8de9071c32022ddcc9eef95d2d998d459538d3361e33fc86304b865b5a37e0bfc9b7e9b887a670ac4b9d20514a0aeed8ec4a1f5266e9e62ba8c1a4a0d5b14ae7c50122d8ced6642ab8f13d8f2dfa75c3199e9e7cb2057e608c55a9960bab918341d0871a922c415cf4091296ce09026339211c0b6c2eef1e95973ac2f4c6f555c80105223c8e130d4f39881bc087b2e72f952a240f04b5115f495b0197d905d19d7fa7597e26ee6752e0760a43efd4279dea50414ee81f0cb1565e036165f879431b8d5845ea3eb2f2e7d927ec43f3a0e93903cfb88a0af4f33e53431901f06c9da4d24cea05af01096fb7c920c595f0211e17020d32871d1ff4ce67599179c28801e494ce9c638a3c5a1024813de6d824e48ba6a499a5db9b1eaafcaa1d194303222621250b245ad9a4ad9e2034f28d43dbcfbc405cfce023d433319970ea8373ce6bdff3b76c6de31e0f97688a5e8866ed1013be0eb006d5bad4eb4dd1c8935ca6907bfa4588fde4d8240ec5f85ceeabd03c6f16c52151dc0030fb568559529096181ddee1a0437790b862405a975db8d39e7d47144cf0378fa56c9c907b205e3fd5e126ec24f613da8f69b8161388f275e6ac7ae0c096bd6967658c94a87dd2cee4289d56bf8f6ad71520d84ccb1fab02ae8e42ff45bc4b33eda1e0e2d1536618146ad4602f6e644b03a1179e68f3bae456b95aa69a04d1e2e309efadf72b7028c5280dfb9f10106b08438801c0994e541365fdae9b44509ae3c1cffb93241f714659c92b7b5e360ad2e1581e1bb381319551b08f3741e995a09ecf12655bd2dcb06688a319ec81f1d81acdd9f4a8ace701302009a292af4bdf694a0014bbcf6f80592f0ed1035eecfb814fe196d9f9b094a28578f5fa11fa4cc3ccc7d0f6a9edf35b8cb942bffa4d0e034e6b12489489a711e7503926f85737f3d083f97fb1c765eadaad582e3e2f85191b7d1c3fadc1e5136d83c14376af7befb42ff2f69a94471e1c9078e9506178be44340e4808f422dad5e220a6aea4cf3f9c6eecee9298f246f846e890bcbcb171eba412f9b8760b9a32d3245719c68d99a56a8a17bb3fbc39d4146474a07733ec5c25516c888deb9ab26c5b882f77c8710cbc5228303f0d4ac846c99a7103e29c006c67820f09ec1f668c6e1531d599ffcccf109e37d04460ab307baa4cd031a6970592b3deca460fb99ce69a8f4610c7a131b4507b835924390a61562ce35cae3ccae0efb2f901b5cdf8817a0b0d017fb6267c516d084122bfa8017a276b9fe7a53cc5815819d4369e6bf32cc2df2f5f77cc3fb731d72459484492277adc9b997058935c847ddaeba0799181da36a48838e1ad679fb3585c3be30a997ff7497a47e69582e04af7615795ebdf040f9fc1f8bb33f16103f990470ec258fddfa41b8de71a6b582349ec1ac1cd9f3a5eec009d064920039f9297682bfbf4a6d9e099379a7091a5203de9183145cf36d7c4df3f48de023eb0d019fe7dadfa4f2ab70630674fa9d908232d06189dd9c1cdacfe3e2140848ddb4840412f9dd828b4a91562cd7d01fe68c8b4e1b108e808cc9e67611d9cf0d01820ef38c354045b0bee50551d8a258dd9364e81a729f2854dd3f4764107ac6eaf4476a5b0f810943874d77d1cd853854c7353c48d904eb404ee6589352e39018eae6502ea81d1faa85fb4d494f3b16982bdfba18620a0c0f35f662649f77b6fd2cdd70d483625d3b0e277c9ceb7cdea4bea6417d8465e4f0c4bb2e6667ac11d2d4318e811aeb489a65e79e22f29e8a37fc4124f60396b2a23b5f03763168bfdb260aab4ba1b735c6534b517d60ba443dabb9c27e0b2412c8c67f83ac5024ece060d9270a094aa26832f061adf6f20949c977ca8e105e73b112449a2679af02544bf05222373a83ca89300e0d4300f3074052c9d6f9d32db901e521b02ed07719eb7db2751f4debcf218d1ab5a8fa0a23ef9b0c965a596c8f34ead424eaa6dfd4ba1828707d9e89359d3d464e52c808979dcf650f9e3e7695f5dd35c5833d673b97bbf12cbd586b21b997d5545f233122c83ffbbf70d221afda04d054f55a4e3dc704635759be0ff160259c7c8a983dce7bb4431a1e39860522ae3d46b18457dd187d74956dd6b695b782109ce410698c75721715cdaca4a751502ad502d6d703c07c7a85d886bcef22dc3002f6a8004a87d385a51ed5a418f5427dbde9857627baa3e456ae260e7f278e9e1084cdfebb0cc752476916488c6dbe6ef9961f763308e65cf01269d20089cec192611a893f582384e3ea8fde9ee4d068e01f7d910ce317dbb24ff37e9d2c4ef6be1f959968707187c6bf57e10558ea283dff724f4a3228df48a3827bfd3acfef687830ae98ce9660ddd52da9148b09c4849b82adf1283d8837b8e455bf0dd08632980a1f323bb9af3a509068c21fa38620900cfff8b3b145aa5a0b23fe1e43782064e92d4882bb06741831434cb4718ea6d8c38cf0c72a816ea9766f6339a9b5bb9e57887e2d4c46d3187b4391997257231ebca6c2fa83c1685bb64880007b68bada48514248d6b4539988b101d89ad354b9755292fcb6bdd43857e8981b387509e45601e7158097f62f7d02fe25c4f0fc15353f3b54bb5573a78bc63c1bd2042781469ad360e133af33897ed9cbd4b88af28c47a4158f8b02309e3f69368b8912ba1160eafcd87e5396940316a52d4b10918a8a81226acf66117f294ada93cd0da11c6e24280b72dbe4185ab1ec4eaa68063071c679d031d790055c8b8f6aead2743b6f87185cfa4691bfdda2358b6c56b8011990c906c670a9edb11b50e365e4bcad81a6c4bfacabd60980c24e49e1986a5f84f0e7373a7852b0c13bc809b7973e0772c20f7451d7fbc385b0e3e0550224b884174752b8dec4db6d16218449e6a2dea4a2054af28cce4611de65faeddd16bdbe2958776fd9d0d6bb0b48c1d77dd562fb644489456145789e6fcfe309a15468f6c4ca9ff6b271c141c5bedd3f72ec4b8e628f481dcda0bc52ac83f2886d5dd565a09a0663ab094d5978e5584dacda1d7d53316e1dd93adba0fe96dc51a1de31ded2c78eac4f95fa4dbd7f7548316b2f7f18715fd4d8e797991bbdc4d1f7b4e6fcf4768ae2ff289bda0d58f2cf083cd93217cbf119e28d565dc824b6ceae01a224b1b92faa792141f87fd5c52e8d140350b52a9cc488bd0e8cf024d6b6de656533fcfa30a92d47b1276f2b14a0efba757fcd5c7426aaf72657d8da90570a845171a6301642842a14e9e18367e18de4eda18208485c3f058f3ae1f67d7489ef1f0f357cfae2db98dace07076a28cfa95d5bc2d844e70ef6879ba020418304f954e1024fbdf1c6aefc8d8dc356c27ce2d3ddfac9f203103223807276b75f0c71c3ecf6672a0229af2c4a9f789a72e07429d372417d35f80e67fb4894083a7c4d2731b5f65f6ccb7188cd3f75ede2f9fdda9d1042a4809b44f6bb91d38286c74b9cf1a7b94a1e96d165c7f72f1c81af870505660f79c43bfaf4232c9cba4d8bd313713ee1dfd56b08fb6aa74289cd917afea6fda2e371ae5ac37fc5e137597b8ce2ac237906a9b4601df3e943282e288b9d732198e62ea05e1ae582b3ddf00d951132ffea7103ef0e601506769fd8c9f681f01d1f48b63470c8d8dec94d6f2152d093959845f191be023e6e1eb9781b5727cdcd417d1697ad2e358d541ec150d2c6553d79ca42b46f660c3efb6afc0293b04f843baeb1b4b6b67c57058d3732636bef4fb397591739086564d0246f75fc5ee8f2cf3ea5614328f154cae0ca2dbf3f2b8adf52811ddc8cbdfc08313ef1dcf9921b4f47ad44f97792aab73e7cd8534894acb84347c40cfd4f51cc5ca7b9db02c940ff0bafe150ef065cefb3b45fc2430aef0d4db45f233a8bf71f01074b3addbd1eb61fced18b540d82e24a990cca424833a94f81bbb289a14d99c447d4479aa6c6ce353a6ccef9afb85b33ae05c395dffc549fb4128646a898d9f09e6268b4ed19828b0689588951b1d04e6e99774cf2609cff833a1c0fcaf669f290994280f88eb39a33147686242b9361f37996a4de949dee9e8741696b7433f14284fded5523428d420447162edb16826f1c64ba5e7827cbfe6e68c739a3c99c5d6d3580f55ce34ac50688610eac01c26b323b21fea9cfba9e477ecbbc09843091ad86dda85b0bd290b73b658cba7f1a35965319222ac7dd6306b99fe3ca792f3e505f99b7a036f2ac33832c0f3f0128c82994d79f957ee291cebfa19276f6962f482304f6c7dddf43e1253552a810599176a623117a6e89945a68a1bfe206ba160603cc8d90d18b5a59ee701ce2d9cb94471f4f493161263e3a746344e9c23cce1d26b1535c45738887d9917c1b21990402db614a5c3bd34d07674c8192e254501850745c9de7d9ea57f72ab2803c73c96962ca4f2dc776f466e82137c965f36b85d49f68d5472964cd9e9257b3da530867b652bedd08352555b709ffa5bfffbda7f5cdcd5d97e9293491fd9f3e233a526c5faea2a7b27b05c1dc3c556ca2bcc2ed4b2d47e8f10dbbe3801563b1814b824c8d8673c88d178008e80ee40ec6639e0eb62eb22295635a57e8bdec03cb4c2d7d0fe79af4450e6928e93ea58bbada3f0835d405d88ebdc9b644b2d1b79fc35e172a0e4b9d95876e0b2e41ccadf5265aabb0d6e015db96c522600dba5c77f979497c48b9c68cf7073408b33ef602e1ceebf285f1441c3bd81634019b8d62c20be1e4236aa0a30bd8fbe70e766f4c54681cd68b980aee3bbbfcf9f469d699b2c189f72ad28bd3c3b7e5d9a5dfb9924b5dfd8bcdcae46c256d68800b351460ed4a446a20dab68ed3c6b56d6c07d991f2828823d7038f4e836c35b931ff4c4ab1c75412b403670b891c7a3fabc27e0bfe90f1f3dbc5673d59744b24efd9d92d2271fa4e3474b31f22db6fe6bd9d43016b7ca71f677af5cd2329ca994daa0c2f8ff44ac0798199851e3e1a2088cc7647e572cd0f322ef0bad433a3559031482b94cfc757df13c73e4f6546906e58505ef77d96f3793a0372479c81e4ffd4c57011dfecd04f311d28233974006dc8e61c9f878f4395ffc4fefea469e745de01523c5f8324a0c1a4ab7c598036767ce789ab90a1af36f9e9c0e5e02b27d1cb0504ec7f274f8039806b825bc10ba97168a887e3cde818b11c8eefc86fc0c2d2c82a9e414eec450d5d5ed67f05d4a1c5c1c571ba524b02ae1ca88ea889ed81095ee2588c0b2ec671b73e97f0153a15fb457a44b0c9e0553746d999838ddc133ebb4789737cec129b7cf32f60053f420d3b1f840f6656ec3371cc6cdd76faa5cd3697370110dd6f7e26028e1e5018d88533743c2cc19d7f962e91f20d6192430fc6eee882fccde0544d51c36e74fb3e06f033bc159e983291a90705698458851edc9744077af5c6096b124642528463c73cfcfa74a844b8f2587697ec3d4938313c8a61779e07eb6f34440539c82906844579043add3129ad1331a09d8d824b6134b1cf5c7d0f56d7fed42a07dcdde37a0097f9902dffe6a5b62d49fead54e8b4d9afb7d6a2a1c1120311470798872385cbff44c9191e37b18e224a4fe39897b84aaa7fdf7a9ae4b39fe5b177694c420b0a48441248ac5cb2034a6f2ca045c553ce9d5d7777bcd7dc6b89a0cd61053433e730b509ed35cb41eadc76e35774606b4ea633adf6aa5dd18c1773ac6cf2072d07f359937362a2691ca16dddfdd3e6cb53a3796300bba0599d23f381e5c50d51f92d1fd26beca81db9a9e1678b75381a395e8cebe963dc7349800c14e5c49efd7f968faef79ff0ffd393d56596228c6fa62dd6052cc6b0c545efc2969b2b3b2206861a7d452f90476cc20aeb9731ad72cd33c3ffba210fb373d207fdb8fce9221f25f7a08c3e7e35dec6f5ff70504d8e6780c65ac778a491ad2c435d25746d1d1f5c35bf78c1913ebe7a56e464dfe61a4585ec02a10e278c32f596630f6fb1cf1acbdf92d23497ffa13f74cd02532986e75852fb45854202cec8dd188bbd3210b9fb6457c71e400ae2f2ea32c4c673c263d0b16f9e7a3dea7aa0e28d9538136a2636653543d498c5f25b350b401826097627cdb985a005b1f4d1e96bb3eeb05aa7fb594dbf8a1c0b46810edbccb93104a10b077228954f4b0398ab64db407d43c894952e0f903e21dd293397d152eb1e4559e3c71e7f0b0a540db34e414c1f2718f8be42f743f7cf994306498fa0b9a63c0baa9f6ef219acbfbadc0682f8b1d51b012180730473abb7b77cd28e2bc96b61d0be982ace5a2cf408837d07d9ec8c9966cab81e5bdebba64a4a3ca5ba9f56a05a2c0c0d66bee78f2ccc0f836ae44685d8195ff079068b711dd84ed474c6cabbcb35a26c1eab1f8fb01b7f3340c083aff61e02991f74025639ad46730688e4f084bdc878fd4e4641c18875b59e122e525806e8ebe10573ba4e6184db9d668a5706a5c0bb8ff61bce86f4427ea7e028d2be81d86a5cea8426d482f3ad962d0beb77f497581d1b6a48d99cfa69f841c7230df7351b94710101f8601baaa064e7c90af74db0145eb9f15893c1dda0745876623f8fc99d8e938ef4bc44cad78071b38ab456a5e3f311cf8cc91c799ceb096bb00f6fd86c225686ba2795667ba61acd9ae2b4a6530b46def55dc2a60af31e93253a5b75b967666a309db240c13e1099c787e67dd762f117ba315d78abe1717b15d6a03e194609c5b5ebc2843d8269b4104ef68eb4c17778a5954d9a890fb0ef78dcc9a97f73e4acc177aa1851d35c54f4ce02342bdf710ade750073d8f3d2be93ba0f60b6f8e1c8aca4b3b68008b798fcbf3e1c62650b6905be08253c9c974cb5fbded5f1e8fe4683f33b7ae563e261e29e63d75e644cc47460665a4383a3ed4d18d6361b0aca9ff6ee78e602097d104ad71d30295138206f2555b690f1b7c96f614b8ee37e334e18d0d0c990db6da744517ae623965ff5d956b63ff79b57ab03756c4af13950c641062da493ec83607593614f64c08066d2e6b970fc7f20b7f45bbe617881091dd09f08c0c49cb4928f4862bb937ab18be274a6c4c7e639c1137dfa779ddb86b6151974f94f224239bd763cf7a119d03c49b40e5616a9c0fc999d5f0af3bda05049af3345046738527cea0c684c20155f24a4a1cfc13a15dcd2e422361ab53539d989cef688acc67c358b8ef5057374ba2cd5cdf9f0f9c6e9a2360826ababadc19f68c78b66f696686800fdcbf0a61ef98633c09c07ff8de2c1becdd7addc9f3481512b3935493aea6f8d36ae5aa1a6e3ad8510c25afcfd715d203ceb76a3d48c028a810bdfa53c2e2deb1bb4988d06e14125c821100e37507facd90e3355808b7f9b65aeedc8d1ba3f36b89335266e9a844c5e1f8e7a5d66d86f2bb49efd557d2c9f0d7eebb107b17572413834118a2102b899727f114a32f1ed92ac21d60b4991ad0a8dd74c13ea0d538328e16c80ef2a48c355640a7fc8a745b5ce98fad3ed994cf1f2f3ea1e79e5894f47dd4ee512c43fd78ad61ef490d74d34633af897862c0d6b5c8cb9518c05821a6b6ecdb92c480595def19985d6802e52d60c83a3bc7030a7d9e33599a8eea335e4401aff8f41554969282c4b1bfbc21cf9a8c9c36b7e0e8da88a25a0bf3d8e1fe8c1bde1b9fd2a1c1965d691448608e44ac8dd1307330e6fcb4b2b07346c19bc72f7150a206355b6deeeeea2c7e9c2c11d4f9dd91f8c93eb93d2eb7827714c359949102cd048f96d42c59bf65e02072a3c530dc4ba06b7900f0bde7a3f0655ff4a2bf07e2889627ee8e4fb990b1365343d2377b567a04af04a748883e1c644fb81a09be372d8a5a89067c79000b6938e87626db12b410bf66ecb48416d1950ce5c44ad7c4ad09da6cc67b3ad5633e09d744853515b8ba62f7b585e7be525647d8960476f14912c6eed7605eb333085e7059579882b25e88dc4656f2a8c23f1c16e3d550ca0fbfe48ac3e0ff45d08fbb7f0117f5692dbe506fc7f0b2e38514044cfdec0f7b0006b22156559eae94d4fd213a212d620d1161992dba94ea6bdc05a0fdb23f1160106f9ec25c3190f9e5953b11ec5852cfa831d2bcb2638cdd142e758094a8e8ce89d2bf21e22a00a91292090834713ef105cb35c4ce593922d82201914b650a709eb9842d7ba4efa845bb445821937dcd53d8bed0ede69dfc0a3ce0bcf6d096afa0a1d45215051660a361bff3e528a52ab415a35c5168cd841e04a293b71766024a43890705af57b5cf607478aaa32c2cf8187862112d80130e054cffc16af830445ce11eee40e141324c332f63507784ee90a9a66f137f2a936775427220ee9bfa79302fe8bb019a727bab57ef196b2f988cef2385927d75da569e25084e0a4a3030a95eecb70816c72eb76a0e56014de4f29eef277f7d5cabd8a02bdd37174572cad3999fd1c6fb57464b4ae0aee4a2ef551f8a147d67284f2b8978ca9a1ad8cdc936dc5a2d7495adb39501acb3384a5beab78c920ae03b539fb96134d72cdb7d613b8d60283469505be49d34a9b949168e0d3eae0587b8a5875b374558b793188edec8f970c57803ba04180c6d8b2319f6feffa064dcf4391a54c3ec27014fc6e9b051ba5212aa1b30dfa31fa85793a67db8127213ce4adeb63006a6ee564fefc37ec452c52f7e3ad96a5e0772b2b816cc2cee7182e31b7f654f598fedb6ab2946d166afb1d2213454dbf73c21bb9fb6289c9778fb8a147717a8b62e3fe0a6e5bb8e321e5917c7be1007a3f69681b87f0710f20aedc9af2ced9c2d1912d917305773df88ce6abfae484d82641096fa7b5ab3a759ee2a2ba71ebc9e3996665a63045584f347a692cdd0b3c65baa7bee7e44d52a515046d0b1e5714e0aba80c143039e8fc07a8d83979efcfe6a014b3d620f59b348605994d67e8caac7ef4c35b16fb00405d77ad35aca585931d6da0efa89d8805abb4f281ca2672a0e1380f8f5e15f65b58683705ab1e0b93f15741639689a01a1cd730f4566adef662f4b50578c1af86b19fa9f87ea79ca80bb679351074c921283cb14be6fee1ad01586eee9131751a1b9d61f2384d5ce7c2add2087946f124d70b7c711922f3a13502c3985f99fe1c5e5e2228a62bdb73559bb7157623fb60fa98ac196e26558c1ee3468cb0ff53f56a4a2e2bb0f674e7e50e8f702f05b254e4d8baabe5220b3163d34b5e27247d7fa5f056e3b6c7e8e5ab08f0f4cff619578c471189e9a13c60de4fcdb97a91f4b047b08c632dddda8293d9d1e570c2ea67f501af49342f1741b10b6b18ce0ed9d3f2d7f74c41041d5483d6f99f7de5668cf2fce2b7b9b6be2becb6e789d9bd089acc52fb5efff2eeaf52e5a5e98425972bafecc10b6c42170c009c26756fb2d8284d4941b169d120e128d41241c3902dc46c4c304c011b60e9f08a3a908e6e4577a16b84756a6fb4e3f0a30605af0ed11325de5fd1a0882752d4155200e1eb302f25fff5cd24e4cdd85faddb24c4146c191d5eef3df8e0aa8637520b6c6c30dc3c5efd65bf0a188522b2577baca7e8077c3e2b814c39ab5acf63b9f1c6c67215b5832a5a7d208d7dc20bd6fac5146cd8e04daea3f59fd50f55398e2159a3dc95ca842d9033ad3b04ae20648020b8729c8ac46e5425b556372a02a6c96590aa0ac3ecfb03fd081a73977b9b24135d5699e7c715c2ff33fc64b7fb133de09f7e25cb82aa6567785c49314c199bc70e7944b8fe4aaaf366f4d2e5bcb649e9f5890f512cad9bbdaed370de913b7aef8af1e4ed97c345467f65290679bff824dcd4360c1ceaadebf8cf7a1c5832f8160e3d87e17ae031d74b46fac9da3e066cb907aabcbffef77aa655909e088df81089431a656199e5f0e45d68099b39716d02f4984f868d243d7ebbb762d2f299bcc0bb3176d67a57de743c69737f077393d98d629d120bcab0d3c1e11197911bcffeabc9e22ec549ce631d90344d009056348bf9338c311eb5a63a412d9c2b47db310efe5b0df74b7246fa47b1cf73620944b9fddfba4d9fc9751983769ca90a25428b0c7ea8e42d49c9e64401c3c3c4471e2253a9c79cc981ad5a38cafbf5d36eb3966a20f9f8e7cffc98551778988d5705dd414500b14ee4b487f40420909b4aef06e0701ff778ec1b86a6e2d234186bd9c49a51185bffe0af5a160e00bb895b00a0db7d361006502478853610b22e4290eea1f291edb8ef4efdcd590489595c4afc0466024891b946691ead4936364aef371d031103a12c34e9780320b5b60bf27ca53defdba587b059e339c7060273f9684b0e89c25ab953e47e92d864c6b191ed3dbf312bd89abf7d2e8b4fd03eb509e6c9cfda2bfaf01ba44ee90cdb31d484371bcbb480b088ea2fa184e5ee932a17918ef636150f35f0f167e9183faf322da01db3e11636b941a02e4b85c94eafd2eff06a140c52d45bcd283a1b87747a3c594f0af5b887688b024657740d636948b81359181ee13491d0e5142477df7e016ca5eb826dbbaef8f6bcd6aec5d8310cd29a807bd8f9dc3ed61f903814e113db2134e38912f2d28c805ffa0dffb322b4d16d35862b4b58796ad1a3b062e629c16dc529832eb59a4ec262ffcfa74a8fc573955a393b9f3bd514efd59b860b87c62630c10f74b1090ee139f007f140724f18efc9c18e65149b0216b71adef81a5de27c18012e29edabd723ae15a87e7a0d78ce135a341fef9560d03feb1e2c83ece49436fa60097dd319a97960776ac414c50bbac0b5cf8e580b3650395d558bc8380ae180f94661a201338ef8b15ed9f68cf196782f2167e84ed5b0a60fa48b89e7000c5a2e35bf08954d28316065d6fdf9bb8f1746ed02cde4e4b50344e3c052ee4e28eace985b6913476bc21ac9df9cf3321495feb57b93f1b7307762434a87fd6d721cc4b152eafbcaa54fba0c7b7b1778d24b54065e6370e21928101c5a2fcc2082a1053ea693698782b9c07812870a69e3fc511b198e397dcc537203a08e3f6a767c5b50afa5a9d4381ccf0de923af24816c7eecbaa54d440b75540b89de1e42219daa62aa177ddf6e45668a70ebb6d85ca035fa8a4077dd7db89d22bd036d5325b6a55d5bc6e43db7529f80b91f78e9fb61746080b2ced2cdb9af8033a95c1db4bf9c61f89f2b9644051920df30c1025a0f72b234ea5a999ff0a7427af5c01d1e8cc2e994f64f28209df6ae80b4faa44e0b7a029d734aee50be81776498867a624ee25ddf26a2ad803c197446d90a5396c3f4c15ef4bb1852f306317fcd57174d604ab6c305b50487ddd821727c94e8937448174f4616c2e03979deda6e1f771316f6df6865a1e201c81390b0c304fae547eea524c69329e8df83a6f1e706a2df5d366cf93cdf60022d92c4e4adf2937a16b48508e7aeb953d6612caa0fa856e6b642100652abc80b0b48daf83fa30180af630c817defc67766d8e6dc43ed4ca5181b9147523e58e1f197e9a1665b2fb5d95f22a6fd0a7c4ddff8739121a26a5e04b9af9dcca05fff3e369e4ea99fdcaf46a514f532f4d0a298554121a0e8418aff046619f79bca691f773f07ecabde507966196a926e427d82bf2e9c7258967e1a53ddcef2ad88fb46970d0899f7ae7edfef1e05e55dfffbb5eda12a82d08868009739fcddd4574e8d0c29691d1c8776a36dc62ba3fa3ebe180d33fe36f5364390489422f06b2b7034b5dc4b190eb90695ec06b5ac815fe005808561c240d7e4dc24768fb6665095c2f9e9547f27c2034bec19ba2854e7733bd8a39c3bf23ba5031175c872025c728d9e34f7e1705dc06d79a90ec362e5c762d15a9bd82bdd4bae3232a881fea20398ffd92e4599f0d747a7f48dfdd831e45cb291eb9cc2da48a0bfd25d7abd3d02775a4fb547b8293a838ed3fc82ceeb40df8cdb3f4a0b2ec882c08aa10b6e1bb4d90376f87d51b94661e96bb696dd1b756fbd900130eeede748a60a86d4833c3b68e9ffb044ae7ff9b995bda9498c7c9ca2a66409eac3ad86dd4eea84ed5d8ba83283b9ee7c2e6e2a0e3d9cd42da1c83d13ef135ef24321122c85fd4a7f1deb480f2cf56fd3dac3cd55d588c1114809894d4946b2c3e949b24fdf4b831fa1df47e18e2061d88181beaf011ee6185c985a273867e4e0bb84809f2bb86ab2d207edb39672035fb4b3fb73385dc3a0746a113b16da4fcfa3ef3a431c19a114557a330967121d510229b6ceeea68dc6dd8b02365e6e06503acf4065106324ccff4ac3479d7d6979e78905a6e8d474395b8755dd59f831010456978a1a93d42028fcc4873cc1b8b7811732dfcb7eb361e51aa028dff9c5a7b1aed84c0a5926da7d534eac5427a1d16b179e64a8ab3b979210dff1791cba143cfc4c746efcaa7406cf2bcca9fe35fa5c8d7194731aee3c91d9db56f6a655a66f501435b4267277a6bce47e505a91323d3b3ecf89d8545e239ce2629f61d4edfd9e3d56c674df914b888626dcb82cdeb8673e9a5388a938862eae4b7d1addcd16d6b642aa5b8d3ca81b6affb88bab8195fa111129ff829831cbeb3ce19a2c4e351dec578019b86291bbc85aed8508c11417d2f42e75a3404973de4f7016153345bce9bef9a1b22f612c97392d62b364a8913b9a186ab596434e27ed6667ecf0c6210148fde7e0e8225e07c8fd3180f179caba7349f70df7e8aaec321f79813b4d5526f2b1dbd321850323bc36253cc50caf8a9b14a471e46c61d89421e58ba03401e1f0d5941c3d966f8f872ca9f621891583a7afacbc8d23d39953c917496a39d8c8679d328da3b10166070312ee9bee7d086c2490f509df3ab2552935e15972b40bc3143c3f56f1cce36eb73b8ad812ce927d691d7c26dc849f453105aec6b388f423d77b02b38dcc64218ba62faf739e87516d92db4536f9c7ac7bf9d6f91ae82882bb56dc0325a48e6e61e1ee823f247837671fe21f034ceff48f57d37b42903e7512367caafbd8f700357d0c9c00eb50d779797caaab50e21d390b0cf4ab287213205091c7037202fafd68cc7c1f919622f4031c3c5fddce85846db540c2f7b745e4bec51a034b7e9b3cc8c53cc009b12260f2cfc6ac3492c5153bd326abc09c3aad786718a28146123fcc4b4f6ba5bce169ad341077ce932571430c19771569b55bd12f3a6a30f03fe0ac59263f965fc9eae1470b6c6205a71e8d90960d756c083146e2943859a54afebd6455df6dda30b97e254250588b9b1af4d864383ef7183b949dc3bf75a29a12ffb811b428616498e64da012055b47a045d4a9a2afcd740eeace6239f5a55ade29714d663e69d033482ecd8869dc5e2726942e535eccffbf92c6f1d0f96fd04c5d6d9329405078bb11db6fd4262e3e52fdc1d2d17b5c82df07e8ad3aa8b184bfec59ed89765ff0f14aadcc4a85e521bee4bbde9879ec3dcd053b53f69dffc7373437e0e65131dfa74c27c42a04fe9d4f0236d95223106dbc8af75499d84640853d99da55d418351a36be8a9f63f032f732652c8a3f0e9f9984e3ae3a423458cd638db70f594087586997dc3e2e25f86304bbfcd217bab29d791d93b773d67c844b4b54bbeb4b5c6764ecd877965157617092305ef021e6c9339eb861625f19b0b5d0d846fe4de4673c24e7c1407c4e768f658043ce0a9000bc623d53c97997e464e1c6f0f568bf0124ffbef64ce268b456ce4f592764647dcea5106719b315c1518ba7286b6e50b9194f685cb08109329c2d1dfa0240ea0664820116beec77f6087b2dd5359d33d09096a8e846e8cf57955bcc1a0d1a3a4d1917da6cf21a2a04235432e93fb6956ea14201ffff84137b4acf722d7efbbb8c415192ac7dbd5fef452da8133090e06e34a751d27d9fc97f42bd4101fac8b96ed2459c25ca75ae22f06eafcb65597d15c8f3aecaed4984c6b8f69303c8ccda142e3f4a438a8109c420b2faaece1462f4e2495b5480a2ee05ed3d1374cee6ee154e63d56f567af55bd3e7d8581c97d5d6e6ed785b949ac5d2cc072a8d5fcbae58946b400cfb960712a24349e12f7f0ef304f0c7660be5527c6fde5c1ba5dab7366fd22d5c47dc4cac107ce8c2229fe144000bd7999fdd1ec39f3f26556b73e1d31d7facb01c54a7299e046c601e02722fc2521b1c0687d549b0b2716ab574654223ff967a2c16b222ea25452acc423584672230317941b768d899daf304bcad5354d34f25d72759d84725152745b4ce51d28ec2323d600432bba58d44b87e9d9c83d1d3b1648743108596116cadd3473ec2f67ff249e3350a8a13e844866c5f2098f3410714af72d5062f3762ca38187e7e22f32fd0eab1e3e082640dff6713f183843d9a402f16fd3822ba40ad3a76a599ea12f88735b496df69baa5f239f12e02f064dc5a01f27f318f13454121c539530c200c9ad3a2a420a5bc7f3e9ad21ea299fd2b67f39da00feee7e1b8b222f6fe27df383fb055b5d430acdc31ba7bbbc3cb6073eaba9343fa61a8ee78aa1ef01f351b2f17b168555a0fbeeaeb3b3aacf5f4d6d26b832accb88ba8aa2b2f8b7e58bbef3d14d452ae92981121a1d38aed0511e3d08edde0d3938bd6f17f5573648f0bdf7411fdb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
