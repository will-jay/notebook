<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27565e5bf2d24e67670efded702e91d57db1bb846f4b89cafe0a5ba7568b869b2e84f3464db09fbc5ee0e54c020e2570a77951eed771d505d560ac64b877383f626e797591d8118602d8d5aca71cbebfdb3d824bdef55536c8b67e46f627358788759c1b85ccf7593ca1d364c8a56fb5fc4838bcf4b808a1ae2e603b3e0b49be367d109681eaab832ad44089519451cd9023643b20243da470ec7eb00e37e6841d1c207fc295597568a9edd3ece23ffb20f77d7dd31915a6cabd6c2028d8f1aee1ffaa4b49a2988313befd64897725c138a36546bb26593967d0bb0de53a86cd2f05734e48b0fe4dec7a0da8411ac5a15b5999618899e4c571171de49d0c12492de62427fc5ad61a954ea9eeef590ce820768c45f286442f5770d3579d236356f05fb3328592e1bb284c6f7cb3b0c9ba6d9f8fdfbbb9b0d2765b288a78e305f63bfecdd124be0bc6e0db285ac2b8d7702824db0199d292a6a66e0205bb55c9113b8d7833c2c0054a85f82fe90d1b6cd5e0e872eb1ae4b0bc14793ffd5f6d6170d8ebcf4bca8a71f84e3e72a0bf8cda053b33720104a54e9420400132ddd1c939085b49622ccd262d2073f04d8683025645494a5274488765e75feee9fed4fec7e20a6a052a00de746f640240095fde4eb85dccf86718adea6211ac8af7b28d235098efa963a80f5a5bbdbca17106e6f6e2476d2ff240090baf79beab300eadcefb85845752354dfd1bc3a1bf911613f57df312b9e52999a7873ca1ec5cdbae7f3fcd9fae8ad5fdc397471f32c233d339fe881ec08a800f5933885a2c1c937f682c4e4076632330de4d0bcaeb4761e6b3a84cb097fa1e481dc73c468eeabd6b517ee2772149bc9511c6306c634ac941e44f9a07b3ab24651b0a06238bf2f1b35bc61183ccb6e1a9fe74f93c75ff8c2171efcff86774d826e3e4b2c3c7d86b37803f5a7d4c1c1eb099146f309ce291c703263ad0c67db25f1d0d3a7e609b9e011cd558c27dea2837f9c9e8d30b9043ad1a6500c40cf93e33703bc4a3e51f65931a2462845d5eeff5096aef5d410bcd9f757e64ae4324a3ed45ca75a946f1ed66fb7a006810e5cf263842f0b317ca978b0f8c1eb56b20b56d48049c669d5668fd1433063d5531e56c1ec4c859ad5ab290e9c20a7a610abe41a24ad9bddca98d0a0db3c571d111433ab36ed7864ea5f765d91a514227e329f70eb7e5eea9b0c402851de6ffc9091bd242d8725cd3b365b39e2be3de0cf0f7b98c74fd5da8157a984cbb6446b7019003d016e4ec8c2479b6c3bc639f51108e8854d5e698436bf41c6e5cc2dfcefdddb208e1e27c07d3d6d1a8979cc85ae5b522738d5afc4c051d2ed68e7912f2564f69c0a3150f151f5ff1d1b032233dba4bfb109833dfcea72616f2455f4a6afd03450724dd309d116e136f29dea4d5abbcd81e4f12e0dec20e77948537a55ed269d2afc03a52936cec789d3d34ad254d4c446468a719ac6f0aea8beed28c95906799faf9cfd0fa87bd092c13114edeb4e11d2ca76e1d204e2573658d7206feb53925dcb0e0c188ebef585730b7671448f4d1897aac760a62fd3d206f57429cfc6bb2b57f1cbc4a35bd16beb5b6d9265a83f8b84a23b7c50912320f25dc838b7687a2c4c92198e1578c92df86dbc7f56b038cf31353e11dbffb053a9d5061105667f9363adb06869d41cf83ddf0ab5c1b536def3d02fe66a5068d2d9ad42599845c2283512ac71e0fdb71b05cce23217a47388c1d94c54921cb8c99d6fec80598f1638460dbc8361d9e28dc44a361fc225646ab0c35f93745796b7a359f4568a1bc6bb82433b2424d5209e14f1f6cf8a1d34a21c7b620e223a85627579b7fe8ec46843e377c61e95c2f8e2734f7542ee7d119010df9d414f3beff89b0f35e32f5071433e623efb109abc2e6b4062d039d021f1d2b29a12818d8698d06f86531e719c2772c1b85b736f7d70d1e9580fabadfc78a90fa822aa288cd350d19eeb6b19cbab1444550103c5d023426fff864257cd61f4a9316ed12e89163c58a7d2c58ce5267b309d96f8b10022cdd0491c374c27f6af8ec13219decbfa091be86f867473ad3844cca932f98477deab36c72cfa8cdbb6f2e0259e4713e0bd5442343cdb1a0eadc0faf86d8ac9906ac897eb80479c1ad52283a96506e76db4d3d15ae8b9f897ed340a62d0bd7f38ff633effce7bdec157b3aea24f3ea5846fbf7f31f3f807d629d00b591b3c321d5d773a324dd0d817c965fd4a0068e31456a45c4e96e59fad2b705e07b98588bb721c0fe4e2277a5024897b816669728bfd95d805ebdf87a9a0edca43deb81f99ed90063371a1cc947e0feea78966ada8d16ed1aecd835e8b635d399ba506f953a1744420cb211a10593088bdae27794d7d600feb4aefb11a1b296927e5a0266d8b76f5744becf703c9b40b0868d2b410f0cbdd968e845e273807e13ed65e9d6e0ed5eae4335e8cc89ba62a4ecd41a8fe2c2d5de04c0a65b8c3ad36d20bbc8be069018fdf37e7331237d0b044eb4ca7c3a33142adfe850e184503e381c2c24e36500c0404640d4cb09709cd4a56e639c7a835717c6b4fe7f8cfbc90952a67064db6cecd325c033f6e3e344011d816794c1bbf096853630238ecda880aa4254d989021a09c91c26684211654660122966abf3911971e1c7a3910d2d0ff5c109c8a14eb9bd166ebd2426f78682bbab4aaae06fff552b77bf8c6c5d3453cfd39ea2dad93c3a0a339b41da813afb2d7d056bd1f0d8a6e6e46c9827f0ad55571fe041f3bc81af7bca3cbcd3d3e812fd3d9752ec501843d2070032b8b84e2273bda7bed51962851380ec255987e2f7f7e52da4dff12b7137811d7807fbbbb52b67b1339b7ec16d6beef155a2a1b8c86fb629fd60191ef2752223f628c0d5718e92dadcfcc86f5cfaecc4c3a7a917f5b5d14fc70a97756e832c26bca3d5e80bafa5f97a59349bd0c5a615997a188e16ad0303e63fc67a351122f12b69a55e863471c63875c5f1916506a5fd1e5dee1fd7dc5adc06b596bb7640dac88f9cb649002192128493fa09840ec9b19cb92b198b7c161dc741ca95bb049cf7b38b67b7d2e032417b09629dc9411db868174f2896a9c83e60ab66522badcc5120b62689c2dd567c5952bb6a228fcc1cc24532d605dace81b76d98b1324d0168c46e7782818ed43dfac3048a1444cbf9c652f0cdb107ffc176badea85d054c3216c7891e61fac059498f9e0dce886e876f1d365cc2ccb4aab6321d6a2a625c0b1932512b3fc98dcadb5c954f11d29bcf6140ef79e690368b502235b1994fc5e0e84f594fefae467be2e9a5c10b9f654060754a8c760ea5de00ea9b9224677009009cc1c81f5dcc765d6d2a79a18686bdb6ff1f868be80e76afb2454cf542f331e33cc9af172068ced62a638cff4762fbd5fe71e29c2747bb680b0a80c50c7bfbd417a24994a75feb4b4282be7c2a16eb3da5bddfbfca70896485d490de8584e0b8824c4572a3805c7c28d4021f5fd2f051bfef4cfa3252c1506df8a8e14c2feefc5b84562b2b2aaa2223450bdb2d560bf46cf9e8dbdf002a7e74e1a4660c052c968d5ed1f4da20a5cc30725b8734bb5b6b1fd2983136a7cb0b01d6a634d3bd15523e0465a5519831b16037ce4cb0248e6cc20997d99b428494b7fba43158901cba17e76b9b0f00dce7dcea54ba76c98e4501e4aa129b5560878a987635ee4d8015146a6754c5ce8d3132835058681ee055f56b26025400aad9ae65fa156c3b1c0f22f5b902436c2ffdce9b6a9946d71f97a31aa7e08ef0a3d9ed1cc4d3f9bc61d604d18786c535e86131e27fc79da5049ace4bbf62e14953c3c573de233f5b751b6e2e607a9061fbad599e7257a8613620567ecdcf87bc90e4d4fb190d75516a8b117c6c89b0ddf70f84040d949e474d0d7418eb42b94f6729bd1948ab55708ddf4f82cd9b02a78b9204ce54aa708b5b98906be71e35f1214b187b802074136d99c67a60e7717d3b0b43096d8cc5ea6906ea496559c60f1ea0bf1bd0dbf0b8a735d4700c40ea9dbc2742c6ca8b933e4bd2f1c99d74cba89e991f03a03b442d1f744ba80fab4aa51c2a05661d4e59e70478ed22849f5607c3843a97529adddaa44c1dede7f47af59fc87ec4b6cfc9d07b9d94e3ea90649ecf43c4e1bc7fae1a1b67baa5e80184bae2dfc866c4c2d23c70a3815fa36cf72dd3cc08219075f2e9c2ff3020dcf9d8c82ec625335affd074482011e4815a8f15c28b95a76d8e9b9464c95ca934040100cd62e53c93a5c320aa6f7f15bc074724b052823a3f3df78ba77f4e1d1aef9dd3a2328340e0ae721423756008cd97e04f0c6f616208e21ccd5afa541a73d0218a44348b991ed031613dcf77818bca45737d3109ebfa2bb182e7f834b7caaa7e5a2578efeec0f9d80fa3d742b66ba2c4f8d8f7f6963b8b87875ac9b57eefa1cabd3a648bb6b2c31984278b3aa818b7b84022c969132c36e48d48837d68a679212984050c66fddea94b28782dd24ba12f898dd66c66cd3403574667f3d5252f63c684bb626f5fc0495470322f942edd081a1a0255107046d74e2cb18e79b26f0568ce6c4daaa0fad4cec56e5d965fc1394a94efb9bf03ff035779aa894aaaa83aaea52a53d7db916703e87e12ea5d5abc487f46915bd25046d275771fb11d28476b03d9e6eacc48b3a27f1d7007371dc194e716b9ea63c5ecd3b0e410ccdd357e2c2b29598b2abd14721e2c4e38fe877d3bd0da56ce3772ee3344712ce3f06f45cb4e12ade5137a8e12784dd944e0bd3edc5c4169a84dea72527878e4c7d2aee081b6f9fc79be8a1dc955124eb6d252d0fc04d8373f906d97b7cb0e326e93ba1a44a6e691025c0ba4c20a025731666bc99b31232217fb65307fd93be13c2228fd049e859d57e16ee16a719772e4c888a9672444c1958430957b120ddc289ddaa335798b5d9e568cbad0a00085c58de8f3560e9daacebc096687c888a05632b69fee018d5e525610b7c55947be4c98d6ae34ce0e16e9a03a34e483e19f06d792849e403d38080ce5e1241adacbf114c37cb13208771f599fb62571619aebf33b4e7feeefb58487082850f5d5295954c4099ccdcbc86c1ac829b58e0d12bc3b5337f85e2c5f490f9b51dc7dd23b24a4be53084c1fe9ca87927a25a9e5c39d12576c6d71fa76e5974af17c3f95f0e55c00bd4487d200c96da814369f692502d828a23d53d910ce63ad71fbc0d8ff431053ba747e7408670c999d109fba59642a430ca3c8c81d76e1e1b96c799e61950c73dc3256f4be68d74979aba92a680f22aa63734c8c381a128b758ba9c16863eb2bb5b930f1f0eecd22737ea0e3c0c7c6dd205064bde3a5ad03d74effee919632dcd5ee8194faf52575a72aac7ae52c5732b4bfe3aaec5eedf9792da0384531fb50440e87799d63027de0198fa0128c1322242ede9a426b67327b0edca40c1a6ff777ed53d71f8f94b3136ff03be30853ff599160cd6d2b6b459934e5a642fb03dd9dcf83ed51f7bb7b2ee84c666cd46a0c241922ab481482f6dd509c219183dfe0bc2ed919d290b831e4445cb90b7d0bc0a77b5c127419bf1122a304ee272ca94fa59917e12b9606365706646651bce2386ae4b3463ddb042a3986329eaed53fed8dc08da994acb6afdcd56136cafe3cbf9166d0d325dd506286fadad7d3687b2229b8f4d7db0cdb613cce0f0e991e5e122e80dd069034d7fa6be969f760cc4b14bc174ff04df029d33aa8780ee5e05eb8e4b59c398b155afc2ce121008f50b4a4b6adc9931a866949549937b960441ad6ea6850e10469134935ef012073af276d7b84da3e4f4fd2d7b6be0ce9b10d6e0811488497ca92643fdadc8254ed5a4851640c90434a732931ffc4064519c9362342b43c4a416169764b427c4852816e64da990a66c14e2397dd42f4daa4e1ae3e75b98fbc2e464293d365a0a1b5d7418afd96e5122c88ae693148d06b59139543b8139546b16dd1c99cced81e217498bcc7d9d7b74920aa625de5129ef3f907bcb2f706ee6dfb028cad3bd6cda08ed48c06cbf6270bda55e19a2ca3017c0dd96941974ecdc3aa05644c4e0fb2f36ad4b7536bb55db0d636accff3bb119c13fa3273844818c64c3771229f1863d477b8ea72972b7bfc97986abd3c5eea88da8f21808e6b44fe78be9c24c706f39d7252f23084eddbec45227eea07541a0ecd4a1d462a92ec6bde97a3d18651a0b25de960d51414c0a52c5f2d98de35c44e7956647d47a73fb5fdfe9d52ed4b940951d13630cc63c58a2a5f0894e2759571b08d59a3bc6b744dc2a64d2ea742be9b4d8e68d23176b262dcacf9dea2f1eb14df0b4af7a7eba6968caf9736bb792a2180cdf9f0de741e3bebf0569c251aacc2b2a0eadbc29c4447e6064d07f91b1407ec800133372d6f1f0cb4323089cfb06b1fc864490b1046a90cca4a22802d7013dc8ce7f4ea2bb13e68b40f631f42b5606252c9fe884375b6b02816452bdd1904962b19a3c4844d693b7ea815bed692d9e1db66fdfd56cedc1e7816857741bf9011491e91db9c9af11b8879ad9bd494e52bac4f7845434e43b8dd236383a2a1fabe781ba933400046a46cf5da539fe04edf7d2d23ad814abeb1182041f314d1c65f5445ff40d7df4667e05daf3fe36bed4520cf2113551a16e9ea18d20e15ddca209ff357c958d21ea34cc694bef9bf1ec2b72f2c3f208cc3b501ebe69572f91ec0b731f5e999cf4068e12aa398a3099d8c1241642649f58a6bf35461f81dda7d9d2ad26e3cda2a790dc252e2acb4859ba40f63bd13e40ff5b8e34621756268198ff7beb7b7d4f37c8e71ac2a125b7a02fe2b9e4b06879654a4dc8e235b29dfbfc90545c899db4a4b73b8b53a7b9fe11680470af0e5626828df27487e2746908cad7237f1cc5dec96c4accaf3942022270ad44635e619016b1327179bc21da88f12924c903bc584b7a9fe149019bcc72fb6cd35f25c48cec7f42d1d96c03c9cc7c59a565749aade3f52344eba06c5117a49b8104eebbf9c12790e7912670a1ea1c3417086fb8c5a406fc0f88508f2d2ee2e39c71fb8ecbe945677fa95e8363d0dc8fcce1fb84aefb6899d5d507fe9fb7980b2537548743a1cb225c2353f09b03e18909eb91fde51e0c6f9b323993f081d80183d063fedbfb8b3d3d5fceef348c8fd48d05baaea00fc5d6ca33245927568daacace61dc40d1e4767139537b8f022b56dabd401ef826ad7e8e90c377add0688220b35d0c01f48e7540055822cb201f78fbb5c4d3dc807d9dfb25e5fb5ee3c4e68b14e9e3dfa9b8752e53d5d1186bbf935eff12fbc34f31de8fc36c7ae54152525079ebb5d9ce04bc6541f2fc287d86e41b371dff4e2eb82c2946f15efbc25dd2232987f7ca684d5c243d74ed3d698c304b011def2a32a7a56bc12f0fc025900170d384db3b5e8215ba9604b45f6f27829f29ddabc914661812b15c79ee7543c4889676fe7544d3aa9b16e96352d8998573b17ffe49c8636843ba7bf679d5488a13e7651c23c0f30ab873665269f65998a7567069a8c24eac9ea48b9dc4b4cf5c5201175206d71255e96287045b8c66ad674f7c1ee9c43dc0d171ae72dccad84de1ef76e77d48331f1bec98b97f30b55512fe9266785a6c39bf4403f701b5d07f941e6fcfbed44ee06f3fbacaf741a3a4e0e0e15a59da279f5ba879f7f62ab753d92b94280df6aaaa3e39890964e2e289996fcd9d8d4d2fc534c5a65f2a913d67d69ce0c5dba41b754e190214ad8fc3039a928a5b78834671ef1ce0bb9067fa1329a5204bdf0f9383d8663539bdececaff4ca095da1561427729e6d9783cf5b1e4e49a852312c0b48de573a87675555e420c8e0a9439a37f988977337a80a6f6ba8c8863d24385cf2884ae5dbcc4e6e1bb6ccf8c37913cd9ff5e252add618740b2d50c138e1aac6ad4036d6da8c186f319457ed91e4a13fe9682f6b15b7a1543e11a2a9e83a3cd6f6fb10d303425b0e4d7dfe5c5dda08bcdb7ce003f37983b4d56a943e98b6ca604f553f8b8a80fe28abe6c4dbd2f4f7c2e6cf0760309fc1093c2647d5b275f19b86308ab0d13e47f33f798ef763c1e1358eb9abd77ae42571187bb7df620bef6978c5f0203d2c44a6798f99128f7407f61d1daeda78d0f2601d3ae60c8f91fa91a6eb4f24004892528931e5f57db73163cff4e764ca37071b0afddca673f5063afc614d8e70441fea4e723d25c09de7c916a871141ff00c17aca8056eb9d059cb99ee1df20ec30aee24dbe6790db93f832798ca00c10361f16227fc5cfa66182c946e62697b217b624003c12aa8570803b9bed644a1301393cc1fb067b9357b14f1dfe465e0f789939230b6684484acee944d91eb10385d8b262484b2219bf16f7a28c3a23fb53ac96f2b1f09fd9edb5ef1b98efabbe62a9b6a8eeceb1f450c73bf1d045f0ffc7ea58cef5ad5fe5833e4776937aa50b71b27d4097b4c20fb983053f9bcfdb9d82f9a056134603f527cc04d7622b1187f91e38ddbc7ce13565c5afbc392cdf94d4d1920fc887e6144d2dd302e3342ba8e98a6add2c8621822f204294d91eee6e736b900cc1061e9284d90cc2a7b6acd8d8e3643e776760bded203ca425c5bc001410bfe9433fafe430a70848c5ac46b17e59f4783e03184a881912982c668b45e588b02c0dbf4cd8fa0ccbb34d8b5fcce841dcf968c33e1305843c90107860c1568c00d128ca16b9ef949b6c1bf7fbf7bc32cd568213eac46f8481a645efb4dc9cccbbb69816c77ab99bbd2d35c9e1f4b44c9db87ab30eb168d119e0b6cf6d08e25af6d6022f279f71c24f8167bf2b2e09199c9f6b8f58852de67f564c02d1356f1845dc5d6008ab04a8cd2b3416820c87d39f97e26b3bd87a53eccf7e8ed4c97479bfea0ec76244da6996e2901917f3d3273b2aeb565496b11bdfd322bb89ff2fda0ab16d8715fc0571fcfb887f42eb3055e9b2cbf008e807a16a2a2427cd882b9f6c090f41cbcb377fef063e03c6e8e10461bf5125f5835020db0a8995477d12d17b1632f5ac2e1bb551502ce06680db2ce9d012488d3f36306b5c1dfc569f7cb5d69b701a573184541ce1ac324faae71f79bbebc14cb1a2063b5035e683b3f315bba94d4215300a7f79dfc7d9f44399a258a124e8bf64f8bd97552752344b9adb8c6302cceeb55701a85e65119846db14a63fff8ea92852c3c093fad2b0d7c74c6ec752308ac193281b12d282360b38b78870271301b3731d042c027f35a23da3d3feb6be32e6077182e0b071409bfa503c81dbc878b73d5fe475531f91061f135cb0d34384a76e2e881b7e7869c706211306bb0ccd06b0a6ed7b8372aa899761be173c4a71a238d2f5c3c154c772ba0de16225241942a6d6f8d2ba174569da3120037f4adeef19cc38c5f067639e681bda0ef3bd0f4eef234919df58be36d3d454d74ee862ea6cacf57f67fe816a17a9b9e9af3e1b965dfeb30a279d21d9729a5dd70df12ea5d90b9a00c882c0263cd2510865797f86699d8593e4055a75c551ccd3abb5fb30e01115bd7e768f809eb1cf9e21389d88214d5615c6d4d548949bc347661fcc413ca4d22cf862435e11937db12ab303739ee604a4e6238c1b050b637fc577b8d77bfc2b8d1366e0eedaf54efcf9b1fa66f4abb892348989ca66311cbd92d0640944d84cbb3ca897d39785f4e2369673104a427e927f5a1763eec7e9049bb88bf0d2188efe678f9ab6f3831aee41514a83f8cc947f0d7e961931bee352076cc77bfab9d53ff1d0e1da730922dd79397147723f4c5e405d55dae296ceba2db5f3ac963b6e4b4eb45d7cdc7eb58bca145fe132610e7eea3e4bb93e4e58039a0fd9870981408c926fdc56757caac2aa75f55978172a6e36237bad0d74e0b7f658128f6b5e98839aeddf15295ef432366cbde843086be3aac1acc9deb42e2cd9f1331f01c66c07848e6e9188fb3bb1454d2c3754c8f8716600f90b3ecc70b011453d0506bc9f92b04e597a43d2667b0ca3e1be97d8aeed5a6044b94eab3f3e65a74858018f88b28519bcfe93e2a9c047573d98e079378014a3d692f893903697d508917c997538cb15e5b4a9a8ead87a5dc34ee7169d3f05b723fdb7455452520b2dbb8860ae8f3feb183f15856811b4fe9c33283ca672a587f70465bcfca2b9a675a53f4ebb6f7a8395340af1447f7d24e120c32abe8fb03952b149dbb8aa8be112419806eb60d1cce1ba5b243e931dbe9c5319214c6d14feb5dd84a1f472a4e35e358e16c061547a79266c59308ead06d8208894834df6e86d99ef002ee07d58f8c6a4cefe77b0ec36149ba036671287427f7d507d3152f53870ace5af3d6a84bbfee2520c5ac5c994f0be74166c16576711579dea1ac217842149a5cb4bbc4fe389d535f714dbf76c13ef1014a6fc707f9bac7baa5e8e746edcad9d7eba4439bf198515bac8e99b4c71f965737be2e63678b56f067f6fa210ae51114f3f7ff385aa52201341737fd9bec9e82e34dced622d27960f8dbc343b99de44e80fd5f177bfb47be733609a4c316617e272be59ae8d95313295a23e32d0601525f363ee7678658e7e90649d5ec6613662805e8bc6f309e23e9217625af8e910022032428102d1cf68472f78cca54fd2212f5092ecbddc59be9443121f9612b055cb5fa5b5c2d240426d607c7a081b6049530b99dd77afc6a19ffe196fbe512b483bcea1d10c25a301cf9ec42a9928d80e3aa8779f1a4614775fe42b930bf111412f4fe211c156ab1901b61f8e84d7d7dfa9631007c2e1e4bf9299e660171bfc0d04c9ed74a8cba991de56ea6c38e5762369bac6fbb75d9c33d21c6ea88364fe5efa8ea9b520ee680076bc266263a8085c5284318c74e30253a650671b15a04d45b9fbb2652a9b61b4ab52ef3db24c53ffc874be151a6114798c09fcf7ccf6d71e4f6304d0f01f1e05725a5324087f7628f7fe0f532870fb18f957a74c24c1176db2b31bb57b0b496f22234ca0f47b0c895e9390ae5af1de6be7b2c99649ff16b0584aeed151c8e3df3c73c67fd6a05e2556c4e2058f5c8d1ce3594aa0626dfa700b1be1e7738c4bcae85d2ec67a741f651607b066312043f7f0a3a421468a2556ac0460f1ab10d930b52704a29d45d70f49810b228f1c45895e4daee0ccfa7a4a80cec333b3231b63abbf9c13c55cad09f786f970e9dd5c7205eb953b081026a162db1123b28eee58c58e498b21904ef2cd33cd458bce7ede0cdc20b73e5aba162b23e7dd35b96c10a3fa2408b2104e783612bef726f1ffa3bbc8f51feee6366ae43fe6a76f94bfbacef2ff5c71c72d1ce9a4960ee001c44e8f29b3c38a565421b238cbdebe0cb93556130699598a7b6ebd3a97678e2f162269f24997508d7ee3f5d02a1fb8876145cce15dbf35d2caaa38fea6ff064ac98b40aef8d34723426043e036cca5db2165fb53ac533e7d0ba16a595599faa0075ced12335467e6fa8b224cba10eb2ea588d72191ed63fc7d70c0c8d1cd74c33520f6b3e82b562fb823c75ac47fe31416b722474322d86fa4228f96db6b65710db1fb87923cc444b94a51892aa3671a1245231077ca1d2078f19f7e4a09de0b928b878bcfaa6ebedb374986a90188348612b15fd3a842ee37d000002576109f952b45a5618f389f3eada85fe6f76cd5127c6993fea31cf0481a7598af09fea47788848dba245be4e88fb85e783a3376db16738415449fa422af76ab70602668704bd4029379483020f932f92e5f07bc9daa130dc3dffe56d845b2e9ed95b3270d8fa231d11a72829d20c8bfce139c0e7f1286b53e350b56e6039e705d4f6c04e6130cc1d2119a5e36360bc3ee391dcf5fc8f6dde097fad580f992571fd7fe1e4f84f44b914efe9df9456653636178229d25179dd19c995ab3371db22909a9364c7c83079eefb76aa05dc642f4d03727252df302070b218b28cf7f8a3c73045a1570a33410af7995b61259ea04521c8430d6cdf000b01acae9ac371ca960a7d33bf8e7e8962b70988330143288d112ce7b529869ccb7d0f7ee0b775600398011157a33ec5f6a41a2f959edfafc2e01dfce0323b4bb7fb15b082e41235c943eeeacbf0583a44f069be4abd0e12cce412670673a31d8c5bebdde70ea76eec23f211ffc99c62b5ec09179f417c38b99ed64964a1a40f857636a9736fc7ac2e540a3f6ff2b383cf0a2a2f516206a2de5641b44aac07b91744853234d51ca0ffa3986df4c3ae5a96583d6354c15453347d13060ab35676a026f9cd42babb316e98c0870f8a9df8448930b8f0c0bef7f9ed41f8c594781b5a6801f8d0d952f77170b02d9637cfe9aeac8006f0419cfd158cb0f86837791421154ca6e2c256e7eaaa8a1abef3e9dd73f0adad14e8f2d09bb93b64e80f3dcf4dae94e171abe9fbceb241165e481770be937c91e635bccac93fedfe6b0281c72cac3b5faf19405eefe516addf56b88096989788a92e0e71b7069103501bf564b24b65bbfc61230a11f39487356ccc0d32687ab6338bc4e3909e797cea2772cfdd478e81a245d8f038fef020893cc4b73b9bcb3662a64439d81a2700c4bf712d657c9702349ff2bf55b871530c5c1846a2fdf5cde200201ef9288516b238df7b63f06f9d5afdb1ba7ef41476a20ff478015bc0a606ce9e3078a6e35e2661353eaf30a364d5ba51f1edbda1f5814532d7bbd0fc3904e636862cac5086dbbdf2d91d332a9adb412ffe0733298b82b3fa7a2682dc9f9b2dcd4337034dd8513dbb5c1b321dc02bc87cf300541425bc556039b5f5c37c6ee8dad81940fdb8dc0da1de746c4c8b4f4a55d402d44f67ebdcb17f4136d75db04152d7d6f34bf0c170f72088ca4694e2c402110ba544df4d3ed3ef0ee300f7cff7d4687a623b920393f3360a2a0eb4cf8c9188f6dfe5d3ea21bf71ef079cefcb6ea5fdf19e858482d18ff652c763a080c2d4ef9e793fd979448f9f93c9b53cc9045ae72848c9839228d15ce20891720d20c4c9d577d72f4a89b1614a385cd899ddb09bea25bfa24d6708aee667e8d9c13ea7c6ebc065f765da51133c0949275a2dec5193ca992c873216a0d534bd21b580e6bf983e903608cbf22beec52e6f1a0d37f6e33963aa9af2c5d615448bd4c3104da8906fd3e74e6998c7619c5554bf6d70c4327e3ea91d3f9985a9d169e6d83e1423dcfb663387071a5adecee5f79f28cb351557885faa82f1daa851190eb8b2861796f6072030e0d8e7b4d60af88afac49a62ff7024944ba470106928ddabc7d0d799dde57c7220013e832b952321fd5b454795ee2daf9d7431686910d587e2a78b9aa24b70b5af763458b4da0e67ff12b9ea307cea2afca90228a795f694ff35e8144df3e38f380ef39d0acbb26f70054fbf989a9d0da69cd9c3791b153b107c444b0cc5c542506b0d7e894ac8c87a4c7e5a560c094f5c4e01114d92c4bb2daedab1ea78fd7826a005b05c9079f067cc0e280296e4a622c1fd592123799936407d5984c7f2dba29483b87c75f6546d09abc6bc3ca81c5342920ec19ee1bd260ff6dcace0f125a5df9e53670e2eb4fdeb67b7263afc4b3bf5825d50b441abf4ae47a0eee42300b7280a63e1fb374687f0711d02e754a59ac0bfa202aac7bcb41a0a7c0a6542958c69be1b09d61387a966062ccac71945fe6a24b9a3f9f907f2a57eab09f85572af317146daceb24914a01f48b7fa0e2cb77691e81f822253919a9bccf518ad567d78ec6f4e0fe8331d91ada336ede855119a71cdcda93e2c377289931c06c09d965bf924c7da903d6d6c660e9f218827c1a90314ade84de140962524de6a2327e9fff816b99d2fef6e8ea392968408586a76b226fa8a9be345d662a2474743c24bf9abeca9d882c8c5e0ae5168cf54db5d6b0f27e951ad7c535af3af3d0c96364a7f55d3df3f2ad02d753d68bcef46b5400059c57956159bee67a4071330f53006685b1cd85f30329bdf1b72456671949f6d6e8709d0f71ad6337d391ae7ae3e901af7d0abd8727c128f2cb3235e1a0a09b54757be51c7cbd05db26879fd51d0e35cb31d7aaaa2d179533f51db89148aca3a58bc9d3691f286cb242cae6b4275cae6d521999fec739129ff7ebdba9652c97e67ec3109e3f6f753cfea87dfed083c90c6bb3e87365f0e59119f4876eaa45261a74f48b6fb86f91a09e7b5a3fd38e7c7efe0039a51dbf6a9099febe99895ae669604800df9290d5e06e70be249508e44d9efeaca2c00725616d061ebe0c4efeab3408b9a7e817c605df034decddac1be6f6756dce8da36e788dbaab51172b1cdb6bf86130bdf3bdabcc66f4cb4c3dd0dd4c75801627431806c5ec76ea3f959cb37b1e19e24e5d1fd0afbe4c485ce21d4e91030d256f78a1713ac0fa8e82a4b18ac72edb96d9b2848d7c40d9c51616d7a87c1bfd9563d59ad373dc4f29f1eef6a09fb2b15050078232bc6ae0c123bf9b703d851c6ffde6c38128ecfcc64bf0ade25681cf28e390051b9bee9916b10d5aa264337419d8bad8bbeb881688b3cbd27bba51ecd2fbda30581836498e75dca2645045479f5568c50dfded4b0153083adbccd272976644ceb18dd2b705aadbaf9028beb6a339aff36e2d79200469124e96cd1ea2083dbcdb8f601ee87d6139dd2a8f913739e8b558af3850e46ea7ec907324a250f81c180fe4ca0612156232f6aecb491d11516da31ef72a55b25723a123a3515691af9b089e98e917a953b8fbac0d74940d49cab4e7205ee5b22ea343ce082138cbc4ef0ec41ba1caa336b063863d6e9a53701a4bdcabfa3a0d03a9175f9523468f7b026fdb85180b492bcc8707fa4da5de966f68f4d83b1c62359e644891e478c642061fdcb5e55d25dd975bc55c1553a1152de04a906722f5859b1128dd5f12350bbd229399db7ee71b8f92a8cd362f7ef40151281300927f3d772f9ea5bf65c2189c439db5c429749fb0a38069c91aea52f735d12ca3903272e61d5bd46bd85233cff85fa4dedfe6e8dbff34ce348e8b63fea90a084aa7da3812561cb12ac5bd2c56574d23827d3a191d12e4338b054a699de79224a49a6b54df939e43ee5f4e6f55fd144070799fa437fa184d04144680b773b88db6732884bd203376ab0da0e5f6e24621010849e4008cd176f5aa16fd626ca9754efcd64bde5e5aa1aef70759b72b5a8d08b97de5a5c61a48267b65dbdc4263e3020fc29aec332647dca29d49219eb9219ae89a0a175b052da121d30901271f83d2d140d40c291068cd490ef990c29570561a4c3f525311a169d5d765ef4182af7e52e4e308f3019d5da78f13da642db91dd837336b6e20afa55023e45eea2c11a002e8081bbbfd0d4ba17addca55998513d058a1bbfbbca7389e0d59ecbfd9c55d43746256214d2789a5cebd26396e392626856e742e38b8b787d8b0b20c23a32695934afc6b3258019fbe27d072126bfc2ac623d5cf6f3018dc1cb3803a19cef500f26364ce15b71d9454b53eeb19c86843a358e6047a24b7aaa47e8e55425770ca9a21c68592d3d3f732c4c02f9a08e60241559d6d1c301f95e4aa3768f9b2ad2cb3bbf26adf890e01188cd06a163b0ee5b5f6e9803e458288bdc2c55079333f89a873af40aebb0d16c800c41d3a456b13a13d6933b9a414645b9b6661d13db434805baec30c359ec770dbd58ede96b0d57033c005ff840d26b68e19b3cd3ee196efe00240c3175a811dfc3120235b2a5b5415759469e423a7a109121e91edcc76ddd96e21377295d9f92b4b5b59efc0cf40883c065240c11d3181019cdb5f144857b1ceb1c5439f92e8d54a5b83c8f12262d4eca1206f769cf1fe8bbafb0cdd8e39462c5a8f655a47a540108e5fdf78d07bca535e09fcd9810c02958146e14968e084bd0b305d8ba8fed66bf3a9ccdd7ab62ca4723ad4b0a35bd1c1a646e8f05cd3d753f6462f32e36db15aed7261954da652e5857b84da2d8d6e6faa549adbbbc040b4e483bb20da6ef7cea737da3efe2083e75300e2ee522745992a66bab52e73957b789c40094157346fa4dfd7cdb03ddbde303c58afe305acef46ea118fa5081748ba83b3276fca0633ef63220d69ec2250c6055828b0dfc413319f626349126aa9db6af792d00cd7420aa09f84a8649e3380ab4413b2d9f4d0125c31366ae0e77859c7b8f4f44a2188e54511b3d2be41588f55dd73db5ef8fff7df876860d6472e49ca029509a7a11ddbee4d29b558902bf5130ce404997a83022ba67e9461847792e5891a705fd44b308f7a19b68edcad44745c7f2c73dcf008efc028d72e9e646e98b5dc67dd5cf6f64dc634a159a5980f1c0ae7958810fd2370dd955280fa03e01d6f002fd122d525350769351deda8dfcae4f67af35aa35ba619557fef06ab42b2bed2d36379922d4c3beb44011647fbd546e9aacbcc448066f61a8f3661aca229554ddea6c35824845f5c64c74b51af1eab49e7028122a7e264e4e8680879d1371be1606dd20b8098828ed260b1f2565539989d66cfb2bd7c1406b2c4065b09d2560e78b659b21a3847f7d63dedeab9fbdc05aaed517a9d93fcabe6767663ff36dd3afc7caac14512ea8a3a3133d9e4b21f890de636fedc88720e958ed572d5b9032dbdb60db6b6f8f3aa3128fb5c3959b8a8df9357af3ec42c5627e01a6910a4bcf6a040e655244173e2e5e1238fdf3b6e72cb2a3e8772e53a928d717e481ef6072c050049477a59a0116b1c83a69cac44c37651dd134b3da3e32f0327c474037620fa432d90f6a756c08f23cd5104e56d824ca3c5a57e1a47d1f3ca5642a658550cccfa2f89e557663f3537f562fa3e993eec1571a67c826fd54e75a6d571ac97dc722e4ee16485c0a6e41350ad3fefe1b854d21a674155892224ce17101eab3cb8aa0d24fbb15f246a4d2b1b477c0061e6e4fa5881bb3b247b181b59127367279fd73580e662370e56734c4c04b1189986d29c19ebd9b38def6f19a672a8fcac6960dc0f403dc09030bf416f0c5ea3d68f4260cd00de75c8abb14cebcc44d9a8daf5f08e2e2f3a9963b1cc90eec5dfc0428878797d4d9a949de44c613d5d47697d06b050edf58cf0ab5e4b32a977b21cd0268b579ce246ae1b1dfd5d8e8a80b0deacd60a01f0c08bacbd9536d2897919e723d93b24425f28d5609c48c6cd8cd3ac32e10750225752ef45e6ff04c3675504b31097dbca246c81333c8508904cf444197f9bd75d5a192aa8a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f1447743613fbb1c65c83d6863ec1a1b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
