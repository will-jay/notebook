<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6acfb276b847e4a495a84258ffc85e2fbb7c15bd4ecf1d245f970a189682d98cbe87f63f30271338a584a285e1dd37dfedd1bd10a6766f33135a6d83d06248222cd71b5d20fa46fe03d11ee54bdc9ec99057bd3a9a919ec930ecba2f97a7dbc0388967630c1f798d80b7e1bba22c664dfd7b50016654653af94088d8321103510aee484509eebdad9cccc3f046ffc56f67e0bf035589ab4464857f08e7e337e2411ac8c080fcd7557510e38bbc9ca2c89b4460ffa0350fb77fcff0616af80c0c07a1e130670363417a443d6adfb0200c5caae5627f085a7bf133115600bb7cb08fd4a954817d513ffb1ff80c159d7f5b9c1c57b2ec98252bfe94f82606fb43add7bdb5356aac093fae9e6ce9374f9c161cb0f7d6093139a2bd4bb7f9cc388d9ad579526d92320f3fe927b3471b64a922dc0084f6078c96c4f4c92dd3c654ec7ba910e6f8994b2db800e13ee7d0aae6fa58a10f3cebb58932c462b227f69f7875508f8e865ca082c6d61d7fea0833070f5b8996389d09e6dbc379b367f0e92ba25b0bbacf2d4d628f35076fc1393bb3ecc5aca4a96704f2a09551a0e2384d597c16512273cafa446885b8315ed75e142517ef1004b02100f950b807091ebdbc376aac26f99ff66fdecf395daccbf34ad64c127f97e27bb43a6f0b6d3b37578f32145ec801f24efa3bcf62a07bd201b42651852b1c27a8103988f1f8a48d7e1ef5d33e8b737321992cccbf663627438d4d0e1a7a3b68470c9b396c838d60ce24d59cb6131ad5fd60a1691c60fd581b011b8d3b2e662b2e0e4855ab657f9209a6c56708c8fdc38c916bfc7b039fbe8782c59ff24cf8f2ee741bcb7e2d228b15725a947af46a2aad42f087085bb51f85cf5036954ae14b6d37fa17a6f7f732f067c01ebcafc6e82601f89323fa4079642dd70070087d843ea51036940dd0a9c844e56c0058a5b8fc23d8f16c3a4c2d9b3ff2a40d7edb9c4e0c17c02a7a899b3230ae2dcba95ede5abec2201b42a1bcfb87c99b1ce3aa21ae66be5a178c2601a3bf0543d4bc779b56a10cc57cbcbbfc93c17c90d25fbdc793208f17478d7304e468a717208a82ccf1c62c7ae36a34d738f796b402b9f77aa29e23e04703ae1eff42aa38227ace003a06cd547de180c32302b8df44d6108a2f705c2d8dbd1d8946c140003ac975707171b0c2ecee8eceb44247b98e6ec1822c5311eff85c538e772e62e13b7ffc241ae0613de5a9a9d0d869932d0e40604bdd7801e21f12cfc1c2daf9086163527212a26a924dfa31d7ecb115ac2d0e93b81f68864e5f40e00a57c5a5a5385894b78631158d3b761200dc32442b1f587ab91addf8511f5b624ce2eae5cf11e6517a12990a8dbc0aab6c978035ef1189f2f7a6b90b78546c34812e120c1bf77cfda951603a20e408c244beb38538731b2e026abfdd13243fa2858d413c6753adab8519e57084b9fa4dc934d96e30c8108f1c85315c0e478c8ce270fe22241c36b8c86b53e0e511b44326223ed789cb5a463dcfb97c84b24abcbf27b1348fedfa40cd59631d4a2e3dc2cb439d41c0465dcc1ff4e19eb25fbca09a72253679f3f03ea711f1c9ba004c0542da01d869aee7424c879ce8eedbba9b275161788d98501ef9057414e50b9061894f5c40f5085fca23a9d62e6e82dbbb62bba65cbdd6a7df62487fe8f98fd7c77c265896e60d32fbb34bfadc573d49651675ef891f1fd15e4ee3cde7bc47dd50c60e132717d055507b0e0fce1d42b04cc12648c969cd290ed3224b0822e817bd035330eed2e65c3e04e6e47c9965f2ca3bde5af945e7639c2c063519cf2f4a0b11c45751bfdf8f5565d872a64c270d51e275f7bee30356f4f9c74bd1127024f7199bcd6ddf2fdceb52727746bc05f7ea64ad1b9423718d1e041d6367762386d68ddb4d7f2ca45e4d8b7640f02ea99be31d4828cf79cddb0dbe02fe552a71a38af71dbb3bf3de69f83893622d054a945d00c216576949c63180482f5adbbd25d7a1af2425aca4c29659e27f81a116525d0a7198a46db543452513dd03c818745c6b75598e6b4fbc7f97bdd756a56c5b6c68e374eff4acca7ab8d81639fc89ca9db38739b053fa506bb443c5e682a3b4f4e975fc74416df08ec58e20553c2d848b2c024e43ca1245d163d371f95000ef9904eb879b0184e4e9437b9bbb0c835e197b5f41c7b3c27adde4b957e10631883647135b31cedb1705e90e6d455cac3843c89ef2d222a3ddd8641cf8a4edb9c912847c0d5adf8f4355e0a68911a81b881647a8ebf0a2a44ba51727850a5aabca6fcaa52c9319b6f8e4903e8731abb13464e8d68b7ccef4c84a80a43aa98e0578cb32f524eebc81465b89985cd2909ea44dc9f56809ee0c7c8a1789037781cbb0ed7fbf83745222057eedd82fbfbcbbc001b4c9c635926e369c2860662c2240547f7fcd37f17d158b4d20d65cd9b8d152653f782854f64620220959ccbf4e66a14bb92d9d26fac234550ea35c71b470914a4ee8327cdaea93b2306564bba95f4c2385f507f09612e7decef024649607b6b644b64883f724e05f9a7f805b05a62f60d735c6e35263d94b37a0c183b81f92cef02b908590dbda53b18bd9c42bd192c38965aa5694e0af9d27350ab6fd546070c9afbc42608f2ecbe389f11a942b1ac0b927830f0a30980770c02413ea65ac2838b4cf0f6633a085d4f37a1eee59b34a00e9286e31acdc1ee47c8847526fd09a36dde6512cf0b3d95a0667e4feeaf9f5d339be638e92493acde67a8b57fd6b80c5c76a932496f768f52d3540558b31b60064e823ec0a52395bac5ab7ab31bb93f086cdb67bb3e97e91a0b6dc756064eb8e218cba3c69adb6664a48e17b4c733811cd6a54afbc7570160236346cd659d35b7321b4a4e51598a22b606f10d00f8c8c655766104741845c197a50cb95b25adbd4e638b68390f38e4fb680221d5e8351d1a4f4b4a9c4da831473b7aeb9a3c40c399ba0b9de6958fb946b8bfccd5e3c1758b82ffe3e85f7182649298854036cb3246d6e4778d8679b7a70ce05cb5300f164b48a73a4a174417e113631eb1165b0d95e7544c2a5a59d9294c4403b133aa97d1d295902d866781a2d569e436cdebf6220a694db99f0838ccd7b2b47cb62df41c1f2d819bf3f6b0a2c4070b2cef91c10b8fa09b74609c839b4f2b9cce82a463457d16b858bf768512ae3fb96c7e0e9fbb21cdde9395f68edaf5fd588b3cb8e2551f98cfe87316badc2568c734395a39b8dfaa1ad24a53dbdb660143516cfb344eeabf8941773f8dfbe2cb3073eb728bb9f9dce353d6c49c1abf998ee3a01cb1daacfda37b7e25393c2c565f783d697d3ac53c03eef8d7233f68588dfaa6b98d37e3f42c0a631e7efc71455c0f2aac91da1295fc21fca585c23fd2b0ba8a9ddf9f7e6cb2004e12339de65d18907515c9a479351ef79d72db0c9e473b98fbce454c4447b23b51b0fbec2515ba137a585f940a7a2a799abde7432029933d21eed727e970318b9af3dd31df3cfdb9f9c722058eff4702479c0995e003132766184d3845241e4ab807da1d084e04fee403cbe2518f0459237eaa6d33458d26c292c1e2bc47242f00431d21a1261808da6888a3bca5538b8c524a559cce385bd91e25e9dfb54c94e7071ad0f05659e7d836da57dee6357ae171f64dd87c5b36318dfb4d03b20a81483b7933c3247e1d98f8d425f669d1cfbd1aadda902c27da85d285015ded66248f8405d1a7b722b993a70756fdc143334c01209dcb847ed2ada8c66f0d9bc65624036fe0f3bd5bbd4dbf47e14e84e956fb0aa93f9a58035b30ceab5281e8478468be21b86269038e954b00c33757a87bc1b56b302e251c0488e9a4412566ad6f99489b9dbd8ccdcd631801801b9e88fd82c2a5411eff1888866af88f551dd438e584c231ecbe911a57c10c1093ffae4fd4348ef734409f32f0c7277f2475d990592b6e36e9d198a095a25fe3a76386150aa3783ae29aaef6a135325976329e2b9d09e9f525101bc4ce3de3f3fc9de15c36eab40d9dee420eefa45c1e75d169c6a4cfeb70164040fc5eba6718eea3b301df009490370f787f5c39538ba7a0f1c2d24c2bbf82f308a4f27434f4ce4e2bdda2538b308f802697bc4a42bb4108bacc5536fe0f221f1061973e4bac74e48c413625eb749fb5e81c1640bd51844ecb9e847fb95b3b6b757679ca63f5a86f83d1b0134539a7ad2d29980a1b804e4d475b504bfdf76d6294d20771270d540cd2783fb1ada2f41095a12e66c0f599fc41458391fa5b19f4a53f6a762c1a7e42b7b59eb727ba7ada4d0c1655a48e34fc61189814e28f48bf2e1d1fef0fb00b5b20505dd39a35225cfa2dcd2d1982be01d0880df0a7f125a3ee410a1b5b22217074f9da203a1e1d2849be0ab2fcb8a608db3abea4be8b5daa40e5c5fe2acd0a9bb28b9b74ccf7d993befc106c31d42cca1816df6547cb6f86518d4534f88c20cdce5392033a06386157f17c5fdb34fc34e70be5de45c4702740b2ad5546931682333b08acc06eb43a5848c383b802faae5e261ec6df46998ba2d0edf62acfe7d238a10760f680fb21a1e3a0318c7f7fe244f82a99300bfb842c0a8c232e50d3b2db62cd19288b333001ac81beb82063eae064bb9bab9cd9ccd7dac62478cf3e56eb8574799e8fb7a23327fcacb69e39b8411158cdc4f79c712329dab1cb4809116a752459d56d137506fdfddc346259bb54d37739e1d8f16f6eeb242a5f612ffeff1128911646636f890c18de105afb0c323228ee581c9e5a4d8eb7dcc0185881a07915d88a11f20af25287611ac9243dadc6bc576932bbea52eac1ad32bb9a6e6cb258fcc926c087d80b99b781ab2062fe5221f45cf81feee5fab90a14c996a8461fd32e2eb4e79ed2378f8ff536252412a9b3e47fbfe31a0fe99c68f8168489d9ea49d2fd7c596c83c50dd8ee6c02c176b21f2dd0e4764a7257d404ce2717ace84f1d8fc5154ebe45ca4c1f5a5840799da8171be77195e2aa2632b0fa0948be86d6db9fdcb882385eeb9382fbb523fd60df85ced34b7090b8fe34ff0dd69b503cbc83c741fdfb5d642d8fa90dce16dfc8f7473e50095e7742bc9977b71ab9b154a6e846dd5c36438460b7e78a6bee3271a2b03ed28fb68c07ad3b041c9daaa377045757935d0c09bb783fd409c249b18d352fbfa16064fc47605811e9671ef54addfa3e2261adc287bf804ca7d225901fe387b9b31aba1158d6cfc3b63712521b61e03749242a33c65e3a34a3e6b10063ba9de3e78236206b73fa92d4c0f58f550b35334d5fc8c1d32252d170c2baf4d42c11e0904227e1303f5305c7cb674f7cd8d39bc4c153405493400b659af499c2d386252d79dfbec3b99156b541564e07d5d04587a2d241c6720155e5fd88b7fed69599ec290b1e0721787a2297c2b9bf750bfb348c460a0867893aaf055b7f908dd272541a4a76ccdf5ff60b18abf629c581ba44e921a5c53c0e0f1e329592a044857629e331e3822d6c270c6a4500e8d628bf9fa90fd31becc5eac9768f6550794f577268a4d39a94158c8b24eb89e24018671c7c639fd85453bb469379f20ab832aac6370802a260ca0f2cc6c92d083c836a97f7e6af0d5845f0b6fa6499b311333eacdfa9d39358bdd3e4cd1cd266d312d991de5a16e9f5d0a87d7f312938b723d1b45f804d5b04a5495495a5bd7d42e9b5f8d49337a2c0689af5d17618970242392978722b95e43f3d8a71253a8238ad653a948957dedf1aad61011002143075b1c6e093e1a90eb1a231c77a86e37b7566eb4f05f54dea245fd817eb371d06008a61581704e5d7158aa727d165ac924832588312ee74789bf82489fd579f6f1fc50cea3847ad7f48b3b2c723b0a5b39cffa8b27b176fbed3ca3de0ac270dab64159bfdba9edd08df5f1df0f3192d84f7be5e1666a44a382af6afd3095f60ad02429fa9817fffaffb9d3abcf5188826439cf47dd4dc5ab614689077f0bddfdbc44b13cfe3ed72c1beb733f39d92295e57ca244a1f03e2c6a8f46ad6d2d6e2464e58e5fdb793dea8c8772ee0f513c741ece04ef3b490fc43f5cb4753d4e9cf76a1ba86e9478eb00a3f04ccb2455530270e41884c85b3a17136f10875fa5ba5456359ed3022a3438f25a4a3e5e8d4bf098243c6d1cd7a5d1ce5cd1830d4ea53a5a42c40870b5e78f50f425bf2cbfa4b250d5ec2803d196239576d0921b1a122ea1c5a19bc899b839d5bcbf4334512dece5192857ed197800b21df4a75bdffeb4766ea57670647092fee5316ff3bbfb0da20cdc0e963e3963752ab37cff9925be7279e752167899d27878913f3bb4afa4422b117e0de0574c15b644afcc251567ed26c3a39b09a39ec5887f03ffefcb997b34b1dabaca9d790715ccb26b7aa53409969d0febf2fec3b61c1ba59e02cb822316ee7bb30f1202adf51dc75cfa76bc9c46f970f52ebace77b3bdcfe40cebbbcf12c6a0674970c84463ed434b512462081fae839c9b526bc04a161e67cfcd1ee4bb0cf9a9cc60dc7d18b8a855a6a7bc690bfe36b8ad4d6d90304cfc69c7defc696778b75c02267bab1221ee4e923ecfffe5df113bbca75519d0a75a6ceec3f9509b3131a28ebb0d479aaf15280327ed4cea672b761996edba10187b2e51b6ba5db3c96110bb719ea696184707b788035683182948f6bb1d49bc6f391fa46fa8981907abacb85323394d1199dbef7a25ee4a819db6825e89c213d28a249f8031ca425959154295e57593b0c71af4d4b78b25abb4328b16a4f9d5263da242a71a223400a5e52cb7ff9456dc82b757f0eb2bcfb4556c5f02725031116d33fe73055c78189e12e62fee67ad449a05007b3b6ddf7a2c0782d2043432d84cb14b043c9ad96f8ec0d062aa40574abcc3ced3b9f01a64da8f8069ef67bc9308f6588a7601b8e368295a4013de67ca6b356aa7fd66b7f35cb086f2eca5be68adb66dab634dcf6cda8d1a982a79340625110ea4537c503be15a44ea9ddf5a0023ecdef2e914ff7a2e616f4279c9dd7387255953108859458fc1fc8613bf6bc10e9d7cf65563337b8c16d4548dfeb155f0ced71b6e438ceb0de4359bea2efb680f97f051eacc5495d265ea307789e2ae22100c12648dfb22cc2cba6165696800ae44abecf2a9f1f9cc3e7cc8c5e81f93244b7824a1be3d870d548e258b15b9a7b959f17e1960811c9756edd8f93faba90ad1c12c80ff0de740b3a64996650cd377f522177787be7b409711777e04daa031ea152cfbc9da72aa1536850475c8ae91db8ac9b892c20d4ea712825336006c701b02580fdf482ab1185dff6c13060a2f9f49bd2799e183d8051fcbaabcf9a2c3b017e4a082812786c77349e112ffa39bfec451e6dca03a0dfef9913807407057af460f69781759074c116539201466d1d19c8da65fe63edc20cb03f80c9b7d565a8e1d4a735c9e89498fb2c16f74024a6da7e2965296b7c43677a9e5fe4e3b71a9e1bb726af73f8a6a11ec1ee0b02a5aeabc0a6cbee9633971825e1a4d646e6b9d028ae084e7bc75de48589536aefe689feb6e14d2fe4853d851e2845f0451e47dd30a1b8737e5db395d300136387761d4b80c5d5355b5f95f17355221a61601ba9f9b8129ef3b1b1889ed319a17ee60b53e1002043324e3284e7ad1d02434ccf4a43a6bbcc236016bf6beeb851e4a908abc89cc654fb8c557f3c84c333e5545121bf34b7d8d47f4ae4082c1a5f30d2bf4d17adbad34991a42700fa2c1748f37c2da9131f1f1fd9d08848adfed086580c6bebcb22689e5615657fb42e0be9d54a52f93e424268cf48f4c52fe424f9b0038eebdd228b03f4cd57ff7e957cc10238324cc5318788b356ee120832802644abcb27264010b7864749becf3a922c397d702cd85650b86a29e4fc722a0024978e24f5739d81e0c4a98f08557d79a436a798e2c30f7f915af95ae468ec39eb723c8832db7ed7cdbe6d3e7097b6093e37bdb311ec523ef6b367bd2920291610a9f7c50fcec535298e72832678324386cd947d0f8960cc5cf36865e36f0ed40bb94c8bd48f238375bdd7823b1cfcd2d6314712264a52d3395d65ede7f990f3c0a037aa7518d8029b900dc13ab8810bd3cb92f83847eceea70ab03ae60835ca6966530afc5a5b19d323968322f07cf0ca32b7fcf817ec9785d2e27bea3caba19a8ed544f11896bc94dc018054298a0712bf3b41c1b0c3e0394737917cccc519a085e81533b1f08abf71f0ac5ae660363529fe5108c65bfd960fb366ac12220441b396681ba05ef1869f8e3c47b861b987ecd367d11e80fa62dff3b000ce62dc3086d01168be6f68d47f6036775660291f6ba998b8ddaeebfb31c645fca800583a69cb9f59952c12fea4187797f01e64c03039334b4fac4bc08dbaf7d2dea48aea35a903a9c1b68bbf599608a9a457a12e05a7fc20314be1dcb3f01eaf476be11303bf0fe2f6d623516614ca70ca42ca8c97ea1965d041cfab54daa1b828947ec34fb8fbf84dd8fe823029e883e17e0f3f3130fcf5d00e113c2937a497b96c353edf919576aa923f716142c74826d5b032042b0c07a5e56d5186cc49ca2a094396487e24fb587a78ca74fb8809594d961f257dac59950ba6dd06480fa345cc1b2f8d836e30c35c05628f629ed3a5084007ffd8fc33d5b17992520db72123a6863521e799bcd956736191e2783e2d56e58afe54ad98670e6cd3fbe36fd5fe271398c5a982dc6e2acae25ddea5194a11daa44fae0dbdab2d022e5411bd4f6c0bacb0ce61f23151f3b72163609111bef383d62eddac30c721f8969b99e9fcf5c00e9cbbb58a5e3695006021e598db0cede1bf202af6217072cc0474c5bbea93c5a98f66b018997cb660df31df8b64ad103aeec610eacc98c28c35cee23ba1f5313da39bfa3ba12597405fb76d4be9ccb823b62386eeb3aa1e85e507d48f7e93ee87d71b6f76608028684d0f1dca1b073cd59e270d119b249707d4018ca29949bf04d215469b4c45869f70dd371464599842d721e45073e749eb417f55436d008dbbfc93fd2ca46551651f016e9866580b28563a840b8aa7a9065ddbe1bd3f4fe1401c88fa3acc1eabde14be05aa7a6d1b3e816a9cfceef7b5f71bf8cb18337b4935c15bcaaa8fa59fdc61a3b3cd8375f911685e6bcdb4be83db966b442a4397d541fe6ec1fefcd9991f6da166e71d9a76b832d965a7b0bf3c202d01af3dc703d0ccdd846019a4f63e9a56865d1ac789ef73c517ba4324c5c73a8e707eadd1c62c71010950562678522f7e765be68d6a99fbea783ea1c2343261f2f15f12db25cc7e47f44180b8bc5f358c99198c73642197698aa1be36d3aeba2dd955ef1e1adf4eb0a8ea3e3d42aa9ecd554ddb88c521f8882e5eb9f6e2c33ebb3955f43b4d8afa662cb3586ab7d9d4bf2afcf9a5488e603d37310490670a1e19e379d55dc741f5d1386e4dd3dc9281c5aab6ee663ff62461931739d36563dc1dbc9b1641c28b301c303d9eed1238a8e0d4c88de63955ff47704251e0ccaa16f1de344f7181f0008b4b30bbd3ee5aa3d26461f0aec60b672180d1ff4c676cc443de0e3e41e9e5e216006321ea0f88eeb44e73fd31680a0b4b66731233afe7a70013d1b56aeb4bab700c1610b69fa541100fc955e362bd09f63e58b09b32b4640cd0e4875f90c19cb19cd4a65cbf31d77711d56bfaf788bf679a31eea8837589c4fd0c04ccb46ac211866beb60faa41aa449eb9665622a6e241cc43af259fa67984b30f7d5eda9fd64158169e2c67d886acfd39e185c54e2ea86e85d605e0860b25500df352ec92edec4e8bad878f65edab83860119a97a9fa985e27259f7a1c8fc97929a140b30d9103754d286ccc5904daf2dc572dac3ade965affe7cf21b5065b0c4b52390bdcbbb03fbcc7ff12fae016d6da0e19e9360a519b6e6c8e511ecacab9ada63f33b61452c71c4ab7e9cd315b2784ec20d98f7ab8997e5dc11606fa1234f10554a84e2bf0f4e24c8e6f56934906ba4b98cce189da57450a9625dd7ccf1b9eba96f3f54dc8b1bd7dea1ef3e5e314b67d193dcf05bb8504c76a970cc6c693b4c5c4ea3b65899972140435f318c4bb3fe51441b6c27f411adc8d0c904b2a003fab5f3174da5367a83bcdea8cd123a43a00db04f5fae3ca43a6970df62c5ea3a4a03941c00450c7fccc7ec6138100591a273377b3be06d3682e78f97d83b4150ef6c9914925de397f6444f69e354ff3a08daedd3a851b8ffc1223f6dc15582b9cc0940c4530e0c5eab25c41c4c689d978624d5d01aba07557228bcc6d9a6b04d101bdeb1d651e2a407dcf9ac4b8e346f573a1903a5ef8a9a389167dfb7cea8c2b54a0dde7f864b99449287533e69356331d678a800253dcccfca9ca9c6b46dbb00538acc3a0a5aa2086340af95709540f7598dfd9283c46702c229ed1c2fa940b9fbf8e654e3cc3ed3db1e7734d2b9b33b523af59894ada8c2bb45e064da40984783dfa42db101df6a51841bd60ac5d4847a0c31b03fd28cd423c3f49eb68b5edc96180d82f2dbac8586a43736c8231344f58e02e47e10c8d2b3ca26ac97de665673146fefbab13fbce1cc5311cbe666335e09f4dce9cf076431d06ff0b0a1a062c0609a884ac44dc8533e1b2523d5ec0961bf4536fc8236636ada923f317c48a2c6450ed2d2b0cfc804051b5e258af8149e697c868b0f3ed2227b2afc5f0207e487b8f06f4cc7f46977ce5fe312d93767bd52152677facb9d33e6cc4e1ce760ce6f44038cab47ed184ff2967f3d5eff2bc60467cbf91a25d19688412b0dea14a170006b111933d99ec4bdf834570d22fa327a1907c10f4862717d6adca015a8eb571a9be58a0b8fb37956b2c9efbc21c579ddf9b4183eed53e7a478668f82f54bf2ed2df4f76ccd402d7c5b1ff7fe0df5f3687ab1c82f64f8225e8313a2c6cb8742e8f96030f77c73b51662b49e1b9121e0ed4e2056de56c62ab2dcd436f5846a020a9ac20c7c4b0c98cd89ca97640843ae526370d6439a28f4f03e7603298d48ca93192e07e55dc8a554ac0c4d3426dd5c838554274d13f7c1bba5802ce393dd4ed854a1acdcf894e925d7c52a16a3c7c939d4242e06a1b81fae597db0ec7759609568d037578699aaf2460da61eae322e416447d7626c9d10724a23c3390169d013c8375463996b13842ec1a0a29fbab1abd886ba6efd2aa8f3a481b1ae4107f49ce4917fa95934c80273bf1b3087435024255863a391b89cc3982f9dcce089c64f2ab62e85e40e120b562a0f02296056dbbfac041ee6a0ab2d94ba9cdef5bf00370bd85043bf11674a1dc007460d5434355c9f33d317376adaefbe263662c60482924911c2939065760e0cd4552b4e40ca3e256b07425ad57e31ee558fcb22347ef72fd3738997262380a4620563c236c5040955f6d5e2c88852e77b96ec72905d119e9381e00f32ee5179f0a956f464cfa3b34da9730d4c3289d15bf6887ac78369260d5f99ff57c5a41f50de8fedac8c1cc5cd645921b083f068fd071e4e04aaac159bb364258f1b4df52d3f1a1c217380d38350d31b33d5d7e88b3169e8025809c5f204c230cbbcdefb8ff636dae10181faf3b8b09e730cb29d3ae40dd46df577729fa77c6b6856330c8c8b2d9e269d15141f6b2719e82fe852dc49240b709edaeafc37c3905cd74d2c98854a2ccc0e05217db37fd4bae447cec82b749bf54b69463734fb7e063ccd34c0c8c04ca0c2ed0e3717660f4e68f9875136cf41e2952ecd97b24248f841dad05625d3e1a5f5a14f7b07f9107c403cefd2474b1ad88720d893ad6679758d31478f42715eaffab51f6d0a6c156e09cd883b249b9f57ee9d09b6a1841f66ba55bee49c79e35a87cc58bbebf4315b0a5690986d5ea231825eec18a7fd07491f049edbb1e0465eeacf57169798adab1f881d08b1085e277913e24d5df2a22f38a7f29955c7494e23732ae2cb150f6f66a2f7483de62c2717690bf83b0d82e63b93493154627338aaef28215282a5a8d992da0bebf6f6a823b99311e73d1859e240898718ed37e509cef8186e15f2fcfd138c1d960a9ddb5537d81b0ff4c9d3b76f4ac81856d532efd171f6efeab2df0fce33a573a78b1360d5c98bbd57755a9a0e01ee94999401aada31b953bd97db68bd265b2efc9bb482c13decf51cb10aab5197f49fbe1a56c05ef11b5d4c8b0d3f7023e8dca0b980146bbe10920149b5095f4c06bbcf9b9bf39d318a8a01a2b12321e9fd8da7924310e8f4d8cadeca3b254a75b6efa2827735ef070e366ef58d5b540bc502d2d9d2ecae2f30d3f51b254d78dbf9fe85d84b28a8ece612c48960838641e192c2250ed89f6506ea6bd7be676e1f8cfeb770dcb270d96ab947c125854a97a5e50e6b988237b54b7b530a54416575b1981f96cd3738edeaa9280d73b475e23bd813ad057f554c0400a13b719aba38edad8bfabdd75fde5c12d536a71bf60b6c6b8f97dc8f19217ae5f880617cd942cc92272a68b8041dec20ad96c6805fed9d1a1f5b885f0e15ad9fdca67f4e9f4b6b4f878cabf24e985c9874940f37cd8fca4aa553ba30da0b6e098afdce1b79c252fe337144999a88997eff84fc0cd9e0e3c8fb934d5f3186b30b0d1514d124d76511a239d282e98e4d499f751ceb74aaa475329a25417a20f04942c6cf851278253a13bb7643420397ecd73047d6ecfd5c4716ee6bb53c7ffddcee7bbd9b84ebc16c211bdcdb3b86a689dbc1887598cd40d76eabe9e40b7590a8776073c9118b88fce2e6cbe76878d2b10033d9e2850446d68437f9f336e1de71754f7a667e048e6483a9b84360be84d2c08db31ce730e4420292a8c1be104aa3bac7bd530f9a47b093ba29a5115b966dcfbaecf4fec4c24903ad5e6f904aaf104bd1996bb155b2bdd27e25292b2d497c0abcc7c9166bc1ef70cd23bcf49add2423729a6c74b847ac1407cd58c1eb973c1bfad63694a4c24ef59a4c247de3e7d7d620ac685b0675029ac74bb615abb7cf1717243a63f683df9c0ee38297bbd47a5d4add9fb179f67f7653e0b9beb587fe64d1c134cfb4c09f97f0d3c060da003f1431325ff8911e67defa1eec43bd61d510fd8c897f5db2ed3b6420f82bb5f432ee7dab9c78d446c2c680e777fc45ba756cf8e378fe68157928ddc9a6b50aba98c37f748181e6d04093aac031a5767ff92c7aaeace383e15a402813b23f0d8a9b0b9ee3f0e6f7a24be3328a87f21fdeca2bbd51ffd4d29765eb3669818a445d50ae9c9db02d89c1b2c541e8130f69495b4dae052654d658e6f3ad0fc899f82a3bdb6d7c9c8fbf7ee5da108052b5eb1ad82681b20e61053ad4c36a73d3c5ffda776ff96157314d9674bfe79eb15457a1b64eb11933e131c4532c9e15e2e655b9991d18213bd5c5c056098c421a7b3a7a7fcd53287e11f4d5ad9f865a51368f2e13478ed48567ffa76596896366fcfaa2bda4e6004682eb3204eca83bc584fd0bef1e60a2af3fccde81f7659b1d18890870689bfa3b47c407443504d68e73d4d200670c109d7c862a7174b9069d39ffe30073ac40b61565492559d577f603ec677d86ad05ce13cb2846bdfb820546cde02196df285fbd3724cf392c2f788d799193bc2793964600f71830da4a1b5ba9139e49da35321a6197c5f4e8a9f7870dffa0f5bfb4209b72e2c629bc9d9d0e2afcbc6961777b7a18190e5567206fd06ed69b03ed95ce7c8e310ef466aa2fca369bf8d9d5939a46ac567b715dd2f2fc1193d64fd472600ed3044e489f5dcbd87ca5af24a2db4b10137c1e5b6ebb5e8bb9bad81cbe2022990bf2740524d4766cac133951497660ecf4f99b24cdd956d3322e2d9433e90c844c5b42e49a1cd501cc650c1b672b845ccf07fbd90e5bf6241364faf29a6cc0ac59442a8995c8f0b3325b6ab81a6d249a2605e2508fc35cb2b79e240faaa65762855895bf324e76e00d8550bdcd1f9a51897ecbf0e2e96de6169e75c5dcc7582875275e6e92af7161b598c9018d53337ce79352b2f84172dded151b4e82c288453b9df0bf1e9b5332e26f23d0d8cdba4eda30a5ddc911bec16d1132eb5fdcafb08bab675c48158a0d8cc275537f69f72d88147d33a08c11f129a0e113a12fb7dd385a471dce1f5e185bc9825808b9a2610e6fbcea96ef72d3654f53d261c174cb4bf54362d0c56afb41567198d86684dc5fbc797972e2bd46632c3e865fce2243001d277df70f9c675f588b64d982824c8ffc8a341a71de7ec1aa492a4d66ca4d4cdee8034af5ead0617be455062561833f56b31665dd01e457d9f176c91f86c051f098112663598269ddbf815685808190655394ffdc0d8dc9e69dd4a18095e94d039f79c6bb2ad74530ca66dc1fad4d71a604abd1274d6c8fe3ef9fcd89841a77e9dc079988bcf2ef24108d0f77627ef6c44ad30f2a7fb6fcbf218f75a6e02225f86a8fc5d3270863ec46b1a28bf78167fcf758d47fbeca57d965fd1738af8e85f53f4bd1f06815c4ec8b76bac41160aaa3659686769d74dd476e8f47458a01024ae72fbc7ea26a4b587896326d8d09c4d91d3fa035b20bdfe71e137033b020f13677aa51cd399d29e2ee218249c5a0a563274ad3d81102166d467a911c7fcb8d7bfddb31e1e1f1cf80fd27a297c2f3c2121a8ae76e10fc6254b1be98326979a882d036865c71c856d382db8cf23d96eb696f18cef45d3f27b55683bcc20d94180e1254210f309a2505ef5f00caae1b657df4e6e5b8d5295e62073b9c998bd70cd07293e6eb2d00637c382899b4b62f50b658566471c4fab23d6a46c60822160b6c2a87f815cb8f369cae90b3984a8c61c98d36aad7be8d5b733e6d2d19943583dfae38779a3a69178dc4c13f332458863743ad3235460232aa1beed47722025411e15a722051ba12a777ad8546d02c52aab88de048d9218c5f9507d62b6e7ecdb1563d94f718508c1a6168467062def0d94d2ac39977bb0604e2e1fd2fde761ac2e05f6a634c0de3e8f2aec97c3c8f9b8f8b70c69883a806db3bc6e1d9738911bf7f3875fbcc8c79b4f0de98a573962cfe6766096646b3f62cf23d46361e3f9f740f57d118b4a2b484594eb30afcf4af675e6d7029dc506eb21b2dd485872acabbcb2ec75f959f09378e64e1980940a29eb2363e412e86ac178534d325283b05dc3f3fdc3192ce952d0c668ce572f24b5d47e56d6a600ab4876e9fe2030e586ad3ef6a366b811d42b285c4339d163359f4e0b5b50991d296b1dcfe983ec5ee96a87cacb9e09677bdb0847676b84ceecdba08a9324498bc584a933c9413823f4a1a474ca8b5e6d251d1e6a9a060b8ea0a2c43c4932062b3a3c439a8763094ac9c9e5c955baa42b04b4bd69190de273ae50227aa72913afba8527de25126a764030381a65b4b984ef2660b776f946aa9a36d3cfe14ddd5eb5e94e3f700ab6b88c956ae897643df1c8e1bb51dd5fcdd4a06e4f888597e3078fe6d1c4c160e6c76f34a0301f31b5b2eda767ca891efd802f15c882bca9c96da286b9a4441ced74edcf9ac83bf28f0ed8d4a2d638aed6659cf25997b57ff034e1b7db0235fb43cf62666ba49ed7038e4af31bbcd061ffc78274017d065302cb4aebcc26e988fa74be51aef4c030e0942d2944044af0705c2c58e8de9e4050458c42a4d8193fc23c45d3a8e6f8d0837afe047aee465b705af7fc5285bd8bfa8253fdfc2fd58bfaf5f4abf5d6ad3832ec3a1954f18f6c7cac308b975b96bf0efd69f2e3cca916ce4ca2c5fa8c2c7493610175434edaef23aaaf4e6718d99577660f8405cc0b04d0ddd326735ac8368fe27cdad2bb53249b9f716fbe669b84d08b9b4fdf5ccb97ad04e042a38fff5761842ecd3db458fd09ae935cc0f88a6f52f6909016f726d6cda40a1af0fe481833bfe99c3ff482defeb8bec104bb343a23706be9d753c27b6204ae3d9ad77c02d4511d2f23a427026dd7f3e18c29000f7d25d62186b33f660038cc49d14b0af2fab22744d52aeff133099a462cafd4476d1850b10708ab95b3b1a3ce5e885679602a17783aec842741a41d576e2097a2a93e227c831c04e3c545f8eb5acac6f2ae9f53f1e1319d43671fcf7d1d69b4e523d0d6854b290aa77f12ffb2c5ad1a80ca407e5210c8dbf2fb77226369d684482846f8ceef481188ddbd8a4534afae039a3f1c6a6b7fb973908c1d63f22f4bcd5e5d0163ffd85d13dc2c09ba27f61b41c0303850a5f8fe8f7db4d587a5ae435d6df72b8de19d1015c9cc123fe3b2f0400a1373fba0c0c8344e4384a58932aa3e199780faf76bb3daa823cfd650195902baccc3f831fc6122b829b86f6efe40223be35a73aa9dc1381fb3a38f9f9fcdbbe4f9346c45ca560d1d6561930c338de20cec7625f9ddc89a8cbfc3579507cca9123758a6ed48cab55a81577bb972a2ce34cd9327ebb0fcde879fc91cb80c2d172c289e055cc3c51fc59f7d9e67e3cba5a41bda596a019ec064f2780c05af119fa5b51f5ffef0696d5175d9db3b4ac24a83519b0a4529d885461e3486c9be3548d68fa11c1aec770a2e3536efc18a09dadf6a519974948c3f07b2ee22466d46c574bf995f736624b679ba7b2b32a11928e2e3ae1e517e2328cb4fa59aabb17c38e6d3d8254740186c40c394c94681d0bd07998bcda3315783141c0092f1afbb54c8ea46b55b91ee771efabe248568297c44b6dff2ef955ce8dc1830e9650cf308e594505e893d70dcea20a5abbb14da95797be8fdac1b26b96e9195aad9248b218299be7dedddd68e81ec9ee379b198fbd0d5f33d1b3d9c3e11ae4d806d971b7477d5d8b87b2c3408c08118b9a2df39b4bf8a0cba8e0c27b6c6a843d18393838cdbd69e46ceee766312a75c5c3eb7b04afbb33dbf5ed7f1498baa4dd5f7f0c851772e7e2803879de0929654664f6b94008aceb6d86d0d14fbbca7f23f9a6fa80c2208dd5fa93d324337cc8a87230ea47139e8f18fb95f31e65af14667a1bb20db1c580fb24df04e87c953078e43429acd10d8199e43056a63ba769c92077e9bbcdd226963f5348fbe24b70d14a18475df9dd68ce5d7de037591312c2a154a94206bac1d46ac97dc3af268636bf7463c903934e977a978b7ed6f5b024fba011a326e8fb298ada0bd58ccc77c0abf8409743fdb247d63a1530281e66bdd434ebd40761fbc91dfa2eb3e3bb35b5150ffffc9f2d041d01fb4dfd64e0c72ef736e42c677276828ef0a427","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
