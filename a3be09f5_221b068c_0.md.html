<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c145be6a0785713e97e3c426cd8e106bc873d9d7b349463376d25fc08771de6fdd4e4e74b3542c10ec869570b533a90edc5296aa537c0088a2cdce0fd8c00678784f4daa6132e22eeead1d7f778c7002241c965bd13a48c077bc82002f56bd8b6596f114b299e331a81ac43335296b81d98e4ba70826b6377b9eed867fc3c6f4940e814970c3d1a5e516b892ed78cddbda0d2afe444c2ca6a20458246502419e2129f82f7f9743848de5dc8857cc4b9ba35bed4fbfe05b4112e3ea6d26671e0a5fe5aa461c4df2ff656f5e1da5860ee492bebd33c19d4c839a3a954d250fb71f12e2c6dace497753ca189ffff94e0f3c59450408f5d3c93cba6fa3f50fe498c204b991b537019615c82b63007ce1c2e58f2bcb6b8e8fdff9fa6e780977f4750b2274b3064f2298c6977d65385428ad18c2b2943831e4d1b6a4b36e9be86154cae5bca695320da251437b99d7ca65924c16dada6e6c35eef36dfd379e6ed4cc87db5bedfb36f2baa56c3e25c64e5003088a15590fc14258b704e18fb886c10c29de03b742831fa816a59c11278b6ac17ba1bc32fb65a2beb69be962cf02d984534999a621f07d9e67498226951c1e85ed68a0bda64abfec3de850ddfcdd66b04cfd72d4582ef262faa92d4e563402f4dd0df152981f61d538108e3ad196270590da9f9a0f5ad9a72cab513be9ba12a696fe3268cbde5564cc81f42e611765d55cb188a5af540ced56920f74d8fe81b4bd12d01978e26255bbbc4d3a3f1879b8fe742a5725880461d5dc8e8a5bb2bdccd96d20950519fd1ec219a2228c14b935e4336bff45204dd05f8867a8c81a80ed3345abead5117224c8aa2eee6b7d443f613fef861edead36d6b0fb6097802416b6ab4498bdca9ca1fcd86b2db07727b63844ef5d0828561e8e7979e15aff8ac46f5bcebc778d2ed36304325a93a9cf0eae2f64dcc99677c912d691a2a910dbcf40787686709eaeee67c0717d53e27eeedae2710ea89152cdce7550b3bbc5cfaaea8820030cb7bf0385cb6e6b5c4135b953a9c661b4437963ee4295a2aa6638c7bbd706cf01b3d3300deef6ea613e72a9c9d38e5a3c0c7cdc44f8147caa6d45b7896f74763ef7bb62055199f59421e612d2bdef6999d7582310afc91d731df1134c842bdd02e6ba4b817d1d0c6e9eab777826f3ad2865ee573f55970ede955f4091c6b3cb867bf5521760981c3c2e77faa82e4ff7a34541fe297122a276910709188190b5f00512f0d30bc7de95c57c32d072e7e9634b2d6a4ad74e8a3aadd38bc26b09ebb22cc25b049887a1913c94f0be26f10a32acdf573a30ed0d8f051f5c2112c5c3fdb971f45b4255c46e3fe772ef70fbb519f6c82fafe5794d44a94e7dbaaa7098c7a750fce9127046cd0d650cce732dc04ec703d3c596d373dd3c4d28ccaccc7df3f7045dba4871824bffe9310b827b0e320029e5f09535b5175f9ddf26ac2331724e3921cf5c5a29bddd494c8c7231ce68f5598f337b1019c91d8bc63939102336bad7b21cbb07a39c3bbf8e8cd8c49f8f37e7face8770cc0d97ee963295648654ba740ea927002039570e384671f8809133684a39489a5965be59db5b8aec5207139d410ee2e9dc3cd398f44ff3a9975d58ff28693170f029dd6ac2216aa70cf4544b4813a630c39711313c9c09690490cc17722f225b84c1519af383a41e628b48d8646e6b7da007c4f793dba76aa59fb5c4ab7663b5680f9290938f1a2874ae0e52247be92329cbf65d13f9db112b865c39b23a4d5bbee9a0df9f21dd43b1c7feacab45f46782854128c2e07b21614b1b4f1954efa7c8ab41c52c3a5fca799775c9c164922c9c6f89830e2f3f717a2f41e66619f643b85b15c6522f9a8b738bf20d42ac3782d32000ccb7799236812d9fdf077cacdb974afac0131a1f5091766b6f0c548c3f4017ecbccfbbe6d44f8de179139b7e62df46d4b1ab2ff5bcfd56611be39ca9da510815de0cc68ca1a74af305b0786267f1fa453b6973402e85376dc6dc1e440e665ec74494e6333dcbc97617f4ef453b8212ed44ef1dc007fbc4956c3c1d4f021a17ca970b0b317209a2c9c91249897130bbd3e7b707ba56b606446ee96be03c28a8eb3f21d253a197c1708903636dcb7e81ac1fa4ea32f28c0c6205129a6f1f5c8df62dc45165f25ce168aa0e543343811dffc4d3d382925a21e2a44aad1d789ee79c7ec0af4d2d64d31d26db38fdaa3c260a0641faea63cbdf92b25bed77c6af22ce23b641c04d64032914314b4e2596791b816dcde02cedc092ce63e87a9d13cb3dc0f4ee2eb8e4da60b88670839ee66e5d35fc2adcfcc75c52abe7ff70a2fceaa629282f1ce87be3dcdec37c603a2d743a2360f2687f0ddcb2603e4a8ccfe581b93b3996750500690c8f5406165427fde122b6128d78f5a85e87b24683e5a0d1fa831f627bd5e9dcc28e9f9b15938a4452ed79617213654d7953cd13e4a94e5df5530e7527deafdee277c1854ea421829a331a53e275935c5159c0f87e786e866b7197681b5416835939dd365a594f2197764db0698703ac3551961ec54ccab973b6dc5134c4691aea0b0b0970df9c666af6eac6a8a1b8af9ac58074e120233fe07c58e578ec59823efd92804614eb9067a6ef41ced6dcf878fc26f1f1400e78cdc083ef9e432304a14a1c21a2c2f658af9ff69d0b47f411ebcd636a114daf9af717a2c25962568a0f9c2e8f6e2d9f7ac4f5ec1b86eb5c3b0a2289d2b6f96a66e81c75e6c9032915026be1988d3e62c6950e758bb6fec245bc679940b28d0b06cfc1d1ab72b61747c130c8e0ee082c6470a050364730dabdec4f2a3ea3a594b79e99a3644b378144daefd0c27a1559cd139dc45ef409664128b38d5d2dcf35bac40fbdba4df3deb4b49a88f26a86dbab27be119598dafd4d3becac34e79af6b654a3dc45d09cd204f45c11be3a8cbbe9b2405bbd3866c6515c17ffd48b437ce7939382673a2c6660113f5b4e43993e99a9335c95f046bcc55454d62610a2ec012095eb502fcaeec5834dafb3fe01956da315f30308346c055707e97f0846d266a5848e5e841e8b311be879b459edc40cf39606fd20d0bc863619bfd511ebd9f78b65929b06f9f2d55b5de14ad5f38f0303ee88b225487ab59c70a0b952fef3e1f64743d2399bba7181393cbefe17d1a0ccc67bdac5d965be0c1932e8c151c9343e7fe3357441177831b39a7867972c7a66c4a99f90c22f85eae25935414e5f3d2901614ba44b245f4648b85a37871bd77519345f0ff583fa2870a2929b139ef905bd5177242a5d21bd8847a3b347e34d6e0c7cb47954be825a8e984668a5996ec9279f45cbd2acacca1ae67f92c85646690dab3ae5d2d05873cd8cd75b4aff1e0cb4ac65019235269395874f40a2124a158f343f4b5a1b4ce3c881a1a79ca9986ddfcb77b4984d85cf37df1ff6c109bb874029090d73a40f6fb96430a0a4c5a217624bf701c498990745ee7348dd7b59c9ba0acba37adc9889a0a53084caf741a8b6e2640d58469b0a6235d7cbc013ef1209b0d42e3ceb8b09a8b8ceec4fabd4766d89704104a6b25540e332f489b1abe986ea61962c35cfb2cf82926b8ea11dce3f04e37f0cb7848d06d32cf71d89d395ec9609624e4d5ce34b2692d40c9c04ca14882006d09d1ebc7677e0f68c063dd2d3d646067eb4516d0d365474a0d6f4dc08606020ee58e615d408d2f779dac1a9de1d2d7f9c131259ec7f5922920ecd3090b0a2d4809a89b4b534a32c77f4ba29a9f87f9437cfd09829c4f97500eff877418ab5e1b0c705f4c8f42fb5a836f7aaaf2f1dfe46afabecbdc4bd13c47097106d88a5ba3afb83727d6788a8891cb8117590d5fa36865eaa466dcef97a2fd283214c9813c34543ce431ab40c308f723702daae09fd9087f6549ab2817b0ad833c8bda443e3e42bbff40bf79d58106e53e4e1e59b1c873f2c353b6a6efb5b48a5e3c523586f6dde9ac6c571fbf0e8123fa25bf5e65dbda53c75376fb7e0e73ed124c5b767e9414cc20aca4629cc7a3ee6eea372e2bb42216ffacf7e5479dff9f14fe097908be9a53f2d4339234c5d71bccd43d0dbdff2cc0d91fa1cd863af1c0fd1730bc4c6382b86297ba18d8fa884451f5e6d1a46868da28e43560e59424d0a8e973f1f43f05c2ac76c9dd6dd4f00d96c2c771070bba78111304e12acf732d9946cdf1ac0f59fd2917e7ef1222d1dae2efe3e37c959712db4a5aa0c68ef16a43340e62cbe9b300bcef82edc8eaaa4858e5f8a2882dd0545892e7f2c39bb7a82eb2353a628adc14b8a76aee805e516189b317c6dc3dee70444ba1d7353cd56e35dc959503e4ad4f218ccb0908617cb4acb8e9fe195ecb76109e9f58da091cee490140b441a6e97a84cead05dfc41096727d03446c5212b144192f7861aebf85abf108f421edafcc489939c74a88f9a6e77dc39d2a492beb84cc6897c699d67968eba8d8083c496702f35bd04c8e1e046def73c81fec2031f9902b77a572249d058c42764a31f64814cb757ab18c9de32525319a88b361bb1f53821d12526dad40bab29e222fc16d64c941d92f26014a910905eedeeee096b0e74bc656db3d736cef676399ac6cbbce053c0d354880375da18a587c4ac1d73186e9923fa2268c099357ded1e4d6053b45acd959f4692cb992a537f245c55aac6d0cf45d16cbcfd0a0bfca4f1e54df702897fdfa9e0b4cf27bf14ddda8b5fa203191527c15f517521449ff96418b9fdd9c7c97fcbfbaf90738cbd4dfe057aeb51c037b0430ba4cc4ef0678b5247e4c0a6eb26af9c3ce73bebe75150e1ec6c5bc71c1cde4bcdce2384fcb4b33b4fd604cbdd05b0cbe415734a716ace21ea81e5ac4df1e18fcc42cd9be132c5b32a1dcccd49aaeb8198000e72714b559a63b2c68239862afd96974694af539d89cbb3df03aea4c71797fd4d9f2e0c1527a3577dd6fd0d4842b93ca554da615e9c19df9adb993ffc029a5c0a71ff84b6eedfd539d836059bea9f0a73dae7773005e1e84b1c5bc4c63adfccfaccbf71934f8978a4c975011d6eefc09d250df5365d005046613e89d4f6a1668d1a22a70ce8ce81210aaeed27f2bf37e542807353fa5cfff94b3be8d5e4166dcacfe81af56c38464ebe1e585f89d4bdc5e786c1e18e1a85fc47c10d16cf6c130e2fa4a172c02e4bc60a505637ad2de9dbd113842443e61ca7c21f3ea8c0477ff36ee573f0786ebacfd9c8c607edcf713f2b080333bc55558fb002160840662aaa9efd489664dcf5250346c4613835ac1d2466427c027c30ff259892e21129baa21ada512573c711d93f133bc86c683fce1aba8f7d71c2ad833183bdb1b4621fd22d80de33b105be50d9cb7cc3c443520320fa3e48605ce3eb159fd03b8a6a5d286ff6b6b6b34532de41de9cd3d9b285a3389ec50161be92afd911b7231fe69b1acc05ac0ea3edcfae224044545f0cc9610218257f1009fc44bd328472fc5235920dd724b0561444a5929390dc0369b1cda7f15b4369892a7fff2631b2b06ddb631083a08dc264450094f66b318096c49e7febddbf4dda5afa41eb963af0b1aff412cd4c4c2f6ae658b44d9c395ba222d7707515a8e53f30086176be7ec07c1e81cfe7a92054cd2fa63dd75a6be2189b4b06b1763c58340644bfb9a25a5dd3fbef64deb25518b7924e3f65cb8b48f800271bd0a1c972ed53c2f4e60d235d4826956d049a1295bb21ed2e84083f5221a6aee19e73dd1ac61b26fc60da890f66d5cb3a833df3b92a90f7a5551ce47a6bb8c7dfdc92454c64ce70355a69a5692986524204f02779a174adc92df88df34921e96ff7c82f4c49cbaa7bee1fcbacdabcf4718875a433111b6c485e468f160493223cfd97f6a8bf96d989e2b66fc34b14633373a242c4fe8a4a91cd6ab855e42e803f505547f990d322dfc473731dededa13cb157b26e384108262c05825098fafabf3c5fde53bbad6f307a8567556d35ddc6a2eda78dc6523c2cf0b794f7c0a1783cc0770f28508902cf04ad4ee6ae7dad1c06d754ccfd4009f0d12b2cd10944dcec3dd89c7396652e9ab663ff4cc48f7d6b96b9fcd9050de3af65e4b4751127f9eb9c351c2850d9134fb68539025ff6ced83041f06adfb19c6ae2793d83756e775c37bbc58e2296623a502c2fa28ebcd22a4e906f9b8bf405f564a65a00a2f8b8c38801d8ba899b644efd8fefa4c21883987435a084060a98a23ebc665091b4e0cddf746882375caefa71b6d62c9f6fed88bcd8137a155842da4df65931d35486b3c3cf93c8893ec098e2327492be8c7684abffaec632afd03d47cabd7fabd230c7a2ebf384b528956f115a83d19af22005f08c0268b5a2a9c3e7f0fbe4cd6e74425ae6a36bf8e2cfad6cde9f287643d50531acfe89c56f9dbba74a0de509c8e38baea024e64e8c39144a06f4890cd4efe219c67e64b7b2c667ccb72df206f666b64e9e881940abc7eb720682fbef63ec8fa2fbe98a164ead7c182ffef995d0930bc800e28a47d6b36b2bbd1150db08f0bdd3a884d6c0376635d1a32102012346f88f2d85e0a604186aa0254985031ca63bf880bb81f36fd1af92eadd77777bba5c8a3fe2877e903bcc9896ffc10a3b54dbfaa7f0e02531d9e2f47c0253ad4a78d0925ba6ff1b232d1d4df2d411503e641edebe5f6b750666d912b2c5f83b76f842f794de3e57e145ff45f6075c0344f7d006396f4196591bb77322fc0d96c9990259846e836b22cfaf01fda6b12068b4bde3e6d1568345ef770b20d229d4795c675e2ae7cebf3c2af6306107d3beaf82dd5ecdbbb38acbd8eaeff50e76d6ce3a33a58843f4a9c5b55dadb6c6c1ef8db4396c2dfc0711ba04288e898e8e31dc04935ae084b9bcc74e9d83bb048027d53000a4c8ed0e318037b2764c962497bace3c26cf806d4a2fc9243689f1e1816565c8f301c0ee067293d14a1a6f068ec293b87470a1ad4fa25be46699b514d206b176fc1dba80bd7f267d3b061c0ec40d054a873d69bc009e335d7a7ccb8a0ba3b16d94f716ccec40ba7ce33d390348361480b90a7f526d964e4be9199ee3af1edcec15dfa976563a68b46840ede705668c9339f8d8b21eb2a26d8be2cba9cf97078d6207dcef1e47470e5571561e9e2307f9e0aae44ac0080d90337cc4e8f009abe7bf0e93bc7aac7ff6c52da9172c64bdba174991630c47eb945d30b0ebff53765bfa99195c1c5f9df6c07f2a66cd0c0c9881c1ad6bc70d61781d2e80ef224271ba704c4ff1db67339678c36f7303567ae871b01e488e85bd0943f5cc6661d0af9ad5d7c0b3b8afcc3aad06676ac572e10c241665c9a024304faf7d98023e3b07be25479c99dd1d322db32464a0dd31475c822dc9d9d1842185169c474708e6adc4658bd1be512e098fa2672e2146285212bf3d45d3698aa3fffefb2f681078bf0afa9ac11e3376a0b36d1bdec455ce0e746062224b79187003b9a38d2aba2e3e1f105f61175a8ec30312a490ee4472e4af1497384ab349be8197abcea40aecf6db0480ab99e7febf0ae3f33253a3d21887d0a66d6f6c8dafffbe77165726231276dd5e7762d517c6d3a6e53e15d76b13c5ff86eca7a37442d990108209097b16ea8b9a2bc5bfa18ca010adef05cdf612c25a9ac428d0badac32853f970b8b9a40e2858d4ea5ae6b34ae8f593e63b62bf89fd84c86784de36c12af28c6ebe27ed4d29438cf479d8a9068d16b11d01f86d028a99ff0dc64e2fd50b2e6d77567d3a9b182431d7223cd162a7cb2869c8c02e3a15963b424529e3304d7fab673df03a5922e775ea74f11ecd16a83285648f3e5147e5d176c8867c26ae4cd7ba5123a81fff65ce0ab5bc9ea94238fb9fe6868df6dc690489c0af3df6b8c60a5a11acc86d9c636bda3acaa3c3978fda877cfb57ca98a932fea966acbec9c044a50914c961d553fab8738c24fb9a7a53a25af6f4c3c0bdc2515f374969c64e0c12472f90980bd664bd853a8c544a574d00ffee80b140a1976f1ce17bbae8ecb9f568f320a1e750dcbc016d0f1c421e740f3688fb89bed529d682e0a11faad5d762bc240e1b3b7cffa997420f90a5e1da61e51f621024a17b18dad7fe0c792fc2a3271444e82907ca34f8ccea66a9cc488ee9d09b39946e02902ef8e2e40c8d72b09d101bfaa3099ee87d2ae7cab2ca8c169b6b2e09f02c62c2bfa787759377075b18b9ce60fc1df8806c9fb468d10ed3889615f6c09ff79626c00e1059e10d35b1e7c74a8d000d1056635b9744873032065e734a5a77499cdd2fb9fc16b74c13b033ac0799a11388898547c0d42bfa808cdc9b2d32eb337e03ea0a31a90c050dcca3badedc38a6ff5bb3308aa2ad1fbd1a20caaba1590c23515a5cbc2c95e60bd9d8617ddda0b3a1adfbff0e45156670ae2d0d1f4896c196e2831d7430523b32ec980a87d73fe70f6c2773cffcc8cf1691894f19bf091827eeba3ab4553a3e210bd11c20f5aa8f735a420a3c4980410120efde6513f0d42edc2f069ae756b3991484e89a471179b9cd9a72f822df4bd3d263a27d64d595314b9bb6a6dbedf8c49f476343faa1679e9c0a8fdd08106ef0af0d74d07b5bb11526e8fa59675b0e705f6e5301a1b9b0759229a0f377ec3d9a9facae2971dae5626a19f529ce779cdb0c838f0b5c9b2b208c4b12ac5b842463539babd69ef67d3fb197a5987668fc292535d61c110794ac16a39ba33660ac1d265693f1cc96d43e0bf33868ca0844011ba60e1c9708dc1a56b073367a11abf22feda05248431ede641e045f5771965ad38341ae88cbd45648650a45439f4d4745fb52be8652a6da45f7d7670a9cddff2e447048f3a0e1d38485762b4b92c098896b27b4b842c4d6f62dab88c68d949deeabb1e81813bf18261f78f16c80ebb6cdba34a2486e1988aaf7b7d27ddc4a24cecc1db9871cd222dc92c644002ca4d9fae2368e973a840663621bcddba7e150df5c7b7cfeba57efb977b67e77fae6ee6a556230d1885fad7d89f1cf64d92f901bf35c6da788154eb65e645d858b47acd0f18b450386e10af24b02a6bbf518a83b930bdbae40604eb189c9e8b3c9be9fba54a1ec0254c27047938f22d73d731f5a00958d73f419a722a608798155e21bdfd821ae5c59a4b89a218c707d0ee1b90d745a74866426d640b31d89c6d7188ea52e0ce0a84aa3eeb29ef9fd2d5ca877a213e6401d4c084b25cf1fbe8de0a9051a566e560b7da6e8e15b78f331141a970d2d44c8e2089d2e6ff6bd1cb9131c58dfacb824bbdfa76033c82ef0f4938bb20e72baea4c305e1b5c0a72e2856e6d46da7ac944b34bafc62410a967cdb7aee51f1b46d2e962c5d60ce3269711a5962d98dfcc773712e729af90719406cf02f00a3cf92732edf74f9f35998434d4d0e280013783dddcaed90d1a70e54a51a406c42e6164859581a40773a20b52cfb1d94764e9c3d0a20ce4bc4a5e26a88626c36ecf850d37479f030c007ebbc929c72f16081ce8ed64888aae2fd1886a07836aa106a0c3a60b1d7dc33dc779ef67651ab407cd9a5b6b28ec8628ca655513c9a0a33324951f345fadfb608208657e72df23061ec66e918d90469f0fb7b84553e8dfdba8004dad57e3b8bd02a4378d4061c1dddffe0a0440a75d51f50a367a73e8e443a30736fd901279dd7baec49f5ffd24a58b2eae2c37cb8e09932c429c4a1e8e2e22d8fb3e28200809c5a0c174f708cee1bf7effb76c24951c19dbd516eb02d66f453968338de2aebb384f273d56a16eae4b0c57237008ac87e1f0b1da0613dee767230103375005b4a0d7d5cf9d07214c567f17f82ef89a74901dfccb38cc7d5c8069823f30c2b51a85a0052eed7ae9e465db621f4a5192d40ad3e16eaa0e0b7840ad6f0e6c66602f0f7d654e0da7ee81acac4d3daae09f1a1db738736dd4e520db493c51a9612c9d112e7ee5faa1e6a92ac175155fd2265d74918956f73d416690216a094264d67cd55f4399641b7ae87642930037482162a79f9df1861e3e72cd202822f249241c94acb33a52884920473e7de3e46d47a2cb3b6c6e73c3e297504b876d5b254419ecffe76389d66582e8b626926d7c8f5b93799e71b0b8062a9cf3c1b3bc7adfe9833ab4a7dd6e0e07a430c55f16f10e398e57a274a722e22adc155556caf748ffb4c86d2ae78f7feccd491e8320dd64097189a256cd28135e4fa8bb23adabbc2a199518728fb15cb4624bf2dbd498b707c8385f3f3ed20cbc27b45d45bf43e6e0d4ece0f5677de45e3409a8cd196c48cff8864e00d879b332a234dd6bfff1ae0a5ea0b8afeeb53d21fbf7947e354f055d7a013c9da728c5add782d7166331556c83496a787c53b489cc5eb06869acba5ce3769c3fc9defec40a2cff0336006b952ac79d2e6a348a494ab2c05531140913ad61ee96d755dfcb45b62963060a23e305cef809e62fe19624bcef25ed7ccdd025032d58019f866f4cb7d6ea7fa629f713f7cd1a638f5e28d959d59c06644938c58e8b9f260a7db6189bda7e8d76513ee86ab1434b421989aea90d74ee740a43a41b768ec05faef735ba74f107c49029b8a75c1f8e3202867a96bab0851a25c2e7547eeaf2d6b1ab3d7d9fb2b712d3fa374e059fc3ced5b4163cdb26405e6efd39468d257e2b189968c1e6df6a0df054f9ee26c3d42a5650292e6b71d6163c0c36ae998561edd383466b74fe36a99463a91107abd09df5d6f00aadc2d49cff66e01f551c69f3828a016c9aa6fc877da5153fe6e8e80941f2b75edf6c740498c7be592c4f8d8b743afca14d0dc8e8e16cb838ee6c475913c42ec5caf88c9c0d532b9192c727d93f1a573513c84411e17dba74623685a5ac81894b7cb593e56fa15ecf67c0d4f74d8e9aaa01edc625d83f0764399c13980d05243b8fcf38808232116f288c48cdad6bc91913e79f6da915df84f4cff42347a14fbabc9934a100416fb5d5202ab2bf42afcce6224d48786f0ce189459f9f5896ceeaeba8d816741d0d8daacb3f7ec96d13e79dcca80bf2fba5a939906f267ef4c47b7e3ae0caec8e9d6dd55acc29a26da5da9fd47013dd92330bcf36bc951e19dee801013b30b0595980e0a8e3eb6bc5581d435013e5b619a30d624227be09e565e78447f9553a5f2aa30bbcb6b3bccbf145f7a0ccec52c4da8e00c81d4783829b3cd74f7a33414d25504dc08a84cbc50de2b2cd17c9e8f35a0e436b55d07b5dd673a7d78ee84b50124fd89263bde1b8c42e4c42435ecfec3a206a07f264cc0df0edee603e5030f0766b3197712af679025bbf85f0ec5a0d8a46be40de3ecb9087e3429a6e224041c38febe0460a7322de5b49ddecd231ea0e6776a1550006da671767d41d0cc824a5c9dda984727fc83458ed753d10c3a7f62e3c9cc1fb0a7c030db3929bb77c3587eb1a13ff0996177cc18c4b3480ad51d7e43069d3d107d4b62d4b68bee8c74d3988158964948e301d6a691d490201a88517e3cb6f0ed3f4774bc3c5bae11eee22da43d20d36830352cd0ef68a6099a8dfabdb151afc722fe146c23a28e9ad0f55aa46f43e6267ac1ab6b72fd154dae63cf164098f3a71e2dba88a5bc0e53faa7f95b4e67a1142060c62c1eb31417e71c1790fb530afd0a89f67d0280567e37e7152f27bcc3e54760f4f6dfcfcefd9f67c50dd5a0b7e2e4bedbffed5fbc1769be692b0c32a0e20ca626ced526b37dbfee5f1df6f5cc8da8b6ea0fea8eb11efafce5d126bdd9e392762d66f19847999a7d51a59060cebc3df3a77c87af30a2261aa41b2087578a451b50f9dcb0fd0e64bc4eb3160800a0249634f0530fb5771ca72684f14dad2d028c283764e6149cc1b6ab6e3894f19238a51a5fc705db9eb33d426df063135bc55a6787c8ba5e8fa3c3e73073adbe93a89b267653096f38460d37a04d6d94dfeb966c914e2132bdd8c814936f4e675a4977452a66bcbc424bfe990e5a8cef08656226110a2dd9ebb74fa54139fe73bccfe4dd67488969355c2f488d5684278d19ac2ec81bea47586388b740d68ebf8656ea93822cb9e4fa9f8b614efafab05512c9626d346862b87d471e35c64b2144a5253ef052c80bcb7e665363b69a8be6e95b08fa9fb9440874c58c5cd5a8650fdf2a0b9050217804a0ad0b128b2a263d9c6e9ca53ae0549c6bf4a9abe96d4984e0898f726983b12a87465198d7f9f871dec3a2c88a307c483ed7fa5f2d84f9f1f770aa4dea0a18890b84add9594e997fd0f1a8605002d34775017e03fce453dab5754d736b6e1fdf90a91b3ce2841d00b2248d9fb8713ed6df7638e31e78f5f777cfe001afa682d35d4f7f2101098907d4db0ad45b4c950c93347208ca117d4cd02a90b1c957f032693ba04d9d2603f9e3e37d2e5213ad5c3e3bc9189813d549d9b6e42357d1deea1e71fe36d6bf5784b32ff44a2219987457e0dc09381e275e9a61875c99c0186c8895f9401364d7e129b946d0eca8099682dac3cf52d9d828aee9ef4148ebe5b6f2f212f0f67e7027f961e5482affb662eadbcdce955ae38ab6905b5279c0cf3b22f3766d515394fc88658384cf2acf39d490a6c1079461c091ac14436c844e7a5151bee05c33dcd7f797b75a9566f324457429db7691580dc81e6559fd2fe31b53a94faf9ac1d074180c3c8927a3ba297f1ac632a31cf669afe49935d1589a05c391c8a0aa75ffc3ff2f112f50187dee09b2846fdb734132834f5487be809faae745a6bed4c9f360648c3c717a46e74cc8e2d73edd021c0dc19652bab9381358f10d98117872e9c32e3bbfc06b8db35625c82ddd3f3fac40a1b0c4554062b6d51854906ff859de921f71b4e6cb57829b23ac6ee28429f7c608adbe3ca5b1f4aa088cdf78a4e58a4187012bbd8e3ecdc1c0446e67b1f6f0ebfc4ee9493e7805f36880835d73797de6b37884bb98ebc9cdf7db2a5ccbec1eb3ebfeb922690eaf8515677cc5d555ede1bd9a8325996f6b67e541e0313c25c85680bc0885e1239be297f3a513ea332219dd9e0e3bdcb70fafc41dc32208a946bd8fa04b6ae6804d14315a57c5ff0d444d9896a8559a189cecdd48b315bf0195a871d6e66df78044724f6a1a85f526dcd8ab878380dbdd20f8a610110e2c53405fda5f4a9bb085200014b51b3d48b18241d88ba7a078ed0efee622d0d0cc381e7b9c833215ef4f8794ccbcf5118cbfee36242d13ef24e4a1b4f43f35d2c32b5b2c4b9d138b2625556b2411c589bf9a0972593afb0c6134fe7810598b6dd54d1922daf65e5057e2fc4067557d100fbec0d3da9ab20c8a214c91b976c98941228e87934bc4a181e56b8d09bc0ec2c8b2fc4c7dd75049c199d57d57f8732b4355e5c94172500c9abc46559e631f82ed8042f683f880fa54d1fcd441051c0d4d383e6f4cd7841c0a07ce26d3648113139ed455910ac47157a60c46d2b7b28dcca0e58fa3fed5c16a0143efecbc3c5553c8925e0d420b5ceca7698849f40d4e4ca3f4b7e864a13d96b747e8e6dfaec74b7e8c5d0d176d020c61165968eba2a48e3bc495a3a30403401a3b2182c1c768121c75444b3722077218bfe44755a014cbe39e934f4239a1fa466ebe818d2624cb9df13e52ae015fdd23f183c6b441711f9752a13edd2cac94b11375f39872f7c9a85ff22bd2a846e38711b1206f619f736d16dfdeae324cf45ceb10f872ce30d13215459b5ca71b83a6415ea0ed03c7621dafacae1b56851b1c87d6d283543bcfb30dc44cf007052425a22abb63006a3a8fc0bb21459c24e8f4231d35a61ea6d1f4555ca23fb0ea6b52ef8f444c955658490f9d0cce8405cdca8bd0b8d8c7b6a87532f69667f4f3901141389571a7217b40371b52fdc7fb00ae4adf0e20f209f822b331cf286f734d652d395093ebe304a4bb050a7db4a4b2c607f9b94ead3f15acc8404dbc69571511590b6a0500bfb67cf1861ff192399c19d6cc729b16ec7213b5ae9b0aaa0abdf453e6838176bcf94fa5e729d7ec36111fedfd428c5930472312e85943de4abf898540bea45253db534193ed76ae9be54c7e6084701fa23e44065f577e06f68ce70677f6e882c868af4cf1123834c47b7c7bc467ef210674c35db18ad6e9821b08c2fac0f378be485b2a93f14eb82c1e3e05625637b73e6e2fae0dae48cf96c29f860b253ecdf63bff564dc8099c9c8b9462cb6bc7b8dfb0062d35502827e0bf1c87dffc2602a2a1a8b57e0bcf86f5aa771052ded186ff9f7ccbfbe92fd5551f1173146f4d86746c658a1ca193cf42421b90032a771ab3d627bf8b2245492d411b0f000f0382ac0916dc216aee0c849a52ad095ab3acf1f9e20825f654f317e530dfc36e88018a2f4adb37f98910a39e7ef3e7c3345510974bf313baf40a676a7c327a263020a3b6c16c7ea9df66ed5494c40551224e0d6b72efcedf357d81b053dff07d5a3c0e9e64caa8f30032ff082804f8886b001bed6d0cc7b5e7f964f72a1854dcfa02d4bf756bd2e60396168fe44be19a4d3e078803be99bbb7eb21e7d09be080d14368416764caff62a0ff99393ddd24d6a1c06943ed05039e1b468a9ef08aed54317d2ba95cc0762bded5882b3d0e0e9f943f90e83da0aa3fcef599c20ef9a1a06d1ca095abe0d2bcd66dfe54eab32835a3efc71e0b5a45f63d6faf3b1d12d96e9569ffba8f3a5017e6902be209fafb37e27213222f5350ec8fefd61d6351144b12a398d41c2990b00bea40290255b3dec6081e6825f13aaa82f03aa77bf16e5289971c00ad743929efe681dc90797986019e0412176eda2eab102d324a5fc0af795234b7b788ddd2a83f6e2833f0b4692877ba2cbb922008bdb01d1a2c8776abb4ebe0561b4626afab49f6756e48adab2920e5458e9704700a68f6ce7b6e81b3587e1fbc519d2aa2d8844e19f72145f85c8a43647e3546c90145bacd1264151ce6baa8fce0f5b9a20e550aba45ca9b61bf89e5bcb13c96f6e0485ef1116d3729ae2065fd48f9a67132ef7c2c20db81f45b55442ed42ad8a0549d18956d872e91671d15c5cf9e2715b111ad45631b1667652ed5dd6580aa95ad3136d780239a94f6501be70daf30e2e827b394cfc1b90fd69efff6158239c03d7148a088eccdc45989326c54fa1d5a02a066ebb8fde39ce15f4f0c18f8218a57fb6dee71e7f9e89c13902aa8146e71d42e6bcf70a6d8e428fa48bb0b475e05aa524d3cf3746535b13dbad1e14e06148881404f90d931439549b09801b60c274f9229130f7924599419b27558c3df93d525dbef174a8db2e6682519a4fc2867393dcbb090714db48bc41051d642077c98e4e94fc53a9a33e309b583ecf73da480768318eca08ecdebe542866be8e89bcc8b1cf757a2f814dd644498c9cf0ef659d93699f782eba1ca7ba1de444ab670afa7495fa0eba137a586ec1f79c24ea0abcffca236d81bd18122cf155eabc3d3dba3e02bf20f1040236ffc51fda102383430a62c7f1730d4c4ae8b5563b614dcfc856cf77397ef312f981ad3a8dc7832a6d5842d303ff079aee35d9a775a271b464db9ab3180086b759d3e4f631ef8286743bb13e544932193449d5b6962b980d949b79fa14d75fd5f28f35adbc0c45aab5a5693778cb99dcbbb7b3b2da4352cd91cdf439fc5ac2bfbaedd57de9515ffc9a44816b391c1eff7b5402a596a8115163736c6c7018448edcc8f3774b0a202a3e37331a4a794350d41ad095ddba886e90adab546b2f237c3879401858cc2bff560d1ea5071261dc91ab2d965bb57937c5311677399c339106770c47313d649956d9429ac52b7010b43b22cb5bc35f74d3372f9a66ad6ab7bbf8d11a704b7d3f8147ca0a4a66a5ee34b5e3c24801480b0c19dc8216a841f2461acd1d579f015ebf3bea60b34f621c05d40d5536bfcf5e695aed51af1a95936605d119e19796489e26ab7ce4af6cf92006370f5794e92619560ae9186eeaaa9e7d5e61d7bcff3ef4aafb53bcf408d4455c8c3c6e60bee8e1721b0a1ea54c966dbfa1f12cf9a622159e615ef73f9cb19c8234ef50d5c65ca92396874c03280d3258e348283be293a2ffe405e8969cacc8a108e0246c7066c598997b7867dbe04d5a5500f474334f33fbd135ad92303d17c606b56c0ed7955149d8a6d181a31cb9c178537211a30ca8ef6e890987500b3f956e377d10d424801c158f80278bff657603fd4a762d134acb04dcd891ac07e5adb2a2ac2721806489663c2d921b2f2148d0778aca2186d2857c2b05df0318e178fe22794363db80f5ce021fd510586a1015ad707595e7e7719ef099f5928b919e018d06bb1350236400155b4e55e15d7152858faaabcec72a89b5da38d3d975637099cabd892193c3a2b5172f734374b0a247f4d58a1b461851434a6bd48aa48b8bde61d1051d26a9d171fea44a386e3b512d0960031e33da24bd4e56e0372d9f8c8c042896aa6e45973b792fa052b43f825224f38b9ccf2a65ccf441adb3dbe9587892e7d53943b34f2c71c34124ebe5da3a46eea2b39cd6ba3989547939289b81d451ad36fa67b7757a916d0163efbf51012614f8f5ab22b4627e6430ba3716ae35002e0c6b1b9e0ab42abecb2ae5f68d8d33b884743f2710bbe6f75ee93045e7d94f65650f4d546b78a0d92040eecdbc96e2484c2fca80ea5427fda853842a16e9e5348e592df876fbc700b1d0ed389e73d9c807f4ff4ab52985366830e3e931824f0a9e146f14bb69e960154965b7713d6038c88be2d0b4bd0a2e4344cb4577cfde0ec054facda45dd9003c91fb5aac8a22c69d3484a1dd438c58d7627e53f50a0112b4b263a6f4609a54d82169b8242610103e23dafbcb3ba29674441e61f3c27da8f17829d527fd5043cf18a050d45949cd0fa2d17251246b7276e8129aca6e48d1011665ebd5f4c7c4a826247ec37ba9d1964d01c2b94b5beb7e0248860a66057da02af4a7711cd60c605a8b5451d3dcf831ec19a06a4ca6877babf1e8b6cb9bcd3f2447fb644ca238acfbf06f744979482378335631d7044a2624c6ac5cc20b30e9aabc2a064740d87580787cf4e6479d0375bd8235e8d87bca93cc146db1153136423b93db61a37ada3a5fddff7ef6e1f463f09bc3df818214f1c930940999f4b37784c30597a75e92502eabc3ca05058861eb4c21544103f60e8c60cf86e00d90a2d3cfd70a0588224614ecd4f3d1bebc0e00760c225c1bf02e2464c004f59c593a60ea6a06d8b3e1196c17be358051879869fdceb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
