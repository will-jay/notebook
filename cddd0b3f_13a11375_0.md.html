<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ce45576b1bbef981f5d721f7c2c5266700a836ccad06e3d53a53821e4ba96c67f0b9b5e35d9d7aebda6910a17e0f1bd11a73af4ef0b2b5d5b26251a7e9bbfdcb27ff5dbf6af05541b56257ba5b7d4d8865c79615d19853be589bb1d101b796d7137d70a4530e512b9d4283b2642088b3000e07a96bf3034c4e612171a1c9a14383e272c73fa392a38dcda9507d947907c9192b5980a4c1306b8aed03479adc62304916aa239218b0dfd4834e2816113113eb9bc906de3eb320e2f356b17384a8b2bc8dfdccd6e4ed5ac2a13db905578067cbbac80f96eeab87d5d1245a52021deea7a1d443c54b1066d49e16007b7b7dc8ffdc78787321400b9ee6c76e5ef8f403aa123e60172c46e5ae12016a936d1d38ad5968c220e1c751ff8cfb3169f2295f1e513abdfe5cf990ee548b67423ec7403d437b1aae868690be514372285c9551e68b15256418543dce78d022a4511e7e5643f7238751f371ce2f9bed2512ae08dc6056c740653ae564f873e40a104ace030cecd66bfb350ffac2d2e5c74c3755728fcd5998b8f67a382f0d96b848689d0d118860bd6cab40d4ec82b2bd6dbe56770e14b9e047b6570558fd7d0ea49c6215f1943b936b20c4b4548b1cef26d7c14252c2aa56ee64b30cc23aa17a7f309b18806b7b3255507c53459bdad6cee62c00ddcd69ac7ba5b1fac5b2d0ef88683d5bc322e26a8bf9a89486e8d1ed25035f8e021adf8f599ac66b0d37a59fcba4838b40c39781978bad5128e25cc7aeae80f44d36c26ee3754a10e84c81ce97060bb36eecdf16b1d1188eea490cca6aa671fba2724dbe2cfa358e11fac6a7241d1d1a34e0f395cfc9a2c973082d01f84b143ac59d933d5b92d5f2ab6f2c6c3f0184dea9d8923e87e3a9149cf8ec5bbe182cf3ffb87283ba4c7c247ad4d13a5bfd3c69461635e79245c2b6eae1811d3c5e1d10b1c566c2e8bed1ea5f120f3c72f2f707eadfb800799c3cc8a30d2fb3f0cb452aac1e855e606370fc2c97db8f8234e63a4ff8736518e2d2114a9053abfa2d40202adee28eb46e320f55377f03c708d640328cda5f75a6261dfd611901ca4a100be88437308426849dcd75069d639e4d88a52fb95e7a120dc47496bb3a145497bb60e32e36885f5704c3a779a9302bce64155a16d92fa4f2fef0c7651a182c90c9927ebf77f0c2a544b04939c2f1c0c126d3dfb6733f32567b2c95f1bdfb9a7f167b4ffb94c451fb97ad6534c423c3904b2f4141537a41b831ccf8d039bfd7e96cdd4cdc4961f9eead629101fe2398cacedd5bc7d978ad3f78af38a192fdeb0c834e12e2464f9c5e34b01d4b3fe7b7afd992b2c1f363d59f3ae6b329e2ba37bbe57bb9fe85a841d59e39be1bd6791d1df4f5582423fbbb1eb9e5e1439cacd350a79449485c3579a5cd7e368f00df0cb9981aa793c74a1f61d4cdfce8ae9b9e0ffbfe22afabf957f2cb020f1d1314a8bdb59bf7d0136dfe3671cd265a6faa25d67043660913737ceeb6c43df07749deddbbe76f07298b3c4d4920be65fdff241627edd4d08f78811b9f7e9c578b506603c532031b5c5a5d61b1e8ce5e6d8ad2694fbd322f040174515e226c83a01968de9e4febfaf792b7714f5d09cf8de2d7467c74eeadd38405875b5fefb35e85fabf6f121c34d821990b97ea17f3e9ae45c894536d5e0176c2c1190884978c0284fcf90594f0ffd8a597cddbf75460243879b7cc39e1ab716853cd1a4938f5029343008d21e04f22f0a142002d5052a20195a54e29bc7b7f94d3a26902246adee5a033413c32125b2f2d62576d1a5c14a251a827aecf3439cdb28a87334403dbe916bccb81b8a217f3ed20c62c4fa51d6d47f2ebf5f6b6a298da5c86c9ca8d8466de79bbaa497f19c6b590cad6443c181ed8de8b1c3fcfd20f56101c312d0b5700f798dd1ac117877ed23634c0997b825f0db829ce8edb053370395860cf793989defaef1918120f10e02016ed5dab09a3b4329f70619806a45ba27500baf15c604fa0184dd6cb1d1c108f7b025d4a898a497537b6bcb3fa442f7d14d1ba89213bc4809044ae6ff60a6c2e6f6123cd96cb743dae2f07ddb5f926976c3607756946682ef081a70211881b2bfe781f059b6edac3a24c35435de13b30ce75c1c4b5fc5f8c09a5d9f56db3d450df16ab5606f2ed2e8c23f1ad34a0b49b29b9d516b799666c5dc623eb97afb00a6ab31d0739e60342fc448d49811238dc942f9d02baf95956976f8cba06e9c1f596234f1cdc7aa16ba8f68acc6a71fa9f9ef83d9c20cb06ab40b35a9ebf887b461a05cbae10b631a8788a96c2caa9229e0a1af4a25b78067d5969295ff603f9695deb327cbba8378272dce31ee595553eb383e47142935e7304c7a450579843dcdde45b76598d1031f06d0df63404e42509c114242929180c7516fdb9c91ef5ee3ae0957300bdabdcf5dc6625ae3eb4f5b2ecd2a4293dd28ac37cb2acafbcd58adccc31c8fc6fddf7d19e7cd66453942f436fe6c0d12417dc8c99d2f44236577e8fc497f8b4d3bbfde7f11edfe74be7f1fe784c55069ab117fc6668ce80f6a947d0b429b9538143bb3912fd9307478343693af42610cb5dccbede80d430c105832ddb97969648e419fb558d01126cfb907bd57a45ce309c0d89a75223bb9ed2fb89143bdbf0d57ab992d4be14f9753c09270ab5572b29248c393d23d37c0f6986e86fb8c91f4b9567e18c4bfecc211c0436e848668c9c67071a0c1374742683c1d6b0df005e7357cbf8cd2293fbde400f1b1cc0b13ade9fb7cc6f8becbdfe654b98fffa83355b63df62559158c76273337f23eccb91530b6980111a6767b3eef44e58909149082d510a29112359b846d5119f8f0af8a2a4ab8bf0483942eefc41ca3d6c85801d03310c7a9022dde8916592bc2b93d25bb76fc772aa1ff0da1b55d1e650d8eeb694f391ebf1fdd3903771e3f0c22614e6f9f45c38d1cf8109e7d8151cada886b5d6ef14d2b6a69ef6ced4135e4d5771c2ba94af35ac3c46bd1e7decc027a1466ea6a33323d9d8e32a259f3009383bcc2de6cac8a5b80e59d6cbf1ae0e578391d5e8ddcc44095ead124133f098b6a45360f68babd86857469dfb20bc3dce12f0b332a6cb13d4d82983a1f379d144655bc5a9bff9c2020b80a5d730caa2c50db9d5afeb6aeed96000ef6492d7d337ff53deed2c4f6181f6cac28c6514873d309554249839168c06f0b4508fa7df658b524181ffd53825f9974d7b210a67d146717c1f4c00b696a87aedcd3726ee5cec2140e4561a6a34535b1228af5b0469c48bff8f92c102d50ba72c52ec31f3f6c58fccd6ee3513a6c8905b20dfa1e3eea24d0084e96de8b4fec147ffd56d851945d5dc1f8130ffff16a7d3f8659c6487ae6e179af4a7dca1d4b5ca51bf39e54b32cc0a2d1435af9debf43ee16ab937c346647ca699935d32dc6cda6ac278b9217d7d98f1ee9f11855ef96db079d0bf60db0589eeb900314461df8eb33b9d9785363e2d7f0e3aba6f658db55ec6b31816fc578425ef2756294feb3e83fa381f7d43a3a21660bf37e77b7d008d0069a1364ed4d5788c6f2106d7120ab1d2e6da4f1208e3400ea1e630655d571a2468a811f424756164a4457a760cc6348621f0f7653e2307817691d5c4eb142de93cf68ba3b4e87349985826882a47dfd5ddd5aa3877535272611fbf07e283ca541eeac2715eaea334e7a4aea93e16b7ececbe58b0119a874866a2e0c9d55a9ddf867ed8f30cc24e5da922e93fec63c33d2a731ea49ac25df5891e6a59ae5279ce67498abe27e21cfab8653b70e82edecdab47e91fa1840e30598794f1f7542d7d85f76e5fa26506a0f2c36d91f24df17268032ef14743814818e2485191e93932f1e2af1e53f302913802b596585c15f8c33350ed9f478d795a50c5bedea9e11ae5049e9c85db5814834e86f0ce4ec90ea3e7b9246b1ae0aebb9a88c02a1f5b367eac5bca31403c1893c326f38f37009a5dd09273d756d012fd6504ade1bacb75231b70b17b7082dc08d9f2d4226997a4a360d69fcc956cb47ae39a71c0ca7d9785a21a903b3edbead17d3a9c04586042d196ff5e3a6c2bf4315b67bc44913bf489621b4abb3cab51e4b6bfa721a274283142f50772f7e4859391ed7d86b4b8bcaf03d7eb882ecc171847fd189da70535386609e96547b6c84a0dda97bbeff73edc121f4468f3ab9595a8f4573c674fc5291f942baa068400c7eabd1f26df06e2caed276b90b6342d23bf3e8713cacc5205bb49960deffd4809aff1f8d4d604396dab2ce1b982bc37f7d62668844436864a2873484b73ae2d99485eae7b06dde0e997f50e3cc7b67fca6d6d551051058fd96c14cc8851305c70aa0cb527a6cd48d45f5d912ee3e71dc5bb8a7d08c1edc3d08780c581a19b69bf3715518a5470109ce4542da8737ee6ec85ad238448e7a21535e1797cdac33977fc08389305449e3511522a851db623a46d386d73ca5db576e9d419b41b1d11d7c435048491ac7e7db4842823ea71bc3d5c740f675d90f5dc86a1509183c779334fd8c3a98be7920a697e90a03be3c7f8101d981834fcdc0609866f12dfc41519216bb9d2950f4979249b02d4933a7e463f81267e5202e5ada6010b2fdf6cf9fc3691c86b0f014e28aaaf599cfc68c56bbe6b87768448bf0b375fc2eec1aff0af064178027235f5dae3c71617a2de4f095236d8c099218421aaf0963abd8f773e3d1edfb5e6732f64381ba6d11b0dcbbb7a4cfb046200d53fcc2278506142ffabeb7220e3417ae281183e76ae77302d6f66ccb88e4eec74402ec1514c0581af9dd3c9eae86a034008867398d10a69fe8a01b4c164b14f9bbf55a27007e648f0ee36559d113661b71c5ebf9fe2db6f94d0f089361c1207b0ab0af32d816832aea478754b782c1771d2dc20495a9617df1ff8549e8ab6a611e76be5a5362ae3a64186ec711ba2ef502110abdd63926ff772a18b22da9159cbc9b37c20ee69b48190df64d0c5f0dd1747db03b8ab5d77a73b13d484ca7320e6410f686c7a1799b33256a76f5f17b162dd8fd0154c84c3ae4bb10e62dc6098fa97f6d246b587e79f85c8972a4b7067a7c61901315ad4c489f82c0e10b20896a302a16f4b3d2e2dfdfb9c8cdbd0e71266b893125173dd958962124678b3f59d27c9737a4856d297a76c4ff91df23980d4d4c37c521c5bf7169eee15fafc5e5b0ac25a20a4dde9ce04c78dd01f79f383c7a94b87602117314cfb7e1fbe1dbefbf648396e85a9d60841ffdbda83ac3062f0d972d792070f4e5ab53a9bc26043ebd438ad430fa39d5781ab90b3e0598514bf04077c08c8227a35158a9fb85363dc283e5ee84bdde5b702b407f54f68b65bde4e55d025436e4f771c9186eac7ba65dd463e2b9e13b9478916ef14c79d34d9f5112ba028318ccdd3b5845e9e270bdfabdf90d7983e9af4a0c9f28efbc42450c6f9dbfe1291b7028b112a4daebb6387a69720386f4b6d4a7558e742173b0fe8e1579381f7228d3cf9c850ac9bee04db6d79090953928c2c0a6e5715708b4eeb80ddd54fc840b27a5a7580afa50ba746052e684ef5c1395ba1fab8c2f04a3288bef9a8c470a57903bd503bea2d6a538fa83d7ca9c48b8a76667051f5c9d68b14a13e750717bfd7f24e50ffb5e82f044c091bddd1e8f7a71f579b3cbacf1e38c19392c04b7522629c368e80bfc21697ffc66b9761d1fb7e6ff50b837368968362d4642bb8d7567ccda0fc77634c567be34205a83986c2846f6d365ad0b145967d5e6791e9c287f9ebf4a0f51c4b6ecf7c27f357615c91962b5684bb616e1bc2b77a1d6b3ec2bc73efb59e0cbd393abe43221ce1b6393dcc9ff13a9fc49be862a65f67c7c175da5542996ce9646ab93e8b02d99ef19472bc9a4605607a88276afb8ffcd8c2c9612516d6c54e5c017b94a424fe5282c37e187730b5b054e65dcd52790d2b1fa70bf2b1b147ac725e7248a8c84e3c382e0faff86a4c9f61faa02e42bfc398ac772e784aea31e037f3d7eb87213408c458093303f91fd73454674cbfcf9adf843bd9558175deec11179055636baec32e9624af397f7157d37258ef194b04f4fd400dc5197ffd90c7d5bf31debc8bc0599576949eaf9b9beed81ca83ea7d45bec68d657207e51150183666739e84831bb9a2b5bf18ac7595fe3b780713740c4baf71e9e9f19ba611a87e49c20d16ec3d4d43b7c4504ec35626ab9917decebc71e79e177a87ddd2ced73808f0755a5634c2f22221c5da938c0225606f7095e26114b20b0a1f644e0172bc86a66c469c6868bab4f48b1c16db5e1ea8b45515690f217047fc958fed9f3f01691898cef5b524798da95571371c3a01b5f3ea77d7e8c706ddce956079bb82a0e96795604ab65b1992ad5572decc033c20c484b6a2ef5e4f2e056364a87a968f4274ee47b5bd5ec44269a46cd1381088ddbd5e831d5321cd9d76ab0c8a3f3c54ba77cef382558f6a2207e9fc465adffd9c0636e0cb20a13cc55f2d11c6bc727bb4e483770e6c6b07fb5ce464ccb9155788ca486158258abe410bd82022700b7558a3f77a2bc8a3b15b10108d08087587d82385007ff84bd7c8f953a33cf0b222f20edf2d708566514cf4bd376b0de4681bb36d9e5caed4e602266a03b36b2776d31531634fd25dec949c914320965ee434bb7db60302fb4467c81ec90b5aef6377333e428effd0d0ddd573d472644b692b6fc89fc45f88155344009050a5bf333356eb2bdea61bf1b24b9eb9a59bbd4919ecbf83dc6859a175cb9c45fb32d77078b2e14eef68869e92e2c554f4a28efae27a1a4ba7b2506f1dba61df2274413e24a03df4462393e7d8c7152c99f26a981623905ffd4e5a3f17c07183e2c6718c730660b5f757ffe72b2a987112b488a5a3f8cd7ea56da0d45971d460442c18dc31e7c675c74963cc856f7c79059530869d4cc0e027e101be4cac27804c80fc8ff3ca66ec2f58012761a464aae617e736c01c1abb82ee6bf14baef384eb027ea285d2713a9488301b32313269dc479f2498fade41c5a220ac40ae70bb1760e33f7aec87f7bb68e5ef5038d1a038e5c357b6d2bff0b1df32f6106a9e2f2563f681902b8f8ce3b04db611433458dd3cc7aec9a32831e335f27ad26f989b89c52c9b6845b448d9c28789e79ed7e510cfb7e9c92bf795edb354473f638afda3a36caebd1a8f5427749243f410e31a3c11b398471c2f7330147bbf3c9a558acda72af9b5f54a12873e6afcfb3cda44285b6a2d211e744cae086aa655724eb445ae397fc3220cac22996da38ad012e945320b29b8cf39252346410bced0f241f3ec2f994a89f3121f89a6e1155700ec29ae20e2bb533f3108274d4179e9916f4b7670e90fe1bc9eed3b2f62a839a6a1cfeb901588ff56febe0839713fa47ae59e2614c1a3d532f28339e2bc056fa73b3ee4317a8de0c04008751a34265a0b29063809762adabb5ea95dd1a4a2fb86222fcdf187f3ca8820027e360e6f7d6fa9ad52648588336c44bc0e69dc64f05faa9ca7847fe65d59015ae0fe469364a685bee89bd9994581b745b84c23180da76db56aabe81cd24b0e31d79e3caf59ebf99ee1f6e8b934a6831d367463e353305ba4a2f862ed32e0451f46121b6d3327a623f1ef27a9de54d9af22fa73548bb6178eb6dafdeb801961556c45324f9ec43a20a1f368a5dbb0db6c43aa91478b2ee6166a7a1625c2d0c09750f68ac6547ab758d0c8ac84058e5d5b6a6ee1d2d677ca50e1b9a735d6b16c8b3cf4a6812be64a778817cb8032c730f46fd15711c0a3dd14531984ebcb39bef0b74c1a713bed19a3ec44d9581c87f6bff3c91117a37cd77e2557835d2d0b36f839d2a3e0c1799e700f2f6088796feff50547033782bc15cfc19b381902c893cb95e66cc94fd8261d93fb12e2124aeedbd1c73c454daee05f190a9d2b362862fce66fb54ea23821f1653917247a452c9166ccea6a990aac00a7d03367431f4f86407ae2c076526d46d67c89b9cd243f6b8e6488f425cf78b51099eeb37ce0fab24ce103d11c36acb712db8e78362813eae64db70070bddaa4e345e96b7fac1675988c93a32c84082b2ae9fe74e42a91777f09c5a05fa47da695ba6b6efed9bfa6ca7b50008d621098d739cbca6d7306673be3c7a104c3d15cd0cbd4402d29782da3e5d6bbe08e37094b1295bc68e1b1ea9204ff44cffc3a043b744c25b811cb9906df48308bcb5c8d316428a15441a6bd5d04213f47e236dce924ce27eda7b8879de2d93d532b3945001c8e04ce62908df16deb0cf89da8827dfa8a8bbc71647833d4010af550f39f3bbf80ab986ac10dc1e997dd3b72b1a2bf090a13a8a8c41ddfe090b450832d19958730965cac683971a0b32ba50c8d01d18332b1f893fa82d239774c73cf01b71239d993bdc888527293a749aa71b1d50927e59e6483705220e19a5d5a55499233b143311cff8a72d85529be6cbdd198312fe66d3514dfa00f885376a1408ad586bdd2b10c73662ade665f340326cab80bef1cf65f7a1754e90ae037339ca1d0ff86997b3edab971aec295439e4d3e5bb664b7570edb1d7a361f132e9a1c7919878cf8c2b77db2a513bb26f539085f37b316fc3c8444846759a90424c929be61c1a4b8a9663fd15e83710a57b2913e48711e0441763538b553ceb2ae4a3c185cde0d4530a60243655349a33d13ccf16d634310bf49925fa38e98b6b76b0485b1f50138b63484d11f805d8c825c31a926b82016ce464b46b74a6dc60bace48801330b0d44932a3a1019e23da67dde0f83daf7ee372943abceadd37387006ea686f666a8939dae3f773f34f6baad546835b9f87784b1f8091df8b99d103475e67142dd6ff2cb66566abebb2f03d93fdcd2a962a35e6f964e04c9bb028f2554668068fa7c8f23cb347a4e776dbfceaf98b68a2a84bda926fa59a524cd7ab44fa7ba954c19cf6bfded402b61f68ac5d08c7676288552c8ce7293e2b27419ce74e8a9af653cdbcf46f6a3362474a8e00c3ce72b4a0eaf1500ed9cd534fbf989a72fabe02fd5aebe8c2ad7af88f4fbcbc27ca01a1bd17573e85d8cdd9776a2a0aecb7a164f40a3922f660e7b9cfb5cf44865e379c5458efe5ed079238136c2abeddd3880e3a36a2c6425b56f5624641e4b9081ad619ff46f501051f7ddd91725bac99e78644a48d4fc3457e700a3a01f09acf0835a84bb823c770ea7eaedd2e3b7381ae36cdb7d4746a64334088bf939ebe6581d89b3d0db9a3eb12bffbe8b5b95b12e772f3e55d883afa8a39e1f3e10a7f42140b873c59ff2552d609e1853e44261d5effb90d83b8927114fc725876ea0178ebebc67af3db883db30d11b1e2d1a5827538d2158785a092dd0b20d2f66d86f6fc9c8d3c2f45cc8b2aa0d2da98ca220d1d54afe5673c9a0ffecaee63135dc5880760c7c6e7dd3879ab4fb7ff4881322a0639eb4924b209b1a89285a5a2ac498db731ac712e43f9819a0d2a438e27a1f228690f4fc04aafe3ef1350ab6343a35cb7624ea5f31bd18c9b6c06f5a05b2ae77079f3d0ba753619be126b3fa73cb8b6a0b4a7b5b7b4fbd35cf91933dda0a5472acaf47912e1ee330c3c16adaa3034c4b265481b139f795f3fda21e47fbcf74b0bb0c24f9b09581f75c072f4a75320aeb7ad5da6f1325ade15a4f2f870cea89b5376141bd8e9d6410d520ea7019709bf11e2b96235e89446387d32cfcc47183d77ee764183d57c842b8081c07b6b61c792df9ffc22f1d80a57afcdb676a763f53a27e73a17eb414ff013370df12f866e3fd72b66ae6cea996ab7843773f3c3e86eb719f959ba7273bf7ab951da8bb8eb67f29b5968e160ab5a6ee96e1452f1dcd3b5e2efbf440b1aa6c1433122d766ef0c327925da2fe1ca3ab7d10c08dcf868c439d42839c3f3d335665f6531aae182833ef0adb40d72a5ed12ddc937d4cc6f6811f68431bf6ff4c92455b2926d16017d8c71781b51ed8e3c0aa57b358065057a2b9733dd114bd4a75e645572d08f6047fbd0083576f6ed9dae2f474f41b1cd7b618a53802d4df2cfb705c19e93af1106b4528edd47f2dcb37f5a276981ecbb178cf724e6ed821f4e9bd391c66818d7e5d52fdceb130a7c9257742708536240e8781c1d4e3dc80bcc38aaa7a209f4707c29e6d7920a0585d4f66cacc5eb7cb54e7573fc69d08c0495408eb5b1cf588b5348b9fad5a460275c1a48e96837d5c67292571ee8bc17d13c1faed1ea50b3d03ed0231d86ea2adc4d52d4252fba46aee479bbc7b4de415e91ad8d80399c3649f2471fae3ef128c4c8f7fa6e509b35e2f4f82fef697305b343720ee86303cc0ee4da3178ff8c21639ee75302c6e3a55424a2c287c823027b4df19322ea4b0688523f40f8e582da27438b0888494fc4a52f6e2250e8e0bb82a12c2e7d868560254db199bfd41a1bc9f1f6a4a21e694e2be9b2925c6cb65597dfe2e850ce51b051a43097f30206cf6efcfac64d62c9568c9e64bb982125182beb4186b56bd67d3d26db64d50d921b3df77964813caeead3dbd86888f8c37be866529e6cbee6063f6c9a93a1a585c02ef76e33535da7f699d20d68cffb403694c1a7b04b2ca087433f0cffde541682328a0dfbefb886fc150e70232623520643ad4540548b1a0866200a0efd4a219f7578e0653f247881a8156df71056b7fb3c7ff3a23ce73edf74958c8173277f648fe7db01b2feeaef3c9ac7104b9d833502b01fd2301b631b26c5ceec74a03d7a685d58254cb88b9b22ca0f42d2a5855d463a0cfbf328fdbe268221faae7a7e52ef9675b902a3ca673c34642ec37d5be1d0c4d1843ae04dd7dd8c1c8dbf8e84f1b69097b36350f448bd5b0b42b2e72f61d4e678df133769091b610c5e0b6d1027a28d802c020dbbcdf1dfce14790a8d0cc448bcb71785a0c9efdf952b0408bbd51b5b4d888afa103b50b3359d71829aa2f70d11e8f8208f677a1278141404d1b13a5a7b3ffbb608478cfab9f69d358aecb8916af39c59af05fbbd1982e66215bee820c337d6cee86d2fd5ca68f1bd954964e0c112936b031d4c8585ff2874dc991455084dd49cc702ef0f462755d17046f72ab86ce02ee6ad25370cb09171f1ef6e94a2058d9e448134cea82a6cc2bf20f279195e86db9b8b04f0d364ba86885196635cb93e3d79956125ec8b8782bdafd87f66a9d8d583f0ac4deab2e31755971170b102fb1321cbb533442415069901352cf5bc288784ecb8188daa333c089626ded3852dd5820cd1124c035ede43533673091880cab357c941b8c20be464193c19c6939f8923ba789056adb04a1dbc1171c52718af84be09818b3c3519d4f23b879ab7d6d1d9b0fe3cb7d385b2bed2925a369df248a80b5945abdea7b8952aa3a68f9cb05453a1f71efda3c34dc05fcc0e9681a6cbbaf91d55fb4efe674790b9be68d4e1f58582744d363a3b850f2d0afc9d303d601a1df1a47637a5a5ce9fb350d2d7a17e9fbfa488ea22b3acb9ac474f854ad6473bf7c08de22526d8ad90360279631f9d20cc9d1028ee063f5e06fbb083f23dfafa55afb77167c87452b91724604d2ad9c7e49cbcee95b4153508b56a405888a2bcd484cf26697b1aa2101b730fe7c4393fb63a28a996bf78ac117d74f8946500ccdbba04b9d8e593ca27d14822a5e011d6b62893436e329c12308cecd70facf712336e39c007de756ad25b5037cece34e8618be9a4ba444d2306d5ed6e2682c02c7794510f29c949267a69a33a55f73b6985587e4d9885509e569ecb57049f4947d0f7bfe20a5f71f3eeca2f8d8038f02b176beb5b6b5d218a989fa70d4b00b2e4b54553a53eb1775a230bfa5c34da63dd5746820b31f0b2e9428aaefc47856ae8b7483bf3387995cb7a15e2d9fe232f6638ca7074287a2c2d9da22cc91819f0cbc061ee194170013b88996c07a1764007032d885f67f13d78fc36e70c617a43dfdce9146c2cf146648ed7001afc969eb23964808528b0713f7e4166c058a880f6a433b204933419865313570cfb39bc1a1b4df29d212dc48bc1a2ebdc0838fca8ac6c54877be460693c5d2b61b44d77a84088400e98aa285e2830a00c9db2836692801a61876247ab9f66ff78dc5b8ea21a54c74ec2a7e5bb53754eb783c28084b34a3f4303d17f31103b963e1744c475551c04f25454d40d23c1f912a1be7a1507ea3712551569d07542a1e95b9b15fb827932a0ba23fc4016e005216aada898364633c1d05352aa5412b1012c03ee36312600c778715739a1b0b8aa3b7d5ba4c39246e8001805061788c73b572b977ff6ec251944c52cb63d493b12037c54dae8f4a91b7aebb178d1fa9b281c9147c8e068edee45080bd65ca51fad30d246519f30e6418b618f1962267f9af2b164d04ff4ab0a02d82eaa62d54ed69c3ddf9cdb6887e4d0e4304485cc8bc1080a2f1650c546ac691d728fb81d92306bb5027a54c8eeff28081e65ee0e0b96586797b2d9efabcecf6a1cbe7e73eccddb85a5ea8991dfd6e5a7b990ed9ad476f9f03e76c1a73d813aa99d371ae767ec0d2e8fa5e5249f04e0ce4a77143776e7f69e3a8f639bf7fc0da9c4279d72dd29245ca937ba9226c8f9b4930a1c7dc824030c565a55312824c653163a5bb0a2f8c42eb9f08336060896263434c0a4a1054be096c83a735e05fbe84badcdded2a8153207558034271723e6fffc1a16cb26526037f3d2c82ead4a0287db9f042c2c95224c0615d5dcecb58e5c7c6890857c1ddf71a8f209ac50bc0b1366612b66da4748f892be5a0012b8b8cc7da0eaf52d5d7095eaa4f5fbe3474533d64ed02a35286782d90c375017fea2feccfded4c5b161eba8ba8cd3124e46eead98c73b74a580c4625b644f777bc96f1b2560cba0786b71edd0f40d1d3336c83d08283808c32e9cf8de612e84889c48cb6b020a4afe083e7ec30285a096955f73e1c5fae637e271316000b6fc8c09d60ffa639697efab85228136cad6c687502413df634442285f1e67c75d5eb007cbcb321272494bdf48c29ed679d877ca04c0f305cd0a5828b8560f561bd576328118d6d2d75843f826c50774ed5fa0bf4622815ee7921ac94d4ed852f511dc54bf93c1ada68e79d84c75a392003521bfc7403d96333ae6f1db02b9c7a50a3ac880acbc8af07d4867478bb8beda1b21ba7295d2774d5159d94bd987143396ebf575e76b7db44fde90083a5469b3b4ef86695ab821acffa970b99bd603533daf9959f3d18bbe8af30b6f7bc5e8509a9b56dbb3ea17dcb0e8b4035034eb0a0acd2d767540c5cd09f588be8711802765b9e712c5071fa26c61e280093ffd6267392fad7e878f5e2472cc06bbe7c85ab1eb9a4472c2a770001de361badb9b4f0281e675e953505d7e48ee01d1d0d6d0b14f6ee5d89cd0478079148081c6fd3fbd34adb6a3b16b974ee0328f187ac8c8b0bf0c4c082dc77d7a19e1bef0a34667e750bb943be072a8265fae9336b466394920c21765fc793c0d28b3675cf4a0cb78c2d651a2e934e74dfc89df893bef67f33243c163a215c00d092f92b45eca8bdbdfae807d0492c536be7fc83b8f0013a8df95ec0ffdcd32888c97979c692f6f56b15873c1e9c233904499b1848c7848e79249e80e987f39f710eee35b3409ff1d0f224b93b8d3b78e1f0de7ff80280127c475a827f10a186240deb6650364406cf9c4feb297e61e11d80c963a8e2b2e28ab005e07eec578aba4f4b2236a0fbbf2d33fd50b77ff7c63c3e4e6d6973ae3ba8ce1f05f9744be3f183c81a9885637cca7a9801b57d748284277421652566d5cf8a8b2ef41b3932dd3400797ba8e1d193d2cda24b4bd54f4fec99dbbeb22e037477f4a910c723353d9ad562e783f68da684399a46af138728c486a2c65f63aeafb9e999f6bedb52d8c0215b2308f9de0a65aee0befac3da08299561563182849326217903f811782489f120b55bc8d56087f7fe1de1bbe381a050a2d19480acb7a01e7fb2bcac70874d4752156be47a593ecd2549c5e6bb715711e294bde9eddfd5671f292727bf2a49e12b91c4db879382676bcae90f26fa42c7aab20c77868c3ae61bda32d85995d283ae7949ee8341e6029aaeeace1e569f6ace78e55cf5ca6f1acf79f66cf036ba6041110e198c7373713609c2ed923002e1e5630ebd664e29995934f5da263848c0bc10f09b523e118f25423707013371065cb35918ff0e565c7f44258378e5adc63504c59fbdb62f607b34d370134394f46b10121b30b03e8e0d068ebde2b1fd20870d6bb059a9a88c054ca00a7d9110db27ce4b0237aab635731369b777f38c34f9ab01bf176cf7422ef56dcf2ed7eaf819a397d46556eba107e78166d334ec39a0b383b7cf888f911ed53367d5af5ad246614ce69adfeda56ef4d74900c12b44d8a7f7d6900a60055ab69b2993f21be655b5c1359d32cd9d814553036cb5a1cd5cc9a247c0944d2c8fa4cb0504b31aa95b928c5b48dff712b4013be64be1711e2c7a5dec7b58cd4d4581c7bb1ce09e00231ba9a63feac9c6d5c54b654c1d3d9535336f76bc2457c9e8238906df0b2f2e115bf0a316e17fa45fd68603f8374864d33263124e509adc320536d39453b717a79122793115b16b298950ab61beefb28c2b241fa06029500e0390d66e576f5f83b609131d313d6ad6bb166b327308545b7535cfb5f4776353a1fe82a4d62dbef16ca654e232bbd57dc2d4dcfa55f01a905fa491a5cf6e62b674bdcfbba72bf4be0d75648abb5ef9b8931724b3afc58ab0f22cfc52d91b1be03547b329cb20d84ba03838f2a0a9e0c21dd6884ac5ce74cb8e66795adb051cc5834ae31bb137a72d93594f27e903156f3ce0616b8c53691296c269941d02026edef80a35a941964851d0267c287d9c0b46fd83be3e1e43011c71a4eda8cd6c1afc74474374a22e1ad5e9768659a49f03b8d08c8837b102616ecb6cc2fe0e32dd4d70e0ac042b428f152061b2f3593af2cee2b7f287f2f0f91e36c0402fab6af41dfc117671154b15df74a4b3d9914185b5c5ac8c3961895ce06f1eafbd03e668d43d123465a44302cfb5a91a1bdf49b3c8292b84ccb1c45b929463bf2bb6617e71d735a7d53d62a9493a1c413ac3a8941a435dfffa6335103dbb27931c8a5926dfd3cfaafa589313ded7069452c3bcb0ce96d39def3259402f9a72c0c303d1290450547d206cf016532511bfd141e634796908e920c38a4ff41d032c57214bf56738abc919c4321799c8bb8b5b274f3d7277bdbcfc4e2929d06fd4ed8b9de59a1b094d99bee6125a79c826cb48bdf444d3b32ff62751d6b5aa8074ed16ef81c6711e53dcc591c8ece50d1851d48ba85581b02eeef0ab44035a87bd6af2d5bfbbaed9416a3534dec4c88f958a617675a86d794fd8b22933f0e63a2b51aac5628a5e433841d3951ce949d6c0fcb27e0f51cef51595f6838a3f80953bc004301e9fcccdbf47b065698d1f29b9bd514ab2aca5b1c667480e1e45ec1c1a3a581eef409035ce2cf4f35e6a366ae0c14b3445534ad0801b286dc711594ab86d96b4e282c66a8fac50f2b3a0c413d6796b95db920f1d5ba07bf11387ca5db750ca562fb6a58fd316395dc0073a621f023b8707eeb96dd66629117d76c7b86d8a3d8cde28ef5d22f2baab3cfd1ca206d22f20e19fbf3948d2523a25b0f0094a7879130c618ccfc1700d0c1a03dc2053edf9c2a401bb502446327fb0c5e597af79c2d1fd46ea41ccbd5523245c038a7c2ef0d03b6a9bdb4099fb3bf3b3318763b69edec30a775b3fa5dc749a23ad5d682a24bd821dfc859f4a6ad43c385d5e308a16f63ca6e7fdca9f1435a636e55ef305fa8e47442b34a70f5898f551791082a408aa71f92fdef1db99b2be398331d67238e2db09dd2f6c3da8696bfa59fa8c3275e5bb8471ce54838ec54263f8a104b19d6595e5bcbe244dcefc66d5a8be020449fbe8c83b9ead5527b3538c23f49f9f6ffc9500293d34731948c1238e781d7e64ad1e51546933d204f573d903600e079db1c849d2bd5eda34e481e425e2419d9012f739aa78273c1aadcd2356220de1a9a1815159ef65603ad3cdeef0b1721a273d7946d104c2899f34d5481bab74076613e1f0e215abd6cdc731be54e42a5eb3b94bafc8336092e3c6d67b60ffb6a9871ff7ddd34ae208662b939dd97c884a901e65b285fa93138d180b276b2bc1c893f2d8c9e6d133f2a17e9b6b6b7e33c1015e6632ee654ecd2f8219197f5cae9ff61d89f6a9dea2ffb3fcc00cd3052716afb34371981394e0def322947a82e31e06bb1b0f2028a0200dd74927232bd3ffee31f08a8ac637bb3076effbf03a70856427bd110174d3aa135dd325300afbcb2ce7094b9ca8b2ddad4a0e5cd0312c1fde5d93b18060f2f0aa6aa13eae0d44fcf660f426bc5a83182d1477b498cf7b450fb4da8271a3e981f52049189bee2fa8b2cadd60fc121674a050d9c8663f1c9abf90dbec1825e1c86c1a3ab22e2f40be48f5879d19720d094465c409cafb4abd522c8b4eb46d5d8e5fef90ebc24a08a641a0a3d954acbc42410eee75e0b9a5346403b5f94a6836f559be6ab65290bf28e82efe8fc5aa87ce7d996534ed664f5e12eaae263d3728f1f81cf3be5eb0611981f65b6000c0126b2475b007863abb26dae330569b429618c0b1dc9083c437c2fa2f6fc300fa2be011dd34f6bc6871b190264034b5cda233a2b762d65a511cfc0252b78f50694d24e755c098741f3d0b985a708b02b875a828e750c5fe7506fc25a0c3b3a07d5d5903c79203b567ed2867287449c4696b341654ea52b3a735e05fb7083c8401dd697ba7ff8c2a373fffe3ff7c0126f382d84dff6d0b2af924e07ada7202bfdba23563a9fc7232b945a8efeea998e4b3ad243f2ad3092f85ab7a09c5b2fa62069ad43ee2ee1d914903d9c9df6868779d24c20647f91bbad2af0e80c46cff71ea2cc5ff71b6e9ce4e511a9c508fcc71fdb854f457ac75245e40925b3113f5727ca2c68dda98480e28de9bfba64910d5cd7d71de34f13b5bd93645fd1082a50fab73870ad0cdfab3e5f27f3cc2454245387de4b95c9ca4542b2762b01d9e27b40fe251c07e7905c6e65005d9b87aaa7e5f79c5a1c3185d93c8d5d2a7c413ff2aa9f945eedf78203a46a508d7e7d45f3b4e0bc9bac45846b6c7dc4dd6e4df4045e70e968258e491e443e944f1dbee55d5a4be5fee7d9039eb301fadff953c1b8fb7d0e9ee0b780f106afb17d93dfe13d4b3016ee82b259899ce8879137174cf96bc52cb3b3e3fe2af8ad38e90b5826ba558618b6725e4cc049e33c3e1c75332e05d0f3f062f9f04ce6d7a83bc456850a3950073491d1c04e92cb66b03747d4fb43a6395eca1da7c4e8e5e76f016c9d9ad5d23c0a34d01bf55d638c022d7c3b03dd5488d62fb4f62f5d3a41cda8cea4e7007a2ec9d61196e8af8355673fdc59bd4fa44158973d2fb006a89ba2bbdd0f99551422725b4e81c82ee2c7a840bf4f84fc7eef7dc1305ff9a7bb8eb90269c2ea38cfc8078ac86c00270d3c5b5b888dc8d61ee58483dd21293a3740c0a6e2f34481b955563d0d6c45f72f5143aee53eeace0d66a063f1e61bd939d6f12c267e94f0feed5d0596e06eb0f223d767362f6c0af6674fdafa9791208601aaf9e3c66f9c636f08dfd0e37a38167cebedda72956031cd53ac10e79c39adb7879d134b1e44bccefb78acd63d2bd03f769e2aada4645406b6549ce11fabc26b9bb9d2fdd5270ccecb514b3b490fdb818aafd40adee2b971abcff174057cad79d4076e366f0db4ea459fd9edfd0171338ad0ebd35f6294f1633809ffd2b0367b02887bf80cf71d53883dbb477298d1e5c3dd616c3a89fd18fddb5d96ae3a294904eacc4e4826b0d798848289f1301f18ec97b65e9740d4eb8b22509746c5a248e799f118c39eb82ada38e362c8e796a6dc22ece214c2e58b2862460ef90e73ea4a605f823180a615f69078896aad3678acdf221cd0a1c9736178c337da2e708ec1bb1f220bfbbab0555b0af4346ce5cdab97653475d26e013791b8036eecbce86641b3d07bcd3931beacfb3c0fa17060b1724ce09607f02f33d8d899e945663c34d4c4011ef5e81dfdbbfd93628e4caa8acf19ac6e2e93e23e2d4e91f5c0e9338fe0d4ae358272cdb9656a461be083d70e1289d452c5e5f5f7c1cd60fa199dd90dc60403262a9639e74cee4b5f04392ba7f70e8d074fac4f94eb63561c9562ea4a13888916d5399f0f3bec90312bcce04a870c2ae8d0e63c693c6c2f0b9d4b68e96bf042b2f04453a4a7378f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
