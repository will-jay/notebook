<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5409f8e69ff72bfc1a2e3fa5cc01496176b1e9651a0e0b61e92274d6b05eab998332700b3a8ee09f9ea684ff8294213c8960e693761f7e3221fe19a5812781613650a7dc11805cfc0658fea67b5fc52ca3aac067d6658db590092378ac326784f903a046fe218efb086a77d6257441c4c5951b5016b2a4baf8d28a358e7e7fc6ae364d05dcbc8f5259a04ee92aeb0c033f3e3675328986c08ce3fb48904ceed021de975b624b42a32f66466f26831ee571e0521b15f6dc6444cffb01098dcf9d09e257016bcdfcbd65a9463bfe23dbf55c78ec3b03127ce40762b2cbf3fa86d1a59b2f466be70d760ae5c1a0b23b40cde94fb49e8684ef777b3c16d2813e2faf70da6907b67f6f2a1f9882e8e9d72b3e49631c4447268c7e504dfdf11032ddbe569936343be07783ee0d047d2a23c63032334672a3b6091abb287bfdf6d2661aa000702e3c742fe3f7a7ba27b591fb4ca511d86d325ac06a5f04651e7e13b8d3fb6e6a8b74ad844102426e29859589aa93296f30ad899cb6e00546e6588cb3756055c02ddba386175dc7cf0f26d4675f38974bdecf6a4ad65faa13d17a33469098065ba0598294698ce9f7a59fc7f9303de8fcc6f3b06585a3c1d430a71eaae40820d427ef022235f4f41b73a9f2c5d4723430ebd0df65b477e5f71d05c285b271373957728fdd3c5fd9be00f788a2697b9dc1589cf70011308d606354b1118a9dc0f2fdaf6a8241fb0c8888e30333c784bec916aaa6ac443de9056545843f4ea03b4a88e5db7759db68d9346cf4ea06b76b2c38f85895d76d8bbb3a289135e56c45e7f9f131c53730139e17248c5483096804b3f874a7c6be26929dae1933142f0678f797cc14da30a0a5695f6d308172e9740317ead7c8ccfbb65b97e97bdfefa3985bbf1b3904497aa21009d42952ddee5b291d6fc2369a5a1714092a815ead977e84d63f7c253fd490e30d0b4874b8ff66ab4d35e45794720ec6d6af2cd2365f43ff7ac2e2bba93f57c53aa05cac622d965018e5901570b582ef5dd5db07761ece3d22289af75d7f7a23d0743a4a08d47364e7723464c606b7dd7154099dc3126e60b7aba482be2f694db84e3c6b9d1768eefea573d63153e94c11732855d5e58c316dbde92c4e2e13f2fb1700e92f95157184bfff6536dd9b35260854d4aeb97ce059c89bfa193c4a80b07aca364c394b52d254cd1974301c3692e6629ab6bc89b00ea1f5ebec369a77896349f6dd644de3de053cbc1745f4f49b28f063c0d020b597a5589bf7f90ef35a52a4c7b17f7c362fc38264fa6ae2d8c65d8eab0cb9c8ce367b06c6182c014a83350f79eab54725d876a8cf82c90afe4a611cbe79378795a2e3e45745678be30e4803cfa4543cea6fca2fce8239a10c17dbf9958071b5eeffff1b551fa865fa8f95ecd3f4fa8b23de95ce61f58f31cb4c3e59bae56a4d6b80f2bb707ae6aa39e0103c8f3ce5b50a5f0ad4ea0c8be817e5d36f803b0e70448cfd3e3a462e8e402917e4514b5b1035eb09037712523cee2dc16bc6bb9876773c31fc46069463c268e315ba86fb5853576878bfb5e7d8cdf479519579f8aa24ae506f65f4ec7d328625e86b8f5783d8c3cd317f4d58d6f4054bd4d587a343d33d75d02d5e088aae96b4ef8a5a7396f9c5dadb9481316f8a1acab7efc08057235e7ac5e107fdced5430277349856d2d43bf01fe6942b3a10255105a9b38b0105c343e609f0192022a84d6e45a38da4f23fc6e6e11d3381521331a53f01154c83eb9ad33b58fda9363e9bbeb2415da527d2e1886161589950dfed23b6030a4b5ed685afcccdfcedbaae51b4a6108bcc95198fd11b7a851a57b53580775cd247432204837b1d262dddee83734d096501911659857401e5e9a85755ae090029913c6ce59471db80ebc8f52eaa5a8658b41b322969e2617692e90b462ab71cf0775c96c8d1788803804c94efabda341a98a568017551e80293b780c1d7968ca8a2b447c20420199015ed6e5782c9c09931af406c56bc9ca39e5a4dc8379251a55327dab98e7642b4d446d7d81876d98ffd8bb84115272337ed2614bac58d0998eefe406151a06fcb7a3696c3094964901b73c53b93608b31dbf8cb84cd62b76b9e1feb5ed2f156714c672809f45d4675d278a581d8044e0da3a86b555d5de8669659d49ddd84b678d56963bf299d32978a9658bf153b5d90d6362f6e82161e97ac08e3550b560d14f15f021154ed058f416d2db4c959e216faf42758a4f0a6cd98b32b04ceec3e61e26088c46f56f6712b9942fae1694fe3775e3740b097707f5908d59c26826ad89a55087df7a3c6f804c7198dd30701b980addb1d9ac6869e315ee28b8f0ad447b019c0f05fc5957787f21d8543311bafae168741231cc1ec764739432bb09c5a30151cfe907955fa67020f185d2d9cafd68c88850b2926055b5aa7a66567ea87d674a58ba53e7dfc83fbb1febd8721b2192713945bd790cb9b20dcbd00115715456b2ef98dedbd1188c2840a29b78728114c5a66c76c21aa0b200c0d726b09cb481e0afdc55cfc418f38f1a70c6d62b54552964c4353d52130454295e05ea6e50be9b21dfb857fa15ff26cf1176e9a5fe3ac1ccff5725b8d0b1ae381db728d5295a54e8bc38f16f41e8a6efe6d9aa48116e6653d6149d27f920d9324e36f5b8125f4598150a136e7ec16c11c3d5d830153ae745fc53418769b50c6bd8f1688f6a7401b6f2d195521429e1e8c44109a3a11a1a339548dbea7e986119bbd9bfad020028255f86a0db040677fc2d748905b7505ea30c7c8246d54c5380b73ea392cb02c2c1ead12fb7081b79bcde43f038afa22a7dd2bab63fafb861897c3c291fba2a790c7792568856f990327c6d1553575c860a906cb4c2f9d76d621ee6ecb056acde4930207db7234c214c157bcf8e423babf56072d45af165ff7741f0d10685e01d9138eb07bcd09549b12273b2ece1c427161fc9b88d379f628ece4cec18b61d6e78d6541adf34bd60fd681dfeaa822b3e0cd3fae45c7312a6da48db6d9ef067954b0b2fcfa2da22245a629bf6081fa7f8472f711649cfa267342fddb277b1c3912eab74b07d3c5f1446dd3fba0dbe3bde13f1eae4cc81063c4ff2b0e3dc7760222e2606c181361b5f43e1bdab99849e2c353bbb57aa7ea328b8ec22157bab475dcd8685a5cd4e4c5010cfe45acf50af634a892f8f109e593d91377ae234c5c5cf42c9a7b9234c3f1d0022483c604576b4ae2b1dfcc7f65da2572b1d7075579ecee24eff85bfe535304789c89bcab22b40064874e5e698c51abc611088ec18ddb7a18ed2748cd9f17f79e6c73a9cd4125c1d4bc8d35e963cb40218f2db5adf25dcb932edc300e3b8e9507b5a7c9c136cd2ff0d9ba177ceac46bd45f33140814853ee39ed44e627d4b897dfc5bb6453addfdf742db414e548595cf23bf6ada1a31eb99fad80af1ea7a6537f41eb14a3c1b5e521652e6a6a886973e51f088d4774901cccaa4fa8a70568fa93a2055ba987f651335461e52d750db5e5fddbf69ad30ec4d9629314fb47a79a1e6b8ab459d1cc589fb891f6b787975bf5f5f8a78165e1e3a691f6b606b730e6a610c088e45552643fee5af73211a3ac2a1644dbed3981095c89d90cd6a5ea6d63ad2d6f56069675b27f4aa1f27854c761cf91b728d660f6a95e22ee4f900948b8925212a0f9b1a7950bd62390bfc6c9e786ec4bc479bd77d6b874586efdb4bf1f50034b019cc0bd113535b84e17b39be185006e21285c12f1d765d11b14a0a2f01d4949623421dc923bc95ca3d1b4013ae05777d5d29c56a5344720164ade1143c685a1e4f1de3e63ac1160d7b0f903889e7ae6cb2e3066c5846b6bdf7e12adde43e1d8ba7b06e08d4e192d0be0d3b514a7ed8e4a0abf44afd160e97caab38bf88063407588495325f8069d19be8b6f1d5f297cd24f8aa24dad4e71a64c556d169aba0845c729bee3122c7ce201309a2db414a75b00ae8774b9270808f54b16fb85ff854270c7193cd35e7fdb1e4af93e7d2234375e91011d5a172897d61525e1db1ff8b0ac6481cc2753f586f66ed2ac85681a61e261df7c63be11502a34450c6a270858cca6327befa28bfc57dffd731632719d3870ad57247941cc93c9827d89e5929b87a493aebc3561e5acc99cb9004ae03b92d69332278d1de7f7e7fc8f09b5cd194cc6d7a0ff08311fd0ffb0c6f9162b6d043f69ba72b26bab993a79055e2e3e12eecf59db2b467a642cbd46effb8a170b96c50c0d417df7977c4433ed9914b907e144b55d561222e96ee611038cfb2a7fb9094a97efdc967e8c1a875007809e92ca5f483e8148c8cdb0f248f3fbaeb708bff7749f96a55b8bdcf8eaf0de43cd50ca198417e3039b4049ddc12e33ec5678198a4c208b14a3f42184b885abee963e73f5f4cc22153fbbaf4c317cc0d6de79adb8642fb693591f7ba0be948cc1505a49548651b67696e4957e4ddb42171557e1d7c13dd577524baa911502cb16d47e08151c4e9e8202aac705bd5c0020fa2be0895dade851a4a70f451ca976fa35823ce058f459a8025b9fe83003bf565ee96b72a4890bba133e68d9a881aec3eec435fd1908cf4ca5cf7952dcb069090da03917b77b07de870f1a89f05a5124ddf6dc7c4998e67a42ea57c06cb1f288ee633443fba85d8fde03a178385c67051ef43fac7cca5df86207a16cd93b39a9a944ffb006b0dc4c198713277cb44d297719123a119f16e7e0d73bacbe48c08e705b673a1578531cb4a31d57bc7e61cfc2d1818131dc3739ef5bb8cbfe7a508bbbea513fd4f09e21116e0093c0004dfe5a6a0dc3f98f37069d928d3b240d4ab5caae302ef252337371d8e52f324a39c15326835c3fec9a5f2791d5b067461e95ebbb238b8a17c214bc70014db798271416405676294ac6b5d539badbb5095dd70f608ae7fd52b71f3b1500bf8f19d316f4056fe9d5a352e137c28698042c432b6c876e65f1894df32d447d36eeb671da936a673c31692247abb096fbf6513dc557620249cb157a5823114a3c899d667d490cebb0dbf1061b2a7ac16a73eabd93eec2c8eecbd447e50220b494b7da21fc05b13dbbfdc7d9615c77f0f94e78e9fb7d6bf4c3fe83fd6e65597f3d8d8abc8d5c5b10c6f2db829d6ff71412b92d513396d2b16590fe4435bb24147b0c0b834361f931bf3ad8de9b8c05ee9987581e9b6da4c00d1f51d9f21f51ce46b2c41173ba8818ce5e64d0559eca4b70b6c16d776b3d2dad539b0782259db7371bcdd80df300c2fb257f882e16c14b67c37a08f97fe1e6e5667f3ba4120c6afc3088cda42c3d4d59561527d1ac8afb44947f2dcc6de06d87644f6edf2b44d0dc9419b87109493b51f37d4ecc20169fe63b09f1cbfca15f45d57b9ab6a1427d5b2936e19a616da651fc863904a28b6683f607c0ade23b188d3b6954b106967d079492b491bbb8fb9bae08ef7849542d4ddf56c448be204309628c92f772b63c482d7697e2a21c980773f90747d21bb461429ea9a2b11a15eaf04162dd05ae773e66ab650312040950223ab63c090ed80ae23dc8484b03dade017491e7890703d086613690fcaf22a887aef46d20514ab2a4c4d9cbf3942ad4a4f90807c9db58062672c99d852ef3ef5fd0cc86d53e1eaf1c40929dcc0408df9ed634ff226d3ec6df473e2d3170d32e08476e8798126a1586e822898864f531ec917af68dd399eea3069437894fd47e514c4b2eebb527562f217e7a6a5e3c57fca9ec692e25860fec468b3e8ff9a1eac42ffc86cdd61f3cac983b92f01a2717cbafffcde4ab047b35951a6a2dcc328f9178dcfd06bd7f387fa5747769a55bc83492a50b821deea140c1d92e4406c0a6590ddd5ffc2755cdef10ff081280df180736aa9cb27070cdda79ba93749b45cc5dc89335b5ff5684ae27ec5fcece7744841fe7063efdf93a9410ef0e0e728779d624dde0b762d990d00cf63efe256d519001862247f6d7847b3bdba8dcdb111467706d10e46120b9d96029d17bb4aea1e7f1a1b757ceeb9c79baf4ca90a215620b79a72535b95dbd648225ce627139bb17262c01a1efecc51415f85c7b5c29118f1530fe9ceacf6feb4b8ecc1512cab6984f0841ef2b0c07a2526c99976efbd920595b71c3544afc941a4ca840b0d73b2d263da558f5b1cdfa1542ae251f6c7cc47981c30ae038fe90b14b5c127175fec20f07adf13df962134b1a43d0d60eccd2929fce9bcbed9de43d6436dc06d3c8073069a63c53b660b127f1b6d8f7d745d343f2b59c28bc65237cc78d0803f6517ee9b961853e4d33b664bf51b24ae28c0dc3b3c79581e986d80a1ab7199f219baf47095655f9e3e1c4d7b8ccfecdf49b661de47207290183be0213cee47991a7ed9a19a96d71d040676bd520b25f0aef205c7ec6f767e938076dc66433e9aaf5b9aff532a60a83c9a3d83dbce0f0a76f82fd1a962d9c6a83f5fd713602bf5f1b1412b040b03f98a64335e481ad78b623fa9bf5a9501c22ab96ea2065d61aeda48f5106dd7f012b5d2a10014b88eaa20e07ade0b7e33e7d39dfaecca04d2f5ada1edd56c0b6ccac3da2ed659e3ff0b19dfb91f6f1fbda2a88cdc472076d34373b9ee4d2d9f6571a596efc5e476659b04184ecb169960048bf1268eff31c83039af1aa71d4aab929ef1aac6b28c76e3a3824385e0f5e530474db8cb2b864455956d950e4982b31b5a89487ebc70d0a8d5e37ee8373094b8326de9d07fc564297f52298f2306cc1da63e45da0935c3c2bbba5cbd2e669826a12674f5838a855fe4b204d22320f63c6c24c41bcb9a138074523bade02cdd4f206e77801553b9d5cbafe99d9f7556dba06185f43b9403669e746d7269dd8410d7a002cebc2ef45f0619974650d308b42a4fc208d338cfb44466a864def83a482332765c7b7a68ab2909316c390e5b8655fa87038301ea4dd1b2c9664b8da59e165080bc67f78052b0431cc90e7c7c2d5b24feb1eba5cd891468c796ad311fc21fce98b2e117e82ef67232fafcbc8521feed8810c3bd0981700a27f84bbafff4fba0bbb3ccf35c2b1ce223b446f66ee9894805b3b38341f2a0272b6fab2fae7dd3f8a1a53acbbba2e46eccea167fe8d696bb0e3a5ab5dc2faae9672b73d94804b4e7a2a141482134334ea29b30ce72399700abdc49fe3ef7fabf001711eec3bcc572d48c06b048b5aba6fd71c5bc4a492766944ee364188a41565b682be6f2fbf59a3515dcbfa9f7b29e75b2938a4d30ec423bfabaa504d79e496a1bf17fe2729e8a01c6fe691d568f305ef91207fcb1783612b1c06376ccb0bf6f0db8a8a8272f9947605fac858ce40c1430f267cbf13271b4c985b524798a4e8b0dbfb86b00aff3039e996bcb098428f279ca291fe6ec61cacf48399fe2c513533167a71f718ecd59e0e22b792635811c837dd74b43a8994514241dbc56eabd0a25fff14acd11969e0e666d7d3eb2ae0dcbc652bd4fe68e1fa5edf770625a409fca6f0b0721bbacd8c0d7ca0ef1b5a2c5f03661e797e805c3610a2bf1caa0a2601536788131322c664efba062a2033320dae3ceff66dc6cfa5d20648c27a8b0993251bf9a449287a0d36ead3f2e4cd368c50ac32233de9595fe16169df518ba65eb2c9355bc96b3e3e294432c9514f06d41ab8f189514a2c932d011be837da95f1b5087e324ba38b634d7f9a6216ae0fde73060261660b2715e8f5bc96f49f0de63e17b836e2a2e726cd9b5f44c9b185eaa630b97df80637e1d795d999bdfad09f05515301b05992ae243879d8a51471ad39a19562faa3d5c82e62625a0061cf453823bf610b2583c740a715add0e0ab113e61fcabed51d2179098fd9d56d95762cec89a34940eb1b79d5d8a404aeb98f5e93918a51c4b82d326c4df5a10bbccc1c77b4f328093ae23af2eb189ad2971aa8a930eb95a52be02554639cc189edac8acf1db20f3c5c19186435fad8d72e40ce01639f5edeab0e46ef62c523fb57c89d064f48c20169a6a90a36095ee73f6d8576c557f96e8209afb430dc73ddae2b3065ef51e1ad6d3cade1ec17bcb7b931419534bf05bffd3f8a457d51e7c53f71c7966380e9838c299e1cf1f6f49085750803e90d3ec56937cef1f8fedce3489c0baf4d54bd2bce8e9d8a9e7f6c1509b85aec6be6e70744ce769fba3a805f7965099b39481d27ace0e0ee451db3eded78adb853abeec19b1abad2be6071c8e52bb7177188a728dc717d6e6f64cc9e3a4d61e71726b9b9caa22e496f79e671f78ec3ce6fa26b02fa329215e796baaf6997b7edc3a2c5c78b8ca207f55c49664978790e5e2f00c3d2604809dd7434170c19f1e47b22068056822c6191c568df40b62f076e9501a7d406fedc284b636b9a0b4d73be40842acc840baf24a4525f66d19a8e42feb371c54ee80de73c2bcdb0b06753c4471950826ce0f70ab3d93e44bf4eb5e934da7bee2a08b25cda5e4c4252d561d177202a97b65a9aaf91acc8f1b998570805855024833f7e95fc56e78410ab35c5b43340a4c98622ff4519864fb7bb633d821235c47d1f6e20ba6fdf0d67bb28778cd5e184192495d11a7c172a5cb2be769d22fe41e719a6aa56de004835ea7aeb9a03b8ae1ffa57f7b7aec610fe07cd10a27a5b2434c993f11e2bf85f2b53f26bc4791aa7df1ed8eaef752051042d667c12a8159559b5330e634ad7554423245b748a4fe6cef62fda01da3a3d85b7d48b2dbf69c3315b0e0678cc35947d747dac3dcfdf5affe8c2ce2e1ca03fc7299d916e8d01e110547e2be7321d35dbe1853708efb57a0bdd74923e96a43698b098d264798506ea6fc0a0fd1e6d2acb4cb0f6414c09228aeda6ed32f157f3731cccc17b4e15881aecaffe411367d934ebb4e9d4deb4846de0cddbaf167a0aff04c614ae1ebd7fe450b880facd6ce81401bef900dde7be8781786f5712fb1fddf465c242af6ab76d2d79572059663514875a14e9bfd2e989983eea4477dbebf52b516209e0646c489eb243828b446522a3309fd54aa37846148a6063f9d99b3ae62cdc8a574c5ac809a6f122bb2c43c50b13537ddff7aa6923f8f26ee62df4f1b8cc231e7102aef4dc99575e6d8cb1643d0e981b3597dc5856056fb9633a85e08a2b9e9ffbda0c5a209cf13c969430b7bf81f44c34ed39556a91d3018babbb12eb5a2ca1b45df395372bcc74d1a72112c3a41232149f032a56b857679dcfa97dda20e2c872e19a6abbfcaf539fba71e936296fa3ba9c6a80f6dc1d3b9ca0e6b6b793e48ee4c8d39789669adc175d921b0f1a30ef4d7345828fd12a5cba4e0127da86aca663386a548004d420f309fee51e99c0c99a632371a08a360d9ebec0f16e52f1dc10c33d4f5630a9c72a74b5dadf23a5c461f34e7680c8b602cebbd848299f139b7e832e79b1d37b18df8f4fda1454564fd1e9e650f9c2ec35c1f959f876d96de31fb46de5ed52aa1ed1a36ac6b45203c8004e8aa6c28df8b3513d9e8a2e80b380c7ec69795a00ad70b3f9fd6d13bbf6e88112386d5d6e9269f7cf2648bf1fa31ce21a98c0aa821ceeb16225c86e9a922f76d31703dd2d69b0db25c751b94ec69c06cd68663064b733a1f1915b626f01984300a6b7095c08eaa8171d77cfddffa130ab0ed8a435ac3a946a600945ca74a67d3a34cbcd707f45aa9423db298d2027fd0045177b084c3562e31394a7d3f9a079370d8b3218e0f945ccca1479280dc0e454686ae4f25385d42c411a784b9fd4ea533d178b2186f12b4d8a8e8f2d347e489bf4cf8cb8a4d28b6a2a0cad4d2898680f5ec2106d3fa19d705752c3f70ec55b0e1b13724ee7b35ab2da0904038a2c46df9da88570a802bdcb2fa4e666b82e95e098bdb8620d9189ea25aef9b65bfaed71e6356829f52340f5f5fde5cdb1de86933db350bd601755e0d3143429eef90e10171dc823ab335e1119e0726f345a2e83672f9abfcfd50c66cf16ba3de5e1d9d9242d0c938583c47c21ed0728c03e2b7d6b16b59edcbce8aecc29c0d16de3f826bc8e5b0d28fcd78fe1d550aed5e4566bb2a5ef6dd4b87ce17ce5ccd84bee5a727f8cb55ee424bd90f309a2313257c3d08311bc2b34fc16ba58cd3b2e969fc974f5ae2e37696fe7ee0a1ae895338060326c0c577074262b4415b382fe1ae257834b588a5abd955633857bfa1d8d827aef051b25717adb62e4bed4c218c0605d827a592d753ee63f6a57343629a476cf91749974e85ee1c4028665ae33a791611350d886a9cb906c837a0b7d62e8f5ffb5d92b8074b79adbfb9226ed36191f60098bc490e9ee87fa23d65ecb2ed874e746644fa55abc5fe08c4e71f5a666acd08dd3b202bc672c7afee2688cfd750172eb73199ba1b8d48c7685ebba3c5040e6af6e0bb89b149f5b246544888bc12b7569b29d2422ef29fc0a6a7f266ab9cc8009162f924019391bae5de152dd72396380fbe35809b24b026699f74131f48cf9e5fc8e0b341f91b6ed464a09b09c94153bccb4e21bf357a931ff74958c91f1f8c658bd12c843c83a3acf5d7bdecb97b885f5fa913dce51ceda4e7379e9f6c83d021f18616636feb3c4f38cc4aa09b11409acd15d3eab730e52e0e3752c406fbc9d1aee6094bb0816d4daab51d8038b1b7a197e65bf27a9fe8f2d40ce90ac036f786840e5af5f7c72a7e92a4fafad50f314e0fa1df735441b6cdcc2fca0ef03fc6163df8875f692a2b86103da782c4c1297cc814870888a651f2c11de82b9d73d0d44b25e5d2a1b8f80be662ddf232b229e023292300f5844c7cb107b92e8876e63230e4e8f759aa53a16e4282837eece7edf4870db7780039701e20f02326ebd2c5792727d28dc13067f96bf61b24b95537dad573357aa6ba9973e1f2d0dee5e4647cb3c94ef9d7435591a41201069ce747e553d3765ee38d6874be0b509876ec7d8136773dc5b8888e8ff83dfd14acd485b801a4a8a1e5e63752d4e9ed2ca16da0813858463c1cb99a426dc35b104f6fe3dabf36153663514e35f329647c616a0b482cb76ce409fd713d1aa52bcb64efe0fb2578dea2544127c7740d227dd87751e6a17511cb4725b378b1e9809339ca052eefe849ac15e8202c44f6aa19cac32221a9c5eec55b36164e575fd4ec6f31fbf3eeff99cd2a86c7fba7abc8a007a0961532ba0b624fb58916cc4d6546703e9c2d6c2f795268449c9399795d7cc02b32ffa39ee81ab2024bec5061cbd2aaa1ac6806ca7c3548af41f5dff623fe3119585defb3df616057d058e3f16a780df6ec2e04e2ee48fbe3be1ab011d3fdf3c32e41f97189eaceb426c93181e2304accab30b809cfd3e106bdb09eace42709a82e13fb60951cc1304efad426e868374b1eda348a933a425b9248b5bb8d2436c0f52f59d730038ae711825ef9cfa8a4d7e870aab5e19ee0a979d5c453fee31aebc75c1eb113022fb97312b6e723e3acb511f506a937b065f78b2d4aecf60e2e11858e8467b78457a87920e248dd8906d7e4517be62a352cec695519a8a493e3ba9426adc89b691beea5f195b04c36b02c39f77949dc6354e5e1efd5589adbe38b1b69ef09b3d298d4679a11ed589057dcb088e708d8b7e5286a3d6914b92567e98d70c804b4956845d0929558f89736530a00ac86d2d737af9a6d6fc959901c26df25d7e5bf1b80373ca26caea53dd7634f2cd5e9fb95da82b01f7e5498550538dfab6ed8062a17680097082b0e5d0e8e1cf617009381ed8c6e2ded5038a9d251735608a6f2edc7a110bc561a2d89fa0ab29e99a977583eb72a4e891df859064c057d9c91f626a13485a4c33bc5dc9a03256d3118ea114cc8a9df662bf3d9f8af012d39a1f36d0c43c379e1952a2a807b58e1dcdf6b46d87b6efcc7ae693dcfa81d92b6be7f8803adab1025230624be30a4b14f2b02f343126ec49d52355843b18799838e462f8782f266ff09a09ee67e50d41cae2fd09a4869e009dea6272080ceb43263a426d3a5759876b744b98dbb74ff98875caf1dd2bbc9129b7fdcf7e64242c8617be5049d68649765f5f4f22bfbb4192e396391e1c97964a1a4a4a6928bf479bbd25f1838487c70a454e7a613b5aa7c9d1dccf91dba2cf06fc0cde4d4285983cde07b8b36f0987bf6c658617a93a88c626fff4673d4cf38195525bb81fa1e514ba6713f3e2bca5823057bd980ebd706bdbebc33d747f722dfca065bbb2a78fd0ffd3c52b542227a1d286ec93a520134b7e67163da284144fdc6ad2dec46e583c6823b0b8111de579e33b366f95dcaff701c1d4856cb38452fe9f4338b1fdf7f9582b1567eb3630be5d43a1a3ccff7695872b7065aa539cf95c89668243ddd0ede73cbfdaf4144b37274e02c00c341149fa5db7b233a79c367b19edd8a333a68e09e66bbc7c165b32665bed8b5019d5e7103436e148cb0b923e7aaa311d80b9899e2a3fd1fa9883da13e70bf58dd78428f2979e969fe4f348a018394b6b82d8ec9a9f8eab2a1693c34b15e0c3f6db794748b222626ef0b36c5b3bee986014d9ee620bf7917de89e6cd8276446840e077462cf30a5d1c62aa0d24763085d1a9f92128abf9b490c0f154c149b1c26cb43378b53947078bace7ef27847fb939fa4ae195f2ccf37e63cbfa7712c07c5c704ee316f7efce138a596c60ab734f8e40fd91bcf0c88c7463a2473b42c8f735c3d674897bac57c6832fe09d51e8e6d7513c2d42cf84613a4c62e5e3cc91a8e84217f89723d290beccf0d16a8a31026c6c39d0ad8a60b199d38d81d46033e741b836d487032c3d84ed474ac8546a85b296552349dca9f44bf017f7ccb0fadbab2c3a2bf995eb51918b30c500722267f6b22ebbd12107fe19af5493949048757c2e470e718b3387c6f3bcf9fcc23946dc5c2aae92cbb1233794db7fdc7fef7c7c59837752cb6f77e1c23e866ece3376da426a4917573359ba1ecd1a3a16c26fa3a50e4ea4c57406445eec675f71ae46b6794e7c9e1b3ec1fec285237d87702357fc763bb39fc983de363b7ffed18c10526e6ce715679e485ad8b9155f0de6e452cdee8d5e11354a30af44a3168c081a742b9c7cc90f465b68e9bdbc67488f64a28c1eb58a2f2a3ece776eb2e92f534292422ab5a2370c8778bc5257aef3a0399a58b1e031bc6ce9d56920de1fea8f1a5066830d85b4d13512d881f84bd0c30a79b86d837f9cdb8abc41b26f5f973e78528a23936395f5dda72c34a20efee68487836ad9422f92624da0823379ad426946876be4469fc9e6990772201610f69910ad1a2e7842d68ce01844698cd29124b552de35b1a7841f8f34735ec6566fff3d2bcf29b4d2ddb33de11ed08971f9fcab61020bf7b2ce65432abb8d04e544f6780516b0aa828b98bc36b24d07f490ff693868d7dfd057464ab148dba8ebc463ebbe62513cd611385c74df4cddcad9a8321ff18f2b8b53304cb72eb7231b7abf44fdf1d0019a8dda32621adc8b2f965a27c225b4cc6209e47ba02466a57bc7e53f1cb71db751dfc068038d3de5a3e9153ec4856430d004e0a4a80371dec9f046f2b24112ac0713bfb6a248f88fb509ab788a258197a0b66207d6e531b5fdd19012b8307615d9baf86f86c48732b8a6316b52fd4c0bdf29bd1baf5f3bb41518c60f05a2b1eab293d6e9b3d3b7a9d7b686c6cfcbcb9e4defb4127475a9cf744c03299a802a7755923b7a4fe62fa8139b07d44541f20421a95c53c6ac5c1f57dd9f4acf43b3e12352ef6c39fc88505e2cd4a9e4060648a16ed8fb6e8a4f2b692491f0941eb7b4909df6f7e18975d122ad2eb176bff527c90a182503cc9e6be32e288ad8a10cec406d6fdfa9bfe2fb0f3035f27bb27c630814b30d74b77bcf2d5a620bf21275d5d82f866ba31f12925e5a22af612fbcd1a61fafd39ba5f9cc660c052a8b0866fb60bd7dd98a29c299683ec01f2d94afcfe204afafd4eaf5de21346c02c9fbba7fce5a9cf2cd1fb71c514bc419631747c205443737ed073cb7a5b61d1556c251e1100a904ced37643526430777ec706c7fa083276be7b3095266e04fe4bc4f0106f9b14b34d70eb97885948e4fe5fe6e3f3b98f07123c1e18c2ce1eb33d9cbe070d77bbee196781c1f8ac8a365a1b4a910013e92ac72082748c36eec0eaad1e7fb0f95dd4e58d69649156e2ab13fa0ceceac21476ee2f4d1057426b4698b5125ed1daa4263030035e914310cf3f12afebfcc21c43ac2d2d759ace70715e5ffd8ba4e08adebfa873e392929212f9d9f5538cf74e7979d76ab39f9c5e1320743ede3f11837999a18a5c3ba745e42b47f780b7962e3956aed3c94adc24a35d27397cada26ba9142757ae5407199f23b26e6ed26457d7fda81663d4953e004e27b698096070b8662929ab25c9b6bae6056c52a6bee2c9aa928e629a52fff2058523a41165587c03beb208255e263ec32052cda407e4672a18bf307ffc5539fb81583c2a7f720726c1c01b49abffeda2b55db823354e927e63878ddad4c2c3fc45a47c498adbabd1eabe9d06037ec8df2d5b2fdb9fa4ee4a6edfac510da86e393cb76b40233e015054ca2083d443deb35fe912d9751eb13c49edbc95dc140d8b1f8cf7c2d66dd879f0304967f49822d6f4ecc573ebe4eebcc291113a54abc84a52c0e01d1c14ab4f76fdab5f60f48bca2df0683f76cd8f465d608e69a554b5c8880b213f3d86b0eaecf8b757db3beb8f43d5bdd167776edc62efb6ef85ad87704ed128d0261b6213495f9d33c24744008551b7c76bf6c8008571854277595ed53e9e7084fd501d1ea01de8788306091d9848fd5fa7b0f17e20adeb1e26a925b6428112d6eb6a9e1e98624229608e3542e5efebc5ee6a09d64f45af6fe8d77f5a764f873311b7c6eba99bd5e47602a27114bcf64c4178a991b9c658e6a64b32f1b50132bcc44e8a7425c1007c82b7cf4d779dc09b92755ab1c3a8552cece9f2188e23e191336e5fac5d3c289565396757b04cc428f67b6f9bdc01089981e7f6d43e333ed4b908050a1061be83dcf99d451be4738ea14b5a3d747d9c6490855ee6ad363fe35d815b0269f6563dbc8f7f90b538843989cd41f37aa8bfd11322527e25f110e1de6201169e874bbef113cbef91eb92d7b7c0489116f62e7e85140e7490e4daeb189dc849ab177d99042adf0c206bfcbcd0d331a3fb699b7a4de7231b3921e26b56d1beb5fc79e95766e443f82b7de73936385be5f7157e9c089d3dabff27d9ee8f5d1c015f3918765ba48ba34c0d3ad4f8b6992dc7ccc7a32bc270aae5c418cbb635d58460dc3119eb4d04bff9b15d0d9eecf404a00032bf66ebf0d3c92b0e105ffcd21b1c657ebbf891935667b5a21b86b219497593b610ac3faa729d179115b55cad2b68cdafcbea7198add1aa82094a793d21a37e5d96eebcee2f643050f4639e14096e5a3e88d4476a11cabb27d1dcfd7f124cad9cb9486264413e3b705af562506b79f75686c9eec1591240f5e459d57c954c13c3e5aed54595e56a734339cbb0f4d72f44589687e1f8caaf78f184c08942a8ebf95fe20910f39bb905d6cfab010cd1a5e109722357cd4e563dae66b55803752802db96e5efa529660bb68068fdcdd4fb258973e51e3d57db8255daed38b6cca311765f73e83243c080ae7897b2910c53032bcebce89285eac6693c56a5d9a85dbcbdc070f46c6bc4ce24300d055aa031d34520b78f891042e75e3decf99523eb177e08b4c45f8f0f8008f28e675c65fd0dae55f247748d5357129d4810159275c64f629c88fe7fab6df7e44cc6d7190db2f2964f492483ae42cc152b5c88b7278ac4c69c3bbc520113f22d62a840007584734fedd28ef008feb33a1e69e6fa03f2da81c6d2663d587447e2854791bc7a10bcce4dcf2914da0f0bd048c650a2122a53a1bd04b0c4ce6edbf153c399c124553360268e9afc100e34f04302b082ac5ef68c6b75c6285c3e9815937dfd5e289f06f0c50029fde0a2b256b93c6d6d7602cb912d9c584bcd715de9b7c731062139191a6539cba2370abc31eafa38ce8d0193c47ac9ac904d236763cd7bac35c58cdc7445f1a5d5d92a185e7fea8d3bc70ac8645684bc74bb32ec4a8e20708be61ea2997a12b5a50898c4d530431a2e4d123ba8f8b111396819d6f48c98442c021fd971643fe5fd649e3ad5a66b08aa7df31e7dbeccf931ffdc7219001a97bc464bd058ceea0c278c25038d2b854aa429586cb5592f54de70cd052ea66c6b086f658f98cd998ed8092656e9f86a5e15bc742dbf59fd0a89204ab1ce19323890775f0f3605dc979d16b4217db12ae7b2e5134612f488d2697e1c1aa4bf11ed2c5f09508c2c70c9dd99abc244ae0a1e0b059137f001e80463a82c2a539d7a819b339ac905394b885d8bca4c338b93eef960cd6ebd4d85bee8aa0b51895a46393d702900daa93a2ec481efc2b5592a00e08daa9b3c896130f9662ab8f1a877412bdb3f75f7f9260bd16c53fb2416287c27d7e09fe7940254fe4cd2f4dea8078e579a98ae8de6ed2f8f0bd0fe4b19faab54e8b3b965801919d309389958998af5045f81a36bdfb42eee708229444271f718630a042eff1dccadc2ea6da43775471eace94d38020dffea0e1684f65deb2dfb5a16f8645afe4ed29eee2495be7406b7d62ef4c02cbb26568f037fae2cfc526c55f0467531e95c97516101e913a25f5dd831be5dd9784b81bd7b0ffe394106308e706226a421c902dd8f947e56ac34880e6e3ddc53a40c6140f71f05b99b0a78e8cea6d3ffa236de6de6ae6407135bd396cb554cccc0bd931c3c15d82216cd368a4338f6b2655580992d407792f021007015302d8144dc6f643db5023f0f8b3ad19ceec62f2cb18ae66d7051c16ee2603336b1b7cee8379b3f55b012a8503b81b41b65f5e2477f1f2cd2daf8c800c67aced8c55b07d3b10f8a55b05897bc684316011b96e30e5b557daaf2a34133285ef686a0c37c1b3c9ec1c216916d9dee916a280885fac9a0b70b18f29341fb0eae0709e2aaa6300a35a72136728c9822c5b7e3e7ad99b6cce0ebccc3ffaf7bdb31041c475a3d1ee6c7f596e72adbc8f5a92b8ec5755f7755b652ff240c480225c820089e918b885b0f20cc082571e95ef7c5173ab6a6af03ac6906e96cf5782c0afcd98c73ebd8d8183936d2e0f50a1d1c52129c2fc897dc3242f70f2ead841b534b9fcff11a8865a3ebb4845f88c84063217e3044fa5bf3f022cb8fbecdc62a5c42e6de38847fb4e854eb1636fa4a4e05ead693d0f678ef4b7938f36de75f3dd7e655bad4fa558d506a9e20c6195131fddfd27c15c06228bf854403f054d442b315910834d7c480a4f35d878e4fbdfe97e7e46ee5faaf375256e5c4c2e00c7fbdfe0b38e31c154e5a41fa6688703326f1e225ddf56ccffd1bf46bdd4815a70a5f19520564803dd141128e0caaf9e5af08b6e8a9f7c8736ca77ed7c485409109eec8475e51b6b002f5ca5fcfda8d499d658e40d662369058c3da6de5bb3295a93b45332137e3de4be3075324b0452d2ca604786acd240b338b1d1022425ef59d459422462932943d67196849ab3f02c0b4ee70bee3b9d3e00529dc37f55808cdca75745b326d6c93c816d003517a9d00f538ea557c4927514ef8ddcf02b40bddc882735ba3afeb022bd54038c0e90462a0394612781f03a68e1c73dead3b6dacf4a5b8e36d8a84489003eb2d5104f0607837e726d5ae69499bb7f8c8a0b45326b1a1dff5715bdbd0d9441ec929b9cb04826875c9ad906ad9bd3498eb04bca7574fb528401f18eb1f32bf1e95cb1abfdafb68541907b164b4353bf4a4ef53295d53acf44134297abd488dbe7c4a564ce661552dec722ed25687a193df14ce082832eca0b7facd0308111e09985e501c2f2df20701835d0e0b682696cabc228d5981a296e17d2ab5ececa00cfe4f85886c0ff7bfe9818eccc46148b25197c63513bc3caf8dcb4cdc5cbc77db5eea10bde0fd9ccd743c2af165d33369b5d9fae46ba911fa3b01660fbadd9dae1b0a6cee207217aaf04e248beb216d64796c5bbc5ea44fa62282bce48525e74c5a7a9fa969c63642c8b72d2b0081e13f820f0d897aba0a3b444ffbfec04deca2ea32019107a7e5ee7d82bc1a181263f742d3777b64db04f5991882933049e351c522236158104f4291b08acc6c95e6c853672bd9e1f854719ba61471189e467bd6ae2a621f7018eb4af63d29fa927dba64f3a7d6d7802633b1b7bd23f5a14f2656e5f72cd7a12c77bf8b9f9160b4db8a9c9c8e949185bc3b0837b3e612018db524789680dd9f92439bf283826c37ff1d8f89e5f2c2da7fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
