<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fd5873dba6649574c11a1e7d9a01a83a9a996b2068ae845a96baea9a420921f355fc09d531cd4b2e3a3a26ccdd407f03f345e5926be435865244cac398db33de9b07083acd33275f4ed04b1ff64c6261ad2fe1088626a00c76443f398065eb7ab4d0a9bfd82e677228fe5df3ba324f3c639a9910217f58b854778d34a102c8e044ae3ce1d39089cfa1d0b56dc399680f52b1c43a7c10aa001f216fd5f72f3738f8cbc34b5df4b9babed225b2fd7c6edaed9acbe0746ef217c98c2f3526806bc76f2b7f5372c0575390bbfa0228304b876ef52c10f1233043e78addc3a2267c35e2ddbd4edccd7cf9132816b35a1b9587020e82b9a46e88add3d924fc0c141f0e47b60b8f47bb6a3b418a056c990030b46918812417f4c279f08d7ea5eeea6f45ea2b442524b25171ada1524311209587547356029827797cd0f3df8e5ff0865bd1dee02c80b2dbd3c4376b1c6c8e1af64773d769d56a75c9bba17539e40aa10869d227cb3a10052aeffda3df4da9a4786262541eb6fc69a1ae55fccc595a9e7b7366a46caa4991b74b5436723ff997038da58412511a3d6f6da89250e3650dd04cd0fb4187f77cda4fe6f672e524f637001937bb30cca82c3abbbd176282ad62754d87a709ee64d70d6844466d283557268c753a4be4a83f1ed60c70c638a0561b8770d533dbb79304694eb29c0cc613414fa2ce425e458561aaf245336b21848fa669c47f9ad79d1839a765f9dcc93802a1c366aa1a4128b8669458d9cd20f65ace1a9bfd0311dfacc47149aa5c4cd0e4693e22a9b43e0bcfc19a6a8c241cffc2a40348b41d178695d2e4cc2e445bd0ae50a58cdf5daf8a6295c67a0fada7c4821e8ddb770db5d559f7e316bdc93b67ed262a7d82d10bf245fecc546aad34a5020decc5905f612857389d04c6a86f61f56ffeaed97bf2aa3a1d9f7715e6f5508df8d5acd43caec553f7bc17e001359f596d354d0aa3a3027fe04f3ba722ddbf56c660906ada33ef71b277f448f14779bb2e7ef53ab6008f87c8b8e07e29e1720f9c5f03d386520b9abfa3a2ad428604b23f1e2b6944c616c272cc9365b598652e8a88f2c6bdfc6a0fc296730f41dd439a604081f73149a2291d847be3b00aa4bbb03004bd6cff605e5ad7d6720fd904e792ed77ba48602706c251abee52a631105fa7d35e691fb2e96076bfa668ae61769a15debf382bb6d42cddba75483f6e83e80bc620c5a3584470e1a51b5583d2257b97995156f4ef19e04c7f7d03814753b66817ca44fb28bfe5b604466926eda64817b6ec970e4aee29b5787e1d8b7a1f6564a66530307e037d88ab1710a20d86978489b3a2acb3bf0becff337d61c4f1bf885f61b190f68ef659d4bc79cbb1bb69d01e3c9fc1e6b35edf6dffa032b92142d17cf4b3adc66ff5c05a347eba01d5fa7d06a628388a4ea2633c69ed86a1d88832f211f125bc3347cffe021b8afa284c66e91e65cf0736263f84ff1ed8f74577bf5f76c9d92c51531128dcedfd8e67d0ca424cf344f37cbb1fe9c123da7c0217302a5c2f39fb8ec113f910491912c81c677f670214c2b59a20ebdc5e8d34b5d35f3c516ec57844c2ed781b27a9b41e454ecd6c7d296f451e08556d7522243392645a8ba9d44620b4b5385da255260959153246ff0ce30725d4b40a238c7b15329bc9de1aa52e2bc2f571992fe4498958c49f7a078bb09e2632dd1603c6dc88aadde9375201dcc6346685556385ee021e27a6cab26b6066718139e3912b1ffa743b2063638774cbb240f9ba8070183962ac7a1f1e5686e0b9b4c7aac95d52f6c41d8467c98ef0d7ae7c33ec7f535df535fe609e2bf995d0f47b2a8cd1b5bc502ef4acf62e325a54e106d13259c7966d641be38124ae7d0c7316b5cf2878ee2ae1680aa151c457f8c189ae70404f80cfc96962bc4edb636c2528e64d4305834c58123de1707849e9d47cb45ef08e4ac485aecabd22463b603e4fdcc698d4b6f41c2328a51f0f638ad4391a12e689008d3ebe5aa2daed9707e5a89c4c26b826e122f1b9c534d7051a3b236e01b1874a09f801bfc4672d464d8b780f97d6e01bc70099990d3dc0f26fb5007c304c9c583bf1e668a76cb0507302064c67b891f91c6b4885b536a84ae73a8e69b5b444ee720a38e3f3d7368a0ec39cb9aee4c8cef3eef9fc621e623d9bca9e65000ae17a72752292026f325f7acb4163296eefa3069ced8ed084fdf56f31c0fa8f1f0942e1d2bb3bf46ec696cbbce17055d6ef69c0f455937e3f9340158d7eec2acf6e26746e6a80a9f7876db200295f6ac1f6e9971f2fff7fa079f038ccd3f6e87fde7d8eb4d49a8f82ec02edd4c460301579e48f1dbccf1c1be9e2a91bc9fccb440bb335c359c845f69b8d19698dc144d5802f953529903abfe22457a51ad1fa72921356ffa00199f02bcd73e33198f4a539af2fa93084f8d03fdfc79b39a094fb62b2f1f8625835e31144c2274a075c9bd5a5dde3b08de874567a32978d23f53b1fa7a3611c1545e430f5fda7a6aaa278f1021decb82ed8c6e1833b4b6ee5cdbbcf269249a72b63f76e02be7706cfcfe53893944d0b15fb4f86dc3e977c497d1de2fb25bd624cafa235f402585e3a738c002c1438ed0f991363e8dc9cdaa1a53feb08fa97543dffac53fd58704e61a45fb4c89440da452b4dd2a94f542a3d227054324cc553115c7a21c8e197f728d5addf33a0e74cfbdf2013757008d59ffecc14747c345ddb1d2ab9a0d2195f3643b380fe5f33c3bb45f62b0b457996c1055125cb17b4b5cbb3b9418633a308d9cc5eb36408a6a9d2fa9218fa3a84ef207820946cc93400223f3ca7d331a356d55c0d4140b2bd8622ad7ea2ba59e9b4da58b2f4a477f9d7d6048aa254292799a8d9408e3d98c6571de6203fbebb632597575b819ae387dc0996ec81a1f3f2caeb7650a9ba36fc16a31833406ef74e304eee441fa0953352d4a56a0aca22636d5930461710853aedd0554b7588ee3d1c3d8843854e81586b525136ae107323104cb6ac66c2243013bf4f3622104fd8b96aea0a31559abae0e0b67e0f8ab7fe998d7c4de4441128709358a9e9c1aebdbcb188d525635e79a44db5eeffcfe2605fe1e04ee8bd55947e6827c4fdd2f8311897867d5f6e9445cefbc049ed4b26fa27a3448a616eb89791ec0c1a3a842d30781d84daf37e812e29c27cae3c7777c3fc5d864216bdbbf78a069da5b9f6808da44f42967ce33f9a4f3ddb3788c6eab875bcf0e5338c2ba2699f4733fe5d85fbd6e62e0ccad426ad49cdb7eae8dccc9a9c7af0f4087a14170aa63c4beb545a3c8f486861492c1711eb76e708d3a8319a14632d8bfb730f543314baad7de3a05e9c93a6463a1cd2be7e528d8e729db98a4630bafb6d8bc12278a85a9b5f909a7408e6ee0509b12f02cd57a34e55e9fe4f309064b81d132749aee244159dcc4d4c6a896ea5c3dbb4157316c80008e3ab30f92cc8488da0a2164f690d6e8718ee70b669e690a60e8e3c3e9b8827cd023caadcf6747dc6942e8ab37c5a551d467780c3537219901d10f1ebcd4ffc6d0f512c96a714efc8296ae88c2132343e6f1f6e22f20e3a7579b9f7fc827bffa588d2f796bab327196d8642eb52f57407e94c0253262b36789a7323ef50c1836e582046733ba33f13ad1061b04ded862ba930589407bdee594e0393940bf4a66436ee78e467c761e0e9bfabcf2e3327efb85dd7c5409967dcc0bec7fe543e03a9ee24e97096edd266d759349971c9fe4b75446d8d7c68e5ffd02b2b791d9cf15f7e778122d0abcc00053c725ea53274b6c4e734a76187964fdb2de7caeee1b47b92e8fa9535244f7e8526b9a02a31c588f09c4568c8cdf94c531c2d9632967956167e0aa03f967e0e8ab9ef0a9f8aa1a427f7d2a6861a42c8c7e804d97e2a56746b03bcf8e13173e4ca65bb97cd942870563b01a0f82889d4436f8c9e4f71de055dc1b78fc984043dd07dde3e72e711288721f92a893eeff352448beca478b357d37716f7cd12b184911bfd179fccee4e3f3dc99e501384e87502558f55e87ea22213a668e39f2518551cf27ca421f568da9f18476a30358f4c4dc108d24bf78f5354dec6ff648eadee4b32e8864101ae4c8f1e15799d7f62970e5d35b899168c0a44928569f7c5d0070ca1b3d25fbd8a5c92b0ee4d707931537a59f7404fc2fb9f1da862b944a01125f6fdbecf133896cd1ebc6636073ad9a06a19b772baf9c7e501a2949993e8114dadfd94045377c92282b899eec645a8c5dcbd58aa7eb891fdf8cb5a7f3ed199938982f85d6ede6807c610938aa7b64bb4ba0deb4833cc49836ab93f6adad64026b321aabc5c9d01e5f2684baa04e3ae9b2e5c495c1bc553e4d5012d344095a952d3bad302b85f174526dcebe56ba6fc18c601fabe2bad7937b4c775941e5ffea47195830220495dc3373a17135f3da57f68520d125c4feee7415a157efde8d0f57dcd891d6afe179b8373e6d7348784c035280a506f3c3bd2c622d0c175e338418d00b417ec575c00f11d69cb3b18eb8f9fbac645b33a224a75d3be961c81dda8f0d6ce8493e0c7fe84961f7d34f43d48d11ad3966d7bde32a29a10515080480a5431d0b5ff7ee5b2f62b7ce0f2d7d2fa208881b31dddca4b53c848b2181962185c38311a4963da814d621d689a7b8c141bcdb233d32e89b12887af06adb1c79961a53928c3f3342915698edd76b807a22a33130984d970f207ab88a0d4e6e14ccf76dc7249e6a079391dbecfa20845cce351ac11868d29e8108f95e4e47928db9f1654d66a9c83edc41eb2b544e8409e9612acd2462e2d61d1dd31abaa92058e6239e9feeba549c60cf3915e062a8dc97fc1305707374aa1ebcc7b605e1876b760a7ec443e61afc9d9b87ea65724fc9d7498930e895975e128172863cbc28b617e0c12a06d8c7c2712da097c8e1e9d3d6e0d36681c2674eb9be76949f0a2f6b1a6ba707071e1913b2af9a4fb9f0695fabdf033e7db68de2ed97f5400931ce86b16c0810607b9c2ae67494c7620005f69ac0810376567928efc03f5dfa50b7d84ede22cb755d27a99c07799435fd9a7d3be5a3dad8abef1bfd3a10cfa2c0f5548359a700073c360e69304d329b2ae1180f3a89008372fcdcea8c16087e0fd2437c9f4c4179ee93deb148a4f6af0d1147397436320026d98280278fa39469b4cc5f12e19aef4bfc70e14630620c2d5471c5facad2c1b53d6ef9e5b3eadce7f535ac3da843641b1b7a663f94953d72be422816cb4000480fa9770f352074677a8c49ff82932472a5199fe967c40efbba5159bfcc757f3be45e1b943d90476907241161d6c469e4f8c52b47e92041a3af414eb0dd80f39fd4828bdeb79cb91e02f7b0b82ec2edcd3bee840bc560d611b3c63e2a3b2e677420778d2da095fe05328c3a621f8ddacdb3b10f48a52b074b4880dbe019f34a66d6f73a488ddf08d8b98e83b5e36e911e8a51639b45d35e4c50079206242119c3b2c2838ccf8ba3d1ac19691bd8fa6f08f728f4a8c396e106768b0c6e46ccd9d4025a1ca0b0faed53a70ec37e33d70d88a7a9d9ccb2946ec5f76d670ef0878eaa39f62024c4496a5ee6aaf898cf3fb01eb9636176cd004cd195e27f5e307a83cb9957a48582845519ac7822b8fd4fccd8e92310fbf991ec469fcb2c9157469caee2412f989c603f4439b4b96d65603875c2da79fee82765c7fe1f38fc93db0ae16f21e8ab81a322d2e527c9bba1d895ee7bf317d02bfbe300f81fdfcf5c9a1aec53014ad1a5777e55f91c4c47db11a38e3b34e1667f7331d1d0c01661c328fe88a2a8daf85b724e0c3bf2806ecb01277832de0d4a0217ca2c0e8d4233c686fa3fa6af209a026806417d44d16e77dadd5ef9f67317be5069b5765d067f5b51358173a842a2ab9c42f0ee484d8312f7dc9ed317c2da40dfce284e902968f13ded0c5acfde86e7a9df4fd13b7ff455c40632c68204ab272943645d37aef3d034875cac13c80b81c2a4c090680e3c9b203c9d4d4e5f4c3ce23069886b387e8677e13f51cd2a67a4d313433993e09048d735035a4b4b8ac99331d99cfdf525b2db69a06bb466b927043f05a3b1a54a62988b7a61e145c3e86a96515d98b3611de60efc18c5da5aedc0f9bdf0fbc4ddfbafd50a7be5772b4c02be678dbcf98ca7fa6c767cab0b78a201252171407ffec32717939858b36d964a0eb969dddf6af9eb44df9952ffa24cb98ed75c0df3edea3f4c7ca42e5eb176ea22c6e571d8353ec14fea1c488c08b8e30e41e2ec8e1977ca3c1322a06709525994d021968baf45c0e989aa0823eb655aa7789a8301cda8f210c9b2aa211273efd117deb16f62fabe3c0f98938ec776e188f2c2789a3a47c325f15721f3a253299c8dd29c9d4bf9ace3cdb23d6cb908f5e41785bab503cc3b856f57d741b618b8702b7b58ddaaea5bdf333cf2957556d6b379e1a6e12c6c56615aa139cd303fbc6e0ee57bc47d6d7eb7761045a6e319e8ebf712896e3ecf9df16c36057367c714de56492871ff5b89be60c010d5b40920c5807f42c0d5bc6dc8a0fa4799dc8085df0613a97ce20d2f863cfdfd0ddd7ff4dd1a12b28c1a2206b3a062473bd04c050e1c41013d29210e6fb2f1369cd4e25c63aba2d8fefa0f4016ef3c720daaf596672d994ddde7050e8fbb7344e3d6fb951456274526fe8b39ddfdc98eea51ba470fef479263db51e74cb1a15394e66840ab56da2231fa1f5fa4d3b7f2f5e803468f48cb4a31a0067644fe4d7d18021cf94eec033a065533a47b48216cd6ff223430748dd71b58efe2879325700277f4a7496321b19d91359d502a738f2847b5cfc6a3fd190a55e5e30ba69a1e8829b1e83e6cafc98495563540c6871e438b2d07097552ceec4e31d3681d86c8629b5e31ec7f492a2c167efe531e13fa0d0bd17b4e284ea85248db81ade5ba969ac70e4b3df4ea4cbd17e37f950bafe5b0141b182a45803ec1793848ba6f90a2beca17f182302b88121f0aa17e2626aa85594c100cc8616ebe73f5b0f72a9f5cd5b00ac9a6d9f9cb8f900971a734799e93b9561b62fe6c0dffee6a0217287f7fa9ea45d3b7ab1f3b3e9e4c0e3673c3c1d27b6d75102d32b90a0df1b649981107eeca6eb985f4b328dc5833844a9f08eaa69596317442bb18c2b03a3f58cfb5d81c93997bbc4b8011a2898bb44b3658968bb3f8eb84e6ddf3b65da18d118ac0146a4e41a23f0a19d6f6473350c6242fe0a30f8ca3dd24cf7c3f66ebe916228c3a12560fdafc1b110a6f2b3799cbb7286962cbcc67929c88b129e25ae8971bc5c80933241d18300b6310c33cbf862d59c88e0d5130b514c6246db52c0f05db13716a35f6080948256ecfb1159b63cc7ed757a0a9e2ac83cdf9844240a11358aa4100a3596251b658244933fdeb39eb184b6bf36849cc2778145cca97620e9cd0b237a7f1d919f09d907b7ce591bcea5b6b1a445ed70546594c9e2ab70dafb33c05ec9d9da1ee30cd4cb6c84abac9f154d643af6db0d02cfbfd0bf35e43235cfb259648df4b6b7405aabed136af8defa48c7561a04bde99c65674f6d8721298322230d216d5bb7fd21d45a9e4b0ad8738271649650ba2874debe6aa45462ab484bfd79f3f1fbd6f80825fd8f170205c83d053f10f91f8a075b409229f2861886b27d24e229f661b6d663fea1ef0b37061fcff64fa7a5e3f268311053ce0b86b10cc2e8a2187e4d3e093a2e30298e0c4d1e761d7dbd2d7002440d11770efdb600e64d7cb3b6e8fa41739f5944ec2a8034b5f5f902e2f25fe9fdf7929e7a095eae1b2924fd852932bad6ecf70416accf82854d24fd2f9b12e3f841bd6fe802af44fbeaf48c9aafb81e041f117d0e828580a66459cae5df23db811e82584379de3a61bed1c403c061219e610b1fc3a6187d38987fe2b9e5fc2efc3c6447a2fe7117df0ef34d7c841c286eb92c09887675c5c1d4ea2eac55a0421e19d857575e505938dfd79bf5e52f4584ba56f07dbd5af32f2ac881e2fea2e933ecf24246e7b38b92685d2dd2427746087db70c517c54e9c355f07f22b5fc9874bf382277f7c501c1ef3534e32bf40c28237b4784cd5abbd9048457d3692dae4d909421b563942787b46cbc386f92aea1f87fe6d1a355d291a997da181b68d3767e086f24ff75c2761fbdae901a48a96f0dfc367aec9e21ed524c4640d8b47afd2c1491d34efddfba98a96f8a5584cb46641a2040190351fc1ab96bf746ab32982e15187d7b77914b7e510ae79d9fad58bb43149a394e155920d3280ef622d60cf276eec49ab69a3a5fa852593b89c2aa1b817b16ca9225ae08f20300951595656c8517130012de2d7c98343e66498240d7ee8e8a6374693083a143dc26074fc8a4f704ef12f48f2d16de75749caebaa0370961b0ed849adc321171bde1da08d9d48b51cb7065ccec0acd1b22f6172a226ffdfddeb6b706d4387e10fa6781ca28b3f93b7e88c30622233dd12e2d21c50217ebfc035a5fec5bf59df6395a6a3740306b5a12356a9910805af6bc4226f094d5e44e177dda9ad51654dffed34614a746c4712ae80f3587af9fac1958c62a0483a4391b018b8dc0f53bba71dd37fe097568f7f836a327de9adfd59ac998ea3405e35b1960d71315e1612d0626a96073bf5c82855a1bffdd2e87f83f39f86f46f5367695af269595fdb643b730ff4c81d674247207ad6ddb131b89b1e3f69f49b0cdd07a0a65ea49c3c847fd507da3e75939749d38c11db4fd4155c1ca362abbc0ca7aeb1b42425b1c0954865bd93695a3f8fd8fb75704b5898e531aa184725bd951eebc14a405bb0f90f25632fb43f0d9c0353ba83f755876af280ec2978ed2121bf939ff20f7b3a76b4836bb13a6956f532a87731b9ca8c6ca706aadf7267188170acfefa8bef98d38a7fbd516206877f5ceadba2e0fa6b62c17e16b9178ece35fd3e817e2d713f8952a319f28674c0ab31f61a8af0e5c240a52a7916185c4c4995c01d8be0af1e6b3898dc06f7c8a8553e8837a2478af9675d6b3162a90efa999045ed908062b8f1e1de6442ab3d075dc1da7472de18960599c4a2096115015d74f7055a6d900ed0a25e1b7f1bbff7a75fba3eb40363556985334823a017488812545f99ee0f846b02e7a11c55165084d9f1469c4223732e7be729bcee912a3b5ca39e576201e68488a1c938e9da57a222b5ad02123b1e5bceb70319886d4b25863b22ee0abb1fd02e626bbd2a669c17922b0598fa756b8db7f4877c34be952689124fa6f041dae296ed279ed596b3057dc8738a34931c83388b7196cd14ae80ff046f322cba0c5652ac410bdbab4d631115ba4a696771421c4bd45718e11f5bb061e2a7fa0689707cf97d480555c46666e5d5e09b2e7d307edb93372414b04578ae566644c6ab00bae386a930606c9ba8bfac56c4b2e297ca5e073b2c0a6a13ad7b056d2b9f5e82d505e5cec3e3e08d55bb773b6e92134d78848f8b02ea8dcf02af07fbf9bf050e569e314000bef1314581f79ff3d9a67b6be4c55affe806a059694f0ad6f08168bf6982bae8c2937be55d788b6f33e915c2bc1b72f40b605087d2a75f339d645c07959cc1c482c1aa422ebfd2c5b13e52b0c6fa45b0592dcba5aa133a570a2fc94d7b83df5eeffedeca7412ce8683cbfb250d524ce9a349689bee9002bbc68fb58ae654f9596713075370c2031bd0a696ba0844b5a978980d42002dcead83f4ae5a1ea0134e50c98fed84a1770dc29ff80244e44a4ff9b5cbf4c1f5bf1973b8001792f0d4e663a546efc03ab04901fe12d6d7bbacd5d2b274050225e9dc144ad013ec1c5dde681fb88f43b796edf9712a03df930a9ac0b764969f153d4a79a903d190917276e7415d7cc72febafe9db3de6c6340c2c20ce8e91c318f8802e2c6f8aea83fcd9ac05b0549b6db06f386a8fdaee8391f38e37c59f315abd8f80d96d20a93874c12d6b801596ea39f088d50286deb2d1530a5c38fbd73d4b0ff0721ff77f211144e61b9b400ed03f5a7e210e7b60baccc2768d125ad8c037d646ec80529a2a5152dc9f775089f7c067803827ef3b1b47c5242958eadfdb12832bdc656cb2f67997ccb68b1bcff3525874bf82f1681395b6e322fac133d43a542d431fa7fbc293ab8c8c4764e724571a472931e63d48e5b23dfbf132f76047de1392f9ff6dc311c8d258761a66d6c79e2420a54e2e57d7a66af923adddb3a968a823ffdd189d5b8067947a35eb1a53a9d263c295f51c3599d0b9532f455d4ca5630c5ce211f165294ec5706d0af3549442b840e2303c3b665a9b1b0cd377b1740ac4f39d1e5316858c73d233945a84a2d57577be41280ba2ac83f8bd4c544bde3d26678147c2785b3d1ee2b411ca653ef1eb74f661490b5a9b8b5af20065387e231b908f725a13ab078cfd48ef4207b699473aa3569c2819c785f35183c927447e07020ab277267356eceddf4889d7c5032a48f38b9c2238684e6914f35174c7a00b836b6bbc717a1dd9baa5c7eccc2e1eb09bda7c9a433d4cc951eb893d54f51cbe24440508fb3b99f95b153ba9e8f6294524f2764b03135ba59b43b5ff0781d1bde542b7f9288c3e3e08c019dac493ffc6c518b5d68eedb87ea046698d892661092ece9dcd1b816f261a7e94ed9053d1f24f98546355cb579e317a7a71902ac6abc0c03983ce649c9d520021e467485382b3dca12883e6f7d189964d3df689ab99c28564688daba8e06d4e560056ef010668a5ed1bc9abe99942189b2285edff5639a1701085d7e60d476bfe84a48c12c00097fa06c77e75bdf213650ea3ddd049a1c6c0f4abc355cd9e8f8c7857ace4a10f1d9db4b62eb7223dba835e8c0d08bce18c19b189569da4de3f2d89d6204e9d99d39453e935005114a2933762e44de3b58d00350f6aac34fa839b990bfb7492a7d5607c6681f81b5fb58c950ba674aada9b11a0e6265677a3ef874e63662a35713f79e4a66b1b339f78dba49b0991f8d38fd0a0782919d5a70dabb5adbe508f921d2ef4f8c29fa90d6aff08f7d5321a48f492257820a87ecbd93c99b68b4efabef15c235434e00dde91bfe9038e2a35596f966ad2a2eeed43f038fa52c594bd554a164b788f469648b6edfba266daba78d39d21a5b6e3aa2383af19fb1db5958202a8ef8a54f80f6b2bb1fcf910f855849ecf6e877acdb12335bbdd7a6b908d40601470ce1ddffe976f0214c3a98a1c39f0179db6a8b1e00e6256ef125ceb37ed983a97ab5c7805c4b6bcc3b5fdda04e2aecaf7e6d0edb866cbb8e7a85a274ca2cc4b6b4d52c43bb414cbb9b6bbc75b84cc08c2e05c8252f004f06899ffd3548300469412efe414a486a9fc7a543e36cf747c41a5feda29392617218657f042c0c496083e699ff0d5680610bb14493ebcd20073a47c19debebf879462c275a515aa7a16b0a395f77e7d1ef81e2d8b764fb90afb769cdd87c8eccc3a2ba80ca3b55cbf0769fdedac3c406095e47f240fee161b6b1bce850b31eac39c3e06a01e64587675c36a1b18afe1606a3ad4b80de0bf675f38806b8402e6bbb262dd6df70859cc58a72a0acda40e0c3eb75df7e192f4f55f5939a89e16c351731e67deb2cd6fdb251041cd23c21c1fdc16c4417c4c2554db5d35ae648f8f9d8ee2428e7c7265c2dec6480ddec18654adadea0044e39628de0bcfb9d5678c4327a7a8de0f5e589bb36d27b3c19a870f865f1175798b61900fa49847c3e5d1d6849657b7c282e0fbbcf62adae14913ceb27f5e3000c4e6ca47a3b7b4327e4fa13af46773c324590a1b675b83c368e84da788be539450e004bae50d1916c161f75ab8266e1b83d9c058c7ff4347e0af4642cadbed8aced5f3776e0f0d6b11ff56a38d97a325df9e4dd600ba0eebf4563bc8c36e2242b2c17e0b804e94f66c280ff9daa451f50d2f1bde34bfe29521a05e6000955319f395fc6f99a6247507693774f337abb4dc1e87e3062d2052faed18320aca81ffe6a9296081e971652688ebf58b83bb543d93fb13e68b73150e2e5b2e05d5a29673ec1e78dc2b4d617a912a678ea5b757d60b10ee071c57646fb2ffa3fd8f88bcb8a005d9e8dbac76a0c947c6d38e35c8dd68673f2bd05ec40f72a387f62b7c5b099721a78781500d9f1aafac4c73e8a756f8ff5777178362b4d4a985ce37d8024f04ee24ed35b3256620ed10665dd609b6b5df2c1ca4e0bdb2bd31bc3997cfff8a645acd7b14f517b54cb61d2fb5aab405787627e38a26ef15390c73bb589633d028b3690ea8ceba74b8fc6ed393bb1330f31ddac1dcc9c3db3be0f78b97a7d8adfd09325ebe943dff062f43d955fcc0c65e235c64e2888459c87979e81c076c867e0d95e1f64d9b96d5ca244bb3b84026ee3c411ed82b54b5edf7f49b2249e606bb395e56f13de0b053f97325e74499766cc47aa2dbf04c2dfcc9b02cbfc38037eba81bcf4a9f5c6a09eee198d0f6d9939156d4fbd44fb4c72a8e1a9030136069d41fcfc7cb12f31492e220d43946a2cb4a077060b86d9f5bee73ff96b641bce576d14a68a6cc204fb451bbca5db902a81dab93b836a80d781fab41eaa6ef0bed6a9bf508b4803634794ffd870c00142953f6c69b32b9fedbc26fe8498b786aec911c746788cd93d98d2f1ffd84880f37fa8a6cc1ca3867569932f4e85d5993fcf1406f375e5ef66693c118fc4cdd9d88626535e8308373d351dfe7094dc115296040ae48f98465ddea2ae9bbce1b585ff939f0a2df9a6bc66d42605591d87961e2c535d2676fbdb38a632a4ef41fd9b4d7d28f8a563003ee908e8df8d77227b5c0258e08ccdc412c6e7d13b6a3fa0fa4e873f765923c29d0d0f2c405dbf55b19b5a9728a3c7ebc046069d84944d54218fd9f9f34ef2204723766a91799dc6f39af57dab8f84103b7f2b47ad51e2cf78331ddd9ee365543b78cfba4e263a4d26c6732cd39276f14d6294f9c7935541ec0927fb3a3be8276d63e0e98bee3f1c1dfb9b29e7d21e9dad8bb523a53a1ae42648430c42c802522220c6bc2106a99c6e818e43dcbd5dfe3766764728a731feb7bccc8b773e0f40f523e6f09d773f377114550b11a38df36910b84618bc0797b3a78f2233b1505350d76a05a5cf5c0c6a77cdeaf4181b2448788e5bba15cd55881c154dd1c70476d027029aa565ce88e503417bfe05ab2ee219cedf03f93a21a55394d128edc821622e334131b42ebb4db9026c4dee6ec2b12a2dfe1d4a11a30f81918c888af5ea55a4567c0b20a1879a25c1b760bbaa532fec3b2c8fa40fd0afae1a31dba6690132a596db9457ca39da76142926221b2c0cd684167c1d9e9feeeef870c604c58dc824796a0d9b8e14249de8ed3a20ed288680387b33602b1e4b2c8e6280106d7fea1d863ca18b30b80c462671a03723575b25b630197469343216923b48b0ea696697eacdd44e4ccf454005e20d8fa6c38c93e558ac823cc2bedc6c861a4e1471b54bcb97dc9c1146a1506c81f03d3750857370fcf4eb482b6689a6253fc3ef013c8fddaa7c2fae2c6322a6fa3284f1a70f9b67c5f0da5fdb0373387d772ebf84cc650918ba1a13a28c051eb0eb76b2a84ec11c1de0037fd372069e2d64848e2ffdbe090917ed308429757a8ad819f09ba1a8415af85519c7e5de7de9d3723a5ee2a6c924b05ae6b94b254c5431ee00956fbccdbfe8bac303a34cfb1f49af92a709c4be3d84a23727027dc2616d0efd473ee24814d0ff0ed2ab5565a6ffed8066c407f3778f07ca012dbe5f5144a77476a89ed8d2666b147f6647478abcd747127528ed6a58d6d5eae31bf4ef210aa334befb707fab027f4cf284b834b9cb7d1931a1d2ab592abc5a91cabd879b74ea5c6841a4bf5bcd8040ba24392dbc31f07f0a4b41d03f8abb280e72456d4c7d2a2c133a6f898505d793de51c523349a72f79d4bd7f36611555fd37ddd8d859bbdce5e545e95329f5d541852a3d968800cb29568a09068e8f8954a256a52ed8c18246c3cec27613b686eb6c916df3f8484f2d2782191a1a15e636fa1b64ccd70f76cac0aa5b00aca3b88acc93b976498ba4cdbaf652f82cdac77fe4f83c1fd0f22ce5923ec7519584d0443721f97947dede3607f2a76b45071775e4efd9439ff2cc797bdf57b9aee8b3702e3567b19e1c9e7232e680940da32ea4d85e7634b98652f7db432908e895c6d8ec4c30c5c9bfc6c5cacad09d37407a20fb52773464fa8edb1d11e59d0f3b418d937ddf827bb4ef06148cd7e97a725158b92ba7bd8949ea8acf60e589059512bd5067a46eece12708568f5a9dc3f46c9c126f4380557ec122b4e3ddda8f363ff33e0edba8b3a2a6273a92e83cde5b22aae13323359b3f8b01590c0c4ca395cf2c4a6fdc7499823971fc0658090e2bb6147973d9d80953f28cdb06e27ca700de7d85d2437e240ae37d4f6f406c2f5adfd1fa0716afc023782db76cdb319f14ee33cf69243e52c54597f12cd5c18a0a9f7d4c62b052d53bffaafbaa8f3f97be2fa8a3d34a0f589f2c7d8dfc54b90481a9e1b19ade66122ef7d192947cd8cb79e76b8ac553684ff255758b65ba01357f783562930e363860bfbf9915ed8c6c532be7c674a466593cc378b27aa531eea51e3a8b1e16d0f689d1b7d5012c5e54ddc156c3284e18dc22eb6c720a0c915f54678faef9a7bc2d85a2f8d5d5145277ecb8abae09a41dbfaa8ddbcee0eae3fd6027339d90f012b12cd039cf2bc97ba7f5a72eb9638623ce200aaeb6142dbc8028fe9ffb8dba5c1d86f9b7bbf626b597d09b64e802126bc496482cecb334d308dbbbdbdf5d744f96c2eec7d23c74e365bf0b7ee73ca4e8e3d85536fead9cc95867519053b23285c095b3d380d168c0718097748c5529e173758a7c2965fbcedac193ed2f4d9ea65ba088ab2d7a1d0729e3dc52807dd81e80232aeaed136a00406bdc7af0660ec130432ac38538e7544b0cee771056dd577a7025e00a8958d0108c77b2ad94dbd30418e0e54f42bd480d75f1a8ebc6379b76dd510e1f8a7d49196511dbf486eeece4d27996ffc3239ff4836f393f64469b0814de1d61be8a0b00ca5685caf6640316449c5771a52185e107076659c2c496f12b7113a3bb13356d82bb3c0a6f0508c5683dd7b754d45a381fbce921a6cc096f71ab131dc8a23f510489c4d825b37c0826eee370ad1cdd5a13c879630940eaac122e0e8d08adc9fdd39d4ebabeff574411957e6a0acfcc717c7a31aff93e49941028933d61b196f8716865f80ab8d8237f8052bf42a67388321e3c6bbadb49c50f82c8210e858ff26a0f0e7e504f51d4a3d0635a78906d4b4cacd9fe0d8e9f6728332a1847e0e23c84bbb2b1f114642b44a87dae62230fbcf01634acc481d6e9f88cb1a6a68ab6f91a31cb406ef643c03ff45c4e3a321ec3bc38562e282dc5df767e7fc8c9ca1416d3d02b4c0b228329093fae788a9aea1d3cebcb26681df5789fc9afbc4926294e09688631ea9fcd0243cb1d4972c8f0de045d61164560247096b5e848131a429ee0b51653e88b23d24ba93760c3d5948b71d20a9142fc40eba0438b3acec8b618be75bb16eb82f295372e242ddf57651ad4dc32950b5d429065524854bf4dc6fca49b2fc8e064d359270a0182f1b65bfdce1907df4970a7db44e2c3a80bcfaf4c6be13293ca963d64a4672eb9c75eed8c1cba0e5d4edba6f37c4a7935f793eeabc41419626e994724e5ffdb36a58d080fd7d7e1f9b4db8a59ca1bd21c44ce34551cd3ae90d85f280a7ec892873420281039fd173e49a6072f51545db79c46e653e3d41c6f98040a3ff64fb982d41f622118ddb7e16985c4f0f2d8fe72bcb8071360ff5ca6f6405a1f04457e22100b87a850bd2ba9207c8bc2706611700782799b329230c71ff11b56abc0d9761794fcf2173183c80bc669aaf2cfcbac537cbe01d9d693b3998e6d37d98c55df9277d11b15082e44828b59667040e6403eab9d841db3b4e3794c9fef68c1c1ece7a7d2c2d04361317823b3ecbc7c1fc84ba4030725dbd18879d34c43344fadbb3858f0863280e153850edfb56d243d897a009c041696eef77c9ece1455beaf96511229673d19b85d07945235ab4262d777249c86ab1083a995f8a7059ee34cac31fe4e06cd100750d888cc99492faa32274b1d6b5491c43222b7bdfa26e378d04a621d4d02d24fe436239af7c62e3934c5591322d664e6bd690d172e2f882543e4334d9da752b1e25eda522b9fdcc90dd9b950badc71e429046f0b9bb985cc4d5f467ddefb98b2780eb504ece9ebc207bb0edc2dda2750b87613e0993c787d39ff20a2641062261222b56ba24ec8403db40385cfe8f96a8fddecd649c44727b8b21a2262e75cd1a556a2f733ced0e02e8f1ae8c895b1149b89359c12a6c5d098fe0ec19094d338d46d8c2d147417235b0f691c9e3bd950ea0351d60b9ba3d1d8d3e5e244aa11fe2c50ee9f54cf7938681cd2e4bf592955b4fe116c186719226eef443b3da3fc79eb29cbf6c65001910990259a84a3dbdc01e25b2553c8afb1152ad276341f00f45ece35b9dbd8c359068ebeff3b3a88cb9982efa32c5f8fc3c82792e5988a1f8d81bd209f2f3d95e6cc4405d5381f9c40fac8156534c7661df07cf8175aaafd6979abfc1fcd2924cfb23604319397622afbaa1d7b779e7994a1b9b9555aa48cc6bc49df82fad1e3c9d5aa3beabd5c77860b4b7725d7fb244de9bdfd48051c9ceaf7ceef3f6913e01b52f33fab53447ad33a31252a7ad1e48ae7c5517074044c3c7e85c696c555e156adca295c00cbf9ca8381ee7f1e5adf2ca6a0b92845a6d3a5808617934f365bc9d04402ea8540afdc630d6607364fd6305734f6d86c3af7770d01c7e75a1b7a16cbfbd0af6a07c9fec61144fd34d77fcbb0f84b8d6d95c7c3f7a1ebb8bebd416be259311afd98373bf92b0675c5d1ef0119751e7da5daa6a849c2c7addd91899ed79724eaa26946d1807d9948bebc5bdf5c8d112c61393789eca89e254eb6ee8d750fe3bd9f5e04bd4f83b65d824e5bcd23f8777cd134a9f8419692fbcad31e587efacab7da9554cb98f903e68190e804546b2faa1d26d3c0458abf2c164a4a39582cf00132332b9b6ea5e77642c9858796f1dd9b1684c6802f2e827f6e212d0384464a1abf72dc8748ee50ca1b6147c1b41b741eba1986660f49a8e15ec221c6c2f90b5df136fd9e02fb17236febe979d28c42df44c4f367c0f9ac296108f94b54d8c725267e6ac42645014038069037fd881c9ae301d824df88d7ed6b7628f71a113dd64d16ff325bc8f4d1b24dbbad064cff26aedcfe6cc496d28931d99e909a8a7738317fd40efcdee6417b4f131afe1cfebe7e12a460b850c0c96638016e0db3d50c286e98be5ab5e14eedf99e300f0af78227127e03d521412a5c7262baf0905a9380dc4b8f49c6bf3044a2f9355dc14ed29a0c9556d2041fbf1fb2dbcf31f4e3f8a3d57d109dde0e0db4ac185e69d11cfbabb67cc51f7ef785002a3fe56e869ded186eeef21ce8857213622ca77d6761642a5acc2ff64c50aab73ff9f00c446be7966ae6dcc24f85bfaa8fbac98049401f70bfbce1dcd840fdbf36d06551def65d4688993ef8a633950983b22618b6362f6769c25c201b209d58b7b2336ad397a9ae4c9c057b9cfddcfdf0db5c744515fd99ac5be4d8277225121712b90756384b50be3cc158d18670aa9aab83de2340dbad16c31db62d2b5a4f342fa4d6841f3964b40b41fe9886a4e189144fde021c85ded0bd9c55cac49f7520edaffd4d74684d816d2760d973206fa43f3ab784bbf1a0065788b8ff48d47ab31a9b2aee9e8fd07974525db06e5e44fb3526971b68145fabb5c4f9e1359c0021bf6943e01ae1f87e223f9bcc5e22610cbf89e5c62241f994fb18732beaf653f9df2d8b2bc8478f0d1951cf9ed0f3e1d16f21c49d01c16cad3d644123edd4a31d1530778ebac4224bdb17ad7506a29fbeb933c9cd2bfdcf9e4b1e51ee21fb65f30dc2e782e207064857cac755db600b7543387a5038de2f64662fc4dde1f2c07363b6f9dcdaa7dfa7037629684e6a6202265f1cba2313e220a29812b8bd8422f91603fbd73ae50f16e29ad28b68d6c3adf1d02913c01a3f9a0e3cf370a52759b0a4fcbf1d62a00727bbeb39658926ce23e9d37a0306dac8ca834404b07b08a3b3af0ae160063e18569ba7436139c9a153b35fab6039430b52f0d09fca21ec8860001b9be6fa9406d28f6f70d013e08205e34a15a7052825ad61c9d98130451f0096981363bbf370b4d9065adbebcdc1dbe103","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
