<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cab119e77e69282c5cc355fd32d07ecb340047ea635117a952bb41bf3a0c220916ecf7053d1b6a322fe458eb5b7ab2a3d7c998f6cc57493cd16cea99641ab6ae5983293f5c2b5d76560acce2311bd187e1b3da199d136e5a6adeada89fab60264f9dd48a6fc4062f51a165f5954d0fb9f771a9c9cdf7c93c62e10ee010e22e877afb68bba7596c67b650e53e8167a8e92152a50a3249f43dd2a87fc2c21c98eaa60e3fd9c2e163c14e0fe3596d233ea9555c36b03e2f47b6489bbf737b18aa497fb01fa4bef61558ae6efb3ed5fa6f9eef41791abbe0d85fb965b594a88379ccfbb21a76c8a4ad73c23c4a71da0e373b15d193aabcfa6b72d48f5ae2511696461b68ccb97acf5ee2565b7ee794650cbbc11743c87297267fc726f4061a2e4c99d712a539237b610ffe0534530c8ecd0437c8c452ca08fcdf228326cb77688f73279e74092d3ebc00d533a418c22416136c1704fc01770cab730beb5e2d36c3170f77ba27252b13f14d8387747d4297f56d5b3ccbd1bfb99e3348d7bca59bcac04baa065d4bc1ecf501e2ba906bd13b52621780c35f2ffa2a4d4df8fab3b08a07047ccddfc5168fb99de466979db8a96934878413b173e939ef1c961004501b05724484add3aa11e7b86438aba211786c25da7d7086fe3a60974b1e6c608d495eac933306ca72103c4fa2b9797cb8ed39e672774402f63771c392e8f0719f3cfe3308db703dd0aa7bf1a0384bc3cbb76b4bd2613f68298b9f2b95b492c992224d0681a0a7f22f5b6963d1f03d22ed778a4461e4746c25bd3d84c4b1d5b6c6a44d560ccff6932a3e72f0f5d82343711038cef2acc7e60598426d511a29e19934d97b6ed573d48888ffd53bf378e3c9b9d2f7acca88867783693750260a17ee562c535c4e13ceb102448a18bec44d99c295b8958b7a71e45455efeeca4bd030a9ff8b6e8b7d05128dd5095a25d4f71b40be0041c8b74877eaf5f7b7c9027f2e339d53dafef0afe2221fc8b6c3681ad1baeca1779d44cfa932ec4d4ff3111093146041fcca2c95465ace2f4dac71f3586e6f24478fa84a91dfd0a7639b0309e588038b3b5a1e7fbdf239986e895d2e25b3a1a385e356ed8b4865b70a0fc789da1421b28a9c79b8a26c564d506c9c0a474dc4f996a40c35dc125b1d296f190ae7b4ba8608097799087b54eb6ed656b1ebec1469cc7812a38aecb6a5cb709167da918bd0b33b0eaaa32693d8708872f4a260c291445f97d6212a178ffd9cb68436fdeb625278b5813c43b9f11e0b9e9fdd845fc3afeb2a89b039f97c47cacf8ded10f595d9d4124cccbe0df67445a3cb086ac0ec01aba174124122d75bcc4f85dff563a76b7c9df7d3fcd68499e96b98cbcc7020cd4f2dc7d16528f7f9ac5479719ff9d9ad66ee6973fe71b05b54f69e2fae075271e91823aafd4d1e6602572ae1aa59a37eae11e980f0853da5ce6c6d0ae86cd6f1713bde397331df973a6a1e2556240b784adee05486fad230a36bf75487639660e58435a514c737fcd24a37e62e85f8d080875b870d31f2b8fc74ce9f8090d5ef4941ae1cae3c78ba62a90f5c49c645bf551b9cf6a5b20d7c3b100fd35c4ac40e4193fd0fe524cc4548fbea2d8eaa7c685240df03e2b79dab3375e5dfb6fc685641d73f86332ce4fb70952bf620ce13c176107b0567c4a8c7a81cb08f6b59489818a5ff736051f46ad14add5e9068720157bfee8688e6e912749df8f2b2f4f1c0d0bd9d5ecddc088d2ca6f8ed1969359c97d323e7af18936e28f1e65f445bb0c103c51d693643859f206512563bbc584b1b1c2a22f1cefcac92beef567f4336f290b2db82a3831674acc228c7e1dc79c1b269088072792c654fa6475163185e59c52e686f91fe8ee643b05d425f0daaf1b60f918faa9a570a617bfb487398632b18eac6d63108a325ee7deb93c22ea44a7b0c8b1392e28d33d64f42b23b82bf5605ecec1a513347860b21c976766facf69b7ef8c8beb22ac088f78459f308228ff9be2d9c038d92246a5fec877b40bc51726963931014f745ab484c5385e7f4db64a4548099ed144d2e28afb843a2b04b385a454b461f70af5c74ed609a4d147086eff6134d01f6b627690d8703b4ce76331394656cd32622971ab65394630b4999d13f6de06e50e477f5c46c655f34f3d1f3799f795c0744e86ddc65abe973d973e9f24b965f14e70c96bc73dcbb4f2d24dd932e8d34de4a15fb21388dc746d19ed39d6e07aec001f198d1ecdd2f5052c3add378b28c89dfed8764213bc9a3d7a0e203ad68ca37b358d7f2bd20f7819713b71fd94cb3331686c3ac28491d5ba61e162b94d21ebe19f286396e64394c08d001d51eedc76c2e6bf0c3e9780c5e41e4ed6aa41d13b57f1d882a8898824b637695aac0a83a5086f7dd3849c411d2184a3d51fe15622555658e61d79d86fc9231a9dab3073b6588fa46ad8f5f479ddf52ce46cb2f756af5ad9dfb75235a022185db67fbd78b14ddbe35fe799f66a052a3170f2e43f95c14d2992fd60d117ec56ce2d2b35dcc69e8c0d8432a0671d307eeecef5e6de0c77c70f9c4b173a95df1cb6b395976bb2b03fb40e4cac35cec7debc93a0fc6c1b71702f72d0fb93918080982b9707f77b16e7b9ea0d299350ae7a674c39b19973b3cf27d7083d533e8552c1cfa34e72a4f638deb2ccc45b41ad97f55021ec7f09d387abe88380cd0060f1734b249e0299c15f8273aeeaef0ac2c36fa30400009672bc44e64d92758615ec5f409a3d9df4d7423c19220d14e3a73442887db4855162d0fe3d9d0ff4e8349804a3b9bc5e5c5e514580412f1f23a1d659e6998e4947d7d0776a6e2630dc66afa266a2ea8075709315e1d1b9ca40a58ec94afd5141d1c9caa32f69678da4e8718957aac7268e0dd40702f995d254befbcfc17828fa43680fe09de86122f18babe7e0be0bd374a865aba8e521e5bf572f9a4ad9a4a08ba3050ec53991b808ef3f8429d59b3f03f72aa94ce1df6e91e6d82c3fe1f6ffce1245e4bacfd3ac00969719eaa94e0f828d680f06c52199c94a86cd15cdb54135db989ac18bd11e99cbd52614caed8c374d9ab49f160257a39ca0cdc92824ea1132233eea9eb323791b226eb6e2dd337141704290f462ed3f42218ca426590daffccb07ac4639c9a3c52e7329facda1c1a40407f46201d1a982e401014d01e29e07806f5ce8684c8318a91c0a32daa4fadd289a2252310b1adccf2f6f51b14fb0c8910695a0a12063f03f492abdf17cc25ee62f3f80e69a6c5d5906a2327af9487c8b606702098e75f4835b8c04769962bda94af8ddf40c3ce41e3cd5eeb76c306594a11b759ed0c110e0f167b1f446067aa651ab1ef662689133e46651754c2e5b5e43742928c1a924c43b30ff87735e9a4708cd74773675e241f075d9f2fc75d97d33c616d3281bb0d75b59ee1cedd225be267681ba8a0f4911450bf3d98d506b840ec3a8e6da0da99546a0a40598776eca8ce6ea5d2aaa5a2b3c329ee03e61573af4ea725edfab7efedbe9a5cb03e23c26d4394525a9d5482567370e2a8de2427621ef09705e629006cead3add93224ea8dc531e6442bf5646a082b5195002864c0b5e9d9340e01e64f98d083ce05998e7596474d7d06c4d7d4d2e528d8f1271665fc86d653998389424e9ea1be8d25e9a5f6cc0b3ad55b1a622861a2c193bb295517e18c9afac638dd67089ce0af7d66c1791dc1b6f68de6f8653287a74f2ab548f5e27e34f923a0b9242a264e1b837c59260a537826b6e276ca804991eb24a83239a013c599bde8e69ddc24da80d4a4805bd760d33af35cf0b96b6c546acb2250b57e7f47791ab27e6595de486707918c426116a37a1345d68294ea2a4b2b492c7e087ab4002e818c175becc5839f77778af91e4a9ae4ac2e47d9b16b0aeec55ed10ba2cccc1ca495605a8f3a48519e3543a627cbc511abd23cfded8373d209fd7c208718f527fd80d64d4b4fdb5bf478fee7a38d4cb0390aad6f8893a9d3fe4ccd8bfdb39453712200a8ce80e24020a6042c0f3b737818cd5ce9ef92a90df4338d7e3497cc026ee4c98fec265c3880c06b9ee3b02ded538a0bc390d3eb074894db55f19a574f86e433b6153b8f8e231c69614c575644f39ade25bc570640c9ece197eb4ae0a3f741f24288ab91ca22eace7b82a7931ca6ddf3428e6a17012a3a36e87375796f98ec95a428542b6911359e05aee601da73a8700012c0bdba4e56ca9a502ccfc52f96f92708029a1955b6b3bfa19df2af950a101e2786be78ecb0d38bba3ada0eea918c5f3c5eaf184815150a680c2a87d92ddaf487bc9cad61ad69d566aacc23dc64f136464df9d64899c83e8be2712d54872ea40d5f074d3ec7bde6021e0089ed119e9816e345c022f9228f6594aadc2c1b675c299525d717a8c525fed2f765ff2b7d72be4ea4d9807c80d4cd320399fdd305537bbffbbc6d19e196ed8207eded86918709f181c75c8a21a4fc66161981b28bd62bcb615d324af02348abe35e74bd02a7b9f38723550052ad3e7ddb9d0c4c7cde122317d84ab3d4047072565f9bbe6bdd71556b16dc2d3a7f3fba2b6238f6b0d2c6ff35c3382d2364b2a57c5f2e5be404771109605d1a6e303dc950485ece9650c6c8e1032da90a752aa66df4de73570a3654c0a45e84c52dce9aaac93230d77e3534bf90eb6426c8f4b8fad6d26ede26d12ba9b7af311148cbe9fbda9195cadd89a088053bf6885113735da0184535afbac9cfdfc62460d9c2826537c1eb1e45e7e05fb1ded3a791c83aad02197cdece6cd25a1552152eb6773072b45dc9293a7ef069ed3f51a9157018c8db44476817d137c254a6c7104857233b6bb9be7ea669700cd11567bcc677b1515d07e0c8dff4ac4a2cfc4c0faee32f7b7908031a32b1bc90eb5f822d4b420fdf9ccc7ef14c4ef518f7b48d470d2eb298b468c8976d7e60422d497ef57b038e56420427cabcb58279cab6656f12a79e7b76c83b50849cf51e8e73dd30a07c28b1fb90333152ec62654459cac7c4fdd6a3678036e79acb052c1419ebb8a4cab0ae825fd6661fe0667b7c5cdb0717b5479f63a838e0674354973873aa1ad42c1dcdaae429a093276fb24154f5b97ac0269cc8d097c80a56bc76e11b797db873f6577e01d6c0985b1bfd4d45b172288ea3f62939a14139428c712192b09eba09e9e2ae6f859f5bb422ff140b7875236839f9a09f2b34eddde6cc770248b6db04622be74b226a989c71e27755826fa4a99d951c010aeb85c8c98dcec4274c4c2d3d2f46f9ddc2c6844f521eda7e1304120e3b621f373ba84bae1f978a40456fb36968694075f4b126d77328835ffe88ff2a8f673b89ed493eb7a63904e63b550f3949b0060243ac82b2f079bdcd1cee89c81c0c1df941ba0f150e8e095269f7df3dfefa33a2e4f4fd6f1ddd249b0f15d13384242ee9de53c52707fbdbfe30492b2ab6b3f9a8f624e4dfe8437445376f3485445be4f97f8669da56aec9cd6251cd6fb920c4d20e5f71b329d59eed8313ee485f803fb4e796182657346769b9e3148be49662193fa51846fbffd14dfbde388966668adc956593a7f5e46c65cc0f2c3143590c0e680d0e1d3ccc43f3ff5b375fc8fb3e68eacb3979f41eaebe5becf8f88a6a5e3fb7acc3c0724b6c8e67e0f15cda6d00e4b64f611f36b1ea9f3c02a0da83b42b4cd32a2c99c826d7d5b615be80890e82e5f3213cc9701a2d88ec6a5e8d72de4f9f1aae3e54672fe6f0185d6b35a4fdb61782895417456cf18c81adff349d7b581f3455c9ac16a9a52f3702bd644e6c12f8be391092cf5e69b265348f8a9304689822e2d3c2ace12012c1330a222ef401af2d3ab7da95c53b458cd578b2fb026f90467accd748c7f963fe4f67216b49b3e66cceb0f4a3413c5cfca67372348bbdc3c7b7ecd8e590ee95676c288355301bff3e13cc58c44feb03ff1ffbd9af79613c9f2f75c663b200246b212fc68a4496ba4a3d5eb168a063bc412509cccf59f05a084e0782374e85768da6ef6a95eba577d888df999a893bcf0e89711d6d26eea4ef2c0c3f9b6768be73ce297e15797b5e601523cf07874d908432c313931bf1eecc9c20645ed767e5943f4de1ba22dec229864711c08e9c87659f49778c912a1381a9bf9c85adc44493fe759139324804d036979571aa9143b1487c86d267b9caa2b1cae78e01d52e9ac0794815d50fc905bebcb28d5cd6c38410557345c1931700d9e88fd876c3962c72dccd86a48114d0eef7af03f4d94e2390c58f7e5c42d7c05e9c63b0c934683720cd94e1fbd153af952e6d3ebb39454294c1c954e2ff7e0be4351812bb443498a6f7eaa6162a894377590bce2fd699cc5b26c2b0d3a122e7f678f12e344964b3f0b1b78f1f86ba6138ca4b2d02bea095d1f4e2659a2f83a9977cd1e1f61d4a87acede201d4b7bd8c360f0f6709b142e242c253b713ca866fbb99095400fd9e272045f6ab7aeafa8c8ef4b3409a178455e6979c3d340af3e0600d951ea45cfd2ef94603a264739835a6930516f9f83bb3b5b098f15b4d1fcdc9ad9d83280d910615426a933451627d28aa5ce964e2170c0fcc7e9072dc2edeae620fc116074c6844995a9285088d666a7a937bb95a3985f5c24f94719c449eee46345d848ff5ff8ffb1cc2e6b1cf7b167c8f8d8238dde6f1d5b9d90670ac6f2feef5a3792203654352167124866b32034de41746f552d826be6c466520a7fb60d9d62b273d8bcecda050857636a23d35b902fc3afe9529824fabc1b984df5745040b38695c14839c2478fd6f88c13e462d73dd6c22ed77984c4cbf8a61a43ad96e84107c778ebca52ef6f98c811757abea61a26e5b7d80eba5966afe27aa98094269d2086075919b8ba771973d7aa9301ab92fa5698f47e5b83b007e40caf7527399a700e84a1c57763b22089322cc2f62e5858866237d842b840c9e48bad01f266ba7dc00934b89cd11ccbfd4873a8a1b2e1e79f038fa9191389a4b2730ce1fc83b7e65ab57811e875ff1cba72c8be69aab9803a41d810326931312c87f190f592cf4ac9e381794531223da1ea4d1ddfef99aaa22e6b0b78fc1f9ba0635cfece96aa47ca443398c78b5489a6219cf60289f20fe55487880094a259048a2a7a16f439e485f5a1031b65ccfc7690c498b290af4cc5ec6d4243dc9a5da2e77b431f998b589159a1759a161f0ba1eb5389d4ea533207820f11043a84d7e466d1e25ce440025545a707bc5853bd400a797934e54f1a8bc3cd594574ae009985f1931913c32eb9be9f329a4a593e5167d2cd52fc5fad48f24ded69f2317bd714b8b8ed810e6225eb1b8a9be75d7998718430db44c73e0e25d2795a76be824268acb2ecba1a0ca6fb4f9df15e9a0346360efa044978e54abc320f444344504067ab51c13f42ce3ea8f93ca5e6bc40e9f51ec0ce444effee6b4e3df8493efee691e0761b2ab6e6e0068ff9476678e5533989dd25eac9d49b2cea25829da902591e03f274a21ccfd61084d89b618e45ef08ebeb2497df8e86cf9913fe796a5e166bd64fda4ba5007f0e09a4e3404f22bdbef452d6ed5c8757f115ad8ed9bb732e2df1ad62df14e58eda8f29775a26d37be7b0e1f49a50516db0d90fb7a92a63b2e0cb95e5abc21518256dd36147819945af3c1fcf5fa00450ad83b14ef0279887c6920d88c63f80d6d7936ddb239cfb2a8ec1bca43259c19f9471419a9d802c5ec0c8d84b3dc57297d713185a862a7d7ca8847d92fc3756b541c829b17aa83fc89fc2fe3a8d86e856866e9e847e1462338eddc5eb11d2526864b6de14e6b5a1f0d89a88012c051550592d1ba13078b4183d894c2c27084e0d924cb74b0220f459c281e2ebb3eaacb72aacc8aa225ae551d23a8ccfc710ac9440b8e80c6dbb689f073ae231c90db5e17591d1df1115925ec77f830066cbce61a118667a66c375f54cf1228973e7828924f35071a3f66dbb69fd25aa5cea4de1ce1fc15ef522cc255d43ac58c51f946ec518b94d788777894ef23b23b3867405ba5a232898979e1df5ccf6c7ed7d29fe1183e0be852417e6dd8c1f146e9ead4b86e71c63d3305300577811d68afc93fb461a077bf810123790bfce478d238602d02b395ff7bd89de21800c889c95e52206e11ef91fd094dce17856ea5d72e0e51bdaa45673efcb6ed2e2f6506601714669b75cea1a3da66f620916199745a5db50bf2dd771f77d2eaddea34cd532648cfb15d5758066b56994a0638d9b9b856c887e65405c7d1110c033d5e4c7dfce1aad761d3f3413c43ec590e1f8ba1a0e5beccbe6a3ff1ef9c28728188a9dfe85d4c831d03af1f3c58803cd6f53c4d7d7b2a60f678e2762fa7d8880bc116dba094da46784a48696326302cdabccf274206d6834900cb41a9260c56e6536658401f7c03db29fd9db11d3cdc1495652378b9eee667ae30291124908f7daa2e52165be1d71d80f4180534e9a9c863e2e26ad99479bcd2a0a566b782e04bffd4d7463e5c4c70205dd9f37708a478df8d267dd38653ac2b51ff903c9811e5175d24222162df596543c4c22663fdf942e7e9814a05c34e0e6ca71da95b3d030cd14726a396118bfe2c1ba6af54ccb5a977c652e75c1d422920983cf83de03a20f3657accb0c2740774af84fc68858cd8a9c1d77a50838fcc868903c4b0a81dbb4c03f2a4b0c7d938fe14c5f00810a31609dda377b6b9b3766b00dda2ae471359402b4a59bb519f962ed655b8055e0b1e71e426aead2942067666022838a3816d64b883633be81c5336d156ed20b84dd7219ab3482fe02e662116e6166257bee9a62a51a9190f74628146cffca0b4bfa4d003f52d3ac279e010d37916a9ecb489da36e66776690d43f0be8032bd82decc651d781c94083ae9c64eae6fac8ee088536d8118422a1665f07d90b38e59624ee3f761b1f87b8c84b5e8ed1d857e7f8e4eb9c7d45ed541198ce390b5dfbc61368d487abcc4c59eb4d5a36ef5299757d28e7102672abfa50d059baa9a69975c72c904c3a239b769da86e1fdc34f6abaca983f0b10e595014d60b55b3fa90df210d6c2942decc2824a775a762db0562a57d8bbe834b0acd57e49fcc3409c92c3484af4f51ed7a79299347d48bd9a9aae6e60b65b7075b8aad1543c2855d43a620fde8ede95c6242d5feeff83352dda4e1ff6dee2f315fa8fd352a9219c6d505d83484440194ed3eac98af226c1fe95e015fb844ff46b613c517ac94ea5102a3acf3cb7a98947955a67cf5f211bf3d3e1a4739410662449197bbdbbd2b50520d02aacd1d2eab7ad0312fef054bf8acb42c30cae6d8aa0447329ae2192d4d89674ea39527611c21f6c442f9f430b51ff015ebdc80bdec1a50d332f0b02509f19fae7371a868b3c195c0895a0a310a3b999b2b59fbeb5970d857fa415365d94529f05ac4fdf9057d706a611a7d5099283c779be2842bdf88e5e8e26dc0ff5a3b7453015335a87fb449d7ebd56cbf8611ec352345b15576d8b1d5681b78deeb22f98ec72a7c6049f7fa9bed2f087993e7b63c7d3adef2c00b3cba761c3fcd7503dd32c1b78b50292816dd86413839498f731b46443577db532875ffad888227ce57151578e3aac4c1c3d9ef7c6ac9fdf8021fdc99f1b9638fede3d0687ab1267c25b6f686e08b93210c1000e21c609fb464bd32e998288c05ff5443c31670ab3855385206334825762ffd75cb3495ddb924be1a7e2d88b486ef7607daaacbd222f23ef56db44acb8f73887d0b5922c5d047cb40c799a5e9a62db5eca0f6a0d0bd4c6c733ced4c04b0babb264448f44941b4927e09218373849853301214458ec1afb113bbf0cc37806cbeae4ce68789d3c5735190a19410064c9d6c8c2e06d48ebe305fde4cb417d557b8ad4a6cc843b499931c84847e97ea250ab3f0532f13758c6c5f2ffb9857b11b0c0e18365b420899ef35719dcc282015bbf7b33a7186006196f712675b7477548815662337f8d2e7468832927057e480d6e1e513426240ce2191e0d62eba5e313d55148d10b13578f224138ec0e3a4530cb31389fdfe1ff905b9844c46d7add186e89ba5224c111a6d0cbcfd794c6151f82ccc173202c595996fe34902ae302cfa85d8dc6c43c6cb1dc6fac3a58777ca6940c2c3bcc858753b6ba64a7763704dc14dbfffd24c5f467e4af8288286db2484790d2c346926d3ca90e9b1d7176942f8c9d5a8c4e1aa99b2906a642470a35bb905c3e57f4717e0f4e208e76d379ad2af4a99052f8597faba02f9d6539bb8fd43493153ef552940dbf8ded6298948a1e71bff7cbb07a588de4cd3b5ecc2ede48f0e39c1bd6657f61565c8934256c836492b29bc30584dc51569a131d93dd93ce69ca13593ad8ed0f1e8f86ba446482c1ac23024df5df8ff345b431564730d4f1501c0e8e4feb8b8bfdf5d06d36df4799381fe8f961cac120e27cb425880d679639d7533e13a5238d6617b46e90356ab35a3330a98560d067b484c5e58f542293db25d3e287e94f446a493a2df5bb51e82b58de5c4ea9bc96b41f30c9bca34e9148c66fc4c413e37004a898f498224f8bbaafad2cf555e60b72740e921221479096338e206ba2ecd9e693afcf013d6e5071c78c61290ce739998f1ee19be9ce6254b3fc0758809db08e68149548542efa9eeefc2bbb709bdd32965969335df0d1e2adcfce2f4d6a9e7d451a25b1ae212df3e8fd24f9e52b8893e49e96ac27a9c8a5e0f912aa0365cac904f674204f9904a4aa08d572be68fe1b9f0b4e6b0cdd7e4ac72397ba2b41361d3ca6cb64053aaaacb4edb0bed1fc3ac03c754e8fa472c0f3a12253276bb1ee22021d9a3c0c5a5846ff6ab3cc5d67f28d4fd95d83d4f66c16334ff4e2e49545e5218f3e7761baeb48cb7b51ef8a1588c09fb6ef26b0353a7841572f561f7b308dd4d2277b07cd2164fdd178024b86334e2f738a358c85a155bbc0521d5b25385ed399988c6096b64445b4abc077e0542468a0d6564c8fdbad1967ea71e6ba2e7b7a5741e1cd5d463b81a7d48812d0fb3d85028500aa24b2fe9e27a0d4b102bdecb4443a167351a02a8b5a36ab2394fb8e208f59819b55bcfd26b14a94b49428b00f804d961e5c588c8c340f57e019a80cef537424dd70e6b0e61562b08a9ef236f9f5c9f45b18b631222c124fa4f860923570cef75774972ee5178a3216a1517354a5b40a856badef54f99aa435b7fce964dc596352f65afadc49dd52dadf57021b72f0dcf5344db791662a64a2f64fc8ca9cd8e3f24fbb817fec5e53babfc6f7686317ad75e6842c61b13d32ed86ad906fa4dc71c1aa33599517bf0afb26a2c1bb913e6ae90d95794e5ce9b19702ab37a18bb8ba8ebe1c37c4577068055c8484c308e01d891a541be2808ea193cdfe7a01f4aea16370c70da81bf16f40f27fc5113fde96c3c3325ed9ba0294587612349063aadac018fa162af60d96feab2fb6e83740c7fe9506c3d5024e9c8cd3570e479a9fbef4111fe0270d78a710540f31e2e2238c68261e9b21d3186dce248acd282162df999f9f3fa2d63165ab5c8a6d4c01f79574b5f3eae1c8ec1bfda131f47602ec39822081179818ee252eb4a929956f36ad906a908ad960106dd7a16a1d84f2d4f8d77c50ca35d1cb9379764e5ab6db7e7dc9bea2b17e2b6836b3d235e6a58d12da4a95d82ea39bc31efc0e0231af1f8979c1cf21ca03858b823ce8954cb5cd5441b64e087796aac56903880908b0be0f104c9533a6a4aaba639e5d23470ca888d29aadd19cada41eefaf64124d6cb9f2e6d09f5313b29674b8855f3ca9841f3a7cdc28e22771774e29de0a37dd10d01f337bf5a057304df47e53e30d5a666910a796917f5682dbc77771b331e8da0b0a58f05f71646a21eeeebd23421c9d8ba15e6d9e77164e360103dbf9aa97ef4bd7ba038b21c20899639be42923fc4ffdb3af344acc3b7c0f2a9253e7a8824f67e3912e9ba58f4561bc1c23737ace8712f6fa8f343b107aba747f20f5369c5d3ab8856489bac23b0aefdd95abfef5091ce43168371f83dec3d88cd1639b6933ee0027b0feba5c28bfaa73ebfabd03e974251536ccf3986e9c11426cc6c4bfc4e81917b3ac54c41b55ea852e6454b2a1e83d323e5338eabe8ceb9150e85dcacfc3e0db038e9fc881eca60975526aac8df9568b8a34cb445d001083b8187609ef749c6566be1d6f5b0ff19fbaa84bd85dc7aa8c7079f3f50b3a35a8cd7cd3718a7f65fa4e81b67dc2452e79cf61769bd0948e958f460ed93054612a7cf384e38f13d259a6d1af37a9d973a3e42e53a04d703bb1d7018df3f9a2b33195cc81410bb220ba10997aaa102ebb939b8673007db0f9922e88692289c2ac4dfde073b471081508fc2e1a329ca2bf99e7f6bfc696fe4610eb687681c645016cf42282442fc74d90308df3f31b829a563ddcea92f892db48257d332513cfbc95d788e131ca691b9527e9953b98c3559ae723132055ac9035bc395fa674a78775e0fb82159dc006dbf5c0dba27ab04454383f9219455dbdef3278d2e9bba0efe3cc6d6e890a618ed57722b0bd5608c105c1192c4b9789aa35ed4d464c5cb572b7710cd559873bdcf4c0d6ea3fdcdf937b6cf8922fd76b59dce7093727433edacbd99323973180f6dda5b4f69b1aa5941163e8d5709b37c8390d0e2d20cfc7d99a74fad27d2b75301af200398676f66f0e9e4859159a3fab76f9ed09530e3c715f35fc1b7e96f79cd1ca55a34729cd3b2580f1c182bff33dc07cd9fb7cc599f8af247ab2c71adb867511657961870c0ab63e47938cae7e5a3411c6e80b53230fb33991ccd236b5149572af96998fc9260817d93393f0a7ee3c9828c3e99ae8d1fbc2c96124c481370ec13e924fb37cbaeb9634afba6cf51faaba887fd517250d9071a1e3038206482bd8a8cd9499b68af411dcb40f94cafb42a53cec6079884fa5ae7cd77c3494300c96d24804282b871c497ae987cc79a71eb57ec6ba143805b204151cf919308ccc709744841449f2ff789a764faa2638861a88c8ff3063d1ace7aaac798aa71fc098a028cb737b84380ae72b41e756ce4c91359c67b635552eb78d8384354342c4e0a44ee1ccc2e2363e4522ffa515702d0d90a8389624ff11266af23c863b92b79d2483f820c109c228b271cb468a231aa26b37da1dc47388547eb4276a0eca417790831473ede6313dbade2630435dc41f3a55173902baef4ab56be1dc21c6f5553b0837f9dc025bd3bfbacc09e1692b364adb8ec8fc52ea30ec614fdcacbd204dc681e954b433904b6d3343cc73ba8fe95d2e4089482f08ec183387b666d53b23f2b7cc9ec145545c436b86995ef4f918ac38b1ce62bbd875dc7e086cbfffaa76d6b176543a71c4b87f62ed71d421db84259157bb745a0aeaabefa088df6238905cfd221296b976309d23663825dac99cd6d707874fe6f6b7d91c85e398c07165b3fca9713bde2dcddf2d62ea809341941387bb11269ed522d742a8b46a699c8f66ba58fcd088f2d01a3a2921de5c54826db30ec67f2eb746029bb134ef0ffd7926391cea5024992fe152cb068068e136d13db2da48741fa720636d00e20d489b1f53baf5825c70978bd43173ca17fbffb922b3743b4cc78bdf951eecda83f11f9a6f84f8ae86e5a017b9cfb68e2f26acff6775d1c91aa6f0c817dbef4d0455c145b2d771fed554a7461920222551a5dfd0c5c6d11c743b801f54ab625cf61770c9729b035477c37fa46b2b36db2e9e6fc63b545f9f6da82da9da86a59ea0cf1d119bf5fdc40b05df730314ca303731fd2cce592e9493d4724c4122dc8096561116c99c7d89a0a7dac897c3bd98c98b0c3555425507c848b4506e6b929b13737131c254b0f3c5da29947f9aec5f0281db0306920cd5369be0e5e267c364c2486086cb41ac7d803abd6bc619bd2cefb6be2a7277de8b3b2c7ca9ff2bbdfad183bcbf87fec8149b219f8143f25d1aa61b42167477c0c0042067e36c89c927496898c6b3cc9a70b3545ea0caa390ea51190ce08e8002521527a047f2083c295e48ce62b5c29796fc75946061ee2c8860f091de2cdefa9759cae4134a2166f3a7b81208c1e5debc6ca2a3624e5bea59f98dd5844454c984ffc1c768dd7cdcf55d5d7b03e67e0193cbb380090d64084772cc57270d0261b96fc7017ae137a93071d1649803cb92dcd6b60acb29301d66a261825e2d5670e92ccf7469ba016488354d6c71193133829f17961bedd312673ddf383467267985f0b17893dacb30d97b7aa4b70de533c87fca16c8307f24f65ef3a19cc8dc36f00de8341696b2d7a54b97e9c9084cec97f3cbc7fbd7601f9a1b98586e30851688148ddeaea3b1ca923b5eddc0a35510d4c001530a01c63b194819b0499986ce05a18399b2c401eccff20e967cc5ae1ed74520602f765a4125bc867ff7c5e2b8d77609901337487a8dd70ccbe5ead0745832ef1232808607643223ce0faca36b479ad267310c96a72ea6f4f04db71b3e2a60e320c5d78cf67de316cddca23ebdb437435c5c703558f7d10bb38025884d71b599f3620f1cb6a9a6195e4f620b4981f623291cfe91a6b45b2c9052aba7ad5816c49a1d602cbf3a51099177a0240cbf3b7da556fe8b99cbf35e5a064d7e1520837d8af2746cc79b107f462dd5c2c356ec902bac00d7cbf6b406189fa6ee9404c76a9c8698622a8bbb53b297298894e42b6a3b1c07632c62130f4993412c4020e497f4a3937947590273a198821ced80720ae1ac74d4a24baa96ae5d5fea83d4231598496b8f9a104702cb2f155e932bd1d995c6f6cf3673f59cb2e03cb9579c96ee6c1de08d2d4577881b8a110d82de5a9ad750cd80b376b575bab26841d859df89762ef2673d557b0e5879c1f86e56d59d2e94f26fe534d3203572294492e904119ecb0e58021b117bcba658deb3e459e19383c61fc70995262b5a4992e9a874c71b1ac428849293fa8c17f7553cc5ab1f665988ce5801a93319a894a6a0d9bec910437fd03bf226932d6c0c6da0a2ccc7287b69675ce48ae34170dc75784b677caceac170f29e3265b8a75ab68c48d4315ec12c28a42a784e0a8623b493165f864ef46593fc5786ade76038c9e23f25620ac76aa824d9226bfe6a2d02af244ccfcb77ea2257929ee169e89f1ef11cb22e1ca1baeb4614719c5089fe34d2ff631681c5543e37de3cadf9df10d69ce37fa7da1b40c13d1c749b09a25d11a51023fc110aa31352dcfa372d8bb31b4a48d6598ba1923ffacb7b3da3b0618998f31a025331e71a4d77e489997366c1ffee269f7107ff11dc9801353d0c26134a4546feb097474e133643fcac37e1a12c6bd9ef409d955a7acc9aa4b515d18d5d8cf27b199e190596b57c3f9240fc3459d0f307c3fffb698b05845c776631b90b175105d285bd72d9e95c0feddaed426102b31815b104e60445b5799a23773d78343d9dc35a639db6d1888c5eb43a7ca949ea31ae51ae4e6fe3f5f3e28ca880fa5633f37e2f69ddac90544de10f1c1ab29c9b0503e5511bc123be0a65309becd7c6217e8fc23b293cff9fa91bf5bbbb7c16a4e5def8c057fc10c791c4737117b15adc0e059188c39f7cbdb502f65689645e167e4a2ec951ec77857b806b9bb92acfa88fb07889bac9c9ff8771920f669bb0450dae5894f8e3e3830f93d76ef2fa62da347dd2ef9da9f337b5561bca7eaeccf5860a00c1726f9add816a952534391041ad63b4eac9f02472d2f2c21b823fa8e471f2ad1725370ee4da1ec9b210058c236d0e523edbfe77d42ca77faba051447987a00b26ee8618c31447abda94fc8e8b41231b9535b1a8e6483e20746248d70af1ea02564dac66e2300b7ee07a91609add437dcc03538b1176fcc890b612a4c9b90a70c6b7d936bd18c9adbe1ee6f8af708e90b7fa8ca4afea5befaa902f9c7de1b84455599d0ed2f4282cce73a2dd329b85d7413639a091c9a624704ba48e8f5ea7298049e7a052e68eb6c7d8252199f9a8c4fca319ce8bfca7bbe5ea7242d813426234cf30862b867cbdc73814840ebc8570869b831dae6e6c529229f6769cc409600246c3f3dceca25fee017f0e8e8c59c99d2c2b3ff6a919a09188380adceebc41c8d54333a1a029f2ef2493884d5911d8196054fbe2d0679ab2b24d7f635922e157de2f0bfbb44e67fe3bf64581c901f18b25a0bc1f19f182fdd35bb44437942f6a7ec2c73f824629dfd6d595534fdae9e4ba3cdb72f074238d7c9953bb357f9690f1cb49ba6b50a60e20229cc0e7a2a9c3de5005dba19b8071242302794d51e8604758a5487827ced2f4aad708a3e7ab71d4b5728e14b8ad10351572e033f400ac187ddd23b89c542c7e3c263c7f3d08e59d92eae8943051416604d5b7f28ddc3a20622525f8d95c512819612671ae1ed049dcdc7686c687baa64344bd2ee7df63d05a3d9d183816c8b4a6f10ddd884a83f55b43c1810497007e7348cf685a5e5fa9e1294469e61ff2a379a5ccd3c59fcc8871b81c46a5dde633835650621e9ccd8c2c6163b67c1cb39abfd59dc8d311f25fcf46f9619f5cfc159b848bd20f3db45d76ba78fa381a5022bb5922dc5945e79b4d40d6257b7c8ecee5fa5dd87cfcc37ceba2d572d8052080dd271d9af3b40f98391fcc0d6c00a71266bf279653cd6dab4b4e68ca23b63f3f9d576a43627cdf30378d5cfe2d510fb233db4d79f810fb4009035e350a450c5f485983a8eae274c86ec35072edc5811d12a331903f385fe12c8643d340ea27e4aa5f5528aca5581f32a4c7c1caf4dd49b26dbbf4ee697d980b04af8f162c20cd6678a9a04abfc81d882ff32fa995412720e06b78d3990aab36d804756b552e8922480bb5eb35b6936634fb990134a4740cf0b538beae61a53c78898d998bc4c996d910e62970f6928519dff093aa839c3c3565b74835b1e45eb01250c3ff68a45677c17a7c2de3bf264bfb37c70d25ff660c89d60253f7b47d54d629cb5b335c01a37a1a86da0b9f97460198fb93cebd5aa54d0a82fe5ef17d1656e145df0e1e504da32df918426ccad0d50a7efc1200ce51e0864b8a2bde095b7a15354ea4dad05963360b6480c17e11d7e2cbd96925e4fbf77a58b83a5325539377de4553746c9f2347207607d9713036049ae830c61dd145bb8759ec4a1543f3287ab0c08fde210f3fea562617d3884c2c830fc925e13622f94a5b85efa8945bc65a191124e3c7f8806e886fc37bda1d52e24fe139a7726524d2714157d5d825f7b11a74a0307e8edeaf23612e09e37aefc12f6a57e8aedc2961a85fe2c5f630276cd36eb0ad69d37b9d461a474df0174848a45fd00b8c089053ba8d4d3e1da8afab2602936e29aaa6c436456b42f60c0a912f43f777d29bc99207fd71da3831470ba19e372b98326114baa4920c3d6a83699b918d34cc0e63cf1d35949cb593a6e5482ad69b3c81902e4a3c014378b6455e3b615b0dad2e0c8aa0a3827058b44ed0291524ed393b2b42e21c1224b01bafbf89cf15b6bf85ab1ce28bbf35afea2da196cdc04e3c7e986ca5b66bf88e6faba34faa0d22764aced67086f90224e88424a9d4fdc0246d1367694dd15541b58edb329e3c7e0b6f7f1dae3dfb2a089cc2f38e425f17c80bb0d069d019c035689ac5e10844ce19e9b1229ee4e254d56185451db3b4d18eb1ca1ed07df7d778251db5386ecb6cf30031b28633de1f3f4d62314d28d924d9d15fbe89ac7300497697591eaac279c5d7ab574cae38f61b7c3a14645ec6869e8b84cb63866927f8d6696033a9764265fd548affec4ffd43a786655cf711442c619b88e692196625c93d3cedcd4ccf4b9cf3c6ad6800282960797af4c21bf9c0e7f7f6b5c4d0de4902111d22543b8064e78c8f72aa703f3475b339fb81eeb2e079a145a85a68df596e4af4c4a76e873101058573925f7c670ecec08de64ad9cf92865ec1178f19ae64d128f3b6a1fbc60661f8eded703fcd4cdf6f6eeb91d4f652e8b5a406a2cad3ef533a0cdd7d88cf325fc7bc1cc857b67bdecf8bef009108f73461b5925f2b6110e9fc661d8d6a7ddcf00a66aec97e6c55832725a84bff00b8abcc3e40ab889c2ce66bbefd61293e307b02a0566602db8b1bbcd9379bc18ac4de101bc874ad7ddf6dbdca301fd9ef44e667df665428ea1fdeb3e91d792713d7fdf74a9a5364867a5bdeb884a6835a53c348b2d0135b7371bd715ae415e5db611359556eff00d01727e844ffaf85d682d993bbe3cf6c365de94ce0304e6d1ce26af2b540ea92a3ab73b152f6cde53a0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
