<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d8e61d8973887f4cd4488bed58c9bbfb5cd37c5ef756154a6a1189e170f2f5557e8076c4708f83cdd2bda089965b772bbf32947d7f298b3c39ac53ecf3e10198219d7b686de62fdb77362e20f52598e5ca56b3a66bd9e64106aa28e50d21dc74196e6d14ea8cbd07f9040a1a170400b48e9f9eabc86c62750ca0d8976232b6b986fc7de34abc29f327cf6ee8f7ca608b9ecbfe1cb66c314080bdbe5ccb0301c28c59fcf3ec16b21bf24d8ada23952b6817b5341598f8350300b3c4335b4977a033f5b67b50aef63a0572094ba90d4bb0d6c17c2fe37905e15d5755c67c5b818a0b16236863b79f6c3fc65c6f43808717c8b77e345ec8443ee531662c6a313c75636d0c12731dab8c6a965bc2b502e0567e3b5add308e122f4e5915a83041e50ec7ffc385eaecbc3209bee86c6594cdf6258685062a8342955bdda8843a3e950b221906949a1a416359d3eaf5eb0b3f33625f6ecb12b5697611653de18ae726a38374d65f495ab8fcf4fb33811cba6a00a84c718fc33fbbe126aa05f9d187e36c07b63f968fbf6fbc53cfef11d54b84af0977ce77142b37c94f17c726aa0427fb87da25469b915cc2abc7c28a5a5825974e2fb7ac8098972303ff48463630a76cd54faaab039c6dd6ae72a8a761390a28a856b80968287fb5766a77a18165340403fdddce125f7c820cd46829f40613466c2c4ff629be3c83a17ef49f43e61f50c9f6982cf8c7d5ef7d11263471f7cdecc2795004b406cb2b091e9d367035f6246f3a8eb3b83dac40388b3ed10316c4ef92d251dabb337b32db3ab127aeb7af9e9fc62277fe8bf4bebaeda93e318dd61af61aa0dc0f2261dd22c812dd17160a6839707a9f8c3dc118fc76bbf0d9fb93c90df59cf2e97f141943e714e9c38ca3d67305e65d2b418552e168395a5b72c4c5e0ed1e107410030406687da41f37a2e2949c931f2b359849c5dade74e3c2dff3fa86c367817916c51226b4498c27d5488ab0ce1b2024a648d4d953125f8d429ae55ca9d189c3d3ccca07a5312f540944921223cc5fcf8bfa2781d001feee1eb627ee5907664f6c8b63045cf142faeb83dd7bfecf91ad976c8ae54075344e5d904111e291ca7b9645cecc2b86154f79aab1c04aab717fbd42452a6611f628c94a2463eb0a4eb25abe3ce88695872b6dcc3369dec48a4195b94273b80faad17a2b7fef161abfeaed0953fcc4d359aa4cc70aa9c69bde93c0f8c7c53e8f208f8f4db950172e338b9fee5bd6e8a18d7afac9fa7da38b82fda83368d3aac634e3eb745e5d4059f5d1872b8194a0b4101860360652761d23e414bf5b3b4ac0d6fc7d79a1004e831ecee5b652b5163e6a11c57cb5b00ee8ff544d369874791b94c08452b5983d59714e2dae3fc44d4e61059ddd39f945860073521cdc1049b5fea392ab94eb4c9b74aec21e7660b135039e303925cd9de4afed48d26cf003a2f3f32dd1a0e732e56e92c673d85a5250fd653f8556f4d49dc0dd52a0ccf598df410996fe888c7213de23ecde420298a169e27b7d4cda051a6fd238a4025a11a3e4e670ad727031bf826766dff07562456407894a4910063d6d1a083ffcd3a52b32f2be9f0928765b1189e598905e0745dd4a08c6f40da2f181214a41ae23c810293c77a698fd63639a76ffc8050bbd57a82c0216ec6f49a8f4c18a1fc573459a9788fede029cc9ed622c5aa9c52e120d13c5ccbf7db841c968b6fb702239fd3cfd9bfe2401f1b53b9336d1997fb3443e36cf5fb2aca4472009538d1a1fcb013f353daa52898d999a525e1449c83bbd080447c911509355291057a0fc28ec4f49a645d26077ae9d7dff162d46ed5f14aa95bac75245593cb6fd87f7c2abfbec0aea38429ce5f18bb3cb8d9fb2d6e827250197427e4a2a07d9469690d9b03651a01fd8f4e08b0a4339dba7a07641e7a8114a6e9d0cc2c6d03f4192697c9f939608892916eec7c1ac604e8d1a178def807e2201bbc2fec866ff21198dbcb15c9362cadf9c0773a338672f2c51157d31f57276e52d4efc24806f633fc15a6f51f81728d7f26692d9caee3aac14c9acf43a415a21dea74703285b4a146e8e8e29a5ccf43fcc14ac5e78bedcc9eec17e82afdc468e84c6b1f7ca15cc203bcd984bf1ff529ec19e32dc7a0fc3153bcef4c9fe2e4b1c093e32b04b99581a871d2058ee2bbe427a713866836ba30b78f00e7cec5d2892352cf4253f70d33ad4b03187b1cbc181c3b5e80eb2677136ec097af2de814787859df90ec90922fb366ae59feb4a86668119fdda07e4b9bc3998895d73720cf4eaca4ae332ec604b29fcdaaa17b57238d28e494e3b5a20f87ec1a279d2cea3ea01031ff804ee4e66ae833f1fc479556475702f308ecc2727bbcb55e37c7ce049a4d26f1c7756d04b48fb6b012dfb72aad85ae1c15de6e946be617728ae33e38502eec2dc0aee2c9113d4bc4a477a82419cd19c8602f73917271163bcfe391e55ac22c1dd6a0ab3577f1ad4239386faa9a983ade8553038209fd2054a6418b4c2cd3c5d3490ba93f8fe3fd08817f55b8440099d41ecf5f0024fabfa0b8d5444768a73bd52c658fe2df6ca7188ccd23ef942ef32122a519919924f035b895d668dc7c48043900dccfce86e74d8a91327874030edab27bb3b95cc9a3cf809c0690ac9e93554fc3ac3ffca5a5f400995d6b571d87b1e6a5c7e98ca6875d95a4d3f87d2ded93210e7f190923024f1c9d0dbbb4debaef4953f10bd5659c5f18ce0ea714acd309254470d38991c56505e7540f5b623f1055670163d9106945651cd5746171547f1df8cb60a0b5333b36be2b11951d37a15bb68e922c49b429be3079fb630f0032fb7fd05196267d9207e6a7ad5899b6811afc5f5267df344906eba06a392b0f47752267430bbe90cccc2a1c6698daea118811179ae0e123848ccd82d9cbbe223232a8e19f100959a244b1fd303c2e63bfdaa74145b685a06617f0b8b0e5bf31855e89763d08de5b5bce99ce022432b44b6d0de4182c60f84a8e10900a8e181f6cd0d492c208adc134636def1c44b769f15b60ba5502b660c74491b5c3e4f936e17ca4c7b4e055770da3143b35617d0517c510d418660467795f958b03f9cafbb031b29d2e59b58b98a2cb7c42a9229be8527da7edd6a3d5c0902b5f561981cac4746ddd66b4d8cc511f1fef7507565988b1a72b669a0dd3ecc77719e596137b50c686c309108fb8e6a115903de84d89813afc4a7ea9a8762932fe75de3db4284ea20068a3064081883e83cb3bac6f3c5c3ba025554dadc6bc90727cdac186d293164bbe0b9d7a91d5162aa648036a41f231bbb092d2ab34ca3081fa4bed436b721d24d9d5fd2d3c92c2519c4fd7d2d50df58bda60de644724f3cd4b4f2731cbfdc8b4140f81915e7b0ab892fc04d30627c8c0afa2f0d96fced8ff195b8cf41d6fec0c6e60ac88b35aaf8c0238a7c60449eb3321a5917e8887634ec22ed2f46bf7373d8361d11c510c7616b0a89ff57599d462ae77907a0da2e22b8579c2c422aa1d8dc51d26d76a0d1c3be6e009123262d3d0776d9b5e4d88f76ac66db3293f04e7b711d4d1168b5e67d3e87081a4e6f1d1eed02ae6c80054d4319814951cc46953c7dff2d90e29f43f7183dba24712be27abba28b5352712b59e93e67e43f8553319c652433f34b85a8dee6b119448d9ffbe92f9f7af29258d18a2fd1516b40b998e4999019ff86acf232ef0c9e48f74dd2e13dfa6d7cdea0c302eea47e5c35c1b3e32f6b2b63e18678107c72a02a432414819628c40b4c73e3f9f7d2efb4f8168d8bbc5b7ebdfe76bbe01b78189703faad348c3a6560b5e7dbf2f90636cdaeb2e4ad065a60704b237c60546c6b96b1eded9935ba282ba4a7e59d6a27d87bd3f08708fa93934b1282b4ce08792b4814c398bf5bccfd75c4ee6fb3af48c92c203b70e047ac21865557f1c103cbd1c235578cc4c8daa6c29eabf37c186a673f41541cdc0d5ce46d29af34466722b468b8336db239822d3612bf39dad62943e0c7ce54ab2c06ec77cb365c623f875db2011f26ad06aea248347afabb3195c68a47ef6feb8403517a91ce4ed4a465ab695bb970b5ca212b4c440959b180f85d28e75acdae46cdf6ddc9688656b8f0a020591d75df111ec9a6f8d2dd567b18b17cea994f69573832f84bd1107d10b03714561cdbecd93dc3410d6ce0b9e47c4d6327a1cd3991fb966868af12dc30a1df1bbfe9c96cb4becbaef77762b8950d65825dc55c1dadb27eda26e6f2ec4f2002bbc5ebe7fd8d327b60cc89c6ea29c5dd249543280dcd9dfeef4f0a643b260cbb1a342ad8c3596847bc4244d69c481d8f313eb9d1342dc7ce60fa87cd07dfddf0d9ae8b6aaf31a485c4b1c5918a1246b0910c69639be3baa603243214892d9cab9786684cf9b1e531115ec5498349b589590e75e0c357a7f14cf7ef035832e2e44cac23d1024b1b2a81df757ffd7a414ead7114291e6b1dabeae6db4d8daf50fa4468682d6e1052e5851871af29de7ba88e55408aafd173fe77a44664d50677af3fa4f7b55d08b8845769ad72f2fcafd151208498aa15d63fb0c4987f844b0316c116393381bca273b19eee4757aabe7417c1cc47f8201a9e5873c12a1282ae4b239a1e4f758da09c8465d7c421ea5a7dde5d72c072d78bc1f2e952916cb3a83bac08c5f2255b1a2177f3481e2650e710666efabe3e85cd69c243af60f9c54b3a15d70f136f8a52c3001eb813563c038b639493a5aaf71eaae8609c276f5edefa1e835253364ee3a367200c7a9c4479feb93f75b0aac517a03fb3490fb2d4be04210e6d734fa054689374a9f72d9ebb1231a8655667be7490a6c5ad3e870df69e4b825bdd0891ac5cbde5b3ae688bb787cce482d8d1b8f63ac00be8ed838edab07111e19ca34ec0636797d1b5eb8b7a50bb0e0154993523c328c3da9c358d2d4d28019be57165413b6601ac7096def38823fc16f0ace503aa2d567df11864e6c76834075481bc1583c138bb55be02501611dea25a71755e15368ec6456c0b1c0612c9d0a9230358cb17e8994f70bd93c4ec1f8e8e8178b0a9714388fbaf46b9870de16761e70f0ec396c199b3772e6070b64a1b0b8ac587965c78896cdd2b76e8b2bebd5f5f3e65ae1821832d2a93268d9d9c2b9eb8b2879a7414d26e4a4f5e480aee1cae995e65ab896f45ce5b08fb9d1decbb59b4e9df5549cec0011a5db53dc3997dcffe6c6e225f5bfe1659c5156e9e1f8cf5525b44a6e4f10499cdd52a82dfc05e43081afa19c81d2059262f8e88b1b61e0d73834e2fb142f8290fca71514b737467e8d6b85f1ceb3ad4e4ccb9094c4cfd4d5b5690b2811bd3b9a32be1a43580591ad7de839c87890b59af5dc19778a7166a9e8acaa69a3fe91f7f0e10bd1df12a57f4a4779b8c731afe5837875c2a689e84e9c70ce93072dccefe6323a42e369c5c6d5a479f6f5e9c27f14441e6fedc3a58a07be398fb6c29ada24ee65f0921fc6f3052d14d5552c66228d2be91c20ad9b473358aedcc5af91ce07b720a7542479db8c560a6d54b3e8d43d5567201f0cf2500544dbc994c4a9a81d44b2a2ffdc755c4e140f9d5a649eeca51587b89e5c164818127707abe52a0d8d1327f9eae69591dba98073a5e6f9da39daffb4d06b4c6a60b590c26026dba19e77930a5a1371c9655cc88bcb9e5a6a6ceab0a69f1024729bf40a1759f8197ddeb21b607c94f215cb179f97591a19f86edb86a6c3d0eeac2fa928c4bff0160d70e20ddf884a821046a9798899e26895b305d79180b5b78052f73607eee79eaccd7eb0f2cf22fc7f7b9adfb3d9dcbc2d13b3ff6ec3475fa602c3f78693499c3537ed12aee037bbae4bb82dd537c5625f59223ba79cca53db0d255413bbf0f0b3589f0a0d9b288d83e5a068189469f113d5ecca9063ecbdde6dab419e891a8cfd92b2dc1de8f38016580b7520b80610de634c5f02d6389d0ca36b9629a9d1ef31f105e3e365a74f645a938500be0892a2f71acf44f26707fc3b49f1c00f285c647df6efebd8312aa6ad4a2e72a68e3c23f04adb918ac9184f1a998da9e6b0f03ef86da2158e7f17a05e80ab91dda0cacb8df468bbd5ebba6b33683da056d19fe9e083a2bdf9be606d4109a0526ae06e5fcc1076c04dff528bfc329012db4f1d3e899dc249d4340d8cb6c83033444847ae5111d62425404c7d83a06b7f5c89ffdcb6ce8471fcfdd93ef8defe3e06cd33edd3f35a1b9e888e43fb81b60fa99c7ff7b005cf2c7d8db4bc00460437193f5b103aa5a9e4c4ce951aa0ee6ba8e03978a334ca7a9d0d04b7d24c322a50fed71c15ecff302ab5f11fd1627bb7d9fda96b7b2bb9cad0669819615fa48fa260b41d74dd9c27999adc49fac3672637a9c812111d49ed61fafd3b94af321d104f5e6e128cd9373eb6874f5c7a07d4d51f5509cd6d72e9e7aa1100c44f0dcb818db97df38e5401d3edcfb0dc872a382e127641ccc2e3abdecb8cd9c5e2fb80cfc4168f00829fa1fc7f36c2f1fb7c9264987aeca94ac19eb891a3cad857ce17bdff4acff1a7a2a76064fcacbfce0bc458a0000e8234c62fd6951cdcb2058991a3946c15d2104dd5d448805c9cbe0f2f67c30c1e6f8cb193070cf9ec9468801bf8230fc07a3291c3ce5ced5594ea340af12d06517fddd29333313654698fb8b1ca1176e65ecfba3c77b38d6bfd59930bdda2e42392e1d38167983f250fb115a4947b9f1240c00c3588a14d7dabdccc36ee57e6e2de12859c93362a080e985e5c310b970b50f6be70d962b1fe2262b7859335b29cc01d1451ceb2080abbad9afdb77cb1ba9af7688e670b9359399101e62a4b0db8674752f603661dcb5574cb1150a363105a04c4334180517d97d5dcaf524a7ed7729095f14ce26e839e872d3ed111e6717b07ed16af919c75f39f6bc4f8bd5fa290f9a1e97656587171c8ba74735547a18798a4cce1425927f9b88183c9bd1f16eb0ec4a684756fd7616e9ca684e4d38a84d31b136b46c96ff3eb20075eca4b82e05ee5d9a83dcdb3a5061eeb3ab338994e5bbfffc77e1d9174abdd5666e08b16b04f1ceba9ee1cbc4d8304550737e5cb6fc2d7b1df4a6b6f4b02d92f9713516a949db7d53351b6e39033b0a49bb7002164732ea57095305ce2ead6f2be2c528d95847df48d209d478c6a405871416a69dbf10f77e5a87241b7b8e30235a6dbf1f22d6308d9aaa98424a3019f797c23b9099f5303e87977ccfa92f20bd35c157366a49b517f46dd87d04ab622313c91746982d847143926bedb1aee01392c8399461a79031a964563155c18fb46f3b76a71db418371616691a9ee60167ffab149f73e9c2af7296e881f2a3cf223205931a08e29d749abd489ec6641edb751e9214b97b21d57aa25af1940f286cb08fb26cbdcce018f9ab311e35642e8b800211b5b816dfce8e041e66a7bb8a201e9f7ebd4282783a90d38dd4a19ea206506ae1d0bc01812db0f94f9a119550fd7aac0510faf8cb3dd821d00cd124f76af89355f9d66293d76f28c8404cdad4205e268b064acae9cc2db9e8eb0010c2495103eda8c2aa02bc821a1a72acf2bbe9d3dbd6e66dbf40558baab7a9a44bae0d86ed4ed94d3703eb5c11cffec43bb1b0a389505d76867ffbc029c9321898ba7aa1c6c2f5d4a63553ee59771220c12c5d2d29af9000c74cc1af490ff6b1e5ebfb3371d851fd5baa3222d988c2cde61f4ccae56212a3c7ed21698ca3670ccbbb993f139b10a48a51c83ec4572c609b6243459506bf6962647bac3a12f5a5351b8f6fc96e5667ab487ebdfa13af32c21315c30f92a531c9e798da9164ed69041185c0d7a0748f29be1a205bc4263c33e0f9c483b23e62b22efa31839d30f9c4957502cf89655c19dec41c87c94b85326bb373a046c0ed7bc1722f7b6d0671339c2762a3f9957fb42bf23d00bb4af5ea49c543c8398941c3bd851552b836dd0ba1a0d627399165f55f5086034d02868e8c40493d1af6474df65829c0c08715356860f9de6614e86e36513ff2afc993ad0a42b210ee904ddf3c85310c1c9ea966a2c94e45652a07a73fab44d8a7197c3ba9fa0ec70e35e99e5606b0b17b555565211e09812a86ff09740193c4399b63beec1e185ae16051fd8504e6ffd469840d7eee08f5860ea787c143ee8cf991033f37d054c8bcfa84f585fc6873fc472f67070efbc7e7288c380f25990e0b1eb241e0b177a695fb8ea506f69f527025c152828aed0ba93cca914e8fc62c250988eb7668b6373f018ef11fc63b4fa0a116876b20c5e25d7f52fe7255bc6337a9ecb2a1df2da400001b13a3f5c1731d15ab4e176dadac4f98426db9e599e4a79cbfbda52cdb3202d456df1a0529a277a5418b497c9911a17e165d4ebaec550187dafd4f75f13edeaa02d1ee736be434c887aca580572676347ca2e2560c0220ad0b4731ffec5f45d8cd957770e5977c1f457474e87f5ab5e65f94d0204e717c319419660d9e4cc549ede15fa56b569e35d73d64f915e2600f992bb9202de26ffc09ec5633cc64bfc9fe05e8d76b3953bf56b90c72b45c85500c9de189ceeda3ba498942b8d00fc421a6bda0a94cf9cfa399ffeef9270a6945013ca82dcbf02eab4cc3c7f9ca26f614a6f5df687aa1c068526795b20cc373e39a893ed58487f768ccbef5b4fc34c56bd9683fe5f9140df924abf5b4510407356977ceaee73b1c48b2d379c383e2a753a90b279ee9a6ebf75da8ecfe1a89bb69b22fd4b340026ad45589939535d5626422ac436e0a1e7a01416704c2d60d69b3aa6bd6d5f3f92bcd90bf92611b1e097041153c70651f46a3c6a8920fcf37a79aa71613ea0939a94ffafe2a9ec729df83dc631364d3532834715e1316aaaa422494c2d97423abaa90d1536caecf919e64aeeb9e098952eb5da0ac4913946d1f281b0ed595967d82b70c0bd1f3dc56d10509e6db4863af80d4713face32fc7b00be15fa07fd3e9d1890463588586a684c7f09f4937adeb1cbc8a5c34945a8c18ef03a88bf5f1dbb986f2efd37221defdc104189db60024bcdd530d085af2b9360902027160bf0ef498981398dbf20dc419d2fe80359dda60131d1292108de53d2003f8360a07d9050afeb33d4bf309a6b72b332de9b3c609521fc1e50b060757f79bd0f089f385d862f26a5051b5b96e3b71d30ae44a16b19f060c0d9749b295bfd0a446726b81960e12cb9519207d8131ac1b833b28f8889d5009637388bea75fb0d917e4fee61173d9634d69070043d9124b495cad7c38a461d852fba27d6125c6a6930715e747c1bd34161b924be9eae0e361e5f9cf987d70e4b6343039cacf579b02f71c4fc8b2ac8deebb11c3236f0500a4055c1a32bbc885fd158f70b0b45f0541039693551ba2966f92f3eecdff858a855d02d834cec42674dca8ce9623d010d824494f6b3e3db5774b593a87e351dcfadb2bbcc2a2614c97a93a56489ac9457f3335e899d3a197d7d0879591e5da65cee71dd7db245ca19c6ea5e4c2ad3e02cb9f0ed57426c3285712b7c0d14c73fdc430737c540ed592bf2f6b68c1e7a941a6c4615334347a6665e16c819fc984e82eda84cea60b00a9543d02aaf3e3ce7e11487a223a501279a394356f1030ad6d89cf460c101c8c1ac849e7d25fe8c3936aa0189aeff5cbf6ac198a3b61eaabfed029120490fb177e71003207bd5c43989a46defb0e2ce4d97bd3989eebd49e9b752aa6ca434f512c8ef13db9051ef4754adb9d385073ac16a9d49fe20cff94617316b0183476ec5861a1ab5ed332c8d997c46ce7134cdacb4389d2d57e76d1229228677e55755067bb75c28a9dfcb16787b6f2974e5f26af3fcf12ed48f343998533637bc5a3f7793bf4f07e8d4fe2223dedf5aa7e5386bb06a486261a34a78ffa586cac073ea8268813c9a4758da101ea1de15edf6af69b0750c9c5d474ba974f29e665da06d2a0a701df3ab77fa11da4cc351f934e2119b7b4e7e6deb52ca218652ea3e869a22552ca164ffacf90b94524b0296724a1466e4a8ba6810fe5e1e171bff06e6d834b7a083502e254010e151409f847d1fa39f65dff0ea5e670fbdcd171fd6a93c4001384659a9450134ab7eb3ce615b4465417b9f10deae25a7bb4d8728e78485ff851abd58e333c48bf897313529553653bf78ab6b59edfc0a63009b60bc67be0c98d42c12c4e43b7748a21c828b81b34740a259c604ed1eec476f1f0df9e5789ddafe03ce227981186b95dcd67b7c26a79cab2e5b7c194f19a72de93cf3b37abca393810d980235b547d4608a729ba279105e488415629716e4d9ef80252edf187cf0c4f31f3ac7ff929490be5bf110c209e07b105fb232e88a319982b13ca9c60edd3b94f4e50b6f89933b3c63581aa148d14abfe4a9b1e4955c970493186d96036d1c403c237a1dfd0ad3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
