<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"056e608816cd33bbc5993b7f9f079adf7cdb8299564f2b1c990b92f7f0e2089c80f36057d119c5a17ac7391c8970548a4bf9d127be729f9415c99c3cae9de66f4d56bd5b44ef690b55863b114011dec590cd68ce72ff25b6034a163aa634532db29d8f57003981ff88cf7f53a65fac0068b10c95d6da6e2c8e578685ca647a8ff6135abda3a1b1550fc5080f0ed6c21fed80511f8a76c631dae8c8ebbb2d5b93235e8df1ad6db12fdd2e2d8738761237e747e19e932b8ba8bf21bba4a1f0535b695f1227ebaa4ea3213d53657ed5cbafc46aca3f38312867301d9a956545be0d91c46810697c41ad56c87d048ff9286b0aa7ca7f9cde1aa7a593c4518880bf0920b148b84c8b5ea1917cdd20748b076b464efc7cc9adc3e7443db345d40a5c551be117dc8629e0e9c53611c935e0a103b33ea6dd3d0bee7febaa691842bc13bb49c7c01cfc0d1a0e46b285c433379f2338a0be3a533771a4583930beb10f27fdadaa0781a93426d2fbe69b6cfb0ec024f60694648bd87d939c490bc034278ec7a23d07542e9d32a358c6dcd19c08aeb230c43b1d589e5dcf2bc95b5106eeff6bda322f217a2e017e699b1e03f0e47981a4a28878dc9061e0cb4e0e1c4687ddfb607cf5869156714821a72f234f9c96ffe6e3523e7b4164f140136fe365bcc781b008bc5617bd8ef86878a3f4ac6d8e143f9f43ecbad4593e96f0835324d0d75dbf35560c9d0d6424502e13ce226127574e8c803e44fd653a826efcc39bc1d3a94b3e94c0d50aa627955246a3d97bd4b1a2a96ea4ae19242d6783a1eb7af22e16f7372d8c9d3ba2ae42af78bcbc222870876a917e28293d216b4d07d582ca601c89898834227feb7055d175bfb4368b73caa60ee28ca30ec5450e833a575344cbb676969b19b4323136f8db669d0775f9fe66c913195b8bb73ce28ed762e49881c1f355b3e6c2338d9d2722b7a327780f24832aca034c6e13d4a3e481886512a7465a3ea3e7560e76e4b6f39b941ef7764e9ae9efd4da0e05cd04c2a2d0b6763a0f9ced044849de15f90639828af3f28095b915592d2b654d121973361bd4e11c55b244bb4ba58d018d7085253443585d73d500416e7f7f6faf30e4e2030fa2c7e939073a662bae3c0d493032d85ae1d75988b49f69b52370614562820234f71d651592ac715deb7b05c25f3e82c83f6e9183ac84f63975a097cd8822b705c4b1021d97d439f32533ceb671991a6c6de3e065c3414fb0016041ffc4b9787622cdf8230164c84c175ec36806d6b4075cd873c9dac05b58f75560711e37ea922ef01a9c977c3db37c99b957cb0ad3be34f0fbd4973ce0d943f3fbe3d474fd54bad4fa946eb10f1e6a60b66bd702477e7a846e3e736de28b0361db33869a3035dfcb1645159c07f1d65870d1c2804085c90064c91abf7d95ed8b34f877350682d5267370a2f4628966fc955c11fc0449105c21390fd5c01079e43483114518cf5c6d2918ce301d0dbaa6b4d02e603680a52fe8f05cb46c516a1704e4df9bd3def53486c2300d36e0e50cac1b599568cc770b3d9179bf3e4dfd0da24968fbcdd23fac73bc813437d87666e0f560257314fa4ac317846f878e9ce853fc6c13b34714ecd3d1ca557748f6eace500ab1db5e7c0bcd0a6d56fe4518f4fa76a7a1d924c73f19b80dfa492c5cfd95d4cc208f7102a4427f26b8e765f8e598f58664f65c34830cc78ad189112cec037c05800cb0bf17e983fd3483029184ea557be4405ca2804f342e9309e14e9d1cb00ce4f06613e1e55adc2831650c044dcc6f42cebb2e311310933a96d80bd1fb3444ca66177ba4778394bfbb7fd32e5ff102f69f5fcb6ad0351b9e50de537b5cc956857c07b2c20d0060041ab4c4fefbca11912cbb22651c1d344f471ca1c54628fa3601d3faa05965e2d36a018cf1c99413f04ab65e727d7ca5f99a7d66aac209b9afc9109d25011edb1439a3e291f590d81ed9535594a9537005355bec435e7b9f75b34ed25b955ff6bb93ad047811ef479b932f1d235bf52417e58596040ced8faee7144dbb183025801755baf12dd540044778ff339f68831aff882336efd1c9acdd83f5c49c048aafd3f62df0b2bec30db0d27e55921759c464d64ce1919a4500a58b64f41ca8c526b4845fda479abf2f5610d19bbdf03f25ceee11cdc9fafaeb21ef16c3b99f4e4d2a2a8799dede43edd71be60ef427d668932a8272c4b8d6fc83d33d03d0668dce3ab3a10b69c2a66603a1fccf32bc1b6f6efb93ec836a64cda73911586f3ad3cb24fc75d4f8c9faba20d2585df15e17ac2098343cb1b2e8692eeca579ebe9f529e71dfd58decfabad417acb644c3ee69f2775113ec5743bb741341193cfd3e3c6605e4f4ce35881d1571bd9f8078e08eb226bd18a85b0d9f9e04585946d16651e07daa36e605a0078edde552f480696e2a59204d877d24c15a62aad83c2aa329e16743cac67c8c8815bdf538a293808ad2c33ff3767c8843b0fa73f8a5f33999c7c14a012b4268ab13e3f0ace6370920e24a450ce7cb6b7348b5420903047aaae1d4d5d0fcee7b37edc30ba69f773c27bbaaacb66a8f6564649c0d2abc0e311b59c0a0b2445972145e2f9f81ba1f46f4e9f9588b1e8f4fe3a490abc2b7f62bd974913f5d38cea648ac29ae48e9805b0b33dc0f94a63310a6dbdfb47df337480392f3adcbafba39c752463a8fb7bf42a1f30fca918cf0590dcb5029c1c15c87edece5385e6b8f4d46025ae96ece3ef38609888f5ad8eabe7d3d21f94be70b376054a390289fcdb94a14fb23a9895265230ba883132a4fbfcf29fe0026dcf2d054aae93371bdf094947b69ce34626d6438f7977e303fd764b86a5fb78ecff66aafb4e7c5eec0f5aaed20c168961b0a24821b2493fe55b4def4c9e5a826b635578f67ce18824be1d6d138d7c18ed0a4ec0492d9f356556754f5ca6fa182da7b6d70758c2efd0b26f98fc6bbe0c0d3d2b98825ec2494d8681e391e47bc7f33728a9f47d7c7aa8527f9523ff2ddceb2c8a0c85d362a8f6942f01c1699264e55da46743ad2d617e33d04f68b2f9a3b623c10732893f2cd0137f4cd1257d0a848c2357490ed0ca732ad9efdfb985e80e31984ec550e3ecaa1a44f5fe7fdeebe94ac5b6f58f07a4853e5e21e5619700354322887f83d19f6bcacff48ee912618bbade59093a1e1e282d8e5c402bd894c5ac77cfa3ca7be884a27e786d269b4e8608aed0357ec1d9e126e83f373c761aaa84a14d2f40855ecada1a70b0ed63dc66bebf85304ee3e408746e91322c910de9b288ed9b6a338492636cd5c0de3dbe58dc410b40d0a746033673d0796e97426f6f7356be030c2713cb3703f6def6a42afe99cef44792fe4699a86418bfe85882402c114d35d5fe2437f43a5578df4e0b08b286cb6b71421ee8790abc0c81f916cc828a7b3dde425acfcdfc5ac6855312828979ee4e87532456bc7e89f92374a3aaaf6ee86be95738da8c9bf255c15fc48c543b5e1d18e93ca7df1c268b2d28e569d58d11d0260664a16fa0f3d83edbd227902fb54ab05e6466db513e43d95e46ef9dc2ab35b0d616604274383d1d0a92adc009157ea102c795c313a3af7bb7bf76dae8b8c84b4b7a5c1036724ae59084fe431983a431a82271e66fb12d09dc4ad978a596e30221ecd7b383554f30e6495fee089fc56cf320e7d8eb35531e852dc0b2a0e6a7c617fa3ed07cf988ad6ccadc5a379cc5d84e9bc2958181fbc0eeaa5d231284c2ae3f1f9fa7c7a906dd4ab5749f1a712aa91c048045eebc0cd02dacd04d0585893f85a0cbb1556d3fb09218835e9142ceefa3185a8bc6b089ac188c768bc8f88a1dd3593762e96fe6ca462fa041d919cc7bfa20b5639bda7a236fd2034fc0a48e50295b5d251935c93162b98aad4155837611b2a2eec2758cc85d7dcdff6e48b16359a723101f419c8e4fef44523e715c7e0665f03ab5680a39b5bfb0140a49d476acb0a6d03e24602118789959935b110de0268cc409615c35652dee70b86201a7c5d0e67c68d4a2800b745d4310c27d5a1e5d39dd423b57026a6fb199fcb63a8c6b21d6e246867f6aa5d46caa8d09c4701c449e0437fcdcb3240be57ebb5d23b3f79493a61859ad064c17eeb12181c7671dc22af8e87b8a33861bf6fd89787770d86c404bbcfc9a6844df751e0869ada7e4c1d926069b5dd96cd6a44576542562c41dcf1cc447abe9bc15096802f81ffd449ae5603865a67d3aa519352d7497a468fa8ae7c3f0d31d4cf356a7d3bcaa96f4de0fc1e238e97639cec378ac3ec8a8d8b5a35c02943d7feba05ce801a7ced6ea9ba31fbc46d30f550a28ef222923d9d94d9b54f615d4e0d15d60df6e17f5e26e04053fc7deaed45935928871283c779132528723c8693f63469908e4b29d30e16b74f4284913fc13be06aca25f5c2a5e7832122e2d100b2da126096f825cfb40416dec325f45e5e004347bfd338eb796692dd60e2801cc695dcd92c4392b7d2932703ec75ffdc699c997f5b79502c1f8f2d1bb9a6d1b435080850b3771d827d9f854fb33c541e9af270e2bc787e0d4c51639113b2f342d85d4b40e33704488d42a1627269764cc68e4c30d54f6c64aab91270089f0258d7c1f9ee13e5cfb0287f4320d7877942e072a6ab392441bd59ccd9f131a08a8534fbe634e039b1011568628846ea47c21d14908468ad3d475ce5568528fd197e0ac4410f75bc9386fc410cb60fc385e5b8a5e36c2657bb7a90b18aee3454ee6d5b56a5e240252f4e7ff41420753d574e181b486d6c3224bc45a73603cdddc16faefed1fe8826372a99df38902a68c3fd682b02f6e76605293340910455a1aa6913722602609dcd67c928dc4c5b1cbe00a20b2ce15352a130e5a524a93a2f33c9a7902362a4f5476d06e9a796282ce58a63cbb52aec804c503a9e64cb3d1433a545e5d717e56dc20b0db2d8abe6e4fea7050e6ebee7cbec1028ad3783530aed9a27f37042a0e4b6a7e7c726d099db3fac2db5a470614e188eed1e03279b467e2b7376ed44a966220913dc4ab7092e57e979a49aa584cbc6961bf25d150a803fceccdac61ce2e613037ccbcea91f742fc83929020df9650ee22b90d25b47a415781ff4c5924ff123d0bbe327cf2c3e4d9f94e8f56cda5f2f567d476b0d823a17c2cb59fab686a38ed5f763afd76d493b196a5d6989c07251bbab78d7229696911615c1fa809ee7e5d5ae695b8ca7bacd7a700903db8caa59b38e1ea64063a740526a87f88c8912b45a21abbed6d0d2109435907743bb740ea2f50030669cb6c8bb0bd0b324e6e683963c993fc72f115e19f833ca296fa3d14fad79c2a062e87c18cf6f50830d7a82c47e8e23bcca3a0139280932e0246f68c3a06459220e7a75227f96638e49ad5b5040892148ec8d1ed3004248c08db52a6607e960fc83ebca15f329c42584c5071a521a810a365f390d591a5092673bfc5db805f2674d5cee1817738432ba57bec2743dbb9432bbfe08042801aba8b13dfcfa1eac50bd407149ef5b00952eedf64237a3b638adf505819f57aed9f934ccee7bfd6e1734f9941534ea5c6f2fbcf125b7bd049ec3c544982567a042d73492b8f4661253a34b2b695da6b0a40103edd17060ec6928a861fe8d7e6681e442f6e46a278dafb79013469edad4009f0dc8e14d3a4d3aa3d389d911ba13c67ad828ac8b0870ea856e4387e68caf6c55b68163190864cc4feeb99bae74780b16760aee5322654add3b05ffc86c38dd6099c640a09ab068504c4ed5450fa6f934e3f7bda8a644fc16de6447e4beec02eec413abbbcfc145ff734f17adc537688670eb73168e201425892230cbf6ac6836639225e5ec10a2e01122bb93f6629fc2e01280d8130d8b0ed4fb42acf4c2ada1408026a1e6d3c3fa5cdddb4fdbd0b233063e386f4033b69604f1fdef8ad624c6fb771999469b9209d3ae1f6ece2460c02279877fb78c2f3506c8d0f64add80eae50e29f36911dfc7876b8a3d65617e0053838339ff851cc903639ac566f6ef01f1ff516e13f3db7753ec0e8c3b6c70c964f44332fefee5b05fdd947a22dfbe9f2a5ecd2c984019f15260b356c3dcdde5a49ba71d07be38488135d398bfc51aa84c96555b5a1260047a27e09235c2e9b27405eeb5e1bcc51bb739d1e16e53c01eab6dda40bbb1a3f50c3aa3585e9f8a6b378121456a61d679efa93b5d635a5bbc6266e82e86b575bcf4a0debee216bebb086ac40132d48e8ac75be776394a47514b73bc92f59341dbebad23c868282b9c7a6e700e3e0876a8fd92ae646fa2fb98084d88b885d178dc99e4281fd02692b1bc8ee6c1cfa8886244479edfc997cc3bc14a58d74adbfee4c8dd64707fc6c87ba1f9b262012b60666f9a712e43089e2a67f8bc52a4fc000d1c8f62cbd9e862fabb36bac0ad4ba75cae3c4a5bb32d3402ab6962f6d89dd68f8093f4fcf0f67eef139e42e712d971db6ee0c04a6ba6f1fc96aee77e07c3e2ed371dbc924ea2bb62137b7ff07a157bd8d8ebbdd5382788f26c41a9ef265877d35fac366a3dd2f357a9754bdf532c10ac917a382d382f6611b923118cbea4afd6f9f66f4ff30dc7a66cc342dfb22cd5ded06403a24b62b21a0975fe48210f9f8427817e342e0a8700cd58acbc73693bd7ec6f4df7b62a06ff2c5fc5f0a95fb6da02fb57f03a46677e92b0048a833feaa589a050be9c3674f604a2ebcba38cb06448ffcbba2ffb6b17f75e83c411de8727b9ebe60797a92c12ce37fd48e35dde74b3e447bc2c9b35d8ba9725d2ab58ed3d9d79721db305a66c975170c06430e16200f4f668fea001558d23aaddf44a77b37cf8bbf5cd4f45c924b9506cb584a1491ff5ec161f26a97788bc1905b3f6b73d0ab759aa4027c7304ee064fa640029447f4e24936877bcb4eeae56b84b9af864daa447a40a21117375dbaaeb841551b395e5d54c1182ae1e57fa1f73022ca3c868ef7fea8c8fba695109f507bb287df35f39784e443bbd98e974c4c66c5f4da7599fe3172336f64b582c599f2b6056b0565f29a1ee6933f47c40fd233366ff8f796c255652f636469adb1d8b793f6a645cae38068ce8f38f8b2627400d5101dadf78959dfdae414c72890d69949c0956465cf8c61bdc65b251d759982b23b850850576398c2b1489eb67e6010e89d92ba30a85eea9e56677b4f11b144d34b79ca3e3f6f506dc6c72176808d35b2c839381cb937b2c42577297b7c14cad1e4d0ab72063ac686d97be82df76d4d46e6472f43af954feae90952de0ecf072eb06ae5c853410e27004175dbf0c50c50f5148b2f672a8ed397c9b69ceddc51e9b81369523c76003c8440c96c7c59c2bad681836b4a704f8890022a892e913723fa74fb093ad4245fed80e8ea6275979e0f8cea75bdb6ef7d11ef54ea75c1ca1213f0efcb392c2a2460c4d2e5f5cf5f79803b7c6df293f87b1a5664812d02ecddf2db19388f5eca626a4af9109a898fbb026ebf1a205c6fe3cbbf71dbb4efb2aaa0b6cdf029c9d18a6110c6b5e07a637b9090222a01ded94031423857fc90845bbece9b5ee3be4db652c6b068bc3cba138a2592b620e48773e5bcbba71db2d7ac80f5d9cd27dfcfbbe5fcb71ec2af2288c272f3cd793086d2a02b9d220dae1cd1ef1ec1ca62c9cfbd9e32d51d32fccb4f8c1e48cd2cc1bffeb70ee4a7c5603bc95ff150d7257d509d29316ac9a7aa65812ab4fdd6904fc718ea87988de8ef88178b48a6cd785c385e044086eb6da2b0e3d6714e97c8d49f6ab425c2b0608e39320adab61ed6c9bc73a066d42c0b6362bd207dc333c6d5b142eb96763cdf94bf0d6ef5075fc6d2ff8b7143b5b13af71cb9fa046bff93aac1f82dbe5c650ac875d243a839ec15260bc0c5f8c45f48ab0ef92aba5149e4d7ef04456c3df745eaa66e4920fc152dfd10b1ddd5fe9d6ebfc6f78a12ef5cd0f6993c1ea131f756472027ef423fbb10ecaecbbfb80346fe21dab1613b825db95fc7a0e5a9bd34fcb2d2abedd093f7c5affb64dc5a111b87abf85b3d6a0ce3ecefc54f467dc52444339e5bbe947277571c5e6b760eb829b029cccf78a44d0e76690f481980a003197ec46041bbb5d13db1caf2e251b2fec6fa2da58724f307e25d2cd1548fffa4440562382d61d1a3161cffe843609da4c706c5c97771168c826cca39c332fbc378a3f9d4ee4012afca3278b7a5aa149e9362c49ff5de2d0a63bf3a75cf577c8eabc0b5453fc6221a75c32186652dfdab063964de56b8bf0c9c414046fbe38577e163b9ea7976c97817a546f70c857f9149573bf5a6e62faf71d74b2bd946ef4ea2845b1980061c5febbbf7b199d1a59e17d3cd0d040836eac56ea359aa81b8fd02deb58fcafd2a520e107fe2124d652d3a91ed70596542edfa6b7df30d0a9557e9a648309b8dabe59d15f5aa38e981251063d378422a1cd130dc565f7d2e6c4cdaceeb0f96a1e9749fca233fa6fffebf29058fc5b8f55ef84d73dd143ad89388a5b624540ab78ce4cc3038e710d1fb0726505c0306b3b1e5ed8243c997d0ae7981b0d4784ea2f416c3b1dd6ba626b801b287596283c95d68e0f954c6fca1e9076b91fc6596b5aee0c9b121c81e396093a152cb4db72197a207bb0dfabbb50e0adbb1eeaaf7756012a7ff7f74f1ef5556ff813d0f1d19fc9c44c9a7e8ba14dfeaa116b2e65fdff7ded7a9049293fd011908d6eeb5d07bb49b85b270e188ffc0afd69f5eaa04cccc121d0a40d1a48fc216c966081bc8a34611b8557a1eeb76f33936a9292f06ba404028fc60de74a594b7c109449f2258d3216c61a955705765d81bfbd7caa50d9aed0df58263502e7973414364864f1ccababe8f168fa30507dd5aa2f571983ceb6718c3a361cfb8bc000900e1cdd84ae877ad937bc957a4972aa2ee137d00e766e41895e00ecf2ba3da893014ee26258fd4dae7de94f44d3fbdd42da90406dd304935b68110f6505cb2cd4c4c554e2316f32243cda832b6cb90fc10a26551b5d726eb69c84739a8c1dab550784fed8d76669362c4655ee63754fda516d8dd1864132435882d029d717a5b158105fe64f149e47a4a38acf0fd3ad0d34085923f349d2503e6238355f2d878b17fdf25eff53c4ea326c8db3a1e8d5d6ba2c1011f1b5e00ed96981fbfcee37934736acf4359fb526fb82ea8a6a33981d083ba1034587c855b9625f8f8357973a59f5375743a41095cec735f23ab7fa32144148e9df8aff77aeb6d89c1e470a3c802d3149d2022aa67929868e84f5d0fecf4c0d2c1e2216c3cfcb13dcc9519e688650cfbd3823f5d6eab772b8d32547553eab06dcb51e149c04405d40e308a90488bc3ec0f76e4672350463a5aad2bb2e891651a12a415bcb8d540ec6eebd041d31b6f4db447dfee5b934801368437bad2fcf4c7e52bf6fc6b7c203f8fbcf46e014b3f9b5c9c60132ff6fd74a2b8128e2656eddd9979fafb9c26ce6714cef6bc4c83de813527c1e046f3006d425cfc6a5262627c4e6e03bc8cc4f8233d27ca72339bcdb8f9d4fe59c3bde9da428c7b5b7a01cee75f70c6f3bbbac99ff449bd047acd74c556f3bebf0a41882da0eb41fc1c06c34a4a5b99478ad203309172dd9fc9b670f3cb4369a4f5de1b008e33e0762bbe88ecf0701f88a364c79209bc0a6b6c93fa93314f0a4f3f6fedd19a913ff5a8662fbe4ce1c780d2c1a9c81ed3167aba545518d4e1b436bf7b262423b991930a5954913cb451d13cbeb542f10d40e1900018c28f558afa68a557113612bb2f3f402c929bc620429fc353857a5a8ff9d96792cf5a617fd15526d1abe246cc317453d83b190df7a46f3de6b93eefa0a07198612752b146d086b6b6e7a837d1f11efb06c1cbe6a18fe32f167879075302ef34724a51457a1478393b1250764e439ff9be99e96d67cfe436b44b27190b6acd2e323d98bf47eeec63a5f719ae7f2e2950bf400e81ce21753f24c8a0f310618af1f1228c680392b492b9a58139bc275a1bcc4a45eb3cc5dd571a031adaa4d8970765310f66ee9dc6f5deb93d8738d834557c174137e0e00fcd5d2a002e753cb7d7ee1d4eb089a07988bcd2eab2e03d16e49a729dfbcaa23692a484b34f9cba8188cb4648ebeb7b3abdc73a39c34b8c156440b97db982468187de0560597f774573cae98e4abea4ee7475825cfd59290a25cda7cb9e9e0008ef22e8bbd5dd120968d2e152fbc515074a4c7f82aa20acc30cf4b22b3d4012d66566b13f4a345bcb99fd3b5cfdfd1d0105137a0b00519d1234d83cfae4a40d4ce4f4b866f9bec819787ea07045475bb94b3f1d9f58a3abef3add8879acbff83473e60478d272875cac2bde6acee2f1e43eb125e08cb94fcf074b90c410695918dced41dcf748d3c9a0234bdac026e1457eb1841a34b96593e30a0a059567c84b679a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
