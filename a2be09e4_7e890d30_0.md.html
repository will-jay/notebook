<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"128029c1a1584bd2f21e9abbb127135ab5c52d5df674c0925b51970fda58be2ae2b0df81958f190595c440285db67c44c76f9c2306f57e060b336d915708d6a32633dcfa7f6ddec34b443ebe63c48921553ded04e0364dde4f51103226b368aaea333bd47a976f7f8a3ee9eb45c8ddaf8029dd639742692ffd8aa93165da400383b33c05a5ba8fd3ec99cd331373785b6e7fe11affd467bcc45080376c07829f0caf3e038818793080b4467b23349688d01dd6f97fcc7d994db6b50c3885bf1253cc578d10d2273c10b1b06d425667e5661969907590845382e8f2e80de8a194641350664267fb6c8e502160e24c3567cade4ab98d8b427828636f073075678efe055c0c6166d8129027fdf388c32f352fa96f48d9aef28c708795130356dd07e81f1cc451752f00c96e09347ede2b06fec821a136e8b67e235ec2e16d37ca6d3ce9a2b4440900c799bb95265a044f38a983ad052eae5252059226992daabcb5750f8db9f1c13a96511b54281a30d95eff92cd117470f383294116bd1d9637643d737478b1d4c188f6dd9daaa24278762f3eacd2498c36c0655c4f8dd44f0bf2c64dd84e9f284b99ab4cf47c2fd44c2b93f1e905cad937e120a6cd20bd326cb1b2b21f313c062565202daa9a863f1a156cf6ad5dec74c2bbc3a1d9cbe369081d9e055526b6ae143cf47a6e002a3ce66e32de494ec8d68f7b06f04e84237992c71d36dcbb1f0a9d81996ad3775531c62655e30a57eb5942c17b1cb04ba1d628c0d29dfa7358161262c76909673b1266f913545b8fd0b244b5e3f0a8f30a08e066dac08deda8ba05572b398a294a9fa3e014bca68263f98ddf944214605c025611d730475b6e2054e69360f3c6c42214dc90f3e448b3f1cdc2bc7b1647eba50770de1954adbe3ea742c2519eea3df1037319dba19366e9e9334dc687cd3b9ca0575af74010da3d7cf1174577a373f05c0a39cf1108cd30c269524d9171a9727f5b89abfb69ee850b89cd55da69f7b10ce34651dd6248e4154288906a355fd1ad624d4045a003f5895646b7aaef10ba8fe8d59a2f6f76e712312454bce98fcddcf1826ff82d03bcafef97fc8dc48ae775976139ed69ae5f0165295ffbe47acb24d43cd294aca81cc02cfef88a9b88a67be0774a2085c6f9344bf0ad3365774b024904ac4308c0414b914ee3067e099da3760b576850cb73cab838cf2a6e497f624fe527e0b7f6a3ed25cf5a2b3080c661d01ca08e6497d9fd7ecc4c2ebfd3ba0f973e0d24d46fef98f6299399b59f8d71b68b79f5a56a3c8d8e13c45ddaf714afd92a31f4658483b022cb3a5e5f1874267fe19ff7ecb690c9bfb7bf775bd950e2f99adc65d219c0ec275da68667365c1ce9defff8974b3ca265d364a40a001fb2f775970a33055a3cae2502cf08462fdabeb45ee0fecdec2d51580e42f1ef78133fda205b40a1d832e4064d502b365bb2f10bcc6c3d06cd3c7980f34d0e474d83e8296289fc8cfa650738ea17bfafda2edd8e0456bceff24529a798e87fdffb7cad38aa4bb61d10f0d1ae323a9b9c9e8c6c874f1b69ce9abfe81c7be7d52d72595ef273535a920ff4b192f21dc1ef4ced6c291db6402a56f0a777e24e98ffb0a978e2b8ce28eca13d17f171f8378134e5103e1d40efdab409d09c49f16ef8d512bd0345fa9eae260450307fe1290deeb36b58cdde52743d16ae42be43689712df9e1a2aad9d6fb3ef72a4981b95b80c488650bc15052ea416e3a5a991a63ddeda8fe21d904ff8a0f081bb8acbaa0f89b757435496d282c94a99544d0ad3519bae326cab06875945b937ddde98a8cb3fcf3aabb1a6be8403359ed4eb217e7389c71739ded54b7de8680751f4bb704bd78642440e8dbeddfc9a103823749e34270c9ccc81bbcdc8e3a9d792231b4e06c6b80952b1160a10a771fa59b955b4eb64100c9dd5ee41c4c9f9ebc0bff0a27099e68e6900543a964643e6e5d173f9d3feedaadfc1194609ae5a81b5291da28c17a319987750f5f82b8aa1282b94262f2a4530b6fee9647a38e5c9c9f7cd7f3105c714892824b3821326b4e7562995467757e740025e00d0b1f8daca5c0335787df935f177bf0924e7ea3d94e88a1e674cb68ca13c0ddba3f6dd4e1d47f017da618558aacad42f473ff6e1b2347c56f339f9c2313cefeb4610e2fbfc50c3307d42ca07861bc5ca9309e5eaecd96135125d964048da999912ddf3809e7c46c5feb17871acd69d63e7c2a523ab9236c24a6656465d321ef780c22b3cf547cc1497767cab2c29a99d32918cb36a84b32aff9bcb9aabbe1e1bc1bccc274af776a3be1faaf17f7fec32878bdb006c71d04e80ba8cdf14eb416d5bd762d01dc5e09e92dbaedd273d88ffbe4abcca56792423812d098c2a1d525819eddd7f1bd3659f376192d185b549ec473d2d55572472a301924090853fd21fb33eb2a4ef973fcceb5e48894031fc5c9ae42a3bc7ee16f905b61410fe819bcf716016a1590128810a83d6e13d6f522d41e7c10fddc3558fbae34eedf54ad11be712e12459a21a03d5541f98185656fb1c23e579c72055a9a4e85e894ec402c7c1ca6164dfcd4c032c69529f4a55aa780ea24c2dcd2559a66477acfd2742302241cf377cc3ae41d094a2e9e8753ca2f8f756561d52c8c943f02d870e1c024e3cdd9262c29498b5ced6ffd03f155bc862704dd211d73c1e19ed549a10eb94f6ba7352a30e14054f49586037d919534baa22b90b719e5c35172e89b6449edb5be08bc4f97427a8258585d956c073659cc4f9ea6125b57d51adc5f5bae7bab7989115485032c543ec93f00e0366f672e1eaf08339512b531a819c094dd94f6a16c4a6f6c2ad17937fc89ede3f3534eb13ebedee87213e6c54259ff280293d40afdd15b590028831472a40e37cbc7363cb858cd3977184cba86759c94b6fd2b1249933f2ad320d8b0d928257a3889d89531ddf2dff662011ea67d62394cac7711e0dd719b503cb1a1b953c978058192730fa4f0bee6c951738ab30b0825fbb0525fe53c967125d71f2b65fc093f635aef94939605cd2cf9b9fa6159c8a1f9bd750aeb246d4558aca597746ee4151a7911067ef57987b68d74c54e83c62d7747d833403c5717043806e136a797d7a287f40ae4c63ca48b5b12510e4630058313980283c6c941b2fc8c06189ea150c8bf991a1e11b76c2f241272a9cfe103ba84213d9455a844e04de4c729c9c51a1f9da3ec63a808fa5601697ee84abe6682989bf03a5f71417c869975a414657acea86b81a2209a6197a9cf832a74f0fbeb6019549141bb714afb9f99c898f48c5295314834f08c5b7a5f0957629e4cca5ffb5423e0219d51f1c769a630ebd3d15ba6737bd7d5ea5c17bc3330c82d7e68473b547a9ecfde0cc8edfa2a5f1dca36983a249ce96238c38bb41115ed4afb1c34b1e7617dc7782bad421bf33a9b908b01debcd67fe874b4260345361f3009c52d16e076f50cceb54f170cdcdd314704d18a3a77b1076b9ac12a2fc407b488a2a96e4c5ad24445ad500bfbb39a0fb93212f1efc052efbe7d4913a67a54bae366b804922293b853e8048aa9ee0de0c91a0e172b66a60cf35616faeb7eb3f7d284699a2b81eec37b0bf37f74b2033a1360fde5333c38dfb2313fe97003765ed1e87d51d776ea9f6c85e7e986f74cfa9f75bb60bae6c2788609f3d7bda812275c748c593c936f6732cca2291d3e8cacc3aeeef386d5f40559d2d5fe487d6688dea4ac257e7de59d771c8bf92531dcb34cc0e1ac701f198cfacc78dda29dc523cb0b0d8f1593a0423c71fd7c62864c37e16314f697cdf8035e3f1104c03564026a5b2a091d5afe297bfeeef15a452f60b97957d7781bea04a1f1571d6415dc0ab54cd0da4f00601bbd58f026135242f408588c2fa76cb3d6b2383ae0ca4eaf49a20f8d3259c70e28ff770ee368372cee734fb3a4be322bd55c1be93700aba4c0f1a1b932df99782a2169bd2871d26620dfac22c12ec2576bfb0a17ac5193c6214f83d3992c6cc299a0f879f19a04133ef5702c17feac627de002bc2007169bc21ff6929c1089cadefa6058b23aedccc14e0bc56f8ad07ee0acdc79ff5bb6e40082a7be4ba782c8f2f48e35df76477057de6dad5b96bfff9217ccc9146e45be142e88e014d9d60b2dad06eddd68bb6912730ac68e7aca2a3617e9b091966198483beb5792865d31e22d7d4ba6949bbdb68972f2aaaaed15c6ff405a52085971c3363915f046373f132f631a8ae3dc37fedfd55c7d7d3b9af494c3909a285d0a091a1c3e8aca937653bf870857ab66887f54ae00669d1decdb66e9dae8f1144006240b4e97f4a2bef78d41935abdb0f6f00b70fc01b7267fa59b09e2e801c44b86d92ff6e2412b722185aaae09a90309a1c6b765dafc47093b24126802d1f2f086b7f2403f5129e0d25f87344a6cae6171bbf70dcca4906c3e85c6ada966bf766184c4f6a23e69ef52842a77e53adbdbb0cc6b86c535ecc19c17786abdc5848c24b63c2e616fb8db01a4ab1760d470735ed249f3faa7b8702b0edcff03b2e4b21a7cea74c8a9aed900f4953e272061ae393818cd10beb535cb8d6201cee1c45b3689b3bf687e4a3226e38f61a0ef9ee31fc1770e99b67e3f092ac407193648c831a5476794da9bf1c16612f97674c5327f988584f504929c6931601657072416dfea9afdbb61147f0f5e8d486265c614410c00ce4772ddf81e9001d746fc1b73f02d222cce1592a718783cf207951d470cf7d7c66405223896a662d6500c041f3f4bf7747199db20ee5fc90ab89a0b2c84910c36c3ffe672309bafe292b2a6e36c93aeb59e78e697f9a0900ed9e8a20a471a123322c09ab4692da0bc4fa84919fba72937af7a04025cb2a74260c6995a1651039938dd51dcdd5ac8f78f3c40ba3be0602bd8487be0563acd1a0c73c1ba2d23f21737d8b85d710ef023c556a0bbff17544bc01860f4406ff46a5da9be191a0ba70c733d411500e407509cb642f7fefe2ad10b05b863f4fa39ff589b834f6edd003d9d4ce57fda3bfd0158103afc5c5d40fc80f073641e8c17c02e3acb20894a925c2348ff1e2e6407c9c586b87be43739c1fd91317413b12c1dc57def148f99d6d8f27c47e626bf81c0d9186182336823262de356619f1db3271f1953cfa5357499ce854ec290b5c3213ccf095effc45508aba7c42b1ce93d4db7d74d864038fb867c2c464012b128c2bbb59c32d0daca3a5237e001afc5ea3198648c5e46cf23920597e94220c77aa5e9457ec32fb1345ffde6b7f1288199573feb49538e97fbc5efe67a306132660de1349e6c9ed052ef7dac3914a3b93a619a78ddb41d004cdce91d275364c8cabbd4b00be6db0e99d6131136214bafc4bbd5258dab0e8626ca1f504c4c7d02997738a01cbd7f2119264db2e93a3f06d575fdc243cb05ea3426ae09d987bb9f34d870018326cc717d4dcf2a35b04f3f58ac368c4f80644f245b4cad2dcfd82fbbed09c1a4b0e7f97b4365d021384a608a3a0591aa26ed0d9a81cf40ecd15c525262815f195c8cae2025974793f518757ed454dba489311a1eb9323c9420029ecae49399d7702fafbc90be7d929a8476e82bd4ed5a92cf391390deb6dc5cb1e1a87f28125d8783f1019b7e7f1b84bc0d2d527d87117073408c5877a20a2f6c09ac68f708c6351adfa64f720de6970740dba3d613a987be15bc129d39560f861a9d84c92861b7ed0249eb699610b1a2e97a741822fbed4fd6f2bbac20cc01c75b311e2f6287c91ca81bec19337d2ca563f7ebfc45a87c4a9f3018890b852b7bd6739fcc6ceab08daaf1dacd64912c5327c013abc023d331a5b9be728b1df678ca95ab00326e92210eda4da325b2ead56ded9dd4a61f9b225426bf7526a3b4dec8ccb846c20ee0ccd0e0dfcb2a0809b64070abcd0d6e8fa32705d9466338b3c6891f5cbb51ee764b8161aa24dd35a22737d238a3689eb98e75634fc440393fa75a9abca1016eb06d82f12760db741ad43304bd854c335b22a6f3d10ecc7774dca08be8a3861d0824838e1f9e44f5eba6fd117847fe25f0f5086939c2739b3752cda102c66e1a1cfb17985a8f4ed5af6972689fc87026cee750cc7602e0c3f9deb55a6c7079a85ca718e02b0e4be1944f6856fa455ebd9a1a1a54733587a4b84368278b3c909ae3e1156143757f4ac14b45c17d1208560f6640c5ba235db126153726c4b74e1fc7475537cd862677a28da4a18da2f00ecd8bbd75796e227484c16acf6c5d52e3e39efe5fb9cac42542aa0fdc7be56ef2e04382858cc93f54d1b0385eda5179042f39c091fcbe9fa7df43e32d6ea6ceb8ac4fcb9273de3608293bf3ce17174397e7dce6ee0ec9579ff31ee0086bb4c653130ab50e51f2c2085ecc03d2d4f6dd8ce486d4791beec87fb3f89e16a0b05faeed883a7f3d4713d9a95f3d3203025861b4b086ceaeddd5ff529ade78a5f1ed71fc6c43eb178899c1a892fb6ef8f40372fda04663e1e41e44e8f413d864791d51ed2987a22f1c98c610e55c4f10be9a09de6b8fe318b511963597e0636ed9d56f3e7e68c5c2a864658d2c7f3553d40ec38a740247c61bab4fa1b88545fa93f5c6cdef18efd3a190ffd00950000fa4340cf9b83254f20d8f94a2aa9acf2d97675efe0a9e5246c782f9e491eda5757682418469182611cdf779811ae20b8d2578bb8f0937b7d6dbda9b709962b0e22a19e112eaf4c59e1ceeb0361e2bf439c7569591415ab5a5cc5083ba75eb6e1e3e59a90bd71ae0c3afec87f6b849482a1ba26786686d835c818c241d18160678766928e91097b33a7e56649fe177435204f3b291e2b53efa69260ca7f517bd5545f923abdb8da66864cd8f397b2aa9ad2005f159c135784f762e614bd742d2a506fa144c66b5abb809fc8dc5366f355ca3d09e917f3d0a1c378382b9d1556feba666bf8b200374f8eac3ee5f9f4d32c1e46d8d07290c68fb6344a5440ee8c7f6950a7f0ef9d3ec00dc6fd1ec06272866765bb226601ec2b518f63059fbae07622cc9df2610f7dd37c9170ae321f9d3aa99d808b7ad26b3a97148651e9192a0f47491e57e579a5cdbad56101f590e78a7efa1017af4c92aaec2e709e1ea327635926eb81cc378f4300a95e6310232b063ac102bfc572eed9bdfc797c33831d16fc10520ae25d664ddf5ecaf6fed271c43b9fd2b5d665db9fb9a4975581d9eda2be75c1170b5ceb9085341aa16194d2e36b7138c20ed8545cde74953f2fea7a971af53f2c2e66cf573c22cfd38f6d7f4bf032056b6f6893b0ae9d80c3b8c8942dd41a6d6b43d7e65cfb787eeeae9f2856511658f2eed6bad3c395344a3c8fa84dc5fd7df7c4e66662330339e73a2e3034044bf7efca2f71fc8d479f8ab0c8c465b8993893a6f311b1301612995f759563fbc0831fd3d37d39387f132e692cf2f485cd74a1fc091a5f33fb1138c6986168955408a9612d20d27e247a0776fe18dd5a9e7122df278471252e81a5f39ec5bb6caf5915919271a2adfa63dab7147272418414a57b432e4abb7fec6519abf7f080daf54d500d879b5f40688070b23db0cf7a4bca4120aa4370ef71a09731ecf5ed2304d9455e5393907694eacf3e0a4b6bdb7395c1e0f56595d4383644a48c3432dbdb04dc40acdc2beba41e161011adf601c26f1c47e9a251d32b80c724cb6c0d1702e909236e15633cbabc554f1c50a1ec2737f5776b2ebe6261bc092f2004b535a32b8bc2b0a21110fb0a5310a9b4ad5378679edafc304d2bb00daaf55e0f6316ecc0da45feedc59c58dc47a22c547b6bb26edd0dfb2b82ad8f96fee3c451f87e349317aad4419c07139a065d5af111cd1acb7a801707355ad5075e99d2c06e32d762643cfab62d6e0484f7f8a958e7ed8a79656c2e88a042d04ad88ba216d202fe6fd7d003dfd5ca325fe0dc7e93f87c587c18537132ae5fb07ba6ef467ebccb530843ce9ec6e9c2712a2b6718c4ddedf69a888b8a570db6ee6391c3fb752a8c36226e25dc340eb1053b9ecc9cee8e30a84ac4a926a3430b8ca763cb9083110913a58e10eca4259ddd153496c43b792a57795383345f087ab3534ad2d1633f7c369bca5f5c9cb529bd916d28fd0c965f3bec20746137ac49db791544086d6b1f83123b37992ee64cd85351d3f1397ecd00bdb2ece6d25b643cad3d1c3ded50514dc22a8a39b17425ac4d50f5a195c84159c3bd55001d854da3d46b1242f9127f1c2d3319f3ecdd45b01361d21ae34f98fd78362dc20938fc31c8bfb2cc34fa612b3f82c32ce211049b29323c885063160a8f8cb04d2f2cb10dfcaa272a53bc8bd78c9362eb7ba39fe1b556e27cc201d1504df3a1559a0fdd3a987d525dd36b8149fce21616c2edb82a7aec8a3f56dc03dfb8e6a3e03f793e750dcdeec18a7d60c76598c35ea1728c85835a01d71d84ad6c14a072a3871f74bf2bf4e15bb7f70b82b73ffcacdaff2157e38ce7cbaf2d17999acf2fc512e6a8a7b74e41354356762f7bc5388026fe499a10f84cf14d6d5128b5f8abbd0c73c1479714a389f8b73d15d5cd157a290b507b22bf23ebdfee95b1ab09d568231ed6d1efe5e99f6f0e7aa42a96c6a47de8b8091d7ff3c9d0e4019f841e032af034c440bf940f7f5742700c5478f68836f8f5b626eb7fec2d20a28bc05a723e3daeffa45f8210ba4494e1e6e4a6365ec7243aa24bdf12cd5bb2af69cb394464df9da03a6cb7f020e3e223d02734102db502e29ddc5f322890eabea9ac36075399f75c2dff363c5a9c095ca537e674b3a43a173f021e979a449f75acbf9e8b25d33c382dc937ace3cdf5c2bab7bd25c6c7d802532206e7480c276a4400ee39e42c2dc1388d3d65b3dacae0f014734b266d67496c284b4562e1e76e317c666800ef917eb8b76179a781cdf791b1715c2e9a08b741dc33793a7db99d06841843a6f546a833835425c487a6d5bde892ad788075f211ec129e02a92ffa0b764634a4d2e03d0b9abdc73f61b10f3f9cd15c4311d17ef6ec54e67e9280a0569983f24e83eb48f57b6640b1c68d30d5d7c051b79edb81e47d308fd9e5c763812743cf92fcae8b9408d141745c187fe5fae6244f6e72ba6c78b50c9b4f888c0e5fe920a1649e42a8ec1a14c408a45ae269287a7f1e4d688cadc7b05ae3a86c75cee5d4bb90cbd2608a0ed7ae0ae107ae77c233d52bb8ce105efdc73cb31fbdb933034af19c26de3097efc6eaacddb2be0777cdaccc0fbddd6b81e34d51838836357ae0aac0c4a84d4daab3b27239aa27dbc4dfd49223edf8f45f5a7ef86c308d0d8e54f30498d66a552645a568607fbf41cab51a32c441ef8d01569a4da236cf1d7e6b6d78aad3f5563239c93e4ea6d9056bc136b823a69b3bd1eadea7af9dce98b07fba2cb0f7a15665c7bc1a6523d7ae319aaf8f61a0a2ee55d4d809813da3d2f6e97185873dc7204325137bfdb08170c0fb414b4bccefc99332a209fbe8083f4c7e77534d071a79f3cfb1fb2c2ae7eab022a8c95ec4b5ddb6582a9c85dfc20201192342fc2438e9c283246830c40a500e95e1713de91d82514061b16b97e65c626caadd31b4bf35c82252d83f99697fcbf74061a16382b5cb276129cfca2aa09edaffe24f268c96f4f08aff313496dc9bc91054c42c020a5a3a1c300203bfd398b5b08e0517e0ed65a69beac1e0f50cdd68493c17478ba879f1b7f3665629c4bdb4d6575b37288646c5ad5cc814fefc4efbc61a2f7b17ea3f8c669189af3fb57baf524c3bfad2330bf083b8b14cc6b1dc7f10914a512c95287775adc7db9d34cebd3fd8aa22b7bb360a41e9d5c5b837d95f4a1458ae089b3da4b1f14454d7c440d8683ce119f3bde5ec4e14e28405b68cc5f0b21f6c764c5de6bbd1b2a0ce940ef806abb52dae6d844736922f78037e25d35e53a1324c1b204ce737453252728cca9ee1843d612257409489f5b7073d05ea1ac1a1998b84c22d429514fd7b9195d817999fe2e3889f2156885f85818dbae57013d09605a254eb07c01ac4305308d4dc63","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
