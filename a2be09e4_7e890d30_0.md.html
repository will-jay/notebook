<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34187f1c1f2ff80c0cd40684d8ccc314bafc60d2b7e9c798dcfdf1ebeafad53e70b8138030192b1760cfdc3aad9db9c4d53d83e623d117f82d950dac1b425ee41cdeb6e0ef65a4e6d57330860818f6a2eb136bcb8a3f2c365cffcfb8c127356177b085a4e8ff6d37058765ac070a52dedbfb381cc77ed4dfd9d9b1b1d550490297c09f0dc3ed2dea1596a22c85ce4b2383636cf8071b821f913a2e318c6dfe2a4d3849f99e79a01ccdd2b84d354fa335b79d09c7c170983752772436304c260eaf1a85b2450acdec74c8f5875e897876f8a6a4617be0be93b7f406aa81ab0a785f87a589454c461c732c16eda5b623e375a4338e364063b7ff5f748c8f83e2e092cb2d84e66ac9972f5c66f4e67c5ed26f19341aae8792fbc3b576464659a31c4ee72f208892dca332d7f350e94b1dbae10baa124454f73c5ddd8a2d076b4f6b50dfd8ea23c4de66c0dc7532f82fe04e07eb0d9ed529f8a02681a2c56da16357e0e182ace03c86e89c6d8be550d14bc5c4871a1a15fff9088667b30ee26911386224d3b07de6c3d5b6ef3435ffd8a74ccbbcee1c2deb852c92747c0517ea0211c3d961ee525c53d8b9d16d1220765680be1c14983f3369ede20b54fe10bfa89b8c6fdec0d229cbe425e7169bafba8a361de5ab3265e39f6c4511527ebb7a801b37140068c376a1f0b0e7be48274cbba7e09c782c426c2b1b276c241c5f5451f251136113c46c1d369e7196a27c959bd4f2d6f34ce61702f6a688cd9a0c211c1b6d9123bc57b37f8ed1c60dca1a4b42648346092a0159e10908cc0088cc7352786e27174d7c4556027ef209ebdbf330c4ebcd3dfe010e398370b769c25b1f728e13752fa44caa67f658ea1d765c0ca126e610caa351b95ed56cb3e5954be48c684ce486ab3e74e254d63b20b0a90769b8839cc7e9f326ba3db13ceaa4050a21a26d370d71aa92dab236f02b4db608b644251bf0d14fc031b49318cdc134f552c9025ed864d21937982742cda59f2a371e154937ceeddc9e988ffb40b2f0aba382524f62ec5c603e7d9de7434fcaa94a7252ecd4132ac2883728bb0760076e9ea0b9ebf3b3eabee06b72e50a16c74137dd709c7d4eb8761b316d883a876ee3b7e6a6c2b9d45d341296100390f170f1a245d8f1a020707ea857965e4c81e0aa11cdeb42b44292b17ad79be2027e45f196a0107d0ffc301f2881d87e641886160e1ea282bae345ee9741f2eb1341bb745614d11ebe5229e478f7a8bbc02712ff4205d1eebd8da7579e6f4ce6f069494a11cfaefa53b20ad520bac28efeb281319fbdecb56d16455574bf0a7b2be6214c4f7a5903e933fcc2f34bcfc08feb6a88ae6abe6ebc15657f388f5b9f113b32d3d2368f04eae24047d07185a6b6cf98de612d29461f58e7e0aa783cd36ff534c039988e20044278159c2c1135cdf9e9a43b8d70115d185ae7072530340ce5d0224f5a8041cbdbe83b0d3f0f8f0515dfe811669bb628f32effdaf42efc026a0e15bef80bd5b880d40a38f57e96c3121287897a723c56c36c52a53acdea5a3d06029bdec66aba0589d50611d8d80ac34bb3f56c8aae28998cfc481a7c64207bb3265aeb70703c07cfdf94b70c9f92fc324c1ca1f0554cd165f8e1ad869946ee4d6dbd1899f3564ac1e644cb4f1b60c2d4467e669e4bbe72d6fb6f4a051014a63ab7620f0f1999358febd83fdc289a38b35d5aaa70efb09d39b2810094fb642ec0a1545d3aa8bf417c38648f07526682170468fa2d882832f1bbef6b756e9b8ffa9fdd4dd68dcac1ea1a2d7410aa6ec36408397d82d01a95d077d2162774a76bc6c3fb3fd2279467cb92645daf223ae4e665b905f76089667d1fea9a540b74393e9a681d570db92167501e20481d5cbe3408aae9c17523af0a583ea6cac4991413a0f45f59a260367d9dc03a06c926718402a9be680d9880e5df1213a7d9360f36871fb86377b0152a77c45354d2a24a71a24e12e933e8cdd07c445380958332c40c68cc87d6466ecc0263fa25009365805fd17d4d43cd5eb260ab6813c832a6a7667c1e6d00754317c569afb09aca56943c7f8c4ccb694564300ec0f9095c6c6ee6e5e6ef49b60518cf908e58fb344cce033fcde0420667cb4e543ad1cbedf3bb6ac651f4ef4a03bf6edd1a1069e56ec1e34ec43202ac172b633f6a6f9f2da49b542803ddf277d916c8ef4aa0b56ae6e977e901d469bed172a2f462ff97b9b1decc7eaf300b6c6d94d396ec4bdcfb35ef2fb1658478b4095eddeccea35fcfd3b9735b7f1db11752e9f52a73be3cb9b38204f9c3ee36d8d609570c35042ca4e9b0600dec9040fb8e775041d9c8df413050e7fd010900257fab573aad84dd7e0eaea7da96c4a73eaea4bcf61139442f1aa3c12f634528e4e9eb4e652a80df422fccc8165c87967f240955e6984b4041900d921c6a702f7c686694c0b450a07c0533794caf619b1917b0fdc2c956aee1e3bee87e5e5ce4f14fc158eb605ac970f8856ef956d6beb3020c6fcb984d6563dc50598283f9c884e1be6bd6144ad20ea3c20e655ad693bfd2023c23abb191ea720b375294168a0d904eb8af59c4b9db65122684a8e1f0223595b5721dc5175e5c499db53c371c8b5b5d3e6be37aaf4ce144efd733469a7d8028b3d924265dbd2fc900167ca133977dddbe690d078bae0b0cfc61323e2ae08498b91e04e84a39bcb88a54c354dbbbfe0b6355185432c9543b25b87337e34ae5008abea31de01ec74be27e9e22cff60a9bd668f0fa8adddb7415e56b427d2975063ddede7b4ced8b60cc3a6f8efc5e0cb309b64d6862831f27006885137d633021fb295fe7a06ed5a2ecdf562e93f2c7288a3d174c4c4435dcb06787d04ce0950b0ed9b0288cc21797893282f35e956005493923c2a15e867cd4048462a0da8866ab7a493f73a27476ae60b1a66e9ef0771b108957df80b9de4a7214ff240952b16a84f0b0c9ad14bdbdf976750cc409c9af6a168d9bd0cc81e0c3d6c97df91d29de87b757b6228a63fcb8a8d6966725f019f06411cad12e20884b42cba8a3a94e944502b7bed48acdbde244c34f55e56ed9bfa6fdf665968c75e4fa57272a5d915d3c113b88c2ba9f42b99779eecb880fb5ca802f3040862bd421e52a9a6155bbff537e71b7c2b91c689ed27cc339cc2cdea6b234c68b0f0a135dfa2ac09550288319c6a8dbd2b1bda6eb62f252a97711b34645a19c44248e5cae3bfbc26bac8a40f63d59b34a14dacf95add77ba57f22485ec89c716313ddd28e4dcbbc0a4c4ac6c8491583114b5a101444e084933c82cb99537f5dac6c33c14d8a5dc786bc5b407f80117aeaf7eabfc9ad3f641ddc5b5adbf335466174849a7e1723e83de40695b359601aa3889ecec4d074d3b108324f6d2a60b6687786fd2a321074635f7613f1e1b410d29c669331f9e21f6a24b5cc259779acf78eeb1261ecb5424532d55114be5c9d0b2b341e2551d53aebba949f5b1e85c5db2a93ad2f7044aec83100ea43ac342eee97dde0a236d4e5adb7290a92c01295c031baa1dcc40d64d641889ed033aa9c735c70f9a9db44fe72656c3c138b698e6b5ea04c9deb572d7cf692da0098159d39204f012f1818e045113fbab0d8790fec50dcec2aefd6eaf8947dd06ed584fbf34ddb9fbb10ed7322eb35bb8375539aee2adc1120bc761781b16df6fa37ad00cf56cdbeceac62c95c084b2efcc2fb377f771ef541de35548ca64318be930211224dd46a80abda8db6eb3e1d514311b4240ca2939b2291e14165af4b58a82381420daffb41fc61c996dcbd06ed0cd17671c01aeca78c3cf1cf0baa04ad38682f28b500023b31a23d4adc36d6e6073900ca970e9164f1948631a5a9d920f36e10f273d6c966e582971172367af00a6c5bd3fd0742f0c4d46bc5028963ff0cd721a606a30aabce4a59754c94ef4368eef9aea32cd91e1058986282f786361ecbe729210a40660c8ace53e834125ddbcbd20c2c0dbb60fb0ee6eab74f316dde68c6ab6f5612501a31c95dc50dcb4540523df9d9fe231a75701549c45fff789b07f9c26eb864e9f68988b91bfe41eefeaec803e4a9d689eb8e300c84827ea50f98bebdc42a58639fdd2af2824014437cea05e2089504f08debfa5a773a2d58dc60494a1286d33c53209ffff6ba574065a2189d75e23b27cdc16d69aa2843fb1c80c3f5bf195157f7b7f189c07c5358e520271d285610eeb52fed3c0fe81638955bfa8d443ee181046fef75c0209cded9134eaf893e8ee312415bd3ae9afa22e1fc13ab6683e8242654828e8baddb7419a591d0b4121f685fa1ab1e9a90fb8d10ed8c1dcf745056c653542e7c3a93d3fc26e5f10973eea307d9358d3454e3441208018182b450e72cbd267afb9845d5c0998c2de44702545a65e9e0beb7db91617e1fb6a923b3260f7c06c532ae4f763f0f2610026624459f765af9a4412edacf154bc42cdd35bf3e53ace0670964e2043586ac713422644e4ef4f14f4cc0e53a959c4f8e59e1311ffc6c4029a13bc2fd5f1fe27127cfdeb751dd7783731b659233925b6ae3e744b852075a6734222d971b20b2e42221c825ca58ade6f8ade840a8c56a061fbd90c397a57865a1c6d29750d282f63c3cac493d14bce5cad9655af9e9c03ac9f2c557c00849e665b5786fdc8a93d503a7f9538e5814123509eb93792d778d6f881dd483b2b3c11fb4f560bc4f2edfd16ef82af3c541b5789654d6efb918dd439683966ab3f1d7051d486d3799bec4cbbb81454138a20635441b9d292f3ea9291986c615dc2a6153a194b907e77dd82e6162a6a3d3f4e708bab834f2527f5f01e8b5111b4e0b3a1484fd03d005a086a542d0d9ebd8aa247cc4df6e373f88c6c867e2985013424be3691870b5dd2203c6c4853366c2e62e2c0cb2c267a9185bf8cca86996bdc2ff2f531bf3aea178bc86d95a6b6c09725303f710b27807a1592bfe2311d4deed0e91be16564cfc3e776c0d08d5ad72a8c14ca49bf5ab77ed5cacca6dcbbcf239a431f70c846088f1f321d33d8a85fcd0a0b2d8372ab50748d2b8d933323cc6b6a43fdc7a865828f71da36f0603daa881c1cdf24f9f2dded5280bfecbbda4ef8b85244b2ad45c41728291989af80ee6ccd9f7e00c216d3649c076413cde56a407e77a266b0a5f92c0a58e7bc6aa4d579883bbcc0bac762f62179ff32b6b300801db948b93ecf1b0aef83ce1de02dbe1ca0d87cdfa2e49f4df6b0bc61fe6b7f57c45f92d7abc1b4730b77c910f39f789608c59178bc98504b4cea960a68e139f955c04a1bc341ec5b001af5d3f2de4e7d99e61a407ab5e2622712e1d1cedc8c75cb4c9fbd09e296518c16b5d405cd4e7045e4ebc0c3f534e87d49be93bb7091ee1a127f191c521266cd65f16b1a9d03e5c8050ba0e72ec6ec44d2993e90ae7f7685ac380e0b3b8379d764bd572de19b6fe47e117d9214b993bc79988cfb3172bcbde234e1aca5d58307bd0cbc69bd79bae5c5b8036df2426542764b3c16b499165df87c9900008e4136c3e589a9cfcd42d1cc268549a642b0320d9d601405c5093e6c671bdfe305ab6206602198cb1684912f8cc15cadaeecdd74fe7b022bb18478a754f5bab8b2c1e28b7c2352943d751cc7b2eb3bf759978516155c74fc74c93b4ba128b0cd305ef98587c83544fa08a0e3b625735114f3ae0fd6531b77b8e59b47636385b5c96828a7e55db1834aae026a29a1635674ee0438f2acde2d1e03e2b64c31896589ed3c148c37386002aa0b3e4991b0ad99a73bbb04a38b859104a8184dc3ba141863956c92349530c38c0dbd5796accd8bffa0dc8629155f75a233d1dc6c65787ecc99a5b9448915e4f31012a9da4b012cf770269448b2fbd14cf1ac5be4dfde78c1cfb5747224260fc0304ef2ae0892437644b41dfb84756c88b46b001b3f5829214a9b201594b7de6e133cbcd43647086b0afd4e7ddf0365ed61bc8b9e707de43b519bae46e13ba6ff3e898d969caebd70c70c2b666bb710c4bf08f00d396dcf64339e1310aa92f823ba168f5e5d4c1208b1c32045c205ce92f374ac3b296bcba9c6afffca2c360371f35bd518fc58dc188d914367b4029a8ec115f4004333929fc26d4bb4e20db3995161ab00c45bd4a68dbbc65abacee803aace6403c7e9d10f6925836327db28da3e3ab3061944a0d0b174b52ba083ef21d70c2c2649601a0c0ccd24cbd9015a1c3425d2020cd6e3296a8b8c236331163a658b7d8c5090bc899a2691ab75b2dbca86c8c526b0ac466ed83f1c905f37fdb728bcb43e061a68950246def1eed73a760551256dd336cad61dd923799b63675dd92e9b42e1091ecabe8ee8d680818f5d0a80641de71a75c4751add6e20c4d440ec624a39385e412da6da367a11ae0fdcc30ff4d11809cb4cd38cdb8cc37173439f03b18391faf5b822a7862614042c628fd202e403b60f29e7fe00cecf60807233328d09fedf664f6eae0c7f2cf09a1c0d29ebe16c6596bbdd913d1f158cac9cefafd8d77c732133eaca21b39c75aa2dc8857bb3428d25329f175c507d3224c5bdd64084554825330e77f8a66c4a8e618a652826548ad6e2eb70c7e67b67082bb757012c7d3e325900ea29ff304ce2a742ef0180ccc69c73fe991e2fbc0859a21c677f67497371120479eb2c2ba406e7cce7e143f0ccb7f86705f9a541f00a5ae4956231573f7a7adf19a84940e319d51e2c370c37d773d2a50d24decb1b32a553e87b758931eebbf2f563456f6e34799390f93228ca8dbfecc22327e395e9dade3f9ad4c5ae8a0ecbb477abbc6450ac818b372a33ba687093e9513e1ae74ce94cd54f664546b2a9d21fd3be80cef1b329b8151db1b5a0ee11fee2146df4bc3b796062b1e60e3541db095259286282ba654f349fed4f6caab4901eda312b9c05d0d5c1ddea0b21b5a40b3155c8f2e19e413c42fe4776afc2378919a4e4786ea6cc89fc355a2997f32baf6d5398456410f8f455b94a88a7ae38c7274480a8e624dffe87fd721b8bbe06bce545bfb529d3d13e7097e4ddff1b265a6c8b72f334301044ff2f2839eef2749277bc5595ca91a7fe207e37ea40a0b721d6e84c3a77222748f83a359a048607ded76687aa66cc8b75b3304791791e5817f9d91d368fab44f9068530ba790d9b35cc8f9c9d12cc3dce2b4a1207b2df27f31d31125989c4dc9039a2d679dcaf1b781d38234036ec5790a277405314bcf53370633de2919bec8a224250234fd18eebff06ea726d7a835891cf3ac23d0734117810d1f326bcc7e974643c0296934f91f11da10da67f1fbc0d8002f161f5f968e760e7571016d7ac833a52b323c528b891c2953d4d06ce1d5d8786e515acebd99102218a7b6d315b9434ffd5e362057abf46683319ed429c3b9ecb10cbf7ebc4a07944b0443380aeadd08ce2965e9799b8e7567d0d6b780290dda8c947ea8dd03872420c0ad6140b47c0c4d9b777e6382312a1db338c39805e824d3f43ec69b285999e95c53012481445ef286bee2c2a5bf6b8eba862068a0925e97961be7e708b2500ac49f858dedba1da3056153335baaa86ae68d73af52060ef1f828be053aec28fe25b6526c6f92aeab02a6e468617251bc21f854a64183f40513fdefea1b0f8da661d2c15452702a92e1fb9de7cb19878f308f5e55ffd7bd0a46a7e42faa729e5d9127ebf061d9b855de5e025d373f9dcb08d7059456e6bd7ad7049b5b279829229d0e0ecd996471da799970f96f523548a3dcbd3ad9cc885f453562195a43087ba19c6bfcae0364a7871237828e3a1ac63e64092b951d2aaf31cf43e9c0cc5fe060a99e83e9b1db614215d1c93f49cf8f04f2460b80e6504536805458888880cbb72bc833945b85e065a30b52907f253bd12fc7219427ae378aa3317b8cbf9435d2bd56b7c10e67dc705ea6fba6f2d9704ab076e89f23b98361e39c90c9d3cf75268c199351421be9acdb7cecc1a3c99a4cf7ac08bbdfae5ab60f16df2b41f4022c9223af31c31e89b3f1c637b50c3ac23c9a233f448dc0eef53575c7d1232f89d74d5633e74d6b4a1bd907a52ac666484f3935969d11bd83f4622a24eb2ef1fd3774484c341b5ebf1ff829ed77da25b63b76861eddb79980abb9d09df6190265fb46e7dafeb824e56643cd53eb296fe8b2b6c61fb0db34efb994a6712aa680d72a536edda73e8353cb8e7023a282cf13b004b96ce3254b024b9951506ac5eb72c6119f91a7b38b909171e30b7eee2d9816555360aef0c421b6b06e95e6ee51ad74b198d5281e1da98609bc161d6cd6a9f48017fa2b4ca2cc549c24f65beabcd846544a20fa68a4fc62dca765fb2336374c457270304433d96aa3b19db2fad7690c054437aa7e96503a065a6b4260af7ad6413b116bcc7c860734f3c5ea776dd080436f1454b9e8c4bc011c0a7e7e86c7764af62f8c096e806b0b6be0a99a56956215f5ac1db828fe7f2faa0c0d19ad34f25eb8b835d3e8d77924ffad80ec0db42aca3e17851f0f4af63096c889c80395b11b4fa5da9779cf097c380b59e3ad0c6b281ce451c9391689f1eadef32ef45ffafc5eabe5d3497a37afeb9f428a70e378371d39ccbfb1f86a37d1aeedf4a08287bcef945b4abe50f94735230ea7976535784bce0bab21e73cabdb826485b66250865665bbfad44b256ed68b6da08a2dfd336d0d1d164933351938b666eff1c5a3b15bff586f23d2f1422e5a70e97f74514cc87282c1751a36661d89b345c80a3dfedb93c640d555e9fd8dbd86051b10382d58ca07d6b0de8ca3369019c65648ccdd462aa08e63bea4ac27b65e80c2d3b2fc121f207c2d80edb0b5b0501c84003154e4c854c0d27b8c86c13b9b430e456daeb2a94966084bdbccbd3889a70d9da60cc58b1a84264c77db40637cecaf718f81be85dff00b24d8f96957658211627d9848f39728032e5a84a2f9c1d73cbc862ed9032f221eeb4c40ca8950bf64ed7766917d749c73cbca3d6ed8e98d08b14c7d4c661d1018f6e26e1aed5f35a5a0fade23b65fa544054e79aa5539d400e390988d907ff57c84c23a0841bfcc1b2bf47491a82d24c516f8bba999a821dd91b3cdc93fc56572520a308eb4111dd609bd200667b6f648550f4fba0ef7033741c9e8ee2de21acfdaff2ae12713b1ac2d4386b16ebb40330b53385b383077590bf477380916c90e7820cedaf632508767687e68069d86955c63ead422aacd911b1e512cf1d528c1a65a275c0d05120e7770a25dcde26e4fad43c3270752b0d5e54114a27f60bf1c5c82c66f6b0961b26fbf2146eee9dcdaa2c37503faddfac55eefb4595e1ce048005c03a2521ee490b829a57dcf2f39a85c198078a16bcea7cb80e287a857e2ad1477225866eee8b0dde1e6a4508ca40794ba30fd8715dff6304f34c404f9b6ad9f6251b1986ce23b7190121f9f14bda88079256d64f2fa1f0c2f79ed3bcae2c3e6261a6fac2d695e88d8d3acbfab82fbe0d3abbeaed9b3fb9c32b4fc3bc10f2fead55f112baec0c0514c856dd546d42fef1b8bdb777326446322fee98229d302264ed80b6932b4c645fc6baad2cdacd361265ffb05adefe11d4fa728ca38f148510cb45a72f8115d15969c1aaaa9efe1d327d1a7dfb8c6101d9fc587c184603dcf689a906665ed2b901170cd202f22677a9d38765ec3523b3b6a8c5e975a78947ec8bbe13fe35bab55ce264bec56d64d7fb4aeeeeac0971b8f9dff9899146526cbd1651ef8ddee56c6dfcf2c22957d4f4ec500978019d3c517d7ca5cb9fa5b16022e8a1f9e0ec6d55070c55ecbc7aa1a01d1f7c9bf7f20f7f649bdff304e45a5217b88aef3075af5c9976d06b10c97bf843f2b9b96b85e332a0891fa1783f31b223c9fdb692287ac18f178ecb176c0cfb3688624d76f96843afae3c69bbd40a3db0dececa6f4a224cffc698c72ffcbeb5019928b6f136f943eacf2f81f11f6db4554949c64f694a83435d7cf292b0943815b3779b250586b74b22505b5e1a9854c37ba622447004877d8521b0a79a2e5b11718bfbba924259c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
