<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa8e45b11f0aa72791a8ff7d773f166cc610fa13a9218799878c7bd8f04ba89212e755400037c60c9b67d1b5640b627c4a8b46e0d1388c460fa855384d727f3c551a39fb755a0f5b30b2938f0cf9b3f1951569c708b0e0fa0dafd23691efb078ef6be8ced4a9fe9b425828bcb530f598bab464cb9aa54f863647d62ed8b1b3af96ffb5d4bb22f3c5215ac94925f5ec45fdec16ef26b54401726d2299157c428234d663e18c6374496bc361b16bdc0789f660ffe78419fdcdf778a9752ce66131663b5bb6c7e99d0f3f4723030daa388da584e81462d1a8db6f3ca2a0af5c703193a22d7f8d263c0aa3ecc84ec3b2ab4eaf5e97cdce8f49a69f493da55fa7a4a951c71997dd326fb2db5c9bc45351e42e0c409a438fa70c85fcfe311a69f83aae47c3092e670a73b70ab588564e5b973bef22e1d06db65c948b667f9e9b3e6727921f8c57b069e3b7c3bf3af38750c181359affe220aadc7132f5868db387af9476d43b7e262bde457445dbe71a05f445afd8370ecf218a893f9952587c918d8539efced251f159e3dc09384862313bb7347c8d0bfdbc6a85ae4a212cbf033613e85898ea29fdb6c81efbe29a260a2b11ae625cd5955d4fbf9fded4419ba7e98133159b24b7dbfc7016557905f7a7ca24265e78a4e3ec1ef0df836241c2ee7188a644ac895bbe665edd3a47ee6700e4b0361e3c0e7f8a33f9c12553507cec25df020d8cdafb8a51f6f4562d855cd7633c29a79ed368d4da65e4fa40e09d7df2a227f7b64b6106ad9bb4da0d199126930c773d29e1213ee3cded509f95267f9d9c57bb499dbb8aa4019d7afe824c32ccb0198aac7ae61fcb8b43e59905a8912d5918345b01a0ec2ef63fc279125a1c2945f9e57457631a8280d4b55f3dcb426788e80176dcdafe2a9b8cd315c86162f94d0e5770dda4b119128c8372fd89c41603ba978f2b526b50d2ab68cdded4fcab3a3baf45eb96c5211dce63928184f7483b14d3ef19554729ea363b57f69d259bcca5720937d4a2837e4da13ab7bc194a400251c62896b8f728146d2fbdc8390f56aa74a290816ade51e60ab721534b3b05fa213a1ecc9ddfbf76ba98b676060bcf3e2f6463b2036df35ca03275cc4f7e8322c7918ecdfcdf2989602bd78759efcc6d26af53137d2ccc4de20b55052834dced4d0adba8cdbe8b4ac6f5e3e6abb973b0ff334d186645e2a322ed0485501413887a85b1a2e4dc0edbad865c574700f44502fc4980c05d4a38c34a8f52835224d85fcc6bfbf9fb3d1343b6b9df5fa435b9c189bd61662668dec890b2581174ab4aca5413646b1ec1d54bd4d9a741f7eb3566196d1ca5f012517459b6af9e8aed080e5209a930f44e7a6dab5d8cc0c1d521519507d1d2ad900ca65ffa759570f5416c993e12a3d13e331df87b766ec07adb341e963cdf01b27563f2dd623ed21a55575169a4a35423cb9dc6efecec95ae2e0bfad1693c65ba6a1914433ad63468af995de50252d70341e1df7a55cfad27d89d4cbd5c73b79e1d830d4761c6da1c3a2ed9b2816c619abdc071b4f50e35c847a18f964128795cb53ff04be859dd543c77b7f6fc2e2f7f5c4a89966e74dee26db1f181ad317e923970d5f6d6eec30506e926ceacb6cc8de7917d40d1cf43f079dc579d8e9c63d583251ebd78771c131a941468eb75e6e7bbb5b76bc3f8112136c15bcd77afb4344b2e8cc167c36b7e8369a9854b3abd6dfdd1a125043cba932a6a6276a17de679a038033fd91c1b5a1bf4ae1a1e10aabc618d8eb08e355b9a04f3916e4fb157bbe6b0ea04394abce868e32678982db7679bb302323ce59386e140127dbea667c0706f36f9a075fa311840839cb2cc6749324d0f05078d96bcbe962d8b03cb2a48c7a3dd7634ac92643157c24df93542cab38299871d5ef4f83207d84379e3a15be76c6de59556209e45bf0ff4a884a8cafdb63c753bf2911a4e18e38d7f2f384d335b69ef08a4905b12be0d7ae2b0d52ab457c1b321f89dfaef3cceca9b1a2d7b93aab426b8bd0b148b566e3f2cb97aa3a560db1798a0548da2b97b2a2a30bc3c37c8060e76143c56dddca4ad644d84ff5161c32fe960620fbd6a4b94be8333feaa3da24353e4652ca372d61662109298efa0a11686cefa705df4a9fb23392167a55b037fafec938faf2d983c06ea5b53e6f7e4aa824c8ed876e92c9fd40cef94c2a80499b9e23be232d66b727275ecd169fd9b1011bcd011d4e0ab63bb36be4ee38485bbc4cc93167fe7111e705e9cfb550cd4e1b6823880d5c30ddfa034c1bee7d7a90d12d99e6be70d6e131af7ab2cbad4b871ba3980b9d4bf45b75214ac2027cc6b8bb59ee14aa9a1e6a08b24d7f0682289d24d2293b22bd4bd5b1402da0e17838369b34f30f393ddcef75029230bdf4813ccdce68460c22c050c6c1d1bb36a6badc44487dce0eedb9858d8b040d9d00a827113ebf5674db0ba0657b4b42119caa3a4f99ef8e74f2433b4778a7175f650edb55100b556bf5c34176caadb896544ff2523696e00950872391ad74b15a56a45ab625a3bfdf3b418ddde6814653731307e324e5543b001a6b5a0271f5acb48a4417bdbebebe5a3fb1b59d32e50256d388ed31a7a3195d6cd52cb6b7295f5184465f5d7c95a06cdd2ed8920b608af554757f0abe375499fcf04694d4a127a36c4845b687403693f63bab2acd2b997c02b115cb5b966ba22723fb6ce1c86bf6b0ae4e328a98c56264e5f36d2943b8f06693c6f52ab5106aef5fd5b779566239d6100c973f00da7b4f47abfe2cf47a1540a66cd6f90d027b667232109dce1340d0d0736ebdc9e16908e35636a5cd41145f83975cb96aaf9d5bb3db3bc980f813e9672e5293b45ffdd8c2db1f1eaf4bcdfda24779dfae3c84dc2e73ac91eda499fa7109448baafad0bcd0e331d87e1fed3639de6f566c540fc6af513c535f02f2c21f59f9d25654d910804cdf4c918a2979a529c56248901708ba25b33056b2f7cd5e0d30991397a647cd71ee8b4152f2449c0bc989027d26f6564b2dcc5a2dee1986faed5c7cf2e2927c47a0cf19f358030268a492d1aba316f0ba250ec7c43a895b15fc432cf2e649742d1b81f2ad9749c553f623b366aba94cb3849c54a973c9af2999e09ff61d94275719ef446eb30de0976c4924ebfedfb6b718a38effb365308bc5e1da4b90b3603d3f2fc37e51b20be3291b98a51ba5447e2ce7c352787341487b7a22fb34884d0ee613a1f2b615a7dd7e52b9c27b546b0f2d71f4d6d4b80aea22a7235fb5e9b2f51565c97d6e072788cc255a37f6f155e2e2711fd7a419e05edae2ea0aa1b51ea2e7dc5b266c53e4ad9dbe0f44424e0ae1f57e18b795b9320e4ebb30541f2bc61c83df51b6547a05452da9a68519b7fcfca7b0f0eb473ff78e688222318a6305e0a4545d0d874d8e6e6397ae113e3e457e21e3230d67fc6b1d1efc7ca986383d23c2bc326ed09466f47b6aaf541fb5a64a6dde577edb92e8fb122f079069c100c35fe69dfc26379225ec2b20fb08cb667e2bdab5e21b19cb62f9a3d5079361c664c8c00964079ed4115ed7a0f5a5aef02b9eabb0902a6fbbd7a4939e9da432872ef9ea5de19c31a54c18b6a39889855f0da1b7b741ce9eebd02776e82c93ed7ec086bf211fba1f133e58cb30ebe0df8de6df2bb5e44c33636db19670a208b3a50d940d116df9c0902debd2c9e121b3c73bbc7a6e40e7a2e866813b0d9af6f174a7f800995d668a923e3d6f2ffcaf13ef7a129d8894eac80c6f57d15c39ecc379e12a31b8f67a15774e5fb56054b096c96fb025f84c188d3576c568e7b4ea26697ab618a3fd5937f92dd522cd6195e2c9020c317f7ce6e16a07cbfcfc979b34d9936e5512cba2518fc5d7181f2ce0f6868f00f14d2da7f626afaa3acf3cdd9a79326042b71a52695d1f975493181866cc08fa9bd66f2bef7e4da33d7eda5f95953e6756f8dfb9426e406627664a27cf6c6b1e4d4e2410c4affba35366637996376bfe43507f7fa9f19ccc23405ba132cb005bb0c93a7289d7e9a7024c9bd8f7ca208b027464716e6febd59adeba79329450df3761b03a83eeb3ce2b0ccd9e4f4d13d434f31252fd33289963ec46a7894382dd702c6895197bc34c318f1f92be5e9abf86ff70fa586a7535e23de0eb54f987dd1ac8eeb9d716319bccc4af48058d827fe3ed3f5fd7fb764c7193910d3ae8c849e7109df5e4678ffb3606218da62ebf1a3c80b1d927d5cd548805ad9c8fa1d939f30c6bd7ac1f77f4eeec5c38cfcc0118d2d9700a3575cd759dced65c589395a8221b849ec6ddebc4d0ede534d491e6eda6d4c6f23786ca4dc1cab814f56496ddb1e40e3f88e66065c1e3d2ccd543a7f9d64beb92f5ca552ffe215778f50dd932c65c7e3b8ec517134a73e994465de8b5b49991e4f085d74f7d223ef8fdd638142ab9722f960e0e478b05b0cd49f56e1d511fa20a28df9d50396b0b639c62ec1df908e3f3527a1d49158a35c8daa7529d26be5059ac2315ea7b095164da700a9917f5cca3a38fa1e3580fb51e30742ebc46aaa3302b2badc58544a304af7784146b1b6841dbe63e11fa8bf88f507f67bee2ef4cc129a485de218169e0f30c9c6ab2f39bcdbb4fb96678b9008aa3ae333adc7770dbc0cf8cfc59e2248f0af0ccac1338fedaf01c72d77826eddc3d171aa8807d97d02c070ecab883991462c5fced2e0a1dbcb1db102e207f5a2d8a9375a46587cab2d09e635dd2c67549030c5b032287ac71febe357e46eb2710a71906adb5773898452f753c657024cfe4e9350e54095012303b5b3d416369a1932bcb396a9721b4d8b37b3485b06964b53a2a4b15c05ac8967bb516f2f22ec5fa3b8322518993ceec5102f0cdbf8892462826c0c9f50fba31f69156ea33639c00e9415dc2a7bd472b15173effa3f7390252792752017f3acd13a49b71d893addf44d3fe0239bffa26a919b0dc3c2f9b6d8a95b3bb8bd03173df358f7cdf2bdc020e24d747361cfa452e84590e3ec6da43c430f84cde398f8a38ae1afef4bffce9dcf3d752eb9410d88c08e92a441cf3eb98d6148396478d5d4a8bc2d81ecbf390108dc34fc9970f36d19a7b6dcbcfacfe7d4fc33cf7eb6980eaef9f6cc9d88dcc6842f36b11ac9db23e9b57b474b6b118ab7c416c4b5f16e9ab1c1d7577e85382a1d689c8543b55c203f18cc47004c0a87b097aca0a0c579c4cbc79cf47a795917fa0e64a61097c62b5b6082d39750c798a6ab9f75423d693ded7200e10d7131f5eacbe2e5ed00f6ecc339656ea0ce10825605e7005edbfc3691bead02fb43246684a6a469003b6688b494848f8d3c917fda0325154177908712d5af3045769326f399865cd899e15bbf96a29974b3c50b4249d092b8d547009cc9e48d534d23dbf6a80cf1a1dcff9c4c43154e94115ff1569d4d29f28030551813741e8da455a7e47e68061644724a06f4b912ce7c928e2285f0b159dd8a24540289a6253cbde1ac947fb8f2d43452848d2873a77c80d55f79406f3e713cb4653dbe7962e51d4284e94a0c4214a5016192ad73ff48623a4e1b40faf6f041e49109438fd2af152e994a6d5567103a398876f2290fe3e1ef017a62f44fe14d6044f0e88d7011dc7b6cf1764c08908e321f6fbaf621a32df1a59743369378c4e394c1eb5f61a59b40bb5b285c1488bbd27b2d2fd3ebd56c59213544bb2638754cda27704b78bb18b9fde093cfb2b6afb8b6db2f12a37d640582cb05e266a63e925aff73c8093c35dfbf48afaa1d558abbabb677541dd78a4a661f2bd418c9284bbe369fa14e3630dc905addc52d976f8d88f6fc852f2bb600f151ab1b65a6118e8f2b5eb26e70d215ef827bd96353d448494dad808a059267098ff40319b1011555eedaa09838d7b1eff6cf8dcf6e2ae680c36db9cf28ebc7c46af9396a08f145874ef3a5880246251196f16ca7a9e5b773e5dae730c91b35192af37678f0b3d9e3321e566cbfba4bdf1111c3d309497ff4267b73637f6266063fdb481084e42242e142e8a9594e05daf9e86a0c7a9cb5c7144394167d6b1c94e415d5b514495d612d9e1355cb1708e99afd7f3a3ec48c1e5f15603e9a22b8e7fb9aedecf52a28e342d01e64234426ee3184eab998988049e8c03310176f8617bad67405aaa2f42b176cee0688d8837b7154717255b54ac3254615c27415272243a15825bdf397e400a82fe29298ce180e7e253e6a07e96fdd49e2162dcc18ddb7f525622ff4dcae6161c88b7073da2b58bdeeacae6388a126a5b89737d478d3f3993b4b18eefc0fb89651f548fb53e752b872f6bf431a1a8967833928b25e2a2959d378f2e8210c13adfaf05909fd3146b6257a702f7b918b64bdc2c470e5f3c982c956c66eaabb761172507346e0dc441b2e60cc3dc982e6b01cb74b0b4db313b23d806f91d6ad5147e15ab61b4b2b9510804a9f39dcaebab6b3f79fd4d772325c2769833dee08d643b232277a7213e33b524d87b53d9e5f2b420214a5397d695a69af119d7321d8fca75e5bb931b3c83eaee3ec8c714e63af8ad80862b107499e8d4251b0ddc43c73ef78ea85ff7648eb3df40967729ccd46420ae349a8dd500cb27e1a2ef78b67f3314e433e03c58d1573936582fcebaedf31bc35a0c824367301b2027eb8a52a3ade9c1d33732aabc7c87da463e4ae807e7ee477995d487ae0a2ea1beffd964eb84fc4cc26139b95d47b2e1511036a5b21df466aed2f0b5783efa107e222dc76f6db87484923d07ca93bf5804fbf05b063e50809b2c7e5190ee419a2ae84807054f3aec27f2a752e1d775bf48a303597b8f9c872b5cc8174177c5cbb4e7e53cddc441795a6139edd073058936a02fdc4cacd83f542310ce810ea59880c15f435455a10ae11dd2a5633c5963a35b63e301e62714f8f6dd3944ca2b9fff6f3175cd391f89a32bc12ad19b4bfa5749982407ebe5c20066cf49a2743ead4129b663e3b916e9fe0d37f5b18cfa9b2cb72880ffd8bf07e5bb2b68b8e69b23d1961af5dd849621b6e53e7948e37315ea8fc7001fb200a56faee7bb29716ee92654ec2a40925589af6f6534c235463a2d3e4b3639d5d314c6716d1a5e79ea7b56b8f2f0658fd70ce511f06cc39bfe8b02a6a7a3dc8812ed7edf0fd480e34dfc2b3e04b95a2ac0437371bf7f7aec30afe135b7adfb9875bae532f1aeba0b3a52da6c52cf446e35448b141496ea9cacdddd6482c1ddc92c203cc83dd0c647ffc9de3196aacf506bdb9d9f0d4a8f5659bf2a74657c91d0a2cc49271133ceca5ec7c746530d2025d9ee0d5b578d20800255881f3b85a0e1a487133852e8290b768e237d64e75cab90df35cf2f735ab46704987a3caa438f0705c7c6a429f8a7838ba249db96b626ee1051661aa6fcdeca53f41ddfab5c8871894323a94ae961c0516e8e29b3fbac0ab79213d5151610000c50700e25ff5b7b541e253bc749921c1a232487a2c0bf8b137957ca7226c6a185f4260b3874a1042cf2a118a2cd02f1582b580ab8382fd0991792c439656bdc7ace9e1f244a2be98a78cee56c809bfb671c532ab4cc3f1f8ea68cfcc9ed8372d9124ad02c57b07eb692f7c0fde96f28028f5e8a538c46afcd0751b0e31dd59d65e48473e605a29f6617b001e8831b247ccff657588838838558eda38f3e7143984fe5732bb400ecc5a4b1fb08cb7364919b771d9566a61a98b360e853f5f896e44baeeec6d213e54b0f68bc40247e36c5909395bd6b6a41188645af985d8707dc64892af1ed9b37c10b345e3f2749db109aedf57f9b4a1165af43969cf40a7b89e8697d1b48d8df9556702ce214047c741bfc6f3e4371e961b74e8ea4ff88a561ce579308f829427f85452f4d304c68177b43190950789c5b88aa6db8852654329c2e46a52fedd5aa8134e098158a3611b3b826d3796bb4b22b4829b82e0e9ee50535dd4c61d6d232b23fdca85df4a09e58c4930b4bd495cf78009fd1cb08176f45e3ba73e58417a67d60e1d1bb659d8d3c0a716d9cbf04fed533dcc250694fbfb9268224dd7921b3fa2a5cdacac727fee54456677ae881fd836bd2294fb1af72c6ad63c6af540b1787a7bd65e70443ac4efc6b4c4c3bd798289e30f66f092c194982f7d0518b79cc50de9a97f9382b1f10012a5277af4a7da3cc8557210d9280b220918d2544793258482f41b5c398363f0f0b940faba6c7331c055b29375ce64820f7a8aecd2411fb6bc69f624c56702828334e09eec271e117c3eefc4776405c28f9528f3e0df904360c49b78890ba608770722fd1df79493c9d84704c74699dbb23f6fb6710127d23fd838f64e63d29d5b2c892ad43f5a3548771f6a948e8180f8276624f15a8d2eec9b0478372342d130372aee5298954ae23b42689f84dbdf23f2a1a96023f4191eab3ed4bc62be63b1574d686d71e74b3381bcb6a189aa364e047cc6261ba77c8734b080733e959a6b70f43765933688c3bfc3a8f0fdbe06aeee621d52d1b4d06b8a868a7a57abce58acb59528c9b5f8ae0f2430aa05b898fe344da3bf34a63869368b5f038f2ca598e5b304c8aaac9b0443e549ddc4b82af959c6170447b45078da8f5c2d0df36a8663be71d368eaa054e7ca5dd27e1fe29a682a0a0cdaa5678f916979d16bd1dfd9c56501d9c628596b66d6b14a1c79b9b9fc14949b6595eed87342808749ba0f96424fe67e80642ffb64793885fc894abd988bc4dcae29450b28b8e4690ff940b0ea82e0156224970fbf7db327b4c7671caedbfa0a31982295ca0bddc0db2f2e4ff87e1ad59e5d2cdfd487f4184eeb6a10f924b84b3d0a720c2e4d0643c307c148f546e0964a56088249826474f4bad2a59bbcf5050f1b3789a56f3324fc9a425adc8cd31ee0c97d0e1788a7d3fb9e3af9b119b3350f733cbebd6ccb535d4400ff15dc8ebb1afe22a588515927d2b75146aa90456773f26770d354a1a3be0ede8e32f0f30dc944f74cda5a14627f4729c5989e8b512967bb56ce31202f15c08cdbf7dedca43488a7a4795dde798c6da0dca7279462c6312ca7d164e5c45b33573d9f1c26f1636c0a5e973b3e05a00c7aede71dc54afc773da19ec4a5bd1da0897d8ef005dc462ba5fc3bde011ede0cbf00a25031e19255d94228cd64074002dae0710512210bebb1247b10bee2ec694bc84ac7f1f7d789cacf87d91a54b476f0cbfe355822cb7b799062e1cd6609a0c8f2e10fe84aa8b88472241eb245b0172a478d25ebab65f9030a86c36248302c8df349ead9893cfe886d19cdf7a93072c09be38b28deff0cb85a2bfbd087be9db6e96ce8076e277e3c032b0de70f69a2d7302a07b92e941d500c9de706ceb597fbcfc462ad2bdf118489dbf5a0ba137bc653771c08322d7cb6f13d4150e0a1ed73be24e17adfd5020234b673e95ebf7f751ba5aae43e2ecdf13cfb84724c14ba0492b7316fae82e53455f65a5c32fc800f03f5f3f7e490e7b6cbdef0630c2f2913f0f5157aef6fec7f7c87631c9b69c1b33f1318757395f78eb797741ec8fd1cc956f6f5f13c9a6fd619bf31c26fc239a9a35dc3cf8becabede34eb6d9daa48ceb2962dfce1b82705a3bf2c43da6554bb49139e6e4fe8e409ae443cbb00f2cbdf4ce65839aa3e4645734f561c5d3ae47ef7ceafaa478076787949ed00c7756b8f7fd7171f44d5232a1330e10775cb936e51a20cadd93cf47d5c6593ac63bd0820e9d6fb43e1b79fa114c579412eb017513461b6c855550f52b92ed5d609942d99e3e1ba01b6544617104a4413d71e4f82b95049a7022d322b90d4dd3b44caf89e6ca61250344fa8a8bdfdaf49bc17a66565a066138e63e7133762e45640b52869d3f752591e7972769de66d804e7a81762087ec22bdd9e4edfafdcc9f8c6a5ebb1b7d4364d49abc74b53938440c86ff289756d5c762a506705b2d3971b877dc0589e215762ab9eb014efc662f13e8728306e1de01dec12107049f0fcf9c44215dac4ed679431feddf0eec3399edc2191e162f4999822cef8937b86f01fa54626a3347c40b4e76b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0602be8b5ef40eb597cc5a6318bd000"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
